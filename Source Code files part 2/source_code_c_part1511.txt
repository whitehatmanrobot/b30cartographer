              {
                    DPF_ERR("Driver can't handle 2-factor ARGB scaling");
                    return DDERR_NOALPHAHW;
                }
            }
        }
    }
    // Save any modifications made to values of ARGB scaling factors.
    puod->overlayFX.ddargbScaleFactors = argb;
    return DD_OK;

}  /* checkOverlayAlpha */
#endif

/*
 * checkOverlayEmulation
 */
__inline HRESULT checkOverlayEmulation(
	LPDDRAWI_DIRECTDRAW_GBL pdrv,
	LPDDRAWI_DDRAWSURFACE_LCL this_src_lcl,
	LPDDRAWI_DDRAWSURFACE_LCL this_dest_lcl,
	LPBOOL pemulation )
{
    /*
     * check if emulated or hardware
     */
    if( (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) ||
	(this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
    {
	if( !(pdrv->ddHELCaps.dwCaps & DDCAPS_OVERLAY) )
	{
	    DPF_ERR( "can't emulate overlays" );
	    return DDERR_UNSUPPORTED;
	}
	*pemulation = TRUE;
    }
    /*
     * hardware overlays
     */
    else
    {
	if( !(pdrv->ddCaps.dwCaps & DDCAPS_OVERLAY) )
	{
	    DPF_ERR( "no hardware overlay support" );
	    return DDERR_NOOVERLAYHW;
	}
	*pemulation = FALSE;
    }
    return DD_OK;

} /* checkOverlayEmulation */

#ifdef WIN95
/*
 * WillCauseOverlayArtifacts
 *
 * There is a latency between the time Update overlay is called and all of
 * the kernel mode surfaces structures are updated.  If UpdateOverlay
 * updates the src pointer and an autoflip occurs before the kernel surface
 * data gets updated, it will cause a very visble jump.  This function tries
 * to determine when this is the case so we can work around it by temporarily
 * disabling the video.
 */
BOOL WillCauseOverlayArtifacts( LPDDRAWI_DDRAWSURFACE_LCL this_src_lcl,
		LPDDHAL_UPDATEOVERLAYDATA lpHALData )
{
    if( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE ) &&
        !( lpHALData->dwFlags & DDOVER_HIDE ) &&
        ( ( lpHALData->rSrc.left != this_src_lcl->rcOverlaySrc.left ) ||
        ( lpHALData->rSrc.top != this_src_lcl->rcOverlaySrc.top ) ) )
    {
        return TRUE;
    }
    return FALSE;
}
#endif

/*
 * DD_Surface_UpdateOverlay
 */
HRESULT DDAPI DD_Surface_UpdateOverlay(
		LPDIRECTDRAWSURFACE lpDDSrcSurface,
		LPRECT lpSrcRect,
		LPDIRECTDRAWSURFACE lpDDDestSurface,
		LPRECT lpDestRect,
		DWORD dwFlags,
		LPDDOVERLAYFX lpDDOverlayFX )
{
    DWORD			rc;
    DDHAL_UPDATEOVERLAYDATA	uod;
    LPDDRAWI_DDRAWSURFACE_INT	this_src_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_src_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this_src;
    LPDDRAWI_DDRAWSURFACE_INT	this_dest_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_dest_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this_dest;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    RECT			rsrc;
    RECT			rdest;
    BOOL			emulation;
    DWORD			dest_width;
    DWORD			dest_height;
    DWORD			src_width;
    DWORD			src_height;
    LPDDHALSURFCB_UPDATEOVERLAY uohalfn;
    LPDDHALSURFCB_UPDATEOVERLAY uofn;
    HRESULT			ddrval;
    #ifdef WIN95
        BOOL			bAutoflipDisabled;
    #endif

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_UpdateOverlay");

    /*
     * validate parameters
     */
    TRY
    {
	this_src_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSrcSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_src_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_src_lcl = this_src_int->lpLcl;
	this_src = this_src_lcl->lpGbl;
	if( SURFACE_LOST( this_src_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
	this_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDDestSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_dest_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_dest_lcl = this_dest_int->lpLcl;
	this_dest = this_dest_lcl->lpGbl;
	if( SURFACE_LOST( this_dest_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

        //
        // For now, if either  surface is optimized, quit
        //
        if ((this_src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED) ||
            (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( dwFlags & ~DDOVER_VALID )
	{
	    DPF_ERR( "invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( lpDestRect != NULL )
	{
	    if( !VALID_RECT_PTR( lpDestRect ) )
	    {
		DPF_ERR( "invalid dest rect" );
		LEAVE_DDRAW();
		return DDERR_INVALIDRECT;
	    }
	}

	if( lpSrcRect != NULL )
	{
	    if( !VALID_RECT_PTR( lpSrcRect ) )
	    {
		DPF_ERR( "invalid src rect" );
		LEAVE_DDRAW();
		return DDERR_INVALIDRECT;
	    }
	}
	if( lpDDOverlayFX != NULL )
	{
	    if( !VALID_DDOVERLAYFX_PTR( lpDDOverlayFX ) )
	    {
		DPF_ERR( "invalid overlayfx" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    if( dwFlags & DDOVER_DDFX )
	    {
		DPF_ERR( "DDOVER_DDFX requires valid DDOverlayFX structure" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}

	pdrv_lcl = this_dest_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

	/*
	 * make sure the source surface is an overlay surface
	 */
	if( !(this_src_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) )
	{
	    DPF_ERR( "Source is not an overlay surface" );
	    LEAVE_DDRAW();
	    return DDERR_NOTAOVERLAYSURFACE;
	}

        /*
         * make sure the destination is not an execute buffer
         */
        if( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            DPF_ERR( "Invalid surface type: cannot overlay" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

        /*
         * Make sure that both surfaces belong to the same device.
         */
        if (this_src_lcl->lpSurfMore->lpDD_lcl->lpGbl != this_dest_lcl->lpSurfMore->lpDD_lcl->lpGbl)
        {
            DPF_ERR("Source and Destination surface must belong to the same device");
	    LEAVE_DDRAW();
	    return DDERR_DEVICEDOESNTOWNSURFACE;
        }

	/*
	 * check if emulated or not
	 */
	ddrval = checkOverlayEmulation( pdrv, this_src_lcl, this_dest_lcl, &emulation );
	if( ddrval != DD_OK )
	{
	    LEAVE_DDRAW();
	    return ddrval;
	}
#ifdef TOOMUCHOVERLAYVALIDATION
	/*
	 * check if showing/hiding
	 */
	if( dwFlags & DDOVER_SHOW )
	{
	    if( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE )
	    {
		DPF_ERR( "Overlay already shown" );
		LEAVE_DDRAW();
		return DDERR_GENERIC;
	    }
	}
	else if ( dwFlags & DDOVER_HIDE )
	{
	    if( !(this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE) )
	    {
		DPF_ERR( "Overlay already hidden" );
		LEAVE_DDRAW();
		return DDERR_GENERIC;
	    }
	}
#endif

	/*
	 * set new rectangles if needed
	 */
	if( lpDestRect == NULL )
	{
	    MAKE_SURF_RECT( this_dest, this_dest_lcl, rdest );
	    lpDestRect = &rdest;
	}
	if( lpSrcRect == NULL )
	{
	    MAKE_SURF_RECT( this_src, this_src_lcl, rsrc );
	    lpSrcRect = &rsrc;
	}

	/*
	 * Check if ring 0 interface is overriding what the client
	 * tells us to do
	 */
	#ifdef WIN95
	    if( !( dwFlags & DDOVER_HIDE) )
	    {
	        OverrideOverlay( this_src_int, &dwFlags );
	    }
	#endif

	/*
	 * validate the rectangle dimensions
	 */
	dest_height = lpDestRect->bottom - lpDestRect->top;
	dest_width = lpDestRect->right - lpDestRect->left;
	if( ((int)dest_height <= 0) || ((int)dest_width <= 0) ||
	    ((int)lpDestRect->top < 0) || ((int)lpDestRect->left < 0) ||
	    ((DWORD) lpDestRect->bottom > (DWORD) this_dest->wHeight) ||
	    ((DWORD) lpDestRect->right > (DWORD) this_dest->wWidth) )
	{
	    DPF_ERR( "Invalid destination rect dimensions" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDRECT;
	}

	src_height = lpSrcRect->bottom - lpSrcRect->top;
	src_width = lpSrcRect->right - lpSrcRect->left;
	if( ((int)src_height <= 0) || ((int)src_width <= 0) ||
	    ((int)lpSrcRect->top < 0) || ((int)lpSrcRect->left < 0) ||
	    ((DWORD) lpSrcRect->bottom > (DWORD) this_src->wHeight) ||
	    ((DWORD) lpSrcRect->right > (DWORD) this_src->wWidth) )
	{
	    DPF_ERR( "Invalid source rect dimensions" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDRECT;
	}

	/*
	 * validate alignment
	 */
	if( !emulation )
	{
	    if( pdrv->ddCaps.dwCaps & (DDCAPS_ALIGNBOUNDARYDEST |
					DDCAPS_ALIGNSIZEDEST |
					DDCAPS_ALIGNBOUNDARYSRC |
					DDCAPS_ALIGNSIZESRC) )
	    {
		if( pdrv->ddCaps.dwCaps & DDCAPS_ALIGNBOUNDARYDEST )
		{
		    #if 0
		    /* GEE: I don't believe this code should be here
		     * only test alignment on width on height
		     */
		    if( (lpDestRect->top % pdrv->ddCaps.dwAlignBoundaryDest) != 0 )
		    {
			DPF_ERR( "Destination top is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_YALIGN;
		    }
		    #endif
		    if( (lpDestRect->left % pdrv->ddCaps.dwAlignBoundaryDest) != 0 )
		    {
			DPF_ERR( "Destination left is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_XALIGN;
		    }
		}

		if( pdrv->ddCaps.dwCaps & DDCAPS_ALIGNBOUNDARYSRC )
		{
		    #if 0
		    /* GEE: I don't believe this code should be here
		     * only test alignment on width on height
		     */
		    if( (lpSrcRect->top % pdrv->ddCaps.dwAlignBoundarySrc) != 0 )
		    {
			DPF_ERR( "Source top is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_YALIGN;
		    }
		    #endif
		    if( (lpSrcRect->left % pdrv->ddCaps.dwAlignBoundarySrc) != 0 )
		    {
			DPF_ERR( "Source left is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_XALIGN;
		    }
		}

		if( pdrv->ddCaps.dwCaps & DDCAPS_ALIGNSIZEDEST )
		{
		    if( (dest_width % pdrv->ddCaps.dwAlignSizeDest) != 0 )
		    {
			DPF_ERR( "Destination width is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_XALIGN;
		    }
		    #if 0
		    /* GEE: I don't believe this code should be here
		     * only test alignment for x axis
		     */
		    if( (dest_height % pdrv->ddCaps.dwAlignSizeDest) != 0 )
		    {
			DPF_ERR( "Destination height is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_HEIGHTALIGN;
		    }
		    #endif
		}

		if( pdrv->ddCaps.dwCaps & DDCAPS_ALIGNSIZESRC )
		{
		    if( (src_width % pdrv->ddCaps.dwAlignSizeSrc) != 0 )
		    {
			DPF_ERR( "Source width is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_XALIGN;
		    }
		    #if 0
		    /* GEE: I don't believe this code should be here
		     * only test alignment for x axis
		     */
		    if( (src_height % pdrv->ddCaps.dwAlignSizeSrc) != 0 )
		    {
			DPF_ERR( "Source height is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_HEIGHTALIGN;
		    }
		    #endif
		}
	    }
	}

	/*
	 * validate if stretching
	 */
	if( !( dwFlags & DDOVER_HIDE) )
	{
	    ddrval = checkOverlayStretching( pdrv,
					     dest_height,
					     dest_width,
					     src_height,
					     src_width,
					     this_src_lcl->ddsCaps.dwCaps,
					     emulation );
	    if( ddrval != DD_OK )
	    {
		LEAVE_DDRAW();
		return ddrval;
	    }
	}

	/*
	 * If the surface has recieved data from a video port, we will
	 * set/clear the DDOVER_INTERLEAVED flag accordingly.  This
	 * makes life a little easier on the HAL.
	 */
	if( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT ) &&
	    ( this_src_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_VPORTDATA ) )
	{
	    if( this_src_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_VPORTINTERLEAVED )
	    {
		dwFlags |= DDOVER_INTERLEAVED;
	    }
	    else
	    {
		dwFlags &= ~DDOVER_INTERLEAVED;
	    }
	}

#if 0
	/*
	 * If any kind of alpha blending is requested, make sure the specified
	 * alpha parameters are correct and that the driver supports alpha blending.
	 * If source has alpha channel, this call clears source color-key flags.
	 */
        ddrval = checkOverlayAlpha( pdrv,
				    &dwFlags,
				    this_src_lcl,
				    &uod,
				    lpDDOverlayFX,
				    emulation );
        if( ddrval != DD_OK )
	{
	    LEAVE_DDRAW();
	    return ddrval;
	}
#endif
	/*
	 * any flags at all? if not, blow the whole thing off...
	 */
	uod.overlayFX.dwSize = sizeof( DDOVERLAYFX );
	if( dwFlags & FLAGS_TO_CHECK )
	{
	    ddrval = checkOverlayFlags( pdrv,
					&dwFlags,
					this_src_int,
					this_dest_lcl,
					&uod,
					lpDDOverlayFX,
					emulation );
	    if( ddrval != DD_OK )
	    {
		LEAVE_DDRAW();
		return ddrval;
	    }
	}

	// check for overlay mirroring capability
	if( dwFlags & DDOVER_DDFX )
	{
	    if( lpDDOverlayFX->dwDDFX & DDOVERFX_MIRRORLEFTRIGHT )
	    {
		if( !( pdrv->ddBothCaps.dwFXCaps & DDFXCAPS_OVERLAYMIRRORLEFTRIGHT ) )
		{
		    if( pdrv->ddHELCaps.dwFXCaps & DDFXCAPS_OVERLAYMIRRORLEFTRIGHT )
		    {
			emulation = TRUE;
		    }
		}
	    }
	    if( lpDDOverlayFX->dwDDFX & DDOVERFX_MIRRORUPDOWN )
	    {
		if( !( pdrv->ddBothCaps.dwFXCaps & DDFXCAPS_OVERLAYMIRRORUPDOWN ) )
		{
		    if( pdrv->ddHELCaps.dwFXCaps & DDFXCAPS_OVERLAYMIRRORUPDOWN )
		    {
			emulation = TRUE;
		    }
		}
	    }
	    uod.overlayFX.dwDDFX = lpDDOverlayFX->dwDDFX;
            // deinterlacing is a hint - if not supported by hardware, mask it off
            if ( lpDDOverlayFX->dwDDFX & DDOVERFX_DEINTERLACE )
            {
                if ( !( pdrv->ddCaps.dwFXCaps & DDFXCAPS_OVERLAYDEINTERLACE ) )
                {
                    uod.overlayFX.dwDDFX &= ~DDOVERFX_DEINTERLACE;
                }
            }
	}


	/*
	 * pick fns to use
	 */
	if( emulation )
	{
	    uofn = pdrv_lcl->lpDDCB->HELDDSurface.UpdateOverlay;
	    uohalfn = uofn;
	}
	else
	{
	    uofn = pdrv_lcl->lpDDCB->HALDDSurface.UpdateOverlay;
	    uohalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.UpdateOverlay;
	}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * call the driver
     */
    #ifdef WIN95
        bAutoflipDisabled = FALSE;
    #endif
    if( uohalfn != NULL )
    {
        BOOL    original_visible;

        // Set the visible flag according to the show and hide bits
        // If the HAL call fails, restore the visible bit to its original
        // state.  The HEL uses the DDSCAPS_VISIBLE bit to determine
        // whether or not to display the overlay.
        if( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE )
        {
            original_visible = TRUE;
        }
        else
        {
            original_visible = FALSE;
        }
	if( dwFlags & DDOVER_SHOW )
	{
	    this_src_lcl->ddsCaps.dwCaps |= DDSCAPS_VISIBLE;
	}
	else if ( dwFlags & DDOVER_HIDE )
	{
	    this_src_lcl->ddsCaps.dwCaps &= ~DDSCAPS_VISIBLE;
	}


	uod.UpdateOverlay = uohalfn;
	uod.lpDD = pdrv;
	uod.lpDDSrcSurface = this_src_lcl;
	uod.lpDDDestSurface = this_dest_lcl;
	uod.rDest = *(LPRECTL) lpDestRect;
	uod.rSrc = *(LPRECTL) lpSrcRect;
	uod.dwFlags = dwFlags;
	if( this_src->dwGlobalFlags & DDRAWISURFGBL_SOFTWAREAUTOFLIP )
	{
	    uod.dwFlags &= ~( DDOVER_AUTOFLIP | DDOVER_BOBHARDWARE );
	    #ifdef WIN95
	        if( WillCauseOverlayArtifacts( this_src_lcl, &uod ) )
	        {
		    // Eliminate artifacts by temporarily freezing the video
		    EnableAutoflip( GetVideoPortFromSurface( this_src_int ), FALSE );
		    bAutoflipDisabled = TRUE;
	        }
	    #endif
	}

        /*
         * Don't call the HAL if we're in a DOS box (the busy bit will be set),
         * but we also cant fail or this might cause a regression.
         */
#ifdef WIN95
        if( ( *(pdrv->lpwPDeviceFlags) & BUSY ) &&
            ( pdrv->dwSurfaceLockCount == 0) )      // Don't fail if it's busy due to a lock
        {
            rc = DDHAL_DRIVER_HANDLED;
            uod.ddRVal = DD_OK;
        }
        else
#endif
        {
#ifndef WINNT
            // Hack to work around s3 driver bug: it crushes the dest surface's
            // dwReserved1 with the src pointer!!!
            UINT_PTR dwTemp = uod.lpDDDestSurface->lpGbl->dwReserved1;
#endif
            DOHALCALL( UpdateOverlay, uofn, uod, rc, emulation );
#ifndef WINNT
            // Note the STB video rage 2 driver trashes uod.lpDDDestSurface and
            // uod.lpDDSrcSurface pointers, so we must check the driver name first.
            if (((*(LPWORD)(&pdrv->dd32BitDriverData.szName)) == ((WORD)'S' + (((WORD)'3')<<8))) &&
	        (uod.lpDDDestSurface->lpGbl->dwReserved1 != dwTemp) &&
                (uod.lpDDDestSurface->lpGbl->dwReserved1 == (UINT_PTR)uod.lpDDSrcSurface))
            {
                uod.lpDDDestSurface->lpGbl->dwReserved1 = dwTemp;
            }
#endif
        }

	/*
	 * If it failed due to hardware autoflipping or bobbing interleaved
	 * data using a video port, try again w/o
	 */
	if( ( rc == DDHAL_DRIVER_HANDLED ) &&
	    ( uod.ddRVal != DD_OK ) && ( ( uod.dwFlags & DDOVER_AUTOFLIP ) ||
	    ( uod.dwFlags & DDOVER_BOBHARDWARE ) ) &&
	    CanSoftwareAutoflip( GetVideoPortFromSurface( this_src_int ) ) )
	{
	    uod.dwFlags &= ~( DDOVER_AUTOFLIP | DDOVER_BOBHARDWARE );
	    DOHALCALL( UpdateOverlay, uofn, uod, rc, emulation );
	    if( ( rc == DDHAL_DRIVER_HANDLED ) &&
	    	( uod.ddRVal == DD_OK ) )
	    {
		if( dwFlags & DDOVER_AUTOFLIP )
		{
		    this_src_lcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SOFTWAREAUTOFLIP;
		    RequireSoftwareAutoflip( this_src_int );
		}
		if( dwFlags & DDOVER_BOBHARDWARE )
		{
		    RequireSoftwareBob( this_src_int );
		}
	    }
	}

        // if the HAL call failed, restore the visible bit
        if( ( rc != DDHAL_DRIVER_HANDLED ) || ( uod.ddRVal != DD_OK ) )
        {
            if( original_visible )
            {
	        this_src_lcl->ddsCaps.dwCaps |= DDSCAPS_VISIBLE;
            }
            else
            {
                this_src_lcl->ddsCaps.dwCaps &= ~DDSCAPS_VISIBLE;
            }
        }

	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( uod.ddRVal == DD_OK )
	    {
    		LPDDRAWI_DDRAWSURFACE_INT surf_first;
    		LPDDRAWI_DDRAWSURFACE_INT surf_temp;

		/*
		 * Store this info for later use.  If the surface is part
		 * of a chain, store this data for each of the surfaces in
		 * the chain.
		 */
    		surf_first = surf_temp = this_src_int;
    		do
    		{
                    surf_temp->lpLcl->lOverlayX = uod.rDest.left;
                    surf_temp->lpLcl->lOverlayY = uod.rDest.top;
		    surf_temp->lpLcl->rcOverlayDest.left   = uod.rDest.left;
		    surf_temp->lpLcl->rcOverlayDest.top    = uod.rDest.top;
		    surf_temp->lpLcl->rcOverlayDest.right  = uod.rDest.right;
		    surf_temp->lpLcl->rcOverlayDest.bottom = uod.rDest.bottom;
		    surf_temp->lpLcl->rcOverlaySrc.left   = uod.rSrc.left;
		    surf_temp->lpLcl->rcOverlaySrc.top    = uod.rSrc.top;
		    surf_temp->lpLcl->rcOverlaySrc.right  = uod.rSrc.right;
		    surf_temp->lpLcl->rcOverlaySrc.bottom = uod.rSrc.bottom;
		    surf_temp->lpLcl->lpSurfMore->dwOverlayFlags = dwFlags;
		    if( dwFlags & DDOVER_DDFX )
		    {
			if( surf_temp->lpLcl->lpSurfMore->lpddOverlayFX == NULL )
			{
			    surf_temp->lpLcl->lpSurfMore->lpddOverlayFX =
				(LPDDOVERLAYFX) MemAlloc( sizeof( DDOVERLAYFX ) );
			}
			if( surf_temp->lpLcl->lpSurfMore->lpddOverlayFX != NULL )
			{
			    memcpy( surf_temp->lpLcl->lpSurfMore->lpddOverlayFX,
				lpDDOverlayFX, sizeof( DDOVERLAYFX) );
			}
		    }
		    #ifdef WIN95
		        UpdateKernelSurface( surf_temp->lpLcl );
		    #endif
    		    surf_temp = FindAttachedFlip( surf_temp );
    		} while( ( surf_temp != NULL ) && ( surf_temp->lpLcl != surf_first->lpLcl ) );

		/*
		 * update refcnt if this is a new surface we are overlaying
		 */
		if( this_src_lcl->lpSurfaceOverlaying != this_dest_int )
		{
		    if(this_src_lcl->lpSurfaceOverlaying != NULL)
		    {
			/*
			 * This overlay was previously overlaying another surface.
			 */
			DD_Surface_Release(
			    (LPDIRECTDRAWSURFACE)(this_src_lcl->lpSurfaceOverlaying) );
		    }
		    this_src_lcl->lpSurfaceOverlaying = this_dest_int;

		    /*
		     * addref overlayed surface so that it won't be destroyed until
		     * all surfaces which overlay it are destroyed.
		     */
		    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) this_dest_int );
		}
	    }
	    #ifdef WIN95
	        if( bAutoflipDisabled )
	        {
		    EnableAutoflip( GetVideoPortFromSurface( this_src_int ), TRUE );
	        }
	    #endif
	    LEAVE_DDRAW();
	    return uod.ddRVal;
	}
	#ifdef WIN95
	    if( bAutoflipDisabled )
	    {
	        EnableAutoflip( GetVideoPortFromSurface( this_src_int ), TRUE );
	    }
	#endif
    }
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_Surface_UpdateOverlay */


#undef DPF_MODNAME
#define DPF_MODNAME "GetOverlayPosition"

/*
 * DD_Surface_GetOverlayPosition
 */
HRESULT DDAPI DD_Surface_GetOverlayPosition(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPLONG lplXPos,
		LPLONG lplYPos)
{
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetOverlayPosition");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( !VALID_DWORD_PTR( lplXPos ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*lplXPos = 0;
        if( !VALID_DWORD_PTR( lplYPos ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        *lplYPos = 0;
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
	pdrv = this->lpDD;

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) )
	{
	    DPF_ERR( "Surface is not an overlay surface" );
	    LEAVE_DDRAW();
	    return DDERR_NOTAOVERLAYSURFACE;
	}
	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE) )
	{
	    DPF_ERR( "Overlay surface is not visible" );
	    LEAVE_DDRAW();
	    return DDERR_OVERLAYNOTVISIBLE;
	}

	if( this_lcl->lpSurfaceOverlaying == NULL )
	{
	    DPF_ERR( "Overlay not activated" );
	    LEAVE_DDRAW();
	    return DDERR_NOOVERLAYDEST;
	}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    *lplXPos = this_lcl->lOverlayX;
    *lplYPos = this_lcl->lOverlayY;

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetOverlayPosition */

#undef DPF_MODNAME
#define DPF_MODNAME "SetOverlayPosition"

/*
 * DD_Surface_SetOverlayPosition
 */
HRESULT DDAPI DD_Surface_SetOverlayPosition(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LONG lXPos,
		LONG lYPos)
{
    LPDDRAWI_DIRECTDRAW_LCL		pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL		pdrv;
    LPDDRAWI_DDRAWSURFACE_INT		psurfover_int;
    LPDDRAWI_DDRAWSURFACE_LCL		psurfover_lcl;
    LPDDRAWI_DDRAWSURFACE_INT		this_int;
    LPDDRAWI_DDRAWSURFACE_LCL		this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL		this;
    BOOL				emulation;
    LPDDHALSURFCB_SETOVERLAYPOSITION	sophalfn;
    LPDDHALSURFCB_SETOVERLAYPOSITION	sopfn;
    DDHAL_SETOVERLAYPOSITIONDATA	sopd;
    HRESULT				ddrval;
    DWORD				rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetOverlayPosition");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) )
	{
	    DPF_ERR( "Surface is not an overlay surface" );
	    LEAVE_DDRAW();
	    return DDERR_NOTAOVERLAYSURFACE;
	}

	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE) )
	{
	    DPF_ERR( "Overlay surface is not visible" );
	    LEAVE_DDRAW();
	    return DDERR_OVERLAYNOTVISIBLE;
	}

	psurfover_int = this_lcl->lpSurfaceOverlaying;
	if( psurfover_int == NULL )
	{
	    DPF_ERR( "Overlay not activated" );
	    LEAVE_DDRAW();
	    return DDERR_NOOVERLAYDEST;
	}

	psurfover_lcl = psurfover_int->lpLcl;
	if( (lYPos > (LONG) psurfover_lcl->lpGbl->wHeight -
            (this_lcl->rcOverlayDest.bottom - this_lcl->rcOverlayDest.top)) ||
	    (lXPos > (LONG) psurfover_lcl->lpGbl->wWidth -
            (this_lcl->rcOverlayDest.right - this_lcl->rcOverlayDest.left) ) ||
	    (lYPos < 0) ||
	    (lXPos < 0) )
	{
	    DPF_ERR( "Invalid overlay position" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPOSITION;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * check if emulated or not
     */
    ddrval = checkOverlayEmulation( pdrv, this_lcl, psurfover_lcl, &emulation );
    if( ddrval != DD_OK )
    {
	LEAVE_DDRAW();
	return ddrval;
    }

    /*
     * pick fns to use
     */
    if( emulation )
    {
	sopfn = pdrv_lcl->lpDDCB->HELDDSurface.SetOverlayPosition;
	sophalfn = sopfn;
    }
    else
    {
	sopfn = pdrv_lcl->lpDDCB->HALDDSurface.SetOverlayPosition;
	sophalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.SetOverlayPosition;
    }

    /*
     * call the driver
     */
    if( sophalfn != NULL )
    {
	sopd.SetOverlayPosition = sophalfn;
	sopd.lpDD = pdrv;
	sopd.lpDDSrcSurface = this_lcl;
	sopd.lpDDDestSurface = psurfover_lcl;
	sopd.lXPos = lXPos;
	sopd.lYPos = lYPos;

        /*
         * Don't call the HAL if we're in a DOS box (the busy bit will be set),
         * but we also cant fail or this might cause a regression.
         */
#if WIN95
        if( *(pdrv->lpwPDeviceFlags) & BUSY )
        {
            rc = DDHAL_DRIVER_HANDLED;
            sopd.ddRVal = DD_OK;
        }
        else
#endif
        {
            DOHALCALL( SetOverlayPosition, sopfn, sopd, rc, emulation );
        }

	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    LEAVE_DDRAW();
	    if( sopd.ddRVal == DD_OK )
	    {
		this_lcl->lOverlayX = lXPos;
		this_lcl->lOverlayY = lYPos;
                this_lcl->rcOverlayDest.right =
                    ( this_lcl->rcOverlayDest.right -
                    this_lcl->rcOverlayDest.left ) + lXPos;
                this_lcl->rcOverlayDest.left = lXPos;
                this_lcl->rcOverlayDest.bottom =
                    ( this_lcl->rcOverlayDest.bottom -
                    this_lcl->rcOverlayDest.top ) + lYPos;
                this_lcl->rcOverlayDest.top = lYPos;
	    }
	    return sopd.ddRVal;
	}
    }

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_Surface_SetOverlayPosition */

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateOverlayZOrder"

/*
 * DD_Surface_UpdateOverlayZOrder
 */
HRESULT DDAPI DD_Surface_UpdateOverlayZOrder(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags,
		LPDIRECTDRAWSURFACE lpDDSReference)
{
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_INT	psurf_ref_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_ref_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf_ref;
    LPDBLNODE			pdbnNode;
    LPDBLNODE			pdbnRef;
    DWORD			ddrval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_UpdateOverlayZOrder");

    /*
     * validate parameters
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	pdrv = this->lpDD;

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) )
	{
	    DPF_ERR( "Surface is not an overlay surface" );
	    LEAVE_DDRAW();
	    return DDERR_NOTAOVERLAYSURFACE;
	}

	switch(dwFlags)
	{
	case DDOVERZ_SENDTOFRONT:
	    pdbnNode = &(this_lcl->dbnOverlayNode);
	    // the reference node is the root
	    pdbnRef  = &(this->lpDD->dbnOverlayRoot);
	    // Delete surface from current position
	    pdbnNode->prev->next = pdbnNode->next;
	    pdbnNode->next->prev = pdbnNode->prev;
	    // insert this node after the root node
	    pdbnNode->next = pdbnRef->next;
	    pdbnNode->prev = pdbnRef;
	    pdbnRef->next = pdbnNode;
	    pdbnNode->next->prev = pdbnNode;
	    break;

	case DDOVERZ_SENDTOBACK:
	    pdbnNode = &(this_lcl->dbnOverlayNode);
	    // the reference node is the root
	    pdbnRef = &(this->lpDD->dbnOverlayRoot);
	    // Delete surface from current position
	    pdbnNode->prev->next = pdbnNode->next;
	    pdbnNode->next->prev = pdbnNode->prev;
	    // insert this node before the root node
	    pdbnNode->next = pdbnRef;
	    pdbnNode->prev = pdbnRef->prev;
	    pdbnRef->prev = pdbnNode;
	    pdbnNode->prev->next = pdbnNode;
	    break;

	case DDOVERZ_MOVEFORWARD:
	    pdbnNode = &(this_lcl->dbnOverlayNode);
	    // the reference node is the previous node
	    pdbnRef = pdbnNode->prev;
	    if(pdbnRef != &(this->lpDD->dbnOverlayRoot)) // node already first?
	    {
		// move node forward one position by inserting before ref node
		// Delete surface from current position
		pdbnNode->prev->next = pdbnNode->next;
		pdbnNode->next->prev = pdbnNode->prev;
		// insert this node before the ref node
		pdbnNode->next = pdbnRef;
		pdbnNode->prev = pdbnRef->prev;
		pdbnRef->prev = pdbnNode;
		pdbnNode->prev->next = pdbnNode;
	    }
	    break;

	case DDOVERZ_MOVEBACKWARD:
	    pdbnNode = &(this_lcl->dbnOverlayNode);
	    // the reference node is the next node
	    pdbnRef = pdbnNode->next;
	    if(pdbnRef != &(this->lpDD->dbnOverlayRoot)) // node already last?
	    {
		// move node backward one position by inserting after ref node
		// Delete surface from current position
		pdbnNode->prev->next = pdbnNode->next;
		pdbnNode->next->prev = pdbnNode->prev;
		// insert this node after the reference node
		pdbnNode->next = pdbnRef->next;
		pdbnNode->prev = pdbnRef;
		pdbnRef->next = pdbnNode;
		pdbnNode->next->prev = pdbnNode;
	    }
	    break;

	case DDOVERZ_INSERTINBACKOF:
	case DDOVERZ_INSERTINFRONTOF:
	    psurf_ref_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSReference;
	    if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_ref_int ) )
	    {
		DPF_ERR( "Invalid reference surface ptr" );
		LEAVE_DDRAW();
		return DDERR_INVALIDOBJECT;
	    }
	    psurf_ref_lcl = psurf_ref_int->lpLcl;
	    psurf_ref = psurf_ref_lcl->lpGbl;
	    if( !(psurf_ref_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) )
	    {
		DPF_ERR( "reference surface is not an overlay" );
		LEAVE_DDRAW();
		return DDERR_NOTAOVERLAYSURFACE;
	    }
	    if (this_lcl->lpSurfMore->lpDD_lcl->lpGbl != psurf_ref_lcl->lpSurfMore->lpDD_lcl->lpGbl)
	    {
		DPF_ERR("Surfaces must belong to the same device");
		LEAVE_DDRAW();
		return DDERR_DEVICEDOESNTOWNSURFACE;
	    }

	    // Search for the reference surface in the Z Order list
	    pdbnNode = &(this->lpDD->dbnOverlayRoot); // pdbnNode points to root
	    for(pdbnRef=pdbnNode->next;
		pdbnRef != pdbnNode;
		pdbnRef = pdbnRef->next )
	    {
                if( pdbnRef->object == psurf_ref_lcl )
		{
		    break;
		}
	    }
	    if(pdbnRef == pdbnNode) // didn't find the reference node
	    {
		DPF_ERR( "Reference Surface not in Z Order list" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }

	    pdbnNode = &(this_lcl->dbnOverlayNode); // pdbnNode points to this node
	    // Delete this surface from its current position
	    pdbnNode->prev->next = pdbnNode->next;
	    pdbnNode->next->prev = pdbnNode->prev;
	    if(dwFlags == DDOVERZ_INSERTINFRONTOF)
	    {
		// insert this node before the ref node
		pdbnNode->next = pdbnRef;
		pdbnNode->prev = pdbnRef->prev;
		pdbnRef->prev = pdbnNode;
		pdbnNode->prev->next = pdbnNode;
	    }
	    else
	    {
		// insert this node after the ref node
		pdbnNode->next = pdbnRef->next;
		pdbnNode->prev = pdbnRef;
		pdbnRef->next = pdbnNode;
		pdbnNode->next->prev = pdbnNode;
	    }
	    break;

	default:
	    DPF_ERR( "Invalid dwFlags in UpdateOverlayZOrder" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * If this surface is overlaying an emulated surface, we must notify
     * the HEL that it needs to eventually update the part of the surface
     * touched by this overlay.
     */
    ddrval = DD_OK;
    if( this_lcl->lpSurfaceOverlaying != NULL )
    {
	/*
	 * We have a pointer to the surface being overlayed, check to
	 * see if it is being emulated.
	 */
	if( this_lcl->lpSurfaceOverlaying->lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
	{
	    /*
	     * Mark the destination region of this overlay as dirty.
	     */
	    DD_Surface_AddOverlayDirtyRect(
		(LPDIRECTDRAWSURFACE)(this_lcl->lpSurfaceOverlaying),
		&(this_lcl->rcOverlayDest) );
	}

	/*
	 * If the overlay is on, call down to the HAL
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE )
	{
	    if( ( this_lcl->lpSurfMore->dwOverlayFlags & DDOVER_DDFX ) &&
		( this_lcl->lpSurfMore->lpddOverlayFX != NULL ) )
	    {
		ddrval = DD_Surface_UpdateOverlay(
		    (LPDIRECTDRAWSURFACE) this_int,
		    &(this_lcl->rcOverlaySrc),
		    (LPDIRECTDRAWSURFACE) this_lcl->lpSurfaceOverlaying,
		    &(this_lcl->rcOverlayDest),
		    this_lcl->lpSurfMore->dwOverlayFlags,
		    this_lcl->lpSurfMore->lpddOverlayFX );
	    }
	    else
	    {
		ddrval = DD_Surface_UpdateOverlay(
		    (LPDIRECTDRAWSURFACE) this_int,
		    &(this_lcl->rcOverlaySrc),
		    (LPDIRECTDRAWSURFACE) this_lcl->lpSurfaceOverlaying,
		    &(this_lcl->rcOverlayDest),
		    this_lcl->lpSurfMore->dwOverlayFlags,
		    NULL );
	    }
	}
    }


    LEAVE_DDRAW();
    return ddrval;

} /* DD_Surface_UpdateOverlayZOrder */

#undef DPF_MODNAME
#define DPF_MODNAME "EnumOverlayZOrders"

/*
 * DD_Surface_EnumOverlayZOrders
 */
HRESULT DDAPI DD_Surface_EnumOverlayZOrders(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags,
		LPVOID lpContext,
		LPDDENUMSURFACESCALLBACK lpfnCallback)
{
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDBLNODE			pRoot;
    LPDBLNODE			pdbn;
    DDSURFACEDESC2		ddsd;
    DWORD			rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_EnumOverlayZOrders");

    /*
     * validate parameters
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;

	if( !VALIDEX_CODE_PTR( lpfnCallback ) )
	{
	    DPF_ERR( "Invalid callback routine" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;

	pRoot = &(pdrv->dbnOverlayRoot);	// save address of root node
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    //
    // If the current surface is optimized, quit
    //
    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
        DPF_ERR( "It is an optimized surface" );
        LEAVE_DDRAW();
        return DDERR_ISOPTIMIZEDSURFACE;
    }

    if( dwFlags == DDENUMOVERLAYZ_FRONTTOBACK )
    {
	pdbn = pRoot->next;
	while(pdbn != pRoot)
	{
            LPDIRECTDRAWSURFACE7 intReturned = (LPDIRECTDRAWSURFACE7) pdbn->object_int;

	    FillDDSurfaceDesc2( pdbn->object, &ddsd );
            if (LOWERTHANSURFACE4(this_int))
            {
                ddsd.dwSize = sizeof(DDSURFACEDESC);
	        DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) intReturned, & IID_IDirectDrawSurface, (void**) & intReturned );
            }
	    else if (this_int->lpVtbl == &ddSurface4Callbacks)
            {
	        DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) intReturned, & IID_IDirectDrawSurface4, (void**) & intReturned );
            }
            else
            {
	        DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) intReturned, & IID_IDirectDrawSurface7, (void**) & intReturned );
            }

	    rc = lpfnCallback( (LPDIRECTDRAWSURFACE)intReturned, (LPDDSURFACEDESC) &ddsd, lpContext );
	    if( rc == 0)
	    {
		break;
	    }
	    pdbn = pdbn->next;
	}
    }
    else if( dwFlags == DDENUMOVERLAYZ_BACKTOFRONT )
    {
	pdbn = pRoot->prev;
	while(pdbn != pRoot)
	{
            LPDIRECTDRAWSURFACE7 intReturned = (LPDIRECTDRAWSURFACE7) pdbn->object_int;

	    FillDDSurfaceDesc2( pdbn->object, &ddsd );
            if (LOWERTHANSURFACE4(this_int))
            {
                ddsd.dwSize = sizeof(DDSURFACEDESC);
	        DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) intReturned, & IID_IDirectDrawSurface, (void**) & intReturned );
            }
	    else if (this_int->lpVtbl == &ddSurface4Callbacks)
            {
	        DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) intReturned, & IID_IDirectDrawSurface4, (void**) & intReturned );
            }
            else
            {
	        DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) intReturned, & IID_IDirectDrawSurface7, (void**) & intReturned );
            }

	    rc = lpfnCallback( (LPDIRECTDRAWSURFACE)intReturned, (LPDDSURFACEDESC) &ddsd, lpContext );
	    if( rc == 0)
	    {
		break;
	    }
	    pdbn = pdbn->prev;
	}
    }
    else
    {
	DPF_ERR( "Invalid dwFlags in EnumOverlayZOrders" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_EnumOverlayZOrders */

#undef DPF_MODNAME
#define DPF_MODNAME "AddOverlayDirtyRect"

/*
 * DD_Surface_AddOverlayDirtyRect
 */
HRESULT DDAPI DD_Surface_AddOverlayDirtyRect(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPRECT lpRect )
{
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    DDHAL_UPDATEOVERLAYDATA	uod;
    DWORD			rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_AddOverlayDirtyRect");

    /*
     * validate parameters
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;

        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            DPF_ERR( "Invalid surface type: does not support overlays" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

	if( !VALID_RECT_PTR( lpRect ) )
	{
	    DPF_ERR( "invalid Rect" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	this = this_lcl->lpGbl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;

	/*
	 * make sure rectangle is OK
	 */
	if( (lpRect->left < 0) ||
	    (lpRect->top < 0)  ||
	    (lpRect->left > lpRect->right) ||
	    (lpRect->top > lpRect->bottom) ||
	    (lpRect->bottom > (int) (DWORD) this->wHeight) ||
	    (lpRect->right > (int) (DWORD) this->wWidth) )
	{
	    DPF_ERR( "invalid Rect" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    //
    // If the current surface is optimized, quit
    //
    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
        DPF_ERR( "It is an optimized surface" );
        LEAVE_DDRAW();
        return DDERR_ISOPTIMIZEDSURFACE;
    }

    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
    {
	// If this surface is not emulated, there is nothing to be done.
	LEAVE_DDRAW();
	return DD_OK;
    }
    else
    {
	if( pdrv_lcl->lpDDCB->HELDDSurface.UpdateOverlay == NULL )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}

	uod.overlayFX.dwSize = sizeof( DDOVERLAYFX );
	uod.lpDD = this->lpDD;
	uod.lpDDDestSurface = this_lcl;
	uod.rDest = *(LPRECTL) lpRect;
	uod.lpDDSrcSurface = this_lcl;
	uod.rSrc = *(LPRECTL) lpRect;
	uod.dwFlags = DDOVER_ADDDIRTYRECT;
	rc = pdrv_lcl->lpDDCB->HELDDSurface.UpdateOverlay( &uod );

	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( uod.ddRVal == DD_OK )
	    {
		DPF( 2, "Added dirty rect to surface = %08lx", this );
	    }
	    LEAVE_DDRAW();
	    return uod.ddRVal;
	}
	else
	{
            LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }

} /* DD_Surface_AddOverlayDirtyRect */

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateOverlayDisplay"

/*
 * DD_Surface_UpdateOverlayDisplay
 */
HRESULT DDAPI DD_Surface_UpdateOverlayDisplay(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags )
{
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    DDHAL_UPDATEOVERLAYDATA	uod;
    DWORD			rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_UpdateOverlayDisplay");

    /*
     * validate parameters
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
    	this_lcl = this_int->lpLcl;

	if( dwFlags & ~(DDOVER_REFRESHDIRTYRECTS | DDOVER_REFRESHALL) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	this = this_lcl->lpGbl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;

        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            DPF_ERR( "Invalid surface type: does not support overlays" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
	{
	    // If this surface is not emulated, there is nothing to be done.
	    LEAVE_DDRAW();
	    return DD_OK;
	}

	if( pdrv_lcl->lpDDCB->HELDDSurface.UpdateOverlay == NULL )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}

	uod.overlayFX.dwSize = sizeof( DDOVERLAYFX );
	uod.lpDD = this->lpDD;
	uod.lpDDDestSurface = this_lcl;
	MAKE_SURF_RECT( this, this_lcl, uod.rDest );
	uod.lpDDSrcSurface = this_lcl;
	MAKE_SURF_RECT( this, this_lcl, uod.rSrc );
	uod.dwFlags = dwFlags;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * invoke the HEL
     */
    rc = pdrv_lcl->lpDDCB->HELDDSurface.UpdateOverlay( &uod );

    if( rc == DDHAL_DRIVER_HANDLED )
    {
	if( uod.ddRVal == DD_OK )
	{
	    DPF( 2, "Refreshed overlayed surface = %08lx", this );
	}
	LEAVE_DDRAW();
	return uod.ddRVal;
    }

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_Surface_UpdateOverlayDisplay */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddsckey.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsckey.c
 *  Content:	DirectDraw Surface color key support
 *		SetColorKey, GetColorKey
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   02-feb-95	craige	split out of ddsurf.c
 *   21-feb-95	craige	created CheckColorKey
 *   27-feb-95	craige 	new sync. macros
 *   15-mar-95	craige	HEL work
 *   19-mar-95	craige	use HRESULTs
 *   26-mar-95	craige	support for driver wide colorkey
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-may-95	craige	use driver-level csects only
 *   23-may-95	craige	call HAL for SetColorKey
 *   16-jun-95	craige	new surface structure
 *   25-jun-95	craige	pay attention to DDCKEY_COLORSPACE; allow NULL ckey;
 *   			one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns
 *   01-jul-95	craige	don't allow ckeys for overlays unless supported
 *   03-jul-95	craige	YEEHAW: new driver struct; SEH
 *   09-jul-95	craige	handle the display driver failing setcolorkey
 *   31-jul-95	craige	validate flags
 *   12-aug-95	craige	call HEL SetColorKey when surface is in system memory
 *   09-dec-95  colinmc added execute buffer support
 *   02-jan-96	kylej	handle new interface structs
 *   12-feb-96  colinmc Surface lost flag moved from global to local object
 *   21-apr-96  colinmc Bug 18057: SetColorKey fails set on system surfaces
 *                      if no emulation present
 *   12-mar-97	smac	Bug 1746: Removed redundant checks in SetColorKey
 *   12-mar-97	smac	Bug 1971: Return failure if HAL fails or sometimes
 *			if the HAL doesn't handle the call.
 *
 ***************************************************************************/
#include "ddrawpr.h"

#define DPF_MODNAME "CheckColorKey"

/*
 * CheckColorKey
 *
 * validate that a requested color key is OK
 */
HRESULT CheckColorKey(
		DWORD dwFlags,
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		LPDDCOLORKEY lpDDColorKey,
		DWORD *psflags,
		BOOL halonly,
		BOOL helonly )
{
    DWORD		ckcaps;
    BOOL		fail;
    BOOL		color_space;

    ckcaps = pdrv->ddBothCaps.dwCKeyCaps;
    fail = FALSE;

    *psflags = 0;

    /*
     * check if is a color space or not
     */
    if( lpDDColorKey->dwColorSpaceLowValue != lpDDColorKey->dwColorSpaceHighValue )
    {
	color_space = TRUE;
    }
    else
    {
	color_space = FALSE;
    }

    /*
     * Overlay dest. key
     */
    if( dwFlags & DDCKEY_DESTOVERLAY )
    {
	if( dwFlags & (DDCKEY_DESTBLT|
		       DDCKEY_SRCOVERLAY|
		       DDCKEY_SRCBLT) )
        {
	    DPF_ERR( "Invalid Flags with DESTOVERLAY" );
	    return DDERR_INVALIDPARAMS;
	}

	#if 0
	/*
	 * see if we can do this on a per surface/per driver basis
	 */
	if( !isdriver )
	{
	    if( !(ckcaps & DDCKEYCAPS_SRCOVERLAYPERSURFACE) )
	    {
		if( ckcaps & DDCKEYCAPS_SRCOVERLAYDRIVERWIDE)
		{
		    return DDERR_COLORKEYDRIVERWIDE;
		}
		return DDERR_UNSUPPORTED;
	    }
	}
	else
	{
	    if( !(ckcaps & DDCKEYCAPS_SRCOVERLAYDRIVERWIDE) )
	    {
		return DDERR_UNSUPPORTED;
	    }
	}
	#endif

	/*
	 * can we do this kind of color key?
	 */
	if( !color_space )
	{
	    if( !(ckcaps & DDCKEYCAPS_DESTOVERLAY ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_DESTOVERLAY );
		if( fail )
		{
		    DPF_ERR( "DESTOVERLAY not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}
	else
	{
	    if( !(ckcaps & DDCKEYCAPS_DESTOVERLAYCLRSPACE ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_DESTOVERLAYCLRSPACE );
		if( fail )
		{
		    DPF_ERR( "DESTOVERLAYCOLORSPACE not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}

	/*
	 * is this hardware or software supported?
	 */
	if( halonly )
	{
	    *psflags |= DDRAWISURF_HW_CKEYDESTOVERLAY;
	}
	else if( helonly )
	{
	    *psflags |= DDRAWISURF_SW_CKEYDESTOVERLAY;
	}
    /*
     * Blt dest. key
     */
    }
    else if( dwFlags & DDCKEY_DESTBLT )
    {
	if( dwFlags & (DDCKEY_SRCOVERLAY|
		       DDCKEY_SRCBLT) )
        {
	    DPF_ERR( "Invalid Flags with DESTBLT" );
	    return DDERR_INVALIDPARAMS;
	}

	/*
	 * can we do the requested color key?
	 */
	if( !color_space )
	{
	    if( !(ckcaps & DDCKEYCAPS_DESTBLT ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_DESTBLT );
		if( fail )
		{
		    DPF_ERR( "DESTBLT not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}
	else
	{
	    if( !(ckcaps & DDCKEYCAPS_DESTBLTCLRSPACE ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_DESTBLTCLRSPACE );
		if( fail )
		{
		    DPF_ERR( "DESTBLTCOLORSPACE not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}

	/*
	 * is this hardware or software supported?
	 */
	if( halonly )
	{
	    *psflags |= DDRAWISURF_HW_CKEYDESTBLT;
	}
	else if( helonly )
	{
	    *psflags |= DDRAWISURF_SW_CKEYDESTBLT;
	}
    /*
     * Overlay src. key
     */
    }
    else if( dwFlags & DDCKEY_SRCOVERLAY )
    {
	if( dwFlags & DDCKEY_SRCBLT )
	{
	    DPF_ERR( "Invalid Flags with SRCOVERLAY" );
	    return DDERR_INVALIDPARAMS;
	}

	/*
	 * see if we can do this on a per surface/per driver basis
	 */
	#if 0
	if( !(ckcaps & DDCKEYCAPS_SRCOVERLAYPERSURFACE) )
	{
	    if( ckcaps & DDCKEYCAPS_SRCOVERLAYDRIVERWIDE)
	    {
		return DDERR_COLORKEYDRIVERWIDE;
	    }
	    return DDERR_UNSUPPORTED;
	}
	#endif

	/*
	 * make sure we can do this kind of color key
	 */
	if( !color_space )
	{
	    if( !(ckcaps & DDCKEYCAPS_SRCOVERLAY ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_SRCOVERLAY );
		if( fail )
		{
		    DPF_ERR( "SRCOVERLAY not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}
	else
	{
	    if( !(ckcaps & DDCKEYCAPS_SRCOVERLAYCLRSPACE ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_SRCOVERLAYCLRSPACE );
		if( fail )
		{
		    DPF_ERR( "SRCOVERLAYCOLORSPACE not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}

	/*
	 * is this hardware or software supported?
	 */
	if( halonly )
	{
	    *psflags |= DDRAWISURF_HW_CKEYSRCOVERLAY;
	}
	else if( helonly )
	{
	    *psflags |= DDRAWISURF_SW_CKEYSRCOVERLAY;
	}
    /*
     * Blt src. key
     */
    }
    else if( dwFlags & DDCKEY_SRCBLT )
    {
	/*
	 * can we do the requested color key?
	 */
	if( !color_space )
	{
	    if( !(ckcaps & DDCKEYCAPS_SRCBLT ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_SRCBLT );
		if( fail )
		{
		    DPF_ERR( "SRCBLT not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}
	else
	{
	    if( !(ckcaps & DDCKEYCAPS_SRCBLTCLRSPACE ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_SRCBLTCLRSPACE );
		if( fail )
		{
		    DPF_ERR( "SRCBLTCOLORSPACE not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}

	/*
	 * is this hardware or software supported?
	 */
	if( halonly )
	{
	    *psflags |= DDRAWISURF_HW_CKEYSRCBLT;
	}
	else if( helonly )
	{
	    *psflags |= DDRAWISURF_SW_CKEYSRCBLT;
	}
    /*
     * bad flags
     */
    }
    else
    {
	DPF_ERR( "Invalid Flags" );
	return DDERR_INVALIDPARAMS;
    }
    return DD_OK;

} /* CheckColorKey */

#undef DPF_MODNAME
#define DPF_MODNAME "GetColorKey"

/*
 * DD_Surface_GetColorKey
 *
 * get the color key associated with this surface
 */
HRESULT DDAPI DD_Surface_GetColorKey(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags,
		LPDDCOLORKEY lpDDColorKey )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    DWORD			ckcaps;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetColorKey");

    TRY
    {
	/*
	 * validate parms
	 */
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

        /*
         * We know z-buffers and execute buffers aren't going to have
         * color keys.
         */
        if( this_lcl->ddsCaps.dwCaps & ( DDSCAPS_ZBUFFER | DDSCAPS_EXECUTEBUFFER ) )
        {
            DPF_ERR( "Surface does not have color key" );
            LEAVE_DDRAW();
            return DDERR_NOCOLORKEY;
        }

	if( dwFlags & ~DDCKEY_VALID )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( !VALID_DDCOLORKEY_PTR( lpDDColorKey ) )
	{
	    DPF_ERR( "Invalid colorkey ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	/*
	 * do we even support a color key
	 */
	if( !(this->lpDD->ddCaps.dwCaps & DDCAPS_COLORKEY) &&
	    !(this->lpDD->ddHELCaps.dwCaps & DDCAPS_COLORKEY) )
	{
	    LEAVE_DDRAW();
	    return DDERR_NOCOLORKEYHW;
	}

	ckcaps = this->lpDD->ddCaps.dwCKeyCaps;

	/*
	 * get key for DESTOVERLAY
	 */
	if( dwFlags & DDCKEY_DESTOVERLAY )
	{
	    if( dwFlags & (DDCKEY_DESTBLT|
			   DDCKEY_SRCOVERLAY|
			   DDCKEY_SRCBLT) )
	    {
		DPF_ERR( "Invalid Flags with DESTOVERLAY" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    //ACKACK: destoverlay can be set on non-overlay surfaces!
	    /* GEE: I ramble about this below as well...
	     * seems to me we have an inconsitency here...
	     * I am too tired to see if it is a real bug or just
	     * a weirdness.
	     */
	    #if 0
	    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) )
	    {
		DPF_ERR( "DESTOVERLAY specified for a non-overlay surface" );
		LEAVE_DDRAW();
		return DDERR_INVALIDOBJECT;
	    }
	    #endif
	    #if 0
	    if( !(ckcaps & DDCKEYCAPS_DESTOVERLAYPERSURFACE) )
	    {
		if( ckcaps & DDCKEYCAPS_DESTOVERLAYDRIVERWIDE)
		{
		    LEAVE_DDRAW();
		    return DDERR_COLORKEYDRIVERWIDE;
		}
		LEAVE_DDRAW();
		return DDERR_UNSUPPORTED;
	    }
	    #endif
	    if( !(this_lcl->dwFlags & DDRAWISURF_HASCKEYDESTOVERLAY) )
	    {
		LEAVE_DDRAW();
		return DDERR_NOCOLORKEY;
	    }
	    *lpDDColorKey = this_lcl->ddckCKDestOverlay;
	/*
	 * get key for DESTBLT
	 */
	}
	else if( dwFlags & DDCKEY_DESTBLT )
	{
	    if( dwFlags & (DDCKEY_SRCOVERLAY|
			   DDCKEY_SRCBLT) )
	    {
		DPF_ERR( "Invalid Flags with DESTBLT" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    if( !(this_lcl->dwFlags & DDRAWISURF_HASCKEYDESTBLT) )
	    {
		LEAVE_DDRAW();
		return DDERR_NOCOLORKEY;
	    }
	    *lpDDColorKey = this_lcl->ddckCKDestBlt;
	/*
	 * get key for SRCOVERLAY
	 */
	}
	else if( dwFlags & DDCKEY_SRCOVERLAY )
	{
	    if( dwFlags & DDCKEY_SRCBLT )
	    {
		DPF_ERR( "Invalid Flags with SRCOVERLAY" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) )
	    {
		DPF_ERR( "SRCOVERLAY specified for a non-overlay surface" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    #if 0
	    if( !(ckcaps & DDCKEYCAPS_SRCOVERLAYPERSURFACE) )
	    {
		if( ckcaps & DDCKEYCAPS_SRCOVERLAYDRIVERWIDE)
		{
		    LEAVE_DDRAW();
		    return DDERR_COLORKEYDRIVERWIDE;
		}
		LEAVE_DDRAW();
		return DDERR_UNSUPPORTED;
	    }
	    #endif
	    if( !(this_lcl->dwFlags & DDRAWISURF_HASCKEYSRCOVERLAY) )
	    {
		LEAVE_DDRAW();
		return DDERR_NOCOLORKEY;
	    }
	    *lpDDColorKey = this_lcl->ddckCKSrcOverlay;
	/*
	 * get key for SRCBLT
	 */
	}
	else if( dwFlags & DDCKEY_SRCBLT )
	{
	    if( !(this_lcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) )
	    {
		LEAVE_DDRAW();
		return DDERR_NOCOLORKEY;
	    }
	    *lpDDColorKey = this_lcl->ddckCKSrcBlt;

	}
	else
	{
	    DPF_ERR( "Invalid Flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetColorKey */

/*
 * ChangeToSoftwareColorKey
 */
HRESULT ChangeToSoftwareColorKey(
		LPDDRAWI_DDRAWSURFACE_INT this_int,
		BOOL use_full_lock )
{
    HRESULT	ddrval;

    ddrval = MoveToSystemMemory( this_int, TRUE, use_full_lock );
    if( ddrval != DD_OK )
    {
	return ddrval;
    }
    this_int->lpLcl->dwFlags &= ~DDRAWISURF_HW_CKEYSRCOVERLAY;
    this_int->lpLcl->dwFlags |= DDRAWISURF_SW_CKEYSRCOVERLAY;
    return DD_OK;

} /* ChangeToSoftwareColorKey */

#undef DPF_MODNAME
#define DPF_MODNAME "SetColorKey"

/*
 * DD_Surface_SetColorKey
 *
 * set the color key associated with this surface
 */
HRESULT DDAPI DD_Surface_SetColorKey(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags,
		LPDDCOLORKEY lpDDColorKey )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    HRESULT			ddrval;
    DWORD			sflags = 0;
    BOOL			halonly;
    BOOL			helonly;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDHALSURFCB_SETCOLORKEY	sckhalfn;
    LPDDHALSURFCB_SETCOLORKEY	sckfn;
    DDHAL_SETCOLORKEYDATA	sckd;
    DWORD			rc;
    DDCOLORKEY			ddck;
    DDCOLORKEY			ddckOldSrcBlt;
    DDCOLORKEY			ddckOldDestBlt;
    DDCOLORKEY			ddckOldSrcOverlay;
    DDCOLORKEY			ddckOldDestOverlay;
    DWORD			oldflags;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetColorKey");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

        /*
         * No color keys on z-buffers or execute buffers.
         */
        if( this_lcl->ddsCaps.dwCaps & ( DDSCAPS_ZBUFFER | DDSCAPS_EXECUTEBUFFER ) )
        {
            DPF_ERR( "Invalid surface type: can't set color key" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

        //
        // New interfaces don't let mipmap sublevels have colorkeys
        //
        if ((!LOWERTHANSURFACE7(this_int)) && 
            (this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL))
        {
            DPF_ERR( "Cannot set colorkey for mipmap sublevels" );
            LEAVE_DDRAW();
            return DDERR_NOTONMIPMAPSUBLEVEL;
        }

	if( dwFlags & ~DDCKEY_VALID )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( lpDDColorKey != NULL )
	{
	    if( !VALID_DDCOLORKEY_PTR( lpDDColorKey ) )
	    {
		DPF_ERR( "Invalid colorkey ptr" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}

	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

	helonly = FALSE;
	halonly = FALSE;

	/*
	 * is surface in system memory?
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
	{
	    halonly = FALSE;
	    helonly = TRUE;
	}

	/*
	 * do we even support a color key?
	 */
	if( !(pdrv->ddBothCaps.dwCaps & DDCAPS_COLORKEY) )
        {
            if( pdrv->ddCaps.dwCaps & DDCAPS_COLORKEY )
	    {
		halonly = TRUE;
	    }
	    else if( pdrv->ddHELCaps.dwCaps & DDCAPS_COLORKEY )
	    {
		helonly = TRUE;
	    }
	    else
	    {
		LEAVE_DDRAW();
		return DDERR_UNSUPPORTED;
	    }
	}

	if( helonly && halonly )
	{
            #pragma message( REMIND( "Need to overhaul SetColorKey for DX3!" ) )
            /*
	     * NOTE: This is a temporary fix to keep certain ISVs happy
	     * until we can overhaul SetColorKey completely. The problem
	     * is that we don't look at the drivers S->S, S->V and V->S
	     * caps when deciding whether to call the HEL or the HAL for
	     * color key sets. This is not terminal for most cards as it
	     * will simply mean falling back on the HEL when we shouldn't.
	     * However, for a certain class for cards (those which are
	     * not display drivers) which have no emulation this will
	     * result in SetColorKey failing. To keep them happy we
	     * will just spot this situation and force a HAL call.
	     *
	     * 1) This is a temporary fix.
	     * 2) The H/W must support the same colorkey operations for
	     *    its system memory blits as it does for its video
	     *    memory ones or things will go wrong.
	     */
	    if( ( !( pdrv->ddHELCaps.dwCaps & DDCAPS_COLORKEY ) ) &&
                ( pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM ) )
	    {
	        helonly = FALSE;
	    }
	    else
	    {
	        DPF_ERR( "Not supported in hardware or software!" );
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
	}

	/*
	 * Restore these if a failure occurs
	 */
   	oldflags = this_lcl->dwFlags;
	ddckOldSrcBlt = this_lcl->ddckCKSrcBlt;
	ddckOldDestBlt = this_lcl->ddckCKDestBlt;
	ddckOldSrcOverlay = this_lcl->ddckCKSrcOverlay;
	ddckOldDestOverlay = this_lcl->ddckCKDestOverlay;

	/*
	 * color key specified?
	 */
	if( lpDDColorKey != NULL )
	{
	    /*
	     * check for color space
	     */
	    ddck = *lpDDColorKey;

	    if( !(dwFlags & DDCKEY_COLORSPACE) )
	    {
		ddck.dwColorSpaceHighValue = ddck.dwColorSpaceLowValue;
	    }
	    lpDDColorKey = &ddck;

	    /*
	     * check the color key
	     */
	    ddrval = CheckColorKey( dwFlags, pdrv, lpDDColorKey, &sflags,
				    halonly, helonly );

	    if( ddrval != DD_OK )
	    {
		DPF_ERR( "Failed CheckColorKey" );
		LEAVE_DDRAW();
		return ddrval;
	    }
	}

	/*
	 * Overlay dest. key
	 */
	if( dwFlags & DDCKEY_DESTOVERLAY )
	{
	    if( !(pdrv->ddCaps.dwCaps & DDCAPS_OVERLAY) )
	    {
		DPF_ERR( "Can't do overlays" );
		LEAVE_DDRAW();
		return DDERR_NOOVERLAYHW;
	    }
	    /* GEE: in GetColorKey we say that DestColorKey can
	     * be set for non overlay surfaces.  Here we require
	     * overlay data in order to SetColorKey (DestColorKey)
	     * I understand why this is the case... are their any
	     * implications to HASOVERLAYDATA other than bigger
	     * structure... if not then we are okay?
	     * would it not be more consistent to move DestColorKey
	     * into local surface structure and not have it be part
	     * of the optional data.
	     */
	    if( !(this_lcl->dwFlags & DDRAWISURF_HASOVERLAYDATA) )
	    {
		DPF_ERR( "Invalid surface for overlay color key" );
		LEAVE_DDRAW();
		return DDERR_NOTAOVERLAYSURFACE;
	    }
	    if( lpDDColorKey == NULL )
	    {
		this_lcl->dwFlags &= ~DDRAWISURF_HASCKEYDESTOVERLAY;
	    }
	    else
	    {
		this_lcl->ddckCKDestOverlay = *lpDDColorKey;
		this_lcl->dwFlags |= DDRAWISURF_HASCKEYDESTOVERLAY;
	    }
	/*
	 * Blt dest. key
	 */
	}
	else if( dwFlags & DDCKEY_DESTBLT )
	{
	    if( lpDDColorKey == NULL )
	    {
		this_lcl->dwFlags &= ~DDRAWISURF_HASCKEYDESTBLT;
	    }
	    else
	    {
		this_lcl->ddckCKDestBlt = *lpDDColorKey;
		this_lcl->dwFlags |= DDRAWISURF_HASCKEYDESTBLT;
	    }
	/*
	 * Overlay src. key
	 */
	}
	else if( dwFlags & DDCKEY_SRCOVERLAY )
	{
	    #if 0  // Talisman overlay sprite might not use overlay surface!
	    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) )
	    {
		DPF_ERR( "SRCOVERLAY specified for a non-overlay surface" );
		LEAVE_DDRAW();
		return DDERR_NOTAOVERLAYSURFACE;
	    }
	    #endif
	    if( lpDDColorKey == NULL )
	    {
		this_lcl->dwFlags &= ~DDRAWISURF_HASCKEYSRCOVERLAY;
	    }
	    else
	    {
		this_lcl->ddckCKSrcOverlay = *lpDDColorKey;
		this_lcl->dwFlags |= DDRAWISURF_HASCKEYSRCOVERLAY;
	    }
	/*
	 * Blt src. key
	 */
	}
	else if( dwFlags & DDCKEY_SRCBLT )
	{
	    if( lpDDColorKey == NULL )
	    {
		this_lcl->dwFlags &= ~DDRAWISURF_HASCKEYSRCBLT;
	    }
	    else
	    {
		this_lcl->ddckCKSrcBlt = *lpDDColorKey;
		this_lcl->dwFlags |= DDRAWISURF_HASCKEYSRCBLT;
	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * add in extra flags
     */
    this_lcl->dwFlags |= sflags;

    /*
     * notify the HAL/HEL
     */
    if( helonly )     // Color key valid only in emulation?
    {
        sckfn = pdrv_lcl->lpDDCB->HELDDSurface.SetColorKey;
        sckhalfn = sckfn;
    }
    else
    {
        sckfn = pdrv_lcl->lpDDCB->HALDDSurface.SetColorKey;
        sckhalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.SetColorKey;
    }

    /*
     * This next part is a hack, but it should be safe.  It is legal for
     * them to pass a NULL lpDDColorKey, meaning that they want to stop
     * colorkeying.  The only problem is that there's no way to pass this
     * into the HAL since we always pass them a colorkey structure.
     * Therefore, we will not call the HAL/HEL when this is the case. The
     * only problem w/ this is an overlay surface will need to know this now,
     * so we will call UpdateOverlay in that case.
     */
    if( lpDDColorKey == NULL )
    {
	if( dwFlags & ( DDCKEY_DESTOVERLAY | DDCKEY_SRCOVERLAY ) )
	{
	    if( dwFlags & DDCKEY_DESTOVERLAY )
	    {
		this_lcl->lpSurfMore->dwOverlayFlags &= ~(DDOVER_KEYDEST|DDOVER_KEYDESTOVERRIDE);
	    }
	    else
	    {
		this_lcl->lpSurfMore->dwOverlayFlags &= ~(DDOVER_KEYSRC|DDOVER_KEYSRCOVERRIDE);
	    }
	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE )
	    {
		if( ( this_lcl->lpSurfMore->dwOverlayFlags & DDOVER_DDFX ) &&
		    ( this_lcl->lpSurfMore->lpddOverlayFX != NULL ) )
		{
		    DD_Surface_UpdateOverlay(
			(LPDIRECTDRAWSURFACE) this_int,
			&(this_lcl->rcOverlaySrc),
			(LPDIRECTDRAWSURFACE) this_lcl->lpSurfaceOverlaying,
			&(this_lcl->rcOverlayDest),
			this_lcl->lpSurfMore->dwOverlayFlags,
			this_lcl->lpSurfMore->lpddOverlayFX );
		}
		else
		{
		    DD_Surface_UpdateOverlay(
			(LPDIRECTDRAWSURFACE) this_int,
			&(this_lcl->rcOverlaySrc),
			(LPDIRECTDRAWSURFACE) this_lcl->lpSurfaceOverlaying,
			&(this_lcl->rcOverlayDest),
			this_lcl->lpSurfMore->dwOverlayFlags,
			NULL );
		}
	    }
	}

	LEAVE_DDRAW();
	return DD_OK;
    }

    ddrval = DD_OK;
    if( sckhalfn != NULL )
    {
	sckd.SetColorKey = sckhalfn;
	sckd.lpDD = pdrv;
	sckd.lpDDSurface = this_lcl;
	sckd.ckNew = *lpDDColorKey;
	sckd.dwFlags = dwFlags;
	DOHALCALL( SetColorKey, sckfn, sckd, rc, helonly );
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( sckd.ddRVal != DD_OK )
	    {
		DPF_ERR( "HAL/HEL call failed" );
		ddrval = sckd.ddRVal;
	    }
	}
	else if( rc == DDHAL_DRIVER_NOCKEYHW )
	{
	    if( dwFlags & DDCKEY_SRCBLT )
	    {
		ddrval = ChangeToSoftwareColorKey( this_int, TRUE );
		if( ddrval != DD_OK )
		{
		    DPF_ERR( "hardware resources are out & can't move to system memory" );
		    ddrval = DDERR_NOCOLORKEYHW;
		}
	    }
	    else
	    {
		ddrval = DDERR_UNSUPPORTED;
	    }
	}
    }
    else
    {
	/*
	 * This is really only a problem when setting an overlay colorkey
	 * and the overlay is already coloerkeying; otherwise, the
	 * colorkey is set in the LCL and will be used the next time
	 * the overlay or blt is called.
	 */
	if( dwFlags & DDCKEY_SRCOVERLAY )
	{
	    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE ) &&
	     	( this_lcl->lpSurfMore->dwOverlayFlags &
		( DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE ) ) )
	    {
		ddrval = DDERR_UNSUPPORTED;
	    }
	}

	/*
	 * NOTE: We'd like to do the same for dest overlay, but:
	 * 1) We don't see much usefulness in it since apps probably
	 *    will not be changing the dest colorkey on the fly.
	 * 2) Since dest colorkeying is used a lot, changing the behavior
	 *    might break someone.
	 * smac and jeffno 3/11/97
	 */
    }

    /*
     * Restore old values if a failure occurs
     */
    if( ddrval != DD_OK )
    {
   	this_lcl->dwFlags = oldflags;
	this_lcl->ddckCKSrcBlt = ddckOldSrcBlt;
	this_lcl->ddckCKDestBlt = ddckOldDestBlt;
	this_lcl->ddckCKSrcOverlay = ddckOldSrcOverlay;
	this_lcl->ddckCKDestOverlay = ddckOldDestOverlay;
    }

    LEAVE_DDRAW();
    return ddrval;

} /* DD_Surface_SetColorKey */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddsstrm.c ===
/*========================================================================== 
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsstrm.c
 *  Content: 	DirectDraw surface streaming methods
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   19-jun-95	craige	split out of ddsurf; fleshed out
 *   21-jun-95	craige	added lock/unlock; split out clipping
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *
 ***************************************************************************/
#include "ddrawpr.h"

#if 0
#undef DPF_MODNAME
#define DPF_MODNAME "SetNotificationCallback"

/*
 * DD_Surface_SetNotificationCallback
 */
HRESULT DDAPI DD_SurfaceStreaming_SetNotificationCallback(
		LPDIRECTDRAWSURFACESTREAMING lpDDSurface,
		DWORD dwFlags,
		LPSURFACESTREAMINGCALLBACK lpCallback )
{
    LPDDRAWI_DDRAWSURFACE_GBLSTREAMING	thiss;
    LPDDRAWI_DDRAWSURFACE_LCL		thisx;
    LPDDRAWI_DDRAWSURFACE_GBL		this;
    LPDDRAWI_DIRECTDRAW			pdrv;

    DPF(2,A,"ENTERAPI: DD_SurfaceStreaming_SetNotificationCallback");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    if( lpCallback != NULL )
    {
	if( !VALID_CODE_PTR( lpCallback ) )
	{
	    DPF_ERR( "Invalid Streaming callback ptr" );
	    return DDERR_INVALIDPARAMS;
	}
    }
    thiss = (LPDDRAWI_DDRAWSURFACE_GBLSTREAMING) thisx;
    this = thisx->lpGbl;
    pdrv = this->lpDD;
    ENTER_DDRAW();
    if( SURFACE_LOST( this ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    thiss->lpCallback = lpCallback;

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceStreaming_SetNotificationCallback */

/*
 * DD_SurfaceStreaming_Lock
 *
 * Allows streaming access to a surface.
 */
HRESULT DDAPI DD_SurfaceStreaming_Lock(
		LPDIRECTDRAWSURFACESTREAMING lpDDSurface,
		LPRECT lpDestRect,
		LPDDSURFACEDESC lpDDSurfaceDesc,
		DWORD dwFlagsForNoGoodReason,
		HANDLE hEvent )
{
    LPDDRAWI_DIRECTDRAW		pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    DPF(2,A,"ENTERAPI: DD_SurfaceStreaming_Lock");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    if( SURFACE_LOST( this ) )
    {
	return DDERR_SURFACELOST;
    }
    if( !VALID_DDSURFACEDESC_PTR( lpDDSurfaceDesc ) )
    {
	return DDERR_INVALIDPARAMS;
    }
    pdrv = this->lpDD;
    ENTER_DDRAW();

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceStreaming_Lock */

#undef DPF_MODNAME
#define DPF_MODNAME	"Unlock"

/*
 * DD_SurfaceStreaming_Unlock
 *
 * Done accessing a streaming surface.
 */
HRESULT DDAPI DD_SurfaceStreaming_Unlock(
		LPDIRECTDRAWSURFACESTREAMING lpDDSurface,
		LPVOID lpSurfaceData )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW		pdrv;

    DPF(2,A,"ENTERAPI: DD_SurfaceStreaming_Unlock");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    if( SURFACE_LOST( this ) )
    {
	return DDERR_SURFACELOST;
    }

    /*
     * take driver lock
     */
    pdrv = this->lpDD;
    ENTER_DDRAW();

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceStreaming_Unlock */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddsprite.c ===
/*==========================================================================
 *								
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddsprite.c
 *  Content:	DirectDraw Surface support for sprite display lists:
 *		SetSpriteDisplayList
 *  History:
 *   Date	By	Reason
 *   ====	==	======	
 *  03-nov-97 jvanaken  Original version
 *
 ***************************************************************************/

#include "ddrawpr.h"

// function from ddraw module ddclip.c
extern HRESULT InternalGetClipList(LPDIRECTDRAWCLIPPER,
				   LPRECT,
				   LPRGNDATA,
				   LPDWORD,
				   LPDDRAWI_DIRECTDRAW_GBL);

#define _DDHAL_SetSpriteDisplayList  NULL

/*
 * Masks for distinguishing driver's blit caps from driver's overlay caps.
 */
#define DDFXCAPS_BLTBITS  \
	(DDFXCAPS_BLTALPHA|DDFXCAPS_BLTFILTER|DDFXCAPS_BLTTRANSFORM)

#define DDFXCAPS_OVERLAYBITS  \
	(DDFXCAPS_OVERLAYALPHA|DDFXCAPS_OVERLAYFILTER|DDFXCAPS_OVERLAYTRANSFORM)

#define DDCKEYCAPS_BLTBITS (DDCKEYCAPS_SRCBLT|DDCKEYCAPS_DESTBLT)

#define DDCKEYCAPS_OVERLAYBITS (DDCKEYCAPS_SRCOVERLAY|DDCKEYCAPS_DESTOVERLAY)

#define DDALPHACAPS_BLTBITS  \
	(DDALPHACAPS_BLTSATURATE|DDALPHACAPS_BLTPREMULT|  \
	 DDALPHACAPS_BLTNONPREMULT|DDALPHACAPS_BLTRGBASCALE1F|	\
	 DDALPHACAPS_BLTRGBASCALE2F|DDALPHACAPS_BLTRGBASCALE4F)

#define DDALPHACAPS_OVERLAYBITS  \
	(DDALPHACAPS_OVERLAYSATURATE|DDALPHACAPS_OVERLAYPREMULT|   \
	 DDALPHACAPS_OVERLAYNONPREMULT|DDALPHACAPS_OVERLAYRGBASCALE1F|	 \
	 DDALPHACAPS_OVERLAYRGBASCALE2F|DDALPHACAPS_OVERLAYRGBASCALE4F)

#define DDFILTCAPS_BLTBITS  \
	(DDFILTCAPS_BLTBILINEARFILTER|DDFILTCAPS_BLTBLURFILTER|	  \
	 DDFILTCAPS_BLTFLATFILTER)

#define DDFILTCAPS_OVERLAYBITS  \
	(DDFILTCAPS_OVERLAYBILINEARFILTER|DDFILTCAPS_OVERLAYBLURFILTER|	 \
	 DDFILTCAPS_OVERLAYFLATFILTER)

#define DDTFRMCAPS_BLTBITS  (DDTFRMCAPS_BLTAFFINETRANSFORM)

#define DDTFRMCAPS_OVERLAYBITS  (DDTFRMCAPS_OVERLAYAFFINETRANSFORM)


#undef DPF_MODNAME
#define DPF_MODNAME "SetSpriteDisplayList"

/*
 * Driver capabilities for handling current sprite
 */
typedef struct
{
    // caps for hardware driver
    //DWORD	dwCaps;
    DWORD	dwCKeyCaps;
    DWORD	dwFXCaps;
    DWORD	dwAlphaCaps;
    DWORD	dwFilterCaps;
    DWORD	dwTransformCaps;

    // caps for HEL
    //DWORD	dwHELCaps;
    DWORD	dwHELCKeyCaps;
    DWORD	dwHELFXCaps;
    DWORD	dwHELAlphaCaps;
    DWORD	dwHELFilterCaps;
    DWORD	dwHELTransformCaps;

    // surface caps
    DWORD	dwDestSurfCaps;
    DWORD	dwSrcSurfCaps;

    // minification limit
    DWORD	dwMinifyLimit;
    DWORD	dwHELMinifyLimit;

    BOOL	bNoHAL;   // TRUE disqualifies hardware driver
    BOOL	bNoHEL;   // TRUE disqualifies HEL

    // TRUE=overlay sprite, FALSE=blitted sprite
    BOOL	bOverlay;

} SPRITE_CAPS, *LPSPRITE_CAPS;


/*
 * The master sprite display list consists of some number of sublists.
 * Each sublist contains all the overlay sprites that are displayed
 * within a particular window.  Only the first member of the variable-
 * size sprite[] array appears explicitly in the structure definition
 * below, but dwSize takes into account the ENTIRE sprite[] array.
 * The pRgn member points to the dynamically allocated buffer that
 * contains the clipping region.
 */
typedef struct _SPRITESUBLIST
{
    DWORD dwSize;                    // size of this sublist (in bytes)
    LPDIRECTDRAWSURFACE pPrimary;    // primary surface
    LPDIRECTDRAWCLIPPER pClipper;    // clipper for window (NULL = full screen)
    DWORD dwProcessId;               // process ID (in case pClipper is NULL)
    LPRGNDATA pRgn;                  // pointer to clipping region data
    DWORD dwCount;                   // number of sprites in sublist
    DDSPRITEI sprite[1];  // array of sprites (first member)
} SPRITESUBLIST, *LPSPRITESUBLIST;

/*
 * Buffer used to hold temporary sprite display list passed to driver.
 * Only the first member of the variable-size pSprites[] array appears
 * explicitly in the structure definition below, but the dwSize value
 * takes into account the ENTIRE pSprite[] array.
 */
typedef struct _BUFFER
{
    DWORD dwSize;                            // size of this buffer (in bytes)
    DDHAL_SETSPRITEDISPLAYLISTDATA HalData;  // HAL data for sprite display list
    LPDDSPRITEI pSprite[1]; 	     // array of pointers to sprites
} BUFFER, *LPBUFFER;	

/*
 * Master sprite display list -- Contains copies of the overlay-sprite
 * display lists for all windows that currently display overlay sprites.
 * Only the first member of the variable-size spriteSubList[] array
 * appears explicitly in the structure definition below.  Each sublist
 * contains all the overlay sprites displayed within a particular window.
 */
#define MAXNUMSPRITESUBLISTS (16)

typedef struct _MASTERSPRITELIST
{
    //DWORD dwSize;                    // size of master list (in bytes)
    LPDDRAWI_DIRECTDRAW_GBL pdrv;  // global DDraw object
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;  // primary surface (local object)
    RECT rcPrimary;                    // rectangle = entire primary surface
    DWORD dwFlags;                     // latest caller's DDSSDL_WAIT flag
#ifdef WIN95
    DWORD dwModeCreatedIn;	       // valid only in this video mode
#else
    DISPLAYMODEINFO dmiCreated;        // valid only in this video mode
#endif
    LPBUFFER pBuffer;		       // buffer storage
    DWORD dwNumSubLists;	       // number of sprite sublists
    LPSPRITESUBLIST pSubList[MAXNUMSPRITESUBLISTS];  // array of sublists (fixed size)
} MASTERSPRITELIST, *LPMASTERSPRITELIST;


/*
 * Return the dwFlags member from the DDPIXELFORMAT structure
 * that describes the specified surface's pixel format.
 */
static DWORD getPixelFormatFlags(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    LPDDPIXELFORMAT pDDPF;

    if (surf_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
	// surface contains explicitly defined pixel format
	pDDPF = &surf_lcl->lpGbl->ddpfSurface;
    }
    else
    {
	// surface's pixel format is implicit -- same as primary's
	pDDPF = &surf_lcl->lpSurfMore->lpDD_lcl->lpGbl->vmiData.ddpfDisplay;
    }
    return pDDPF->dwFlags;

}  /* getPixelFormatFlags */


/*
 * Initialize SPRITE_CAPS structure according to whether source and
 * dest surfaces are in system or video (local or nonlocal) memory.
 */
static void initSpriteCaps(LPSPRITE_CAPS pcaps, LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    DDASSERT(pcaps != NULL);

    if (pcaps->bOverlay)
    {
	// Get minification limits for overlays.
	pcaps->dwMinifyLimit = pdrv->lpddMoreCaps->dwOverlayAffineMinifyLimit;
    	pcaps->dwHELMinifyLimit = pdrv->lpddHELMoreCaps->dwOverlayAffineMinifyLimit;
    }
    else
    {
	// Get minification limits for blits.
	pcaps->dwMinifyLimit = pdrv->lpddMoreCaps->dwBltAffineMinifyLimit;
    	pcaps->dwHELMinifyLimit = pdrv->lpddHELMoreCaps->dwBltAffineMinifyLimit;
    }

    if (pcaps->dwSrcSurfCaps & DDSCAPS_NONLOCALVIDMEM &&
	  pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS)
    {
        /*
	 * A driver that specifies nonlocal video-memory caps that differ
	 * from its local video-memory caps is automatically disqualified
	 * because the currently specified nonlocal vidmem caps do not
	 * include alpha, filter, or transform caps.  Should we fix this?
	 */
	pcaps->bNoHAL = TRUE;
    }

    if ((pcaps->dwSrcSurfCaps | pcaps->dwDestSurfCaps) & DDSCAPS_SYSTEMMEMORY &&
	    !(pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM))
    {
	pcaps->bNoHAL = TRUE;	// H/W driver can't blit to/from system memory
    }

    if (pcaps->dwSrcSurfCaps & pcaps->dwDestSurfCaps & DDSCAPS_VIDEOMEMORY)
    {
	//pcaps->dwCaps =   pdrv->ddCaps.dwCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    pcaps->dwAlphaCaps  = pdrv->lpddMoreCaps->dwAlphaCaps;
	    pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwFilterCaps;
	    pcaps->dwTransformCaps = pdrv->lpddMoreCaps->dwTransformCaps;
	}
	
	//pcaps->dwHELCaps =   pdrv->ddHELCaps.dwCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    pcaps->dwHELAlphaCaps  = pdrv->lpddHELMoreCaps->dwAlphaCaps;
	    pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwFilterCaps;
	    pcaps->dwHELTransformCaps = pdrv->lpddHELMoreCaps->dwTransformCaps;
	}
    }
    else if (pcaps->dwSrcSurfCaps & DDSCAPS_SYSTEMMEMORY &&
		pcaps->dwDestSurfCaps & DDSCAPS_VIDEOMEMORY)
    {
	//pcaps->dwCaps =   pdrv->ddCaps.dwSVBCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwSVBCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwSVBFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    pcaps->dwAlphaCaps  = pdrv->lpddMoreCaps->dwSVBAlphaCaps;
	    pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwSVBFilterCaps;
	    pcaps->dwTransformCaps = pdrv->lpddMoreCaps->dwSVBTransformCaps;
	}
	
	//pcaps->dwHELCaps =   pdrv->ddHELCaps.dwSVBCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwSVBCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwSVBFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    pcaps->dwHELAlphaCaps  = pdrv->lpddHELMoreCaps->dwSVBAlphaCaps;
	    pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwSVBFilterCaps;
	    pcaps->dwHELTransformCaps = pdrv->lpddHELMoreCaps->dwSVBTransformCaps;
	}
    }
    else if (pcaps->dwSrcSurfCaps & DDSCAPS_VIDEOMEMORY &&
		    pcaps->dwDestSurfCaps & DDSCAPS_SYSTEMMEMORY)
    {
	//pcaps->dwCaps =   pdrv->ddCaps.dwVSBCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwVSBCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwVSBFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    pcaps->dwAlphaCaps  = pdrv->lpddMoreCaps->dwVSBAlphaCaps;
	    pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwVSBFilterCaps;
	    pcaps->dwTransformCaps = pdrv->lpddMoreCaps->dwVSBTransformCaps;
	}
	
	//pcaps->dwHELCaps =   pdrv->ddHELCaps.dwVSBCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwVSBCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwVSBFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    pcaps->dwHELAlphaCaps  = pdrv->lpddHELMoreCaps->dwVSBAlphaCaps;
	    pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwVSBFilterCaps;
	    pcaps->dwHELTransformCaps = pdrv->lpddHELMoreCaps->dwVSBTransformCaps;
	}
    }
    else if (pcaps->dwSrcSurfCaps & pcaps->dwDestSurfCaps & DDSCAPS_SYSTEMMEMORY)
    {
	//pcaps->dwCaps =   pdrv->ddCaps.dwSSBCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwSSBCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwSSBFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    pcaps->dwAlphaCaps  = pdrv->lpddMoreCaps->dwSSBAlphaCaps;
	    pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwSSBFilterCaps;
	    pcaps->dwTransformCaps = pdrv->lpddMoreCaps->dwSSBTransformCaps;
	}
	
	//pcaps->dwHELCaps =   pdrv->ddHELCaps.dwSSBCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwSSBCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwSSBFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    pcaps->dwHELAlphaCaps  = pdrv->lpddHELMoreCaps->dwSSBAlphaCaps;
	    pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwSSBFilterCaps;
	    pcaps->dwHELTransformCaps = pdrv->lpddHELMoreCaps->dwSSBTransformCaps;
	}
    }

    if (pcaps->bOverlay)
    {
	// Isolate overlay bits by masking off all blit-related bits.
	//pcaps->dwCaps        &= DDCAPS_OVERLAYBITS;
	pcaps->dwCKeyCaps      &= DDCKEYCAPS_OVERLAYBITS;
	pcaps->dwFXCaps        &= DDFXCAPS_OVERLAYBITS;
	pcaps->dwAlphaCaps     &= DDALPHACAPS_OVERLAYBITS;
	pcaps->dwFilterCaps    &= DDFILTCAPS_OVERLAYBITS;
	pcaps->dwTransformCaps &= DDTFRMCAPS_OVERLAYBITS;
	
	//pcaps->dwHELCaps        &= DDCAPS_OVERLAYBITS;
	pcaps->dwHELCKeyCaps      &= DDCKEYCAPS_OVERLAYBITS;
	pcaps->dwHELFXCaps        &= DDFXCAPS_OVERLAYBITS;
	pcaps->dwHELAlphaCaps     &= DDALPHACAPS_OVERLAYBITS;
	pcaps->dwHELFilterCaps    &= DDFILTCAPS_OVERLAYBITS;
	pcaps->dwHELTransformCaps &= DDTFRMCAPS_OVERLAYBITS;
    }
    else
    {
	// Isolate blit bits by masking off all overlay-related bits.
	//pcaps->dwCaps        &= DDCAPS_BLTBITS;
	pcaps->dwCKeyCaps      &= DDCKEYCAPS_BLTBITS;
	pcaps->dwFXCaps        &= DDFXCAPS_BLTBITS;
	pcaps->dwAlphaCaps     &= DDALPHACAPS_BLTBITS;
	pcaps->dwFilterCaps    &= DDFILTCAPS_BLTBITS;
	pcaps->dwTransformCaps &= DDTFRMCAPS_BLTBITS;
	
	//pcaps->dwHELCaps        &= DDCAPS_BLTBITS;
	pcaps->dwHELCKeyCaps      &= DDCKEYCAPS_BLTBITS;
	pcaps->dwHELFXCaps        &= DDFXCAPS_BLTBITS;
	pcaps->dwHELAlphaCaps     &= DDALPHACAPS_BLTBITS;
	pcaps->dwHELFilterCaps    &= DDFILTCAPS_BLTBITS;
	pcaps->dwHELTransformCaps &= DDTFRMCAPS_BLTBITS;
    }
}  /* initSpriteCaps */


/*
 * Verify that affine transform does not exceed driver's minification
 * limit.  Arg pdrv is a pointer to the global DirectDraw object.  Arg
 * lpDDSpriteFX points to a DDSPRITEFX structure containing 4x4 matrix.
 * Arg overlay is TRUE for overlay sprites, and FALSE for blitted
 * sprites.  Arg emulation is TRUE if the overlay is to be emulated.
 * Returns DD_OK if specified affine transform is within limits.
 */
static void checkMinification(LPDDSPRITEFX lpDDSpriteFX,
			      LPSPRITE_CAPS pcaps)
{
    int i;

    for (i = 0; i < 2; ++i)
    {
	FLOAT a00, a01, a10, a11, det, amax;
	DWORD minlim;

	/*
	 * Get driver's minification limit.
	 */
	if (i == 0)
	{
	    // Get hardware driver's minification limit.
	    minlim = pcaps->dwMinifyLimit;

	    if (pcaps->bNoHAL || minlim == 0)   // minlim = 0 means no limit
	    {
    		continue;
	    }
	}
	else
	{
	    // Get HEL's minification limit.
	    minlim = pcaps->dwHELMinifyLimit;

	    if (pcaps->bNoHEL || minlim == 0)
	    {
    		continue;
	    }
	}

	/*
	 * Check transformation matrix against driver's minification limit.
	 */
	a00 = lpDDSpriteFX->fTransform[0][0];
	a01 = lpDDSpriteFX->fTransform[0][1];
	a10 = lpDDSpriteFX->fTransform[1][0];
	a11 = lpDDSpriteFX->fTransform[1][1];
	// Calculate determinant of Jacobian.
	det = a00*a11 - a10*a01;
	// Get absolute values of the 4 Jacobian coefficients.
	if (a00 < 0)   // could have used fabs() here
	    a00 = -a00;
	if (a01 < 0)
	    a01 = -a01;
	if (a10 < 0)
	    a10 = -a10;
	if (a11 < 0)
	    a11 = -a11;
	if (det < 0)
	    det = -det;
	// Find biggest coefficient in Jacobian.
	amax = a00;
	if (a01 > amax)
	    amax = a01;
	if (a10 > amax)
	    amax = a10;
	if (a11 > amax)
	    amax = a11;
	// Test the minification level against the driver's limit.
	if (1000*amax >= det*minlim)
	{
	    // Affine transform exceeds driver's minification limit.
	    if (i == 0)
	    {
    		pcaps->bNoHAL = TRUE;	 // disqualify hardware driver
	    }
	    else
	    {
    		pcaps->bNoHEL = TRUE;	 // disqualify HEL
	    }
	}
    }
}  /* checkMinification */


/*
 * Validate the DDSPRITE structure.  Arg pSprite is a pointer to a
 * DDSPRITE structure.  Arg pdrv is a pointer to the dest surface's
 * DirectDraw object.  Arg dest_lcl is a pointer to the destination
 * surface.  Arg pcaps is a pointer to a structure containing the
 * driver's capabilities.  Returns DD_OK if successful.
 */
static HRESULT validateSprite(LPDDSPRITE pSprite,
			      LPDDRAWI_DIRECTDRAW_GBL pdrv,
			      LPDDRAWI_DDRAWSURFACE_LCL surf_dest_lcl,
			      LPSPRITE_CAPS pcaps,
			      DWORD dwDDPFDestFlags)
{
    LPDDRAWI_DDRAWSURFACE_INT	surf_src_int;
    LPDDRAWI_DDRAWSURFACE_LCL	surf_src_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	surf_src;
    DWORD	dwDDPFSrcFlags;
    LPRECT      prSrc;
    LPRECT      prDest;
    DWORD	dest_width  = 0;
    DWORD	dest_height = 0;
    DWORD	src_width   = 0;
    DWORD	src_height  = 0;

    DDASSERT(!(pcaps->bNoHAL && pcaps->bNoHEL));

    /*
     * Validate the DDSPRITE pointer.  (A caller that does not use the
     * embedded DDSPRITEFX structure must still alloc space for it.)
     */
    if (IsBadWritePtr((LPVOID)pSprite, (UINT)sizeof(DDSPRITE)))
    {
	DPF_ERR("Bad pointer to DDSPRITE structure...");
	return DDERR_INVALIDPARAMS;
    }

    /*
     * If the caller doesn't use the embedded DDSPRITEFX struct,
     * we'll fill it in ourselves before passing it to the driver.
     */
    if (!(pSprite->dwFlags & DDSPRITE_DDSPRITEFX))
    {
	if (pSprite->dwFlags & (DDSPRITE_KEYDESTOVERRIDE | DDSPRITE_KEYSRCOVERRIDE))
	{
	    DPF_ERR("Illegal to set color-key override if DDSPRITEFX is invalid");
	    return DDERR_INVALIDPARAMS;
	}

	pSprite->ddSpriteFX.dwSize = sizeof(DDSPRITEFX);
	pSprite->ddSpriteFX.dwDDFX = 0;
	pSprite->dwFlags |= DDSPRITE_DDSPRITEFX;
    }

    /*
     * Validate the source surface for the sprite.
     */
    surf_src_int = (LPDDRAWI_DDRAWSURFACE_INT)pSprite->lpDDSSrc;

    if (!VALID_DIRECTDRAWSURFACE_PTR(surf_src_int))
    {
	DPF_ERR("Invalid source surface pointer...");
	return DDERR_INVALIDOBJECT;
    }

    surf_src_lcl = surf_src_int->lpLcl;
    surf_src = surf_src_lcl->lpGbl;

    if (SURFACE_LOST(surf_src_lcl))
    {
	DPF_ERR("Lost source surface...");
	return DDERR_SURFACELOST;
    }

    /*
     * We cannot use source and destination surfaces that were
     * created with different DirectDraw objects.
     */
    if (surf_src->lpDD != pdrv
	    && surf_src->lpDD->dwFlags & DDRAWI_DISPLAYDRV &&
		pdrv->dwFlags & DDRAWI_DISPLAYDRV)
    {
	DPF_ERR("Source and dest surfaces must have same DirectDraw device...");
	LEAVE_BOTH();
	return DDERR_DEVICEDOESNTOWNSURFACE;
    }

    /*
     * Validate destination rectangle.
     */
    prDest = &pSprite->rcDest;

    if (pSprite->dwFlags & DDSPRITE_RECTDEST)
    {
	// Validate destination rectangle specified in rcDest member.
	dest_height = prDest->bottom - prDest->top;
	dest_width = prDest->right - prDest->left;
	if ((int)dest_height <= 0 || (int)dest_width <= 0)
	{
	    DPF_ERR("Invalid destination rectangle...");
	    return DDERR_INVALIDRECT;
	}
	if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_AFFINETRANSFORM)
	{
	    DPF_ERR("Illegal to specify both dest rect and affine transform...");
	    return DDERR_INVALIDPARAMS;
	}
    }
    else if (!(pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_AFFINETRANSFORM))
    {
	/*
	 * The implicit destination is the entire dest surface.  Substitute
	 * an explicit destination rectangle that covers the dest surface.
         */
	MAKE_SURF_RECT(surf_dest_lcl->lpGbl, surf_dest_lcl, pSprite->rcDest);
        pSprite->dwFlags |= DDSPRITE_RECTDEST;
    }

    /*
     * Validate source rectangle.
     */
    prSrc = &pSprite->rcSrc;

    if (pSprite->dwFlags & DDSPRITE_RECTSRC)
    {
	// Validate source rectangle specified in rcSrc member.
	src_height = prSrc->bottom - prSrc->top;
	src_width = prSrc->right - prSrc->left;
	if (((int)src_height <= 0) || ((int)src_width <= 0) ||
	    ((int)prSrc->top < 0) || ((int)prSrc->left < 0) ||
	    ((DWORD) prSrc->bottom > (DWORD) surf_src->wHeight) ||
	    ((DWORD) prSrc->right > (DWORD) surf_src->wWidth))
	{
	    DPF_ERR("Invalid source rectangle...");
	    return DDERR_INVALIDRECT;
	}
    }
    else
    {
	/*
	 * The implicit source rect is the entire dest surface.  Substitute
	 * an explicit source rectangle that covers the source surface.
         */
	MAKE_SURF_RECT(surf_src, surf_src_lcl, pSprite->rcSrc);
        pSprite->dwFlags |= DDSPRITE_RECTSRC;
    }

    /*
     * Validate memory alignment of source and dest rectangles.
     */
    if (pdrv->ddCaps.dwCaps & (DDCAPS_ALIGNBOUNDARYDEST | DDCAPS_ALIGNSIZEDEST |
			       DDCAPS_ALIGNBOUNDARYSRC | DDCAPS_ALIGNSIZESRC))
    {
	if (pdrv->ddCaps.dwCaps & DDCAPS_ALIGNBOUNDARYDEST &&
	    (prDest->left % pdrv->ddCaps.dwAlignBoundaryDest) != 0)
	{
	    DPF_ERR("Destination left misaligned...");
	    return DDERR_XALIGN;
	}
	if (pdrv->ddCaps.dwCaps & DDCAPS_ALIGNBOUNDARYSRC &&
	    (prSrc->left % pdrv->ddCaps.dwAlignBoundarySrc) != 0)
	{
	    DPF_ERR("Source left misaligned...");
	    return DDERR_XALIGN;
	}

	if (pdrv->ddCaps.dwCaps & DDCAPS_ALIGNSIZEDEST &&
	    (dest_width % pdrv->ddCaps.dwAlignSizeDest) != 0)
	{
	    DPF_ERR("Destination width misaligned...");
	    return DDERR_XALIGN;
	}

	if (pdrv->ddCaps.dwCaps & DDCAPS_ALIGNSIZESRC  &&
	    (src_width % pdrv->ddCaps.dwAlignSizeSrc) != 0)
	{
	    DPF_ERR("Source width misaligned...");
	    return DDERR_XALIGN;
	}
    }

    /*
     * Are the source surface's caps the same as those of the previous sprite?
     */
    if ((surf_src_lcl->ddsCaps.dwCaps ^ pcaps->dwSrcSurfCaps) &
	    (DDSCAPS_SYSTEMMEMORY | DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM))
    {
	/*
	 * This source surface's memory type differs from that of the
	 * previous source surface, so we need to get a new set of caps.
	 */
	pcaps->dwSrcSurfCaps = surf_src_lcl->ddsCaps.dwCaps;
	initSpriteCaps(pcaps, pdrv);
    }

    /*
     * Get pixel-format flags for source surface.
     */
    dwDDPFSrcFlags = getPixelFormatFlags(surf_src_lcl);

    /*
     * If the source surface is palette-indexed, make sure a palette
     * is attached to it.
     */
    if (dwDDPFSrcFlags & (DDPF_PALETTEINDEXED1 | DDPF_PALETTEINDEXED2 |
			  DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8) &&
	    (surf_src_lcl->lpDDPalette == NULL ||
	     surf_src_lcl->lpDDPalette->lpLcl->lpGbl->lpColorTable == NULL))
    {
	DPF_ERR( "No palette associated with palette-indexed surface..." );
	LEAVE_BOTH();
	return DDERR_NOPALETTEATTACHED;
    }

    /*
     * Is any color keying required for this sprite?
     */
    if (pSprite->dwFlags & (DDSPRITE_KEYSRC  | DDSPRITE_KEYSRCOVERRIDE |
			    DDSPRITE_KEYDEST | DDSPRITE_KEYDESTOVERRIDE))
    {
	/*
	 * Validate source color-key flag.
	 */
	if (pSprite->dwFlags & (DDSPRITE_KEYSRC | DDSPRITE_KEYSRCOVERRIDE))
	{
	    if (!(pcaps->dwCKeyCaps & (DDCKEYCAPS_SRCBLT | DDCKEYCAPS_SRCOVERLAY)))
	    {
		pcaps->bNoHAL = TRUE;    // disqualify hardware driver
	    }
	    if (!(pcaps->dwHELCKeyCaps & (DDCKEYCAPS_SRCBLT | DDCKEYCAPS_SRCOVERLAY)))
	    {
		pcaps->bNoHEL = TRUE;    // disqualify HEL
	    }
	    if (dwDDPFSrcFlags & DDPF_ALPHAPIXELS)
	    {
		DPF_ERR("KEYSRC* illegal with source alpha channel...");
		return DDERR_INVALIDPARAMS;
	    }
	    if (pSprite->dwFlags & DDSPRITE_KEYSRC)
	    {
		if (!(!pcaps->bOverlay && surf_src_lcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT ||
		       pcaps->bOverlay && surf_src_lcl->dwFlags & DDRAWISURF_HASCKEYSRCOVERLAY))
		{
		    DPF_ERR("KEYSRC specified, but no color key...");
		    return DDERR_INVALIDPARAMS;
		}
		if (pSprite->dwFlags & DDSPRITE_KEYSRCOVERRIDE)
		{
		    DPF_ERR("Illegal to specify both KEYSRC and KEYSRCOVERRIDE...");
		    return DDERR_INVALIDPARAMS;
		}
		// Copy color key value from surface into DDSPRITEFX struct.
		pSprite->ddSpriteFX.ddckSrcColorkey = (pcaps->bOverlay) ?
						       surf_src_lcl->ddckCKSrcOverlay :
						       surf_src_lcl->ddckCKSrcBlt;
		// Turn off KEYSRC, turn on KEYSRCOVERRIDE.
		pSprite->dwFlags ^= DDSPRITE_KEYSRC | DDSPRITE_KEYSRCOVERRIDE;
	    }
	}

	/*
	 * Validate destination color-key flag.
	 */
	if (pSprite->dwFlags & (DDSPRITE_KEYDEST | DDSPRITE_KEYDESTOVERRIDE))
	{
	    if (!(pcaps->dwCKeyCaps & (DDCKEYCAPS_DESTBLT | DDCKEYCAPS_DESTOVERLAY)))
	    {
		pcaps->bNoHAL = TRUE;    // disqualify hardware driver
	    }
	    if (!(pcaps->dwHELCKeyCaps & (DDCKEYCAPS_DESTBLT | DDCKEYCAPS_DESTOVERLAY)))
	    {
		pcaps->bNoHEL = TRUE;    // disqualify HEL
	    }
	    if (dwDDPFDestFlags & DDPF_ALPHAPIXELS)
	    {
		DPF_ERR("KEYDEST* illegal with dest alpha channel...");
		return DDERR_INVALIDPARAMS;
	    }
	    if (pSprite->dwFlags & DDSPRITE_KEYDEST)
	    {
		if (!(!pcaps->bOverlay && surf_dest_lcl->dwFlags & DDRAWISURF_HASCKEYDESTBLT ||
		       pcaps->bOverlay && surf_dest_lcl->dwFlags & DDRAWISURF_HASCKEYDESTOVERLAY))
		{
		    DPF_ERR("KEYDEST specified, but no color key...");
		    return DDERR_INVALIDPARAMS;
		}
		if (pSprite->dwFlags & DDSPRITE_KEYDESTOVERRIDE)
		{
		    DPF_ERR("Illegal to specify both KEYDEST and KEYDESTOVERRIDE...");
		    return DDERR_INVALIDPARAMS;
		}
		// Copy color key value from surface into DDSPRITEFX struct.
		pSprite->ddSpriteFX.ddckDestColorkey = (pcaps->bOverlay) ?
							surf_src_lcl->ddckCKDestOverlay :
							surf_src_lcl->ddckCKDestBlt;
		// Turn off KEYDEST, turn on KEYDESTOVERRIDE.
		pSprite->dwFlags ^= DDSPRITE_KEYDEST | DDSPRITE_KEYDESTOVERRIDE;
	    }
	}

	if (pcaps->bNoHAL && pcaps->bNoHEL)
	{
	    DPF_ERR("No driver support for specified color-key operation");
	    return DDERR_UNSUPPORTED;
	}
    }

    /*
     * Assume hardware unable to handle sprite in system memory.
     * (Will this assumption remain true for future hardware?)
     */
    if (pcaps->bOverlay)
    {
	if (pcaps->dwSrcSurfCaps & DDSCAPS_SYSTEMMEMORY)
	{
	    pcaps->bNoHAL = TRUE;    // can't use hardware

	    if (pcaps->bNoHEL)    // but can we still emulate?
	    {
		// Nope, we can't emulate either, so fail the call.
		DPF_ERR("Driver can't handle sprite in system memory");
		return DDERR_UNSUPPORTED;
	    }
	}
    }
	
    /*
     * We do not allow blits or overlays with an optimized surface.
     */
    if (pcaps->dwSrcSurfCaps & DDSCAPS_OPTIMIZED)
    {
	DPF_ERR("Can't do blits or overlays with optimized surfaces...") ;
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Validate dwSize field in embedded DDSPRITEFX structure.
     */
    if (pSprite->ddSpriteFX.dwSize != sizeof(DDSPRITEFX))
    {
	DPF_ERR("Invalid dwSize value in DDSPRITEFX structure...");
	return DDERR_INVALIDPARAMS;
    }

    /*
     * If the RGBA scaling factors are effectively disabled by all being
     * set to 255 (all ones), just clear the RGBASCALING flag.
     */
    if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_RGBASCALING &&
    	    *(LPDWORD)&pSprite->ddSpriteFX.ddrgbaScaleFactors == ~0UL)
    {
	pSprite->ddSpriteFX.dwDDFX &= ~DDSPRITEFX_RGBASCALING;
    }

    /*
     * Is any kind of alpha blending required for this sprite?
     */
    if (dwDDPFSrcFlags & DDPF_ALPHAPIXELS ||
            !(pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_DEGRADERGBASCALING) &&
	    pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_RGBASCALING)
    {
    	/*
	 * Yes, this sprite requires some form of alpha blending.
	 * Does the driver support any kind of alpha blending at all?
	 */
	if (!(pcaps->dwFXCaps & (DDFXCAPS_BLTALPHA | DDFXCAPS_OVERLAYALPHA)))
	{
	    pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	}
	if (!(pcaps->dwHELFXCaps & (DDFXCAPS_BLTALPHA | DDFXCAPS_OVERLAYALPHA)))
	{
	    pcaps->bNoHEL = TRUE;   // disqualify HEL
	}

	if (pcaps->bNoHAL && pcaps->bNoHEL)
	{
	    DPF_ERR("Driver can't do any kind of alpha blending at all...");
	    return DDERR_UNSUPPORTED;
	}

	/*
	 * Does source surface have an alpha channel?
	 */
	if (dwDDPFSrcFlags & DDPF_ALPHAPIXELS)
	{
	    /*
	     * Can the driver handle this surface's alpha-channel format?
	     */
	    if (dwDDPFSrcFlags & DDPF_ALPHAPREMULT)
	    {
		// The source is in premultiplied-alpha format.
		if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTPREMULT |
					    DDALPHACAPS_OVERLAYPREMULT)))
		{
		    pcaps->bNoHAL = TRUE;	// disqualify hardware driver
		}
		if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTPREMULT |
					       DDALPHACAPS_OVERLAYPREMULT)))
		{
		    pcaps->bNoHEL = TRUE;	// disqualify HEL
		}
	    }
	    else
	    {
		// The source is in NON-premultiplied-alpha format.
		if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTNONPREMULT |
					    DDALPHACAPS_OVERLAYNONPREMULT)))
		{
		    pcaps->bNoHAL = TRUE;	// disqualify hardware driver
		}
		if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTNONPREMULT |
					       DDALPHACAPS_OVERLAYNONPREMULT)))
		{
		    pcaps->bNoHEL = TRUE;	// disqualify HEL
		}
	    }
	    if (pcaps->bNoHAL && pcaps->bNoHEL)
	    {
		DPF_ERR("Driver can't handle alpha channel in source surface...");
		return DDERR_NOALPHAHW;
	    }
	}

	/*
	 * Does the destination surface have an alpha channel?
	 */
	if (dwDDPFDestFlags & DDPF_ALPHAPIXELS)
	{
	    /*
	     * Verify that destination surface has a premultiplied-
	     * alpha pixel format.  Non-premultiplied alpha won't do.
	     */
	    if (!(dwDDPFDestFlags & DDPF_ALPHAPREMULT))
	    {
		DPF_ERR("Illegal to use non-premultiplied alpha in dest surface...");
		return DDERR_INVALIDPARAMS;
	    }
	    /*
	     * Can the driver handle this surface's alpha-channel format?
	     */
	    if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTPREMULT |
					DDALPHACAPS_OVERLAYPREMULT)))
	    {
		pcaps->bNoHAL = TRUE;	// disqualify hardware driver
	    }
	    if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTPREMULT |
					   DDALPHACAPS_OVERLAYPREMULT)))
	    {
		pcaps->bNoHEL = TRUE;	// disqualify HEL
	    }
	    if (pcaps->bNoHAL && pcaps->bNoHEL)
	    {
		DPF_ERR("Driver can't handle alpha channel in dest surface...");
		return DDERR_NOALPHAHW;
	    }
	}

	/*
	 * Are the RGBA scaling factors enabled for this sprite?
	 */
        if (!(pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_DEGRADERGBASCALING) &&
		*(LPDWORD)&pSprite->ddSpriteFX.ddrgbaScaleFactors != ~0UL)
	{
	    DDRGBA val = pSprite->ddSpriteFX.ddrgbaScaleFactors;

	    /*
	     * Yes, RGBA scaling is enabled.  Does driver support it?
	     */
	    if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTRGBASCALE1F | DDALPHACAPS_OVERLAYRGBASCALE1F |
					DDALPHACAPS_BLTRGBASCALE2F | DDALPHACAPS_OVERLAYRGBASCALE2F |
					DDALPHACAPS_BLTRGBASCALE4F | DDALPHACAPS_OVERLAYRGBASCALE4F)))
	    {
		pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	    }
	    if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTRGBASCALE1F | DDALPHACAPS_OVERLAYRGBASCALE1F |
					   DDALPHACAPS_BLTRGBASCALE2F | DDALPHACAPS_OVERLAYRGBASCALE2F |
					   DDALPHACAPS_BLTRGBASCALE4F | DDALPHACAPS_OVERLAYRGBASCALE4F)))
	    {
		pcaps->bNoHEL = TRUE;   // disqualify HEL
	    }
	    if (pcaps->bNoHAL && pcaps->bNoHEL)
	    {
		DPF_ERR("Driver can't do any kind of RGBA scaling at all...");
		return DDERR_UNSUPPORTED;
	    }

	    if (val.red > val.alpha || val.green > val.alpha || val.blue > val.alpha)
	    {
		
		if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTSATURATE |
					    DDALPHACAPS_OVERLAYSATURATE)))
		{
		    pcaps->bNoHAL = TRUE;   // disqualify hardware driver
		}
		if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTSATURATE |
					       DDALPHACAPS_OVERLAYSATURATE)))
		{
		    pcaps->bNoHEL = TRUE;   // disqualify HEL
		}
	    }
	    if (val.red != val.green || val.red != val.blue)
	    {
		if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTRGBASCALE4F |
					    DDALPHACAPS_OVERLAYRGBASCALE4F)))
		{
		    pcaps->bNoHAL = TRUE;   // disqualify hardware driver
		}
		if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTRGBASCALE4F |
					       DDALPHACAPS_OVERLAYRGBASCALE4F)))
		{
		    pcaps->bNoHEL = TRUE;   // disqualify HEL
		}
	    } else if (*(LPDWORD)&val != val.alpha*0x01010101UL)
	    {
		if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTRGBASCALE2F |
					    DDALPHACAPS_OVERLAYRGBASCALE2F)))
		{
		    pcaps->bNoHAL = TRUE;   // disqualify hardware driver
		}
		if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTRGBASCALE2F |
					       DDALPHACAPS_OVERLAYRGBASCALE2F)))
		{
		    pcaps->bNoHEL = TRUE;   // disqualify HEL
		}
	    }
	    if (pcaps->bNoHAL && pcaps->bNoHEL)
	    {
		DPF_ERR("Driver can't handle specified RGBA scaling factors...");
		return DDERR_UNSUPPORTED;
	    }
	}
    }

    /*
     * Is any kind of filtering required for this sprite?
     */
    if (!(pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_DEGRADEFILTER) &&
	    pSprite->ddSpriteFX.dwDDFX & (DDSPRITEFX_BILINEARFILTER |
					 DDSPRITEFX_BLURFILTER |
					 DDSPRITEFX_FLATFILTER))
    {
	/*
	 * The bilinear-, blur-, and flat-filtering options are mutually
	 * exclusive.  Make sure only one of these flags is set.
	 */
	DWORD fflags = pSprite->ddSpriteFX.dwDDFX & (DDSPRITEFX_BILINEARFILTER |
						       DDSPRITEFX_BLURFILTER |
						       DDSPRITEFX_FLATFILTER);
	if (fflags & (fflags - 1))
	{
    	    DPF_ERR("Two mutually exclusive filtering options were both specified");
	    return DDERR_INVALIDPARAMS;
	}

	/*
	 * Yes, this sprite requires some form of filtering.
	 * Does the driver support any kind of filtering at all?
	 */
	if (!(pcaps->dwFXCaps & (DDFXCAPS_BLTFILTER | DDFXCAPS_OVERLAYFILTER)))
	{
	    pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	}
	if (!(pcaps->dwHELFXCaps & (DDFXCAPS_BLTFILTER | DDFXCAPS_OVERLAYFILTER)))
	{
	    pcaps->bNoHEL = TRUE;   // disqualify HEL
	}
	
	if (pcaps->bNoHAL && pcaps->bNoHEL)
	{
	    DPF_ERR("Driver can't do any kind of filtering at all");
	    return DDERR_UNSUPPORTED;
	}

	if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_BILINEARFILTER)
	{
	    if (!(pcaps->dwFilterCaps & (DDFILTCAPS_BLTBILINEARFILTER |
					 DDFILTCAPS_OVERLAYBILINEARFILTER)))
	    {
		pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	    }
	    if (!(pcaps->dwHELFilterCaps & (DDFILTCAPS_BLTBILINEARFILTER |
					    DDFILTCAPS_OVERLAYBILINEARFILTER)))
	    {
		pcaps->bNoHEL = TRUE;   // disqualify HEL
	    }
	}
	if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_BLURFILTER)
	{
	    if (!(pcaps->dwFilterCaps & (DDFILTCAPS_BLTBLURFILTER |
					 DDFILTCAPS_OVERLAYBLURFILTER)))
	    {
		pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	    }
	    if (!(pcaps->dwHELFilterCaps & (DDFILTCAPS_BLTBLURFILTER |
					    DDFILTCAPS_OVERLAYBLURFILTER)))
	    {
		pcaps->bNoHEL = TRUE;   // disqualify HEL
	    }
	}
	if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_FLATFILTER)
	{
	    if (!(pcaps->dwFilterCaps & (DDFILTCAPS_BLTFLATFILTER |
					 DDFILTCAPS_OVERLAYFLATFILTER)))
	    {
		pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	    }
	    if (!(pcaps->dwHELFilterCaps & (DDFILTCAPS_BLTFLATFILTER |
					    DDFILTCAPS_OVERLAYFLATFILTER)))
	    {
		pcaps->bNoHEL = TRUE;   // disqualify HEL
	    }
	}
	if (pcaps->bNoHAL && pcaps->bNoHEL)
	{
	    DPF_ERR("Driver can't do specified filtering operation...");
	    return DDERR_UNSUPPORTED;
	}
    }

    /*
     * Can the driver handle the specified affine transformation?
     */
    if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_AFFINETRANSFORM)
    {
    	/*
	 * Can the driver do any affine transformations at all?
	 */
	if (!pcaps->bNoHAL &&
		(!(pcaps->dwFXCaps & (DDFXCAPS_BLTTRANSFORM | DDFXCAPS_OVERLAYTRANSFORM)) ||
    		!(pcaps->dwTransformCaps & (DDTFRMCAPS_BLTAFFINETRANSFORM |
					    DDTFRMCAPS_OVERLAYAFFINETRANSFORM))))
	{
            pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	}
	if (!pcaps->bNoHEL &&
		(!(pcaps->dwHELFXCaps & (DDFXCAPS_BLTTRANSFORM | DDFXCAPS_OVERLAYTRANSFORM)) ||
    		!(pcaps->dwHELTransformCaps & (DDTFRMCAPS_BLTAFFINETRANSFORM |
					       DDTFRMCAPS_OVERLAYAFFINETRANSFORM))))
	{
            pcaps->bNoHEL = TRUE;   // disqualify HEL
	}

	if (pcaps->bNoHAL && pcaps->bNoHEL)
	{
	    DPF_ERR("Driver can't do any affine transformations...");
	    return DDERR_UNSUPPORTED;
	}

	/*
	 * Check affine transformation against driver's minification limits.
	 */
	checkMinification(&pSprite->ddSpriteFX, pcaps);

	if (pcaps->bNoHAL && pcaps->bNoHEL)
	{
	    DPF_ERR("Affine transform exceeds driver's minification limit...");
	    return DDERR_INVALIDPARAMS;
	}
    }

    /*
     * If necessary, degrade specified filtering and RGBA-scaling operations
     * to operations that the driver is capable of handling.
     */
    if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_DEGRADEFILTER)
    {
	DWORD caps;
	DWORD ddfx = pSprite->ddSpriteFX.dwDDFX;   // sprite FX flags

	// driver's FX caps
	caps = (pcaps->bNoHAL) ? pcaps->dwHELFXCaps : pcaps->dwFXCaps;

	if (!(caps && (DDFXCAPS_BLTFILTER | DDFXCAPS_OVERLAYFILTER)))
	{
	    // Driver can't do any kind of filtering, so just disable it.
	    ddfx &= ~(DDSPRITEFX_BILINEARFILTER | DDSPRITEFX_BLURFILTER |
		       DDSPRITEFX_FLATFILTER | DDSPRITEFX_DEGRADEFILTER);
	}
	else
	{
	    // Get driver's filter caps.
	    caps = (pcaps->bNoHAL) ? pcaps->dwHELFilterCaps : pcaps->dwFilterCaps;

	    // If blur filter is specified, can driver handle it?
	    if (ddfx & DDSPRITEFX_BLURFILTER &&
		    !(caps & (DDFILTCAPS_BLTBLURFILTER |
			      DDFILTCAPS_OVERLAYBLURFILTER)))
	    {
		// Degrade blur filter to bilinear filter.
		ddfx &= ~DDSPRITEFX_BLURFILTER;
		ddfx |= DDSPRITEFX_BILINEARFILTER;
	    }
	    // If flat filter is specified, can driver handle it?
	    if (ddfx & DDSPRITEFX_FLATFILTER &&
		    !(caps & (DDFILTCAPS_BLTFLATFILTER |
			      DDFILTCAPS_OVERLAYFLATFILTER)))
	    {
		// Degrade flat filter to bilinear filter.
		ddfx &= ~DDSPRITEFX_FLATFILTER;
		ddfx |= DDSPRITEFX_BILINEARFILTER;
	    }
	    // If bilinear filter is specified, can driver handle it?
	    if (ddfx & DDSPRITEFX_BILINEARFILTER &&
		    !(caps & (DDFILTCAPS_BLTBILINEARFILTER |
			      DDFILTCAPS_OVERLAYBILINEARFILTER)))
	    {
		// Degrade bilinear filtering to no filtering.
		ddfx &= ~DDSPRITEFX_BILINEARFILTER;
	    }
	}
	pSprite->ddSpriteFX.dwDDFX = ddfx & ~DDSPRITEFX_DEGRADEFILTER;
    }

    /*
     * If necessary, degrade specified RGBA scaling factors to values
     * that the driver is capable of handling.
     */
    if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_DEGRADERGBASCALING &&
	    *(LPDWORD)&pSprite->ddSpriteFX.ddrgbaScaleFactors != ~0UL)
    {
	DDRGBA val = pSprite->ddSpriteFX.ddrgbaScaleFactors;
	DWORD caps;

	// driver's alpha caps
	caps = (pcaps->bNoHAL) ? pcaps->dwHELAlphaCaps : pcaps->dwAlphaCaps;

	/*
	 * We permit the RGB scaling factors to exceed the alpha scaling
	 * factor only if the driver can do saturated alpha arithmetic to
	 * prevent the destination color components from overflowing.
	 */
	if ((val.red > val.alpha || val.green > val.alpha || val.blue > val.alpha) &&
		!(caps & (DDALPHACAPS_BLTSATURATE | DDALPHACAPS_OVERLAYSATURATE)))
	{
	    // Driver can't handle saturated arithmetic during alpha blending.
	    if (val.red > val.alpha)
	    {
		val.red = val.alpha;      // clamp red to alpha value
	    }
	    if (val.green > val.alpha)
	    {
		val.green = val.alpha;    // clamp green to alpha value
	    }
	    if (val.blue > val.alpha)
	    {
		val.blue = val.alpha;     // clamp blue to alpha value
	    }
	}
	/*
	 * Can driver perform 1-, 2-, or 4-factor RGBA scaling?
	 */
	if (!(caps & (DDALPHACAPS_BLTRGBASCALE1F | DDALPHACAPS_OVERLAYRGBASCALE1F |
		      DDALPHACAPS_BLTRGBASCALE2F | DDALPHACAPS_OVERLAYRGBASCALE2F |
		      DDALPHACAPS_BLTRGBASCALE4F | DDALPHACAPS_OVERLAYRGBASCALE4F)))
	{
	    // Driver can't do any kind of RGBA scaling at all.
	    *(LPDWORD)&val = ~0UL;	   // disable RGBA scaling altogether
	}
	else if (*(LPDWORD)&val != val.alpha*0x01010101UL &&
		!(caps & (DDALPHACAPS_BLTRGBASCALE2F | DDALPHACAPS_OVERLAYRGBASCALE2F |
			  DDALPHACAPS_BLTRGBASCALE4F | DDALPHACAPS_OVERLAYRGBASCALE4F)))
	{
	    // Driver can handle only 1-factor RGBA scaling.
	    *(LPDWORD)&val = val.alpha*0x01010101UL;   // set RGB factors = alpha factor
	}
	else if ((val.red != val.green || val.red != val.blue) &&
		!(caps & (DDALPHACAPS_BLTRGBASCALE4F | DDALPHACAPS_OVERLAYRGBASCALE4F)))
	{
	    /*
	     * Degrade the specified 4-factor RGBA-scaling operation to a 2-factor
	     * RGBA scaling operation that the driver can handle.  Set all three
	     * color factors to weighted average M of the specified color factors
	     * (Mr,Mg,Mb):  M = .299*Mr + .587*Mg + .114*Mb
	     */
	    DWORD M = 19595UL*val.red + 38470UL*val.green + 7471UL*val.blue;

	    val.red = val.green = val.blue = (BYTE)(M >> 16);
	}
	pSprite->ddSpriteFX.ddrgbaScaleFactors = val;
	pSprite->ddSpriteFX.dwDDFX &= ~DDSPRITEFX_DEGRADERGBASCALING;
    }

    /*
     * If the embedded DDSPRITEFX structure is unused, clear DDSPRITEFX flag.
     */
    if (!(pSprite->dwFlags & (DDSPRITE_KEYDESTOVERRIDE | DDSPRITE_KEYSRCOVERRIDE)) &&
    	    pSprite->ddSpriteFX.dwDDFX == 0)
    {
	pSprite->dwFlags &= ~DDSPRITE_DDSPRITEFX;
    }

    DDASSERT(!(pcaps->bNoHAL && pcaps->bNoHEL));

    return DD_OK;

}  /* validateSprite */


/*
 * Obtain clipping region for a destination surface and its attached
 * clipper.  (In the case of overlay sprites in the master sprite
 * list, though, pClipper points to the clipper that WAS attached to
 * the destination surface at the time of the SetSpriteDisplayList
 * call; it may no longer be if an app manages multiple windows.)
 * If pClipper is NULL, just use the whole dest surf as the clip rect.
 * A NULL return value always means DDERR_OUTOFMEMORY.
 */
static LPRGNDATA GetRgnData(LPDIRECTDRAWCLIPPER pClipper, LPRECT prcDestSurf,
			    LPDDRAWI_DIRECTDRAW_GBL pdrv, LPRGNDATA pRgn)
{
    DWORD rgnSize;

    /*
     * How big a buffer will we need to contain the clipping region?
     */
    if (pClipper == NULL)
    {
        /*
         * The destination surface has (or HAD) no attached clipper,
	 * so the effective clip region is a single rectangle the width
	 * and height of the primary surface.  Calculate the size of
	 * the region buffer we'll need.
         */
	rgnSize = sizeof(RGNDATAHEADER) + sizeof(RECT);
    }
    else
    {
	/*
         * The dest surface has (or HAD) an attached clipper.  Get
	 * the clip list.  This first call to InternalGetClipList
	 * just gets the size of the region so we know how much
	 * storage to allocate for it.
         */
        HRESULT ddrval = InternalGetClipList(pClipper,
					     prcDestSurf,
					     NULL,  // we just want rgnSize
					     &rgnSize,
					     pdrv);

	DDASSERT(ddrval == DD_OK);    // the call above should never fail
    }

    /*
     * Now we know how big a region buffer we'll need.  Did the caller
     * pass in a region buffer?  If so, is it the correct size?
     */
    if (pRgn != NULL)
    {
	/*
	 * The caller DID pass in a region buffer.  Before using it,
	 * let's make sure it's just the right size.
	 */
	DWORD bufSize = pRgn->rdh.dwSize + pRgn->rdh.nRgnSize;

	if (bufSize != rgnSize)
	{
	    // Can't use region buffer passed in by caller.
	    pRgn = NULL;
	}
    }

    /*
     * Now we know whether we'll have to alloc our own region buffer.
     */
    if (pRgn == NULL)
    {
	/*
	 * Yes, we must alloc our own region buffer.
	 */
	pRgn = (LPRGNDATA)MemAlloc(rgnSize);
	if (!pRgn)
	{
	    return NULL;    // error -- out of memory
	}
	// We'll fill in the following fields in case the caller
	// passes this same buffer to us again later.
	pRgn->rdh.dwSize = sizeof(RGNDATAHEADER);
	pRgn->rdh.nRgnSize = rgnSize - sizeof(RGNDATAHEADER);
    }

    /*
     * Okay, now we have a region buffer that's the right size.
     * Load the region data into the buffer.
     */
    if (pClipper == NULL)
    {
	// Set the single clip rect to cover the full dest surface.
	pRgn->rdh.nCount = 1;        // a single clip rect
	memcpy((LPRECT)&pRgn->Buffer, prcDestSurf, sizeof(RECT));
    }
    else
    {
        // This call actually retrieves the clip region info.
	HRESULT ddrval = InternalGetClipList(pClipper,
					     prcDestSurf,
					     pRgn,
					     &rgnSize,
					     pdrv);

	DDASSERT(ddrval == DD_OK);    // the call above should never fail
    }

    return (pRgn);    // return pointer to region info

}  /* GetRgnData */


/*
 * Validate the window handle associated with the specified clipper.
 * If the window handle is not valid, return FALSE.  Otherwise,
 * return TRUE.  Note that this function returns TRUE if either
 * pClipper is null or the associated window handle is null.
 */
static BOOL validClipperWindow(LPDIRECTDRAWCLIPPER pClipper)
{
    if (pClipper != NULL)
    {
        LPDDRAWI_DDRAWCLIPPER_INT pclip_int = (LPDDRAWI_DDRAWCLIPPER_INT)pClipper;
	LPDDRAWI_DDRAWCLIPPER_LCL pclip_lcl = pclip_int->lpLcl;
	LPDDRAWI_DDRAWCLIPPER_GBL pclip = pclip_lcl->lpGbl;
	HWND hWnd = (HWND)pclip->hWnd;

	if (hWnd != 0 && !IsWindow(hWnd))
	{
	    /*
	     * This window handle is no longer valid.
	     */
	    return FALSE;
	}
    }
    return TRUE;

}  /* validClipperWindow */


/*
 * Helper function for managing sublists within the master sprite
 * list.  If any sprites in the specified sublist have source surface
 * pointers that are null, remove those sprites and move the rest of
 * the sprite array downward to eliminate the gaps in the array.
 */
static DWORD scrunchSubList(LPSPRITESUBLIST pSubList)
{
    DWORD i, j;
    // Number of sprites in sublist
    DWORD dwNumSprites = pSubList->dwCount;
    // Pointer to first sprite in array of sprites
    LPDDSPRITEI pSprite = &pSubList->sprite[0];

    // Find first null surface in sprite array.
    for (i = 0; i < dwNumSprites; ++i)
    {
    	if (pSprite[i].lpDDSSrc == NULL)	  // null surface ptr?
	{
	    break;    // found first null surface in sprite array
	}
    }
    // Scrunch together remainder of sprite array to fill in gaps.
    for (j = i++; i < dwNumSprites; ++i)
    {
    	if (pSprite[i].lpDDSSrc != NULL)	  // valid surface ptr?
	{
    	    pSprite[j++] = pSprite[i];   // copy next valid sprite
	}
    }
    // Return number of sprites in scrunched array.
    return (pSubList->dwCount = j);

}  /* scrunchSubList */


/*
 * Helper function for managing master sprite list.  If any of the
 * sublist pointers in the master-sprite-list header are NULL,
 * remove those pointers and move the rest of the sublist-
 * pointer array downward to eliminate the gaps in the array.
 */
static DWORD scrunchMasterSpriteList(LPMASTERSPRITELIST pMaster)
{
    DWORD i, j;
    // Number of sublists in master sprite list
    DWORD dwNumSubLists = pMaster->dwNumSubLists;
    // Pointer to first pointer in array of sublist pointers
    LPSPRITESUBLIST *ppSubList = &pMaster->pSubList[0];

    // Find first null pointer in sublist-pointer array.
    for (i = 0; i < dwNumSubLists; ++i)
    {
    	if (ppSubList[i] == NULL)	  // null pointer?
	{
	    break;    // found first null pointer in array
	}
    }
    // Scrunch together remainder of sublist-pointer array to fill in gaps.
    for (j = i++; i < dwNumSubLists; ++i)
    {
    	if (ppSubList[i] != NULL)	  // valid pointer?
	{
    	    ppSubList[j++] = ppSubList[i];   // copy next valid pointer
	}
    }
    // Return number of sublist pointers in scrunched array.
    return (pMaster->dwNumSubLists = j);

}  /* scrunchMasterSpriteList */


/*
 * Helper function for managing master sprite list.  Mark all surface
 * and clipper objects that are referenced in the master sprite list.
 * When a marked surface or clipper object is released, the master
 * sprite list is immediately updated to eliminate invalid references.
 * The master sprite list contains pointers to surface and clipper
 * interface objects, but marks the surfaces and clippers by setting
 * flags in the local surface and global clipper objects.  Because
 * the master sprite list may contain multiple instances of the same
 * surface or clipper object, we mark and unmark all such objects in
 * unison to avoid errors.
 */
static void markSpriteObjects(LPMASTERSPRITELIST pMaster)
{
    DWORD i;

    if (pMaster == NULL)
    {
    	return;    // nothing to do -- bye!
    }

    /*
     * Set the DDRAWISURF/CLIP_INMASTERSPRITELIST flag in each local
     * surface object and global clipper object in the master sprite
     * list.  Each iteration marks the objects in one sublist.
     */
    for (i = 0; i < pMaster->dwNumSubLists; ++i)
    {
	LPDDRAWI_DDRAWSURFACE_INT surf_int;
	LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
	LPDDRAWI_DDRAWCLIPPER_INT pclip_int;
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDDSPRITEI sprite = &pSubList->sprite[0];
	DWORD dwNumSprites = pSubList->dwCount;
	DWORD j;

	/*
	 * Mark the primary surface object associated with this sublist.
	 */
	surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pSubList->pPrimary;
	surf_lcl = surf_int->lpLcl;
	surf_lcl->dwFlags |= DDRAWISURF_INMASTERSPRITELIST;

	/*
	 * If a clipper is associated with this sublist, mark it.
	 */
	pclip_int = (LPDDRAWI_DDRAWCLIPPER_INT)pSubList->pClipper;
	if (pclip_int != NULL)
	{
    	    LPDDRAWI_DDRAWCLIPPER_LCL pclip_lcl = pclip_int->lpLcl;
    	    LPDDRAWI_DDRAWCLIPPER_GBL pclip = pclip_lcl->lpGbl;

	    pclip->dwFlags |= DDRAWICLIP_INMASTERSPRITELIST;
	}

	/*
	 * Mark the source surface for each sprite in this sublist.
	 */
	for (j = 0; j < dwNumSprites; ++j)
	{
	    LPDDRAWI_DDRAWSURFACE_INT surf_int;
    	    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
	    LPDDSPRITEI pSprite = &sprite[j];

	    surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pSprite->lpDDSSrc;
	    surf_lcl = surf_int->lpLcl;
	    surf_lcl->dwFlags |= DDRAWISURF_INMASTERSPRITELIST;
	}
    }
}   /* markSpriteObjects */


/*
 * Helper function for managing master sprite list.
 * Mark all surfaces in the master sprite list as no longer
 * referenced by the master sprite list.
 */
static void unmarkSpriteObjects(LPMASTERSPRITELIST pMaster)
{
    DWORD i;

    if (pMaster == NULL)
    {
    	return;    // nothing to do -- bye!
    }

    /*
     * Clear the DDRAWISURF/CLIP_INMASTERSPRITELIST flag in each local
     * surface object and global clipper object in the master sprite
     * list.  Each iteration unmarks the objects in one sublist.
     */
    for (i = 0; i < pMaster->dwNumSubLists; ++i)
    {
	LPDDRAWI_DDRAWSURFACE_INT surf_int;
	LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
	LPDDRAWI_DDRAWCLIPPER_INT pclip_int;
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDDSPRITEI sprite = &pSubList->sprite[0];
	DWORD dwNumSprites = pSubList->dwCount;
	DWORD j;

	/*
	 * Unmark the primary surface object associated with this sublist.
	 */
	surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pSubList->pPrimary;
	surf_lcl = surf_int->lpLcl;
	surf_lcl->dwFlags &= ~DDRAWISURF_INMASTERSPRITELIST;

	/*
	 * If a clipper is associated with this sublist, unmark it.
	 */
	pclip_int = (LPDDRAWI_DDRAWCLIPPER_INT)pSubList->pClipper;
	if (pclip_int != NULL)
	{
    	    LPDDRAWI_DDRAWCLIPPER_LCL pclip_lcl = pclip_int->lpLcl;
    	    LPDDRAWI_DDRAWCLIPPER_GBL pclip = pclip_lcl->lpGbl;

	    pclip->dwFlags &= ~DDRAWICLIP_INMASTERSPRITELIST;
	}

	/*
	 * Mark all of the surfaces referenced in this sublist.
	 */
	for (j = 0; j < dwNumSprites; ++j)
	{
    	    LPDDRAWI_DDRAWSURFACE_INT surf_int;
    	    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
	    LPDDSPRITEI pSprite = &sprite[j];

	    surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pSprite->lpDDSSrc;
	    surf_lcl = surf_int->lpLcl;
	    surf_lcl->dwFlags &= ~DDRAWISURF_INMASTERSPRITELIST;
	}
    }
}   /* unmarkSpriteObjects */


/*
 * Helper function for managing master sprite list.  This function
 * frees the master sprite list for the specified DirectDraw object.
 */
void FreeMasterSpriteList(LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    DWORD i;
    LPMASTERSPRITELIST pMaster = (LPMASTERSPRITELIST)(pdrv->lpMasterSpriteList);

    if (pMaster == NULL)
    {
    	return;
    }
    /*
     * Clear flags in surface and clipper objects that indicate
     * that these objects are referenced in master sprite list.
     */
    unmarkSpriteObjects(pMaster);
    /*
     * Free all the individual sublists within the master sprite list.
     */
    for (i = 0; i < pMaster->dwNumSubLists; ++i)
    {
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];

	MemFree(pSubList->pRgn);   // Free clip region buffer
	MemFree(pSubList);	   // Free the sublist itself
    }
    MemFree(pMaster->pBuffer);	   // Free temp display list buffer
    MemFree(pMaster);		   // Free master sprite list header

    pdrv->lpMasterSpriteList = NULL;

}  /* FreeMasterSpriteList */


/*
 * This is a helper function for updateMasterSpriteList().  It builds
 * a temporary display list that contains all the sprites currently in
 * the master sprite display list.  This is the display list that we
 * will pass to the driver upon return from updateMasterSpriteList().
 */
static DDHAL_SETSPRITEDISPLAYLISTDATA *buildTempDisplayList(
					    LPMASTERSPRITELIST pMaster)
{
    DWORD size;
    LPBUFFER pbuf;
    LPDDSPRITEI *ppSprite;
    DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData;
    DWORD dwNumSubLists = pMaster->dwNumSubLists;   // number of sublists
    DWORD dwNumSprites = 0;
    DWORD i;

    /*
     * Update the clipping region for the sprites within each sublist.
     * In general, each sublist has a different clipping region.  If
     * a sublist has a clipper and that clipper has an hWnd, the clip
     * region may have changed since the last time we were called.
     */
    for (i = 0; i < dwNumSubLists; ++i)
    {
	DWORD j;
	LPRGNDATA pRgn;
	DWORD dwRectCnt;
	LPRECT pRect;
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDDSPRITEI sprite = &(pSubList->sprite[0]);
	DWORD dwCount = pSubList->dwCount;   // number of sprites in sublist

	/*
	 * Get clipping region for window this sprite display list is in.
	 */
	pRgn = GetRgnData(pSubList->pClipper, &pMaster->rcPrimary,
					pMaster->pdrv, pSubList->pRgn);
	if (pRgn == NULL)
	{
    	    return (NULL);    // error -- out of memory
	}
	if (pRgn != pSubList->pRgn)
	{
	    /*
	     * GetRgnData() allocated a new region buffer instead of using
	     * the old buffer.  We need to free the old buffer ourselves.
	     */
	    MemFree(pSubList->pRgn);
	}
	pSubList->pRgn = pRgn;	  // save ptr to region buffer
	/*
	 * All sprites in the sublist share the same clipping region.
	 */
        dwRectCnt = pRgn->rdh.nCount;   // number of rects in region
	pRect = (LPRECT)&pRgn->Buffer;  // list of clip rects

	for (j = 0; j < dwCount; ++j)
	{
    	    sprite[j].dwRectCnt = dwRectCnt;
	    sprite[j].lpRect = pRect;
	}
	/*
	 * Add the sprites in this sublist to our running tally of
	 * the total number of sprites in the master sprite list.
	 */
	dwNumSprites += dwCount;
    }

    /*
     * If we can, we'll build our temporary sprite display list in the
     * existing buffer (pMaster->pBuffer).  But if it doesn't exist or
     * is too big or too small, we'll have to allocate a new buffer.
     */
    size = sizeof(BUFFER) + (dwNumSprites-1)*sizeof(LPDDSPRITEI);
    pbuf = pMaster->pBuffer;   // try to re-use this buffer

    if (pbuf == NULL || pbuf->dwSize < size ||
		pbuf->dwSize > size + 8*sizeof(LPDDSPRITEI))
    {
	/*
	 * We have to allocate a new buffer.  First, free the old one.
	 */
	MemFree(pbuf);
	/*
	 * We'll alloc a slightly larger buffer than is absolutely
	 * necessary so that we'll have room to grow in.
	 */
        size += 4*sizeof(LPDDSPRITEI);    // add some padding
	pbuf = (LPBUFFER)MemAlloc(size);
	pMaster->pBuffer = pbuf;
	if (pbuf == NULL)
	{
	    return NULL;    // error -- out of memory
	}
	pbuf->dwSize = size;
    }
    /*
     * Initialize values in HAL data structure to be passed to driver.
     */
    pHalData = &(pbuf->HalData);
    pHalData->lpDD = pMaster->pdrv;
    pHalData->lpDDSurface = pMaster->surf_lcl;   // primary surface (local object)
    pHalData->lplpDDSprite = &(pbuf->pSprite[0]);
    pHalData->dwCount = dwNumSprites;
    pHalData->dwSize = sizeof(DDSPRITEI);
    pHalData->dwFlags =	pMaster->dwFlags;
    pHalData->lpDDTargetSurface = NULL;	  // can't flip shared surface
    pHalData->dwRectCnt = 0;
    pHalData->lpRect = NULL;   // each sprite has its own clip region
    pHalData->ddRVal = 0;
    //pHalData->SetSpriteDisplayList = NULL;    // no thunk (32-bit callback)
    /*
     * Load the sprite-pointer array with the pointers to
     * all the sprites contained in the various sublists.
     */
    ppSprite = &pbuf->pSprite[0];

    for (i = 0; i < dwNumSubLists; ++i)
    {
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDDSPRITEI sprite = &pSubList->sprite[0];
	DWORD dwCount = pSubList->dwCount;   // number of sprites in sublist i
	DWORD j;

	for (j = 0; j < dwCount; ++j)
	{
    	    /*
	     * Copy address of next sprite into pointer array.
	     */
	    *ppSprite++ = &sprite[j];
	}
    }
    return (&pbuf->HalData);    // return temp sprite display list

}  /* buildTempDisplayList */


/*
 * Global function for managing master sprite list.  This function
 * is called by CurrentProcessCleanup to remove from the master
 * sprite list all references to a process that is being terminated.
 * The function also checks for lost surfaces in the master sprite
 * list.  If any changes are made to the master sprite list, the
 * driver is told to display those changes immediately.
 */
void ProcessSpriteCleanup(LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid)
{
    LPMASTERSPRITELIST pMaster = (LPMASTERSPRITELIST)pdrv->lpMasterSpriteList;
    LPDIRECTDRAWSURFACE pPrimary;
    DWORD dwNumSubLists;
    BOOL bDeleteSubList = FALSE;
    BOOL bChangesMade = FALSE;
    DWORD i;

    if (pMaster == NULL)
    {
    	return;    // master sprite list does not exist
    }

    pPrimary = pMaster->pSubList[0]->pPrimary;
    dwNumSubLists = pMaster->dwNumSubLists;

    /*
     * Before making changes to the master sprite list, we first
     * unmark all clipper and surface objects in the list.  After
     * the changes are completed, we will again mark the objects
     * that are referenced in the revised master sprite list.
     */
    unmarkSpriteObjects(pMaster);

    /*
     * Each sublist of the master sprite list contains all the sprites
     * that are to appear within a particular window of a shared primary.
     * Associated with each sublist is the process ID for the window.
     * Compare this process ID with argument pid.  If they match,
     * delete the sublist from the master sprite list.
     */
    for (i = 0; i < dwNumSubLists; ++i)
    {
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDIRECTDRAWSURFACE pPrimary = pSubList->pPrimary;
	LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pPrimary;
	LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = surf_int->lpLcl;

	/*
	 * Is process associated with this sublist being terminated?
	 * (We also check for lost surfaces and delete any we find.)
	 */
	if (pSubList->dwProcessId != pid &&
				    validClipperWindow(pSubList->pClipper) &&
				    !SURFACE_LOST(surf_lcl))
	{
	    DWORD dwNumSprites = pSubList->dwCount;
	    LPDDSPRITEI sprite = &pSubList->sprite[0];
	    BOOL bDeleteSprite = FALSE;
	    DWORD j;

	    /*
	     * No, the process for this sublist is NOT being terminated.
	     * Check if the source surfaces for any sprites are lost.
	     */
	    for (j = 0; j < dwNumSprites; ++j)
	    {
    		LPDIRECTDRAWSURFACE pSrcSurf = sprite[j].lpDDSSrc;
		LPDDRAWI_DDRAWSURFACE_INT surf_src_int = (LPDDRAWI_DDRAWSURFACE_INT)pSrcSurf;
		LPDDRAWI_DDRAWSURFACE_LCL surf_src_lcl = surf_src_int->lpLcl;

		if (SURFACE_LOST(surf_src_lcl))
		{
		    /*
		     * This surface is lost, so delete the reference.
		     */
		    sprite[j].lpDDSSrc = NULL;   // mark surface as null
		    bDeleteSprite = TRUE;    // remember sprite array needs fix-up
		}
	    }
	    /*
	     * If the source-surface pointer for any sprite in the sublist
	     * was set to null, remove the sprite from the sublist by moving
	     * the rest of the sprite array downward to fill the gap.
	     */
	    if (bDeleteSprite == TRUE)
	    {
		dwNumSprites = scrunchSubList(pSubList);
		bChangesMade = TRUE;   // remember change to master sprite list
	    }
	    if (dwNumSprites != 0)
	    {
		/*
		 * The sublist still contains sprites, so don't delete it.
		 */
		continue;   // go to next sublist
	    }
	}
	/*
	 * Delete the sublist.  The reason is that (1) the process that
	 * owns the sublist is being terminated, or (2) the sublist is
	 * associated with an invalid window, or (3) the source surface
	 * for every sprite in the sublist is a lost surface.
	 */
	MemFree(pSubList->pRgn);
	MemFree(pSubList);
	pMaster->pSubList[i] = NULL;	// mark sublist as null
	bDeleteSubList = TRUE;	   // remember we deleted sublist
    }
    /*
     * If the sublist pointer for any sublist in the master sprite
     * list was set to null, remove the null from the pointer array by
     * moving the rest of the pointer array downward to fill the gap.
     */
    if (bDeleteSubList)
    {
	dwNumSubLists = scrunchMasterSpriteList(pMaster);
	bChangesMade = TRUE;
    }
    /*
     * If any changes have been made to the master sprite list, tell
     * the driver to make the changes visible on the screen.
     */
    if (bChangesMade)
    {
	DWORD rc;
	LPDDHAL_SETSPRITEDISPLAYLIST pfn;
	DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData;
	LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pPrimary;
	LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = surf_int->lpLcl;
        LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl = surf_lcl->lpSurfMore->lpDD_lcl;

	/*
	 * Build a temporary display list that contains all the sprites
	 * in the revised master sprite list.
	 */
	pMaster->surf_lcl = surf_lcl;	  // used by buildTempDisplayList
#if 0
	pMaster->dwFlags = DDSSDL_BLTSPRITES;	// debug !!
#else
	pMaster->dwFlags = DDSSDL_OVERLAYSPRITES;   // used by buildTempDisplayList
#endif
	pHalData = buildTempDisplayList(pMaster);
	/*
	 * Pass the temp display list to the driver.
	 */
#if 0
	pfn = pdrv_lcl->lpDDCB->HELDDMiscellaneous2.SetSpriteDisplayList;  // debug !!
#else
	pfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous2.SetSpriteDisplayList;
#endif
        DOHALCALL(SetSpriteDisplayList, pfn, *pHalData, rc, 0);
    }

    if (dwNumSubLists == 0)
    {
	/*
	 * We deleted ALL the sublists from the master sprite list,
	 * so now we need to delete the master sprite list too.
	 */
	FreeMasterSpriteList(pdrv);
	return;
    }
    markSpriteObjects(pMaster);

}   /* ProcessSpriteCleanup */


/*
 * Global function for managing master sprite list.  This function is
 * called by InternalSurfaceRelease to remove all references in the
 * master sprite list to a surface interface object that is being
 * released.  The function also checks for lost surfaces in the
 * master sprite list.  If any changes are made to the master sprite
 * list, the driver is told to display those changes immediately.
 */
void RemoveSpriteSurface(LPDDRAWI_DIRECTDRAW_GBL pdrv,
			 LPDDRAWI_DDRAWSURFACE_INT surf_int)
{
    LPMASTERSPRITELIST pMaster = (LPMASTERSPRITELIST)pdrv->lpMasterSpriteList;
    LPDIRECTDRAWSURFACE pSurface = (LPDIRECTDRAWSURFACE)surf_int;
    LPDIRECTDRAWSURFACE pPrimary = pMaster->pSubList[0]->pPrimary;
    DWORD dwNumSubLists = pMaster->dwNumSubLists;
    BOOL bDeleteSubList = FALSE;
    BOOL bChangesMade = FALSE;
    DWORD i;

    DDASSERT(pMaster != NULL);	  // error -- surface shouldn't be marked!

    /*
     * Before making changes to the master sprite list, we first
     * unmark all clipper and surface objects in the list.  After
     * the changes are completed, we will again mark the objects
     * that are referenced in the revised master sprite list.
     */
    unmarkSpriteObjects(pMaster);

    /*
     * Each sublist of the master sprite list contains all the sprites
     * that are to appear within a particular window of a shared primary.
     * Stored with each sublist is the primary surface object for the
     * window, and also the source surface objects for each sprite in the
     * sublist.  These surfaces are checked against pSurface and if a
     * match is found, the surface reference is deleted from the sublist.
     */
    for (i = 0; i < dwNumSubLists; ++i)
    {
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDIRECTDRAWSURFACE pDestSurf = pSubList->pPrimary;
	LPDDRAWI_DDRAWSURFACE_INT surf_dest_int = (LPDDRAWI_DDRAWSURFACE_INT)pDestSurf;
	LPDDRAWI_DDRAWSURFACE_LCL surf_dest_lcl = surf_dest_int->lpLcl;

	/*
	 * If this sublist's primary surface object is being released, delete
	 * the sublist.  We also check for lost surfaces and delete any we find.
	 */
	if (pDestSurf != pSurface && validClipperWindow(pSubList->pClipper) &&
				    !SURFACE_LOST(surf_dest_lcl))
	{
	    DWORD dwNumSprites = pSubList->dwCount;
	    LPDDSPRITEI sprite = &pSubList->sprite[0];
	    BOOL bDeleteSprite = FALSE;
	    DWORD j;

	    /*
	     * No, the primary surface object for this sublist is NOT
	     * being released, but perhaps the source surface for one
	     * or more of the sprites in this sublist is being released.
	     */
	    for (j = 0; j < dwNumSprites; ++j)
	    {
    		LPDIRECTDRAWSURFACE pSrcSurf = sprite[j].lpDDSSrc;
		LPDDRAWI_DDRAWSURFACE_INT surf_src_int = (LPDDRAWI_DDRAWSURFACE_INT)pSrcSurf;
		LPDDRAWI_DDRAWSURFACE_LCL surf_src_lcl = surf_src_int->lpLcl;

		if (pSrcSurf == pSurface || SURFACE_LOST(surf_src_lcl))
		{
		    /*
		     * This surface either is being released or is lost.
		     * In either case, we delete the reference.
		     */
		    sprite[j].lpDDSSrc = NULL;   // mark surface as null
		    bDeleteSprite = TRUE;    // remember sprite array needs fix-up
		}
	    }
	    /*
	     * If the source-surface pointer for any sprite in the sublist
	     * was set to null, remove the sprite from the sublist by moving
	     * the rest of the sprite array downward to fill the gap.
	     */
	    if (bDeleteSprite == TRUE)
	    {
		dwNumSprites = scrunchSubList(pSubList);
		bChangesMade = TRUE;   // remember change to master sprite list
	    }
	    if (dwNumSprites != 0)
	    {
		/*
		 * The sublist still contains sprites, so don't delete it.
		 */
		continue;   // go to next sublist
	    }
	}
	/*
	 * Delete the sublist.  The reason is that (1) the primary surface
	 * object for the sublist is being released, or (2) the sublist is
	 * associated with an invalid window, or (3) the source surface
	 * for every sprite in the sublist is either being released or is
	 * a lost surface.
	 */
	MemFree(pSubList->pRgn);
	MemFree(pSubList);
	pMaster->pSubList[i] = NULL;	// mark sublist as null
	bDeleteSubList = TRUE;	   // remember we deleted sublist
    }
    /*
     * If the sublist pointer for any sublist in the master sprite
     * list was set to null, remove the null from the pointer array by
     * moving the rest of the pointer array downward to fill the gap.
     */
    if (bDeleteSubList)
    {
	dwNumSubLists = scrunchMasterSpriteList(pMaster);
	bChangesMade = TRUE;
    }
    /*
     * If any changes have been made to the master sprite list, tell
     * the driver to make the changes visible on the screen.
     */
    if (bChangesMade)
    {
	DWORD rc;
	LPDDHAL_SETSPRITEDISPLAYLIST pfn;
	DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData;
	LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pPrimary;
	LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = surf_int->lpLcl;
        LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl = surf_lcl->lpSurfMore->lpDD_lcl;

	/*
	 * Build a temporary display list that contains all the sprites
	 * in the revised master sprite list.
	 */
	pMaster->surf_lcl = surf_lcl;	 // used by buildTempDisplayList
#if 0
	pMaster->dwFlags = DDSSDL_BLTSPRITES;	// debug !!
#else
	pMaster->dwFlags = DDSSDL_OVERLAYSPRITES;   // used by buildTempDisplayList
#endif
	pHalData = buildTempDisplayList(pMaster);
	/*
	 * Pass the temp display list to the driver.
	 */
#if 0
	pfn = pdrv_lcl->lpDDCB->HELDDMiscellaneous2.SetSpriteDisplayList;  // debug !!
#else
	pfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous2.SetSpriteDisplayList;
#endif
        DOHALCALL(SetSpriteDisplayList, pfn, *pHalData, rc, 0);
    }

    if (dwNumSubLists == 0)
    {
	/*
	 * We deleted ALL the sublists from the master sprite list,
	 * so now we need to delete the master sprite list too.
	 */
	FreeMasterSpriteList(pdrv);
	return;
    }
    markSpriteObjects(pMaster);

}   /* RemoveSpriteSurface */


/*
 * Global function for managing master sprite list.  This function is
 * called by InternalClipperRelease to remove all references in the
 * master sprite list to a clipper object that is being released.
 * The function also checks for lost surfaces in the master sprite
 * list.  If any changes are made to the master sprite list, the
 * driver is told to display those changes immediately.
 */
void RemoveSpriteClipper(LPDDRAWI_DIRECTDRAW_GBL pdrv,
			 LPDDRAWI_DDRAWCLIPPER_INT pclip_int)
{
    LPMASTERSPRITELIST pMaster = (LPMASTERSPRITELIST)pdrv->lpMasterSpriteList;
    LPDIRECTDRAWSURFACE pPrimary = pMaster->pSubList[0]->pPrimary;
    LPDIRECTDRAWCLIPPER pClipper = (LPDIRECTDRAWCLIPPER)pclip_int;
    DWORD dwNumSubLists = pMaster->dwNumSubLists;
    BOOL bDeleteSubList = FALSE;
    BOOL bChangesMade = FALSE;
    DWORD i;

    DDASSERT(pMaster != NULL);	  // error -- surface shouldn't be marked!

    /*
     * Before making changes to the master sprite list, we first
     * unmark all clipper and surface objects in the list.  After
     * the changes are completed, we will again mark the objects
     * that are referenced in the revised master sprite list.
     */
    unmarkSpriteObjects(pMaster);

    /*
     * Each sublist of the master sprite list contains all the sprites
     * that are to appear within a particular window of a shared primary.
     * Each sublist has a clipper (which may be NULL) to specify the
     * window's clip region.  Each sublist's clipper pointer is compared
     * with the specified pClipper pointer.  If a match is found, the
     * sublist and its clipper are removed from the master sprite list.
     */
    for (i = 0; i < dwNumSubLists; ++i)
    {
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDIRECTDRAWSURFACE pDestSurf = pSubList->pPrimary;
	LPDDRAWI_DDRAWSURFACE_INT surf_dest_int = (LPDDRAWI_DDRAWSURFACE_INT)pDestSurf;
	LPDDRAWI_DDRAWSURFACE_LCL surf_dest_lcl = surf_dest_int->lpLcl;

	/*
	 * If clipper object for this sublist is being released, delete it.
	 * (We also check for lost surfaces and delete any we find.)
	 */
	if (pSubList->pClipper != pClipper &&
				    validClipperWindow(pSubList->pClipper) &&
				    !SURFACE_LOST(surf_dest_lcl))
	{
	    DWORD dwNumSprites = pSubList->dwCount;
	    LPDDSPRITEI sprite = &pSubList->sprite[0];
	    BOOL bDeleteSprite = FALSE;
	    DWORD j;

	    /*
	     * No, the clipper for this sublist is NOT being released.
	     * Check if the source surfaces for any sprites are lost.
	     */
	    for (j = 0; j < dwNumSprites; ++j)
	    {
    		LPDIRECTDRAWSURFACE pSrcSurf = sprite[j].lpDDSSrc;
		LPDDRAWI_DDRAWSURFACE_INT surf_src_int = (LPDDRAWI_DDRAWSURFACE_INT)pSrcSurf;
		LPDDRAWI_DDRAWSURFACE_LCL surf_src_lcl = surf_src_int->lpLcl;

		if (SURFACE_LOST(surf_src_lcl))
		{
		    /*
		     * This surface is lost, so delete the reference.
		     */
		    sprite[j].lpDDSSrc = NULL;   // mark surface as null
		    bDeleteSprite = TRUE;    // remember sprite array needs fix-up
		}
	    }
	    /*
	     * If the source-surface pointer for any sprite in the sublist
	     * was set to null, remove the sprite from the sublist by moving
	     * the rest of the sprite array downward to fill the gap.
	     */
	    if (bDeleteSprite == TRUE)
	    {
		dwNumSprites = scrunchSubList(pSubList);
		bChangesMade = TRUE;   // remember change to master sprite list
	    }
	    if (dwNumSprites != 0)
	    {
		/*
		 * The sublist still contains sprites, so don't delete it.
		 */
		continue;   // go to next sublist
	    }
	}
	/*
	 * Delete the sublist.  The reason is that (1) the clipper for the
	 * sublist is being released, (2) the sublist is associated with an
	 * invalid window, or (3) the source surface for every sprite in
	 * the sublist is a lost surface.
	 */
	MemFree(pSubList->pRgn);
	MemFree(pSubList);
	pMaster->pSubList[i] = NULL;	// mark sublist as null
	bDeleteSubList = TRUE;	   // remember we deleted sublist
    }
    /*
     * If the sublist pointer for any sublist in the master sprite
     * list was set to null, remove the null from the pointer array by
     * moving the rest of the pointer array downward to fill the gap.
     */
    if (bDeleteSubList)
    {
	dwNumSubLists = scrunchMasterSpriteList(pMaster);
	bChangesMade = TRUE;
    }
    /*
     * If any changes have been made to the master sprite list, tell
     * the driver to make the changes visible on the screen.
     */
    if (bChangesMade)
    {
	DWORD rc;
	LPDDHAL_SETSPRITEDISPLAYLIST pfn;
	DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData;
	LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pPrimary;
	LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = surf_int->lpLcl;
        LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl = surf_lcl->lpSurfMore->lpDD_lcl;

	/*
	 * Build a temporary display list that contains all the sprites
	 * in the revised master sprite list.
	 */
	pMaster->surf_lcl = surf_lcl;	 // used by buildTempDisplayList
#if 0
	pMaster->dwFlags = DDSSDL_BLTSPRITES;	// debug !!
#else
	pMaster->dwFlags = DDSSDL_OVERLAYSPRITES;   // used by buildTempDisplayList
#endif
	pHalData = buildTempDisplayList(pMaster);
	/*
	 * Pass the temp display list to the driver.
	 */
#if 0
	pfn = pdrv_lcl->lpDDCB->HELDDMiscellaneous2.SetSpriteDisplayList;  // debug !!
#else
	pfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous2.SetSpriteDisplayList;
#endif
        DOHALCALL(SetSpriteDisplayList, pfn, *pHalData, rc, 0);
    }

    if (dwNumSubLists == 0)
    {
	/*
	 * We deleted ALL the sublists from the master sprite list,
	 * so now we need to delete the master sprite list too.
	 */
	FreeMasterSpriteList(pdrv);
	return;
    }
    markSpriteObjects(pMaster);

}   /* RemoveSpriteClipper */


/*
 * Helper function for managing master sprite list.  Check each sprite
 * to see if its surface has been lost.  Also check each sublist to
 * see if its window still exists.  Sprites with lost surfaces are
 * deleted from the master sprite list.  Also, sublists with defunct
 * windows are deleted.  Before calling this function, call
 * unmarkSpriteObjects().
 */
static void removeLostSpriteSurfaces(LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    DWORD i;
    DWORD dwNumSubLists;
    LPMASTERSPRITELIST pMaster = pdrv->lpMasterSpriteList;
    BOOL bDeleteSubList = FALSE;

    if (pMaster == NULL)
    {
    	return;    // nothing to do -- bye!
    }

    dwNumSubLists = pMaster->dwNumSubLists;
    DDASSERT(dwNumSubLists != 0);

    /*
     * Each iteration checks all the sprites in one sublist
     * to see if their source surfaces have been lost.
     */
    for (i = 0; i < dwNumSubLists; ++i)
    {
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];

	/*
	 * Verify that clipper for this sublist has a valid window handle.
	 */
	if (validClipperWindow(pSubList->pClipper))
	{
	    LPDDSPRITEI sprite = &pSubList->sprite[0];
	    DWORD dwNumSprites = pSubList->dwCount;
	    BOOL bDeleteSprite = FALSE;
	    DWORD j;

	    DDASSERT(dwNumSprites != 0);

	    /*
	     * Yes, clipper's window handle is valid.  Now check to see if
	     * any of the sprites in the sublist have lost source surfaces.
	     */
	    for (j = 0; j < dwNumSprites; ++j)
	    {
		LPDIRECTDRAWSURFACE pSrcSurf = sprite[j].lpDDSSrc;
		LPDDRAWI_DDRAWSURFACE_INT surf_src_int = (LPDDRAWI_DDRAWSURFACE_INT)pSrcSurf;
		LPDDRAWI_DDRAWSURFACE_LCL surf_src_lcl = surf_src_int->lpLcl;

		if (SURFACE_LOST(surf_src_lcl))    // is this surface lost?
		{
		    sprite[j].lpDDSSrc = NULL;   // yes, set surface ptr to null
		    bDeleteSprite = TRUE;	 // remember sublist needs fix-up
		}
	    }
	    /*
	     * If the source-surface pointer for any sprite in the sublist
	     * was set to null, remove the sprite from the sublist by moving
	     * the rest of the sprite array downward to fill the gap.
	     */
	    if (bDeleteSprite == TRUE)
	    {
		dwNumSprites = scrunchSubList(pSubList);
	    }
	    if (dwNumSprites != 0)
	    {
		/*
		 * The sublist still contains sprites, so don't delete it.
		 */
		continue;   // go to next sublist
	    }
	}
	/*
	 * Delete the sublist.  The reason is either that the window
	 * handle associated with this sublist's clipper is not valid,
	 * or that all the sprites in the sublist have been deleted.
	 */
	MemFree(pSubList->pRgn);
	MemFree(pSubList);
	pMaster->pSubList[i] = NULL;	// mark sublist as null
	bDeleteSubList = TRUE;	   // remember we deleted sublist
	
    }
    /*
     * If the sublist pointer for any sublist in the master sprite
     * list was set to null, remove the null from the pointer array by
     * moving the rest of the pointer array downward to fill the gap.
     */
    if (bDeleteSubList)
    {
	scrunchMasterSpriteList(pMaster);

	if (pMaster->dwNumSubLists == 0)
	{
    	    FreeMasterSpriteList(pdrv);    // delete master sprite list
	}
    }
}   /* removeLostSpriteSurfaces */


/*
 * This is a helper function for updateMasterSpriteList().  It alloc's
 * a sublist and copies the new sprite display list into the sublist.
 * If pSubList already points to a buffer that is large enough, the new
 * sublist will be created in this buffer.  Otherwise, a new buffer
 * will be alloc'd (but the old buffer isn't freed -- that's left up to
 * the caller).  Arg pHalData points to the sprite display list from
 * the app.  The return value is a pointer to the new sublist.
 */
static LPSPRITESUBLIST createSpriteSubList(LPSPRITESUBLIST pSubList,
				    DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData,
				    LPDIRECTDRAWSURFACE pPrimary)
{
    LPDDSPRITEI *ppSprite;
    LPDDSPRITEI sprite;
    // pointers to local and global surface objects
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = pHalData->lpDDSurface;
    LPDDRAWI_DDRAWSURFACE_GBL surf = surf_lcl->lpGbl;
    // number of sprites in new display list:
    DWORD dwNumSprites = pHalData->dwCount;
    // size (in bytes) of new sublist:
    DWORD size = sizeof(SPRITESUBLIST) +
			    (dwNumSprites-1)*sizeof(DDSPRITEI);

    DDASSERT(dwNumSprites != 0);	

    /*
     * If old sublist buffer is null or too small or too big,
     * allocate a new sublist buffer that's the correct size.
     */
    if (pSubList == NULL || pSubList->dwSize < size ||
		pSubList->dwSize > size + 8*sizeof(DDSPRITEI))
    {
	/*
	 * Allocate a new sublist that's just a tad larger than
	 * necessary so that we have a little room to grow in.
	 */
	size += 4*sizeof(DDSPRITEI);	   // add some padding
	pSubList = (LPSPRITESUBLIST)MemAlloc(size);
	if (pSubList == NULL)
	{
	    return NULL;    // error -- out of memory
	}
	pSubList->dwSize = size;    // remember how big buffer is
    }
    /*
     * Initialize sublist buffer.
     */
    pSubList->pPrimary = pPrimary;    // primary surface (interface object)
    pSubList->pClipper = (LPDIRECTDRAWCLIPPER)surf_lcl->lpSurfMore->lpDDIClipper;
    pSubList->dwProcessId = GETCURRPID();
    pSubList->dwCount = dwNumSprites;    // number of sprites in sublist
    pSubList->pRgn = NULL;
    /*
     * To keep things simple, the master sprite display list always stores
     * sprites in front-to-back order, regardless of how callers order them.
     * The loop below copies the sprites into a contiguous array of sprites.
     */
    sprite = &pSubList->sprite[0];             // array of sprites
    ppSprite = pHalData->lplpDDSprite;   // array of sprite pointers

    if (pHalData->dwFlags & DDSSDL_BACKTOFRONT)
    {
	int i, j;

	// Reverse original back-to-front ordering of sprites.
	for (i = 0, j = (int)dwNumSprites-1; j >= 0; ++i, --j)
	{
    	    memcpy(&sprite[i], ppSprite[j], sizeof(DDSPRITEI));
	}
    }
    else
    {
	int i;

	// Preserve original front-to-back ordering of sprites.
	for (i = 0; i < (int)dwNumSprites; ++i)
	{
    	    memcpy(&sprite[i], ppSprite[i], sizeof(DDSPRITEI));
	}
    }
    return (pSubList);    // return completed sublist

}  /* createSpriteSubList */


/*
 * This routine adds a new display list to the master sprite display list,
 * which keeps track of all overlay sprites currently displayed on the shared
 * primary.  Don't call it if (1) the sprites are blitted or (2) the primary
 * is not shared.  The update replaces the display list for the affected
 * window, but leaves the display lists for all other windows unchanged.
 * Arg surf_lcl points to the primary.  Input arg **ppHalData is the HAL
 * callback struct that specifies the new display list.  If the original
 * sprite display list in **ppHalData can be used in place of a master
 * display list without zapping sprites in other windows.  Otherwise, the
 * routine sets *ppHalData to point to a master sprite list that contains
 * the overlay sprites for all windows.
 */
static HRESULT updateMasterSpriteList(LPDIRECTDRAWSURFACE pPrimary,
				      DDHAL_SETSPRITEDISPLAYLISTDATA **ppHalData)
{
    DWORD i;
    LPDIRECTDRAWCLIPPER pClipper;
    DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData;
    LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pPrimary;
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = surf_int->lpLcl;
    LPDDRAWI_DDRAWSURFACE_MORE surf_more = surf_lcl->lpSurfMore;
    LPDDRAWI_DIRECTDRAW_GBL pdrv = surf_more->lpDD_lcl->lpGbl;
    DWORD dwProcessId;
    LPMASTERSPRITELIST pMaster;
    LPSPRITESUBLIST pSubList;
    DWORD dwNumSprites = (*ppHalData)->dwCount;   // number of sprites in display list

    /*
     * Get pointer to master sprite list.
     */
    pMaster = (LPMASTERSPRITELIST)pdrv->lpMasterSpriteList;

    if (pMaster != NULL)
    {
	/*
	 * A master sprite list already exists.
	 */
#ifdef WIN95
	if (pMaster->dwModeCreatedIn != pdrv->dwModeIndex)   // current mode index
#else
        if (!EQUAL_DISPLAYMODE(pMaster->dmiCreated, pdrv->dmiCurrent))
#endif
	{
	    /*
	     * The master sprite list was created in a different video mode
	     * and is therefore no longer valid.  We rely on the mini-vdd
	     * driver remembering to turn off all overlay sprites when a
	     * mode change occurs, so they should already be turned off.
	     * All we do here is to update our internal data structures.
	     */
	    FreeMasterSpriteList(pdrv);
	    pMaster = NULL;
	}
	else
	{
	    /*
	     * Between calls to SetSpriteDisplayList, all surface and clipper
	     * objects in the master sprite list are marked so that we will be
	     * notified if any of these objects are released, invalidating our
	     * references to them.  We now unmark all surface/clipper objects
	     * in the master sprite list so we can update the references.
	     */
	    unmarkSpriteObjects(pMaster);
	    /*
	     * Remove any references to lost surfaces from master sprite list.
	     */
	    removeLostSpriteSurfaces(pdrv);	  // can delete master sprite list
	    /*
	     * Just in case the call above deleted the master sprite list...
	     */
	    pMaster = (LPMASTERSPRITELIST)pdrv->lpMasterSpriteList;
	}
    }

    /*
     * Has the master sprite list been created yet?
     */
    if (pMaster == NULL)
    {
	LPDDRAWI_DDRAWSURFACE_GBL surf = surf_lcl->lpGbl;

	/*
	 * No, the master sprite list has not been created.
	 */
	if (dwNumSprites == 0)
	{
	    /*
	     * The new display list is empty, so don't bother
	     * to create the master sprite list.
	     */
	    return (DD_OK);   // nothing to do -- bye!
	}
	/*
	 * The new display list is not empty, so we will now
	 * create the master sprite list and copy the new display
	 * list into the initial sublist of the master sprite list.
	 */
	pMaster = (LPMASTERSPRITELIST)MemAlloc(sizeof(MASTERSPRITELIST));
	if (pMaster == NULL)
	{
    	    return (DDERR_OUTOFMEMORY);    // error -- out of memory
	}
	/*
	 * Initialize the values in the master list header structure.
	 */
	pMaster->pdrv = pdrv;
	pMaster->surf_lcl = surf_lcl;	 // primary surface (local object)
	SetRect(&pMaster->rcPrimary, 0, 0, surf->wWidth, surf->wHeight);
	pMaster->dwFlags = (*ppHalData)->dwFlags & (DDSSDL_WAIT |
#if 0
						    DDSSDL_BLTSPRITES);	   // debug!!
#else
						    DDSSDL_OVERLAYSPRITES);
#endif
#ifdef WIN95
        pMaster->dwModeCreatedIn = pdrv->dwModeIndex;   // current mode index
#else
        pMaster->dmiCreated = pdrv->dmiCurrent;
#endif
	pMaster->pBuffer = NULL;
	/*
	 * Copy the new sprite display list into the initial sublist.
	 */
	pMaster->dwNumSubLists = 1;
	pMaster->pSubList[0] = createSpriteSubList(NULL, *ppHalData, pPrimary);
	if (pMaster->pSubList[0] == NULL)
	{
    	    MemFree(pMaster);
	    return (DDERR_OUTOFMEMORY);
	}
	/*
	 * Mark all the surface and clipper objects that are
	 * referenced in the new master sprite list.
         */
	markSpriteObjects(pMaster);
	/*
	 * We've succeeded in creating a master sprite list.  Load the
	 * pointer to the master list into the global DirectDraw object.
	 */
        pdrv->lpMasterSpriteList = (LPVOID)pMaster;

	return (DD_OK);    // new master sprite list completed
    }
    /*
     * The master sprite list was created previously.  There are
     * three possibilities at this point (#1 is most likely):
     *  1) We're REPLACING a sublist in the master sprite list.
     *     In this case, the new display list contains one or
     *     more sprites and the pClipper and ProcessId of the new
     *     display list will match those stored in a sublist.
     *  2) We're ADDING a new sublist to the master sprite list.
     *     In this case, the new display list contains one or
     *     more sprites but the pClipper and ProcessId of the
     *     new display list don't match those of any sublist.
     *  3) We're DELETING a sublist from the master sprite list.
     *     In this case, the new display list is empty (sprite
     *     count = 0) and the pClipper and ProcessId of the new
     *     display list match those stored with a sublist.
     */
    pClipper = (LPDIRECTDRAWCLIPPER)(surf_more->lpDDIClipper);
    dwProcessId = GETCURRPID();
    pMaster->surf_lcl = surf_lcl;   // primary surface (local object)
    pMaster->dwFlags = (*ppHalData)->dwFlags & (DDSSDL_WAIT |
#if 0
						DDSSDL_BLTSPRITES);   // debug !!
#else
						DDSSDL_OVERLAYSPRITES);
#endif
    for (i = 0; i < pMaster->dwNumSubLists; ++i)
    {
	/*
	 * Look for a sublist with a pointer to the same clipper object.
	 * To handle the case pClipper = NULL, we compare process IDs also.
	 */
	if (pMaster->pSubList[i]->pClipper == pClipper &&
			pMaster->pSubList[i]->dwProcessId == dwProcessId)
	{
	    break;    // found a sublist with matching pClipper and dwProcessId
	}
    }
    if (i == pMaster->dwNumSubLists)
    {
	/*
	 * The pClipper and Process ID of the new display list don't
	 * match those of any of the current sublists.  This means
	 * that a new window has begun displaying overlay sprites.
	 */
	if (dwNumSprites == 0)
	{
	    /*
	     * The new display list is empty, so don't bother adding
	     * a new (empty) sublist to the master sprite list.
	     */
	    markSpriteObjects(pMaster);
	    return (DD_OK);    // nothing to do -- bye!
	}
	/*
	 * Add a new sublist to the master sprite list and copy the
	 * new display list into the new sublist.
	 */
	pSubList = createSpriteSubList(NULL, *ppHalData, pPrimary);
	if (pSubList == NULL)
	{
    	    return (DDERR_OUTOFMEMORY);    // error -- out of memory
	}
	if (i != MAXNUMSPRITESUBLISTS)
	{
	    /*
	     * Add the new sublist to the master sprite list.
	     */
	    pMaster->dwNumSubLists++;
            pMaster->pSubList[i] = pSubList;
	}
	else
	{
	    /*
	     * Oops.  The master sprite list already contains the maximum
	     * number of sublists.  I guess I'll just delete one of the
	     * other sublists so I can add the new sublist.  (If anybody
	     * complains loud enough, we can get rid of the fixed limit.)
	     */
	    MemFree(pMaster->pSubList[i-1]);
            pMaster->pSubList[i-1] = pSubList;
	}
    }
    else
    {
	/*
	 * We've found an existing sublist that matches the new display list's
	 * pClipper and ProcessId (the sublist contains the old display list
	 * for the window in which the new display list is to appear).
	 */
	if (dwNumSprites != 0)
	{
	    /*
	     * Since the new display list is not empty, we will copy it
	     * into the sublist that contains the old display list for
	     * the same window, overwriting the old display list.
	     */
	    pSubList = createSpriteSubList(pMaster->pSubList[i],
					    *ppHalData, pPrimary);
	    if (pSubList == NULL)
	    {
		/*
		 * An allocation error has occurred.  (Note:  The original
		 * value of pMaster->pSubList[i] has not been altered.)
		 */
		return (DDERR_OUTOFMEMORY);    // error -- out of memory
	    }
	    if (pSubList != pMaster->pSubList[i])
	    {
    		/*
		 * The createSpriteSubList call had to allocate a new
		 * sublist, so now we need to free the old one.
		 */
		MemFree(pMaster->pSubList[i]);
                pMaster->pSubList[i] = pSubList;
	    }
	    if (pMaster->dwNumSubLists == 1)
	    {
		/*
		 * Only one window is displaying overlay sprites, so the
		 * new display list contains the same sprites as the master
		 * sprite list.  Don't bother to construct a temp display
		 * list to contain all the sprites in the master sprite list.
		 */
		return (DD_OK);
	    }
	}
	else
	{
	    /*
	     * The new display list is empty.  In this case, we just delete
	     * the sublist containing the old display list for the same window.
	     * This will leave a hole in the array of sublist pointers that we
	     * fill by moving all the higher members in the array down by one.
	     */
	    MemFree(pMaster->pSubList[i]);    // free sublist
	    if (pMaster->dwNumSubLists == 1)
	    {
		/*
		 * We have just deleted the only sublist, so the master sprite
		 * list is now empty.  Free the master sprite list and return.
		 */
		FreeMasterSpriteList(pdrv);
		return (DD_OK);
	    }
	    // Delete the sublist from the master sprite list.
	    pMaster->pSubList[i] = NULL;
	    scrunchMasterSpriteList(pMaster);
	}
    }
    /*
     * We have finished updating the master sprite list.  Mark all
     * surface and clipper objects referenced in the master sprite list.
     */
    markSpriteObjects(pMaster);
    /*
     * The final step is to build a temporary display list that
     * contains all the sprites in the master sprite list.
     * The caller can then pass this display list to the driver.
     */
    pHalData = buildTempDisplayList(pMaster);
    if (!pHalData)
    {
	return (DDERR_OUTOFMEMORY);    // error -- out of memory
    }
    *ppHalData = pHalData;   // update caller's display-list pointer
    return (DD_OK);

}  /* updateMasterSpriteList */


/*
 * IDirectDrawSurface4::SetSpriteDisplayList -- API call
 */
HRESULT DDAPI DD_Surface_SetSpriteDisplayList(
		    LPDIRECTDRAWSURFACE lpDDDestSurface,
		    LPDDSPRITE *lplpDDSprite,
		    DWORD dwCount,
		    DWORD dwSize,
		    LPDIRECTDRAWSURFACE lpDDTargetSurface,
		    DWORD dwFlags)
{

    /*
     * Fixed-size buffer for containing clip region data
     */
    struct
    {
	RGNDATAHEADER rdh;
	RECT clipRect[6];
    } myRgnBuffer;

    DWORD	rc;
    DDHAL_SETSPRITEDISPLAYLISTDATA ssdld;
    DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData;
    LPDDHAL_SETSPRITEDISPLAYLIST   pfn;
    LPDDRAWI_DDRAWSURFACE_INT	   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	   this;
    LPDDRAWI_DDRAWSURFACE_INT	   targ_int;
    LPDDRAWI_DDRAWSURFACE_LCL	   targ_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	   targ;
    LPDDRAWI_DIRECTDRAW_LCL        pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	   pdrv;
    LPDIRECTDRAWCLIPPER 	   pClipper;
    DWORD 	dwDDPFDestFlags;
    SPRITE_CAPS	caps;
    LPRGNDATA 	pRgn;
    RECT 	rcDestSurf;
    DWORD 	ifirst;
    int		i;

    DDASSERT(sizeof(DDRGBA)==sizeof(DWORD));  // we rely on this
    DDASSERT(sizeof(DDSPRITEI)==sizeof(DDSPRITE));  // and this

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_SetSpriteDisplayList");

    /*
     * Validate parameters
     */
    TRY
    {
	/*
	 * Validate destination surface.
	 */
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDDestSurface;

	if (!VALID_DIRECTDRAWSURFACE_PTR(this_int))
	{
	    DPF_ERR("Invalid dest surface");
	    LEAVE_BOTH();
	    return DDERR_INVALIDOBJECT;
	}

	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	/*
	 * Check for lost dest surface.
	 */
	if (SURFACE_LOST(this_lcl))
	{
	    DPF_ERR("Dest surface lost");
	    LEAVE_BOTH();
	    return DDERR_SURFACELOST;
	}

#if 0
	if (!dwCount)		
	{
            lplpDDSprite = NULL;   // necessary?
	}
#endif

	/*
	 * Perform initial validation of arguments.
	 */
	if (dwCount && !lplpDDSprite ||	   // if count nonzero, is ptr valid?
	    dwSize != sizeof(DDSPRITE) ||	   // structure size ok?
	    dwFlags & ~DDSSDL_VALID ||			   // any bogus flag bits set?
	    dwFlags & DDSSDL_PAGEFLIP && dwFlags & DDSSDL_BLTSPRITES ||  // no flip if blt
	    !(dwFlags & (DDSSDL_OVERLAYSPRITES | DDSSDL_BLTSPRITES)) ||	 // neither flag set?
	    !(~dwFlags & (DDSSDL_OVERLAYSPRITES | DDSSDL_BLTSPRITES)))   // both flags set?
	{
	    DPF_ERR("Invalid arguments") ;
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}

	/*
         * The dest surface is not allowed to be palette-indexed.
	 */
        dwDDPFDestFlags = getPixelFormatFlags(this_lcl);

	if (dwDDPFDestFlags & (DDPF_PALETTEINDEXED1 | DDPF_PALETTEINDEXED2 |
			       DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8))
	{
	    DPF_ERR( "Dest surface must not be palette-indexed" );
	    LEAVE_BOTH();
	    return DDERR_INVALIDSURFACETYPE;
	}

	pdrv = this->lpDD;			   	
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;

	/*
	 * Is device busy?
	 */
	if (*(pdrv->lpwPDeviceFlags) & BUSY)
	{
	    DPF(2, "BUSY");
	    LEAVE_BOTH();
	    return DDERR_SURFACEBUSY;
	}

	/*
	 * Determine whether the sprites are to be overlayed or blitted.
	 */
	caps.bOverlay = !(dwFlags & DDSSDL_BLTSPRITES);

	if (caps.bOverlay)
	{
	    /*
	     * Dest surface for overlay sprite must be primary surface.
	     */
	    if (!(this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
	    {
		DPF_ERR("Dest is not primary surface");
		LEAVE_BOTH();
		return DDERR_INVALIDPARAMS;    // not primary surface
	    }
	}
	else
	{
	    /*
	     * We do not allow blitting to an optimized surface.
	     */
	    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
	    {
		DPF_ERR("Can't blt optimized surfaces") ;
		LEAVE_BOTH();
		return DDERR_INVALIDPARAMS;
	    }
	}

	/*
	 * Will this call flip the primary surface?
	 */
	if (!(dwFlags & DDSSDL_PAGEFLIP))
	{
	    // no flip
	    targ_lcl = NULL;
	}
	else
	{
            LPDDRAWI_DDRAWSURFACE_INT next_int;
            LPDDRAWI_DDRAWSURFACE_GBL_MORE targmore;

	    /*
	     * Yes, a page flip is requested.  Make sure the destination
	     * surface is a front buffer and is flippable.
	     */
	    if (~this_lcl->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_FLIP))
	    {
		DPF_ERR("Dest surface is not flippable");
		LEAVE_BOTH();
		return DDERR_NOTFLIPPABLE;
	    }
	    if (this->dwUsageCount > 0)
	    {
		DPF_ERR("Can't flip locked surface");
		LEAVE_BOTH();
		return DDERR_SURFACEBUSY;
	    }
	    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE &&
					pdrv->lpExclusiveOwner != pdrv_lcl)
	    {
		DPF_ERR("Can't flip without exclusive access");
		LEAVE_BOTH();
		return DDERR_NOEXCLUSIVEMODE;
	    }
	    /*
	     * Get backbuffer surface attached to dest surface.
	     */
	    next_int = FindAttachedFlip(this_int);

	    if (next_int == NULL)
	    {
		DPF_ERR("No backbuffer surface to flip to");
		LEAVE_BOTH();
		return DDERR_NOTFLIPPABLE;
	    }
	    /*
	     * Validate flip override surface, if one is specified.
	     */
            targ_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDTargetSurface;

	    if (targ_int != NULL)
	    {
		if (!VALID_DIRECTDRAWSURFACE_PTR(targ_int))
		{
		    DPF_ERR("Invalid flip override surface");
		    LEAVE_BOTH();
		    return DDERR_INVALIDOBJECT;
		}
	
		targ_lcl = targ_int->lpLcl;
		targ = targ_lcl->lpGbl;

		/*
		 * Verify that the flip override surface is part of the destination
		 * surface's flipping chain.  Note that next_int already points to
		 * the first buffer in the flipping chain.
		 */
		while (next_int != this_int && next_int->lpLcl != targ_lcl)
		{
                    next_int = FindAttachedFlip(this_int);
		}

                if (next_int == this_int)
		{
		    // failed to find override surface in flipping chain
		    DPF_ERR("Flip override surface not part of flipping chain");
		    LEAVE_BOTH();
		    return DDERR_NOTFLIPPABLE;
		}
	    }
	    else
	    {
		/*
		 * No flip override surface is specified so use
		 * next backbuffer as target flip surface.
		 */
		targ_int = next_int;
		targ_lcl = targ_int->lpLcl;
		targ = targ_lcl->lpGbl;
	    }

            /*
	     * Make sure target flip surface is not lost or busy.
	     */
	    if (SURFACE_LOST(targ_lcl))
	    {
		DPF_ERR("Can't flip -- backbuffer surface is lost");
		LEAVE_BOTH();
		return DDERR_SURFACELOST;
	    }

            targmore = GET_LPDDRAWSURFACE_GBL_MORE(targ);
#if 0
	    if (targmore->hKernelSurface != 0)
	    {
		DPF_ERR("Can't flip -- kernel mode is using surface");
		LEAVE_BOTH();
		return DDERR_SURFACEBUSY;
	    }
#endif
	    /*
	     * Make sure front and back buffers are in same memory.
	     */
	    if ((this_lcl->ddsCaps.dwCaps & (DDSCAPS_SYSTEMMEMORY |
					       DDSCAPS_VIDEOMEMORY)) !=
                 (targ_lcl->ddsCaps.dwCaps & (DDSCAPS_SYSTEMMEMORY |
					       DDSCAPS_VIDEOMEMORY)))
	    {
		DPF_ERR("Can't flip between system/video memory surfaces");
		LEAVE_BOTH();
		return DDERR_INVALIDPARAMS;
	    }
	}  /* page flip */

	/*
	 * Validate display list pointer lplpSpriteDisplayList.
	 */
	if ( IsBadWritePtr((LPVOID)lplpDDSprite,
			    (UINT)dwCount*sizeof(LPDDSPRITE)) )
	{
	    DPF_ERR("Bad pointer to sprite display list");
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}

	/*
	 * Initialize structure containing caps bits for sprites.
	 */
	memset(&caps, 0, sizeof(SPRITE_CAPS));	
	caps.dwDestSurfCaps = this_lcl->ddsCaps.dwCaps;   // dest surface caps
	caps.bOverlay = dwFlags & DDSSDL_OVERLAYSPRITES;   // TRUE if overlay sprites

	/*
	 * Initialize status variables bNoHEL and bNoHAL.  If bNoHEL is
	 * TRUE, this disqualifies the HEL from handling the driver call.
	 * If bNoHAL is TRUE, this disqualifies the hardware driver.
	 */
	caps.bNoHEL = dwFlags & (DDSSDL_HARDWAREONLY | DDSSDL_OVERLAYSPRITES);
	caps.bNoHAL = FALSE;

	/*
	 * A driver that specifies nonlocal video-memory caps that differ
	 * from its local video-memory caps is automatically disqualified
	 * because the currently specified nonlocal vidmem caps do not
	 * include alpha, filter, or transform caps.  Should we fix this?
	 */
        if (caps.dwDestSurfCaps & DDSCAPS_NONLOCALVIDMEM  &&
	    pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS)
	{
	    caps.bNoHAL = TRUE;
	}

	/*
	 * The assumption here is that the display list can be handled by
	 * the display hardware only if the dest surface and all the
	 * sprites are in video memory.  If one or more surfaces are in
	 * system memory, emulation is the only option.  We check the
	 * dest surface just below.  Later, we'll check each sprite in
	 * the list.  (Will this assumption still be valid in the future?)
	 */
	if (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
	{
	    caps.bNoHAL = TRUE;

	    if (caps.bNoHEL)
	    {
		DPF_ERR("Hardware can't show sprites on dest surface in system memory");
		LEAVE_BOTH();
		return DDERR_UNSUPPORTED;
	    }
	}

	DDASSERT(!(caps.bNoHEL && caps.bNoHAL));

	/*
	 * Each iteration of the for-loop below validates the DDSPRITE
	 * structure for the next sprite in the display list.
	 */
	for (i = 0; i < (int)dwCount; ++i)
	{
	    HRESULT ddrval = validateSprite(lplpDDSprite[i],
					    pdrv,
					    this_lcl,
					    &caps,
					    dwDDPFDestFlags);

	    if (ddrval != DD_OK)
	    {
		DPF(1, "...failed at sprite display list index = %d", i);
		LEAVE_BOTH();
		return ddrval;
	    }
	}

	DDASSERT(!(caps.bNoHEL && caps.bNoHAL));

	/*
	 * Will the sprites be blitted?  If so, they will alter dest surface.
	 */
	if (dwFlags & DDSSDL_BLTSPRITES)
	{
	    /*
	     *  Remove any cached run-length-encoded data for the source surface.
	     */
	    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
	    {
		extern void FreeRleData(LPDDRAWI_DDRAWSURFACE_LCL);  //in fasthel.c

		FreeRleData(this_lcl);
	    }

	    BUMP_SURFACE_STAMP(this);
	}
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
	DPF_ERR("Exception encountered validating parameters");
	LEAVE_BOTH();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Determine clipping region for destination surface.
     */
    // GetRgnData() call needs clipper and width/height of dest surface.
    pClipper = (LPDIRECTDRAWCLIPPER)this_lcl->lpSurfMore->lpDDIClipper;
    SetRect(&rcDestSurf, 0, 0, this->wWidth, this->wHeight);
    // We'll pass in a region buffer for GetRgnData() to use.
    myRgnBuffer.rdh.dwSize = sizeof(RGNDATAHEADER);
    myRgnBuffer.rdh.nRgnSize = sizeof(myRgnBuffer) - sizeof(RGNDATAHEADER);
    pRgn = GetRgnData(pClipper, &rcDestSurf, pdrv, (LPRGNDATA)&myRgnBuffer);
    if (pRgn == NULL)
    {
	DPF_ERR("Can't alloc memory for clipping region");
	LEAVE_BOTH();
	return DDERR_OUTOFMEMORY;
    }

    /*
     * Set up the HAL callback data for the sprite display list.  This
     * data structure will be passed directly to the driver either if
     * the sprites are blitted or if no other window or clipping region
     * contains overlay sprites.  Otherwise, the driver will receive a
     * temporary display list constructed by updateMasterSpriteList()
     * that contains all the overlay sprites in the master sprite list.
     */
    //ssdld.SetSpriteDisplayList = pfn;    // debug aid only -- no thunk
    ssdld.lpDD = pdrv;
    ssdld.lpDDSurface = this_lcl;
    ssdld.lplpDDSprite = (LPDDSPRITEI*)lplpDDSprite;
    ssdld.dwCount = dwCount;
    ssdld.dwSize = dwSize;
    ssdld.dwFlags = dwFlags & ~DDSSDL_WAIT;
    ssdld.dwRectCnt = pRgn->rdh.nCount;    // number of clip rects in region
    ssdld.lpRect = (LPRECT)&pRgn->Buffer;  // array of clip rects
    ssdld.lpDDTargetSurface = targ_lcl;

    /*
     * The "master sprite list" keeps track of the overlay sprites in all
     * the windows on a shared primary surface.  (It also keeps track of
     * the overlay sprites in all the clip regions of a full-screen app.)
     * The master sprite list keeps a record of the active overlay sprites
     * in each window (or clip region), as identified by its clipper object.
     * Whenever any window updates its overlay sprites, the update is first
     * recorded in the master sprite list.  Next, a temporary display list
     * containing all the overlay sprites in the master sprite list is passed
     * to the driver.  That way, the driver itself never has to keep track of
     * more than one overlay-sprite display list at a time.  The alternative
     * would be for the driver itself to keep track of the overlay sprites
     * for each window.  We have chosen to keep the driver code simple by
     * moving this bookkeeping into the DirectDraw runtime.
     */
    pHalData = &ssdld;
#if 0
    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)  // debug only !!
#else
    if (dwFlags & DDSSDL_OVERLAYSPRITES)
#endif
    {
	/*
	 * The new display list specifies overlay sprites, so we
	 * need to update the master sprite list.
	 */
	HRESULT ddrval = updateMasterSpriteList(lpDDDestSurface, &pHalData);

	if (ddrval != DD_OK)
	{
	    DPF_ERR( "Failed to update master sprite list" );
	    LEAVE_BOTH();
	    return ddrval;
	}
    }

    TRY
    {
	/*
	 * Given the choice, we would prefer to use the hardware driver
	 * rather than software emulation to process this display list.
	 */
	if (!caps.bNoHAL)
	{
	    /*
	     * Yes, we can use the hardware.  Get pointer to HAL callback.
	     */
	    pfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous2.SetSpriteDisplayList;

	    if (!pfn)
	    {
		caps.bNoHAL = TRUE;    // no hardware driver is available
	    }
	    else
	    {
		/*
		 * Tell the driver to begin processing the sprite display
		 * list.  We may have to wait if the driver is still busy
		 * with a previously requested drawing operation.
		 */
		do
		{
		    DOHALCALL_NOWIN16(SetSpriteDisplayList, pfn, *pHalData, rc, 0);  // caps.bNoHAL);
		    #ifdef WINNT
			DDASSERT(! (rc == DDHAL_DRIVER_HANDLED && pHalData->ddRVal == DDERR_VISRGNCHANGED));
		    #endif
	
		    if (rc != DDHAL_DRIVER_HANDLED || pHalData->ddRVal != DDERR_WASSTILLDRAWING)
		    {
			break;    // driver's finished for better or worse...
		    }
		    DPF(4, "Waiting...");
	
		} while (dwFlags & DDSSDL_WAIT);

		if (rc != DDHAL_DRIVER_HANDLED || pHalData->ddRVal == DDERR_UNSUPPORTED)
		{
		    caps.bNoHAL = TRUE;  // hardware driver couldn't handle callback
		}
		else if (pHalData->ddRVal != DD_OK)
		{
		    /*
		     * We want to just return with this error code instead
		     * of asking the HEL to process the display list.
		     */
		    caps.bNoHEL = TRUE;	 // disqualify HEL routine
		}
	    }
	}

	/*
	 * If the hardware was unable to handle the display list, we may
	 * have to let the HEL process it for us.
	 */
	if (caps.bNoHAL && !caps.bNoHEL)
	{
	    /*
	     * Have to use HEL support.  Get pointer to HEL emulation routine.
	     */
	    pfn = pdrv_lcl->lpDDCB->HELDDMiscellaneous2.SetSpriteDisplayList;

	    DDASSERT(pfn != NULL);

	    DOHALCALL_NOWIN16(SetSpriteDisplayList, pfn, *pHalData, rc, 0);  // caps.bNoHAL);
	}
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
	DPF_ERR("Exception encountered during sprite rendering");
	LEAVE_BOTH();
	return DDERR_EXCEPTION;
    }

    /*
     * If the previous GetRgnData() call had to dynamically alloc
     * a region buffer, we need to remember to free it now.
     */
    if (pRgn != (LPRGNDATA)&myRgnBuffer)
    {
    	MemFree(pRgn);
    }

    // Was there any driver support at all for this call?
    if (caps.bNoHAL && caps.bNoHEL)
    {
	DPF_ERR("No driver support for this call");
	LEAVE_BOTH();
	return DDERR_UNSUPPORTED;
    }

    // Did driver handle callback?
    if (rc != DDHAL_DRIVER_HANDLED)
    {
	DPF_ERR("Driver wouldn't handle callback");
	LEAVE_BOTH();
	return DDERR_UNSUPPORTED;
    }

    // Return now if driver handled callback without error.
    if (pHalData->ddRVal == DD_OK || pHalData->ddRVal == DDERR_WASSTILLDRAWING)
    {
    	LEAVE_BOTH();
	return pHalData->ddRVal;
    }

    /*
     * An error prevented the driver from showing all the sprites
     * in the list.  Which sprites did get shown?
     */
    if (pHalData->dwCount == dwCount)
    {
	// None of the sprites got shown
	DPF(1, "Driver failed to show any sprites in display list");
	LEAVE_BOTH();
	return pHalData->ddRVal;
    }
    DPF(1, "Driver failed sprite at disp list index #%d", pHalData->dwCount);

    DDASSERT(pHalData->dwCount < dwCount);

    if (pHalData->dwFlags & DDSSDL_BACKTOFRONT)
    {
	// Driver showed sprites from (dwCount-1) down to (pHalData->dwCount+1).
	ifirst = dwCount - 1;    // driver started at last sprite in list
    }
    else
    {
	// Driver showed sprites from 0 up to (pHalData->dwCount-1).
	ifirst = 0;   // driver started at first sprite in list
    }
    DPF(1, "Driver started with sprite at disp list index #%d", ifirst);

    LEAVE_BOTH();

    return pHalData->ddRVal;

}  /* DD_Surface_SetSpriteDisplayList */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddstream.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddstream.cpp
 *  Content:	DirectDraw surface file I/O
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   30-sep-97  jeffno  Original implementation
 *
 ***************************************************************************/

extern "C"
{
    #include "ddrawpr.h"
}

#include <ImgUtil.H>
#include "decoder.h"

/*
 * This routine takes a source surface freshly loaded from some file, and transfers
 * the bits to some target surface. Palette will be transferred also, if set.
 * dwFlags are as defined for CreateSurfaceFromFile.
 */
HRESULT TransferBitsToTarget(
    LPDIRECTDRAWSURFACE lpDDSource,
    LPDIRECTDRAWSURFACE4 lpDDSTarget,
    LPDDSURFACEDESC2 pDDSD,
    DWORD dwFlags)
{
    HRESULT                 hr =DD_OK;
    DDSURFACEDESC           ddsd;
    RECT                    rDest;
    LPDIRECTDRAWSURFACE4    lpDDSource4;

    /*
     * We need to transfer a palette to the target surface if required.
     * Don't do it if the app doesn't want a palette. Don't do it if there's
     * no palette in the working surface.
     */
    if ( (dwFlags & DDLS_IGNOREPALETTE) == 0)
    {
        LPDIRECTDRAWPALETTE pPal = NULL;
        hr = lpDDSource->GetPalette(&pPal);
        if (SUCCEEDED(hr))
        {
            /*
             * If the target surface isn't palettized, this will fail.
             * That's OK.
             */
            lpDDSTarget->SetPalette((LPDIRECTDRAWPALETTE2)pPal);
            pPal->Release();
        }
    }

    /*
     * If we aren't stretching or we're maintaining aspect ratio, then there's the possibility
     * of some of the target surface's pixels not being filled. Fill them with
     * phys color zero.
     * I threw in bilinear as well, because the current definition samples the target
     * even when full stretch.
     */
    if ( (dwFlags & (DDLS_MAINTAINASPECTRATIO|DDLS_BILINEARFILTER)) || ((dwFlags & DDLS_STRETCHTOFIT)==0) )
    {
        DDBLTFX ddbltfx;
        ddbltfx.dwSize = sizeof(ddbltfx);
        ddbltfx.dwFillColor = 0;
        /*
         * Ignore the error code. The nicest thing is to keep going anyway
         */
        lpDDSTarget->Blt(NULL,NULL,NULL,DDBLT_COLORFILL,&ddbltfx);
    }

    /*
     * Note that we always shrink the image to fit if necessary.
     * We never take the smaller subrect of the source when the passed-in
     * size is smaller than the image
     */

    /*
     * Set dest rect to the size of the image
     * Calling a v1 surface, so better pass proper size.
     */
    ddsd.dwSize =sizeof(DDSURFACEDESC);
    hr = lpDDSource->GetSurfaceDesc((LPDDSURFACEDESC)&ddsd);
    DDASSERT(SUCCEEDED(hr));
    SetRect(&rDest,0,0,ddsd.dwWidth,ddsd.dwHeight);

    if (dwFlags & DDLS_STRETCHTOFIT)
    {
        /*
         * Override the dest rect to the size passed in
         */
        SetRect(&rDest,0,0,pDDSD->dwWidth,pDDSD->dwHeight);
        if (dwFlags & DDLS_MAINTAINASPECTRATIO)
        {
            /*
             * Back off if necessary to maintain aspect ratio.
             * This calculates the dest width we need to maintain AR
             */
            DWORD dwProperWidth = ddsd.dwWidth*pDDSD->dwHeight/ddsd.dwHeight;
            if (dwProperWidth > pDDSD->dwWidth)
            {
                SetRect(&rDest,0,0,pDDSD->dwWidth,ddsd.dwHeight*pDDSD->dwWidth/ddsd.dwWidth);
            }
            else if (dwProperWidth < pDDSD->dwWidth)
            {
                SetRect(&rDest,0,0,dwProperWidth,pDDSD->dwHeight);
            }
        }

        DDASSERT(rDest.right <= (int) pDDSD->dwWidth);
        DDASSERT(rDest.bottom <= (int) pDDSD->dwHeight);
    }
    else
    {
        /*
         * If we're shrinking, we'll just stretch anyway. The alternative is to take
         * a smaller central subrect of the source image. That seems kinda useless.
         */
        if (pDDSD)
        {
            if (pDDSD->dwWidth < ddsd.dwWidth)
            {
                rDest.left=0;
                rDest.right = pDDSD->dwWidth;
            }
            if (pDDSD->dwHeight < ddsd.dwHeight)
            {
                rDest.top=0;
                rDest.bottom = pDDSD->dwHeight;
            }
        }
    }

    /*
     * Add space above/below to center the image in the dest
     */
    if (dwFlags & DDLS_CENTER)
    {
        OffsetRect(&rDest, (pDDSD->dwWidth - rDest.right)/2, (pDDSD->dwHeight - rDest.bottom)/2);
    }

    hr = lpDDSource->QueryInterface(IID_IDirectDrawSurface4, (void**) &lpDDSource4);
    if (SUCCEEDED(hr))
    {
        hr = lpDDSTarget->AlphaBlt(
            &rDest,
            lpDDSource4,
            NULL,
            ((dwFlags & DDLS_BILINEARFILTER)?DDABLT_BILINEARFILTER:0)|DDABLT_WAIT,
            NULL);
        if (FAILED(hr))
        {
            /*
             * ATTENTION: Sort of. At the moment, AlphaBlt refuses to blt to a palette-indexed surface.
             * We'll just try blt as a backup
             */
            hr = lpDDSTarget->Blt(
                &rDest,
                lpDDSource4,
                NULL,
                DDBLT_WAIT,
                NULL);
        }

        if (FAILED(hr))
        {
            DPF_ERR("Could not blt from temporary surface to target surface!");
        }

        lpDDSource4->Release();
    }
    return hr;
}

HRESULT CreateOrLoadSurfaceFromStream( LPDIRECTDRAW4 lpDD, IStream *pSource, LPDDSURFACEDESC2 pDDSD, DWORD dwFlags, LPDIRECTDRAWSURFACE4 * ppSurface, IUnknown * pUnkOuter)
{

    LPDDRAWI_DIRECTDRAW_INT		this_int;
    // validate arguments
    TRY
    {
        if( !VALID_PTR_PTR(ppSurface ) )
        {
            DPF_ERR("You must supply a valid surface pointer");
            return DDERR_INVALIDPARAMS;
        }

        *ppSurface = NULL;

	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
            DPF_ERR("Bad DirectDraw pointer");
	    return DDERR_INVALIDOBJECT;
	}

        if( !pSource )
        {
            DPF_ERR("You must supply a valid stream pointer");
            return DDERR_INVALIDPARAMS;
        }

        /*
         * Validate flags
         */
        if (dwFlags & ~DDLS_VALID)
        {
            DPF_ERR("Invalid flags");
            return DDERR_INVALIDPARAMS;
        }

        if (dwFlags & ~DDLS_VALID)
        {
            DPF_ERR("Invalid flags");
            return DDERR_INVALIDPARAMS;
        }

        //ATTENTION: DDLS_MERGEPALETTE isn't implemented. Implement it when the palette 2 interface goes in.
        if ( (dwFlags & (DDLS_IGNOREPALETTE|DDLS_MERGEPALETTE)) == (DDLS_IGNOREPALETTE|DDLS_MERGEPALETTE) )
        {
            DPF_ERR("Can only specify one of DDLS_IGNOREPALETTE or DDLS_MERGEPALETTE");
            return DDERR_INVALIDPARAMS;
        }

        if ( (dwFlags & DDLS_STRETCHTOFIT) || (dwFlags & DDLS_CENTER) )
        {
            if (!pDDSD)
            {
                DPF_ERR("Can't specify DDLS_STRETCHTOFIT or DDLS_CENTER without a DDSURFACEDESC2 with valid dwWidth and dwHeight");
                return DDERR_INVALIDPARAMS;
            }
            if ( ( (pDDSD->dwFlags & (DDSD_WIDTH|DDSD_HEIGHT)) == 0) || !pDDSD->dwWidth || !pDDSD->dwHeight )
            {
                DPF_ERR("Can't specify DDLS_STRETCHTOFIT or DDLS_CENTER without a DDSURFACEDESC2 with valid dwWidth and dwHeight");
                return DDERR_INVALIDPARAMS;
            }
        }

        if (! (dwFlags & DDLS_STRETCHTOFIT) )
        {
            if (dwFlags & (DDLS_BILINEARFILTER|DDLS_MAINTAINASPECTRATIO))
            {
                DPF_ERR("DDLS_STRETCHTOFIT required for DDLS_BILINEARFILTER or DDLS_MAINTAINASPECTRATIO");
                return DDERR_INVALIDPARAMS;
            }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	return DDERR_INVALIDPARAMS;
    }



    HRESULT hr = DD_OK;
    FILTERINFO ImgInfo;
    CImageDecodeEventSink EventSink;

    ZeroMemory(&ImgInfo, sizeof(ImgInfo));
    /*
     * Default to device's bit depth
     * This is no longer necessary. We always create a staging surface in the filter's
     * desired format.
     */
    //ImgInfo._colorMode = this_int->lpLcl->lpGbl->vmiData.ddpfDisplay.dwRGBBitCount;

    EventSink.Init(&ImgInfo);
    typedef HRESULT (*funcptr)(IStream*, IMapMIMEToCLSID*, IImageDecodeEventSink*);
    funcptr pfnDecodeImage;
    //EventSink->AddRef();
    EventSink.SetDDraw( lpDD );

    HINSTANCE hLibInst = LoadLibrary( "ImgUtil.dll" );
    if( hLibInst )
    {
        pfnDecodeImage = (funcptr) GetProcAddress(hLibInst, "DecodeImage");
        if( pfnDecodeImage )
        {
            hr = (*pfnDecodeImage)( pSource, NULL, (IImageDecodeEventSink *)&EventSink );
        }
        else
        {
            DPF_ERR( "GetProcAddress failure for DecodeImage in ImgUtil.dll" );
            hr = DDERR_UNSUPPORTED;
        }
        FreeLibrary( hLibInst );
    }
    else
    {
        DPF_ERR( "LoadLibrary failure on ImgUtil.dll" );
        hr = DDERR_UNSUPPORTED;
    }

    if( SUCCEEDED( hr ) )
    {
        LPDIRECTDRAWSURFACE lpDDS = EventSink.m_pFilter->m_pDDrawSurface;

        if (lpDDS)
        {
            DDSURFACEDESC2  ddsd;
            DDSURFACEDESC ddsdWorking;

            ZeroMemory(&ddsdWorking,sizeof(ddsdWorking));
            ddsdWorking.dwSize = sizeof(ddsdWorking);

            ZeroMemory(&ddsd,sizeof(ddsd));
            ddsd.dwSize = sizeof(ddsd);

            /*
             * The decode succeeded, so now marshal the bits into the requested surface type
             */
            if (pDDSD)
            {
                /*
                 * App cares about at least some of the parameters of the target surface.
                 * We'll take what they give us and potentially fill in some more.
                 */
                ddsd = *pDDSD;
            }

            /*
             * We may need some data from the original loaded surface.
             * Ignore the return code. It's better just to carry on.
             */
            hr = lpDDS->GetSurfaceDesc(&ddsdWorking);

            if ( (ddsd.dwFlags & (DDSD_WIDTH|DDSD_HEIGHT)) == 0 )
            {
                /*
                 * App doesn't care what size the surface is, so we'll setup
                 * the size for them.
                 */
                ddsd.dwFlags |= DDSD_WIDTH|DDSD_HEIGHT;
                ddsd.dwWidth = ddsdWorking.dwWidth;
                ddsd.dwHeight = ddsdWorking.dwHeight;
            }

            if ( (ddsd.dwFlags & DDSD_CAPS) == 0)
            {
                /*
                 * App doesn't care about surface caps. We'll give them offscreen plain
                 */
                ddsd.dwFlags |= DDSD_CAPS;
                ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
                ddsd.ddsCaps.dwCaps2 = 0;
                ddsd.ddsCaps.dwCaps3 = 0;
                ddsd.ddsCaps.dwCaps4 = 0;
            }

            if ( (ddsd.dwFlags & DDSD_PIXELFORMAT) == 0)
            {
                /*
                 * If the app didn't specify a pixel format, then we will return
                 * the original pixel format as decoded by the decode filter.
                 * This should be a close approximation of the format of the original
                 * file. Note that this stipulation could mean that the CreateSurface
                 * will dump the surface in sysmem. It's good for our routine to
                 * have the same semantics as CreateSurface.
                 */
                ddsd.dwFlags |= DDSD_PIXELFORMAT;
                ddsd.ddpfPixelFormat = ddsdWorking.ddpfPixelFormat;
            }

            /*
             * Could we avoid creating a target surface and doing the blt altogether?
             * It wouldn't really buy much. If the app didn't specify a memory type, then
             * we probe to see if we can create a vidmem version by calling createsurface.
             * If we get a vidmem back, then we copy the bits and use it. If we get a sysmem
             * back then we could optimize that case by not doing the blt to get the
             * data into the target surface and returning the working surface directly.
             * One tiny disadvantage would be that the target surface would be explicit
             * sysmem, whereas the normal createsurface semantics would make that surface
             * an implicit sysmem surface.
             */

            /*
             * We don't do the create surface if a surface is passed in (as denoted
             * by *ppSurface being non-null)
             */
            if(SUCCEEDED(hr) && (NULL == (*ppSurface)) )
            {
                hr = lpDD->CreateSurface(&ddsd, ppSurface, pUnkOuter);
            }

            /*
             * Now blt the working surface to whatever the target was supposed to be...
             * Note this routine may transfer a reference to a palette as well.
             */
            if(SUCCEEDED(hr))
            {
                hr = TransferBitsToTarget(lpDDS, *ppSurface, pDDSD, dwFlags);
            }
            else
            {
                DPF_ERR("Create surface failed!");
            }
        }
        else
        {
            /*
             * Decode returned a NULL ddraw surface, even tho DecodeImage returned ok
             */
            hr = DDERR_INVALIDSTREAM;
        }
    }

//    pEventSink->Release();

    return hr;
} /* DD_CreateSurfaceFromFile */

extern "C" HRESULT DDAPI DD_CreateSurfaceFromStream(
    LPDIRECTDRAW4 lpDD,
    IStream *pSource,
    LPDDSURFACEDESC2 pDDSD,
    DWORD dwFlags,
    LPDIRECTDRAWSURFACE4 * ppSurface,
    IUnknown * pUnkOuter)
{
    *ppSurface = 0;
    return CreateOrLoadSurfaceFromStream(lpDD, pSource, pDDSD, dwFlags, ppSurface, pUnkOuter);
}

extern "C" HRESULT DDAPI DD_CreateSurfaceFromFile( LPDIRECTDRAW4 lpDD, BSTR DisplayName, LPDDSURFACEDESC2 pDDSD, DWORD dwFlags, LPDIRECTDRAWSURFACE4 * ppSurface, IUnknown * pUnkOuter)
{
    lpDD;
    pDDSD;
    pUnkOuter;

    // validate arguments
    if( !DisplayName || !ppSurface )
    {
        DPF_ERR("You must supply a valid filename and surface pointer");
        return E_POINTER;
    }

    if (FAILED(CoInitialize(NULL)))
    {
        DPF_ERR("Failed CoInitialize");
        return DDERR_UNSUPPORTED;
    }

    IMoniker *pmk;
    IBindCtx *pbctx;
    IStream *pStream;
    HRESULT hr = CreateURLMoniker(NULL, DisplayName, &pmk);
    if( SUCCEEDED( hr ) )
    {
        hr = CreateBindCtx(0, &pbctx);
        if( SUCCEEDED( hr ) )
        {
	    hr = pmk->BindToStorage(pbctx, NULL, IID_IStream, (void **)&pStream);
            if( SUCCEEDED( hr ) )
            {
                hr = DD_CreateSurfaceFromStream( lpDD, pStream, pDDSD, dwFlags, ppSurface ,pUnkOuter );
                pStream->Release();
            }
            else
            {
                DPF_ERR("Could not BindToStorage");
                if (hr == INET_E_UNKNOWN_PROTOCOL)
                    DPF_ERR("Fully qualified path name is required");
                if (hr == INET_E_RESOURCE_NOT_FOUND)
                    DPF_ERR("Resource not found. Fully qualified path name is required");
            }
            pbctx->Release();
        }
        else
        {
            DPF_ERR("Could not CreateBindCtx");
        }
        pmk->Release();
    }
    else
    {
        DPF_ERR("Could not CreateURLMoniker");
    }
        

    return hr;

    return DD_OK;
}

/*
 * Persistence interfaces
 * These methods read and write streams of the following form:
 *
 *   Element	                        Description
 *   -------------------------------------------------------------------------------------------------
 *   Type           Name
 *
 *   GUID           tag	                GUID_DirectDrawSurfaceStream. Tags the stream as a surface stream
 *   DWORD          dwWidth	        Width in pixels of the image data
 *   DWORD          dwHeight	        Height in pixels of the image data
 *   DDPIXELFORMAT  Format              Format of image data
 *   DWORD          dwPaletteCaps       Palette caps. Zero if no palette.
 *   PALETTESTREAM  PaletteData         This field is only present if the dwPaletteCaps field is non-zero
 *   GUID           CompressionFormat   This field is only present if one of the DDPF_OPT flags is specified in Format
 *   DWORD          dwDataSize	        Number of bytes that follow
 *   BYTE[]         SurfaceData	        dwDataSize bytes of surface data
 *   PRIVATEDATA    PrivateSurfaceData	
 *
 *
 *   The PALETTESTREAM stream element has the following format:
 *
 *   Element	                        Description
 *   -------------------------------------------------------------------------------------------------
 *   Type           Name
 *   GUID           tag	                GUID_DirectDrawPaletteeStream. Tags the stream as a palette stream
 *   DWORD          dwPaletteFlags      Palette flags made up of DDPCAPS bits.
 *   PALETTEENTRY[] PaletteEntries      The number of palette entries specified by the flags in dwPaletteFlags.
 *   PRIVATEDATA    PrivatePaletteData  Private palette data.
 *
 *
 *   The PRIVATEDATA stream element has the following format:
 *
 *   Element	                    Description
 *   -------------------------------------------------------------------------------------------------
 *   Type       Name
 *
 *   DWORD dwPrivateDataCount	    The number of private data blocks which follow
 *     GUID GUIDTag	            Tag for this block of private data, as specified by IDDS4:SetClientData
 *     DWORD dwPrivateSize	    Number of bytes of private data in this block
 *     BYTE[] PrivateData	    dwPrivateSize bytes of private data
 *
 * Note private data that are of pointer type (i.e. point to a user-allocated data block) will
 * NOT be saved by these methods.
 *
 */

template<class Object> HRESULT InternalReadPrivateData(
    IStream * pStrm,
    Object * lpObject)
{
    HRESULT ddrval;
    DWORD   dwCount;

    ddrval = pStrm->Read((void*) & dwCount, sizeof(DWORD), NULL);
    if (FAILED(ddrval))
    {
        DPF_ERR("Stream read failed on private data count");
        return ddrval;
    }

    for(;dwCount;dwCount--)
    {
        GUID  guid;
        DWORD cbData;
        LPVOID pData;

        ddrval = pStrm->Read((void*) & guid, sizeof(guid), NULL);
        if (FAILED(ddrval))
        {
            DPF_ERR("Stream read failed on private data GUID");
            return ddrval;
        }

        ddrval = pStrm->Read((void*) & cbData, sizeof(cbData), NULL);
        if (FAILED(ddrval))
        {
            DPF_ERR("Stream read failed on private data GUID");
            return ddrval;
        }

        pData = MemAlloc(cbData);
        if (pData)
        {
            ddrval = pStrm->Read((void*) pData, cbData, NULL);
            if (FAILED(ddrval))
            {
                DPF_ERR("Stream read failed on private data GUID");
                return ddrval;
            }

            ddrval = lpObject->SetPrivateData(guid, pData, cbData, 0);

            MemFree(pData);

            if (FAILED(ddrval))
            {
                DPF_ERR("Could not set private data");
                return ddrval;
            }
        }
        else
        {
            DPF_ERR("Couln't alloc enough space for private data");
            ddrval = DDERR_OUTOFMEMORY;
            return ddrval;
        }
    }
    return ddrval;
}

HRESULT myWriteClassStm(IStream * pStrm, LPGUID pGUID)
{
    return pStrm->Write(pGUID, sizeof(*pGUID),NULL);
}

HRESULT myReadClassStm(IStream * pStrm, LPGUID pGUID)
{
    return pStrm->Read(pGUID, sizeof(*pGUID),NULL);
}

/*
 * Be sure to call ENTER_DDRAW before and LEAVE_DDRAW after
 * calling this function!
 */
HRESULT InternalWritePrivateData(
    IStream * pStrm,
    LPPRIVATEDATANODE pPrivateDataHead)
{
    HRESULT ddrval;
    DWORD dwCount = 0;
    LPPRIVATEDATANODE pPrivateData = pPrivateDataHead;

    while(1)
    {
        while(pPrivateData)
        {
            if (pPrivateData->dwFlags == 0)
            {
                dwCount++;
            }
            pPrivateData = pPrivateData->pNext;
        }

        ddrval = pStrm->Write((void*) & dwCount, sizeof(dwCount), NULL);
        if (FAILED(ddrval))
        {
            DPF_ERR("Stream write failed on count of private data");
            break;
        }

        pPrivateData = pPrivateDataHead;
        while(pPrivateData)
        {
            if (pPrivateData->dwFlags == 0)
            {
                ddrval = myWriteClassStm(pStrm, &(pPrivateData->guid));
                if (SUCCEEDED(ddrval))
                {
                    ddrval = pStrm->Write((void*) &(pPrivateData->cbData), sizeof(DWORD), NULL);
                    if (SUCCEEDED(ddrval))
                    {
                        ddrval = pStrm->Write((void*) pPrivateData->pData, pPrivateData->cbData, NULL);
                        if (FAILED(ddrval))
                            break;
                    }
                    else
                        break;
                }
                else
                    break;
            }
            pPrivateData = pPrivateData->pNext;
        }

        break;
    }

    return ddrval;
}

extern "C" HRESULT DDAPI DD_Surface_Persist_GetClassID(LPDIRECTDRAWSURFACE lpDDS, CLSID * pClassID)
{
    TRY
    {
        memcpy(pClassID, & GUID_DirectDrawSurfaceStream, sizeof(*pClassID));
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered copying GUID" );
	return DDERR_INVALIDPARAMS;
    }
    return DD_OK;
}

extern "C" HRESULT DDAPI DD_Surface_PStream_IsDirty(LPDIRECTDRAWSURFACE lpDDS)
{
    LPDDRAWI_DDRAWSURFACE_INT	        this_int;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE	this_more;

    ENTER_DDRAW();

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDS;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

        this_more = GET_LPDDRAWSURFACE_GBL_MORE(this_int->lpLcl->lpGbl);

        if ( (this_more->dwSaveStamp == 0 ) ||
             (this_more->dwContentsStamp != this_more->dwSaveStamp) )
        {
	    LEAVE_DDRAW();
	    return S_OK;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered checking dirty" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return S_FALSE;
}

extern "C" HRESULT DDAPI DD_Surface_PStream_Load(LPDIRECTDRAWSURFACE lpDDS, IStream * pStrm)
{
    DDSURFACEDESC2              ddsd;
    HRESULT                     ddrval;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDIRECTDRAWSURFACE4        lpDDS1 = NULL;

    if (!VALID_PTR(pStrm,sizeof(*pStrm)))
    {
        DPF_ERR("Bad stream pointer");
        return DDERR_INVALIDPARAMS;
    }

    this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDS;
    if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
    {
	return DDERR_INVALIDOBJECT;
    }

    /*
     * DO THE QI for DDOPTSURF HERE
     * and appropriate loading
     */

    ddrval = lpDDS->QueryInterface(IID_IDirectDrawSurface4, (void**) & lpDDS1);
    if (SUCCEEDED(ddrval))
    {
        ZeroMemory(&ddsd,sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);

        ddrval = lpDDS1->Lock(NULL, &ddsd,DDLOCK_WAIT,NULL);

        if (SUCCEEDED(ddrval))
        {
            if (ddsd.ddpfPixelFormat.dwFlags & (DDPF_FOURCC) )
            {
                DPF_ERR("The surface isn't streamable. Bad pixel format");
                ddrval = DDERR_INVALIDPIXELFORMAT;
            }
            else
            {
                while(SUCCEEDED(ddrval)) //a fake try-except while
                {
                    DWORD y;
                    DWORD dwStreamWidth,dwStreamHeight;
                    DWORD dwPalCaps;
                    DDPIXELFORMAT ddpfStream;
                    CLSID clsid;

                    /*
                     * First attempt to read stream format GUID
                     */
                    ddrval = myReadClassStm(pStrm, & clsid);

                    //don't bother to check return code, since the following test will fail in that case
                    if (!IsEqualGUID(clsid,  GUID_DirectDrawSurfaceStream))
                    {
                        DPF_ERR("The stream does not contain a directdraw surface stream");
                        ddrval = DDERR_INVALIDSTREAM;
                        break;
                    }

                    /*
                     * Get image format from stream
                     */
                    ddrval = pStrm->Read((void*) & dwStreamWidth, sizeof(dwStreamWidth), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream read failed on width");
                        break;
                    }

                    ddrval = pStrm->Read((void*) & dwStreamHeight, sizeof(dwStreamHeight), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream read failed on height");
                        break;
                    }

                    ddrval = pStrm->Read((void*) & ddpfStream, sizeof(ddpfStream), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream read failed on pixel format");
                        break;
                    }

                    if (!doPixelFormatsMatch(&ddpfStream, &ddsd.ddpfPixelFormat))
                    {
                        DPF_ERR("Stream pixel format does not match that of surface!");
                        break;
                    }

                    ddrval = pStrm->Read((void*) & dwPalCaps, sizeof(dwPalCaps), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream read failed on palette caps");
                        break;
                    }


                    /*
                     * If a palette exists, then either create one or grab the palette from the surface
                     * and try to stream its data in too.
                     */
                    if (dwPalCaps)
                    {
                        LPDIRECTDRAWPALETTE2 lpDDPal;
                        ddrval = lpDDS1->GetPalette(& lpDDPal);
                        if (ddrval == DDERR_NOPALETTEATTACHED)
                        {
                            PALETTEENTRY pe[256]; //just a dummy
                            ddrval = DD_CreatePalette(
                                (IDirectDraw*)(this_int->lpLcl->lpGbl) ,
                                dwPalCaps,
                                pe,
                                (LPDIRECTDRAWPALETTE*)&lpDDPal,
                                NULL);
                            if (FAILED(ddrval))
                            {
                                DPF_ERR("Failed to create palette for surface ");
                                break;
                            }
                            ddrval = lpDDS1->SetPalette(lpDDPal);
                            if (FAILED(ddrval))
                            {
                                lpDDPal->Release();
                                DPF_ERR("Could not set palette into surface ");
                                break;
                            }
                        }

                        if (SUCCEEDED(ddrval))
                        {
                            /*
                             * Stream palette from stream
                             */
                            ddrval = DD_Palette_PStream_Load( (LPDIRECTDRAWPALETTE) lpDDPal,pStrm);
                            lpDDPal->Release();

                            if (FAILED(ddrval))
                            {
                                break;
                            }
                        }

                    }

                    /*
                     * Here we check for DDPF_OPT... and load a compression GUID if necessary
                    if (ddpfStream.dwFlags & (DDPF_OPTCOMPRESSED|DDPF_OPTREORDERED) )
                    {
                        ddrval = myReadClassStm(pStrm, & clsid);

                    }
                    else
                    //Surface is not compressed, so lock and read....
                     */

                    /*
                     * And finally read the data
                     */
                    for (y=0;y<ddsd.dwHeight;y++)
                    {
                        ddrval = pStrm->Read((void*) ((DWORD) ddsd.lpSurface + y*ddsd.lPitch),
                            (ddsd.dwWidth * ddsd.ddpfPixelFormat.dwRGBBitCount / 8),
                            NULL);

                        if (FAILED(ddrval))
                        {
                            DPF_ERR("Stream read failed");
                            break;
                        }
                    }

                    /*
                     * Read private data
                     */
                    ddrval = InternalReadPrivateData(pStrm, lpDDS1);
                    break;
                }
            } // OK pixel format
            lpDDS1->Unlock(NULL);
        }//lock succeeded
        else
        {
            DPF_ERR("Could not lock surface");
        }

        lpDDS1->Release();
    }// QIed for ddsurf ok
    else
    {
        DPF_ERR("Bad surface object... can't QI itself for IDirectDrawSurface...");
    }

    return ddrval;
}

extern "C" HRESULT DDAPI DD_Surface_PStream_Save(LPDIRECTDRAWSURFACE lpDDS, IStream * pStrm, BOOL bClearDirty)
{
    DDSURFACEDESC2              ddsd;
    HRESULT                     ddrval;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDIRECTDRAWSURFACE4        lpDDS1 = NULL;

    if (!VALID_PTR(pStrm,sizeof(*pStrm)))
    {
        DPF_ERR("Bad stream pointer");
        return DDERR_INVALIDPARAMS;
    }

    this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDS;
    if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
    {
	return DDERR_INVALIDOBJECT;
    }

    /*
     * DO THE QI for DDOPTSURF HERE
     */

    ddrval = lpDDS->QueryInterface(IID_IDirectDrawSurface4, (void**) & lpDDS1);
    if (SUCCEEDED(ddrval))
    {
        ZeroMemory(&ddsd,sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);

        ddrval = lpDDS1->Lock(NULL,&ddsd,DDLOCK_WAIT,NULL);

        if (SUCCEEDED(ddrval))
        {
            if (ddsd.ddpfPixelFormat.dwFlags & (DDPF_FOURCC) )
            {
                DPF_ERR("The surface isn't streamable. Bad pixel format");
                ddrval = DDERR_INVALIDPIXELFORMAT;
            }
            else
            {
                while(SUCCEEDED(ddrval)) //a fake try-except while
                {
                    LPDIRECTDRAWPALETTE2 lpDDPal;
                    DWORD y,dwWritten;

                    /*
                     * First attempt to read stream format GUID
                     */
                    ddrval = myWriteClassStm(pStrm, (LPGUID) & GUID_DirectDrawSurfaceStream);

                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Failed to write stream ID ");
                        ddrval = DDERR_INVALIDSTREAM;
                        break;
                    }

                    /*
                     * Get image format from stream
                     */
                    ddrval = pStrm->Write((void*) & ddsd.dwWidth, sizeof(DWORD), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream write failed on width");
                        break;
                    }

                    ddrval = pStrm->Write((void*) & ddsd.dwHeight, sizeof(DWORD), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream write failed on Height");
                        break;
                    }

                    ddrval = pStrm->Write((void*) & ddsd.ddpfPixelFormat, sizeof(ddsd.ddpfPixelFormat), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream write failed on width");
                        break;
                    }

                    /*
                     * If a palette exists, then write it out
                     */
                    ddrval = lpDDS1->GetPalette(&lpDDPal);
                    if (SUCCEEDED(ddrval))
                    {
                        ddrval = lpDDPal->GetCaps(&dwWritten);
                        if (SUCCEEDED(ddrval))
                        {
                            ddrval = pStrm->Write((void*) & dwWritten, sizeof(dwWritten), NULL);
                            if (FAILED(ddrval))
                            {
                                DPF_ERR("Stream write failed on palette caps");
                                break;
                            }

                            /*
                             * Stream palette from stream
                             */
                            ddrval = DD_Palette_PStream_Save((LPDIRECTDRAWPALETTE)lpDDPal,pStrm,bClearDirty);
                            if (FAILED(ddrval))
                            {
                                lpDDPal->Release();
                                break;
                            }
                        }
                        else
                        {
                            DPF_ERR("Could not get palette caps");
                            lpDDPal->Release();
                            break;
                        }

                        lpDDPal->Release();

                    }
                    else
                    {
                        dwWritten = 0;

                        ddrval = pStrm->Write((void*) & dwWritten, sizeof(dwWritten),NULL);
                        if (FAILED(ddrval))
                        {
                            DPF_ERR("Stream write failed on palette caps");
                            break;
                        }
                    }
                    /*
                     * Here we check for DDPF_OPT... and load a compression GUID if necessary
                    if (ddpfStream.dwFlags & (DDPF_OPTCOMPRESSED|DDPF_OPTREORDERED) )
                    {
                        ddrval = myReadClassStm(pStrm, & clsid);

                    }
                    else
                    //Surface is not compressed, so lock and read....
                     */

                    /*
                     * And finally write the data
                     */
                    for (y=0;y<ddsd.dwHeight;y++)
                    {
                        ddrval = pStrm->Write((void*) ((DWORD) ddsd.lpSurface + y*ddsd.lPitch),
                            (ddsd.dwWidth * ddsd.ddpfPixelFormat.dwRGBBitCount / 8),
                            NULL);

                        if (FAILED(ddrval))
                        {
                            DPF_ERR("Stream write failed");
                            break;
                        }
                    }

                    /*
                     * Write out private data
                     */
                    ENTER_DDRAW();
		    ddrval = InternalWritePrivateData(pStrm,
			this_int->lpLcl->lpSurfMore->pPrivateDataHead);
		    LEAVE_DDRAW();
                    break;
                }
            } // OK pixel format
            lpDDS1->Unlock(NULL);
        }//lock succeeded
        else
        {
            DPF_ERR("Could not lock surface");
        }

        lpDDS1->Release();
    }// QIed for ddsurf ok
    else
    {
        DPF_ERR("Bad surface object... can't QI itself for IDirectDrawSurface...");
    }

    if (SUCCEEDED(ddrval) && bClearDirty)
    {
        ENTER_DDRAW();
        GET_LPDDRAWSURFACE_GBL_MORE(this_int->lpLcl->lpGbl)->dwSaveStamp =
        GET_LPDDRAWSURFACE_GBL_MORE(this_int->lpLcl->lpGbl)->dwContentsStamp ;
        LEAVE_DDRAW();
    }

    return ddrval;
}

/*
 * How to calculate the size of a streamable object without really trying.
 * You make a dummy IStream interface with only one valid method: Write.
 * When Write is called you count the bytes and return OK. As long as the
 * client (i.e. our surface and palette IPersistStream interfaces) call
 * nothing but Write, it should work. Since the total is part of the fake
 * stream object which is on the stack, this is thread-safe too.
 */

LPVOID CheatStreamCallbacks[3+11];
typedef struct
{
    LPVOID  * lpVtbl;
    DWORD dwTotal;
} SUPERCHEATSTREAM;

HRESULT __stdcall SuperMegaCheater(SUPERCHEATSTREAM * pCheater, LPVOID pBuffer, ULONG dwSize, ULONG * pWritten)
{
    pCheater->dwTotal += dwSize;
    return S_OK;
}

extern "C" HRESULT DDAPI DD_PStream_GetSizeMax(IPersistStream * lpSurfOrPalette, ULARGE_INTEGER * pMax)
{
    HRESULT                     ddrval = DD_OK;
    SUPERCHEATSTREAM            SuperCheat;

    if (!VALID_PTR(pMax,sizeof(ULARGE_INTEGER)))
    {
        DPF_ERR("Bad stream pointer");
        return DDERR_INVALIDPARAMS;
    }


    SuperCheat.lpVtbl =  CheatStreamCallbacks;
    CheatStreamCallbacks[4] = (LPVOID)SuperMegaCheater;
    SuperCheat.dwTotal = 0;

    lpSurfOrPalette->Save((IStream*) & SuperCheat, FALSE);

    pMax->LowPart = SuperCheat.dwTotal;
    pMax->HighPart = 0;

    return S_OK;
}

extern "C" HRESULT DDAPI DD_Palette_PStream_IsDirty(LPDIRECTDRAWPALETTE lpDDP)
{
    LPDDRAWI_DDRAWPALETTE_INT	    this_int;
    LPDDRAWI_DDRAWPALETTE_GBL	    this_gbl;

    ENTER_DDRAW();

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDP;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

        this_gbl = this_int->lpLcl->lpGbl;

        if ( (this_gbl->dwSaveStamp == 0 ) ||
             (this_gbl->dwContentsStamp != this_gbl->dwSaveStamp) )
        {
	    LEAVE_DDRAW();
	    return S_OK;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered checking dirty" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return S_FALSE;
}

extern "C" HRESULT DDAPI DD_Palette_Persist_GetClassID(LPDIRECTDRAWPALETTE lpDDP, CLSID * pClassID)
{
    TRY
    {
        memcpy(pClassID, & GUID_DirectDrawPaletteStream, sizeof(*pClassID));
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered copying GUID" );
	return DDERR_INVALIDPARAMS;
    }
    return DD_OK;
}

extern "C" HRESULT DDAPI DD_Palette_PStream_Load(LPDIRECTDRAWPALETTE lpStream, IStream * pStrm)
{
    PALETTEENTRY                pe[256];
    HRESULT                     ddrval;
    DWORD                       dwCaps, dwStreamCaps;
    DWORD                       dwSize;
    DWORD                       dwNumEntries;
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    GUID                        g;
    LPDIRECTDRAWPALETTE2        lpDDP;

    this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpStream;
    if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
    {
	return DDERR_INVALIDOBJECT;
    }

    ddrval = lpStream->QueryInterface( IID_IDirectDrawPalette2, (void**)& lpDDP);
    if (FAILED(ddrval))
    {
        DPF_ERR("Couldn't QI stream for palette");
        return ddrval;
    }

    ddrval = lpDDP->GetCaps(&dwCaps);
    if (SUCCEEDED(ddrval))
    {
        dwNumEntries = FLAGS_TO_SIZE(SIZE_PCAPS_TO_FLAGS(dwCaps));
        dwSize = dwNumEntries;
        if ((dwCaps & DDPCAPS_8BITENTRIES) == 0)
        {
            //the color table is really palettee entries
            dwSize *=sizeof(PALETTEENTRY);
        }
        //if it weren 8 bit entries, then dwSize would already be the size of the color table

        ddrval = pStrm->Read((LPVOID) &g, sizeof(GUID_DirectDrawPaletteStream),NULL);
        if (SUCCEEDED(ddrval))
        {
            if (IsEqualGUID(g, GUID_DirectDrawPaletteStream))
            {
                ddrval = pStrm->Read((LPVOID) &dwStreamCaps, sizeof(DWORD),NULL);

                if (SUCCEEDED(ddrval))
                {
                    if (dwCaps == dwStreamCaps)
                    {

                        ddrval = pStrm->Read((LPVOID) pe, dwSize,NULL);
                        if (SUCCEEDED(ddrval))
                        {
                            ddrval = lpDDP->SetEntries(0,0,dwNumEntries,pe);
                            if (SUCCEEDED(ddrval))
                            {
				/*
				 * Read private data
				 */
				ddrval = InternalReadPrivateData(pStrm, lpDDP);
				if (FAILED(ddrval))
                                {
                                    DPF_ERR("Couldn't read private data");
                                }
                            }
                            else
                            {
                                DPF_ERR("Couldn't set palette entries");
                            }
                        }
                        else
                        {
                            DPF_ERR("Couldn't read palette entries");
                        }
                    }
                    else
                    {
                        DPF_ERR("Palette stream caps don't match palette object's caps");
                        ddrval = DDERR_INVALIDSTREAM;
                    }
                }
                else
                {
                    DPF_ERR("Couldn't read palette caps");
                }
            }
            else
            {
                DPF_ERR("Stream doesn't contain a ddraw palette stream tag");
                ddrval = DDERR_INVALIDSTREAM;
            }
        }
        else
        {
            DPF_ERR("Couldn't read palette stream tag");
        }
    }
    else
    {
        DPF_ERR("Couldn't get palette caps");
    }
    lpDDP->Release();

    return ddrval;
}

extern "C" HRESULT DDAPI DD_Palette_PStream_Save(LPDIRECTDRAWPALETTE lpStream, IStream * pStrm, BOOL bClearDirty)
{
    PALETTEENTRY                pe[256];
    HRESULT                     ddrval;
    DWORD                       dwCaps;
    DWORD                       dwSize;
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDIRECTDRAWPALETTE         lpDDP;

    this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpStream;
    if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
    {
	return DDERR_INVALIDOBJECT;
    }

    ddrval = lpStream->QueryInterface(IID_IDirectDrawPalette, (void**) &lpDDP);
    if (FAILED(ddrval))
    {
        DPF_ERR("Couldn't QI stream for palette");
        return ddrval;
    }

    ddrval = lpDDP->GetCaps(&dwCaps);
    if (SUCCEEDED(ddrval))
    {
        dwSize = FLAGS_TO_SIZE(SIZE_PCAPS_TO_FLAGS(dwCaps));
        ddrval = lpDDP->GetEntries(0,0,dwSize,pe);
        if (SUCCEEDED(ddrval))
        {
            if ((dwCaps & DDPCAPS_8BITENTRIES) == 0)
            {
                //the color table is really palettee entries
                dwSize *=sizeof(PALETTEENTRY);
            }
            //if it weren 8 bit entries, then dwSize would already be the size of the color table

            ddrval = pStrm->Write((LPVOID) &GUID_DirectDrawPaletteStream, sizeof(GUID_DirectDrawPaletteStream),NULL);
            if (SUCCEEDED(ddrval))
            {
                ddrval = pStrm->Write((LPVOID) &dwCaps, sizeof(DWORD),NULL);

                if (SUCCEEDED(ddrval))
                {
                    ddrval = pStrm->Write((LPVOID) pe, dwSize,NULL);
                    if (SUCCEEDED(ddrval))
                    {
			ENTER_DDRAW();
			ddrval = InternalWritePrivateData(pStrm,
			    this_int->lpLcl->pPrivateDataHead);
			LEAVE_DDRAW();

                        if (SUCCEEDED(ddrval))
                        {
                            if (bClearDirty)
                            {
                                ENTER_DDRAW();
                                (this_int->lpLcl->lpGbl)->dwSaveStamp = (this_int->lpLcl->lpGbl)->dwContentsStamp ;
                                LEAVE_DDRAW();
                            }
                        }
                        else
                        {
                            DPF_ERR("Couldn't write palette private data");
                        }
                    }
                    else
                    {
                        DPF_ERR("Couldn't write palette entries");
                    }
                }
                else
                {
                    DPF_ERR("Couldn't write palette caps");
                }
            }
            else
            {
                DPF_ERR("Couldn't write palette stream tag");
            }
        }
        else
        {
            DPF_ERR("COuldn't get palette entries");
        }
    }
    else
    {
        DPF_ERR("Couldn't get palette caps");
    }
    lpDDP->Release();

    return ddrval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddsblt.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsblt.c
 *  Content:    DirectDraw Surface support for blt
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   24-jan-95  craige  split out of ddsurf.c, enhanced
 *   31-jan-95  craige  and even more ongoing work...
 *   03-feb-95  craige  performance tuning, ongoing work
 *   21-feb-95  craige  work work work
 *   27-feb-95  craige  new sync. macros
 *   08-mar-95  craige  new stretch flags
 *   11-mar-95  craige  take Win16 lock on Win95 before calling 32-bit fns
 *   15-mar-95  craige  HEL integration
 *   19-mar-95  craige  use HRESULTs
 *   29-mar-95  craige  make colorfill work
 *   01-apr-95  craige  happy fun joy updated header file
 *   03-apr-95  craige  off by one when rect specified; need to validate
 *                      rectangles against surfaces
 *   12-apr-95  craige  pulled out clipped stretching code optimization for now
 *   15-apr-95  craige  can't allow source surface with colorfill; don't
 *                      allow < 0 left, top coords
 *   06-may-95  craige  use driver-level csects only
 *   11-jun-95  craige  check for locked surface before blt
 *   21-jun-95  kylej   lock non-emulated surfaces before calling HEL blt
 *   21-jun-95  craige  clipping changes
 *   24-jun-95  kylej   move video memory source surfaces to system memory
 *                      if there is no hardware blt support.
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  use clipper to do clipping; started BltBatch;
 *                      moved CheckBltStretching back in
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns; disabled alpha & Z blt
 *   04-jul-95  craige  YEEHAW: new driver struct; SEH
 *   05-jul-95  kylej   debugged clipping code and added clipped stretched blts
 *   07-jul-95  craige  added test for BUSY
 *   07-jul-95  kylej   replace inline code with call to XformRect
 *   08-jul-95  craige  BltFast: need to use HEL if src or dest is in
 *                      system memory!
 *   09-jul-95  craige  hasvram flag in MoveToSystemMemory; handle loss
 *                      of color key resource after blt
 *   10-jul-95  kylej   added mirroring caps checks in Blt
 *   13-jul-95  craige  ENTER_DDRAW is now the win16 lock
 *   16-jul-95  craige  check DDRAWISURF_HELCB
 *   27-jul-95  craige  check for color fill support in hardware!
 *   31-jul-95  craige  check Lock calls for WASSTILLDRAWING;
 *                      test for valid flags
 *   01-aug-95  craige  hold win16 early to keep busy bit test valid
 *   01-aug-95  toddla  added DD16_Exclude and DD16_Unexclude
 *   04-aug-95  craige  use InternalLock/Unlock
 *   06-aug-95  craige  do DD16_Exclude before lock, unexclude after unlock
 *   10-aug-95  toddla  added DDBLT_WAIT and DDBLTFAST_WAIT flags
 *   12-aug-95  craige  use_full_lock parm for MoveToSystemMemory and
 *                      ChangeToSoftwareColorKey
 *   23-aug-95  craige  wasn't unlocking surfaces or unexcluding cursor on
 *                      a few error conditions
 *   16-sep-95  craige  bug 1175: set return code if NULL clip list
 *   02-jan-96  kylej   handle new interface structures
 *   04-jan-96  colinmc added DDBLT_DEPTHFILL for clearing Z-buffers
 *   01-feb-96  jeffno  NT: pass user-mode ptrs to vram surfaces to HEL
 *                      in Blt and BltFast
 *   12-feb-96  colinmc Surface lost flag moved from global to local object
 *   29-feb-96  kylej   Enable System->Video bltting
 *   03-mar-96  colinmc Fixed a couple of nasty bugs causing blts to system
 *                      memory to be done by hardware
 *   21-mar-96  colinmc Bug 14011: Insufficient parameter validation on
 *                      BltFast
 *   26-mar-96  jeffno  Handle visrgn changes under NT
 *   20-apr-96  colinmc Fixed problem with releasePageLocks spinning on
 *                      busy bit
 *   23-apr-96  kylej   Bug 10196: Added check for software dest blt
 *   17-may-96  craige  bug 21499: perf problems with BltFast
 *   14-jun-96  kylej   NT Bug 38227: Internal lock was not correctly reporting
 *                      when the visrgn had changed.
 *   13-aug-96  colinmc Bug 3194: Blitting through a clipper without
 *                      DDBLT_WAIT could cause infinite loop in app.
 *   01-oct-96  ketand  Perf for clipped blits
 *   21-jan-97  ketand  Fix rectangle checking for multi-mon systems. Clip blits to
 *                      the destination surface if a clipper is used.
 *   31-jan-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *   03-mar-97  jeffno  Bug #5061: Trashing fpVidMem on blt.
 *   08-mar-97  colinmc Support for DMA style AGP parts
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   24-mar-97  jeffno  Optimized Surfaces
 *
 ***************************************************************************/
#include "ddrawpr.h"
#define DONE_BUSY()          \
    (*pdflags) &= ~BUSY; \

#define LEAVE_BOTH_NOBUSY() \
    { if(pdflags)\
        (*pdflags) &= ~BUSY; \
    } \
    LEAVE_BOTH();

#define DONE_LOCKS() \
    if( dest_lock_taken ) \
    { \
        if (subrect_lock_taken) \
        {   \
            InternalUnlock( this_dest_lcl, NULL, &subrect_lock_rect, 0);    \
            subrect_lock_taken = FALSE; \
        }       \
        else    \
        {       \
            InternalUnlock( this_dest_lcl,NULL,NULL,0 ); \
        }       \
        dest_lock_taken = FALSE; \
    } \
    if( src_lock_taken && this_src_lcl) \
    { \
        InternalUnlock( this_src_lcl,NULL,NULL,0 ); \
        src_lock_taken = FALSE; \
    }


#undef DPF_MODNAME
#define DPF_MODNAME     "BltFast"

DWORD dwSVBHack;

// turns off SEH for bltfast
#define FASTFAST

typedef struct _bltcaps
{
    LPDWORD     dwCaps;
    LPDWORD     dwFXCaps;
    LPDWORD     dwCKeyCaps;
    LPDWORD     dwRops;

    LPDWORD     dwHELCaps;
    LPDWORD     dwHELFXCaps;
    LPDWORD     dwHELCKeyCaps;
    LPDWORD     dwHELRops;

    LPDWORD     dwBothCaps;
    LPDWORD     dwBothFXCaps;
    LPDWORD     dwBothCKeyCaps;
    LPDWORD     dwBothRops;
    BOOL        bHALSeesSysmem;
    BOOL        bSourcePagelockTaken;
    BOOL        bDestPagelockTaken;
} BLTCAPS, *LPBLTCAPS;

void initBltCaps( DWORD dwDstCaps, DWORD dwDstFlags, DWORD dwSrcCaps, LPDDRAWI_DIRECTDRAW_GBL pdrv, LPBLTCAPS lpbc, LPBOOL helonly )
{
#ifdef WINNT
    BOOL bPrimaryHack = FALSE;
#endif

    if (lpbc)
    {
        /*
         * Not really expecting lpbc to be null, but this is late and I'm paranoid
         */
        lpbc->bSourcePagelockTaken = FALSE;
        lpbc->bDestPagelockTaken = FALSE;
    }

    #ifdef WINNT
        // On NT, the kernel needs to handle blts from system to the primary
        // surface, otherwise the sprite stuff won't work

        if( ( dwDstFlags & DDRAWISURFGBL_ISGDISURFACE ) &&
            ( dwDstCaps & DDSCAPS_VIDEOMEMORY ) &&
            ( dwSrcCaps & DDSCAPS_SYSTEMMEMORY ) &&
            !(pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM) &&
            ( pdrv->ddCaps.dwCaps & DDCAPS_BLT ) )
        {
            bPrimaryHack = TRUE;
            pdrv->ddCaps.dwCaps |= DDCAPS_CANBLTSYSMEM;
        }
    #endif

    if( ( ( dwSrcCaps & DDSCAPS_NONLOCALVIDMEM ) || ( dwDstCaps & DDSCAPS_NONLOCALVIDMEM ) ) &&
        ( pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS ) )
    {
        /*
         * At least one of the surfaces is non local and the device exports
         * different capabilities for non-local video memory. If this is non-local
         * to local transfer then check the appropriate caps. Otherwise force
         * emulation.
         */
        if( ( dwSrcCaps & DDSCAPS_NONLOCALVIDMEM ) && ( dwDstCaps & DDSCAPS_LOCALVIDMEM ) )
        {
            /*
             * Non-local to local video memory transfer.
             */
            DDASSERT( NULL != pdrv->lpddNLVCaps );
            DDASSERT( NULL != pdrv->lpddNLVHELCaps );
            DDASSERT( NULL != pdrv->lpddNLVBothCaps );

            /*
             * We have specific caps. Use them
             */
            lpbc->dwCaps =          &(pdrv->lpddNLVCaps->dwNLVBCaps);
            lpbc->dwFXCaps =        &(pdrv->lpddNLVCaps->dwNLVBFXCaps);
            lpbc->dwCKeyCaps =      &(pdrv->lpddNLVCaps->dwNLVBCKeyCaps);
            lpbc->dwRops =          pdrv->lpddNLVCaps->dwNLVBRops;
            lpbc->dwHELCaps =       &(pdrv->lpddNLVHELCaps->dwNLVBCaps);
            lpbc->dwHELFXCaps =     &(pdrv->lpddNLVHELCaps->dwNLVBFXCaps);
            lpbc->dwHELCKeyCaps =   &(pdrv->lpddNLVHELCaps->dwNLVBCKeyCaps);
            lpbc->dwHELRops =       pdrv->lpddNLVHELCaps->dwNLVBRops;
            lpbc->dwBothCaps =      &(pdrv->lpddNLVBothCaps->dwNLVBCaps);
            lpbc->dwBothFXCaps =    &(pdrv->lpddNLVBothCaps->dwNLVBFXCaps);
            lpbc->dwBothCKeyCaps =  &(pdrv->lpddNLVBothCaps->dwNLVBCKeyCaps);
            lpbc->dwBothRops =      pdrv->lpddNLVBothCaps->dwNLVBRops;
            lpbc->bHALSeesSysmem =  FALSE;
            return;
        }
        else if( ( dwSrcCaps & DDSCAPS_SYSTEMMEMORY ) && ( dwDstCaps & DDSCAPS_NONLOCALVIDMEM )
            && ( pdrv->ddCaps.dwCaps2 & DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL ) )
        {
            /*
             * See the definition of the above caps bit in ddrawp.h for more details
             */
            DPF(4,"System to non-local Blt is a candidate for passing to driver.");
            lpbc->dwCaps =              &(pdrv->ddCaps.dwSVBCaps);
            lpbc->dwFXCaps =    &(pdrv->ddCaps.dwSVBFXCaps);
            lpbc->dwCKeyCaps =  &(pdrv->ddCaps.dwSVBCKeyCaps);
            lpbc->dwRops =              pdrv->ddCaps.dwSVBRops;
            lpbc->dwHELCaps =   &(pdrv->ddHELCaps.dwSVBCaps);
            lpbc->dwHELFXCaps = &(pdrv->ddHELCaps.dwSVBFXCaps);
            lpbc->dwHELCKeyCaps =       &(pdrv->ddHELCaps.dwSVBCKeyCaps);
            lpbc->dwHELRops =   pdrv->ddHELCaps.dwSVBRops;
            lpbc->dwBothCaps =  &(pdrv->ddBothCaps.dwSVBCaps);
            lpbc->dwBothFXCaps =        &(pdrv->ddBothCaps.dwSVBFXCaps);
            lpbc->dwBothCKeyCaps =      &(pdrv->ddBothCaps.dwSVBCKeyCaps);
            lpbc->dwBothRops =  pdrv->ddBothCaps.dwSVBRops;
            lpbc->bHALSeesSysmem = TRUE;
            return;
        }
        else
        {
            /*
             * Non-local to non-local or local to non-local transfer. Force emulation.
             */
            *helonly = TRUE;
        }
    }

    if( !(pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM) )
    {
        if( (dwSrcCaps & DDSCAPS_SYSTEMMEMORY) || (dwDstCaps & DDSCAPS_SYSTEMMEMORY) )
        {
            *helonly = TRUE;
        }
    }
    if( ( (dwSrcCaps & DDSCAPS_VIDEOMEMORY) && (dwDstCaps & DDSCAPS_VIDEOMEMORY) ) ||
        !( pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM ) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwCaps);
        lpbc->dwFXCaps =        &(pdrv->ddCaps.dwFXCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwCKeyCaps);
        lpbc->dwRops =          pdrv->ddCaps.dwRops;
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwCaps);
        lpbc->dwHELFXCaps =     &(pdrv->ddHELCaps.dwFXCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwCKeyCaps);
        lpbc->dwHELRops =       pdrv->ddHELCaps.dwRops;
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwCaps);
        lpbc->dwBothFXCaps =    &(pdrv->ddBothCaps.dwFXCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwCKeyCaps);
        lpbc->dwBothRops =      pdrv->ddBothCaps.dwRops;
        lpbc->bHALSeesSysmem = FALSE;
    }
    else if( (dwSrcCaps & DDSCAPS_SYSTEMMEMORY) && (dwDstCaps & DDSCAPS_VIDEOMEMORY) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwSVBCaps);
        lpbc->dwFXCaps =        &(pdrv->ddCaps.dwSVBFXCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwSVBCKeyCaps);
        lpbc->dwRops =          pdrv->ddCaps.dwSVBRops;
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwSVBCaps);
        lpbc->dwHELFXCaps =     &(pdrv->ddHELCaps.dwSVBFXCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwSVBCKeyCaps);
        lpbc->dwHELRops =       pdrv->ddHELCaps.dwSVBRops;
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwSVBCaps);
        lpbc->dwBothFXCaps =    &(pdrv->ddBothCaps.dwSVBFXCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwSVBCKeyCaps);
        lpbc->dwBothRops =      pdrv->ddBothCaps.dwSVBRops;
        lpbc->bHALSeesSysmem = TRUE;
    }
    else if( (dwSrcCaps & DDSCAPS_VIDEOMEMORY) && (dwDstCaps & DDSCAPS_SYSTEMMEMORY) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwVSBCaps);
        lpbc->dwFXCaps =        &(pdrv->ddCaps.dwVSBFXCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwVSBCKeyCaps);
        lpbc->dwRops =          pdrv->ddCaps.dwVSBRops;
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwVSBCaps);
        lpbc->dwHELFXCaps =     &(pdrv->ddHELCaps.dwVSBFXCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwVSBCKeyCaps);
        lpbc->dwHELRops =       pdrv->ddHELCaps.dwVSBRops;
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwVSBCaps);
        lpbc->dwBothFXCaps =    &(pdrv->ddBothCaps.dwVSBFXCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwVSBCKeyCaps);
        lpbc->dwBothRops =      pdrv->ddBothCaps.dwVSBRops;
        lpbc->bHALSeesSysmem = TRUE;
    }
    else if( (dwSrcCaps & DDSCAPS_SYSTEMMEMORY) && (dwDstCaps & DDSCAPS_SYSTEMMEMORY) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwSSBCaps);
        lpbc->dwFXCaps =        &(pdrv->ddCaps.dwSSBFXCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwSSBCKeyCaps);
        lpbc->dwRops =          pdrv->ddCaps.dwSSBRops;
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwSSBCaps);
        lpbc->dwHELFXCaps =     &(pdrv->ddHELCaps.dwSSBFXCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwSSBCKeyCaps);
        lpbc->dwHELRops =       pdrv->ddHELCaps.dwSSBRops;
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwSSBCaps);
        lpbc->dwBothFXCaps =    &(pdrv->ddBothCaps.dwSSBFXCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwSSBCKeyCaps);
        lpbc->dwBothRops =      pdrv->ddBothCaps.dwSSBRops;
        lpbc->bHALSeesSysmem = TRUE;
    }

    #ifdef WINNT
        if( bPrimaryHack )
        {
            pdrv->ddCaps.dwCaps &= ~DDCAPS_CANBLTSYSMEM;
            dwSVBHack = DDCAPS_BLT;
            lpbc->dwCaps = &dwSVBHack;
            lpbc->dwBothCaps = &dwSVBHack;
        }
    #endif
}

__inline void initBltCapsFast(
        DWORD dwDstCaps,
        DWORD dwSrcCaps,
        LPDDRAWI_DIRECTDRAW_GBL pdrv,
        LPBLTCAPS lpbc )
{
    if (lpbc)
    {
        /*
         * Not really expecting lpbc to be null, but this is late and I'm paranoid
         */
        lpbc->bSourcePagelockTaken = FALSE;
        lpbc->bDestPagelockTaken = FALSE;
    }

    if( ( ( dwSrcCaps & DDSCAPS_NONLOCALVIDMEM ) && ( dwDstCaps && DDSCAPS_LOCALVIDMEM ) ) &&
          ( pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS ) )
    {
        DDASSERT( NULL != pdrv->lpddNLVCaps );
        lpbc->dwCaps =          &(pdrv->lpddNLVCaps->dwNLVBCaps);
        lpbc->dwHELCaps =       &(pdrv->lpddNLVHELCaps->dwNLVBCaps);
        lpbc->dwBothCaps =      &(pdrv->lpddNLVBothCaps->dwNLVBCaps);
        lpbc->dwCKeyCaps =      &(pdrv->lpddNLVCaps->dwNLVBCKeyCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->lpddNLVHELCaps->dwNLVBCKeyCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->lpddNLVBothCaps->dwNLVBCKeyCaps);
        lpbc->bHALSeesSysmem =  FALSE;
    }
    else if( ( (dwSrcCaps & DDSCAPS_VIDEOMEMORY) && (dwDstCaps & DDSCAPS_VIDEOMEMORY) ) ||
             !( pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM ) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwCaps);
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwCaps);
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwCKeyCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwCKeyCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwCKeyCaps);
        lpbc->bHALSeesSysmem = FALSE;
    }
    else if( (dwSrcCaps & DDSCAPS_SYSTEMMEMORY) && (dwDstCaps & DDSCAPS_VIDEOMEMORY) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwSVBCaps);
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwSVBCaps);
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwSVBCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwSVBCKeyCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwSVBCKeyCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwSVBCKeyCaps);
        lpbc->bHALSeesSysmem = TRUE;
    }
    else if( (dwSrcCaps & DDSCAPS_VIDEOMEMORY) && (dwDstCaps & DDSCAPS_SYSTEMMEMORY) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwVSBCaps);
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwVSBCaps);
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwVSBCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwVSBCKeyCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwVSBCKeyCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwVSBCKeyCaps);
        lpbc->bHALSeesSysmem = TRUE;
    }
    else if( (dwSrcCaps & DDSCAPS_SYSTEMMEMORY) && (dwDstCaps & DDSCAPS_SYSTEMMEMORY) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwSSBCaps);
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwSSBCaps);
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwSSBCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwSSBCKeyCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwSSBCKeyCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwSSBCKeyCaps);
        lpbc->bHALSeesSysmem = TRUE;
    }
}

/*
 * OverlapsDevices
 *
 * This function checks for Blts that are on the destop, but not entirely
 * on the device.  When found, we will emulate the Blt (punting to GDI).
 */
BOOL OverlapsDevices( LPDDRAWI_DDRAWSURFACE_LCL lpSurf_lcl, LPRECT lpRect )
{
    LPDDRAWI_DIRECTDRAW_GBL lpGbl;
    RECT rect;

    lpGbl = lpSurf_lcl->lpSurfMore->lpDD_lcl->lpGbl;

    /*
     * If the device was explicitly specified, assume that they know
     * what they're doing.
     */
    if( lpSurf_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_EXPLICITMONITOR )
    {
        return FALSE;
    }

    /*
     * Do a real quick check w/o accounting for the clipper
     */
    if( ( lpRect->top < lpGbl->rectDevice.top ) ||
        ( lpRect->left < lpGbl->rectDevice.left ) ||
        ( lpRect->right > lpGbl->rectDevice.right ) ||
        ( lpRect->bottom > lpGbl->rectDevice.bottom ) )
    {
        /*
         * It may only be that part of the rect is off of the desktop,
         * in which case we don't neccesarily need to drop to emulation.
         */
        IntersectRect( &rect, lpRect, &lpGbl->rectDesktop );
        if( ( rect.top < lpGbl->rectDevice.top ) ||
            ( rect.left < lpGbl->rectDevice.left ) ||
            ( rect.right > lpGbl->rectDevice.right ) ||
            ( rect.bottom > lpGbl->rectDevice.bottom ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*
 * WaitForDriverToFinishWithSurface
 *
 * This function waits for the hardware driver to report that it has finished
 * operating on the given surface. We should only call this function if the
 * surface was a system memory surface involved in a DMA/busmastering transfer.
 * Note this function clears the DDRAWISURFGBL_HARDWAREOPSTARTED flags (both
 * of them).
 */
void WaitForDriverToFinishWithSurface(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    HRESULT hr;
#ifdef DEBUG
    DWORD dwStart;
    BOOL bSentMessage=FALSE;
    dwStart = GetTickCount();
#endif
    DDASSERT( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY );
    DPF(4,"Waiting for driver to finish with %08x",this_lcl->lpGbl);
    do
    {
        hr = InternalGetBltStatus( pdrv_lcl , this_lcl , DDGBS_ISBLTDONE );
#ifdef DEBUG
        if ( GetTickCount() -dwStart >= 10000 )
        {
            if (!bSentMessage)
            {
                bSentMessage = TRUE;
                DPF_ERR("Driver reports operation still pending on surface after 5s! Driver error!");
            }
        }
#endif
    } while (hr == DDERR_WASSTILLDRAWING);

    DDASSERT(hr == DD_OK);
    DPF(5,B,"Driver finished with that surface");
    this_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
}

/*
 * DD_Surface_BltFast
 *
 * Bit Blt from one surface to another FAST
 */
HRESULT DDAPI DD_Surface_BltFast(
                LPDIRECTDRAWSURFACE lpDDDestSurface,
                DWORD dwX,
                DWORD dwY,
                LPDIRECTDRAWSURFACE lpDDSrcSurface,
                LPRECT lpSrcRect,
                DWORD dwTrans )
{
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DDRAWSURFACE_INT   this_src_int;
    LPDDRAWI_DDRAWSURFACE_INT   this_dest_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_src_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL   this_dest_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this_src;
    LPDDRAWI_DDRAWSURFACE_GBL   this_dest;
    DDHAL_BLTDATA               bd;
    DWORD                       rc;
    LPDDHALSURFCB_BLT           bltfn;
    BOOL                        halonly;
    BOOL                        helonly;
    BOOL                        gdiblt;
    int                         src_height;
    int                         src_width;
    BOOL                        dest_lock_taken=FALSE;
    BOOL                        src_lock_taken=FALSE;
    LPVOID                      dest_bits;
    LPVOID                      src_bits;
    HRESULT                     ddrval;
    BLTCAPS                     bc;
    LPBLTCAPS                   lpbc = &bc;
    LPWORD                      pdflags=0;
    DWORD                       dwSourceLockFlags=0;
    DWORD                       dwDestLockFlags=0;
    BOOL                        subrect_lock_taken = FALSE;
    RECT                        subrect_lock_rect;

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_BltFast");
    /* DPF_ENTERAPI(lpDDDestSurface); */

    /*
     * prepare parameters.  An exception here is considered a bad parameter
     */

    #ifndef FASTFAST
    TRY
    #endif
    {
        ZeroMemory(&bd, sizeof(bd));    // initialize to zero

        this_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDDestSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_dest_int ) )
        {
            LEAVE_BOTH()
            return DDERR_INVALIDOBJECT;
        }
        this_dest_lcl = this_dest_int->lpLcl;
        this_dest = this_dest_lcl->lpGbl;
        if( SURFACE_LOST( this_dest_lcl ) )
        {
            DPF( 1, "Destination (%08lx) is lost", this_dest_int );
            LEAVE_BOTH();
            return DDERR_SURFACELOST;
        }

        this_src_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSrcSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_src_int ) )
        {
            LEAVE_BOTH();
            return DDERR_INVALIDOBJECT;
        }
        this_src_lcl = this_src_int->lpLcl;
        this_src = this_src_lcl->lpGbl;
        if( SURFACE_LOST( this_src_lcl ) )
        {
            DPF( 1, "Source (%08lx) is lost", this_src_int );
            LEAVE_BOTH();
            return DDERR_SURFACELOST;
        }
        if( lpSrcRect != NULL )
        {
            if( !VALID_RECT_PTR( lpSrcRect ) )
            {
                LEAVE_BOTH()
                return DDERR_INVALIDPARAMS;
            }
        }
        if( dwTrans & ~DDBLTFAST_VALID )
        {
            DPF_ERR( "Invalid flags") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

        //
        // If either surface is optimized, quit
        //
        if (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "Can't blt from an optimized surface") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

        if (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "Can't blt to optimized surfaces") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * BEHAVIOUR CHANGE FOR DX5
         *
         * We do not allow bltting between surfaces created with different DirectDraw
         * objects.
         */
        if (this_dest_lcl->lpSurfMore->lpDD_lcl->lpGbl != this_src_lcl->lpSurfMore->lpDD_lcl->lpGbl)
        {
            if ((this_dest_lcl->lpSurfMore->lpDD_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV) &&
               (this_src_lcl->lpSurfMore->lpDD_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV))
            {
                DPF_ERR("Can't blt surfaces between different direct draw devices");
                LEAVE_BOTH();
                return DDERR_DEVICEDOESNTOWNSURFACE;
            }
        }


        pdrv = this_dest->lpDD;
        pdrv_lcl = this_dest_lcl->lpSurfMore->lpDD_lcl;
#ifdef WINNT
        // Update DDraw handle in driver GBL object.
        pdrv->hDD = pdrv_lcl->hDD;
#endif

        /*
         * DX5 or greater drivers get to know about read/write only locks
         * Note that dwDestFlags may later be zeroed for dest color key.
         * We pass read+write if the blt goes to/from the same buffer, of course.
         */
        if (pdrv->dwInternal1 >= 0x500 && this_src != this_dest )
        {
            dwSourceLockFlags = DDLOCK_READONLY;
            dwDestLockFlags = DDLOCK_WRITEONLY;
        }

        #ifdef USE_ALIAS
            if( pdrv->dwBusyDueToAliasedLock > 0 )
            {
                /*
                 * Aliased locks (the ones that don't take the Win16 lock) don't
                 * set the busy bit either (it can't or USER get's very confused).
                 * However, we must prevent blits happening via DirectDraw as
                 * otherwise we get into the old host talking to VRAM while
                 * blitter does at the same time. Bad. So fail if there is an
                 * outstanding aliased lock just as if the BUST bit had been
                 * set.
                 */
                DPF_ERR( "Graphics adapter is busy (due to a DirectDraw lock)" );
                LEAVE_BOTH();
                return DDERR_SURFACEBUSY;
            }
        #endif /* USE_ALIAS */

        /*
         * Behavior change:  In DX7, the default is to wait unless DDFASTBLT_DONOTWAIT=1.
         * In earlier releases, the default was to NOT wait unless DDFASTBLT_WAIT=1.
         * (The DDFASTBLT_DONOTWAIT flag was not defined until the DX7 release.)
         */
        if (!LOWERTHANSURFACE7(this_dest_int))
        {
            if (dwTrans & DDBLTFAST_DONOTWAIT)
            {
                if (dwTrans & DDBLTFAST_WAIT)
                {
                    DPF_ERR( "WAIT and DONOTWAIT flags are mutually exclusive" );
                    LEAVE_BOTH();
                    return DDERR_INVALIDPARAMS;
                }
            }
            else
            {
                dwTrans |= DDBLTFAST_WAIT;
            }
        }

        FlushD3DStates(this_src_lcl); // Need to flush src because it could be a rendertarget
        FlushD3DStates(this_dest_lcl);

        // Test and set the busy bit.  If it was already set, bail.
        {
            BOOL    isbusy = 0;

            pdflags = pdrv->lpwPDeviceFlags;
            #ifdef WIN95
                _asm
                {
                    mov eax, pdflags
                    bts word ptr [eax], BUSY_BIT
                    adc byte ptr isbusy,0
                }
            #else
                isbusy -= (InterlockedExchange((LPDWORD)pdflags,
                    *((LPDWORD)pdflags) | (1<<BUSY_BIT) ) == (1<<BUSY_BIT) );
            #endif
            if( isbusy )
            {
                DPF( 1, "BUSY - BltFast" );
                LEAVE_BOTH();
                return DDERR_SURFACEBUSY;
            }
        }
        /*
         * The following code was added to keep all of the HALs from
         * changing their Blt() code when they add video port support.
         * If the video port was using this surface but was recently
         * flipped, we will make sure that the flip actually occurred
         * before allowing access.  This allows double buffered capture
         * w/o tearing.
         */
        if( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT )
        {
            LPDDRAWI_DDVIDEOPORT_INT lpVideoPort;
            LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort_lcl;

            // Look at all video ports to see if any of them recently
            // flipped from this surface.
            lpVideoPort = pdrv->dvpList;
            while( NULL != lpVideoPort )
            {
                lpVideoPort_lcl = lpVideoPort->lpLcl;
                if( lpVideoPort_lcl->fpLastFlip == this_src->fpVidMem )
                {
                    // This can potentially tear - check the flip status
                    LPDDHALVPORTCB_GETFLIPSTATUS pfn;
                    DDHAL_GETVPORTFLIPSTATUSDATA GetFlipData;
                    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;

                    pdrv_lcl = this_src_lcl->lpSurfMore->lpDD_lcl;
                    pfn = pdrv_lcl->lpDDCB->HALDDVideoPort.GetVideoPortFlipStatus;
                    if( pfn != NULL )  // Will simply tear if function not supproted
                    {
                        GetFlipData.lpDD = pdrv_lcl;
                        GetFlipData.fpSurface = this_src->fpVidMem;

                    KeepTrying:
                        rc = DDHAL_DRIVER_NOTHANDLED;
                        DOHALCALL_NOWIN16( GetVideoPortFlipStatus, pfn, GetFlipData, rc, 0 );
                        if( ( DDHAL_DRIVER_HANDLED == rc ) &&
                            ( DDERR_WASSTILLDRAWING == GetFlipData.ddRVal ) )
                        {
                            if( dwTrans & DDBLTFAST_WAIT)
                            {
                                goto KeepTrying;
                            }
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_WASSTILLDRAWING;
                        }
                    }
                }
                lpVideoPort = lpVideoPort->lpLink;
            }
        }

RESTART_BLTFAST:

        /*
         *  Remove any cached RLE stuff for source surface
         */
        if( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
        {
            extern void FreeRleData(LPDDRAWI_DDRAWSURFACE_LCL psurf); //in fasthel.c
            FreeRleData( this_dest_lcl );
        }

        BUMP_SURFACE_STAMP(this_dest);
        /*
         * is either surface locked?
         */
        if( this_src->dwUsageCount > 0 || this_dest->dwUsageCount > 0 )
        {
            DPF_ERR( "Surface is locked" );
            LEAVE_BOTH_NOBUSY()
            return DDERR_SURFACEBUSY;
        }

        /*
         * It is possible this function could be called in the middle
         * of a mode, in which case we could trash the frame buffer.
         * To avoid regression, we will simply succeed the call without
         * actually doing anything.
         */
        if( ( pdrv->dwFlags & DDRAWI_CHANGINGMODE ) &&
            !( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
        {
            LEAVE_BOTH_NOBUSY()
            return DD_OK;
        }

        // no restrictions yet
        halonly = FALSE;
        helonly = FALSE;
        gdiblt = FALSE;

        // initialize the blit caps according to the surface types
        initBltCapsFast( this_dest_lcl->ddsCaps.dwCaps, this_src_lcl->ddsCaps.dwCaps, pdrv, lpbc );

        if( !( pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM ) &&
             ( ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) ||
               ( this_src_lcl->ddsCaps.dwCaps  & DDSCAPS_SYSTEMMEMORY ) ) )
        {
            lpbc->bHALSeesSysmem = FALSE;
            helonly = TRUE;

         
            #ifdef WINNT
                // On NT, the kernel needs to handle blts from system to the primary
                // surface, otherwise the sprite stuff won't work

                if( ( this_dest->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE ) &&
                    ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY ) &&
                    ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
                {
                    // However, there are several cases that the kernel
                    // emulation will not handle, so filter these out:

                    if (((dwTrans & DDBLTFAST_COLORKEY_MASK) == 0) &&
                        doPixelFormatsMatch(&this_src->ddpfSurface,
                                            &this_dest->lpDD->vmiData.ddpfDisplay))
                    {
                        lpbc->bHALSeesSysmem = TRUE;
                        helonly = FALSE;
                    }
                }
            #endif
        }
        if( ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM ) &&
            ( pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS ) )
        {
            /*
             * All blits where the destination is non-local are emulated,
             * unless its sys->NL, in which case we let the driver see it
             * if it set DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL.
             * initBltFastCaps() set up the correct caps for emulation as
             * both surfaces are video memory so all we need to do is to force
             * on emulation
             */
            if (! ((this_src_lcl->ddsCaps.dwCaps  & DDSCAPS_SYSTEMMEMORY) &&
                  (pdrv->ddCaps.dwCaps2 & DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL ))        )
            {
                lpbc->bHALSeesSysmem = FALSE;
                helonly = TRUE;
            }
        }

        /*
         * check for HEL composition buffer
         */
        if( (this_dest_lcl->dwFlags & DDRAWISURF_HELCB) ||
            (this_src_lcl->dwFlags & DDRAWISURF_HELCB) )
        {
            lpbc->bHALSeesSysmem = FALSE;
            helonly = TRUE;
        }


        /*
         * does the driver even allow bltting?
         */
        if( !(*(lpbc->dwBothCaps) & DDCAPS_BLT) )
        {
            BOOL        fail;
            fail = FALSE;
            GETFAILCODEBLT( *(lpbc->dwCaps),
                            *(lpbc->dwHELCaps),
                            halonly,
                            helonly,
                            DDCAPS_BLT );

            if( fail )
            {
                DPF_ERR( "Blt not supported" );
                LEAVE_BOTH_NOBUSY()
                return DDERR_NOBLTHW;
            }
        }

        /*
         * Check for special cases involving FOURCC surfaces:
         *   -- Copy blits between surfaces with identical FOURCC formats
         *   -- Compression/decompression of DXT* compressed textures
         */
        {
            DWORD dwDest4CC = 0;
            DWORD dwSrc4CC = 0;

            /*
             * Does either the source or dest surface have a FOURCC format?
             */
            if ((this_dest_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (this_dest->ddpfSurface.dwFlags & DDPF_FOURCC))
            {
                dwDest4CC = this_dest->ddpfSurface.dwFourCC;   // dest FOURCC format
            }

            if ((this_src_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (this_src->ddpfSurface.dwFlags & DDPF_FOURCC))
            {
                dwSrc4CC = this_src->ddpfSurface.dwFourCC;   // source FOURCC format
            }

            if (dwDest4CC | dwSrc4CC)
            {
                /*
                 * Yes, at least one of the two surfaces has a FOURCC format.
                 * Do the source and dest surfaces have precisely the same
                 * FOURCC format?  (If so, this is a FOURCC copy blit.)
                 */
                if (dwDest4CC == dwSrc4CC)
                {
                    // Yes, this is a FOURCC copy blit.  Can the driver handle this?
                    if ((pdrv->ddCaps.dwCaps2 & DDCAPS2_COPYFOURCC) == 0)
                    {
                        // The driver cannot handle FOURCC copy blits.
                        helonly = TRUE;
                    }
                }
                else
                {
                    /*
                     * No, the two surfaces have different pixel formats.
                     * Now determine if either surface has a DXT* FOURCC format.
                     * The rule for the Blt API call is that the HEL _ALWAYS_
                     * performs a blit involving a DXT* source or dest surface.
                     * Hardware acceleration for DXT* blits is available only
                     * with the AlphaBlt API call.  We now enforce this rule:
                     */
                    switch (dwDest4CC)
                    {
                    case MAKEFOURCC('D','X','T','1'):
                    case MAKEFOURCC('D','X','T','2'):
                    case MAKEFOURCC('D','X','T','3'):
                    case MAKEFOURCC('D','X','T','4'):
                    case MAKEFOURCC('D','X','T','5'):
                        // This is a blit to a DXT*-formatted surface.
                        helonly = TRUE;
                        break;
                    default:
                        break;
                    }
                    switch (dwSrc4CC)
                    {
                    case MAKEFOURCC('D','X','T','1'):
                    case MAKEFOURCC('D','X','T','2'):
                    case MAKEFOURCC('D','X','T','3'):
                    case MAKEFOURCC('D','X','T','4'):
                    case MAKEFOURCC('D','X','T','5'):
                        // This is a blit from a DXT*-formatted surface.
                        helonly = TRUE;
                        break;
                    default:
                        break;
                    }
                }
            }
        }

        /*
         * get src rectangle
         */
        if( lpSrcRect == NULL )
        {
            MAKE_SURF_RECT( this_src, this_src_lcl, bd.rSrc );
            src_height = this_src->wHeight;
            src_width = this_src->wWidth;
        }
        else
        {
            bd.rSrc = *(LPRECTL)lpSrcRect;
            src_height = (bd.rSrc.bottom-bd.rSrc.top);
            src_width = (bd.rSrc.right-bd.rSrc.left);

            if( (src_height <= 0) || ((int)src_width <= 0) )
            {
                DPF_ERR( "BLTFAST error. Can't have non-positive height or width for source rect" );
                LEAVE_BOTH_NOBUSY();
                return DDERR_INVALIDRECT;
            }

            // Multi-mon: is this the primary for the desktop? This
            // is the only case where the upper-left coord of the surface is not
            // (0,0)
            if( (this_src->lpDD->dwFlags & DDRAWI_VIRTUALDESKTOP) &&
                (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) )
            {
                if( (bd.rSrc.left   < this_src->lpDD->rectDesktop.left) ||
                    (bd.rSrc.top    < this_src->lpDD->rectDesktop.top)  ||
                    (bd.rSrc.right  > this_src->lpDD->rectDesktop.right)||
                    (bd.rSrc.bottom > this_src->lpDD->rectDesktop.bottom) )
                {
                    DPF_ERR( "BltFast Source dimensions doesn't fit on Desktop" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDRECT;
                }
                if( OverlapsDevices( this_src_lcl, (LPRECT) &bd.rSrc ) )
                {
                    helonly = gdiblt = TRUE;
                }
            }
            else
            {
                if( (int)bd.rSrc.left < 0 ||
                    (int)bd.rSrc.top < 0  ||
                    (DWORD)bd.rSrc.bottom > (DWORD)this_src->wHeight ||
                    (DWORD)bd.rSrc.right > (DWORD)this_src->wWidth )
                {
                    DPF_ERR( "Invalid BltFast Source dimensions" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDRECT;
                }

            }

        }

        /*
         * get destination rectangle
         */
        bd.rDest.top = dwY;
        bd.rDest.left = dwX;
        bd.rDest.bottom = dwY + (DWORD) src_height;
        bd.rDest.right = dwX + (DWORD) src_width;

        /*
         * Ensure the destination offsets are valid.
         */

        // Multi-mon: is this the primary for the desktop? This
        // is the only case where the upper-left coord of the surface is not
        // (0,0)
        if( (pdrv->dwFlags & DDRAWI_VIRTUALDESKTOP) &&
            (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) )
        {
            if( (bd.rDest.left   < pdrv->rectDesktop.left) ||
                (bd.rDest.top    < pdrv->rectDesktop.top)  ||
                (bd.rDest.right  > pdrv->rectDesktop.right)||
                (bd.rDest.bottom > pdrv->rectDesktop.bottom) )
            {
                DPF_ERR( "BltFast Destination doesn't fit on Desktop And No Clipper was specified" );
                LEAVE_BOTH_NOBUSY();
                return DDERR_INVALIDRECT;
            }
            if( OverlapsDevices( this_dest_lcl, (LPRECT) &bd.rDest ) )
            {
                helonly = gdiblt = TRUE;
            }
        }
        else
        {
            if( (int)bd.rDest.left < 0 ||
                (int)bd.rDest.top < 0  ||
                (DWORD)bd.rDest.bottom > (DWORD)this_dest->wHeight ||
                (DWORD)bd.rDest.right > (DWORD)this_dest->wWidth )
            {
                DPF_ERR( "Invalid BltFast destination dimensions" );
                LEAVE_BOTH_NOBUSY();
                return DDERR_INVALIDRECT;
            }
        }


        /*
         * transparent?
         */
        switch( dwTrans & DDBLTFAST_COLORKEY_MASK )
        {
        case DDBLTFAST_NOCOLORKEY:
            bd.dwFlags = DDBLT_ROP;
            break;
        case DDBLTFAST_SRCCOLORKEY:
            if( !(this_src_lcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) )
            {
                DPF_ERR( "No colorkey on source" );
                LEAVE_BOTH_NOBUSY()
                return DDERR_INVALIDPARAMS;
            }
            if( !(*(lpbc->dwBothCKeyCaps) & DDCKEYCAPS_SRCBLT) )
            {
                BOOL    fail;
                fail = FALSE;
                GETFAILCODEBLT( *(lpbc->dwCKeyCaps),
                    *(lpbc->dwHELCKeyCaps),
                    halonly,
                    helonly,
                    DDCKEYCAPS_SRCBLT );
                if( fail )
                {
                    DPF_ERR( "KEYSRC specified, not supported" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_NOCOLORKEYHW;
                }
            }
            bd.bltFX.ddckSrcColorkey = this_src_lcl->ddckCKSrcBlt;
            bd.dwFlags = DDBLT_ROP | DDBLT_KEYSRCOVERRIDE;
            break;
        case DDBLTFAST_DESTCOLORKEY:
            if( !(this_dest_lcl->dwFlags & DDRAWISURF_HASCKEYDESTBLT) )
            {
                DPF_ERR( "No colorkey on dest" );
                LEAVE_BOTH_NOBUSY()
                return DDERR_INVALIDPARAMS;
            }
            if( !(*(lpbc->dwBothCKeyCaps) & DDCKEYCAPS_DESTBLT) )
            {
                BOOL    fail;
                fail = FALSE;
                GETFAILCODEBLT( *(lpbc->dwCKeyCaps),
                    *(lpbc->dwHELCKeyCaps),
                    halonly,
                    helonly,
                    DDCKEYCAPS_DESTBLT );
                if( fail )
                {
                    DPF_ERR( "KEYDEST specified, not supported" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_NOCOLORKEYHW;
                }
            }
            bd.bltFX.ddckDestColorkey = this_dest_lcl->ddckCKDestBlt;
            bd.dwFlags = DDBLT_ROP | DDBLT_KEYDESTOVERRIDE;
            dwDestLockFlags = 0; //this means read/write
            break;
        }
    }
    #ifndef FASTFAST
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_BOTH_NOBUSY()
        return DDERR_INVALIDPARAMS;
    }
    #endif

    /*
     * do the blt
     */
    #ifndef FASTFAST
    TRY
    #endif
    {
        bd.bltFX.dwROP = SRCCOPY;
        bd.lpDDDestSurface = this_dest_lcl;
        bd.lpDDSrcSurface = this_src_lcl;

        if( helonly && halonly )
        {
            DPF_ERR( "BLT not supported in software or hardware" );
            LEAVE_BOTH_NOBUSY()
            return DDERR_NOBLTHW;
        }
        // Did the mode change since ENTER_DDRAW?
#ifdef WINNT
        if ( DdQueryDisplaySettingsUniqueness() != uDisplaySettingsUnique )
        {
            // mode changed, don't do the blt
            DPF_ERR( "Mode changed between ENTER_DDRAW and HAL call" );
            LEAVE_BOTH_NOBUSY()
            return DDERR_SURFACELOST;
        }
        if( !helonly )
        {
            if (!this_src_lcl->hDDSurface 
                && !CompleteCreateSysmemSurface(this_src_lcl))
            {
                DPF_ERR("Can't blt from SYSTEM surface w/o Kernel Object");
                LEAVE_BOTH_NOBUSY()
                return DDERR_GENERIC;
            }
            if (!this_dest_lcl->hDDSurface 
                && !CompleteCreateSysmemSurface(this_dest_lcl))
            {
                DPF_ERR("Can't blt to SYSTEM surface w/o Kernel Object");
                LEAVE_BOTH_NOBUSY()
                return DDERR_GENERIC;
            }
        }
#endif
        if( helonly ) // must be HEL call
        {
            DPF( 4, "Software FastBlt");
            bltfn = pdrv_lcl->lpDDCB->HELDDSurface.Blt;

            // take locks on vram surfaces
            if( ( ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) == 0) &&
                ( !gdiblt || !( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) ) )
            {
                while( 1 )
                {
                    ddrval = InternalLock( this_dest_lcl, &dest_bits, NULL, dwDestLockFlags );
                    if( ddrval == DD_OK )
                    {
                        GET_LPDDRAWSURFACE_GBL_MORE(this_dest)->fpNTAlias = (FLATPTR) dest_bits;
                        break;
                    }
                    if( ddrval == DDERR_WASSTILLDRAWING )
                    {
                        continue;
                    }
                    LEAVE_BOTH_NOBUSY()
                    return ddrval;
                }
                dest_lock_taken = TRUE;
            }
            else
            {
                /*
                 * If either surface was involved in a hardware op, we need to
                 * probe the driver to see if it's done. NOTE this assumes
                 * that only one driver can be responsible for a system memory
                 * operation.
                 */
                if( this_dest->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
                {
                    WaitForDriverToFinishWithSurface(pdrv_lcl, this_dest_lcl );
                }
                dest_lock_taken = FALSE;
            }

            if( (lpDDSrcSurface != lpDDDestSurface) &&
                ( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) == 0) )
            {
                if( MoveToSystemMemory( this_src_int, TRUE, FALSE ) == DD_OK )
                {
                    /*
                     * Don't need to check for continuing hardware op here because
                     * MoveToSystemMemory does InternalLock
                     */
                    src_lock_taken = FALSE;
                }
                else
                {
                    while( 1 )
                    {
                        ddrval = InternalLock( this_src_lcl, &src_bits, NULL, dwSourceLockFlags );
                        if( ddrval == DD_OK )
                        {
                            GET_LPDDRAWSURFACE_GBL_MORE(this_src)->fpNTAlias = (FLATPTR) src_bits;
                            break;
                        }
                        if( ddrval == DDERR_WASSTILLDRAWING )
                        {
                            continue;
                        }
                        if( dest_lock_taken )
                        {
                            InternalUnlock( this_dest_lcl, NULL, NULL, 0 );
                        }
                        LEAVE_BOTH_NOBUSY()
                        return ddrval;
                    }
                    src_lock_taken = TRUE;
                }
            }
            else
            {
                if( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) &&
                        (this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED ) )
                {
                    WaitForDriverToFinishWithSurface(pdrv_lcl, this_src_lcl );
                }
                src_lock_taken = FALSE;
            }
        }
        else
        {
            DPF( 4, "Hardware FastBlt");
            bltfn = pdrv_lcl->lpDDCB->HALDDSurface.Blt;
            bd.Blt = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.Blt;

            /*
             * Take pagelocks if required.
             * If we take the pagelocks, then the blt becomes synchronous.
             * A failure taking the pagelocks is pretty catastrophic, so no attempt
             * is made to fail over to software.
             */
            lpbc->bSourcePagelockTaken=FALSE;
            lpbc->bDestPagelockTaken=FALSE;

            if ( lpbc->bHALSeesSysmem )
            {
                /*
                 * If the HAL requires page locks...
                 */
                if ( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_NOPAGELOCKREQUIRED ) )
                {
                    HRESULT hr;
                    /*
                     * ...then setup to take them if they're not already pagelocked.
                     */
                    if ( ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY &&
                                                this_dest_lcl->lpSurfMore->dwPageLockCount == 0 ) )
                    {
                        hr = InternalPageLock( this_dest_lcl, pdrv_lcl );
                        if (FAILED(hr))
                        {
                            LEAVE_BOTH_NOBUSY()
                            return hr;
                        }
                        else
                        {
                            lpbc->bDestPagelockTaken=TRUE;
                        }
                    }

                    if ( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY &&
                                                this_src_lcl->lpSurfMore->dwPageLockCount == 0 ))
                    {
                        hr = InternalPageLock( this_src_lcl, pdrv_lcl );
                        if (FAILED(hr))
                        {
                            if (lpbc->bDestPagelockTaken)
                                InternalPageUnlock( this_dest_lcl, pdrv_lcl );

                            LEAVE_BOTH_NOBUSY()
                            return hr;
                        }
                        else
                        {
                            lpbc->bSourcePagelockTaken=TRUE;
                        }
                    }

                    /*
                    {
                        if (pdrv->dwFlags & DDRAWI_DISPLAYDRV)
                        {
                            lpbc->bHALSeesSysmem = FALSE;
                            helonly = TRUE;
                        }
                    } */
                }
            }
        }

        bd.lpDD = pdrv;
        bd.bltFX.dwSize = sizeof( bd.bltFX );

        if( this_dest_lcl->lpDDClipper == NULL )
        {
            bd.IsClipped = FALSE;   // no clipping in BltFast
try_again:
            if( helonly )
            {
                // Release busy now or GDI blt will fail
                DONE_BUSY();
            }
            DOHALCALL_NOWIN16( Blt, bltfn, bd, rc, helonly );
#ifdef WINNT
            if (rc == DDHAL_DRIVER_HANDLED && bd.ddRVal == DDERR_VISRGNCHANGED)
            {
                DPF(5,"Resetting VisRgn for surface %x", this_dest_lcl);
                DdResetVisrgn(this_dest_lcl, (HWND)0);
                goto try_again;
            }
#endif

            if ( (dwTrans & DDBLTFAST_WAIT) &&
                rc == DDHAL_DRIVER_HANDLED &&
                bd.ddRVal == DDERR_WASSTILLDRAWING )
            {
                DPF(4, "Waiting...");
                goto try_again;
            }
            DPF(5,"Driver returned %08x",bd.ddRVal);
            /*
             * Note that the !helonly here is pretty much an assert.
             * Thought it safer to actually test it, since that is actually what we mean.
             */
            if( !helonly && lpbc->bHALSeesSysmem && rc == DDHAL_DRIVER_HANDLED && bd.ddRVal == DD_OK)
            {
                DPF(5,B,"Tagging surfaces %08x and %08x",this_dest,this_src);
                if( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                    this_dest->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPDEST;
                if( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                    this_src->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPSOURCE;
            }
        }
        else
        {
            DPF_ERR( "Can't clip in BltFast" );
            bd.ddRVal = DDERR_BLTFASTCANTCLIP;
            rc = DDHAL_DRIVER_HANDLED;
        }

        if( helonly )
        {
            DONE_LOCKS();
        }

        if( rc != DDHAL_DRIVER_HANDLED )
        {
            /*
             * did the driver run out of hardware color key resources?
             */
            if( (rc == DDHAL_DRIVER_NOCKEYHW) &&
                ((dwTrans & DDBLTFAST_COLORKEY_MASK) == DDBLTFAST_SRCCOLORKEY) )
            {
                ddrval = ChangeToSoftwareColorKey( this_src_int, FALSE );
                if( ddrval == DD_OK )
                {
                    halonly = FALSE;
                    helonly = FALSE;
                    if (lpbc->bSourcePagelockTaken)
                    {
                        lpbc->bSourcePagelockTaken = FALSE;
                        InternalPageUnlock(this_src_lcl, pdrv_lcl);
                    }
                    if (lpbc->bDestPagelockTaken)
                    {
                        lpbc->bDestPagelockTaken = FALSE;
                        InternalPageUnlock(this_dest_lcl, pdrv_lcl);
                    }

                    goto RESTART_BLTFAST;
                }
                else
                {
                    bd.ddRVal = DDERR_NOCOLORKEYHW;
                }
            }
            else
            {
                bd.ddRVal = DDERR_UNSUPPORTED;
            }
        }

        DONE_BUSY();

        /*
         * Maintain old behaviour for old drivers (which do not export the
         * GetSysmemBltStatus HAL call) and just spin until they're done.
         * Any alternative could exercise new code paths in the driver
         * (e.g. reentered for a DMA operation)
         * We also spin if we had to take either pagelock ourselves.
         */
        if ( lpbc->bHALSeesSysmem &&
            (NULL == pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus || lpbc->bDestPagelockTaken || lpbc->bSourcePagelockTaken)
            )
        {
            if( this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
            {
                /*
                 * Wait on the destination surface only
                 */
                DDASSERT(this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
                while (DDERR_WASSTILLDRAWING == InternalGetBltStatus(pdrv_lcl, this_dest_lcl, DDGBS_ISBLTDONE))
                    ;
                this_src_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                this_dest_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
            }
            /*
             * Unpagelock if we took the pagelocks
             */
            if (lpbc->bDestPagelockTaken )
                InternalPageUnlock(this_dest_lcl, pdrv_lcl);
            if (lpbc->bSourcePagelockTaken)
                InternalPageUnlock(this_src_lcl, pdrv_lcl);
        }

        LEAVE_BOTH();
        if(IsD3DManaged(this_dest_lcl))
        {
            LPREGIONLIST lpRegionList = this_dest_lcl->lpSurfMore->lpRegionList;
            MarkDirty(this_dest_lcl);
            if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
            {
                lpRegionList->rect[(lpRegionList->rdh.nCount)++] = bd.rDest;
                lpRegionList->rdh.nRgnSize += sizeof(RECT);
                if(bd.rDest.left < lpRegionList->rdh.rcBound.left)
                    lpRegionList->rdh.rcBound.left = bd.rDest.left;
                if(bd.rDest.right > lpRegionList->rdh.rcBound.right)
                    lpRegionList->rdh.rcBound.right = bd.rDest.right;
                if(bd.rDest.top < lpRegionList->rdh.rcBound.top)
                    lpRegionList->rdh.rcBound.top = bd.rDest.top;
                if(bd.rDest.bottom > lpRegionList->rdh.rcBound.bottom)
                    lpRegionList->rdh.rcBound.bottom = bd.rDest.bottom;
            }
        }
        return bd.ddRVal;

    }
    #ifndef FASTFAST
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered processing blt" );
        DONE_LOCKS();
        DONE_BUSY();
        /*
         * Maintain old behaviour for old drivers (which do not export the
         * GetSysmemBltStatus HAL call) and just spin until they're done.
         * Any alternative could exercise new code paths in the driver
         * (e.g. reentered for a DMA operation)
         */
        if ( lpbc->bHALSeesSysmem &&
            (NULL == pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus || lpbc->bDestPagelockTaken || lpbc->bSourcePagelockTaken)
            )
        {
            if( this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
            {
                /*
                 * Wait on the destination surface only
                 */
                DDASSERT(this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
                while (DDERR_WASSTILLDRAWING == InternalGetBltStatus(pdrv_lcl, this_dest_lcl, DDGBS_ISBLTDONE))
                    ;
                this_src_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                this_dest_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
            }
            /*
             * Unpagelock if we took the pagelocks
             */
            if (lpbc->bDestPagelockTaken )
                InternalPageUnlock(this_dest_lcl, pdrv_lcl);
            if (lpbc->bSourcePagelockTaken)
                InternalPageUnlock(this_src_lcl, pdrv_lcl);
        }
        LEAVE_BOTH();
        return DDERR_EXCEPTION;
    }
    #endif

} /* DD_Surface_BltFast */

#undef DPF_MODNAME
#define DPF_MODNAME     "Blt"

/*
 * ROP table
 *
 * tells which ROPS require pattern surfaces and/or source surfaces
 */
static char cROPTable[] = {
        0,                      // 00  0         BLACKNESS
        ROP_HAS_SOURCEPATTERN,  // 01  DPSoon
        ROP_HAS_SOURCEPATTERN,  // 02  DPSona
        ROP_HAS_SOURCEPATTERN,  // 03  PSon
        ROP_HAS_SOURCEPATTERN,  // 04  SDPona
        ROP_HAS_PATTERN,        // 05  DPon
        ROP_HAS_SOURCEPATTERN,  // 06  PDSxnon
        ROP_HAS_SOURCEPATTERN,  // 07  PDSaon
        ROP_HAS_SOURCEPATTERN,  // 08  SDPnaa
        ROP_HAS_SOURCEPATTERN,  // 09  PDSxon
        ROP_HAS_PATTERN,        // 0A  DPna
        ROP_HAS_SOURCEPATTERN,  // 0B  PSDnaon
        ROP_HAS_SOURCEPATTERN,  // 0C  SPna
        ROP_HAS_SOURCEPATTERN,  // 0D  PDSnaon
        ROP_HAS_SOURCEPATTERN,  // 0E  PDSonon
        ROP_HAS_PATTERN,        // 0F  Pn
        ROP_HAS_SOURCEPATTERN,  // 10  PDSona
        ROP_HAS_SOURCE,         // 11  DSon      NOTSRCERASE
        ROP_HAS_SOURCEPATTERN,  // 12  SDPxnon
        ROP_HAS_SOURCEPATTERN,  // 13  SDPaon
        ROP_HAS_SOURCEPATTERN,  // 14  DPSxnon
        ROP_HAS_SOURCEPATTERN,  // 15  DPSaon
        ROP_HAS_SOURCEPATTERN,  // 16  PSDPSanaxx
        ROP_HAS_SOURCEPATTERN,  // 17  SSPxDSxaxn
        ROP_HAS_SOURCEPATTERN,  // 18  SPxPDxa
        ROP_HAS_SOURCEPATTERN,  // 19  SDPSanaxn
        ROP_HAS_SOURCEPATTERN,  // 1A  PDSPaox
        ROP_HAS_SOURCEPATTERN,  // 1B  SDPSxaxn
        ROP_HAS_SOURCEPATTERN,  // 1C  PSDPaox
        ROP_HAS_SOURCEPATTERN,  // 1D  DSPDxaxn
        ROP_HAS_SOURCEPATTERN,  // 1E  PDSox
        ROP_HAS_SOURCEPATTERN,  // 1F  PDSoan
        ROP_HAS_SOURCEPATTERN,  // 20  DPSnaa
        ROP_HAS_SOURCEPATTERN,  // 21  SDPxon
        ROP_HAS_SOURCE,         // 22  DSna
        ROP_HAS_SOURCEPATTERN,  // 23  SPDnaon
        ROP_HAS_SOURCEPATTERN,  // 24  SPxDSxa
        ROP_HAS_SOURCEPATTERN,  // 25  PDSPanaxn
        ROP_HAS_SOURCEPATTERN,  // 26  SDPSaox
        ROP_HAS_SOURCEPATTERN,  // 27  SDPSxnox
        ROP_HAS_SOURCEPATTERN,  // 28  DPSxa
        ROP_HAS_SOURCEPATTERN,  // 29  PSDPSaoxxn
        ROP_HAS_SOURCEPATTERN,  // 2A  DPSana
        ROP_HAS_SOURCEPATTERN,  // 2B  SSPxPDxaxn
        ROP_HAS_SOURCEPATTERN,  // 2C  SPDSoax
        ROP_HAS_SOURCEPATTERN,  // 2D  PSDnox
        ROP_HAS_SOURCEPATTERN,  // 2E  PSDPxox
        ROP_HAS_SOURCEPATTERN,  // 2F  PSDnoan
        ROP_HAS_SOURCEPATTERN,  // 30  PSna
        ROP_HAS_SOURCEPATTERN,  // 31  SDPnaon
        ROP_HAS_SOURCEPATTERN,  // 32  SDPSoox
        ROP_HAS_SOURCE,         // 33  Sn        NOTSRCCOPY
        ROP_HAS_SOURCEPATTERN,  // 34  SPDSaox
        ROP_HAS_SOURCEPATTERN,  // 35  SPDSxnox
        ROP_HAS_SOURCEPATTERN,  // 36  SDPox
        ROP_HAS_SOURCEPATTERN,  // 37  SDPoan
        ROP_HAS_SOURCEPATTERN,  // 38  PSDPoax
        ROP_HAS_SOURCEPATTERN,  // 39  SPDnox
        ROP_HAS_SOURCEPATTERN,  // 3A  SPDSxox
        ROP_HAS_SOURCEPATTERN,  // 3B  SPDnoan
        ROP_HAS_SOURCEPATTERN,  // 3C  PSx
        ROP_HAS_SOURCEPATTERN,  // 3D  SPDSonox
        ROP_HAS_SOURCEPATTERN,  // 3E  SPDSnaox
        ROP_HAS_SOURCEPATTERN,  // 3F  PSan
        ROP_HAS_SOURCEPATTERN,  // 40  PSDnaa
        ROP_HAS_SOURCEPATTERN,  // 41  DPSxon
        ROP_HAS_SOURCEPATTERN,  // 42  SDxPDxa
        ROP_HAS_SOURCEPATTERN,  // 43  SPDSanaxn
        ROP_HAS_SOURCE,         // 44  SDna      SRCERASE
        ROP_HAS_SOURCEPATTERN,  // 45  DPSnaon
        ROP_HAS_SOURCEPATTERN,  // 46  DSPDaox
        ROP_HAS_SOURCEPATTERN,  // 47  PSDPxaxn
        ROP_HAS_SOURCEPATTERN,  // 48  SDPxa
        ROP_HAS_SOURCEPATTERN,  // 49  PDSPDaoxxn
        ROP_HAS_SOURCEPATTERN,  // 4A  DPSDoax
        ROP_HAS_SOURCEPATTERN,  // 4B  PDSnox
        ROP_HAS_SOURCEPATTERN,  // 4C  SDPana
        ROP_HAS_SOURCEPATTERN,  // 4D  SSPxDSxoxn
        ROP_HAS_SOURCEPATTERN,  // 4E  PDSPxox
        ROP_HAS_SOURCEPATTERN,  // 4F  PDSnoan
        ROP_HAS_PATTERN,        // 50  PDna
        ROP_HAS_SOURCEPATTERN,  // 51  DSPnaon
        ROP_HAS_SOURCEPATTERN,  // 52  DPSDaox
        ROP_HAS_SOURCEPATTERN,  // 53  SPDSxaxn
        ROP_HAS_SOURCEPATTERN,  // 54  DPSonon
        0,                      // 55  Dn        DSTINVERT
        ROP_HAS_SOURCEPATTERN,  // 56  DPSox
        ROP_HAS_SOURCEPATTERN,  // 57  DPSoan
        ROP_HAS_SOURCEPATTERN,  // 58  PDSPoax
        ROP_HAS_SOURCEPATTERN,  // 59  DPSnox
        ROP_HAS_PATTERN,        // 5A  DPx       PATINVERT
        ROP_HAS_SOURCEPATTERN,  // 5B  DPSDonox
        ROP_HAS_SOURCEPATTERN,  // 5C  DPSDxox
        ROP_HAS_SOURCEPATTERN,  // 5D  DPSnoan
        ROP_HAS_SOURCEPATTERN,  // 5E  DPSDnaox
        ROP_HAS_PATTERN,        // 5F  DPan
        ROP_HAS_SOURCEPATTERN,  // 60  PDSxa
        ROP_HAS_SOURCEPATTERN,  // 61  DSPDSaoxxn
        ROP_HAS_SOURCEPATTERN,  // 62  DSPDoax
        ROP_HAS_SOURCEPATTERN,  // 63  SDPnox
        ROP_HAS_SOURCEPATTERN,  // 64  SDPSoax
        ROP_HAS_SOURCEPATTERN,  // 65  DSPnox
        ROP_HAS_SOURCE,         // 66  DSx       SRCINVERT
        ROP_HAS_SOURCEPATTERN,  // 67  SDPSonox
        ROP_HAS_SOURCEPATTERN,  // 68  DSPDSonoxxn
        ROP_HAS_SOURCEPATTERN,  // 69  PDSxxn
        ROP_HAS_SOURCEPATTERN,  // 6A  DPSax
        ROP_HAS_SOURCEPATTERN,  // 6B  PSDPSoaxxn
        ROP_HAS_SOURCEPATTERN,  // 6C  SDPax
        ROP_HAS_SOURCEPATTERN,  // 6D  PDSPDoaxxn
        ROP_HAS_SOURCEPATTERN,  // 6E  SDPSnoax
        ROP_HAS_SOURCEPATTERN,  // 6F  PDSxnan
        ROP_HAS_SOURCEPATTERN,  // 70  PDSana
        ROP_HAS_SOURCEPATTERN,  // 71  SSDxPDxaxn
        ROP_HAS_SOURCEPATTERN,  // 72  SDPSxox
        ROP_HAS_SOURCEPATTERN,  // 73  SDPnoan
        ROP_HAS_SOURCEPATTERN,  // 74  DSPDxox
        ROP_HAS_SOURCEPATTERN,  // 75  DSPnoan
        ROP_HAS_SOURCEPATTERN,  // 76  SDPSnaox
        ROP_HAS_SOURCE,         // 77  DSan
        ROP_HAS_SOURCEPATTERN,  // 78  PDSax
        ROP_HAS_SOURCEPATTERN,  // 79  DSPDSoaxxn
        ROP_HAS_SOURCEPATTERN,  // 7A  DPSDnoax
        ROP_HAS_SOURCEPATTERN,  // 7B  SDPxnan
        ROP_HAS_SOURCEPATTERN,  // 7C  SPDSnoax
        ROP_HAS_SOURCEPATTERN,  // 7D  DPSxnan
        ROP_HAS_SOURCEPATTERN,  // 7E  SPxDSxo
        ROP_HAS_SOURCEPATTERN,  // 7F  DPSaan
        ROP_HAS_SOURCEPATTERN,  // 80  DPSaa
        ROP_HAS_SOURCEPATTERN,  // 81  SPxDSxon
        ROP_HAS_SOURCEPATTERN,  // 82  DPSxna
        ROP_HAS_SOURCEPATTERN,  // 83  SPDSnoaxn
        ROP_HAS_SOURCEPATTERN,  // 84  SDPxna
        ROP_HAS_SOURCEPATTERN,  // 85  PDSPnoaxn
        ROP_HAS_SOURCEPATTERN,  // 86  DSPDSoaxx
        ROP_HAS_SOURCEPATTERN,  // 87  PDSaxn
        ROP_HAS_SOURCE,         // 88  DSa       SRCAND
        ROP_HAS_SOURCEPATTERN,  // 89  SDPSnaoxn
        ROP_HAS_SOURCEPATTERN,  // 8A  DSPnoa
        ROP_HAS_SOURCEPATTERN,  // 8B  DSPDxoxn
        ROP_HAS_SOURCEPATTERN,  // 8C  SDPnoa
        ROP_HAS_SOURCEPATTERN,  // 8D  SDPSxoxn
        ROP_HAS_SOURCEPATTERN,  // 8E  SSDxPDxax
        ROP_HAS_SOURCEPATTERN,  // 8F  PDSanan
        ROP_HAS_SOURCEPATTERN,  // 90  PDSxna
        ROP_HAS_SOURCEPATTERN,  // 91  SDPSnoaxn
        ROP_HAS_SOURCEPATTERN,  // 92  DPSDPoaxx
        ROP_HAS_SOURCEPATTERN,  // 93  SPDaxn
        ROP_HAS_SOURCEPATTERN,  // 94  PSDPSoaxx
        ROP_HAS_SOURCEPATTERN,  // 95  DPSaxn
        ROP_HAS_SOURCEPATTERN,  // 96  DPSxx
        ROP_HAS_SOURCEPATTERN,  // 97  PSDPSonoxx
        ROP_HAS_SOURCEPATTERN,  // 98  SDPSonoxn
        ROP_HAS_SOURCE,         // 99  DSxn
        ROP_HAS_SOURCEPATTERN,  // 9A  DPSnax
        ROP_HAS_SOURCEPATTERN,  // 9B  SDPSoaxn
        ROP_HAS_SOURCEPATTERN,  // 9C  SPDnax
        ROP_HAS_SOURCEPATTERN,  // 9D  DSPDoaxn
        ROP_HAS_SOURCEPATTERN,  // 9E  DSPDSaoxx
        ROP_HAS_SOURCEPATTERN,  // 9F  PDSxan
        ROP_HAS_PATTERN,        // A0  DPa
        ROP_HAS_SOURCEPATTERN,  // A1  PDSPnaoxn
        ROP_HAS_SOURCEPATTERN,  // A2  DPSnoa
        ROP_HAS_SOURCEPATTERN,  // A3  DPSDxoxn
        ROP_HAS_SOURCEPATTERN,  // A4  PDSPonoxn
        ROP_HAS_PATTERN,        // A5  PDxn
        ROP_HAS_SOURCEPATTERN,  // A6  DSPnax
        ROP_HAS_SOURCEPATTERN,  // A7  PDSPoaxn
        ROP_HAS_SOURCEPATTERN,  // A8  DPSoa
        ROP_HAS_SOURCEPATTERN,  // A9  DPSoxn
        0,                      // AA  D
        ROP_HAS_SOURCEPATTERN,  // AB  DPSono
        ROP_HAS_SOURCEPATTERN,  // AC  SPDSxax
        ROP_HAS_SOURCEPATTERN,  // AD  DPSDaoxn
        ROP_HAS_SOURCEPATTERN,  // AE  DSPnao
        ROP_HAS_PATTERN,        // AF  DPno
        ROP_HAS_SOURCEPATTERN,  // B0  PDSnoa
        ROP_HAS_SOURCEPATTERN,  // B1  PDSPxoxn
        ROP_HAS_SOURCEPATTERN,  // B2  SSPxDSxox
        ROP_HAS_SOURCEPATTERN,  // B3  SDPanan
        ROP_HAS_SOURCEPATTERN,  // B4  PSDnax
        ROP_HAS_SOURCEPATTERN,  // B5  DPSDoaxn
        ROP_HAS_SOURCEPATTERN,  // B6  DPSDPaoxx
        ROP_HAS_SOURCEPATTERN,  // B7  SDPxan
        ROP_HAS_SOURCEPATTERN,  // B8  PSDPxax
        ROP_HAS_SOURCEPATTERN,  // B9  DSPDaoxn
        ROP_HAS_SOURCEPATTERN,  // BA  DPSnao
        ROP_HAS_SOURCE,         // BB  DSno      MERGEPAINT
        ROP_HAS_SOURCEPATTERN,  // BC  SPDSanax
        ROP_HAS_SOURCEPATTERN,  // BD  SDxPDxan
        ROP_HAS_SOURCEPATTERN,  // BE  DPSxo
        ROP_HAS_SOURCEPATTERN,  // BF  DPSano    MERGECOPY
        ROP_HAS_SOURCEPATTERN,  // C0  PSa
        ROP_HAS_SOURCEPATTERN,  // C1  SPDSnaoxn
        ROP_HAS_SOURCEPATTERN,  // C2  SPDSonoxn
        ROP_HAS_SOURCEPATTERN,  // C3  PSxn
        ROP_HAS_SOURCEPATTERN,  // C4  SPDnoa
        ROP_HAS_SOURCEPATTERN,  // C5  SPDSxoxn
        ROP_HAS_SOURCEPATTERN,  // C6  SDPnax
        ROP_HAS_SOURCEPATTERN,  // C7  PSDPoaxn
        ROP_HAS_SOURCEPATTERN,  // C8  SDPoa
        ROP_HAS_SOURCEPATTERN,  // C9  SPDoxn
        ROP_HAS_SOURCEPATTERN,  // CA  DPSDxax
        ROP_HAS_SOURCEPATTERN,  // CB  SPDSaoxn
        ROP_HAS_SOURCE,         // CC  S         SRCCOPY
        ROP_HAS_SOURCEPATTERN,  // CD  SDPono
        ROP_HAS_SOURCEPATTERN,  // CE  SDPnao
        ROP_HAS_SOURCEPATTERN,  // CF  SPno
        ROP_HAS_SOURCEPATTERN,  // D0  PSDnoa
        ROP_HAS_SOURCEPATTERN,  // D1  PSDPxoxn
        ROP_HAS_SOURCEPATTERN,  // D2  PDSnax
        ROP_HAS_SOURCEPATTERN,  // D3  SPDSoaxn
        ROP_HAS_SOURCEPATTERN,  // D4  SSPxPDxax
        ROP_HAS_SOURCEPATTERN,  // D5  DPSanan
        ROP_HAS_SOURCEPATTERN,  // D6  PSDPSaoxx
        ROP_HAS_SOURCEPATTERN,  // D7  DPSxan
        ROP_HAS_SOURCEPATTERN,  // D8  PDSPxax
        ROP_HAS_SOURCEPATTERN,  // D9  SDPSaoxn
        ROP_HAS_SOURCEPATTERN,  // DA  DPSDanax
        ROP_HAS_SOURCEPATTERN,  // DB  SPxDSxan
        ROP_HAS_SOURCEPATTERN,  // DC  SPDnao
        ROP_HAS_SOURCE,         // DD  SDno
        ROP_HAS_SOURCEPATTERN,  // DE  SDPxo
        ROP_HAS_SOURCEPATTERN,  // DF  SDPano
        ROP_HAS_SOURCEPATTERN,  // E0  PDSoa
        ROP_HAS_SOURCEPATTERN,  // E1  PDSoxn
        ROP_HAS_SOURCEPATTERN,  // E2  DSPDxax
        ROP_HAS_SOURCEPATTERN,  // E3  PSDPaoxn
        ROP_HAS_SOURCEPATTERN,  // E4  SDPSxax
        ROP_HAS_SOURCEPATTERN,  // E5  PDSPaoxn
        ROP_HAS_SOURCEPATTERN,  // E6  SDPSanax
        ROP_HAS_SOURCEPATTERN,  // E7  SPxPDxan
        ROP_HAS_SOURCEPATTERN,  // E8  SSPxDSxax
        ROP_HAS_SOURCEPATTERN,  // E9  DSPDSanaxxn
        ROP_HAS_SOURCEPATTERN,  // EA  DPSao
        ROP_HAS_SOURCEPATTERN,  // EB  DPSxno
        ROP_HAS_SOURCEPATTERN,  // EC  SDPao
        ROP_HAS_SOURCEPATTERN,  // ED  SDPxno
        ROP_HAS_SOURCE,         // EE  DSo       SRCPAINT
        ROP_HAS_SOURCEPATTERN,  // EF  SDPnoo
        ROP_HAS_PATTERN,        // F0  P         PATCOPY
        ROP_HAS_SOURCEPATTERN,  // F1  PDSono
        ROP_HAS_SOURCEPATTERN,  // F2  PDSnao
        ROP_HAS_SOURCEPATTERN,  // F3  PSno
        ROP_HAS_SOURCEPATTERN,  // F4  PSDnao
        ROP_HAS_PATTERN,        // F5  PDno
        ROP_HAS_SOURCEPATTERN,  // F6  PDSxo
        ROP_HAS_SOURCEPATTERN,  // F7  PDSano
        ROP_HAS_SOURCEPATTERN,  // F8  PDSao
        ROP_HAS_SOURCEPATTERN,  // F9  PDSxno
        ROP_HAS_PATTERN,        // FA  DPo
        ROP_HAS_SOURCEPATTERN,  // FB  DPSnoo    PATPAINT
        ROP_HAS_SOURCEPATTERN,  // FC  PSo
        ROP_HAS_SOURCEPATTERN,  // FD  PSDnoo
        ROP_HAS_SOURCEPATTERN,  // FE  DPSoo
        0                       // FF  1         WHITENESS
};

/*
 * checkBltStretching
 *
 * check and see if we can stretch or not
 */
HRESULT checkBltStretching(
                LPBLTCAPS lpbc,
                LPSPECIAL_BLT_DATA psbd )
{
    DWORD               caps;
    BOOL                fail;

    fail = FALSE;

    /*
     * can we even stretch at all?
     */
    if( !(*(lpbc->dwBothCaps) & DDCAPS_BLTSTRETCH))
    {
        GETFAILCODEBLT( *(lpbc->dwCaps),
                        *(lpbc->dwHELCaps),
                        psbd->halonly,
                        psbd->helonly,
                        DDCAPS_BLTSTRETCH );
        if( fail )
        {
            return DDERR_NOSTRETCHHW;
        }
    }

    if (psbd->helonly)
        caps = *(lpbc->dwHELFXCaps);
    else
        caps = *(lpbc->dwFXCaps);

    /*
     * verify height
     */
    if( psbd->src_height != psbd->dest_height )
    {
        if( psbd->src_height > psbd->dest_height )
        {
            /*
             * can we shrink Y arbitrarily?
             */
            if( !(caps & (DDFXCAPS_BLTSHRINKY) ) )
            {
                /*
                 * see if this is a non-integer shrink
                 */
                if( (psbd->src_height % psbd->dest_height) != 0 )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSHRINKY );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                /*
                 * see if we can integer shrink
                 */
                }
                else if( !(caps & DDFXCAPS_BLTSHRINKYN) )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSHRINKYN );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                }
            }
        }
        else
        {
            if( !(caps & DDFXCAPS_BLTSTRETCHY) )
            {
                /*
                 * see if this is a non-integer stretch
                 */
                if( (psbd->dest_height % psbd->src_height) != 0 )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSTRETCHY );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                /*
                 * see if we can integer stretch
                 */
                }
                else if( !(caps & DDFXCAPS_BLTSTRETCHYN) )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSTRETCHYN );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                }
            }
        }
    }

    /*
     * verify width
     */
    if( psbd->src_width != psbd->dest_width )
    {
        if( psbd->src_width > psbd->dest_width )
        {
            if( !(caps & DDFXCAPS_BLTSHRINKX) )
            {
                /*
                 * see if this is a non-integer shrink
                 */
                if( (psbd->src_width % psbd->dest_width) != 0 )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSHRINKX );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                /*
                 * see if we can integer shrink
                 */
                }
                else if( !(caps & DDFXCAPS_BLTSHRINKXN) )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSHRINKXN );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                }
            }
        }
        else
        {
            if( !(caps & DDFXCAPS_BLTSTRETCHX) )
            {
                /*
                 * see if this is a non-integer stretch
                 */
                if( (psbd->dest_width % psbd->src_width) != 0 )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSTRETCHX );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                }
                if( !(caps & DDFXCAPS_BLTSTRETCHXN) )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSTRETCHXN );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                }
            }
        }
    }

    return DD_OK;

} /* checkBltStretching */

/*
 * FindAttached
 *
 * find an attached surface with particular caps
 */
LPDDRAWI_DDRAWSURFACE_LCL FindAttached( LPDDRAWI_DDRAWSURFACE_LCL ptr_lcl, DWORD caps )
{
    LPATTACHLIST                pal;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;

    pal = ptr_lcl->lpAttachList;
    while( pal != NULL )
    {
        psurf_lcl = pal->lpAttached;
        if( psurf_lcl->ddsCaps.dwCaps & caps )
        {
            return psurf_lcl;
        }
        pal = pal->lpLink;
    }
    return NULL;

} /* FindAttached */

#if defined(WIN95)
    #define DONE_EXCLUDE() \
        if( this_dest_lcl->lpDDClipper != NULL ) \
        { \
            if ( (pdrv->dwFlags & DDRAWI_DISPLAYDRV) && pdrv->dwPDevice && \
                !(*pdrv->lpwPDeviceFlags & HARDWARECURSOR)) \
            { \
                DD16_Unexclude(pdrv->dwPDevice); \
            } \
        }
#elif defined(WINNT)
    #define DONE_EXCLUDE() ;
#endif

/*
 * DD_Surface_Blt
 *
 * Bit Blt from one surface to another
 */
HRESULT DDAPI DD_Surface_Blt(
                LPDIRECTDRAWSURFACE lpDDDestSurface,
                LPRECT lpDestRect,
                LPDIRECTDRAWSURFACE lpDDSrcSurface,
                LPRECT lpSrcRect,
                DWORD dwFlags,
                LPDDBLTFX lpDDBltFX )
{
    DWORD           rc;
    DWORD           rop;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_src_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL   this_dest_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this_src;
    LPDDRAWI_DDRAWSURFACE_GBL   this_dest;
    LPDDRAWI_DDRAWSURFACE_INT   this_src_int;
    LPDDRAWI_DDRAWSURFACE_INT   this_dest_int;
    BOOL            need_pat;
    SPECIAL_BLT_DATA        sbd;
    BOOL            stretch_blt;
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    DDHAL_BLTDATA       bd;
    RECT            DestRect;
    BOOL            fail;
    BOOL            dest_lock_taken=FALSE;
    BOOL            src_lock_taken=FALSE;
    BOOL            dest_pagelock_taken=FALSE;
    BOOL            src_pagelock_taken=FALSE;
    LPVOID          dest_bits;
    LPVOID          src_bits;
    HRESULT         ddrval;
    BLTCAPS         bc;
    LPBLTCAPS           lpbc=&bc;
    LPWORD          pdflags=0;
    DWORD                       dwSourceLockFlags=0;
    DWORD                       dwDestLockFlags=0;
    BOOL            gdiblt;
    LPDDPIXELFORMAT pddpf;
    BOOL            subrect_lock_taken = FALSE;
    RECT            subrect_lock_rect;

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_Blt");

    TRY
    {
        ZeroMemory(&bd, sizeof(bd));    // initialize to zero

        /*
         * validate surface ptrs
         */
        this_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDDestSurface;
        this_src_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSrcSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_dest_int ) )
        {
            DPF_ERR( "Invalid dest specified") ;
            LEAVE_BOTH();
            return DDERR_INVALIDOBJECT;
        }
        this_dest_lcl = this_dest_int->lpLcl;
        this_dest = this_dest_lcl->lpGbl;
        if( SURFACE_LOST( this_dest_lcl ) )
        {
            DPF( 1, "Dest lost") ;
            LEAVE_BOTH();
            return DDERR_SURFACELOST;
        }
        if( this_src_int != NULL )
        {
            if( !VALID_DIRECTDRAWSURFACE_PTR( this_src_int ) )
            {
                DPF_ERR( "Invalid source specified" );
                LEAVE_BOTH();
                return DDERR_INVALIDOBJECT;
            }
            this_src_lcl = this_src_int->lpLcl;
            this_src = this_src_lcl->lpGbl;
            if( SURFACE_LOST( this_src_lcl ) )
            {
                DPF_ERR( "Src lost") ;
                LEAVE_BOTH();
                return DDERR_SURFACELOST;
            }
        }
        else
        {
            this_src_lcl = NULL;
            this_src = NULL;
        }

        if ( (DDBLT_DX8ORHIGHER & dwFlags) && ( DDBLT_WINDOWCLIP & dwFlags ) )
        {
            LPDDRAWI_DDRAWCLIPPER_INT   lpDDIClipper =
                this_dest_lcl->lpSurfMore->lpDDIClipper;
            if (lpDDIClipper && (DDSCAPS_PRIMARYSURFACE &
                this_dest_lcl->ddsCaps.dwCaps))
            {
                HWND    hWnd = (HWND)lpDDIClipper->lpLcl->lpGbl->hWnd;
                if (GetClientRect(hWnd, &DestRect))
                {
                    if(( lpDestRect != NULL ) && VALID_RECT_PTR( lpDestRect ))
                    {
                        if (DestRect.right > lpDestRect->right)
                            DestRect.right = lpDestRect->right;
                        if (DestRect.bottom > lpDestRect->bottom)
                            DestRect.bottom = lpDestRect->bottom;
                        if (0 < lpDestRect->left)
                            DestRect.left = lpDestRect->left;
                        if (0 < lpDestRect->top)
                            DestRect.top = lpDestRect->top;
                        if (DestRect.top >= DestRect.bottom ||
                            DestRect.left >= DestRect.right)
                        {
                            // in case of insane RECT, fail it
                            DPF_ERR("Unable to Blt with invalid dest RECT");
                            LEAVE_BOTH();
                            return DDERR_INVALIDPARAMS;
                        }
                    }
                    if (!ClientToScreen(hWnd,(POINT*)&DestRect))
                        DPF_ERR("ClientToScreen Failed on DestRect?");
                    if (!ClientToScreen(hWnd,(POINT*)&DestRect.right))
                        DPF_ERR("ClientToScreen Failed on DestRect.right?");
                    // in DX8 we always have DDRAWILCL_EXPLICITMONITOR so
                    // DestRect must be checked and adjusted against DeviceRect
                    pdrv = this_dest->lpDD;  
                    /*
                     * Do a real quick check w/o accounting for the clipper
                     */
                    if( ( DestRect.top < pdrv->rectDevice.top ) ||
                        ( DestRect.left < pdrv->rectDevice.left ) ||
                        ( DestRect.right > pdrv->rectDevice.right ) ||
                        ( DestRect.bottom > pdrv->rectDevice.bottom ) )
                    {
                        RECT    rect;
                        /*
                         * It may only be that part of the rect is off of the desktop,
                         * in which case we don't neccesarily need to drop to emulation.
                         */
                        IntersectRect( &rect, &DestRect, &pdrv->rectDesktop );
                        if( ( rect.top < pdrv->rectDevice.top ) ||
                            ( rect.left < pdrv->rectDevice.left ) ||
                            ( rect.right > pdrv->rectDevice.right ) ||
                            ( rect.bottom > pdrv->rectDevice.bottom ) )
                        {
                            // fail crossdevice blt and let GDI do it in DdBlt()
                            LEAVE_BOTH();
                            return DDERR_INVALIDPARAMS;
                        }
                    }
                    if (!OffsetRect(&DestRect, -pdrv->rectDevice.left,
                        -pdrv->rectDevice.top))
                        DPF_ERR("OffsetRect Failed on DestRect?");
                    lpDestRect = &DestRect; // replace it with new Rect
                    DPF(10,"Got a new dest RECT !!");
                    if (DDBLT_COPYVSYNC & dwFlags) 
                    {
                        DWORD                msCurrentTime = 0;
                        DWORD                msStartTime = GetTickCount();
                        LPDDHAL_GETSCANLINE gslhalfn;
                        LPDDHAL_GETSCANLINE gslfn;
                        LPDDRAWI_DIRECTDRAW_LCL this_lcl =
                            this_dest_lcl->lpSurfMore->lpDD_lcl;
                        gslfn = this_lcl->lpDDCB->HALDD.GetScanLine;
                        gslhalfn = this_lcl->lpDDCB->cbDDCallbacks.GetScanLine;
                        if( gslhalfn != NULL )
                        {
                            DDHAL_GETSCANLINEDATA       gsld;
                            DWORD                       rc;
                            gsld.GetScanLine = gslhalfn;
                            gsld.lpDD = this_lcl->lpGbl;
                            do
                            {
                                DOHALCALL_NOWIN16( GetScanLine, gslfn, gsld, rc, FALSE );
                                if ( DD_OK != gsld.ddRVal )
                                    break;
                                if ( (LONG)gsld.dwScanLine >= DestRect.bottom )
                                    break;

                                msCurrentTime = GetTickCount();
                            
                                // If we've been spinning here for 30ms
                                // then blt anyway; probably something
                                // taking up CPU cycles
                                if ( (msCurrentTime - msStartTime) > 30 )
                                {
                                    break;
                                }

                            } while ( DDHAL_DRIVER_HANDLED == rc );
                        }
                    }
                }
                else
                {
                    DPF_ERR("GetClientRect Failed ?");
                }
            }

            // Don't let these DX8-only flags propagate to driver (or rest of Blt code)
            // since they alias other existing flags.
            dwFlags &= ~(DDBLT_WINDOWCLIP | DDBLT_COPYVSYNC | DDBLT_DX8ORHIGHER);

        }

        if( dwFlags & ~DDBLT_VALID )
        {
            DPF_ERR( "Invalid flags") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * BEHAVIOUR CHANGE FOR DX5
         *
         * We do not allow bltting between surfaces created with different DirectDraw
         * objects.
         */
        if (this_src)
        {
            if (this_dest_lcl->lpSurfMore->lpDD_lcl->lpGbl != this_src_lcl->lpSurfMore->lpDD_lcl->lpGbl)
            {
                if ((this_dest_lcl->lpSurfMore->lpDD_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV) &&
                    (this_src_lcl->lpSurfMore->lpDD_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV))
                {
                    DPF_ERR("Can't blt surfaces between different direct draw devices");
                    LEAVE_BOTH();
                    return DDERR_DEVICEDOESNTOWNSURFACE;
                }
            }
        }

        //
        // If either surface is optimized, quit
        //
        if (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "Can't blt optimized surfaces") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

        if (this_src)
        {
            if (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
            {
                DPF_ERR( "Can't blt optimized surfaces") ;
                LEAVE_BOTH();
                return DDERR_INVALIDPARAMS;
            }
        }

        /*
     * Since Z Blts are currently turned off, we might as well give some
     * hint that this is the case.
     */
#ifdef DEBUG
        if( dwFlags & ( DDBLT_ZBUFFER | DDBLT_ZBUFFERDESTCONSTOVERRIDE |
                        DDBLT_ZBUFFERDESTOVERRIDE | DDBLT_ZBUFFERSRCCONSTOVERRIDE |
                        DDBLT_ZBUFFERSRCOVERRIDE ) )
        {
            DPF_ERR( "Z aware BLTs are not currently supported" );
            LEAVE_BOTH();
            return DDERR_NOZBUFFERHW;
        }
#endif

        pdrv = this_dest->lpDD;
        pdrv_lcl = this_dest_lcl->lpSurfMore->lpDD_lcl;
        #ifdef WINNT
            // Update DDraw handle in driver GBL object.
            pdrv->hDD = pdrv_lcl->hDD;
        #endif

        /*
         * DX5 or greater drivers get to know about read/write only locks
         * Note that dwDestFlags may later be modified for dest color key.
         * Pass zero for both flags unless:
         *  -it's a color fill, in which case turn on writeonly for dest.
         *  -the blt goes from/to different surfaces,
         */
        if ( (pdrv->dwInternal1 >= 0x500)
             && ((this_src == NULL) || (this_src != this_dest) ) )
        {
            dwSourceLockFlags = DDLOCK_READONLY;
            dwDestLockFlags = DDLOCK_WRITEONLY;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_BOTH();
        return DDERR_INVALIDPARAMS;
    }

#ifdef USE_ALIAS
    if( pdrv->dwBusyDueToAliasedLock > 0 )
    {
        /*
         * Aliased locks (the ones that don't take the Win16 lock) don't
         * set the busy bit either (it can't or USER get's very confused).
         * However, we must prevent blits happening via DirectDraw as
         * otherwise we get into the old host talking to VRAM while
         * blitter does at the same time. Bad. So fail if there is an
         * outstanding aliased lock just as if the BUST bit had been
         * set.
         */
        DPF_ERR( "Graphics adapter is busy (due to a DirectDraw lock)" );
        LEAVE_BOTH();
        return DDERR_SURFACEBUSY;
    }
#endif /* USE_ALIAS */

    /*
     * Behavior change:  In DX7, the default is to wait unless DDBLT_DONOTWAIT=1.
     * In earlier releases, the default was to NOT wait unless DDBLT_WAIT=1.
     * (The DDBLT_DONOTWAIT flag was not defined until the DX7 release.)
     */
    if (!LOWERTHANSURFACE7(this_dest_int))
    {
        if (dwFlags & DDBLT_DONOTWAIT)
        {
            if (dwFlags & DDBLT_WAIT)
            {
                DPF_ERR( "WAIT and DONOTWAIT flags are mutually exclusive" );
                LEAVE_BOTH();
                return DDERR_INVALIDPARAMS;
            }
        }
        else
        {
            dwFlags |= DDBLT_WAIT;
        }
    }

    if(this_src_lcl)
        FlushD3DStates(this_src_lcl); // Need to flush src because it could be a rendertarget
    FlushD3DStates(this_dest_lcl);

    // Test and set the busy bit.  If it was already set, bail.
    {
        BOOL    isbusy = 0;

        pdflags = pdrv->lpwPDeviceFlags;
#ifdef WIN95
        _asm
            {
                mov eax, pdflags
                    bts word ptr [eax], BUSY_BIT
                    adc byte ptr isbusy,0
                    }
#else
        isbusy -= (InterlockedExchange((LPDWORD)pdflags,
                                       *((LPDWORD)pdflags) | (1<<BUSY_BIT) ) == (1<<BUSY_BIT) );
#endif
        if( isbusy )
        {
            DPF( 1, "BUSY - Blt" );
            LEAVE_BOTH();
            return DDERR_SURFACEBUSY;
        }

    }
    /*
     * The following code was added to keep all of the HALs from
     * changing their Blt() code when they add video port support.
     * If the video port was using this surface but was recently
     * flipped, we will make sure that the flip actually occurred
     * before allowing access.  This allows double buffered capture
     * w/o tearing.
     */
    if( ( this_src_lcl != NULL ) &&
        ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT ) )
    {
        LPDDRAWI_DDVIDEOPORT_INT lpVideoPort;
        LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort_lcl;

        // Look at all video ports to see if any of them recently
        // flipped from this surface.
        lpVideoPort = pdrv->dvpList;
        while( NULL != lpVideoPort )
        {
            lpVideoPort_lcl = lpVideoPort->lpLcl;
            if( lpVideoPort_lcl->fpLastFlip == this_src->fpVidMem )
            {
                // This can potentially tear - check the flip status
                LPDDHALVPORTCB_GETFLIPSTATUS pfn;
                DDHAL_GETVPORTFLIPSTATUSDATA GetFlipData;
                LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;

                pdrv_lcl = this_src_lcl->lpSurfMore->lpDD_lcl;
                pfn = pdrv_lcl->lpDDCB->HALDDVideoPort.GetVideoPortFlipStatus;
                if( pfn != NULL )  // Will simply tear if function not supproted
                {
                    GetFlipData.lpDD = pdrv_lcl;
                    GetFlipData.fpSurface = this_src->fpVidMem;

                KeepTrying:
                    rc = DDHAL_DRIVER_NOTHANDLED;
                    DOHALCALL_NOWIN16( GetVideoPortFlipStatus, pfn, GetFlipData, rc, 0 );
                    if( ( DDHAL_DRIVER_HANDLED == rc ) &&
                        ( DDERR_WASSTILLDRAWING == GetFlipData.ddRVal ) )
                    {
                        if( dwFlags & DDBLT_WAIT)
                        {
                            goto KeepTrying;
                        }
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_WASSTILLDRAWING;
                    }
                }
            }
            lpVideoPort = lpVideoPort->lpLink;
        }
    }

RESTART_BLT:
    TRY
    {

        /*
         *  Remove any cached RLE stuff for source surface
         */
        if( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
        {
            extern void FreeRleData(LPDDRAWI_DDRAWSURFACE_LCL psurf); //in fasthel.c
            FreeRleData( this_dest_lcl );
        }

        /*
         * is either surface locked?
         */
        if( (this_dest->dwUsageCount > 0) ||
            ((this_src != NULL) && (this_src->dwUsageCount > 0)) )
        {
            DPF_ERR( "Surface is locked" );
            LEAVE_BOTH_NOBUSY();
            return DDERR_SURFACEBUSY;
        }

        BUMP_SURFACE_STAMP(this_dest);

        /*
         * It is possible this function could be called in the middle
         * of a mode, in which case we could trash the frame buffer.
         * To avoid regression, we will simply succeed the call without
         * actually doing anything.
         */
        if( ( pdrv->dwFlags & DDRAWI_CHANGINGMODE ) &&
            !( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
        {
            LEAVE_BOTH_NOBUSY()
                return DD_OK;
        }

        sbd.halonly = FALSE;
        sbd.helonly = FALSE;
        gdiblt = FALSE;
        if( this_src != NULL )
        {
            // initialize the blit caps according to the surface types
            initBltCaps( 
                this_dest_lcl->ddsCaps.dwCaps, 
                this_dest->dwGlobalFlags,
                this_src_lcl->ddsCaps.dwCaps, pdrv, lpbc, &(sbd.helonly) );
        }
        else
        {
            // no source surface, use vram->vram caps and determine hal or hel
            // based on system memory status of destination surface
            // if the destination is non-local we also force emulation as we
            // don't currently support accelerated operation with non-local
            // video memory are a target
            initBltCaps( DDSCAPS_VIDEOMEMORY, 0, DDSCAPS_VIDEOMEMORY, pdrv, lpbc, &sbd.helonly );
            if( ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) ||
                ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM ) )
            {
                lpbc->bHALSeesSysmem = FALSE;
                sbd.helonly = TRUE;
            }
        }

        fail = FALSE;

        /*
         * can we really blt?
         */
        if( !(*(lpbc->dwBothCaps) & DDCAPS_BLT) )
        {
            if( *(lpbc->dwCaps) & DDCAPS_BLT )
            {
                sbd.halonly = TRUE;
            }
            else if( *(lpbc->dwHELCaps) & DDCAPS_BLT )
            {
                lpbc->bHALSeesSysmem = FALSE;
                sbd.helonly = TRUE;
            }
            else
            {
                DPF_ERR( "Driver does not support Blt" );
                LEAVE_BOTH_NOBUSY();
                return DDERR_NOBLTHW;
            }
        }

        /*
         * Check for special cases involving FOURCC surfaces:
         *   -- Copy blits between surfaces with identical FOURCC formats
         *   -- Compression/decompression of DXT* compressed textures
         */
        {
            DWORD dwDest4CC = 0;
            DWORD dwSrc4CC = 0;

            /*
             * Does either the source or dest surface have a FOURCC format?
             */
            if ((this_dest_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (this_dest->ddpfSurface.dwFlags & DDPF_FOURCC))
            {
                dwDest4CC = this_dest->ddpfSurface.dwFourCC;   // dest FOURCC format
            }

            if ((this_src_lcl != NULL) &&
                (this_src_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (this_src->ddpfSurface.dwFlags & DDPF_FOURCC))
            {
                dwSrc4CC = this_src->ddpfSurface.dwFourCC;   // source FOURCC format
            }

            if (dwDest4CC | dwSrc4CC)
            {
                /*
                 * Yes, at least one of the two surfaces has a FOURCC format.
                 * Do the source and dest surfaces have precisely the same
                 * FOURCC format?  (If so, this is a FOURCC copy blit.)
                 */
                if (dwDest4CC == dwSrc4CC)
                {
                    // Yes, this is a FOURCC copy blit.  Can the driver handle this?
                    if ((pdrv->ddCaps.dwCaps2 & DDCAPS2_COPYFOURCC) == 0)
                    {
                        // The driver cannot handle FOURCC copy blits.
                        sbd.helonly = TRUE;
                    }
                }
                else
                {
                    /*
                     * No, the two surfaces have different pixel formats.
                     * Now determine if either surface has a DXT* FOURCC format.
                     * The rule for the Blt API call is that the HEL _ALWAYS_
                     * performs a blit involving a DXT* source or dest surface.
                     * Hardware acceleration for DXT* blits is available only
                     * with the AlphaBlt API call.  We now enforce this rule:
                     */
                    switch (dwDest4CC)
                    {
                    case MAKEFOURCC('D','X','T','1'):
                    case MAKEFOURCC('D','X','T','2'):
                    case MAKEFOURCC('D','X','T','3'):
                    case MAKEFOURCC('D','X','T','4'):
                    case MAKEFOURCC('D','X','T','5'):
                        // This is a blit to a DXT*-formatted surface.
                        sbd.helonly = TRUE;
                        break;
                    default:
                        break;
                    }
                    switch (dwSrc4CC)
                    {
                    case MAKEFOURCC('D','X','T','1'):
                    case MAKEFOURCC('D','X','T','2'):
                    case MAKEFOURCC('D','X','T','3'):
                    case MAKEFOURCC('D','X','T','4'):
                    case MAKEFOURCC('D','X','T','5'):
                        // This is a blit from a DXT*-formatted surface.
                        sbd.helonly = TRUE;
                        break;
                    default:
                        break;
                    }
                }
            }
        }

            /*
             * check for HEL composition buffer
             */
            if( (this_dest_lcl->dwFlags & DDRAWISURF_HELCB) ||
                ((this_src_lcl != NULL) && (this_src_lcl->dwFlags & DDRAWISURF_HELCB)) )
            {
                lpbc->bHALSeesSysmem = FALSE;
                sbd.helonly = TRUE;
            }

            bd.lpDD = pdrv;

            /*
             * make sure BltFX struct is OK
             */
            bd.bltFX.dwSize = sizeof( bd.bltFX );
            if( lpDDBltFX != NULL )
            {
                if( !VALID_DDBLTFX_PTR( lpDDBltFX ) )
                {
                    DPF_ERR( "Invalid BLTFX specified" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDPARAMS;
                }
            }
            else
            {
                if( dwFlags & ( DDBLT_ALPHASRCCONSTOVERRIDE |
                                DDBLT_ALPHADESTCONSTOVERRIDE |
                                DDBLT_ALPHASRCSURFACEOVERRIDE |
                                DDBLT_ALPHADESTSURFACEOVERRIDE |
                                DDBLT_COLORFILL |
                                DDBLT_DDFX |
                                DDBLT_DDROPS |
                                DDBLT_DEPTHFILL |
                                DDBLT_KEYDESTOVERRIDE |
                                DDBLT_KEYSRCOVERRIDE |
                                DDBLT_ROP |
                                DDBLT_ROTATIONANGLE |
                                DDBLT_ZBUFFERDESTCONSTOVERRIDE |
                                DDBLT_ZBUFFERDESTOVERRIDE |
                                DDBLT_ZBUFFERSRCCONSTOVERRIDE |
                                DDBLT_ZBUFFERSRCOVERRIDE ) )
                {
                    DPF_ERR( "BltFX required but not specified" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDPARAMS;
                }
            }

            /*
             * make sure flags & associated bd.bltFX are specified OK
             */
            need_pat = FALSE;
            if( dwFlags & ~DDBLT_WAIT )
            {

                /*
                 * isolate lower use tests together
                 */
                if( dwFlags & (DDBLT_KEYSRCOVERRIDE|
                               DDBLT_KEYDESTOVERRIDE|
                               DDBLT_KEYSRC |
                               DDBLT_KEYDEST ) )
                {

#pragma message( REMIND( "Alpha turned off in Rev 1" ) )
#pragma message( REMIND( "Set read/write flags for alpha and Z" ) )
#if 0
                    /*
                     * verify ALPHA
                     */
                    if( dwFlags & DDBLT_ANYALPHA )
                    {
                        BOOL    no_alpha;

                        no_alpha = TRUE;

                        // check to see if alpha is supported
                        if( !(*(lpbc->dwBothCaps) & DDCAPS_ALPHA) )
                        {
                            GETFAILCODEBLT( *(lpbc->dwCaps),
                                            *(lpbc->dwHELCaps),
                                            sbd.halonly,
                                            sbd.helonly,
                                            DDCAPS_ALPHA );
                            if( fail )
                            {
                                DPF_ERR( "Alpha blt requested, not supported" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_NOALPHAHW;
                            }
                        }

                        /*
                         * dest alpha
                         */
                        if( dwFlags & DDBLT_ALPHADEST )
                        {
                            if( dwFlags & ( DDBLT_ALPHADESTCONSTOVERRIDE |
                                            DDBLT_ALPHADESTSURFACEOVERRIDE) )
                            {
                                DPF_ERR( "ALPHADEST and other alpha dests specified" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            psurf_lcl = FindAttached( this_dest_lcl, DDSCAPS_ALPHA );
                            if( psurf_lcl == NULL )
                            {
                                DPF_ERR( "ALPHADEST requires an attached alpha to the dest" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            dwFlags &= ~DDBLT_ALPHADEST;
                            dwFlags |= DDBLT_ALPHADESTSURFACEOVERRIDE;
                            bd.bltFX.lpDDSAlphaDest = (LPDIRECTDRAWSURFACE) psurf_lcl;
                            no_alpha = FALSE;
                            // check to see if alpha surfaces are supported
                            if( !(*(lpbc->dwBothCaps) & DDFXCAPS_ALPHASURFACES) )
                            {
                                GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                                *(lpbc->dwHELFXCaps),
                                                sbd.halonly,
                                                sbd.helonly,
                                                DDFXCAPS_ALPHASURFACES );
                                if( fail )
                                {
                                    DPF_ERR( "AlphaDest surface requested, not supported" );
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_NOALPHAHW;
                                }
                            }
                        }
                        else if( dwFlags & DDBLT_ALPHADESTCONSTOVERRIDE )
                        {
                            if( dwFlags & ( DDBLT_ALPHADESTSURFACEOVERRIDE ))
                            {
                                DPF_ERR( "ALPHADESTCONSTOVERRIDE and other alpha sources specified" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            bd.bltFX.dwConstAlphaDest = lpDDBltFX->dwConstAlphaDest;
                            no_alpha = FALSE;
                        }
                        else if( dwFlags & DDBLT_ALPHADESTSURFACEOVERRIDE )
                        {
                            psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDBltFX->lpDDSAlphaDest;
                            if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_lcl ) )
                            {
                                DPF_ERR( "ALPHASURFACEOVERRIDE requires surface ptr" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            if( SURFACE_LOST( psurf_lcl ) )
                            {
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_SURFACELOST;
                            }
                            bd.bltFX.lpDDSAlphaDest = (LPDIRECTDRAWSURFACE) psurf_lcl;
                            no_alpha = FALSE;
                            // check to see if alpha surfaces are supported
                            if( !(*(lpbc->dwBothCaps) & DDFXCAPS_ALPHASURFACES) )
                            {
                                GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                                *(lpbc->dwHELFXCaps),
                                                sbd.halonly,
                                                sbd.helonly,
                                                DDFXCAPS_ALPHASURFACES );
                                if( fail )
                                {
                                    DPF_ERR( "AlphaDestOvr surface requested, not supported" );
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_NOALPHAHW;
                                }
                            }
                        }

                        /*
                         * source alpha
                         */
                        if( dwFlags & DDBLT_ALPHASRC )
                        {
                            if( dwFlags & (DDBLT_ALPHASRCCONSTOVERRIDE|
                                           DDBLT_ALPHASRCSURFACEOVERRIDE) )
                            {
                                DPF_ERR( "ALPHASRC and other alpha sources specified" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            if( this_src == NULL )
                            {
                                DPF_ERR( "ALPHASRC requires a source surface" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            psurf_lcl = FindAttached( this_src_lcl, DDSCAPS_ALPHA );
                            if( psurf_lcl == NULL )
                            {
                                DPF_ERR( "ALPHASRC requires an attached alpha to the src" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            dwFlags &= ~DDBLT_ALPHASRC;
                            dwFlags |= DDBLT_ALPHASRCSURFACEOVERRIDE;
                            bd.bltFX.lpDDSAlphaSrc = (LPDIRECTDRAWSURFACE) psurf_lcl;
                            no_alpha = FALSE;
                            // check to see if alpha surfaces are supported
                            if( !(*(lpbc->dwBothCaps) & DDFXCAPS_ALPHASURFACES) )
                            {
                                GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                                *(lpbc->dwHELFXCaps),
                                                sbd.halonly,
                                                sbd.helonly,
                                                DDFXCAPS_ALPHASURFACES );
                                if( fail )
                                {
                                    DPF_ERR( "AlphaSrc surface requested, not supported" );
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_NOALPHAHW;
                                }
                            }
                        }
                        else if( dwFlags & DDBLT_ALPHASRCCONSTOVERRIDE )
                        {
                            if( dwFlags & ( DDBLT_ALPHASRCSURFACEOVERRIDE ))
                            {
                                DPF_ERR( "ALPHASRCCONSTOVERRIDE and other alpha sources specified" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            bd.bltFX.dwConstAlphaSrc = lpDDBltFX->dwConstAlphaSrc;
                            no_alpha = FALSE;
                        }
                        else if( dwFlags & DDBLT_ALPHASRCSURFACEOVERRIDE )
                        {
                            psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDBltFX->lpDDSAlphaSrc;
                            if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_int ) )
                            {
                                DPF_ERR( "ALPHASURFACEOVERRIDE requires surface ptr" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            psurf_lcl = psurf_int->lpLcl;
                            if( SURFACE_LOST( psurf_lcl ) )
                            {
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_SURFACELOST;
                            }
                            bd.bltFX.lpDDSAlphaSrc = (LPDIRECTDRAWSURFACE) psurf_lcl;
                            no_alpha = FALSE;
                            // check to see if alpha surfaces are supported
                            if( !(*(lpbc->dwBothCaps) & DDFXCAPS_ALPHASURFACES) )
                            {
                                GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                                *(lpbc->dwHELFXCaps),
                                                sbd.halonly,
                                                sbd.helonly,
                                                DDFXCAPS_ALPHASURFACES );
                                if( fail )
                                {
                                    DPF_ERR( "AlphaSrcOvr surface requested, not supported" );
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_NOALPHAHW;
                                }
                            }
                        }

                        if( no_alpha )
                        {
                            DPF_ERR( "ALPHA specified with no alpha surface to use" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                    }
#endif

#pragma message( REMIND( "Z blts turned off in Rev 1" ) )
#if 0
                    /*
                     * verify Z Buffer
                     */
                    if( dwFlags & DDBLT_ZBUFFER )
                    {
                        if( this_src_lcl == NULL )
                        {
                            DPF_ERR( "ZBUFFER specified, but no source data" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                        // check to see if the driver supports zbuffer blts
                        if( !(*(lpbc->dwBothCaps) & DDCAPS_ZBLTS) )
                        {
                            GETFAILCODEBLT( *(lpbc->dwCaps),
                                            *(lpbc->dwHELCaps),
                                            sbd.halonly,
                                            sbd.helonly,
                                            DDCAPS_ZBLTS );
                            if( fail )
                            {
                                DPF_ERR( "ZBuffer blt requested, not supported" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_NOZBUFFERHW;
                            }
                        }

                        bd.bltFX.dwZBufferOpCode = lpDDBltFX->dwZBufferOpCode;
                        if( dwFlags & DDBLT_ZBUFFERCONSTDESTOVERRIDE )
                        {
                            if( dwFlags & (DDBLT_ZBUFFERDESTOVERRIDE) )
                            {
                                DPF_ERR( "ZBUFFERCONSTDESTOVERRIDE and z surface specified" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            bd.bltFX.dwConstZDest = lpDDBltFX->dwConstZDest;
                        }
                        else if( dwFlags & DDBLT_ZBUFFERDESTOVERRIDE )
                        {
                            psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDBltFX->lpDDSZBufferDest;
                            if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_int ) )
                            {
                                DPF_ERR( "ZBUFFERSURFACEDESTOVERRIDE requires surface ptr" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            psurf_lcl = psurf_int->lpLcl;
                            if( SURFACE_LOST( psurf_lcl ) )
                            {
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_SURFACELOST;
                            }
                            bd.bltFX.lpDDSZBufferDest = (LPDIRECTDRAWSURFACE) psurf_lcl;
                        }
                        else
                        {
                            psurf_lcl = FindAttached( this_dest_lcl, DDSCAPS_ZBUFFER );
                            if( psurf_lcl == NULL )
                            {
                                DPF_ERR( "ZBUFFER requires an attached Z to dest" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            dwFlags |= DDBLT_ZBUFFERDESTOVERRIDE;
                            bd.bltFX.lpDDSZBufferDest = (LPDIRECTDRAWSURFACE) psurf_lcl;
                        }
                        if( dwFlags & DDBLT_ZBUFFERCONSTSRCOVERRIDE )
                        {
                            if( dwFlags & (DDBLT_ZBUFFERSRCOVERRIDE) )
                            {
                                DPF_ERR( "ZBUFFERCONSTSRCOVERRIDE and z surface specified" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            bd.bltFX.dwConstZSrc = lpDDBltFX->dwConstZSrc;
                        } else if( dwFlags & DDBLT_ZBUFFERSRCOVERRIDE )
                        {
                            psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDBltFX->lpDDSZBufferSrc;
                            if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_int ) )
                            {
                                DPF_ERR( "ZBUFFERSURFACESRCOVERRIDE requires surface ptr" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            psurf_lcl = psurf_int->lpLcl
                                if( SURFACE_LOST( psurf_lcl ) )
                                {
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_SURFACELOST;
                                }
                            bd.bltFX.lpDDSZBufferSrc = (LPDIRECTDRAWSURFACE) psurf_lcl;
                        }
                        else
                        {
                            psurf_lcl = FindAttached( this_src_lcl, DDSCAPS_ZBUFFER );
                            if( psurf_lcl == NULL )
                            {
                                DPF_ERR( "ZBUFFER requires an attached Z to src" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            dwFlags |= DDBLT_ZBUFFERSRCOVERRIDE;
                            bd.bltFX.lpDDSZBufferSrc = (LPDIRECTDRAWSURFACE) psurf_lcl;
                        }
                    }
#endif

                    /*
                     * verify color key overrides
                     */
                    if( dwFlags & (DDBLT_KEYSRCOVERRIDE|DDBLT_KEYDESTOVERRIDE) )
                    {
                        // see if the driver supports color key blts
                        if( !(*(lpbc->dwBothCaps) & DDCAPS_COLORKEY) )
                        {
                            GETFAILCODEBLT( *(lpbc->dwCaps),
                                            *(lpbc->dwHELCaps),
                                            sbd.halonly,
                                            sbd.helonly,
                                            DDCAPS_COLORKEY );
                            if( fail )
                            {
                                DPF_ERR( "KEYOVERRIDE specified, not supported" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_NOCOLORKEYHW;
                            }
                        }
                        if( dwFlags & DDBLT_KEYSRCOVERRIDE )
                        {
                            if( !(*(lpbc->dwBothCKeyCaps) & DDCKEYCAPS_SRCBLT) )
                            {
                                GETFAILCODEBLT( *(lpbc->dwCKeyCaps),
                                                *(lpbc->dwHELCKeyCaps),
                                                sbd.halonly,
                                                sbd.helonly,
                                                DDCKEYCAPS_SRCBLT );
                                if( fail )
                                {
                                    DPF_ERR( "KEYSRCOVERRIDE specified, not supported" );
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_NOCOLORKEYHW;
                                }
                            }
                            bd.bltFX.ddckSrcColorkey = lpDDBltFX->ddckSrcColorkey;
                        }
                        if( dwFlags & DDBLT_KEYDESTOVERRIDE )
                        {
                            if( !(*(lpbc->dwBothCKeyCaps) & DDCKEYCAPS_DESTBLT) )
                            {
                                GETFAILCODEBLT( *(lpbc->dwCKeyCaps),
                                                *(lpbc->dwHELCKeyCaps),
                                                sbd.halonly,
                                                sbd.helonly,
                                                DDCKEYCAPS_DESTBLT );
                                if( fail )
                                {
                                    DPF_ERR( "KEYDESTOVERRIDE specified, not supported" );
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_NOCOLORKEYHW;
                                }
                            }
                            bd.bltFX.ddckDestColorkey = lpDDBltFX->ddckDestColorkey;
                            dwDestLockFlags = 0; //meaning read/write
                        }
                    }

                    /*
                     * verify src color key
                     */
                    if( dwFlags & DDBLT_KEYSRC )
                    {
                        if( this_src == NULL )
                        {
                            DPF_ERR( "KEYSRC specified, but no source data" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDOBJECT;
                        }
                        if( dwFlags & DDBLT_KEYSRCOVERRIDE )
                        {
                            DPF_ERR( "KEYSRC specified with KEYSRCOVERRIDE" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                        if( !(this_src_lcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) )
                        {
                            DPF_ERR( "KEYSRC specified, but no color key" );
                            DPF( 1, "srcFlags = %08lx", this_src_lcl->dwFlags );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                        // make sure we can do this
                        if( !(*(lpbc->dwBothCKeyCaps) & DDCKEYCAPS_SRCBLT) )
                        {
                            GETFAILCODEBLT( *(lpbc->dwCKeyCaps),
                                            *(lpbc->dwHELCKeyCaps),
                                            sbd.halonly,
                                            sbd.helonly,
                                            DDCKEYCAPS_SRCBLT );
                            if( fail )
                            {
                                DPF_ERR( "KEYSRC specified, not supported" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_NOCOLORKEYHW;
                            }
                        }
                        bd.bltFX.ddckSrcColorkey = this_src_lcl->ddckCKSrcBlt;
                        dwFlags &= ~DDBLT_KEYSRC;
                        dwFlags |= DDBLT_KEYSRCOVERRIDE;
                    }

                    /*
                     * verify dest color key
                     */
                    if( dwFlags & DDBLT_KEYDEST )
                    {
                        if( dwFlags & DDBLT_KEYDESTOVERRIDE )
                        {
                            DPF_ERR( "KEYDEST specified with KEYDESTOVERRIDE" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                        if( !(this_dest_lcl->dwFlags & DDRAWISURF_HASCKEYDESTBLT) )
                        {
                            DPF_ERR( "KEYDEST specified, but no color key" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                        // make sure we can do this
                        if( !(*(lpbc->dwBothCKeyCaps) & DDCKEYCAPS_DESTBLT) )
                        {
                            GETFAILCODEBLT( *(lpbc->dwCKeyCaps),
                                            *(lpbc->dwHELCKeyCaps),
                                            sbd.halonly,
                                            sbd.helonly,
                                            DDCKEYCAPS_DESTBLT );
                            if( fail )
                            {
                                DPF_ERR( "KEYDEST specified, not supported" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_NOCOLORKEYHW;
                            }
                        }

                        /*
                         * This next part is bug that has existed since DX1.
                         * We'd like to fix it, but we fear regression, so we
                         * only fix it for surface 3 interfaces.
                         */
                        if( ( this_src_int->lpVtbl == &ddSurfaceCallbacks ) ||
                            ( this_src_int->lpVtbl == &ddSurface2Callbacks ) )
                        {
                            bd.bltFX.ddckDestColorkey = this_src_lcl->ddckCKDestBlt;
                        }
                        else
                        {
                            bd.bltFX.ddckDestColorkey = this_dest_lcl->ddckCKDestBlt;
                        }
                        dwFlags &= ~DDBLT_KEYDEST;
                        dwFlags |= DDBLT_KEYDESTOVERRIDE;
                        dwDestLockFlags = 0; //meaning read/write
                    }
                }

                /*
                 * verify various flags
                 */
                if( !(dwFlags &(DDBLT_ROP |
                                DDBLT_COLORFILL |
                                DDBLT_DDROPS |
                                DDBLT_DEPTHFILL |
                                DDBLT_ROTATIONANGLE |
                                DDBLT_DDFX) ) )
                {
                    if( this_src == NULL )
                    {
                        DPF_ERR( "Need a source for blt" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    dwFlags |= DDBLT_ROP;
                    bd.bltFX.dwROP = SRCCOPY;
                }
                /*
                 * verify ROP
                 */
                else if( dwFlags & DDBLT_ROP )
                {
                    DWORD   idx;
                    DWORD   bit;

                    if( dwFlags & (DDBLT_DDFX |
                                   DDBLT_COLORFILL|
                                   DDBLT_DEPTHFILL|
                                   DDBLT_ROTATIONANGLE|
                                   DDBLT_DDROPS))
                    {
                        DPF_ERR( "Invalid flags specified with ROP" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    bd.bltFX.dwROP = lpDDBltFX->dwROP;

                    rop = (DWORD) LOBYTE( HIWORD( bd.bltFX.dwROP ) );
                    idx = rop/32;
                    bit = 1 << (rop % 32 );
                    DPF( 4, "Trying ROP %d, idx=%d, bit=%08lx", rop, idx, bit );

                    /*
                     * We disable ROP flags on NT, so don't fail if they're only doing a SRCCOPY
                     */
                    if( lpDDBltFX->dwROP != SRCCOPY )
                    {
                        /*
                         * see if both HEL & HAL support the ROP
                         */
                        if( !(lpbc->dwBothRops[idx] & bit ) )
                        {
                            GETFAILCODEBLT( lpbc->dwRops[idx],
                                            lpbc->dwHELRops[idx],
                                            sbd.halonly,
                                            sbd.helonly,
                                            bit );
                            if( fail )
                            {
                                DPF_ERR( "ROP not supported" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_NORASTEROPHW;
                            }
                        }
                    }
                    bd.dwROPFlags = cROPTable[ rop ];
                    if( bd.dwROPFlags & ROP_HAS_SOURCE )
                    {
                        if( this_src == NULL )
                        {
                            DPF_ERR( "ROP required a surface" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                    }
                    if( bd.dwROPFlags & ROP_HAS_PATTERN )
                    {
                        need_pat = TRUE;
                    }
                }
                /*
                 * verify COLORFILL
                 */
                else if( dwFlags & DDBLT_COLORFILL )
                {
                    if( this_src != NULL )
                    {
                        DPF_ERR( "COLORFILL specified along with source surface" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    /*
                     * You cannot use COLORFILL to clear Z-buffers anymore. You must
                     * explicitly use DEPTHFILL. Disallow Z-buffer destinations.
                     */
                    if( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
                    {
                        DPF_ERR( "Z-Buffer cannot be target of a color fill blt" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    if( !(*(lpbc->dwBothCaps) & DDCAPS_BLTCOLORFILL) )
                    {
                        GETFAILCODEBLT( *(lpbc->dwCaps),
                                        *(lpbc->dwHELCaps),
                                        sbd.halonly,
                                        sbd.helonly,
                                        DDCAPS_BLTCOLORFILL );
                        if( fail )
                        {
                            DPF_ERR( "COLORFILL specified, not supported" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_UNSUPPORTED;
                        }
                    }

                    /*
                     * Maks off the high order bits of the colorfill
                     * value since some drivers will fail if they're set.
                     */
                    GET_PIXEL_FORMAT( this_dest_lcl, this_dest, pddpf );
                    if( pddpf->dwRGBBitCount <= 8 )
                    {
                         lpDDBltFX->dwFillColor &= 0x00ff;
                    }
                    else if( pddpf->dwRGBBitCount == 16 )
                    {
                         lpDDBltFX->dwFillColor &= 0x00ffff;
                    }
                    else if( pddpf->dwRGBBitCount == 24 )
                    {
                        lpDDBltFX->dwFillColor &= 0x00ffffff;
                    }

                    bd.bltFX.dwFillColor = lpDDBltFX->dwFillColor;
                }
                /*
                 * verify DEPTHFILL
                 */
                else if( dwFlags & DDBLT_DEPTHFILL )
                {
                    if( this_src != NULL )
                    {
                        DPF_ERR( "DEPTHFILL specified along with source surface" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    /*
                     * Ensure the destination is a z-buffer.
                     */
                    if( !( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER ) )
                    {
                        DPF_ERR( "DEPTHFILL specified but destination is not a Z-buffer" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }

                    if( !(*(lpbc->dwBothCaps) & DDCAPS_BLTDEPTHFILL) )
                    {
                        GETFAILCODEBLT( *(lpbc->dwCaps),
                                        *(lpbc->dwHELCaps),
                                        sbd.halonly,
                                        sbd.helonly,
                                        DDCAPS_BLTDEPTHFILL );
                        if( fail )
                        {
                            DPF_ERR( "DEPTHFILL specified, not supported" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_UNSUPPORTED;
                        }
                    }
                    bd.bltFX.dwFillDepth = lpDDBltFX->dwFillDepth;

                    // hack to pass DepthBlt WriteMask to BlitLib
                    bd.bltFX.dwZDestConstBitDepth = lpDDBltFX->dwZDestConstBitDepth;
                }
                /*
                 * verify DDROPS
                 */
                else if( dwFlags & DDBLT_DDROPS )
                {
                    if( dwFlags & (DDBLT_DDFX |
                                   DDBLT_COLORFILL|
                                   DDBLT_DEPTHFILL|
                                   DDBLT_ROTATIONANGLE) )
                    {
                        DPF_ERR( "Invalid flags specified with DDROPS" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    bd.bltFX.dwDDROP = lpDDBltFX->dwDDROP;
                    DPF_ERR( "DDROPS unsupported" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_NODDROPSHW;
                }
                /*
                 * verify DDFX
                 */
                else if( dwFlags & DDBLT_DDFX )
                {
                    if( dwFlags & (DDBLT_COLORFILL |
                                   DDBLT_DEPTHFILL |
                                   DDBLT_ROTATIONANGLE) )
                    {
                        DPF_ERR( "Invalid flags specified with DDFX" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }

                    if( lpDDBltFX->dwDDFX & ( DDBLTFX_ARITHSTRETCHY ) )
                    {
                        DPF_ERR( "DDBLTFX_ARITHSTRETCHY unsupported" );

                        LEAVE_BOTH_NOBUSY();
                        return DDERR_NOSTRETCHHW;
                    }

                    if( lpDDBltFX->dwDDFX & ( DDBLTFX_MIRRORLEFTRIGHT ) )
                    {
                        GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                        *(lpbc->dwHELFXCaps),
                                        sbd.halonly,
                                        sbd.helonly,
                                        DDFXCAPS_BLTMIRRORLEFTRIGHT );
                        if( fail )
                        {
                            DPF_ERR( "Mirroring along vertical axis not supported" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_NOMIRRORHW;
                        }
                    }
                    if( lpDDBltFX->dwDDFX & ( DDBLTFX_MIRRORUPDOWN ) )
                    {
                        GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                        *(lpbc->dwHELFXCaps),
                                        sbd.halonly,
                                        sbd.helonly,
                                        DDFXCAPS_BLTMIRRORUPDOWN );
                        if( fail )
                        {
                            DPF_ERR( "Mirroring along horizontal axis not supported" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_NOMIRRORHW;
                        }
                    }
                    if( lpDDBltFX->dwDDFX & ( DDBLTFX_ROTATE90 | DDBLTFX_ROTATE180 | DDBLTFX_ROTATE270 ) )
                    {
                        GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                        *(lpbc->dwHELFXCaps),
                                        sbd.halonly,
                                        sbd.helonly,
                                        DDFXCAPS_BLTROTATION90 );
                        if( fail )
                        {
                            DPF_ERR( "90-degree rotations not supported" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_NOROTATIONHW;
                        }
                    }
                    bd.bltFX.dwDDFX = lpDDBltFX->dwDDFX;
                    dwFlags |= DDBLT_ROP;
                    bd.bltFX.dwROP = SRCCOPY;
                    /*
                     * verify ROTATIONANGLE
                     */
                }
                else if( dwFlags & DDBLT_ROTATIONANGLE )
                {
                    if( dwFlags & (DDBLT_COLORFILL | DDBLT_DEPTHFILL) )
                    {
                        DPF_ERR( "Invalid flags specified with ROTATIONANGLE" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    bd.bltFX.dwRotationAngle = lpDDBltFX->dwRotationAngle;
                    DPF_ERR( "ROTATIONANGLE unsupported" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_NOROTATIONHW;
                    /*
                     * you should have told me SOMETHING!
                     */
                }
                else
                {
                    DPF_ERR( "no blt type specified!" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDPARAMS;
                }
                /*
                 * no flags, we are doing a generic SRCCOPY
                 */
            }
            else
            {
                if( this_src == NULL )
                {
                    DPF_ERR( "Need a source for blt" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDPARAMS;
                }
                dwFlags |= DDBLT_ROP;
                bd.bltFX.dwROP = SRCCOPY;
            }

            /*
             * verify pattern
             */
            if( need_pat )
            {
                psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDBltFX->lpDDSPattern;
                if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_int ) )
                {
                    DPF_ERR( "Invalid pattern surface specified" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDOBJECT;
                }
                psurf_lcl = psurf_int->lpLcl;
                bd.bltFX.lpDDSPattern = (LPDIRECTDRAWSURFACE) psurf_lcl;
                if( SURFACE_LOST( psurf_lcl ) )
                {
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_SURFACELOST;
                }

#pragma message( REMIND( "What about general (non-8x8) patterns?" ))
                if( psurf_lcl->lpGbl->wHeight != 8 || psurf_lcl->lpGbl->wWidth != 8 )
                {
                    DPF_ERR( "Pattern surface must be 8 by 8" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDPARAMS;
                }
                dwFlags |= DDBLT_PRIVATE_ALIASPATTERN;
            }

            /*
             * make sure dest rect is OK
             */
            if( lpDestRect != NULL )
            {
                if( !VALID_RECT_PTR( lpDestRect ) )
                {
                    DPF_ERR( "Invalid dest rect specified" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDRECT;
                }
                bd.rDest = *(LPRECTL)lpDestRect;
            }
            else
            {
                MAKE_SURF_RECT( this_dest, this_dest_lcl, bd.rDest );
            }

            /*
             * make sure src rect is OK
             */
            if( lpSrcRect != NULL )
            {
                if( !VALID_RECT_PTR( lpSrcRect ) )
                {
                    DPF_ERR( "Invalid src rect specified" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDRECT;
                }
                bd.rSrc = *(LPRECTL)lpSrcRect;
            }
            else
            {
                if( this_src != NULL )
                {
                    MAKE_SURF_RECT( this_src, this_src_lcl, bd.rSrc );
                }
            }

            /*
             * get dimensions & check them
             */
            stretch_blt = FALSE;
            sbd.dest_height = bd.rDest.bottom - bd.rDest.top;
            sbd.dest_width = bd.rDest.right - bd.rDest.left;

            // Need positive heights/widths
            if( ((int)sbd.dest_height <= 0) || ((int)sbd.dest_width <= 0) )
            {
                DPF_ERR( "Invalid destination dimensions: Zero/Negative Heights and/or Widths not allowed");
                DPF(0,"Erroneous dest dimensions were: (wid %d, hgt %d)",(int)sbd.dest_width,(int)sbd.dest_height);
                LEAVE_BOTH_NOBUSY();
                return DDERR_INVALIDRECT;
            }
            // Is there a clipper? If so no more checks.
            if( this_dest_lcl->lpDDClipper == NULL )
            {
                // Multi-mon: is this the primary for the desktop? This
                // is the only case where the upper-left coord of the surface is not
                // (0,0)
                if( (pdrv->dwFlags & DDRAWI_VIRTUALDESKTOP) &&
                    (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) )
                {
                    if( (bd.rDest.left   < pdrv->rectDesktop.left) ||
                        (bd.rDest.top    < pdrv->rectDesktop.top)  ||
                        (bd.rDest.right  > pdrv->rectDesktop.right)||
                        (bd.rDest.bottom > pdrv->rectDesktop.bottom) )
                    {
                        DPF_ERR( "Blt Destination doesn't fit on Desktop And No Clipper was specified" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDRECT;
                    }
                    if( OverlapsDevices( this_dest_lcl, (LPRECT) &bd.rDest ) )
                    {
                        sbd.helonly = gdiblt = TRUE;
                    }
                }
                else
                {
                    if( (int)bd.rDest.left < 0 ||
                        (int)bd.rDest.top < 0  ||
                        (DWORD)bd.rDest.bottom > (DWORD)this_dest->wHeight ||
                        (DWORD)bd.rDest.right > (DWORD)this_dest->wWidth )
                    {
                        DPF_ERR( "Invalid Blt destination dimensions" );
                        DPF(0, "width/height = %d x %d, dest rect = (%d, %d)-(%d, %d)",
                            this_dest->wWidth, this_dest->wHeight,
                            bd.rDest.left, bd.rDest.top, bd.rDest.right, bd.rDest.bottom);
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDRECT;
                    }
                }
            }
            else if( (pdrv->dwFlags & DDRAWI_VIRTUALDESKTOP) &&
                     (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) )
            {
                if( OverlapsDevices( this_dest_lcl, (LPRECT) &bd.rDest ) )
                {
                    sbd.helonly = gdiblt = TRUE;
                }
            }

            if( this_src != NULL )
            {
                sbd.src_height = bd.rSrc.bottom - bd.rSrc.top;
                sbd.src_width = bd.rSrc.right - bd.rSrc.left;
                if( ((int)sbd.src_height <= 0) || ((int)sbd.src_width <= 0) )
                {
                    DPF_ERR( "BLT error. Can't have non-positive height or width" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDRECT;
                }
                // Multi-mon: is this the primary for the desktop? This
                // is the only case where the upper-left coord of the surface is not
                // (0,0)
                if( (this_src->lpDD->dwFlags & DDRAWI_VIRTUALDESKTOP) &&
                    (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) )
                {

                    if( (bd.rSrc.left   < this_src->lpDD->rectDesktop.left) ||
                        (bd.rSrc.top    < this_src->lpDD->rectDesktop.top)  ||
                        (bd.rSrc.right  > this_src->lpDD->rectDesktop.right)||
                        (bd.rSrc.bottom > this_src->lpDD->rectDesktop.bottom) )
                    {
                        DPF_ERR( "Blt Source dimension doesn't fit on Desktop" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDRECT;
                    }
                    if( OverlapsDevices( this_src_lcl, (LPRECT) &bd.rSrc ) )
                    {
                        sbd.helonly = gdiblt = TRUE;
                    }
                }
                else
                {
                    if( (int)bd.rSrc.left < 0 ||
                        (int)bd.rSrc.top < 0  ||
                        (DWORD)bd.rSrc.bottom > (DWORD)this_src->wHeight ||
                        (DWORD)bd.rSrc.right > (DWORD)this_src->wWidth )
                    {
                        DPF_ERR( "Invalid Blt Source dimensions" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDRECT;
                    }

                }

                /*
                 * verify stretching...
                 *
                 */
                if( sbd.src_height != sbd.dest_height || sbd.src_width != sbd.dest_width )
                {
                    HRESULT ddrval;

                    ddrval = checkBltStretching( lpbc, &sbd );

                    if( ddrval != DD_OK )
                    {
                        DPF_ERR( "Failed checkBltStretching" );
                        LEAVE_BOTH_NOBUSY();
                        return ddrval;
                    }
                    stretch_blt  = TRUE;
                }
            }
        }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            DPF_ERR( "Exception encountered validating parameters" );
            LEAVE_BOTH_NOBUSY();
            return DDERR_INVALIDPARAMS;
        }

    /*
     * now shovel the data...
     */
    TRY
        {
            /*
             * final bits of blt data
             */
            bd.lpDDDestSurface = this_dest_lcl;
            bd.lpDDSrcSurface = this_src_lcl;
            bd.dwFlags = dwFlags;

    /*
     * Set up for a HAL or a HEL call
     */
            if( pdrv_lcl->lpDDCB->HALDDSurface.Blt == NULL )
            {
                sbd.helonly = TRUE;
            }
            if( sbd.helonly && sbd.halonly )
            {
                DPF_ERR( "BLT not supported in software or hardware" );
                LEAVE_BOTH_NOBUSY();
                return DDERR_NOBLTHW;
            }

            // Did the mode change since ENTER_DDRAW?
#ifdef WINNT
            if ( DdQueryDisplaySettingsUniqueness() != uDisplaySettingsUnique )
            {
                // mode changed, don't do the blt
                DPF_ERR( "Mode changed between ENTER_DDRAW and HAL call" );
                LEAVE_BOTH_NOBUSY()
                    return DDERR_SURFACELOST;
            }
            if( !sbd.helonly )
            {
                if (this_src_lcl && !this_src_lcl->hDDSurface 
                    && !CompleteCreateSysmemSurface(this_src_lcl))
                {
                    DPF_ERR("Can't blt from SYSTEM surface w/o Kernel Object");
                    LEAVE_BOTH_NOBUSY()
                    return DDERR_GENERIC;
                }
                if (!this_dest_lcl->hDDSurface 
                    && !CompleteCreateSysmemSurface(this_dest_lcl))
                {
                    DPF_ERR("Can't blt to SYSTEM surface w/o Kernel Object");
                    LEAVE_BOTH_NOBUSY()
                    return DDERR_GENERIC;
                }
            }
#endif

            /*
     * Some drivers (like S3) do stuff in their BeginAccess call
     * that screws up stuff that they did in their DDHAL Lock Call.
     *
     * Exclusion needs to happen BEFORE the lock call to prevent this.
     *
     */
#if defined(WIN95)
            if( this_dest_lcl->lpDDClipper != NULL )
            {
                /*
                 * exclude the mouse cursor.
         *
         * we only need to do this for the windows display driver
         *
         * we only need to do this if we are blting to or from the
         * primary surface.
         *
         * we only do this in the clipping case, we figure if the
         * app cares enough to not scribble all over other windows
         * he also cares enough to not to wipe out the cursor.
         *
         * we only need to do this if the driver is using a
         * software cursor.
             *
             * NOTE
             *  we should check and only do this on the primary?
             *  we should make sure the clipper is window based?
             *  we should check for the source being the primary?
         *
         */
                if ( (pdrv->dwFlags & DDRAWI_DISPLAYDRV) && pdrv->dwPDevice &&
                     !(*pdrv->lpwPDeviceFlags & HARDWARECURSOR) &&
                     (this_dest->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) )
                {
                    if ( lpDDDestSurface == lpDDSrcSurface )
                    {
                        RECTL rcl;
                        UnionRect((RECT*)&rcl, (RECT*)&bd.rDest, (RECT*)&bd.rSrc);
                        DD16_Exclude(pdrv->dwPDevice, &rcl);
                    }
                    else
                    {
                        DD16_Exclude(pdrv->dwPDevice, &bd.rDest);
                    }
                }
            }
#endif

            if( !sbd.helonly ) // must not be HEL call
            {
                DPF( 4, "Hardware Blt");
                sbd.bltfn = pdrv_lcl->lpDDCB->HALDDSurface.Blt;
                bd.Blt = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.Blt;

                /*
                 * Take pagelocks if required
                 */
                dest_lock_taken = FALSE;
                src_lock_taken = FALSE;

                dest_pagelock_taken = FALSE;
                src_pagelock_taken = FALSE;

                if ( lpbc->bHALSeesSysmem )
                {
                    /*
                     * If the HAL requires page locks...
                     */
                    if ( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_NOPAGELOCKREQUIRED ) )
                    {
                        HRESULT hr;
                        /*
                         * ...then setup to take them if they're not already pagelocked.
                         */
                        if ( ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY &&
                               this_dest_lcl->lpSurfMore->dwPageLockCount == 0 ) )
                        {
                            hr = InternalPageLock( this_dest_lcl, pdrv_lcl );
                            if (FAILED(hr))
                            {
                                LEAVE_BOTH_NOBUSY()
                                    return hr;
                            }
                            else
                            {
                                dest_pagelock_taken=TRUE;
                            }
                        }

                        if ( this_src_lcl && ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY &&
                                               this_src_lcl->lpSurfMore->dwPageLockCount == 0 ))
                        {
                            hr = InternalPageLock( this_src_lcl, pdrv_lcl );
                            if (FAILED(hr))
                            {
                                if (dest_pagelock_taken)
                                    InternalPageUnlock( this_dest_lcl, pdrv_lcl );

                                LEAVE_BOTH_NOBUSY()
                                    return hr;
                            }
                            else
                            {
                                src_pagelock_taken=TRUE;
                            }
                        }
                    }
                }
            }

            /*
     * Blt the unclipped case
     */
            if( this_dest_lcl->lpDDClipper == NULL )
            {
                bd.IsClipped = FALSE;   // no clipping

                // if hel only, check and take locks on video mem surfaces.
                if( sbd.helonly )
                {
                    sbd.bltfn = pdrv_lcl->lpDDCB->HELDDSurface.Blt;
                    /*
                     * take locks on vram surfaces
                     */
                    if( !(this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                        ( !gdiblt || !( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) ) )
                    {
                        while( 1 )
                        {
                            ddrval = InternalLock( this_dest_lcl, &dest_bits , NULL, dwDestLockFlags );
                            if( ddrval == DD_OK )
                            {
                                GET_LPDDRAWSURFACE_GBL_MORE(this_dest)->fpNTAlias = (FLATPTR) dest_bits;
                                break;
                            }
                            if( ddrval == DDERR_WASSTILLDRAWING )
                            {
                                continue;
                            }
                            DONE_EXCLUDE();
                            (*pdflags) &= ~BUSY;
                            LEAVE_BOTH();
                            return ddrval;
                        }
                        dest_lock_taken = TRUE;
                    }
                    else
                    {
                        /*
                         * If this surface was involved in a hardware op, we need to
                         * probe the driver to see if it's done. NOTE this assumes
                         * that only one driver can be responsible for a system memory
                         * operation. See comment with WaitForDriverToFinishWithSurface.
                         */
                        if( this_dest->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
                        {
                            WaitForDriverToFinishWithSurface(pdrv_lcl, this_dest_lcl );
                        }
                        dest_lock_taken = FALSE;
                    }

                    if( ( this_src != NULL) && (lpDDSrcSurface != lpDDDestSurface) &&
                        ( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) == 0) )
                    {
                        while( 1 )
                        {
                            ddrval = InternalLock( this_src_lcl, &src_bits, NULL, dwSourceLockFlags );
                            if( ddrval == DD_OK )
                            {
                                GET_LPDDRAWSURFACE_GBL_MORE(this_src)->fpNTAlias = (FLATPTR) src_bits;
                                break;
                            }
                            if( ddrval == DDERR_WASSTILLDRAWING )
                            {
                                continue;
                            }
                            if( dest_lock_taken )
                            {
                                InternalUnlock( this_dest_lcl,NULL,NULL,0 );
                                dest_lock_taken=FALSE;
                            }
                            DONE_EXCLUDE();
                            (*pdflags) &= ~BUSY;
                            LEAVE_BOTH();
                            return ddrval;
                        }
                        src_lock_taken = TRUE;
                    }
                    else
                    {
                        /*
                         * If this surface was involved in a hardware op, we need to
                         * probe the driver to see if it's done. NOTE this assumes
                         * that only one driver can be responsible for a system memory
                         * operation. See comment with WaitForDriverToFinishWithSurface.
                         */
                        if( this_src && ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
                            && (this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED) )
                        {
                            WaitForDriverToFinishWithSurface(pdrv_lcl, this_src_lcl );
                        }

                        src_lock_taken = FALSE;
                    }
                }

                /*
                 * Add a rect to the region list if this is a managed surface
                 */
                if(IsD3DManaged(this_dest_lcl))
                {
                    LPREGIONLIST lpRegionList = this_dest_lcl->lpSurfMore->lpRegionList;
                    if(lpDestRect)
                    {
                        if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                        {
                            lpRegionList->rect[(lpRegionList->rdh.nCount)++] = bd.rDest;
                            lpRegionList->rdh.nRgnSize += sizeof(RECT);
                            if(bd.rDest.left < lpRegionList->rdh.rcBound.left)
                                lpRegionList->rdh.rcBound.left = bd.rDest.left;
                            if(bd.rDest.right > lpRegionList->rdh.rcBound.right)
                                lpRegionList->rdh.rcBound.right = bd.rDest.right;
                            if(bd.rDest.top < lpRegionList->rdh.rcBound.top)
                                lpRegionList->rdh.rcBound.top = bd.rDest.top;
                            if(bd.rDest.bottom > lpRegionList->rdh.rcBound.bottom)
                                lpRegionList->rdh.rcBound.bottom = bd.rDest.bottom;
                        }
                    }
                    else
                    {
                        /* Mark everything dirty */
                        lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
                    }
                }

            try_again:
                if( sbd.helonly )
                {
                    // Release busy now or GDI blt will fail
                    DONE_BUSY();
                }

                if (bd.dwFlags & DDBLT_PRESENTATION)
                {
                    bd.dwFlags |= DDBLT_LAST_PRESENTATION;
                }

                DOHALCALL_NOWIN16( Blt, sbd.bltfn, bd, rc, sbd.helonly );
#ifdef WINNT
                if (rc == DDHAL_DRIVER_HANDLED && bd.ddRVal == DDERR_VISRGNCHANGED)
                {
                    DPF(5,"Resetting VisRgn for surface %x", this_dest_lcl);
                    DdResetVisrgn(this_dest_lcl, (HWND)0);
                    goto try_again;
                }
#endif
                if ( rc == DDHAL_DRIVER_HANDLED )
                {
                    if ( (dwFlags & DDBLT_WAIT) &&
                         bd.ddRVal == DDERR_WASSTILLDRAWING )
                    {
                        DPF(4, "Waiting.....");
                        goto try_again;
                    }
                    /*
                     * Note that the !helonly here is pretty much an assert.
                     * Thought it safer to actually test it, since that is actually what we mean.
                     */
                    if( !sbd.helonly && lpbc->bHALSeesSysmem && (bd.ddRVal == DD_OK) )
                    {
                        DPF(5,B,"Tagging surface %08x",this_dest);
                        if (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                            this_dest->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPDEST;
                        if (this_src)
                        {
                            DPF(5,B,"Tagging surface %08x",this_src);
                            if (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                                this_src->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPSOURCE;
                        }
                    }
                }
            }
            else
            {
                /*
                 * Blt when the destination is clipped
                 */
                DWORD       cnt;
                DWORD       total;
                LPRECT      prect;
                DWORD       size;
                LPRGNDATA       prd=(LPRGNDATA)0;
                int         x_offset;
                int         y_offset;
                DWORD       scale_x;
                DWORD       scale_y;
                RECT        rSurfDst;

        // Keep a flag to indicate whether we need to free 'prd' or not
                BOOL        fMustFreeRegion = FALSE;
                // Use a stack buffer for most clipping cases
                BYTE        buffer[sizeof(RGNDATAHEADER) + NUM_RECTS_IN_REGIONLIST * sizeof(RECTL)];

                bd.rOrigSrc = bd.rSrc;
                bd.rOrigDest = bd.rDest;

#ifdef WINNT
                // For NT, we need to deal with a clip-list change
                // at many different points of the BLT
            get_clipping_info:
                if ( fMustFreeRegion )
                {
                    MemFree( prd );
                    prd = NULL;
                    fMustFreeRegion = FALSE;
                }
#endif

                bd.IsClipped = TRUE;    // yes, we are clipping

        // Call the internal GetClipList which avoids the checking
                DDASSERT( !fMustFreeRegion );
                prd = (LPRGNDATA)&buffer[0];
                size = sizeof(buffer);

                ddrval = InternalGetClipList(
                    (LPDIRECTDRAWCLIPPER) this_dest_lcl->lpSurfMore->lpDDIClipper,
                    (LPRECT)&bd.rOrigDest, prd, &size, pdrv );

                // Fatal error?
                if( ddrval != DD_OK && ddrval != DDERR_REGIONTOOSMALL )
                {
                    DPF_ERR( "GetClipList FAILED" );
                    DONE_LOCKS();
                    DONE_EXCLUDE();
                    if (dest_pagelock_taken)
                        InternalPageUnlock( this_dest_lcl, pdrv_lcl );
                    if (src_pagelock_taken)
                        InternalPageUnlock( this_src_lcl, pdrv_lcl );
                    LEAVE_BOTH_NOBUSY();
                    return ddrval;
                }

                if ( size <= sizeof(RGNDATA) )
                {
                    DPF( 4, "Totally clipped" );
                    rc = DDHAL_DRIVER_HANDLED;
                    bd.ddRVal = DD_OK;
                    goto null_clip_rgn;
                }

                // If the clip region is larger than our stack buffer,
                // then allocate a buffer
                if ( size > sizeof(buffer) )
                {
                    DDASSERT( !fMustFreeRegion );
                    prd = MemAlloc( size );
                    if( prd == NULL )
                    {
                        DONE_LOCKS();
                        DONE_EXCLUDE();
                        if (dest_pagelock_taken)
                            InternalPageUnlock( this_dest_lcl, pdrv_lcl );
                        if (src_pagelock_taken)
                            InternalPageUnlock( this_src_lcl, pdrv_lcl );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_OUTOFMEMORY;
                    }
                    fMustFreeRegion = TRUE;
                    ddrval = InternalGetClipList(
                        (LPDIRECTDRAWCLIPPER) this_dest_lcl->lpSurfMore->lpDDIClipper,
                        (LPRECT)&bd.rOrigDest, prd, &size, pdrv );
                    if( ddrval != DD_OK )
                    {
#ifdef WINNT
                        if( ddrval == DDERR_REGIONTOOSMALL )
                        {
                            // the visrgn changed between the first and second calls to GetClipList.
                            // try again.
                            DDASSERT( fMustFreeRegion );
                            MemFree( prd );
                            prd = NULL;
                            fMustFreeRegion = FALSE;

                            goto get_clipping_info;
                        }
#else
                        // Region can't change size on Win95! We took a lock!
                        DDASSERT( ddrval != DDERR_REGIONTOOSMALL );
#endif

                        DPF_ERR( "GetClipList FAILED" );
                        DDASSERT( fMustFreeRegion );
                        MemFree( prd );
                        DONE_LOCKS();
                        DONE_EXCLUDE();
                        if (dest_pagelock_taken)
                            InternalPageUnlock( this_dest_lcl, pdrv_lcl );
                        if (src_pagelock_taken)
                            InternalPageUnlock( this_src_lcl, pdrv_lcl );
                        LEAVE_BOTH_NOBUSY();
                        return ddrval;
                    }
                }

                // Clip region to surface dimensions
                MAKE_SURF_RECT( this_dest, this_dest_lcl, rSurfDst );

                // Clip the regiondata the we have down to
                // the surface that we care about. Prevents
                // memory trashing.
                if( !gdiblt )
                {
                    ClipRgnToRect( &rSurfDst, prd );
                }

                total = prd->rdh.nCount;
                DPF( 5, "total vis rects = %ld", total );
                prect = (LPRECT) &prd->Buffer[0];
                rc = DDHAL_DRIVER_HANDLED;
                bd.ddRVal = DD_OK;

            // if hel only, check and take locks on video mem surfaces.
                if( sbd.helonly )
                {
                    sbd.bltfn = pdrv_lcl->lpDDCB->HELDDSurface.Blt;

                    /*
                     * take locks on vram surfaces
                     */
                    if( !(this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                        ( !gdiblt || !( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) ) )
                    {
                        while( 1 )
                        {
                            DPF(5,"Locking dest: %x", this_dest_lcl);
#ifdef WINNT
                            /*
                             * On Win2K, locking the entire primary is expensive as it often causes GDI 
                             * to needlessly rebuild it's sprites.  Hence, we will only lock the rect
                             * that we actually care about.
                             */
                            if( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
                            {
                                ddrval = InternalLock( this_dest_lcl, &dest_bits, (LPRECT)&bd.rDest, 
                                    DDLOCK_FAILONVISRGNCHANGED | dwDestLockFlags );
                                if( ddrval == DD_OK )
                                {
                                    subrect_lock_taken = TRUE;
                                    subrect_lock_rect.left = bd.rDest.left;
                                    subrect_lock_rect.right = bd.rDest.right;
                                    subrect_lock_rect.top = bd.rDest.top;
                                    subrect_lock_rect.bottom = bd.rDest.bottom;
                                }
                            }
                            else
                            {
#endif                               
                            ddrval = InternalLock( this_dest_lcl, &dest_bits , NULL, DDLOCK_FAILONVISRGNCHANGED | dwDestLockFlags );
#ifdef WINNT
                            }
                            if (ddrval == DDERR_VISRGNCHANGED)
                            {
                                DPF(5,"Resetting VisRgn for surface %x", this_dest_lcl);
                                DdResetVisrgn(this_dest_lcl, (HWND)0);
                                DONE_LOCKS(); //should do nothing... here for ortho
                                goto get_clipping_info;
                            }
#endif
                            if( ddrval == DD_OK )
                            {
                                GET_LPDDRAWSURFACE_GBL_MORE(this_dest)->fpNTAlias = (FLATPTR) dest_bits;
                                break;
                            }
                            if( ddrval == DDERR_WASSTILLDRAWING )
                            {
                                continue;
                            }

                            if( fMustFreeRegion )
                                MemFree( prd );

                            DONE_LOCKS();
                            DONE_EXCLUDE();
                            (*pdflags) &= ~BUSY;
                            LEAVE_BOTH();
                            return ddrval;
                        }
                        dest_lock_taken = TRUE;
                    }
                    else
                    {
                        /*
                         * If this surface was involved in a hardware op, we need to
                         * probe the driver to see if it's done. NOTE this assumes
                         * that only one driver can be responsible for a system memory
                         * operation. See comment with WaitForDriverToFinishWithSurface.
                         */
                        if( (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                            (this_dest->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED) )
                        {
                            WaitForDriverToFinishWithSurface(pdrv_lcl, this_dest_lcl );
                        }

                        dest_lock_taken = FALSE;
                    }

                    if( ( this_src != NULL) && (lpDDSrcSurface != lpDDDestSurface) &&
                        ( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) == 0) )
                    {
                        while( 1 )
                        {
                            DPF(5,"Locking src: %x", this_src_lcl);
                            ddrval = InternalLock( this_src_lcl, &src_bits , NULL, DDLOCK_FAILONVISRGNCHANGED | dwSourceLockFlags );
#ifdef WINNT
                            if (ddrval == DDERR_VISRGNCHANGED)
                            {
                                DPF(5,"Resetting VisRgn for surface %x", this_dest_lcl);
                                DdResetVisrgn(this_dest_lcl, (HWND)0);
                                DONE_LOCKS();
                                goto get_clipping_info;
                            }
#endif
                            if( ddrval == DD_OK )
                            {
                                GET_LPDDRAWSURFACE_GBL_MORE(this_src)->fpNTAlias = (FLATPTR) src_bits;
                                break;
                            }
                            if( ddrval == DDERR_WASSTILLDRAWING )
                            {
                                continue;
                            }
                            if( fMustFreeRegion )
                                MemFree( prd );
                            DONE_LOCKS();
                            DONE_EXCLUDE();
                            (*pdflags) &= ~BUSY;
                            LEAVE_BOTH();
                            return ddrval;
                        }
                        src_lock_taken = TRUE;
                    }
                    else
                    {
                        /*
                         * If this surface was involved in a hardware op, we need to
                         * probe the driver to see if it's done. NOTE this assumes
                         * that only one driver can be responsible for a system memory
                         * operation. See comment with WaitForDriverToFinishWithSurface.
                         */
                        if( this_src && (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                            (this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED) )
                        {
                            WaitForDriverToFinishWithSurface(pdrv_lcl, this_src_lcl );
                        }

                        src_lock_taken = FALSE;
                    }
                }

                /*
         * See if the driver wants to do the clipping
         */
                if( (stretch_blt && (*(lpbc->dwCaps) & DDCAPS_CANCLIPSTRETCHED)) ||
                    (!stretch_blt && (*(lpbc->dwCaps) & DDCAPS_CANCLIP)) )
                {
                    // The driver will do the clipping
                    bd.dwRectCnt = total;
                    bd.prDestRects = prect;

                    if(IsD3DManaged(this_dest_lcl))
                    {
                        /* We don't want to deal with this mess, so mark everything dirty */
                        this_dest_lcl->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
                    }

                    /*
         * pass the whole mess off to the driver
                 */

                drvclip_try_again:
                    if( sbd.helonly )
                    {
                        // Release busy now or GDI blt will fail
                        DONE_BUSY();
                    }

                    if (bd.dwFlags & DDBLT_PRESENTATION)
                    {
                        bd.dwFlags |= DDBLT_LAST_PRESENTATION;
                    }

#ifdef WINNT
                    if (subrect_lock_taken)
                    {
                        // If we took a subrect lock on the primary, we need
                        // to adjust the dest rect so the HEL will draw it
                        // in the right spot.  We couldn't do it before because
                        // the above stretch code reuqires the corfrect rect.
                        bd.rDest.right -= subrect_lock_rect.left;
                        bd.rDest.left -= subrect_lock_rect.left;
                        bd.rDest.bottom -= subrect_lock_rect.top;
                        bd.rDest.top -= subrect_lock_rect.top;
                    }
#endif

                    DOHALCALL_NOWIN16( Blt, sbd.bltfn, bd, rc, sbd.helonly );

#ifdef WINNT
                    if (subrect_lock_taken)
                    {
                        // Adjust it back so we don't screw anything up.
                        bd.rDest.right += subrect_lock_rect.left;
                        bd.rDest.left += subrect_lock_rect.left;
                        bd.rDest.bottom += subrect_lock_rect.top;
                        bd.rDest.top += subrect_lock_rect.top;
                    }
#endif

                    if( rc == DDHAL_DRIVER_HANDLED )
                    {
#ifdef WINNT
                        if (bd.ddRVal == DDERR_VISRGNCHANGED)
                        {
                            DONE_LOCKS();
                            DPF(5,"Resetting VisRgn for surface %x", this_dest_lcl);
                            DdResetVisrgn(this_dest_lcl, (HWND)0);
                            goto get_clipping_info;
                        }
#endif
                        if ( (dwFlags & DDBLT_WAIT) &&
                             bd.ddRVal == DDERR_WASSTILLDRAWING )
                        {
                            DPF(4, "Waiting.....");
                            goto drvclip_try_again;
                        }
                        /*
                         * Only mark the surface as in use by the hardware if we didn't wait for it
                         * to finish and it succeeded. Don't mark it if it's HEL, since
                         * the HEL will never be asynchronous.
                         */
                        if( !sbd.helonly && lpbc->bHALSeesSysmem && (bd.ddRVal == DD_OK) )
                        {
                            DPF(5,B,"Tagging surface %08x",this_dest);
                            if (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                                this_dest->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPDEST;
                            if (this_src)
                            {
                                DPF(5,B,"Tagging surface %08x",this_src);
                                if (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                                    this_src->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPSOURCE;
                            }
                        }
                    }
                }
                else
                {
                    // We will do the clipping
                    bd.dwRectCnt =1;
                    bd.prDestRects = (LPVOID)&(bd.rDest);

                    // precalculate a couple of variables
                    if( !stretch_blt )
                    {
                        x_offset = bd.rSrc.left - bd.rDest.left;
                        y_offset = bd.rSrc.top - bd.rDest.top;
                    }
                    else
                    {
                        // scale_x and scale_y are fixed point variables scaled
                        // 16.16 (16 integer bits and 16 fractional bits)
                        scale_x = ((bd.rSrc.right - bd.rSrc.left) << 16) /
                            (bd.rDest.right - bd.rDest.left);
                        scale_y = ((bd.rSrc.bottom - bd.rSrc.top) << 16) /
                            (bd.rDest.bottom - bd.rDest.top);
                    }

                    /*
         * traverse the visible rect list and send each piece to
         * the driver to blit.
         */
                    for( cnt=0;cnt<total;cnt++ )
                    {
                        /*
                         * find out where on the src rect we need to get
                         * the data from.
             */
                        if( !stretch_blt )
                        {
                            // no stretch
                            // one-to-one mapping from source to destination
                            bd.rDest.left = prect->left;
                            bd.rDest.right = prect->right;
                            bd.rDest.top = prect->top;
                            bd.rDest.bottom = prect->bottom;
                            bd.rSrc.left = bd.rDest.left + x_offset;
                            bd.rSrc.right = bd.rDest.right + x_offset;
                            bd.rSrc.top = bd.rDest.top + y_offset;
                            bd.rSrc.bottom = bd.rDest.bottom + y_offset;
                        }
                        else
                        {
                            // stretching
                            // linear mapping from source to destination
                            bd.rDest.left = prect->left;
                            bd.rDest.right = prect->right;
                            bd.rDest.top = prect->top;
                            bd.rDest.bottom = prect->bottom;

            // calculate the source rect which transforms to the
            // dest rect
                            XformRect( (RECT *)&(bd.rOrigSrc), (RECT *)&(bd.rOrigDest), (RECT *)prect,
                                       (RECT *)&(bd.rSrc), scale_x, scale_y );
                        }

                        /*
                        * Add a rect to the region list if this is a managed surface
                        */
                        if(IsD3DManaged(this_dest_lcl))
                        {
                            LPREGIONLIST lpRegionList = this_dest_lcl->lpSurfMore->lpRegionList;
                            if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                            {
                                lpRegionList->rect[(lpRegionList->rdh.nCount)++] = bd.rDest;
                                lpRegionList->rdh.nRgnSize += sizeof(RECT);
                                if(bd.rDest.left < lpRegionList->rdh.rcBound.left)
                                    lpRegionList->rdh.rcBound.left = bd.rDest.left;
                                if(bd.rDest.right > lpRegionList->rdh.rcBound.right)
                                    lpRegionList->rdh.rcBound.right = bd.rDest.right;
                                if(bd.rDest.top < lpRegionList->rdh.rcBound.top)
                                    lpRegionList->rdh.rcBound.top = bd.rDest.top;
                                if(bd.rDest.bottom > lpRegionList->rdh.rcBound.bottom)
                                    lpRegionList->rdh.rcBound.bottom = bd.rDest.bottom;
                            }
                        }

                        /*
             * blt this little piece
             */
                    clip_try_again:
                        if( sbd.helonly )
                        {
                            // Release busy now or GDI blt will fail
                            DONE_BUSY();
                        }

                        // If mirror Blt, we must fix up source rect here!
                        if (bd.dwFlags & DDBLT_DDFX)
                        {
                            int temp;

                            if (bd.bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT)
                            {
                                temp = bd.rSrc.left;
                                bd.rSrc.left = bd.rOrigSrc.left + bd.rOrigSrc.right - bd.rSrc.right;
                                bd.rSrc.right = bd.rOrigSrc.left + bd.rOrigSrc.right - temp;
                            }

                            if (bd.bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)
                            {
                                temp = bd.rSrc.top;
                                bd.rSrc.top = bd.rOrigSrc.top + bd.rOrigSrc.bottom - bd.rSrc.bottom;
                                bd.rSrc.bottom = bd.rOrigSrc.top + bd.rOrigSrc.bottom - temp;
                            }
                        }

                        if (bd.dwFlags & DDBLT_PRESENTATION)
                        {
                            if (cnt == total-1)
                            {
                                bd.dwFlags |= DDBLT_LAST_PRESENTATION;
                            }
                        }

#ifdef WINNT
                        if (subrect_lock_taken)
                        {
                            // Adjust the dest rect so the HEL will draw to the 
                            // right place.
                            bd.rDest.right -= subrect_lock_rect.left;
                            bd.rDest.left -= subrect_lock_rect.left;
                            bd.rDest.bottom -= subrect_lock_rect.top;
                            bd.rDest.top -= subrect_lock_rect.top;
                        }
#endif

                        DOHALCALL_NOWIN16( Blt, sbd.bltfn, bd, rc, sbd.helonly );

#ifdef WINNT
                        if (subrect_lock_taken)
                        {
                            // Adjust it back so we don't screw anything up.
                            bd.rDest.right += subrect_lock_rect.left;
                            bd.rDest.left += subrect_lock_rect.left;
                            bd.rDest.bottom += subrect_lock_rect.top;
                            bd.rDest.top += subrect_lock_rect.top;
                        }
#endif

                        if( rc == DDHAL_DRIVER_HANDLED )
                        {
#ifdef WINNT
                            if (bd.ddRVal == DDERR_VISRGNCHANGED)
                            {
                                DONE_LOCKS();
                                DPF(5,"Resetting VisRgn for surface %x", this_dest_lcl);
                                DdResetVisrgn(this_dest_lcl, (HWND)0);
                                /*
                                * restore original source rect if vis region
                                * changed, for mirrored/clipped cases
                                */
                                bd.rSrc=bd.rOrigSrc;
                                bd.rDest=bd.rOrigDest;
                                goto get_clipping_info;
                            }
#endif
                            /*
                             * NOTE: If clipping has introduced more than
                             * one rectangle we behave as if DDBLT_WAIT
                             * was specified on all rectangles after the
                             * first. This is necessary as the first
                             * rectangle will probably cause the accelerator
                             * to be busy. Hence, the attempt to blit the
                             * second rectangle will fail with
                             * DDERR_WASSTILLDRAWING. If we pass this to
                             * the application (rather than busy waiting)
                             * the application is likely to retry the blit
                             * (which will fail on the second rectangle again)
                             * and we have an application sitting in an
                             * infinite loop).
                             */
                            if ( ( (dwFlags & DDBLT_WAIT) || (cnt > 0) ) &&
                                 bd.ddRVal == DDERR_WASSTILLDRAWING )
                            {
                                DPF(4, "Waiting.....");
                                goto clip_try_again;
                            }

                            if( bd.ddRVal != DD_OK )
                            {
                                break;
                            }
                            /*
                             * Only mark the surface as in use by the hardware if we didn't wait for it
                             * to finish and it succeeded. Only mark surfaces if it's not the HEL
                             * because the HEL is never async.
                             */
                            if( !sbd.helonly && lpbc->bHALSeesSysmem )
                            {
                                DPF(5,B,"Tagging surface %08x",this_dest);
                                if (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                                    this_dest->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPDEST;
                                if (this_src)
                                {
                                    DPF(5,B,"Tagging surface %08x",this_src);
                                    if (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                                        this_src->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPSOURCE;
                                }
                            }
                        }

                        /*
             * next clipping rect
             */
                        prect++;
                    }
                }
                if( fMustFreeRegion )
                    MemFree( prd );

            null_clip_rgn:
                ;
            }

            DONE_LOCKS();

    /*
     * Exclusion needs to happen after unlock call
     */
            DONE_EXCLUDE();

            if( rc != DDHAL_DRIVER_HANDLED )
            {
                /*
                 * did the driver run out of hardware color key resources?
         */
                if( (rc == DDHAL_DRIVER_NOCKEYHW) && (dwFlags & DDBLT_KEYSRCOVERRIDE) )
                {
                    ddrval = ChangeToSoftwareColorKey( this_src_int, FALSE );
                    if( ddrval == DD_OK )
                    {
                        sbd.halonly = FALSE;
                        sbd.helonly = FALSE;
                        if (src_pagelock_taken)
                        {
                            src_pagelock_taken = FALSE;
                            InternalPageUnlock(this_src_lcl, pdrv_lcl);
                        }
                        if (dest_pagelock_taken)
                        {
                            dest_pagelock_taken = FALSE;
                            InternalPageUnlock(this_dest_lcl, pdrv_lcl);
                        }

                        goto RESTART_BLT;
                    }
                    else
                    {
                        bd.ddRVal = DDERR_NOCOLORKEYHW;
                    }
                }
                else
                {
                    bd.ddRVal = DDERR_UNSUPPORTED;
                }
            }
            DONE_BUSY();

        /*
         * Maintain old behaviour for old drivers (which do not export the
         * GetSysmemBltStatus HAL call) and just spin until they're done.
         * Any alternative could exercise new code paths in the driver
         * (e.g. reentered for a DMA operation)
         */
            if ( lpbc->bHALSeesSysmem &&
                 (NULL == pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus || dest_pagelock_taken || src_pagelock_taken)
                )
            {
                if( this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
                {
                    /*
                     * Wait on the destination surface only
                     */
                    DDASSERT(this_src && this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
                    while (DDERR_WASSTILLDRAWING == InternalGetBltStatus(pdrv_lcl, this_dest_lcl, DDGBS_ISBLTDONE))
                        ;
                    this_src_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                    this_dest_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                }
                /*
                 * Unpagelock if we took the pagelocks
                 */
                if (dest_pagelock_taken)
                    InternalPageUnlock(this_dest_lcl, pdrv_lcl);
                if (src_pagelock_taken)
                    InternalPageUnlock(this_src_lcl, pdrv_lcl);
            }

            if(IsD3DManaged(this_dest_lcl))
                MarkDirty(this_dest_lcl);

            LEAVE_BOTH();

            return bd.ddRVal;
        }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            DPF_ERR( "Exception encountered doing blt" );
            DONE_LOCKS();
            DONE_EXCLUDE();
            DONE_BUSY();

            /*
             * Maintain old behaviour for old drivers (which do not export the
             * GetSysmemBltStatus HAL call) and just spin until they're done.
             * Any alternative could exercise new code paths in the driver
             * (e.g. reentered for a DMA operation)
             */
            if ( lpbc->bHALSeesSysmem &&
                 (NULL == pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus || dest_pagelock_taken || src_pagelock_taken)
                )
            {
                if( this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
                {
                    /*
                     * Wait on the destination surface only
                     */
                    DDASSERT(this_src && this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
                    while (DDERR_WASSTILLDRAWING == InternalGetBltStatus(pdrv_lcl, this_dest_lcl, DDGBS_ISBLTDONE))
                        ;
                    this_src_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                    this_dest_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                }
                /*
                 * Unpagelock if we took the pagelocks
                 */
                if (dest_pagelock_taken)
                    InternalPageUnlock(this_dest_lcl, pdrv_lcl);
                if (src_pagelock_taken)
                    InternalPageUnlock(this_src_lcl, pdrv_lcl);
            }

            LEAVE_BOTH();
            return DDERR_EXCEPTION;
        }

} /* DD_Surface_Blt */

#undef DPF_MODNAME
#define DPF_MODNAME     "BltBatch"

/*
 * DD_Surface_BltBatch
 *
 * BitBlt a whole pile of surfaces
 */
HRESULT DDAPI DD_Surface_BltBatch(
                LPDIRECTDRAWSURFACE lpDDDestSurface,
                LPDDBLTBATCH lpDDBltBatch,
                DWORD dwCount,
                DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_LCL   this_src_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL   this_dest_lcl;
    LPDDRAWI_DDRAWSURFACE_INT   this_src_int;
    LPDDRAWI_DDRAWSURFACE_INT   this_dest_int;
    HRESULT                     ddrval;
    int                         i;

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_BltBatch");

    /*
     * validate surface ptrs
     */
    this_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDDestSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( this_dest_int ) )
    {
        DPF_ERR( "Invalid dest specified") ;
        LEAVE_BOTH();
        return DDERR_INVALIDOBJECT;
    }
    this_dest_lcl = this_dest_int->lpLcl;

    if( SURFACE_LOST( this_dest_lcl ) )
    {
        DPF( 1, "Dest lost") ;
        LEAVE_BOTH();
        return DDERR_SURFACELOST;
    }

    if( this_dest_lcl->lpGbl->dwUsageCount > 0 )
    {
        DPF( 1, "Dest surface %08lx is still locked", this_dest_int );
        LEAVE_BOTH();
        return DDERR_SURFACEBUSY;
    }
    /*
     * validate BltBatch ptr
     */
    if( !VALID_DDBLTBATCH_PTR( lpDDBltBatch ) )
    {
        DPF( 1, "Invalid Blt batch ptr" );
        LEAVE_BOTH();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * validate blt batch params
     */
    for( i=0;i<(int)dwCount;i++ )
    {
        /*
         * validate dest rect
         */
        if( lpDDBltBatch[i].lprDest != NULL )
        {
            if( !VALID_RECT_PTR(lpDDBltBatch[i].lprDest) )
            {
                DPF( 1, "dest rectangle invalid, entry %d", i );
                LEAVE_BOTH();
                return DDERR_INVALIDRECT;
            }
        }

        /*
         * validate source surface
         */
        this_src_int = (LPDDRAWI_DDRAWSURFACE_INT)lpDDBltBatch[i].lpDDSSrc;
        if( this_src_int != NULL )
        {
            if( !VALID_DIRECTDRAWSURFACE_PTR( this_src_int ) )
            {
                DPF( 1, "Invalid source specified, entry %d", i );
                LEAVE_BOTH();
                return DDERR_INVALIDOBJECT;
            }
            this_src_lcl = this_src_int->lpLcl;
            if( SURFACE_LOST( this_src_lcl ) )
            {
                DPF( 1, "Src lost, entry %d", i) ;
                LEAVE_BOTH();
                return DDERR_SURFACELOST;
            }
            if( this_src_lcl->lpGbl->dwUsageCount > 0 )
            {
                DPF( 2, "Source surface %08lx is still locked, entry %d", this_src_int, i );
                LEAVE_BOTH();
                return DDERR_SURFACEBUSY;
            }

            if (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
            {
                DPF_ERR( "It is an optimized surface" );
                LEAVE_DDRAW();
                return DDERR_ISOPTIMIZEDSURFACE;
            }
        }

        if (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

        /*
         * validate src rect
         */
        if( lpDDBltBatch[i].lprSrc != NULL )
        {
            if( !VALID_RECT_PTR(lpDDBltBatch[i].lprSrc) )
            {
                DPF( 1, "src rectangle invalid, entry %d", i );
                LEAVE_BOTH();
                return DDERR_INVALIDRECT;
            }
        }

        /*
         * validate bltfx ptr
         */
        if( lpDDBltBatch[i].lpDDBltFx != NULL )
        {
            if( !VALID_DDBLTFX_PTR( lpDDBltBatch[i].lpDDBltFx ) )
            {
                DPF( 1, "Invalid BLTFX specified, entry %d", i );
                LEAVE_BOTH();
                return DDERR_INVALIDPARAMS;
            }
        }
        else
        {
            if( lpDDBltBatch[i].dwFlags
                        & ( DDBLT_ALPHASRCCONSTOVERRIDE |
                            DDBLT_ALPHADESTCONSTOVERRIDE |
                            DDBLT_ALPHASRCSURFACEOVERRIDE |
                            DDBLT_ALPHADESTSURFACEOVERRIDE |
                            DDBLT_COLORFILL |
                            DDBLT_DDFX |
                            DDBLT_DDROPS |
                            DDBLT_DEPTHFILL |
                            DDBLT_KEYDESTOVERRIDE |
                            DDBLT_KEYSRCOVERRIDE |
                            DDBLT_ROP |
                            DDBLT_ROTATIONANGLE |
                            DDBLT_ZBUFFERDESTCONSTOVERRIDE |
                            DDBLT_ZBUFFERDESTOVERRIDE |
                            DDBLT_ZBUFFERSRCCONSTOVERRIDE |
                            DDBLT_ZBUFFERSRCOVERRIDE ) )
            {
                DPF( 1, "BltFX required but not specified, entry %d", i );
                LEAVE_BOTH();
                return DDERR_INVALIDPARAMS;
            }
        }

    }

    ddrval = DDERR_UNSUPPORTED;

    for( i=0;i<(int)dwCount;i++ )
    {
        #if 0
        while( 1 )
        {
            ddrval = doBlt( this_dest_lcl,
                    lpDDBltBatch[i].lprDest,
                    lpDDBltBatch[i].lpDDSSrc,
                    lpDDBltBatch[i].lprSrc,
                    lpDDBltBatch[i].dwFlags,
                    lpDDBltBatch[i].lpDDBltFX );
            if( ddrval != DDERR_WASSTILLDRAWING )
            {
                break;
            }
        }
        #endif
        if( ddrval != DD_OK )
        {
            break;
        }
    }

    LEAVE_BOTH();
    return ddrval;

} /* BltBatch */

/*
 * XformRect
 *
 * Transform a clipped rect in destination space to the corresponding clipped
 * rect in src space. So, if we're stretching from src to dest, this yields
 * the unstretched clipping rect in src space.
 *
 *  PARAMETERS:
 *      prcSrc - unclipped rect in the source space
 *      prcDest - unclipped rect in the destination space
 *      prcClippedDest - the rect we want to transform
 *      prcClippedSrc - the resulting rect in the source space.  return value.
 *      scale_x - 16.16 fixed point src/dest width ratio
 *      scale_y  - 16.16 fixed point src/dest height ratio
 *
 *  DESCRIPTION:
 *      Given an rect in source space and a rect in destination space, and a
 *      clipped rectangle in the destination space (prcClippedDest), return
 *      the rectangle in the source space (prcClippedSrc) that maps to
 *      prcClippedDest.
 *
 *      Use 16.16 fixed point math for more accuracy. (Shift left, do math,
 *      shift back (w/ round))
 *
 *  RETURNS:
 *      DD_OK always.  prcClippedSrc is the mapped rectangle.
 *
 */
HRESULT XformRect(RECT * prcSrc, RECT * prcDest, RECT * prcClippedDest,
                  RECT * prcClippedSrc, DWORD scale_x, DWORD scale_y)
{
    /*
     * This first calculation is done with fixed point arithmetic (16.16).
     * The result is converted to (32.0) below. Scale back into source space
     */
    prcClippedSrc->left = (prcClippedDest->left - prcDest->left) * scale_x;
    prcClippedSrc->right = (prcClippedDest->right - prcDest->left) * scale_x;
    prcClippedSrc->top = (prcClippedDest->top - prcDest->top) * scale_y;
    prcClippedSrc->bottom = (prcClippedDest->bottom - prcDest->top) * scale_y;

    /*
     * now round (adding 0x8000 rounds) and translate (offset by the
     * src offset)
     */
    prcClippedSrc->left = (((DWORD)prcClippedSrc->left + 0x8000) >> 16) + prcSrc->left;
    prcClippedSrc->right = (((DWORD)prcClippedSrc->right + 0x8000) >> 16) + prcSrc->left;
    prcClippedSrc->top = (((DWORD)prcClippedSrc->top + 0x8000) >> 16) + prcSrc->top;
    prcClippedSrc->bottom = (((DWORD)prcClippedSrc->bottom + 0x8000) >> 16) + prcSrc->top;

    /*
     * Check for zero-sized source rect dimensions and bump if necessary
     */
    if (prcClippedSrc->left == prcClippedSrc->right)
    {
        if (prcClippedSrc->right == prcSrc->right)
        {
            (prcClippedSrc->left)--;
        }
        else
        {
            (prcClippedSrc->right)++;
        }

    }
    if (prcClippedSrc->top == prcClippedSrc->bottom)
    {
        if (prcClippedSrc->bottom == prcSrc->bottom)
        {
            (prcClippedSrc->top)--;
        }
        else
        {
            (prcClippedSrc->bottom)++;
        }

    }

    return DD_OK;

} /* XformRect */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddsblto.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsblto.c
 *  Content:	DirectDraw surface object blt order suport
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27-jan-95	craige	split out of ddsurf.c
 *   31-jan-95	craige	and even more ongoing work...
 *   27-feb-95	craige 	new sync. macros
 *   08-mar-95	craige	new API: AddSurfaceDependency
 *   19-mar-95	craige	use HRESULTs
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-may-95	craige	use driver-level csects only
 *   16-jun-95	craige	new surface structure
 *   21-jun-95	craige	tweaks for new surface structs
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	commented out
 *
 ***************************************************************************/
#include "ddrawpr.h"

#ifdef COMPOSITION
/*
 * DD_SurfaceComposition_GetCompositionOrder
 */
HRESULT DDAPI DD_SurfaceComposition_GetCompositionOrder(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface,
		LPDWORD lpdwCompositionOrder )
{
    LPDDRAWI_DDRAWSURFACE_LCL		thisx;
    LPDDRAWI_DDRAWSURFACE_GBL		this;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_GetCompositionOrder");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    if( !VALID_DWORD_PTR( lpdwCompositionOrder ) )
    {
	return DDERR_INVALIDPARAMS;
    }
    this = thisx->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }

//    *lpdwCompositionOrder = this->dwCompositionOrder;

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_GetCompositionOrder */

/*
 * DD_SurfaceComposition_SetCompositionOrder
 */
HRESULT DDAPI DD_SurfaceComposition_SetCompositionOrder(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface,
		DWORD dwCompositionOrder )
{
    LPDDRAWI_DDRAWSURFACE_LCL		thisx;
    LPDDRAWI_DDRAWSURFACE_GBL		this;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_SetCompositionOrder");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
//    this->dwCompositionOrder = dwCompositionOrder;
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_SetCompositionOrder */

/*
 * DD_SurfaceComposition_DeleteSurfaceDependency
 */
HRESULT DDAPI DD_SurfaceComposition_DeleteSurfaceDependency(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface,
		DWORD dwFlagsForNoGoodReason,
		LPDIRECTDRAWSURFACE lpDDSurface2 )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	this2x;
    LPDDRAWI_DDRAWSURFACE_GBL	this2;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_DeleteSurfaceDependency");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }

    this2x = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface2;
    if( !VALID_DIRECTDRAWSURFACE_PTR( this2x ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    this2 = this2x->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    if( SURFACE_LOST( this2x ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_DeleteSurfaceDependency */

/*
 * DD_SurfaceComposition_DestLock
 */
HRESULT DDAPI DD_SurfaceComposition_DestLock(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_DestLock");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_DestLock */

/*
 * DD_SurfaceComposition_DestUnlock
 */
HRESULT DDAPI DD_SurfaceComposition_DestUnlock(
	    LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_DestUnlock");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_DestUnlock */

/*
 * DD_SurfaceComposition_EnumSurfaceDependencies
 */
HRESULT DDAPI DD_SurfaceComposition_EnumSurfaceDependencies(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface,
		LPVOID lpContext,
		LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_EnumSurfaceDependencies");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    if( !VALID_CODE_PTR( lpEnumSurfacesCallback ) )
    {
	return DDERR_INVALIDPARAMS;
    }
    this = thisx->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_EnumSurfaceDependencies */

/*
 * DD_SurfaceComposition_SetSurfaceDependency
 */
HRESULT DDAPI DD_SurfaceComposition_SetSurfaceDependency(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface,
		LPDIRECTDRAWSURFACE lpDDSurface2 )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	this2x;
    LPDDRAWI_DDRAWSURFACE_GBL	this2;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_SetSurfaceDependency");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this2x = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface2;
    if( !VALID_DIRECTDRAWSURFACE_PTR( this2x ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    this2 = this2x->lpGbl;
    if( SURFACE_LOST( this2x ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_SetSurfaceDependency */

/*
 * DD_SurfaceComposition_AddSurfaceDependency
 */
HRESULT DDAPI DD_SurfaceComposition_AddSurfaceDependency(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface,
		LPDIRECTDRAWSURFACE lpDDSurfaceDep )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_LCL	this_depx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_GBL	this_dep;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_AddSurfaceDependency");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    this_depx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurfaceDep;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    if( !VALID_DIRECTDRAWSURFACE_PTR( this_depx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    this_dep = this_depx->lpGbl;
    ENTER_DDRAW();

    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    if( SURFACE_LOST( this_depx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_AddSurfaceDependency */

#undef DPF_MODNAME
#define DPF_MODNAME	"Compose"

/*
 * DD_SurfaceComposition_Compose
 */
HRESULT DDAPI DD_SurfaceComposition_Compose(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDDestSurface,
		LPRECT lpDestRect,
		LPDIRECTDRAWSURFACE lpDDSrcSurface,
		LPRECT lpSrcRect,
		DWORD dwFlags,
		LPDDCOMPOSEFX lpDDComposeFX )
{
    LPDDRAWI_DIRECTDRAW		pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL	this_srcx;
    LPDDRAWI_DDRAWSURFACE_LCL	this_destx;
    LPDDRAWI_DDRAWSURFACE_GBL	this_src;
    LPDDRAWI_DDRAWSURFACE_GBL	this_dest;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_Compose");

    this_destx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDDestSurface;
    this_srcx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSrcSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( this_destx ) )
    {
	DPF_ERR( "invalid dest specified") ;
	return DDERR_INVALIDOBJECT;
    }
    this_dest = this_destx->lpGbl;
    pdrv = this_dest->lpDD;
    ENTER_DDRAW();
    if( this_srcx != NULL )
    {
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_srcx ) )
	{
	    DPF_ERR( "Invalid source specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_src = this_srcx->lpGbl;
	if( SURFACE_LOST( this_srcx ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
    } 
    else
    {
	this_src = NULL;
    }

    LEAVE_DDRAW();

    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_Compose */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\decoder.cpp ===
#include "ddrawpr.h"

#include <ImgUtil.H>
//#include <ocmm.h>
#include "decoder.h"
#include <atlcom.h>

#define Assert(x)
#define ReleaseMemoryDC(x)	DeleteObject(x)
#define MulDivQuick			MulDiv
#define	Verify(x)			x

extern HPALETTE hpalApp;


void CImageDecodeEventSink::Init(FILTERINFO * pFilter)
{
    m_nRefCount=0;
    m_pFilter=pFilter;
    m_pDDrawSurface=NULL;
    m_dwLastTick=0;
    ZeroMemory(&m_rcProg, sizeof(m_rcProg));
}
/*
CImageDecodeEventSink::~CImageDecodeEventSink()
{
}
*/

ULONG CImageDecodeEventSink::AddRef()
{
    m_nRefCount++;

    return (m_nRefCount);
}

ULONG CImageDecodeEventSink::Release()
{
    m_nRefCount--;
    if (m_nRefCount == 0)
    {
     //   delete this;
        return (0);
    }

    return (m_nRefCount);
}

STDMETHODIMP CImageDecodeEventSink::QueryInterface(REFIID iid, 
   void** ppInterface)
{
    if (ppInterface == NULL)
    {
        return (E_POINTER);
    }

    *ppInterface = NULL;

    if (IsEqualGUID(iid, IID_IUnknown))
    {
        *ppInterface = (IUnknown*)(IImageDecodeEventSink *)this;
    }
    else if (IsEqualGUID(iid, IID_IImageDecodeEventSink))
    {
        *ppInterface = (IImageDecodeEventSink*)this;
    }
    else
    {
        return (E_NOINTERFACE);
    }

    //  If we're going to return an interface, AddRef it first
    if (*ppInterface)
    {
        ((LPUNKNOWN)*ppInterface)->AddRef();
        return S_OK;
    }

    return (S_OK);
}

STDMETHODIMP CImageDecodeEventSink::OnBeginDecode(DWORD* pdwEvents, 
   ULONG* pnFormats, GUID** ppFormats)
{
    GUID* pFormats;

    if (pdwEvents != NULL)
    {
        *pdwEvents = 0;
    }
    if (pnFormats != NULL)
    {
        *pnFormats = 0;
    }
    if (ppFormats != NULL)
    {
        *ppFormats = NULL;
    }
    if (pdwEvents == NULL)
    {
        return (E_POINTER);
    }
    if (pnFormats == NULL)
    {
        return (E_POINTER);
    }
    if (ppFormats == NULL)
    {
        return (E_POINTER);
    }

#if 0
    if (m_pFilter->_colorMode == 8)
    {
        pFormats = (GUID*)CoTaskMemAlloc(1*sizeof(GUID));
        if(pFormats == NULL)
        {
            return (E_OUTOFMEMORY);
        }
        
        pFormats[0] = BFID_INDEXED_RGB_8;
        *pnFormats = 1;
    }
#endif
#if 1
    else
    {
        pFormats = (GUID*)CoTaskMemAlloc(2*sizeof(GUID));
        if(pFormats == NULL)
        {
            return (E_OUTOFMEMORY);
        }
        
        pFormats[0] = BFID_RGB_24;
        pFormats[1] = BFID_INDEXED_RGB_8;
        *pnFormats = 2;
    }
#else
    else
    {
        pFormats = (GUID*)CoTaskMemAlloc(1*sizeof(GUID));
        if(pFormats == NULL)
        {
            return (E_OUTOFMEMORY);
        }
        
        pFormats[0] = BFID_RGB_24;
        *pnFormats = 1;
    }
#endif
    *ppFormats = pFormats;
    *pdwEvents = IMGDECODE_EVENT_PALETTE|IMGDECODE_EVENT_BITSCOMPLETE|IMGDECODE_EVENT_PROGRESS;

	*pdwEvents |= IMGDECODE_EVENT_USEDDRAW;

#if 0
	if (m_pFilter->_colorMode != 8)
		*pdwEvents |= IMGDECODE_EVENT_USEDDRAW;
#endif

	m_dwLastTick = GetTickCount();

    return (S_OK);
}

STDMETHODIMP CImageDecodeEventSink::OnBitsComplete()
{
    return (S_OK);
}

STDMETHODIMP CImageDecodeEventSink::OnDecodeComplete(HRESULT hrStatus)
{
    return (S_OK);
}

#define LINEBYTES(_wid,_bits) ((((_wid)*(_bits) + 31) / 32) * 4)

STDMETHODIMP CImageDecodeEventSink::GetSurface(LONG nWidth, LONG nHeight, 
    REFGUID bfid, ULONG nPasses, DWORD dwHints, IUnknown** ppSurface)
{
    return GetDDrawSurface(nWidth, nHeight, bfid, nPasses, dwHints, ppSurface);
}


STDMETHODIMP CImageDecodeEventSink::GetDDrawSurface(LONG nWidth, LONG nHeight, 
    REFGUID bfid, ULONG nPasses, DWORD dwHints, IUnknown ** ppSurface)
{
	DDSURFACEDESC2	ddsd = {sizeof(ddsd)};

    (void)nPasses;
    (void)dwHints;
    
    if (ppSurface != NULL)
    {
        *ppSurface = NULL;
    }
    if (ppSurface == NULL)
    {
        return (E_POINTER);
    }

    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
    ddsd.dwHeight = nHeight;
    ddsd.dwWidth = nWidth;
    ddsd.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);

    if (IsEqualGUID(bfid, BFID_INDEXED_RGB_8))
    {
        m_pFilter->m_nBytesPerPixel = 1;

		ddsd.ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
		ddsd.ddpfPixelFormat.dwRGBBitCount = 8;
		ddsd.ddpfPixelFormat.dwRBitMask = 0;
		ddsd.ddpfPixelFormat.dwGBitMask = 0;
		ddsd.ddpfPixelFormat.dwBBitMask = 0;
		ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0;
    }
    else if (IsEqualGUID(bfid, BFID_RGB_24))
    {
        m_pFilter->m_nBytesPerPixel = 3;

		ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
		ddsd.ddpfPixelFormat.dwRGBBitCount = 24;
		ddsd.ddpfPixelFormat.dwRBitMask = 0x00FF0000L;
		ddsd.ddpfPixelFormat.dwGBitMask = 0x0000FF00L;
		ddsd.ddpfPixelFormat.dwBBitMask = 0x000000FFL;
		ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0;
    }
    else
    {
        return (E_NOINTERFACE);
    }

    IDirectDrawSurface4 * lpDDS;


	if (FAILED(m_pDirectDrawEx->CreateSurface(&ddsd, &lpDDS, NULL)))
		return (E_OUTOFMEMORY);

        HRESULT hr = lpDDS->QueryInterface(IID_IDirectDrawSurface,(void**)&m_pDDrawSurface);
        lpDDS->Release();
        if (FAILED(hr))
        {
            return hr;
        }

	// If this is a palette surface create/attach a palette to it.

	if (m_pFilter->m_nBytesPerPixel == 1)
	{
		PALETTEENTRY	ape[256];
		LPDIRECTDRAWPALETTE2	pDDPalette;


		m_pDirectDrawEx->CreatePalette(DDPCAPS_8BIT | DDPCAPS_ALLOW256, ape, &pDDPalette, NULL);
		m_pDDrawSurface->SetPalette((LPDIRECTDRAWPALETTE)pDDPalette);
		pDDPalette->Release();
	}

	m_pFilter->m_pDDrawSurface = m_pDDrawSurface;
	m_pDDrawSurface->AddRef();

    *ppSurface = (IUnknown *)m_pDDrawSurface;
    (*ppSurface)->AddRef();
	
	return S_OK;
}

STDMETHODIMP CImageDecodeEventSink::OnPalette()
{
    return (S_OK);
}

STDMETHODIMP CImageDecodeEventSink::OnProgress(RECT* pBounds, BOOL bComplete)
{
	DWORD	dwTick = GetTickCount();

    if (pBounds == NULL)
    {
        return (E_INVALIDARG);
    }

	UnionRect(&m_rcProg, &m_rcProg, pBounds);

	if (dwTick - m_dwLastTick > 250)
	{
//              Used for progressive rendering.  Uncomment later
//		DrawImage(NULL, m_pFilter, &m_rcProg);  
		m_dwLastTick = GetTickCount();
	}

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\decoder.h ===
#include <atlbase.h>
//extern CComModule _Module;

struct FILTERINFO
{
int                 _colorMode;
ULONG               m_nBytesPerPixel;
DWORD               dwEvents;
IDirectDrawSurface  *m_pDDrawSurface;
};

class CImageDecodeEventSink : public IImageDecodeEventSink
{
public:
    void Init( FILTERINFO * pFilter );
//    CImageDecodeEventSink( FILTERINFO * pFilter );
//    ~CImageDecodeEventSink();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHOD(QueryInterface)(REFIID iid, void** ppInterface);

    STDMETHOD(GetSurface)(LONG nWidth, LONG nHeight, REFGUID bfid, 
        ULONG nPasses, DWORD dwHints, IUnknown** ppSurface);
    STDMETHOD(GetDDrawSurface)(LONG nWidth, LONG nHeight, REFGUID bfid, 
        ULONG nPasses, DWORD dwHints, IUnknown** ppSurface);
    STDMETHOD(OnBeginDecode)(DWORD* pdwEvents, ULONG* pnFormats, 
        GUID** ppFormats);
    STDMETHOD(OnBitsComplete)();
    STDMETHOD(OnDecodeComplete)(HRESULT hrStatus);
    STDMETHOD(OnPalette)();
    STDMETHOD(OnProgress)(RECT* pBounds, BOOL bFinal);

    void SetDDraw( IDirectDraw4 *pDDraw ) {m_pDirectDrawEx = pDDraw;}

    ULONG                       m_nRefCount;
    FILTERINFO                  *m_pFilter;
    IDirectDrawSurface          *m_pDDrawSurface;
    RECT                        m_rcProg;
    DWORD                       m_dwLastTick;
    IDirectDraw4                *m_pDirectDrawEx;
//    friend CDirectDrawEx;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddsurf.c ===
/*==========================================================================
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsurf.c
 *  Content: 	DirectDraw engine surface support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   25-dec-94	craige	initial implementation
 *   13-jan-95	craige	re-worked to updated spec + ongoing work
 *   21-jan-95	craige	made 32-bit + ongoing work
 *   31-jan-95	craige	and even more ongoing work...
 *   06-feb-95	craige	performance tuning, ongoing work
 *   27-feb-95	craige 	new sync. macros
 *   07-mar-95	craige	keep track of flippable surfaces
 *   11-mar-95	craige	palette stuff, keep track of process surface usage
 *   15-mar-95	craige 	HEL
 *   19-mar-95	craige	use HRESULTs
 *   20-mar-95	craige	allow NULL rect to disable cliplist
 *   31-mar-95	craige	don't allow hWnd to be updated if in exclusive mode
 *			and requesting process isn't the holder
 *   01-apr-95	craige	happy fun joy updated header file
 *   12-apr-95	craige	proper call order for csects
 *   15-apr-95	craige	flags for GetFlipStatus, added GetBltStatus
 *   16-apr-95	craige	flip between two specific surfaces was broken
 *   06-may-95	craige	use driver-level csects only
 *   23-may-95	craige	no longer use MapLS_Pool
 *   24-may-95	craige	added Restore
 *   28-may-95	craige	cleaned up HAL: added GetBltStatus; GetFlipStatus
 *   04-jun-95	craige	flesh out Restore; check for SURFACE_LOST inside csect;
 *			added IsLost
 *   11-jun-95	craige	prevent restoration of primary if different mode
 *   12-jun-95	craige	new process list stuff
 *   13-jun-95  kylej   moved FindAttachedFlip to misc.c
 *   17-jun-95	craige	new surface structure
 *   19-jun-95	craige	split out surface notification methods
 *   20-jun-95	craige	go get current clip list if user didn't specify one
 *   24-jun-95  kylej   added MoveToSystemMemory
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   27-jun-95	craige	don't let surfaces be restored if the mode is different
 *   28-jun-95	craige	fixed flip for overlays; ENTER_DDRAW at start of fns
 *   30-jun-95	kylej	only allow flip in exclusive mode, only allow surface
 *			restore in same video mode it was created, force
 *			primary to match existing primaries upon restore if
 *                      not exclusive, added GetProcessPrimary,
 *			InvalidateAllPrimarySurfaces, FindGlobalPrimary,
 *                      and MatchPrimary
 *   30-jun-95	craige	use DDRAWI_HASPIXELFORMAT/HASOVERLAYDATA
 *   01-jul-95	craige	allow flip always - just fail creation of flipping
 *   04-jul-95	craige	YEEHAW: new driver struct; SEH; redid Primary fns;
 *			fixes to MoveToSystemMemory; fixes to
 *			InvalidateAllPrimarySurfaces
 *   05-jul-95	craige	added Initialize
 *   07-jul-95	craige	added test for BUSY
 *   08-jul-95	craige	return DD_OK from Restore if surface is not lost;
 *			added InvalidateAllSurfaces
 *   09-jul-95	craige	Restore needs to reset pitch to aligned width before
 *			asking driver to reallocate; make MoveToSystemMemory
 *			recreate without VRAM so Restore can restore to sysmem
 *   11-jul-95	craige	GetDC fixes: no GetDC(NULL); need flag to check if
 *			DC has been allocated
 *   15-jul-95	craige	fixed flipping to move heap along with ptr
 *   15-jul-95  ericeng SetCompression if0 out, obsolete
 *   20-jul-95  toddla  fixed MoveToSystemMemory for 16bpp
 *   01-aug-95	craige	hold win16 lock at start of Flip
 *   04-aug-95	craige	have MoveToSystemMemory use InternalLock/Unlock
 *   10-aug-95  toddla  added DDFLIP_WAIT flag, but it is not turned on
 *   12-aug-95	craige	added use_full_lock in MoveToSystemMemory
 *   13-aug-95	craige	turned on DDFLIP_WAIT
 *   26-aug-95	craige	bug 717
 *   05-sep-95	craige	bug 894: don't invalidate SYSMEMREQUESTED surfaces
 *   10-sep-95	craige	bug 828: random vidmem heap free
 *   22-sep-95	craige	bug 1268,1269:  getbltstatus/getflipstatus flags wrong
 *   09-dec-95  colinmc added execute buffer support
 *   17-dec-95  colinmc added shared back and z-buffer support
 *   02-jan-96	kylej	handle new interface structs
 *   26-jan-96  jeffno	NT kernel conversation. NT Get/Release DC, flip GDI flag
 *   09-feb-96  colinmc surface invalid flag moved from the global to local
 *                      surface object
 *   17-feb-96  colinmc removed execute buffer size limitation
 *   26-feb-96  jeffno  GetDC for emulated offscreen now returns a new dc
 *   13-mar-96	kylej	Added DD_Surface_GetDDInterface
 *   17-mar-96  colinmc Bug 13124: flippable mip-maps
 *   14-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *                      surface
 *   26-mar-96  jeffno  Handle mode changes before flip (NT)
 *   05-sep-96	craige	added code to display frame rate to debug monitor
 *   05-jul-96  colinmc Work Item: Remove requirement on taking Win16 lock
 *                      for VRAM surfaces (not primary)
 *   07-oct-96	ketand	Change PageLock/Unlock to cache Physical Addresses
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   19-nov-96  colinmc Bug 4987: Fixed problems with Flip on the
 *                      IDirectDrawSurface2 interface
 *   10-jan-97  jeffno  Flip the primary chain flags so that GDI<==>Primary
 *                      after a ctrl-alt-del on NT.
 *   12-jan-97  colinmc More Win16 lock work
 *   18-jan-97  colinmc AGP support
 *   31-jan-97  colinmc Bug 5457: Fixed aliased locking (no Win16 lock)
 *                      problem with playing multiple AMovie clips at once.
 *   22-feb-97  colinmc Enabled OWNDC support for explicit system memory
 *                      surfaces
 *   03-mar-97  smac    Added kernel mode interface
 *   04-mar-97  smac    Bug 1987: Fixed bug flipping overlays when the
 *			surface didn't own the hardware
 *   08-mar-97  colinmc Added function to let surface pointer be overridden
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   24-mar-97  jeffno  Optimized Surfaces
 *   30-sep-97  jeffno  IDirectDraw4
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   11-nov-97 jvanaken New API call "Resize"
 *   18-dec-97 jvanaken SetSurfDesc will free client-alloc'd surface memory.
 *   25-may-00  RichGr  IA64: Change debug output to use %p format specifier
 *                      instead of %x for 32/64-bit pointers.
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
#endif
#define DPF_MODNAME	"GetCaps"

/* Shorter name makes flip code a little easier to understand */
#define GBLMORE(lpGbl) GET_LPDDRAWSURFACE_GBL_MORE(lpGbl)

/*
 * DD_Surface_GetCaps
 */
HRESULT DDAPI DD_Surface_GetCaps(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDDSCAPS lpDDSCaps )
{
    DDSCAPS2 ddscaps2 = {0,0,0,0};
    HRESULT  hr;

    DPF(2,A,"ENTERAPI: DD_Surface_GetCaps");

    hr = DD_Surface_GetCaps4(lpDDSurface, & ddscaps2 );
    if (hr == DD_OK)
    {
        TRY
        {
            lpDDSCaps->dwCaps = ddscaps2.dwCaps;
        }
        EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
	    DPF_ERR( "Invalid DDSCAPS pointer" );
	    return DDERR_INVALIDPARAMS;
        }
    }
    return hr;
}

HRESULT DDAPI DD_Surface_GetCaps4(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDDSCAPS2 lpDDSCaps )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetCaps4");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	if( !VALID_DDSCAPS2_PTR( lpDDSCaps ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	lpDDSCaps->dwCaps = this_lcl->ddsCaps.dwCaps;
	lpDDSCaps->ddsCapsEx = this_lcl->lpSurfMore->ddsCapsEx;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetCaps */

#undef DPF_MODNAME
#define DPF_MODNAME "GetFlipStatus"

/*
 * DD_Surface_GetFlipStatus
 */
HRESULT DDAPI DD_Surface_GetFlipStatus(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDHALSURFCB_GETFLIPSTATUS	gfshalfn;
    LPDDHALSURFCB_GETFLIPSTATUS	gfsfn;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetFlipStatus");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	if( dwFlags & ~DDGFS_VALID )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwFlags )
	{
	    if( (dwFlags & (DDGFS_CANFLIP|DDGFS_ISFLIPDONE)) ==
		    (DDGFS_CANFLIP|DDGFS_ISFLIPDONE) )
	    {
		DPF_ERR( "Invalid flags" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    DPF_ERR( "Invalid flags - no flag specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            DPF_ERR( "Invalid surface type: can't get flip status" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	#ifdef USE_ALIAS
	    if( pdrv->dwBusyDueToAliasedLock > 0 )
	    {
		/*
		 * Aliased locks (the ones that don't take the Win16 lock) don't
		 * set the busy bit either (it can't or USER get's very confused).
		 * However, we must prevent blits happening via DirectDraw as
		 * otherwise we get into the old host talking to VRAM while
		 * blitter does at the same time. Bad. So fail if there is an
		 * outstanding aliased lock just as if the BUST bit had been
		 * set.
		 */
		DPF_ERR( "Graphics adapter is busy (due to a DirectDraw lock)" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */

	/*
	 * device busy?
	 */
	if( *(pdrv->lpwPDeviceFlags) & BUSY )
	{
            DPF( 0, "BUSY" );
	    LEAVE_DDRAW()
	    return DDERR_SURFACEBUSY;
	}

	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
	{
	    LEAVE_DDRAW()
	    return DD_OK;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * ask the driver to get the current flip status
     */
    gfsfn = pdrv_lcl->lpDDCB->HALDDSurface.GetFlipStatus;
    gfshalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.GetFlipStatus;
    if( gfshalfn != NULL )
    {
	DDHAL_GETFLIPSTATUSDATA		gfsd;
	DWORD				rc;

    	gfsd.GetFlipStatus = gfshalfn;
	gfsd.lpDD = pdrv;
	gfsd.dwFlags = dwFlags;
	gfsd.lpDDSurface = this_lcl;
	DOHALCALL( GetFlipStatus, gfsfn, gfsd, rc, FALSE );
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    LEAVE_DDRAW();
	    return gfsd.ddRVal;
	}
    }

    LEAVE_DDRAW();
    // if you have to ask the hel, it's already done
    return DD_OK;

} /* DD_Surface_GetFlipStatus */

#undef DPF_MODNAME
#define DPF_MODNAME "InternalGetBltStatus"
HRESULT InternalGetBltStatus(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_LCL this_lcl , DWORD dwFlags )
{
    DDHAL_GETBLTSTATUSDATA		gbsd;
    LPDDHALSURFCB_GETBLTSTATUS 	        gbsfn;
    /*
     * Ask the driver to get the current blt status
     *
     */
    if ( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
    {
        gbsfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus;
        gbsd.GetBltStatus = pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus;
    }
    else
    {
        gbsfn = pdrv_lcl->lpDDCB->HALDDSurface.GetBltStatus;
        gbsd.GetBltStatus = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.GetBltStatus;
    }

    if( gbsd.GetBltStatus != NULL )
    {
	DWORD				rc;

	gbsd.lpDD = pdrv_lcl->lpGbl;
	gbsd.dwFlags = dwFlags;
	gbsd.lpDDSurface = this_lcl;
	DOHALCALL( GetBltStatus, gbsfn, gbsd, rc, FALSE );
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    return gbsd.ddRVal;
	}
    }

    return DD_OK;
}
#undef DPF_MODNAME
#define DPF_MODNAME "GetBltStatus"

/*
 * DD_Surface_GetBltStatus
 */
HRESULT DDAPI DD_Surface_GetBltStatus(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT                     ddrval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetBltStatus");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( dwFlags & ~DDGBS_VALID )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwFlags )
	{
	    if( (dwFlags & (DDGBS_CANBLT|DDGBS_ISBLTDONE)) ==
		    (DDGBS_CANBLT|DDGBS_ISBLTDONE) )
	    {
		DPF_ERR( "Invalid flags" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    DPF_ERR( "Invalid flags - no flag specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	this = this_lcl->lpGbl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	#ifdef USE_ALIAS
	    if( pdrv->dwBusyDueToAliasedLock > 0 )
	    {
		/*
		 * Aliased locks (the ones that don't take the Win16 lock) don't
		 * set the busy bit either (it can't or USER get's very confused).
		 * However, we must prevent blits happening via DirectDraw as
		 * otherwise we get into the old host talking to VRAM while
		 * blitter does at the same time. Bad. So fail if there is an
		 * outstanding aliased lock just as if the BUST bit had been
		 * set.
		 */
		DPF_ERR( "Graphics adapter is busy (due to a DirectDraw lock)" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */

	/*
	 * device busy?
	 */
	if( *(pdrv->lpwPDeviceFlags) & BUSY )
	{
	    DPF( 0, "BUSY" );
	    LEAVE_DDRAW()
	    return DDERR_SURFACEBUSY;
	}

	// If DDCAPS_CANBLTSYSMEM is set, we have to let the driver tell us
	// whether a system memory surface is currently being blitted
	if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) &&
	    !( pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM ) )
	{
	    LEAVE_DDRAW()
	    return DD_OK;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    //
    // If the current surface is optimized, quit
    //
    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
        DPF_ERR( "It is an optimized surface" );
        LEAVE_DDRAW();
        return DDERR_ISOPTIMIZEDSURFACE;
    }

    ddrval = InternalGetBltStatus( pdrv_lcl, this_lcl, dwFlags );

    LEAVE_DDRAW();
    return ddrval;

} /* DD_Surface_GetBltStatus */

#if 0
/*
 * DD_Surface_Flush
 */
HRESULT DDAPI DD_Surface_Flush(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Flush");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_Flush */
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "Flip"

/*
 * FlipMipMapChain
 *
 * Flip a chain of mip-map surfaces.
 */
static HRESULT FlipMipMapChain( LPDIRECTDRAWSURFACE lpDDSurface,
			        LPDIRECTDRAWSURFACE lpDDSurfaceDest,
				DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_INT	next_int;
    LPDDRAWI_DDRAWSURFACE_LCL	next_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	next;
    LPDDRAWI_DDRAWSURFACE_INT	attached_int;
    FLATPTR			vidmem;
    LPVMEMHEAP			vidmemheap;
    ULONG_PTR			reserved;
    DWORD                       gdi_flag;
    ULONG_PTR                   handle;
    BOOL                        toplevel;
    int                         destindex;
    int                         thisindex;
    BOOL                        destfound;
    #ifdef USE_ALIAS
	FLATPTR                     aliasvidmem;
	FLATPTR                     aliasofvidmem;
    #endif /* USE_ALIAS */
    FLATPTR                     physicalvidmem;
    ULONG_PTR                   driverreserved;

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

	/*
	 * We validate each level of the mip-map before we do any
	 * flipping. This is in an effort to prevent half flipped
	 * surfaces.
	 */
	toplevel = TRUE;
	do
	{
	    /*
	     * At this point this_int points to the front buffer
	     * of a flippable chain of surface for this level of
	     * the mip-map.
	     */

	    /*
	     * Invalid source surface?
	     */
	    if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	    {
		DPF_ERR( "Invalid front buffer for flip" );
		return DDERR_INVALIDOBJECT;
	    }
	    this_lcl = this_int->lpLcl;
	    this = this_lcl->lpGbl;

	    /*
	     * Source surface lost?
	     */
	    if( SURFACE_LOST( this_lcl ) )
	    {
		DPF_ERR( "Can't flip - front buffer is lost" );
		return DDERR_SURFACELOST;
	    }

	    /*
	     * Source surface flippable?
	     */
	    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER) )
	    {
		DPF_ERR( "Can't flip - first surface is not a front buffer" );
		return DDERR_NOTFLIPPABLE;
	    }
	    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP) )
	    {
		DPF_ERR( "Surface is not flippable" );
		return DDERR_NOTFLIPPABLE;
	    }

	    /*
	     * Source surface locked?
	     */
	    if( this->dwUsageCount > 0 )
	    {
		DPF_ERR( "Can't flip - surface is locked" );
		return DDERR_SURFACEBUSY;
	    }

	    /*
	     * Validate destination surfaces of flip.
	     */
	    next_int = FindAttachedFlip( this_int );
	    if( next_int == NULL )
	    {
		DPF_ERR( "Can't flip - no surface to flip to" );
		return DDERR_NOTFLIPPABLE;
	    }

	    /*
	     * If this is the top level of the mip-map and a destination
	     * surface has been provided then we need to find out which
	     * buffer (by index) the supplied destination is so that we
	     * can flip to the matching buffers in the lower-level maps.
	     */
	    if( NULL != lpDDSurfaceDest )
	    {
		thisindex = 0;
		destfound = FALSE;
		if( toplevel )
		    destindex = -1;
	    }

	    do
	    {
		/*
		 * If a destination surface has been supplied then is this
		 * it?
		 */
		if( NULL != lpDDSurfaceDest )
		{
		    if( toplevel )
		    {
			/*
			 * As we may have multiple interfaces pointing to the same
			 * object we need to compare objects not interface pointers
			 */
			if( next_int->lpLcl == ( (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurfaceDest )->lpLcl )
			{
			    destindex = thisindex;
			    destfound = TRUE;
			}
		    }
		    else
		    {
			if( thisindex == destindex )
			{
			    destfound = TRUE;
			}
		    }
		}

		/*
		 * Invalid destination surface?
		 */
		if( !VALID_DIRECTDRAWSURFACE_PTR( next_int ) )
		{
		    DPF_ERR( "Can't flip - invalid back buffer" );
		    return DDERR_INVALIDOBJECT;
		}
		next_lcl = next_int->lpLcl;
		next = next_lcl->lpGbl;

		/*
		 * Destination surface lost?
		 */
		if( SURFACE_LOST( next_lcl ) )
		{
		    DPF_ERR( "Can't flip - back buffer is lost" );
		    return DDERR_SURFACELOST;
		}

		/*
		 * Destination surface locked?
		 */
		if( next->dwUsageCount > 0 )
		{
		    DPF_ERR( "Can't flip - back buffer is locked" );
		    return DDERR_SURFACEBUSY;
		}

		/*
		 * Ensure that both source and destination surfaces reside
		 * in the same kind of memory.
		 */
		if( ( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) &&
		      ( next_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY  ) ) ||
		    ( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY  ) &&
		      ( next_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) ) )
		{
		    DPF_ERR( "Can't flip between system/video memory surfaces" );
		    return DDERR_INVALIDPARAMS;
		}

		/*
		 * Next destination surface.
		 */
		next_int = FindAttachedFlip( next_int );
		thisindex++;

	    } while( next_int->lpLcl != this_int->lpLcl );

	    /*
	     * If a destination was supplied did we find it?
	     */
	    if( ( NULL != lpDDSurfaceDest ) && !destfound )
	    {
		/*
		 * Could not find the destination.
		 */
		DPF_ERR( "Can't flip - destination surface not found in flippable chain" );
		return DDERR_NOTFLIPPABLE;
	    }
	    DDASSERT( destindex != -1 );

	    /*
	     * Next mip-map level.
	     */
	    this_int = FindAttachedMipMap( this_int );
	    toplevel = FALSE;

	} while( this_int != NULL );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Now actually flip each level of the mip-map.
     */
    this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
    do
    {
	/*
	 * Process one level of the mip-map.
	 */

	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	/*
	 * Find the first destination surface of the flip.
	 */
	next_int = FindAttachedFlip( this_int );
	if( NULL != lpDDSurfaceDest )
	{
	    /*
	     * If an override destination has been provided find the
	     * appropriate back destination surface.
	     */
	    for( thisindex = 0; thisindex < destindex; thisindex++ )
		next_int = FindAttachedFlip( next_int );
	}

	DDASSERT( NULL != next_int );
	next_lcl = next_int->lpLcl;

	/*
	 * save the old values
	 */
	vidmem = next_lcl->lpGbl->fpVidMem;
	#ifdef USE_ALIAS
	    aliasvidmem = GBLMORE(next_lcl->lpGbl)->fpAliasedVidMem;
	    aliasofvidmem = GBLMORE(next_lcl->lpGbl)->fpAliasOfVidMem;
	#endif /* USE_ALIAS */
	physicalvidmem = GBLMORE(next_lcl->lpGbl)->fpPhysicalVidMem;
	driverreserved = GBLMORE(next_lcl->lpGbl)->dwDriverReserved;
	vidmemheap = next_lcl->lpGbl->lpVidMemHeap;
	reserved = next_lcl->lpGbl->dwReserved1;
	gdi_flag = next_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
	handle = next_lcl->hDDSurface;

	/*
	 * If a destination override was provided then find that destination surface
	 * and flip to it explicitly.
	 */
	if( NULL != lpDDSurfaceDest )
	{
	    next_lcl->lpGbl->lpVidMemHeap = this->lpVidMemHeap;
	    next_lcl->lpGbl->fpVidMem = this->fpVidMem;
	    #ifdef USE_ALIAS
		GBLMORE(next_lcl->lpGbl)->fpAliasedVidMem = GBLMORE(this)->fpAliasedVidMem;
		GBLMORE(next_lcl->lpGbl)->fpAliasOfVidMem = GBLMORE(this)->fpAliasOfVidMem;
	    #endif /* USE_ALIAS */
	    GBLMORE(next_lcl->lpGbl)->fpPhysicalVidMem = GBLMORE(this)->fpPhysicalVidMem;
	    GBLMORE(next_lcl->lpGbl)->dwDriverReserved = GBLMORE(this)->dwDriverReserved;
	    next_lcl->lpGbl->dwReserved1 = this->dwReserved1;
	    next_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
	    next_lcl->lpGbl->dwGlobalFlags |= this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
	    next_lcl->hDDSurface = this_lcl->hDDSurface;
	}
	else
	{
	    do
	    {
		/*
		 * Remaining buffers in the chain (including copying the source surface's
		 * data.
		 */
		attached_int = FindAttachedFlip( next_int );
		next_lcl->lpGbl->fpVidMem = attached_int->lpLcl->lpGbl->fpVidMem;
		#ifdef USE_ALIAS
		    GBLMORE(next_lcl->lpGbl)->fpAliasedVidMem = GBLMORE(attached_int->lpLcl->lpGbl)->fpAliasedVidMem;
		    GBLMORE(next_lcl->lpGbl)->fpAliasOfVidMem = GBLMORE(attached_int->lpLcl->lpGbl)->fpAliasOfVidMem;
		#endif /* USE_ALIAS */
		GBLMORE(next_lcl->lpGbl)->fpPhysicalVidMem = GBLMORE(attached_int->lpLcl->lpGbl)->fpPhysicalVidMem;
		GBLMORE(next_lcl->lpGbl)->dwDriverReserved = GBLMORE(attached_int->lpLcl->lpGbl)->dwDriverReserved;
		next_lcl->lpGbl->lpVidMemHeap = attached_int->lpLcl->lpGbl->lpVidMemHeap;
		next_lcl->lpGbl->dwReserved1 = attached_int->lpLcl->lpGbl->dwReserved1;
		next_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
		next_lcl->lpGbl->dwGlobalFlags |= attached_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
		next_lcl->hDDSurface = attached_int->lpLcl->hDDSurface;
		next_int = attached_int;
		next_lcl = next_int->lpLcl;

		/*
		 * NOTE: We must compare objects not interfaces (there may be many
		 * different interfaces pointing to the same objects) to prevent a
		 * infinite loop.
		 */
	    } while( next_int->lpLcl != this_int->lpLcl );
	}

	this->fpVidMem = vidmem;
	#ifdef USE_ALIAS
	    GBLMORE(this)->fpAliasedVidMem = aliasvidmem;
	    GBLMORE(this)->fpAliasOfVidMem = aliasofvidmem;
	#endif /* USE_ALIAS */
	GBLMORE(this)->fpPhysicalVidMem = physicalvidmem;
	GBLMORE(this)->dwDriverReserved = driverreserved;
	this->lpVidMemHeap = vidmemheap;
	this->dwReserved1 = reserved;
	this->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
	this->dwGlobalFlags |= gdi_flag;
	this_lcl->hDDSurface = handle;

	/*
	 * Next level of the mip-map.
	 */
	this_int = FindAttachedMipMap( this_int );

    } while( this_int != NULL );

    return DD_OK;

} /* FlipMipMapChain */

DWORD dwLastFrameRate = 0;
/*
 * updateFrameRate
 */
static void updateFrameRate( void )
{
    static DWORD		dwFlipCnt;
    static DWORD		dwFlipTime=0xffffffff;

    /*
     * work out the frame rate if required...
     */

    if( dwFlipTime == 0xffffffff )
    {
	dwFlipTime = GetTickCount();
    }

    dwFlipCnt++;
    if( dwFlipCnt >= 120 )
    {
	DWORD	time2;
	DWORD	fps;
	char	buff[256];
	time2 = GetTickCount() - dwFlipTime;
	fps = (dwFlipCnt*10000)/time2;
	wsprintf( buff, "FPS = %ld.%01ld\r\n", fps/10, fps % 10 );
        dwLastFrameRate = fps;

	/*
	 * OINK32 whines about OutputDebugString, so hide it...
	 */
	{
	    HANDLE	h;
	    h = LoadLibrary( "KERNEL32.DLL" );
	    if( h != NULL )
	    {
	        VOID (WINAPI *lpOutputDebugStringA)(LPCSTR) = (LPVOID)
                    GetProcAddress( h, "OutputDebugStringA" );
	        if( lpOutputDebugStringA != NULL )
	        {
	            lpOutputDebugStringA( buff );
	        }
		FreeLibrary( h );
	    }
	}
	dwFlipTime = GetTickCount();
	dwFlipCnt = 0;
    }

} /* updateFrameRate */

/*
 * DD_Surface_Flip
 *
 * Page flip to the next surface.   Only valid for surfaces which are
 * flippable.
 */
#undef DPF_MODNAME
#define DPF_MODNAME	"Flip"
HRESULT DDAPI DD_Surface_Flip(
		LPDIRECTDRAWSURFACE lpDDSurface,
                LPDIRECTDRAWSURFACE lpDDSurfaceDest,
                DWORD               dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	this_dest_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_dest_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	next_int;
    LPDDRAWI_DDRAWSURFACE_LCL	next_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	next_save_int;
    LPDDRAWI_DDRAWSURFACE_INT	attached_int;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_GBL	this_dest;
    DWORD			rc;
    


    BOOL			found_dest;
    DDHAL_FLIPTOGDISURFACEDATA  ftgsd;
    LPDDHAL_FLIPTOGDISURFACE    ftgshalfn;
    LPDDHAL_FLIPTOGDISURFACE	ftgsfn;
    DDHAL_FLIPDATA		fd;
    LPDDHALSURFCB_FLIP		fhalfn;
    LPDDHALSURFCB_FLIP		ffn;
    BOOL			emulation;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    DWORD                       caps;
    DWORD                       caps2;
    DWORD			dwNumSkipped;
    DWORD			dwCnt;

    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
	BOOL			bStereo;

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_Flip");
    /* DPF_ENTERAPI(lpDDSurface); */
    // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF(3,A,"   Dest surface: 0x%p, flags: 0x%08x", lpDDSurfaceDest, dwFlags);

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_BOTH();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	this_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurfaceDest;
	if( this_dest_int != NULL )
	{
	    if( !VALID_DIRECTDRAWSURFACE_PTR( this_dest_int ) )
	    {
		LEAVE_BOTH();
		return DDERR_INVALIDOBJECT;
	    }
	    this_dest_lcl = this_dest_int->lpLcl;
	    this_dest = this_dest_lcl->lpGbl;
	}
	else
	{
	    this_dest_lcl = NULL;
	    this_dest = NULL;
        }

        if( dwFlags & ~DDFLIP_VALID )
	    {
	        DPF_ERR( "Invalid flags") ;
	        LEAVE_BOTH();
	        return DDERR_INVALIDPARAMS;
	    }

        if (!LOWERTHANSURFACE7(this_int))
        {
            if (dwFlags & DDFLIP_DONOTWAIT)
            {
                dwFlags &= ~DDFLIP_WAIT;
            }
            else
            {
                dwFlags |= DDFLIP_WAIT;
            }
        }

	if( ( dwFlags & ( DDFLIP_EVEN | DDFLIP_ODD ) ) &&
	    !( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) )
	{
	    DPF_ERR( "Invalid flags") ;
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}

        if ( (dwFlags & DDFLIP_NOVSYNC) && (dwFlags & DDFLIP_INTERVALMASK) )
        {
            DPF_ERR( "Flip: DDFLIP_NOVSYNC and DDFLIP_INTERVALn are mutually exclusive") ;
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
        }

	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;
#ifdef WIN95
        if( !( pdrv_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_SCREENSAVER ) ||
            !( pdrv_lcl->dwLocalFlags & DDRAWILCL_POWEREDDOWN ) )
        {
#endif
            if( SURFACE_LOST( this_lcl ) )
            {
                LEAVE_BOTH();
                return DDERR_SURFACELOST;
            }
            if( this_dest != NULL )
            {
                if( SURFACE_LOST( this_dest_lcl ) )
                {
                    LEAVE_BOTH();
                    return DDERR_SURFACELOST;
                }
	    }
#ifdef WIN95
	}
#endif

	/*
	 * device busy?
	 */

	#ifdef USE_ALIAS
	    if( pdrv->dwBusyDueToAliasedLock > 0 )
	    {
		/*
		 * Aliased locks (the ones that don't take the Win16 lock) don't
		 * set the busy bit either (it can't or USER get's very confused).
		 * However, we must prevent blits happening via DirectDraw as
		 * otherwise we get into the old host talking to VRAM while
		 * blitter does at the same time. Bad. So fail if there is an
		 * outstanding aliased lock just as if the BUST bit had been
		 * set.
		 */
		DPF_ERR( "Graphics adapter is busy (due to a DirectDraw lock)" );
		LEAVE_BOTH();
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */

	if( *(pdrv->lpwPDeviceFlags) & BUSY )
	{
            DPF( 0, "BUSY - Flip" );
	    LEAVE_BOTH()
	    return DDERR_SURFACEBUSY;
	}

	/*
	 * make sure that it's OK to flip this surface
	 */

    // DX7Stereo
    if(dwFlags & DDFLIP_STEREO)
	{
        if (!(this_lcl->dwFlags & DDRAWISURF_STEREOSURFACELEFT))
        {
	        DPF_ERR( "Invalid DDFLIP_STEREO flag on non stereo flipping chain") ;
	        LEAVE_BOTH();
	        return DDERR_INVALIDPARAMS;
        } 
	}

	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER) )
	{
            DPF_ERR("Can't flip because surface is not a front buffer");
	    LEAVE_BOTH();
	    return DDERR_NOTFLIPPABLE;		// ACKACK: real error??
	}
	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP) )
	{
            DPF_ERR("Can't flip because surface is not a DDSCAPS_FLIP surface");
	    LEAVE_BOTH();
	    return DDERR_NOTFLIPPABLE;		// ACKACK: real error??
	}
	if( this->dwUsageCount > 0 )
        {
            DPF_ERR( "Can't flip because surface is locked" );
            LEAVE_BOTH();
            return DDERR_SURFACEBUSY;
	}
        if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) &&
            (pdrv->lpExclusiveOwner != pdrv_lcl ) )
	{
	    DPF_ERR( "Can't flip without exclusive access." );
	    LEAVE_BOTH();
	    return DDERR_NOEXCLUSIVEMODE;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_BOTH();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Mip-map chain? In which case take special action.
     */
    if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) &&
        (0==(this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)) )
    {
	rc = FlipMipMapChain( lpDDSurface, lpDDSurfaceDest, dwFlags );
	LEAVE_BOTH();
	return rc;
    }

    /*
     * If this is the primary and the driver had previously flipped
     * to display the GDI surface then we are now flipping away from
     * the GDI surface so we need to let the driver know.
     */
    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) &&
	( pdrv->dwFlags & DDRAWI_FLIPPEDTOGDI ) )
    {
	/*
	 * Notify the driver that we are about to flip away from the
	 * GDI surface.
	 *
	 * NOTE: This is a HAL only call - it means nothing to
	 * the HEL.
	 *
	 * NOTE: If the driver handles this call then we do not
	 * attempt to do the actual flip. This is to support cards
	 * which do not have GDI surfaces. If the driver does not
	 * handle the call we will continue on and do the flip.
	 */
	ftgsfn    = pdrv_lcl->lpDDCB->HALDD.FlipToGDISurface;
	ftgshalfn = pdrv_lcl->lpDDCB->cbDDCallbacks.FlipToGDISurface;
	if( NULL != ftgshalfn )
	{
	    ftgsd.FlipToGDISurface = ftgshalfn;
	    ftgsd.lpDD             = pdrv;
	    ftgsd.dwToGDI          = FALSE;
	    ftgsd.dwReserved       = 0UL;
	    DOHALCALL( FlipToGDISurface, ftgsfn, ftgsd, rc, FALSE );
	    if( DDHAL_DRIVER_HANDLED == rc )
	    {
		if( !FAILED( ftgsd.ddRVal ) )
		{
		    /*
		     * Driver is no longer flipped to the GDI surface.
		     */
		    pdrv->dwFlags &= ~DDRAWI_FLIPPEDTOGDI;
		    DPF( 4, "Driver handled the flip away from the GDI surface" );
		    LEAVE_BOTH();
		    return ftgsd.ddRVal;
		}
		else
		{
		    DPF_ERR( "Driver failed the flip away from the GDI surface" );
		    LEAVE_BOTH();
		    return ftgsd.ddRVal;
		}
	    }
	}
    }

    /*
     * make sure no surfaces are in use
     */
    found_dest = FALSE;
    if( ( lpDDSurface == lpDDSurfaceDest ) &&
        ( dwFlags & (DDFLIP_EVEN | DDFLIP_ODD) ) )
    {
        next_save_int = next_int = this_int;
        dwCnt = dwNumSkipped = 0;
    }
    else
    {
        next_save_int = next_int = FindAttachedFlip( this_int );
        dwCnt = dwNumSkipped = 1;
    }
    if( next_int == NULL )
    {
        DPF_ERR("Can't flip: No attached flippable surface");
	LEAVE_BOTH();
	return DDERR_NOTFLIPPABLE;		// ACKACK: real error?
    }

    do
    {
	if( SURFACE_LOST( next_int->lpLcl ) )
	{
	    DPF_ERR( "Can't flip - back buffer is lost" );
	    LEAVE_BOTH();
	    return DDERR_SURFACELOST;
	}

	if( next_int->lpLcl->lpGbl->dwUsageCount != 0 )
	{
            /*
             * Previously we didn't allow Flips to suceed if any of the surfaces
             * are lost, but DShow really wants to be able to do this so now we'll
             * allow it as long as we aren't going to rotate the memory pointers, etc.
             * for the locked surface.
             */
            if( ( this_dest_lcl == NULL ) ||
                ( this_dest_lcl == next_int->lpLcl ) ||
                ( this_lcl == next_int->lpLcl ) )
            {
	        LEAVE_BOTH();
                return DDERR_SURFACEBUSY;
            }
	}

	/*
	 * Do not allow flipping if any of the surfaces are used in kernel
	 * mode because we don't want the pointers to rotate.
	 */
    	lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( next_int->lpLcl->lpGbl );
    	if( lpSurfGblMore->hKernelSurface != 0 )
	{
	    DPF_ERR( "Can't flip - kernel mode is using surface" );
	    LEAVE_BOTH();
            return DDERR_SURFACEBUSY;
	}

	/*
	 * NOTE: Do NOT compare interface pointers here as we may
	 * well have multiple interfaces to the same surface object (i.e.,
	 * V1, V2, V3 etc.). Compare against the LOCAL object. This is the
	 * real object being handled.
	 */
	if( ( NULL != this_dest_int ) && ( this_dest_int->lpLcl == next_int->lpLcl ) )
	{
	    dwNumSkipped = dwCnt;
	    found_dest = TRUE;
	}
	dwCnt++;
	next_int = FindAttachedFlip( next_int );
    } while( next_int->lpLcl != this_int->lpLcl );

    /*
     * see if we can use the specified destination
     */
    if( this_dest_int != NULL )
    {
	if( !found_dest )
	{
	    DPF_ERR( "Destination not part of flipping chain!" );
	    LEAVE_BOTH();
	    return DDERR_NOTFLIPPABLE;		// ACKACK: real error?
	}
	next_save_int = this_dest_int;
    }

    /*
     * found the linked surface we want to flip to
     */
    next_int = next_save_int;

    /*
     * don't allow two destinations to be different (in case of a mixed chain)
     */
    next_lcl = next_int->lpLcl;
    if( ((next_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
         (this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) ||
    	((next_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
         (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)) )
    {
	DPF_ERR( "Can't flip between video/system memory surfaces" );
	LEAVE_BOTH();
	return DDERR_INVALIDPARAMS;
    }

//    DPF(9," flip (%d) Source Kernel handle is %08x, dest is %08x",__LINE__,this_lcl->hDDSurface,next_lcl->hDDSurface);
//    DPF(9," flip source vidmem is %08x, dest is %08x",this->fpVidMem,next_lcl->lpGbl->fpVidMem);
    /*
     * is this an emulation surface or driver surface?
     */
    if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
    {
	ffn = pdrv_lcl->lpDDCB->HELDDSurface.Flip;
    	fhalfn = ffn;
	emulation = TRUE;
	caps = pdrv->ddHELCaps.dwCaps;
	caps2 = pdrv->ddHELCaps.dwCaps2;
    }
    else
    {
	ffn = pdrv_lcl->lpDDCB->HALDDSurface.Flip;
    	fhalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.Flip;
	emulation = FALSE;
	caps = pdrv->ddCaps.dwCaps;
	caps2 = pdrv->ddCaps.dwCaps2;
    }

    /*
     * If the surface is fed by a video port, also flip the video port
     */
    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) && dwNumSkipped )
    {
	rc = FlipVideoPortSurface( this_int, dwNumSkipped );
	if( rc != DD_OK )
	{
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}
    }

#ifdef WINNT
    /*
     * If ~ 50 seconds have passed (assuming a 10Hz flip rate)
     * and this is a primary surface, then make a magic call to 
     * disable screen savers.
     * This isn't needed on 9x since we make a SPI call on that OS
     * to disable screen savers.
     * We don't do this if the app is itself a screen-saver, since
     * that would also disable the power-down.
     */
    if( !( pdrv_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_SCREENSAVER ))
    {
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
        {
            static DWORD dwMagicTime = 0;
            dwMagicTime++;
            if (dwMagicTime > (50*10) )
            {
                DWORD dw=60*15;
                dwMagicTime = 0;
                SystemParametersInfo(SPI_GETSCREENSAVETIMEOUT,0,&dw,0);
                SystemParametersInfo(SPI_SETSCREENSAVETIMEOUT,dw,0,0);
            }
        }
    }
#endif

    /*
     * Driver should be told its cache is invalid if the surface was flipped
     */
    BUMP_SURFACE_STAMP(this);
    BUMP_SURFACE_STAMP(next_lcl->lpGbl);

    /*
     * ask the driver to flip to the new surface if we are flipping
     * a primary surface (or if we are flipping an overlay surface and
     * the driver supports overlays.)
     */
    
    bStereo = (BOOL) (this_lcl->dwFlags & DDRAWISURF_STEREOSURFACELEFT);

    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) ||
        ( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) &&
	  ( caps & DDCAPS_OVERLAY ) &&
	  ( this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE ) ) )
    {
	if( fhalfn != NULL )
	{
    	    fd.Flip = fhalfn;
	    fd.lpDD = pdrv;
            fd.dwFlags = (dwFlags & ~DDFLIP_WAIT);
	    fd.lpSurfCurr = this_lcl;
	    fd.lpSurfTarg = next_lcl;

            // DX7Stereo
	    fd.lpSurfCurrLeft = NULL;
	    fd.lpSurfTargLeft = NULL;

            if (bStereo &&
                fd.dwFlags & DDFLIP_STEREO )
            {
                LPDDRAWI_DDRAWSURFACE_INT temp_this_int;
                LPDDRAWI_DDRAWSURFACE_INT temp_next_int;
                temp_this_int = FindAttachedSurfaceLeft(this_int);
                temp_next_int = FindAttachedSurfaceLeft(next_int);
                // oops, error
                if (temp_this_int!=NULL && temp_next_int!=NULL)
                {
                    fd.lpSurfCurrLeft = temp_this_int->lpLcl;
                    fd.lpSurfTargLeft = temp_next_int->lpLcl;

                }

                if (fd.lpSurfCurrLeft==NULL || fd.lpSurfTargLeft==NULL)
                {
                    fd.lpSurfCurrLeft = NULL;
                    fd.lpSurfTargLeft = NULL;

                    fd.dwFlags &= ~DDFLIP_STEREO;
                }

            }
            if (DDRAW_REGFLAGS_FLIPNONVSYNC & dwRegFlags)
            {
                fd.dwFlags &= ~DDFLIP_INTERVALMASK;
                fd.dwFlags |= DDFLIP_NOVSYNC;
            }
            if (caps2 & DDCAPS2_FLIPINTERVAL)
            {
                //if the user didn't specify a flip interval, give the driver 'one'
                //Also, make the interval consistent with FLIPNOVSYNC: if FLIPNOVSYNC is set,
                //then we should keep the interval set to 0.
                if ( ((fd.dwFlags & DDFLIP_INTERVALMASK) == 0) && ((dwFlags & DDFLIP_NOVSYNC)==0) )
                {
                    fd.dwFlags |= DDFLIP_INTERVAL1;
                }
            }
            else
            {
                //don't let old drivers see the flip intervals
                fd.dwFlags &= ~DDFLIP_INTERVALMASK;
            }

            //don't let old drivers see novsync
            if ( (caps2 & DDCAPS2_FLIPNOVSYNC) == 0 )
            {
                fd.dwFlags &= ~DDFLIP_NOVSYNC;
            }

try_again:
            DOHALCALL_NOWIN16( Flip, ffn, fd, rc, emulation );
	    if( rc == DDHAL_DRIVER_HANDLED )
            {
                if( fd.ddRVal != DD_OK )
                {
                    if( (dwFlags & DDFLIP_WAIT) && fd.ddRVal == DDERR_WASSTILLDRAWING )
                    {
                        DPF(4,"Waiting.....");
                        goto try_again;
                    }
		    LEAVE_BOTH();
		    return fd.ddRVal;
                }

                /*
                 * emulation, does not need the pointers rotated we are done
                 *
                 * NOTE we should do this with a special return code or
                 * even a rester cap, but for now this is as good as any.
                 */
                if( emulation )
                {
		    LEAVE_WIN16LOCK();
		    if( dwRegFlags & DDRAW_REGFLAGS_SHOWFRAMERATE )
		    {
			updateFrameRate();
		    }
		    LEAVE_DDRAW();
                    return DD_OK;
                }
	    }
	}
        else
        {
	    LEAVE_BOTH();
	    return DDERR_NOFLIPHW;
        }
    }

    /*
     * save the old values
     */

    if( dwNumSkipped )
    {
    	#ifdef USE_ALIAS
	FLATPTR                     aliasvidmem;
	FLATPTR                     aliasofvidmem;
	#endif /* USE_ALIAS */
	FLATPTR			    vidmem;
	LPVMEMHEAP		    vidmemheap;
	FLATPTR                     physicalvidmem;
	ULONG_PTR                   driverreserved;
	ULONG_PTR		reserved;
	DWORD                       gdi_flag;
	ULONG_PTR                   handle;
	// same stack for left surface if we rotate stereo buffers
        #ifdef USE_ALIAS
	FLATPTR                     leftaliasvidmem;
	FLATPTR                     leftaliasofvidmem;
	#endif /* USE_ALIAS */
	FLATPTR			    leftvidmem;
	LPVMEMHEAP			leftvidmemheap;
	FLATPTR                     leftphysicalvidmem;
	ULONG_PTR                   leftdriverreserved;
	DWORD                       leftgdi_flag;
	ULONG_PTR			leftreserved;
	ULONG_PTR                   lefthandle;

    DWORD                       dwSurfaceHandle;
    DWORD                       dwLeftSurfaceHandle;


	LPDDRAWI_DDRAWSURFACE_INT	next_left_int;
	LPDDRAWI_DDRAWSURFACE_LCL	next_left_lcl;



        DPF(4,"Flip:rotating pointers etc");
        vidmem = next_lcl->lpGbl->fpVidMem;
        #ifdef USE_ALIAS  
	    aliasvidmem = GBLMORE(next_lcl->lpGbl)->fpAliasedVidMem;
	    aliasofvidmem = GBLMORE(next_lcl->lpGbl)->fpAliasOfVidMem;
        #endif /* USE_ALIAS */
        physicalvidmem = GBLMORE(next_lcl->lpGbl)->fpPhysicalVidMem;
        driverreserved = GBLMORE(next_lcl->lpGbl)->dwDriverReserved;
        vidmemheap = next_lcl->lpGbl->lpVidMemHeap;
        reserved = next_lcl->lpGbl->dwReserved1;
        gdi_flag = next_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
        handle = next_lcl->hDDSurface;
        dwSurfaceHandle = next_lcl->lpSurfMore->dwSurfaceHandle;
	// DX7Stereo: save also left buffers
	if (bStereo)		
	{

		DPF(4,"Flip:rotating also stereo pointers etc");
		
		next_left_int = FindAttachedSurfaceLeft(next_int);
		if (next_left_int!=NULL)
		{
			next_left_lcl = next_left_int->lpLcl;
                        

                        leftvidmem = next_left_lcl->lpGbl->fpVidMem;
                        #ifdef USE_ALIAS
                        leftaliasvidmem = GBLMORE(next_left_lcl->lpGbl)->fpAliasedVidMem;
                        leftaliasofvidmem = GBLMORE(next_left_lcl->lpGbl)->fpAliasOfVidMem;
                        #endif /* USE_ALIAS */
                        leftphysicalvidmem = GBLMORE(next_left_lcl->lpGbl)->fpPhysicalVidMem;
                        leftdriverreserved = GBLMORE(next_left_lcl->lpGbl)->dwDriverReserved;
                        leftvidmemheap = next_left_lcl->lpGbl->lpVidMemHeap;
                        leftreserved = next_left_lcl->lpGbl->dwReserved1;
                        leftgdi_flag = next_left_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
                        lefthandle = next_left_lcl->hDDSurface;
                        dwLeftSurfaceHandle = next_left_lcl->lpSurfMore->dwSurfaceHandle;

		} else
		{
			DPF(0,"Flip:rotating stereo pointers failed, dest. left surfaces invalid");
			bStereo=FALSE;
		}
	}

        /*
         * set the new primary surface pointer
         */
        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
        {
	    pdrv->vmiData.fpPrimary = vidmem;
        }

        /*
         * rotate the memory pointers
         */
        if( this_dest_lcl != NULL )
        {
	    next_lcl->lpGbl->lpVidMemHeap = this->lpVidMemHeap;
	    next_lcl->lpGbl->fpVidMem = this->fpVidMem;
	    #ifdef USE_ALIAS
	        GBLMORE(next_lcl->lpGbl)->fpAliasedVidMem = GBLMORE(this)->fpAliasedVidMem;
	        GBLMORE(next_lcl->lpGbl)->fpAliasOfVidMem = GBLMORE(this)->fpAliasOfVidMem;
	    #endif /* USE_ALIAS */
	    GBLMORE(next_lcl->lpGbl)->fpPhysicalVidMem = GBLMORE(this)->fpPhysicalVidMem;
	    GBLMORE(next_lcl->lpGbl)->dwDriverReserved = GBLMORE(this)->dwDriverReserved;
	    next_lcl->lpGbl->dwReserved1 = this->dwReserved1;
            next_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
            next_lcl->lpGbl->dwGlobalFlags |= this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
            next_lcl->hDDSurface = this_lcl->hDDSurface;
            next_lcl->lpSurfMore->dwSurfaceHandle = this_lcl->lpSurfMore->dwSurfaceHandle;

            if (this_lcl->lpSurfMore->dwSurfaceHandle)
            {
                // Since the SurfaceHandle was updated, update the mapping array
                SURFACEHANDLELIST(pdrv_lcl).dwList[this_lcl->lpSurfMore->dwSurfaceHandle].lpSurface = next_lcl;
            }
            if (bStereo)
            {
        	LPDDRAWI_DDRAWSURFACE_INT	this_left_int;
	        LPDDRAWI_DDRAWSURFACE_LCL	this_left_lcl;

                this_left_int = FindAttachedSurfaceLeft(this_int);
                this_left_lcl = this_left_int->lpLcl;

	        next_left_lcl->lpGbl->lpVidMemHeap = this_left_lcl->lpGbl->lpVidMemHeap;
	        next_left_lcl->lpGbl->fpVidMem = this_left_lcl->lpGbl->fpVidMem;
	        #ifdef USE_ALIAS
	        GBLMORE(next_left_lcl->lpGbl)->fpAliasedVidMem = GBLMORE(this_left_lcl->lpGbl)->fpAliasedVidMem;
	        GBLMORE(next_left_lcl->lpGbl)->fpAliasOfVidMem = GBLMORE(this_left_lcl->lpGbl)->fpAliasOfVidMem;
	        #endif /* USE_ALIAS */
	        GBLMORE(next_left_lcl->lpGbl)->fpPhysicalVidMem = GBLMORE(this_left_lcl->lpGbl)->fpPhysicalVidMem;
	        GBLMORE(next_left_lcl->lpGbl)->dwDriverReserved = GBLMORE(this_left_lcl->lpGbl)->dwDriverReserved;
                next_left_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
                next_left_lcl->lpGbl->dwGlobalFlags |= this_left_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
	        next_left_lcl->lpGbl->dwReserved1 = this_left_lcl->lpGbl->dwReserved1;
                next_left_lcl->hDDSurface = this_left_lcl->hDDSurface;                    
                next_left_lcl->lpSurfMore->dwSurfaceHandle = this_left_lcl->lpSurfMore->dwSurfaceHandle;
                if (this_left_lcl->lpSurfMore->dwSurfaceHandle)
                {
                    // Since the SurfaceHandle was updated, update the mapping array
                    SURFACEHANDLELIST(pdrv_lcl).dwList[this_left_lcl->lpSurfMore->dwSurfaceHandle].lpSurface = next_left_lcl;
                }
            }

        }
        else
        {
	    do
	    {
	        attached_int = FindAttachedFlip( next_int );
	        next_lcl = next_int->lpLcl;
	        next_lcl->lpGbl->lpVidMemHeap = attached_int->lpLcl->lpGbl->lpVidMemHeap;
	        next_lcl->lpGbl->fpVidMem = attached_int->lpLcl->lpGbl->fpVidMem;
	        #ifdef USE_ALIAS
		    GBLMORE(next_lcl->lpGbl)->fpAliasedVidMem = GBLMORE(attached_int->lpLcl->lpGbl)->fpAliasedVidMem;
		    GBLMORE(next_lcl->lpGbl)->fpAliasOfVidMem = GBLMORE(attached_int->lpLcl->lpGbl)->fpAliasOfVidMem;
	        #endif /* USE_ALIAS */
	        GBLMORE(next_lcl->lpGbl)->fpPhysicalVidMem = GBLMORE(attached_int->lpLcl->lpGbl)->fpPhysicalVidMem;
	        GBLMORE(next_lcl->lpGbl)->dwDriverReserved = GBLMORE(attached_int->lpLcl->lpGbl)->dwDriverReserved;
	        next_lcl->lpGbl->dwReserved1 = attached_int->lpLcl->lpGbl->dwReserved1;
                next_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
                next_lcl->lpGbl->dwGlobalFlags |= attached_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
                next_lcl->hDDSurface = attached_int->lpLcl->hDDSurface;
                next_lcl->lpSurfMore->dwSurfaceHandle = attached_int->lpLcl->lpSurfMore->dwSurfaceHandle;
                if (attached_int->lpLcl->lpSurfMore->dwSurfaceHandle)
                {
                    // Since the SurfaceHandle was updated, update the mapping array
                    SURFACEHANDLELIST(pdrv_lcl).dwList[attached_int->lpLcl->lpSurfMore->dwSurfaceHandle].lpSurface = next_lcl;
                }
                if (bStereo)
                {
             	        LPDDRAWI_DDRAWSURFACE_INT	attached_left_int;
	                LPDDRAWI_DDRAWSURFACE_LCL	attached_left_lcl;

                        attached_left_int = FindAttachedSurfaceLeft(attached_int);
                        next_left_int = FindAttachedSurfaceLeft(next_int);
                        if (attached_left_int!=NULL && next_left_int!=NULL)
                        {
                                attached_left_lcl=attached_left_int->lpLcl;
                                next_left_lcl=next_left_int->lpLcl;

	                        next_left_lcl->lpGbl->lpVidMemHeap = attached_left_int->lpLcl->lpGbl->lpVidMemHeap;
	                        next_left_lcl->lpGbl->fpVidMem = attached_left_int->lpLcl->lpGbl->fpVidMem;
	                        #ifdef USE_ALIAS
		                GBLMORE(next_left_lcl->lpGbl)->fpAliasedVidMem = GBLMORE(attached_left_int->lpLcl->lpGbl)->fpAliasedVidMem;
		                GBLMORE(next_left_lcl->lpGbl)->fpAliasOfVidMem = GBLMORE(attached_left_int->lpLcl->lpGbl)->fpAliasOfVidMem;
	                        #endif /* USE_ALIAS */
	                        GBLMORE(next_left_lcl->lpGbl)->fpPhysicalVidMem = GBLMORE(attached_left_int->lpLcl->lpGbl)->fpPhysicalVidMem;
	                        GBLMORE(next_left_lcl->lpGbl)->dwDriverReserved = GBLMORE(attached_left_int->lpLcl->lpGbl)->dwDriverReserved;
	                        next_left_lcl->lpGbl->dwReserved1 = attached_left_int->lpLcl->lpGbl->dwReserved1;
                                next_left_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
                                next_left_lcl->lpGbl->dwGlobalFlags |= attached_left_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
                                next_left_lcl->hDDSurface = attached_left_int->lpLcl->hDDSurface;
                                next_left_lcl->lpSurfMore->dwSurfaceHandle = attached_left_int->lpLcl->lpSurfMore->dwSurfaceHandle;
                                if (attached_left_int->lpLcl->lpSurfMore->dwSurfaceHandle)
                                {
                                    // Since the SurfaceHandle was updated, update the mapping array
                                    SURFACEHANDLELIST(pdrv_lcl).dwList[attached_left_int->lpLcl->lpSurfMore->dwSurfaceHandle].lpSurface = 
                                        next_left_lcl;
                                }
                        } else
                        {
                                DPF(0,"Flip:left surface pointers corrupted");
                                bStereo=FALSE;
                        }
                }

	        next_int = attached_int;
	        /*
	         * NOTE: Again, do NOT compare against interface pointers. We may
	         * have multiple interfaces to a single surface object leading to
	         * an infinite loop. Compare against the LOCAL object not the
	         * interface pointers.
	         */
	    } while( next_int->lpLcl != this_int->lpLcl );
        }
        this->fpVidMem = vidmem;
        #ifdef USE_ALIAS
	    GBLMORE(this)->fpAliasedVidMem = aliasvidmem;
	    GBLMORE(this)->fpAliasOfVidMem = aliasofvidmem;
        #endif /* USE_ALIAS */
        GBLMORE(this)->fpPhysicalVidMem = physicalvidmem;
        GBLMORE(this)->dwDriverReserved = driverreserved;
        this->lpVidMemHeap = vidmemheap;
        this->dwReserved1 = reserved;
        this->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
        this->dwGlobalFlags |= gdi_flag;
        this_lcl->hDDSurface = handle;
        this_lcl->lpSurfMore->dwSurfaceHandle=dwSurfaceHandle;

        if (dwSurfaceHandle)
        {
            // Since the SurfaceHandle was updated, update the mapping array
            SURFACEHANDLELIST(pdrv_lcl).dwList[dwSurfaceHandle].lpSurface = this_lcl;
        }
        if (bStereo)
        {
              	LPDDRAWI_DDRAWSURFACE_INT	this_left_int;
	        LPDDRAWI_DDRAWSURFACE_LCL	this_left_lcl;

                this_left_int = FindAttachedSurfaceLeft(this_int);
                if (this_left_int!=NULL)
                {
                        this_left_lcl = this_left_int->lpLcl;
                
                        this_left_lcl->lpGbl->fpVidMem = leftvidmem;
                        #ifdef USE_ALIAS
	                GBLMORE(this_left_lcl->lpGbl)->fpAliasedVidMem = leftaliasvidmem;
	                GBLMORE(this_left_lcl->lpGbl)->fpAliasOfVidMem = leftaliasofvidmem;
                        #endif /* USE_ALIAS */
                        GBLMORE(this_left_lcl->lpGbl)->fpPhysicalVidMem = leftphysicalvidmem;
                        GBLMORE(this_left_lcl->lpGbl)->dwDriverReserved = leftdriverreserved;
                        this_left_lcl->lpGbl->lpVidMemHeap = leftvidmemheap;
                        this_left_lcl->lpGbl->dwReserved1 = leftreserved;
                        this_left_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
                        this_left_lcl->lpGbl->dwGlobalFlags |= leftgdi_flag;
                        this_left_lcl->hDDSurface = lefthandle;
                        this_left_lcl->lpSurfMore->dwSurfaceHandle=dwLeftSurfaceHandle;
                        if (dwLeftSurfaceHandle)
                        {
                            // Since the SurfaceHandle was updated, update the mapping array
                            SURFACEHANDLELIST(pdrv_lcl).dwList[dwLeftSurfaceHandle].lpSurface = this_left_lcl;
                        }
                }
        }        
    }
    if ((GetCurrentProcessId() == GETCURRPID()) &&
        (pdrv_lcl->pSurfaceFlipNotify))
    {
        DDASSERT(pdrv_lcl->pD3DIUnknown != NULL);
        pdrv_lcl->pSurfaceFlipNotify(pdrv_lcl->pD3DIUnknown);
    }

    /*
     * If the driver was flipped to the GDI surface and we just flipped the
     * primary chain then we are no longer showing the GDI surface.
     */
    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) &&
	( pdrv->dwFlags & DDRAWI_FLIPPEDTOGDI ) )
    {
	pdrv->dwFlags &= ~DDRAWI_FLIPPEDTOGDI;
    }

    LEAVE_WIN16LOCK();
    if( dwRegFlags & DDRAW_REGFLAGS_SHOWFRAMERATE )
    {
	updateFrameRate();
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_Flip */

#undef DPF_MODNAME
#define DPF_MODNAME "GetPixelFormat"

/*
 * DD_Surface_GetPixelFormat
 */
HRESULT DDAPI DD_Surface_GetPixelFormat(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDDPIXELFORMAT lpDDPixelFormat )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDPIXELFORMAT		pddpf;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetPixelFormat");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_DDPIXELFORMAT_PTR( lpDDPixelFormat ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        /*
         * Execute buffers don't have a pixel format.
         */
        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            DPF_ERR( "Invalid surface type: can't get pixel format" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }
	this = this_lcl->lpGbl;
	GET_PIXEL_FORMAT( this_lcl, this, pddpf );
	*lpDDPixelFormat = *pddpf;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetPixelFormat */

#if 0
/* GEE: removed this, obsolete */
/*
 * DD_Surface_SetCompression
 */
HRESULT DDAPI DD_Surface_SetCompression(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDDPIXELFORMAT lpDDPixelFormat )
{
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetCompression");

    TRY
    {
	this_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	if( !VALID_DDPIXELFORMAT_PTR( lpDDPixelFormat ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_Surface_SetCompression */
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "GetSurfaceDesc"

/*
 * DD_Surface_GetSurfaceDesc
 */
HRESULT DDAPI DD_Surface_GetSurfaceDesc(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDDSURFACEDESC lpDDSurfaceDesc )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetSurfaceDesc");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_DDSURFACEDESC_PTR( lpDDSurfaceDesc ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;

	FillDDSurfaceDesc( this_lcl, lpDDSurfaceDesc );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetSurfaceDesc */

/*
 * DD_Surface_GetSurfaceDesc4
 */
HRESULT DDAPI DD_Surface_GetSurfaceDesc4(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDDSURFACEDESC2 lpDDSurfaceDesc )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetSurfaceDesc4");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
            DPF_ERR("Bad IDirectDrawSurfaceX pointer");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_DDSURFACEDESC2_PTR( lpDDSurfaceDesc ) )
	{
            DPF_ERR("Bad DDSURFACEDESC pointer");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;

	FillDDSurfaceDesc2( this_lcl, lpDDSurfaceDesc );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetSurfaceDesc4 */


#ifdef WIN95

#undef DPF_MODNAME
#define DPF_MODNAME "InternalGetDC"

/*
 * BIsValidDCFormat
 *
 * We should only try to get a DC on a format that GDI undersatnds
 */
BOOL bIsValidDCFormat( LPDDPIXELFORMAT lpPf )
{
    //
    // Must be an RGB format
    //
    if( !(lpPf->dwFlags & DDPF_RGB ) )
    {
        return FALSE;
    }

    //
    // Assume that 1, 4, and 8bpp surfaces are OK
    //
    if( ( lpPf->dwRGBBitCount == 8 ) ||
        ( lpPf->dwRGBBitCount == 4 ) ||
        ( lpPf->dwRGBBitCount == 1 ) )
    {
        return TRUE;
    }

    //
    // If it's 16bpp, it must be 5:5:5 or 5:6:5
    //
    if( lpPf->dwRGBBitCount == 16 )
    {
        if( ( lpPf->dwRBitMask == 0xf800 ) &&
            ( lpPf->dwGBitMask == 0x07e0 ) &&
            ( lpPf->dwBBitMask == 0x001f ) )
        {
            // 5:6:5
            return TRUE;
        }
        else if( ( lpPf->dwRBitMask == 0x7c00 ) &&
            ( lpPf->dwGBitMask == 0x03e0 ) &&
            ( lpPf->dwBBitMask == 0x001f ) )
        {
            // 5:5:5
            return TRUE;
        }
    }
    else if( ( lpPf->dwRGBBitCount == 24 ) ||
        ( lpPf->dwRGBBitCount == 32 ) )
    {
        if( ( lpPf->dwBBitMask == 0x0000FF ) &&
            ( lpPf->dwGBitMask == 0x00FF00 ) &&
            ( lpPf->dwRBitMask == 0xFF0000 ) )
        {
            // 8:8:8 
            return TRUE;
        }
    }

    return FALSE;
}


/*
 * InternalGetDC
 *
 * This is the Windows 95 version of this function. The code paths are so radically
 * different that we have broken this stuff out into two different functions.
 *
 * This functions assumes the DDRAW critical section is already held.
 *
 * This function will not return the OWNDC for an OWNDC surface. It always allocates
 * a new DC.
 */
HRESULT InternalGetDC( LPDDRAWI_DDRAWSURFACE_INT this_int, HDC FAR* lphdc, BOOL bWin16Lock)
{
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT			ddrval;
    HRESULT			tmprval;
    DDSURFACEDESC		ddsd;
    LPVOID			pbits;
    DWORD   dwLockFlags = bWin16Lock ? DDLOCK_TAKE_WIN16 : 0;
    DDASSERT( NULL != this_int );
    DDASSERT( NULL != lphdc );

    this_lcl = this_int->lpLcl;
    DDASSERT( NULL != this_lcl );

    this = this_lcl->lpGbl;
    DDASSERT( NULL != this );

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    DDASSERT( NULL != pdrv_lcl );

    pdrv = pdrv_lcl->lpGbl;
    DDASSERT( NULL != pdrv );

    *lphdc = NULL;

    /* Get a pointer to the bits of the surface */
    ddrval = InternalLock( this_lcl, &pbits, NULL , DDLOCK_WAIT | dwLockFlags );

    if( ddrval == DD_OK )
    {
        LPDDRAWI_DDRAWPALETTE_INT ppal;

	DPF( 4,"GetDC: Lock succeeded." );

        ddsd.dwSize = sizeof(ddsd);
        FillDDSurfaceDesc( this_lcl, &ddsd );
        ddsd.lpSurface = pbits;

        ppal = this_lcl->lpDDPalette;

        if( ( NULL != ppal ) && !( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
            *lphdc = DD16_GetDC( (HDC)pdrv_lcl->hDC, &ddsd, ppal->lpLcl->lpGbl->lpColorTable );
        else
            *lphdc = DD16_GetDC( (HDC)pdrv_lcl->hDC, &ddsd, NULL );

        if( NULL == *lphdc )
        {
	    tmprval = InternalUnlock( this_lcl, NULL, NULL, dwLockFlags );
	    DDASSERT( !FAILED(tmprval) );
            DPF_ERR( "Could not obtain DC" );
            ddrval = DDERR_CANTCREATEDC;
        }
        else
        {
	    ddrval = InternalAssociateDC( *lphdc, this_lcl );
	    if( FAILED( ddrval ) )
	    {
		DPF_ERR( "Could not associate DC" );
                DD16_ReleaseDC( *lphdc );
		tmprval = InternalUnlock( this_lcl, NULL, NULL, dwLockFlags );
		DDASSERT( !FAILED(tmprval) );
		*lphdc = NULL;
	    }
	    else
	    {
		this_lcl->dwFlags |= DDRAWISURF_HASDC;

		/*
		 * Currenlty OWNDC is only valid for EXPLICIT system
		 * memory surfaces so we don't need to hold the lock
		 * (cause the surface can't be lost).
		 *
		 * This is an OWNDC surface so we don't hold a lock
		 * for the duration. Unlock the surface now.
		 */
		if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC )
		{
		    tmprval = InternalUnlock( this_lcl, NULL, NULL, dwLockFlags );
		    DDASSERT( !FAILED(tmprval) );
		}
	    }
        }
    } //if InternalLock succeeded
    // We could not lock the primary surface.  This is because the
    // primary is already locked (and we should wait until it is
    // unlocked) or we have no ddraw support AND no DCI support in
    // the driver (in which case the HEL has created the primary
    // and we will NEVER be able to lock it. In this case, we are
    // on an emulated primary and the lock failed with
    // DDERR_GENERIC.
    else if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) &&
	     ( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )   &&
	     ( ddrval != DD_OK ) )
    {
	#ifdef GETDC_NULL
	    DPF( 4, "GetDC: Returning GetDC(NULL).");
	    *lphdc = GetDC( NULL );
	#else
	    DPF( 4, "GetDC: Returning device DC.");
	    DDASSERT( GetObjectType( (HDC)pdrv_lcl->hDC ) == OBJ_DC );
	    *lphdc = (HDC)pdrv_lcl->hDC;
	#endif

	if( NULL != *lphdc )
        {
	    ddrval = InternalAssociateDC( *lphdc, this_lcl );
	    if( FAILED( ddrval ) )
	    {
                DPF_ERR( "Could not associate DC" );
		#ifdef GETDC_NULL
		    ReleaseDC( NULL, *lphdc );
		#endif
		*lphdc = NULL;
	    }
	    else
	    {
		// signal to ourselves that we gave a DC without
		// locking.
		this_lcl->dwFlags |= ( DDRAWISURF_GETDCNULL | DDRAWISURF_HASDC );

		if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
		{
		    this->dwUsageCount++;
		    CHANGE_GLOBAL_CNT( pdrv, this, 1 );
		}
	    }
	}
	else
	{
            DPF_ERR( "Could not obtain DC" );
	    ddrval = DDERR_CANTCREATEDC;
	}
    }
    else
    {
        /*
         * InternalLock failed, and the surface wasn't an emulated primary
         */
        DPF_ERR( "Could not obtain DC" );
	ddrval = DDERR_CANTCREATEDC;
    }

    /*
     * If we managed to get a DC and we are an OWNDC surface then stash the HDC away
     * for future reference.
     */
    if( ( !FAILED(ddrval) ) && ( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
    {
	DDASSERT( NULL != *lphdc );
	DDASSERT( 0UL  == this_lcl->hDC );

	this_lcl->hDC = (DWORD)*lphdc;
    }

    return ddrval;
} /* InternalGetDC */

#undef DPF_MODNAME
#define DPF_MODNAME "InternalReleaseDC"

/*
 * InternalReleaseDC - Windows 95 version
 *
 * Assumes the DirectDraw critical section is already held
 */
HRESULT InternalReleaseDC( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, HDC hdc, BOOL bWin16Lock )
{
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT                     ddrval;

    #ifdef WINNT
       GdiFlush();
    #endif

    DDASSERT( NULL != this_lcl );
    DDASSERT( NULL != hdc );

    this = this_lcl->lpGbl;
    DDASSERT( NULL != this );

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    DDASSERT( NULL != pdrv_lcl );

    pdrv = pdrv_lcl->lpGbl;
    DDASSERT( NULL != pdrv );

    ddrval = DD_OK;

    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) &&
	( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )   &&
	( this_lcl->dwFlags & DDRAWISURF_GETDCNULL ) )
    {
	DPF( 4, "ReleaseDC: ReleaseDC(NULL)" );

	if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
	{
	    this->dwUsageCount--;
	    CHANGE_GLOBAL_CNT( pdrv, this, -1 );
	}
	#ifdef GETDC_NULL
	    /*
	     * Only actually free the HDC if we are running in the
	     * application's context and not DDHELP's (if we are
	     * running on DDHELP's the HDC is already gone)
	     */
	    if( GetCurrentProcessId() == GETCURRPID() )
		ReleaseDC( NULL, hdc );
	#endif
	this_lcl->dwFlags &= ~DDRAWISURF_GETDCNULL;
    }
    else
    {
	DPF( 4, "ReleaseDC: DD16_ReleaseDC()");

	/*
	 * Free the thing to give DDraw16 a chance
	 * to clean up what it's messed with. We can do this on
	 * the helper thread because DCs that are created by
	 * DD16_GetDC are 'alive' until DDRAW16 gets unloaded.
	 * However, they are dangerous because they point to data
	 * that might have been freed by the current app.
	 */
	DD16_ReleaseDC( hdc );

	/*
	 * Only unlock if its not an OWNDC surface as OWNDC surfaces
	 * don't hold the lock while the HDC is out.
	 */
	if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
	{
	    ddrval = InternalUnlock( this_lcl, NULL, NULL, bWin16Lock ? DDLOCK_TAKE_WIN16 : 0);
	    DDASSERT( !FAILED( ddrval ) );
	}
    }

    this_lcl->dwFlags &= ~DDRAWISURF_HASDC;

    // Remove this DC from our list
    InternalRemoveDCFromList( hdc, this_lcl );

    /*
     * If this is an OWNDC surface then remove it from the HDC cache
     * in the local object.
     */
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC )
	this_lcl->hDC = 0UL;

    return ddrval;
} /* InternalReleaseDC */

#else /* WIN95 */

#undef DPF_MODNAME
#define DPF_MODNAME "InternalGetDC"

/*
 * InternalGetDC - WinNT version
 *
 * This is the Windows NT version of this function. The code paths are so radically
 * different that we have broken this stuff out into two different functions.
 *
 * This functions assumes the DDRAW mutex is already held.
 *
 * This function will not return the OWNDC for an OWNDC surface. It always allocates
 * a new DC.
 */
HRESULT InternalGetDC( LPDDRAWI_DDRAWSURFACE_INT this_int, HDC FAR* lphDC )
{
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT                     ddrval;

    DDASSERT( NULL != this_int );
    DDASSERT( NULL != lphDC );

    this_lcl = this_int->lpLcl;
    DDASSERT( NULL != this_lcl );

    this = this_lcl->lpGbl;
    DDASSERT( NULL != this );

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    DDASSERT( NULL != pdrv_lcl );

    pdrv = pdrv_lcl->lpGbl;
    DDASSERT( NULL != pdrv );

    *lphDC = NULL;

    ddrval = DD_OK;
    FlushD3DStates(this_lcl);
#if COLLECTSTATS
    if(this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
        ++this_lcl->lpSurfMore->lpDD_lcl->dwNumTexGetDCs;
#endif

    if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) &&
        (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
    {
        #ifdef GETDC_NULL
            DPF( 4, "GetDC(NULL)" );
            *lphDC = GetDC( NULL );
        #else
            DPF( 4, "GetDC: Returning device DC." );
            DDASSERT( GetObjectType( (HDC)this_lcl->lpSurfMore->lpDD_lcl->hDC ) == OBJ_DC );
            if (this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRTYDC)
            {
                HDC hdc;

                /*
                 * We need to destroy and recreate the device DC because a ChangeDisplaySettings
                 * will have messed up the vis rgn associated with that DC. We need to create
                 * the new DC before we destroy the old one just in case the destroy caused an
                 * unload of the driver
                 */
                hdc = DD_CreateDC( this_lcl->lpSurfMore->lpDD_lcl->lpGbl->cDriverName );
                DeleteDC((HDC) this_lcl->lpSurfMore->lpDD_lcl->hDC);
                this_lcl->lpSurfMore->lpDD_lcl->hDC = (ULONG_PTR) hdc;

                if( this_lcl->lpDDPalette )
                {
                    SelectPalette(hdc, (HPALETTE) this_lcl->lpDDPalette->lpLcl->lpGbl->dwReserved1, FALSE);
                    RealizePalette(hdc);
                }
	        this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags &= ~DDRAWILCL_DIRTYDC;
            }
            *lphDC = (HDC)this_lcl->lpSurfMore->lpDD_lcl->hDC;
        #endif
    }
    else
    {
        LPDDRAWI_DDRAWPALETTE_INT ppal;

        DPF( 4, "DdGetDC" );

        ppal = this_lcl->lpDDPalette;
        if (this_lcl->hDDSurface || CompleteCreateSysmemSurface(this_lcl))
        {
            if( ( NULL != ppal ) && !( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
                *lphDC = DdGetDC( this_lcl, ppal->lpLcl->lpGbl->lpColorTable );
            else
                *lphDC = DdGetDC( this_lcl, NULL );
        }
    }

    if( NULL == *lphDC )
    {
        DPF_ERR( "Could not obtain DC" );
        ddrval = DDERR_CANTCREATEDC;
    }
    else
    {
        ddrval = InternalAssociateDC( *lphDC, this_lcl );
	if( FAILED( ddrval ) )
	{
            DPF_ERR( "Could not associate DC" );
            if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) &&
                (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
            {
	        #ifdef GETDC_NULL
		    ReleaseDC( NULL, *lphDC );
                #endif
            }
            else
            {
                DdReleaseDC( this_lcl );
            }

            *lphDC = NULL;
	}
	else
	{
            this_lcl->dwFlags |= DDRAWISURF_HASDC;

	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC )
	    {
		/*
		 * OWNDC surfaces don't hold a lock while the HDC is available.
		 */

		/*
		 * If this is an OWNDC surface then we need to stash the HDC
		 * away in the surface for future reference.
		 */
                DDASSERT( this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED );
                DDASSERT( 0UL == this_lcl->hDC );

                this_lcl->hDC = (ULONG_PTR) *lphDC;
            }
	    else
	    {
		/*
		 * On NT we don't lock the surface to take the HDC. However, we
		 * want the semantics on both NT and 95 (where the lock is taken)
		 * to be the same so we* bump the usage counts and hold the mutex.
		 */
		this->dwUsageCount++;
		CHANGE_GLOBAL_CNT( pdrv, this, 1 );
		ENTER_DDRAW();
	    }
	}
    }

    // Remove any cached RLE stuff for the surface
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
    {
        extern void FreeRleData(LPDDRAWI_DDRAWSURFACE_LCL psurf);
        FreeRleData( this_lcl );
    }

    if(IsD3DManaged(this_lcl))
    {
        /* Mark everything dirty */
        MarkDirty(this_lcl);
        this_lcl->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
    }
    return ddrval;
} /* InternalGetDC */

#undef DPF_MODNAME
#define DPF_MODNAME "InternalReleaseDC"

/*
 * InternalReleaseDC - Windows NT version
 *
 * Assumes the DirectDraw mutex is already held
 *
 * This function
 */
HRESULT InternalReleaseDC( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, HDC hdc )
{
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT                     ddrval;

    DDASSERT( NULL != this_lcl );
    DDASSERT( NULL != hdc );

    this = this_lcl->lpGbl;
    DDASSERT( NULL != this );

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    DDASSERT( NULL != pdrv_lcl );

    pdrv = pdrv_lcl->lpGbl;
    DDASSERT( NULL != pdrv );

    ddrval = DD_OK;
    /*
     * Since this function already marks the surface as not having a DC even if
     * a failure is encountered destroying the DC, we always reduce the surface's
     * usage count.
     * This usage count decrement is done because we didn't call InternalLock on the
     * GetDC, so we don't call InternalUnlock here, but we still mucked with the flags
     * to ensure that ddraw.dll didn't hand out a lock while someone had a DC.
     *
     * NOTE: If this is an OWNDC surface we never even spoofed the lock so don't unspoof
     * now.
     */
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC )
    {
        DDASSERT( this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED );
        DDASSERT( 0UL != this_lcl->hDC );

        this_lcl->hDC = 0UL;
    }
    else
    {
	/*
	 * Undo the pseudo-lock we took to make NT behave like '95.
	 * The LEAVE_DDRAW may appear strange but we know we already
	 * have another reference to the mutex when we call this function.
	 */
	this->dwUsageCount--;
	CHANGE_GLOBAL_CNT( pdrv, this, -1 );
	LEAVE_DDRAW();
    }

    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) &&
        ( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
    {
        #ifdef GETDC_NULL
            DPF( 4, "NT emulation releasing primary DC" );
            ReleaseDC( NULL, hdc );
        #endif
    }
    else
    {
	if( !DdReleaseDC( this_lcl ) )
	{
	    DPF( 0, "DDreleaseDC fails!" );
	    ddrval = DDERR_GENERIC;
	}
    }

    this_lcl->dwFlags &= ~DDRAWISURF_HASDC;

    // Remove this DC from our list
    InternalRemoveDCFromList( hdc, this_lcl );

    return ddrval;
}

#endif /* WIN95 */

#undef DPF_MODNAME
#define DPF_MODNAME "DD_Surface_GetDC"

/*
 * DD_Surface_GetDC
 */
HRESULT DDAPI DD_Surface_GetDC(
		LPDIRECTDRAWSURFACE lpDDSurface,
		HDC FAR *lphDC )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT                     ddrval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetDC");
    /* DPF_ENTERAPI(lpDDSurface); */
    // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF(3,A,"   lphDC = 0x%p", lphDC);

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_HDC_PTR( lphDC ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER ||
            this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED )
        {
            DPF_ERR( "Invalid surface type: can't get DC" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
            DPF(3,A,"Returning DDERR_SURFACELOST");
	    return DDERR_SURFACELOST;
	}
	// DC already returned for this surface? We don't need to
	// check this if the surface is OWNDC. If so then we can
	// hand out (the same) HDC as many times as we like.
	if(  ( this_lcl->dwFlags & DDRAWISURF_HASDC ) &&
	    !( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
	{
	    DPF_ERR( "Can only return one DC per surface" );
	    LEAVE_DDRAW();
	    return DDERR_DCALREADYCREATED;
	}

        // default value is null:
	*lphDC = (HDC) 0;

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

        //
        // Fail if GDI doesn't understand the format
        //
        #ifdef WIN95
            if (!LOWERTHANDDRAW7( this_lcl->lpSurfMore->lpDD_int ) )
            {
                LPDDPIXELFORMAT lpPf;
            
                GET_PIXEL_FORMAT( this_lcl, this, lpPf );
                if( !bIsValidDCFormat( lpPf ) )
                {
                    DPF_ERR( "DCs cannot be used with this surface format" );
                    LEAVE_DDRAW();
                    return DDERR_INVALIDPIXELFORMAT;
                }
            }
        #endif
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * If this is an OWNDC surface and we currently have an HDC
     * then just use that.
     */
    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) &&
	( 0UL != this_lcl->hDC ) )
    {
	/*
	 * We currently only support OWNDC for explicit system
	 * memory surfaces.
	 */
	DDASSERT( this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED );

	*lphDC = (HDC)this_lcl->hDC;

	LEAVE_DDRAW();
	return DD_OK;
    }

    ddrval = InternalGetDC( this_int, lphDC
#ifdef WIN95
        , TRUE
#endif  //WIN95
        );

    LEAVE_DDRAW();
    return ddrval;
} /* DD_Surface_GetDC */

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseDC"

/*
 * DD_Surface_ReleaseDC
 *
 * NOTE: This function does not actually release the HDC for an OWNDC surface.
 * The HDC is only toasted when the surface is finally destroyed.
 */
HRESULT DDAPI DD_Surface_ReleaseDC(
		LPDIRECTDRAWSURFACE lpDDSurface,
                HDC hdc )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT                     ddrval;
    BOOL			bFound;
    DCINFO			*pdcinfo;
    DCINFO			*pdcinfoPrev = NULL;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_ReleaseDC");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
        #ifdef WIN95
            if( SURFACE_LOST( this_lcl ) )
            {
                LEAVE_DDRAW();
	        return DDERR_SURFACELOST;
            }
        #endif
	if( !(this_lcl->dwFlags & DDRAWISURF_HASDC) )
	{
	    DPF_ERR( "No DC allocated" );
	    LEAVE_DDRAW();
	    return DDERR_NODC;
	}

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	/*
	 * Check for an invalid DC. Prior to DX5, we didn't check so it was
	 * possible to 1) release an DC that we didn't create and 2) release a
	 * DC that wasn't associated with the surface, causing things to get
	 * messed up.
	 */
	bFound = FALSE;
	for( pdcinfo = g_pdcinfoHead; pdcinfo != NULL;
	    pdcinfoPrev = pdcinfo, pdcinfo = pdcinfo->pdcinfoNext )
	{
	    DDASSERT( pdcinfo->pdds_lcl != NULL );

	    if( hdc == pdcinfo->hdc )
	    {
		bFound = TRUE;
		if( this_lcl != pdcinfo->pdds_lcl )
		{
		    bFound = FALSE;
		}
		break;
	    }
	}
	if( !bFound )
	{
	    if( ( this_int->lpVtbl == &ddSurfaceCallbacks ) ||
		( this_int->lpVtbl == &ddSurface2Callbacks ) )
	    {
		DPF_ERR( "********************************************************************" );
		DPF_ERR( "* Invalid DC specified in ReleaseDC - not associate with the surface" );
		DPF_ERR( "********************************************************************" );
	    }
	    else
	    {
		DPF_ERR( "Invalid DC specified in ReleaseDC" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * If this is an OWNDC surface then just check to make sure we
     * were given back the correct HDC and return.
     */
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC )
    {
	DDASSERT( this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED );

	if( hdc != (HDC)this_lcl->hDC )
	{
	    DPF_ERR( "ReleaseDC called with wrong HDC for OWNDC surface" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	LEAVE_DDRAW();
	return DD_OK;
    }

    ddrval = InternalReleaseDC( this_lcl, hdc
#ifdef WIN95
        , TRUE
#endif  //WIN95
        );

    BUMP_SURFACE_STAMP(this);

    LEAVE_DDRAW();
    return ddrval;
} /* DD_Surface_ReleaseDC */

#undef DPF_MODNAME
#define DPF_MODNAME "IsLost"

/*
 * DD_Surface_IsLost
 */
HRESULT DDAPI DD_Surface_IsLost( LPDIRECTDRAWSURFACE lpDDSurface )
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_IsLost");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        pdrv = this->lpDD;
        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
        if (this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE)
        {
            LEAVE_DDRAW();
            return DDERR_NOTLOADED;
        }
#if 0 //Old code
        if (this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE)
        {
            LEAVE_DDRAW();
            return DDERR_NOTLOADED;
        }
#endif //0
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_IsLost */

#undef DPF_MODNAME
#define DPF_MODNAME "Initialize"

/*
 * DD_Surface_Initialize
 */
HRESULT DDAPI DD_Surface_Initialize(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDIRECTDRAW lpDD,
		LPDDSURFACEDESC lpDDSurfaceDesc )
{
    DPF(2,A,"ENTERAPI: DD_Surface_Initialize");

    DPF_ERR( "DirectDrawSurface: Already initialized." );
    return DDERR_ALREADYINITIALIZED;

} /* DD_Surface_Initialize */

HRESULT AtomicRestoreSurface(LPDDRAWI_DDRAWSURFACE_INT this_int)
{
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    DDHAL_CREATESURFACEDATA	csd;
    LPDDHAL_CREATESURFACE	csfn;
    LPDDHAL_CREATESURFACE	cshalfn;
    DWORD			rc;
    HRESULT			ddrval = DD_OK;
    UINT			bpp;
    LONG			pitch;
    BOOL			do_alloc=TRUE;
    BOOL                        emulation = FALSE;
    DWORD                       scnt;
    DDSURFACEDESC2              ddsd2;

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;
    #ifdef WINNT
	// Update DDraw handle in driver GBL object.
	pdrv->hDD = pdrv_lcl->hDD;
    #endif //WINNT

    DDASSERT( SURFACE_LOST( this_lcl ) );

#ifndef WINNT
    if( this_lcl->dwModeCreatedIn != pdrv->dwModeIndex )
#else
    if (!EQUAL_DISPLAYMODE(this_lcl->lpSurfMore->dmiCreated, pdrv->dmiCurrent))
#endif
    {
	DPF_ERR( "Surface was not created in the current mode" );
	return DDERR_WRONGMODE;
    }

    if(this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        emulation = TRUE;
    }

    #ifdef WINNT
        if (this->dwGlobalFlags & DDRAWISURFGBL_NOTIFYWHENUNLOCKED)
        {
            if (--dwNumLockedWhenModeSwitched == 0)
            {
                NotifyDriverOfFreeAliasedLocks();
            }
            this->dwGlobalFlags &= ~DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
        }
    #endif

    if( emulation )
    {
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
	{
	    csfn = pdrv_lcl->lpDDCB->HELDDExeBuf.CreateExecuteBuffer;
	}
	else
	{
	    csfn = pdrv_lcl->lpDDCB->HELDD.CreateSurface;
	}
	cshalfn = csfn;
    }
    else
    {
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
	{
	    csfn = pdrv_lcl->lpDDCB->HALDDExeBuf.CreateExecuteBuffer;
	    cshalfn = pdrv_lcl->lpDDCB->cbDDExeBufCallbacks.CreateExecuteBuffer;
	}
	else
	{
	    csfn = pdrv_lcl->lpDDCB->HALDD.CreateSurface;
	    cshalfn = pdrv_lcl->lpDDCB->cbDDCallbacks.CreateSurface;
	}
    }

    csd.CreateSurface = cshalfn;
    csd.lpDD = pdrv;
    if (this_lcl->dwFlags & DDRAWISURF_IMPLICITROOT)
    {
        //
        // This is a complex surface, so we recorded the createsurface data
        // at CS time.
        //
        DDASSERT(this_lcl->lpSurfMore->pCreatedDDSurfaceDesc2);
        DDASSERT(this_lcl->lpSurfMore->slist);
        DDASSERT(this_lcl->lpSurfMore->cSurfaces);
        csd.lpDDSurfaceDesc = (LPDDSURFACEDESC) this_lcl->lpSurfMore->pCreatedDDSurfaceDesc2;
        csd.lplpSList = this_lcl->lpSurfMore->slist;
        csd.dwSCnt = this_lcl->lpSurfMore->cSurfaces;
        //
        // we record the surfacedesc for any complex surface except pure mipmaps
        //
        if ((this_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) &&
            ((this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP)==0) )
        {
            DDASSERT(0 == this_lcl->lpSurfMore->pCreatedDDSurfaceDesc2);
	    FillDDSurfaceDesc2( this_lcl, &ddsd2 );
            csd.lpDDSurfaceDesc = (LPDDSURFACEDESC) &ddsd2;
        }
    }
    else
    {
        //
        // this is a single non-complex surface.
        // Setup the createsurface data structure to reflect it
        //
	FillDDSurfaceDesc2( this_lcl, &ddsd2 );
        csd.lpDDSurfaceDesc = (LPDDSURFACEDESC) &ddsd2;
        csd.lplpSList = &this_lcl;
        csd.dwSCnt = 1;
    }


    //
    // Note, those surfaces for whom MEMFREE (i.e. the GDI surface) is not set also pass through
    // this code path and are passed to the driver's createsurface
    // This is different from the process for non-dx7 drivers.
    // The non-dx7 driver restore path actually has a bug: the alias for the GDI surface
    // is not restored. 
    //
    for( scnt=0; scnt<csd.dwSCnt; scnt++ )
    {
	if (csd.lplpSList[scnt]->lpGbl->fpVidMem != 0xFFBADBAD)
	    csd.lplpSList[scnt]->lpGbl->fpVidMem = 0;

        if( !( csd.lplpSList[scnt]->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER ) )
        {
	    if( csd.lplpSList[scnt]->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	    {
	        bpp = csd.lplpSList[scnt]->lpGbl->ddpfSurface.dwRGBBitCount;
	    }
	    else
	    {
	        bpp = pdrv->vmiData.ddpfDisplay.dwRGBBitCount;
	    }
	    pitch = (LONG) ComputePitch( pdrv, csd.lplpSList[scnt]->ddsCaps.dwCaps,
    					    (DWORD) csd.lplpSList[scnt]->lpGbl->wWidth, bpp );
	    csd.lplpSList[scnt]->lpGbl->lPitch = pitch;
        } 
    }

#ifdef    WIN95
    /* Copy the VXD handle from the per process local structure to global.
     * This handle will be used by DDHAL32_VidMemAlloc(), rather than creating
     * a new one using GetDXVxdHandle(). The assumptions here are:
     * 1) Only one process can enter createSurface(), 2) Deferred calls to
     * DDHAL32_VidMemAlloc() will result in the slow path, ie getting
     * the VXD handle using GetDXVxdHandle().
     * (snene 2/23/98)
     */
    pdrv->hDDVxd = pdrv_lcl->hDDVxd;
#endif /* WIN95 */

    /*
     * NOTE: Different HAL entry points for execute buffers and
     * conventional surfaces.
     */
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
	DOHALCALL( CreateExecuteBuffer, csfn, csd, rc, emulation );
    }
    else
    {
        DOHALCALL( CreateSurface, csfn, csd, rc, emulation );
    }

#ifdef    WIN95
    /* Restore the handle to INVALID_HANDLE_VALUE so that non-createSurface()
     * calls using DDHAL32_VidMemAlloc() or deferred calls (possibly from other
     * processes) will correctly recreate the handle using GetDXVxdHandle().
     * (snene 2/23/98)
     */
    pdrv->hDDVxd = (DWORD)INVALID_HANDLE_VALUE;
#endif /* WIN95 */

    if( rc == DDHAL_DRIVER_HANDLED )
    {
	if( csd.ddRVal != DD_OK )
	{
	    #ifdef DEBUG
		if( emulation )
		{
                    DPF( 1, "Restore: Emulation won't let surface be created, rc=%08lx (%ld)",
				csd.ddRVal, LOWORD( csd.ddRVal ) );
		}
		else
		{
		    DPF( 1, "Restore: Driver won't let surface be created, rc=%08lx (%ld)",
				csd.ddRVal, LOWORD( csd.ddRVal ) );
		}
	    #endif

	    return csd.ddRVal;
	}
    }

    /*
     * now, allocate any unallocated surfaces
     */
    ddrval = AllocSurfaceMem( pdrv_lcl, csd.lplpSList, csd.dwSCnt );
    if( ddrval != DD_OK )
    {
	return ddrval;
    }

    for( scnt=0; scnt<csd.dwSCnt; scnt++ )
    {
	LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

	csd.lplpSList[scnt]->dwFlags   &= ~DDRAWISURF_INVALID;
	csd.lplpSList[scnt]->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;

#ifdef USE_ALIAS
        /*
         * If this device has heap aliases then precompute the pointer
         * alias for the video memory returned at creation time. This
         * is by far the most likely pointer we are going to be handing
         * out at lock time so we are going to make lock a lot faster
         * by precomputing this then at lock time all we need to do is
         * compare the pointer we got from the driver with fpVidMem. If
         * they are equal then we can just return this cached pointer.
         */
	lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE( csd.lplpSList[scnt]->lpGbl );
	if( csd.lplpSList[scnt]->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
        {
	    lpGblMore->fpAliasedVidMem = GetAliasedVidMem( pdrv_lcl, csd.lplpSList[scnt],
							   csd.lplpSList[scnt]->lpGbl->fpVidMem );
            // If we succeeded in getting an alias, cache it for future use. Also store the original
            // fpVidMem to compare with before using the cached pointer to make sure the cached value
            // is still valid
            if (lpGblMore->fpAliasedVidMem)
                lpGblMore->fpAliasOfVidMem = csd.lplpSList[scnt]->lpGbl->fpVidMem;
            else
                lpGblMore->fpAliasOfVidMem = 0;
        }
	else
        {
	    lpGblMore->fpAliasedVidMem = 0UL;
            lpGblMore->fpAliasOfVidMem = 0UL;
        }
#endif /* USE_ALIAS */

#ifdef WIN95
        if (csd.lplpSList[scnt]->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_PERSISTENTCONTENTS)
        {
            ddrval = RestoreSurfaceContents(csd.lplpSList[scnt]);
        }
#endif

        /*
         * If a D3D texture managed surface is being restored,
         * then we need to mark the corresponding system memory
         * surface dirty, so that it is automatically refreshed
         * prior to rendering.
         */
        if (SUCCEEDED(ddrval))
        {
            if(!IsD3DManaged(csd.lplpSList[scnt]) && csd.lplpSList[scnt]->lpSurfMore->lpRegionList)
            {
                MarkDirty(csd.lplpSList[scnt]);
                csd.lplpSList[scnt]->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
            }
        }
    }

    if (
#ifdef  WINNT
        // on NT side, we still call CreateSurfaceEx if HW driver isn't called
        emulation && this_lcl->hDDSurface &&
#endif  //WINNT
        TRUE
       )
    {
        DDASSERT( pdrv_lcl == this_lcl->lpSurfMore->lpDD_lcl);
        createsurfaceEx(this_lcl);
    }

    // If D3D Vertex Buffer, notify D3D
    if ( (this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
         (this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
         (this_lcl->lpGbl->dwUsageCount > 0) &&
         (GetCurrentProcessId() == GETCURRPID()) &&
         (this_lcl->lpSurfMore->lpDD_lcl->pBreakVBLock) && 
         (this_lcl->lpSurfMore->lpVB) )
    {
        {
            this_lcl->lpSurfMore->lpDD_lcl->pBreakVBLock(this_lcl->lpSurfMore->lpVB);
        }
    }

    return ddrval;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Restore"

/*
 * restoreSurface
 *
 * restore the vidmem of one surface
 */
static HRESULT restoreSurface( LPDDRAWI_DDRAWSURFACE_INT this_int )
{
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	slistx[1];
    LPDDRAWI_DDRAWSURFACE_GBL	slist[1];
    DDHAL_CREATESURFACEDATA	csd;
    LPDDHAL_CREATESURFACE	csfn;
    LPDDHAL_CREATESURFACE	cshalfn;
    DDSURFACEDESC2		ddsd;
    DWORD			rc;
    HRESULT			ddrval;
    UINT			bpp;
    LONG			pitch = 0;
    BOOL			do_alloc=TRUE;

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;
    #ifdef WINNT
	// Update DDraw handle in driver GBL object.
	pdrv->hDD = pdrv_lcl->hDD;
    #endif //WINNT

    /*
     * If we made it to here the local surface should be marked invalid.
     */
    DDASSERT( SURFACE_LOST( this_lcl ) );

#ifndef WINNT
    if( this_lcl->dwModeCreatedIn != pdrv->dwModeIndex )
#else
    if (!EQUAL_DISPLAYMODE(this_lcl->lpSurfMore->dmiCreated, pdrv->dmiCurrent))
#endif
    {
	DPF_ERR( "Surface was not created in the current mode" );
	return DDERR_WRONGMODE;
    }

    #ifdef WINNT
        if (this->dwGlobalFlags & DDRAWISURFGBL_NOTIFYWHENUNLOCKED)
        {
            if (--dwNumLockedWhenModeSwitched == 0)
            {
                NotifyDriverOfFreeAliasedLocks();
            }
            this->dwGlobalFlags &= ~DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
        }
    #endif

    DPF(5,"RestoreSurface. GDI Flag is %d, MemFree flag is %d, Primary flag is %d",
        this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE,
        this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE,
        this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE
       );
    /*
     * Two cases where we don't want to allocate any memory:
     * -optimized surfaces
     * -surfaces for which was just marked as invalid.
     * If this is an optimized surface, Restore is basically a noop
     * since memory is allocated at optimize time, not restore time.
     */
    if(( (!(this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE))
#ifdef WINNT
        /*
         * We need to call CreateSurface HAL callback on NT
         */
            && (((this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) == 0)
    	    || (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
#endif
            ) || (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED) )
    {
	this_lcl->dwFlags &= ~DDRAWISURF_INVALID;
	ddrval = DD_OK;
        do_alloc = FALSE;
    }
    else
    {
	slistx[0] = this_lcl;
	slist[0] = this;

	if (this->fpVidMem != 0xFFBADBAD)
	    this->fpVidMem = 0;

        // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF( 4, "Restoring 0x%p", this_lcl );

	/*
	 * Execute buffers are handled very differently
	 * from ordinary surfaces. They have no width and
	 * height and store a linear size instead of a pitch.
	 * Note, the linear size includes any alignment
	 * requirements (added by ComputePitch on surface
	 * creation) so we do not recompute the pitch at this
	 * point. The surface structure as it stands is all we
	 * need.
	 */
	if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER ) )
	{
	    if( this_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	    {
		bpp = this->ddpfSurface.dwRGBBitCount;
	    }
	    else
	    {
		bpp = pdrv->vmiData.ddpfDisplay.dwRGBBitCount;
	    }
	    pitch = (LONG) ComputePitch( pdrv, this_lcl->ddsCaps.dwCaps,
    					    (DWORD) this->wWidth, bpp );
	    this->lPitch = pitch;
	}
	/*
	 * first, give the driver an opportunity to create it...
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
	{
	    cshalfn = pdrv_lcl->lpDDCB->cbDDExeBufCallbacks.CreateExecuteBuffer;
	    csfn    = pdrv_lcl->lpDDCB->HALDDExeBuf.CreateExecuteBuffer;
	}
	else
	{
	    cshalfn = pdrv_lcl->lpDDCB->cbDDCallbacks.CreateSurface;
	    csfn    = pdrv_lcl->lpDDCB->HALDD.CreateSurface;
	}
	if( cshalfn != NULL )
	{
            DPF(4,"HAL CreateSurface to be called");
	    /*
	     * construct a new surface description
	     */
	    FillDDSurfaceDesc2( this_lcl, &ddsd );

	    /*
	     * call the driver
	     */
    	    csd.CreateSurface = cshalfn;
	    csd.lpDD = pdrv;
	    csd.lpDDSurfaceDesc = (LPDDSURFACEDESC)&ddsd;
	    csd.lplpSList = slistx;
	    csd.dwSCnt = 1;

	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
	    {
		DOHALCALL( CreateExecuteBuffer, csfn, csd, rc, FALSE );
	    }
	    else
	    {
		DOHALCALL( CreateSurface, csfn, csd, rc, FALSE );
	    }
	    if( rc == DDHAL_DRIVER_HANDLED )
	    {
		if( csd.ddRVal != DD_OK )
		{
		    do_alloc = FALSE;
		    ddrval = csd.ddRVal;
		}
            }
	}
        /*
         * On NT, we will hit this code path for the GDI surface.
         * We could probably just not do the alloc, but to avoid hard-to-test code paths
         * I'll let the AllocSurfaceMem trivially allocate for the GDI surface.
         */
	if( do_alloc )
	{
	    /*
	     * allocate the memory now...
	     */
	    ddrval = AllocSurfaceMem( pdrv_lcl, slistx, 1 );
	    if( ddrval != DD_OK )
	    {
		this->lPitch = pitch;
                DPF(2,"Moving to system memory");
		ddrval = MoveToSystemMemory( this_int, FALSE, TRUE );
	    }
	    if( ddrval == DD_OK )
	    {
		this_lcl->dwFlags   &= ~DDRAWISURF_INVALID;
		this->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
	    }
	}
    }

#ifdef USE_ALIAS
    {
	LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

	lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE( this );
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
        {
	    lpGblMore->fpAliasedVidMem = GetAliasedVidMem( pdrv_lcl, this_lcl, this_lcl->lpGbl->fpVidMem );
            // If we succeeded in getting an alias, cache it for future use. Also store the original
            // fpVidMem to compare with before using the cached pointer to make sure the cached value
            // is still valid
            if (lpGblMore->fpAliasedVidMem)
                lpGblMore->fpAliasOfVidMem = this_lcl->lpGbl->fpVidMem;
            else
                lpGblMore->fpAliasOfVidMem = 0;
        }
	else
        {
	    lpGblMore->fpAliasedVidMem = 0UL;
            lpGblMore->fpAliasOfVidMem = 0UL;
        }
    }
#endif /* USE_ALIAS */


#ifdef WIN95
    if (SUCCEEDED(ddrval) && (this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_PERSISTENTCONTENTS))
    {
        ddrval = RestoreSurfaceContents(this_lcl);
    }
#endif

    /*
     * If a D3D texture managed surface is being restored,
     * then we need to mark the corresponding system memory
     * surface dirty, so that it is automatically refreshed
     * prior to rendering.
     */
    if(!IsD3DManaged(this_lcl) && this_lcl->lpSurfMore->lpRegionList)
    {
        MarkDirty(this_lcl);
        this_lcl->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
    }

    return ddrval;

} /* restoreSurface */

/*
 * restoreAttachments
 *
 * restore all attachments to a surface
 */
static HRESULT restoreAttachments( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    LPATTACHLIST		pattachlist;
    LPDDRAWI_DDRAWSURFACE_INT	curr_int;
    LPDDRAWI_DDRAWSURFACE_LCL	curr_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	curr;
    HRESULT			ddrval;

    pattachlist = this_lcl->lpAttachList;
    while( pattachlist != NULL )
    {
	curr_int = pattachlist->lpIAttached;

	curr_lcl = curr_int->lpLcl;
    	curr = curr_lcl->lpGbl;
	if( curr_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE )
	{
	    ddrval = restoreSurface( curr_int );
	    if( ddrval != DD_OK )
	    {
		DPF( 2, "restoreSurface failed: %08lx (%ld)", ddrval, LOWORD( ddrval ) );
		return ddrval;
	    }
	    ddrval = restoreAttachments( curr_lcl );
	    if( ddrval != DD_OK )
	    {
		DPF( 2, "restoreAttachents failed: %08lx (%ld)", ddrval, LOWORD( ddrval ) );
		return ddrval;
	    }
	}
    pattachlist = pattachlist->lpLink;
    }
    return DD_OK;

} /* restoreAttachments */

/*
 * DD_Surface_Restore
 *
 * Restore an invalidated surface
 */
#undef  DPF_MODNAME
#define DPF_MODNAME "DD_Surface_Restore"
HRESULT DDAPI DD_Surface_Restore( LPDIRECTDRAWSURFACE lpDDSurface )
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    HRESULT         ddrval;
    BOOL                        has_excl;
    BOOL                        excl_exists;
    DDSURFACEDESC2              ddsd;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Restore");
    /* DPF_ENTERAPI(lpDDSurface); */

    /*
     * validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            DPF_ERR( "Invalid surface pointer" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
        pdrv = pdrv_lcl->lpGbl;
        if( (this_lcl->dwFlags & DDRAWISURF_ISFREE) )
        {
            LEAVE_DDRAW();
            DPF_APIRETURNS( DDERR_INVALIDOBJECT);
            return DDERR_INVALIDOBJECT;
        }
        #ifdef WIN95
            if( ( pdrv_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_SCREENSAVER ) &&
                ( pdrv_lcl->dwLocalFlags & DDRAWILCL_POWEREDDOWN ) )
            {
                LEAVE_DDRAW();
                return DDERR_SURFACELOST;
            }
        #endif
        if( !SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            DPF(2,"Returning DD_OK since not lost");
            return DD_OK;;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_INVALIDPARAMS);
        return DDERR_INVALIDPARAMS;
    }

    // For now, disallow it for optimized surfaces
    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
    }

    /*
     * don't allow restoration of implicit surfaces
     */
    if( (this_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE) )
    {
        DPF_ERR( "Can't restore implicitly created surfaces" );
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_IMPLICITLYCREATED);
        return DDERR_IMPLICITLYCREATED;
    }

    /*
     * make sure we are in the same mode the surface was created in
     */
#ifdef WIN95
    if( pdrv->dwModeIndex != this_lcl->dwModeCreatedIn )
#else
    if (!EQUAL_DISPLAYMODE(this_lcl->lpSurfMore->dmiCreated, pdrv->dmiCurrent))
#endif
    {
        DPF(1, "Cannot restore surface, not in original mode");
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_WRONGMODE);
        return DDERR_WRONGMODE;
    }

    /*
     * If the device has an exclusive owner, we must not restore any surface
     * in the device's video memory unless we are the device's exclusive owner.
     * DDERR_WRONGMODE is returned to avoid regression problems by mimicking
     * Restore() behavior in the case in which the device's exclusive owner has
     * changed to a mode that's different from the one the surface was created in.
     *
     * We also handle the case where an exclusive mode app tries to restore
     * surfaces while no one has exclusive mode (for example, when the app is
     * minimized). The restore would commonly fail due to the app running in a
     * different display mode from the current display mode. However, if the
     * is running in the same display mode, we would previously allow the
     * restore to succeed. As mentioned above, we'll return DDERR_WRONGMODE,
     * to avoid regression problems, even though DDERR_NOEXCLUSIVEMODE would
     * make more sense.
     */
    CheckExclusiveMode(this_lcl->lpSurfMore->lpDD_lcl, &excl_exists , &has_excl, FALSE, 
        NULL, FALSE);

    if((excl_exists && !has_excl) ||
       (!excl_exists && (pdrv_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE)))
    {
        DPF_ERR("Another app has assumed exclusive ownership of device");
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_WRONGMODE);
        return DDERR_WRONGMODE;
    }

    /*
     * make sure we are not in the middle of a mode change, in which case
     * DirectDraw is confused about the mode it is in
     */
    if( pdrv->dwFlags & DDRAWI_CHANGINGMODE )
    {
        /*
         * We really should fail this altogether since we are only
         * asking for trouble, but we fear that regression risk might
         * be worse, so we only fail this for a surface 3 interface.
         * In the cases we do not fail, we handle the Blt case by not
         * doing anything, but we're still vulnerable to Lock and GetDC.
         */
        if( !( ( this_int->lpVtbl == &ddSurfaceCallbacks ) ||
               ( this_int->lpVtbl == &ddSurface2Callbacks ) ) )
        {
            DPF_ERR("Cannot restore surface, in the middle of a mode change");
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_WRONGMODE);
            return DDERR_WRONGMODE;
        }
        else
        {
            /*
             * Always output a message here.  This serves two purposes:
             * 1) Let us no why a stress failure occured,
             * 2) Inform developers why they are seeing bugs.
             */
            OutputDebugString( "WARNING: Restoring surface during a mode change!\n" );
        }
    }

    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
    {
        /*
         * are we the process with exclusive mode?
         */
        if( excl_exists && !has_excl )
        {
            DPF_ERR( "Cannot restore primary surface, not exclusive owner" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_NOEXCLUSIVEMODE);
            return DDERR_NOEXCLUSIVEMODE;
        }
        else if( !excl_exists )
        {
            /*
             * no exclusive mode
             */
            FillDDSurfaceDesc2( this_lcl, &ddsd );
            if( !MatchPrimary( pdrv, &ddsd ) )
            {
                DPF_ERR( "Can't restore primary, incompatible with current primary" );
                LEAVE_DDRAW();
                DPF_APIRETURNS(DDERR_INCOMPATIBLEPRIMARY);
                return DDERR_INCOMPATIBLEPRIMARY;
            }
        }
        /*
     * otherwise, it is OK to restore primary
     */

#ifdef WINNT
        /*
             * Ctrl-Alt-Del on NT gives us no notice and so no FlipToGDISurface has been done.
             * This means that the DDSCAPS_PRIMARY and DDRAWISURFGBL_ISGDISURFACE tags may
             * not be on the same surface object (which is what FlipToGDISurface does).
             * The NT user-side code expects that DDSCAPS_PRIMARY means DDRAWISURFGBL_ISGDISURFACE
             * which it normally would, and should (i.e. GDI's surface should be the visible surface
             * immediately before a switch back to a fullscreen app.)
             * We force this situation here by running the attachment list for a primary and
             * finding the GDI surface, then doing a surface-object-only flip (i.e. exchange
             * these two objects' MEMFREE status, dwReserved and Kernel handle fields.
             * I shall be extra paranoid and only attempt this if the primary doesn't have
             * IS_GDISURFACE set. It should be safe to assume that the only way the GDI and
             * PRIMARY flags got mismatched is via a flip that wasn't undone.
             * This situation should never happen for an emulated primary (since Flip drops
             * out early before doing the flag rotation).
             */
        if ( !( this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE ) )
        {
            /*
             * Run the attachments looking for the surface with the GDI flag
             */
            LPDDRAWI_DDRAWSURFACE_INT   curr_int;

            DDASSERT( (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) == 0);
            DDASSERT(this_lcl->lpAttachList);

            curr_int = FindAttachedFlip(this_int);
            while( curr_int->lpLcl != this_lcl )
            {
                if( curr_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE )
                {
                    /*
                     * Found the GDI tagged surface
                     */
                    break;
                }
                DDASSERT(curr_int->lpLcl->lpAttachList);
                curr_int = FindAttachedFlip(curr_int);
            }
            if (curr_int->lpLcl != this_lcl)
            {
                /*
                 * curr_lcl != this_lcl means we found an attached surface with GDI set,
                 * so pseudo-flip them.
                 */
                DWORD                       memfreeflag;
		ULONG_PTR                   reserved,handle;
                LPDDRAWI_DDRAWSURFACE_GBL   curr_gbl = curr_int->lpLcl->lpGbl;

                DDASSERT(0 == curr_gbl->fpVidMem);
                DDASSERT(NULL == curr_gbl->lpVidMemHeap);

                    /*
                     * The primary (this) needs to get the GDI flag set, and the other
                     * (the old GDI surface) needs to get GDI reset.
                     */
                curr_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
                this->dwGlobalFlags |= DDRAWISURFGBL_ISGDISURFACE;

                    /*
                     * The two surfaces must trade their MEMFREE status.
                     */
                memfreeflag = curr_gbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
                curr_gbl->dwGlobalFlags = (curr_gbl->dwGlobalFlags & ~DDRAWISURFGBL_MEMFREE)
                    | (this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE);
                this->dwGlobalFlags = (this->dwGlobalFlags & ~DDRAWISURFGBL_MEMFREE)
                    | memfreeflag;

                    /*
                     * Swap reserved field and kernel handle
                     */
                reserved = curr_gbl->dwReserved1;
                curr_gbl->dwReserved1 = this->dwReserved1;
                this->dwReserved1 = reserved;

                handle = curr_int->lpLcl->hDDSurface;
                curr_int->lpLcl->hDDSurface = this_lcl->hDDSurface;
                this_lcl->hDDSurface = handle;
            }
        }
#endif

    } /* if primary surface */

    if (NULL == pdrv->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx) 
    {
        //
        // Non DX7 driver gets piece-meal restore
        //
        /*
         * restore this surface
         */
        ddrval = restoreSurface( this_int );
        if( ddrval != DD_OK )
        {
            DPF( 1, "restoreSurface failed, rc=%08lx (%ld)", ddrval, LOWORD( ddrval ) );
            LEAVE_DDRAW();
            DPF_APIRETURNS(ddrval);
            return ddrval;
        }

        /*
         * restore all surfaces in an implicit chain
         */
        if( this_lcl->dwFlags & DDRAWISURF_IMPLICITROOT )
        {
            ddrval = restoreAttachments( this_lcl );
        }
    }
    else
    {
        //
        // DX7 driver gets atomic restore
        //
        ddrval = AtomicRestoreSurface(this_int);
    }

    LEAVE_DDRAW();
    DPF_APIRETURNS(ddrval);
    return ddrval;

} /* DD_Surface_Restore */

/*
 * MoveToSystemMemory
 *
 * if possible, deallocate the video memory associated with this surface
 * and allocate system memory instead.	This is useful for drivers which have
 * hardware flip and video memory capability but no blt capability.  By
 * moving the offscreen surfaces to system memory, we reduce the lock overhead
 * and also reduce the bus bandwidth requirements.
 *
 * This function assumes the DRIVER LOCK HAS BEEN TAKEN.
 */
HRESULT MoveToSystemMemory(
		LPDDRAWI_DDRAWSURFACE_INT this_int,
		BOOL hasvram,
		BOOL use_full_lock )
{
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    ULONG_PTR			newreserved;
    ULONG_PTR                   newreserved_lcl;
//    LPVOID	                newvidmemheap;
    LONG	                newpitch;
    FLATPTR	                newvidmem;
    DWORD                       newddscaps;
    ULONG_PTR                   newhddsurface;
    ULONG_PTR           	savereserved;
    ULONG_PTR                   savereserved_lcl;
    LPVOID	                savevidmemheap;
    LONG	                savepitch;
    FLATPTR	                savevidmem;
    DWORD                       saveddscaps;
    ULONG_PTR                   savehddsurface;
    DDHAL_CREATESURFACEDATA	csd;
    DWORD			rc;
    DDSURFACEDESC2		ddsd;
    LPDDRAWI_DDRAWSURFACE_LCL	slistx;
    LPBYTE                      lpvidmem;
    LPBYTE                      lpsysmem;
    DWORD			bytecount;
    DWORD                       line;
    HRESULT			ddrval;
    LPVOID			pbits;
    WORD                        wHeight;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;


    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;

    //
    // We don't move to system memory on DX7 drivers, since this process doesn't
    // inform them of the new sysmem surface
    //
    if (NULL != pdrv->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx)
    {
        //this error code never percolates up to apps.
        return DDERR_GENERIC;
    }

    #ifdef WINNT
    {
	// Update DDraw handle in driver GBL object.
	pdrv->hDD = pdrv_lcl->hDD;
    }
    #endif //WINNT

    if(hasvram && SURFACE_LOST( this_lcl ) )
    {
	return DDERR_SURFACELOST;
    }

    if( ( this_lcl->lpAttachList != NULL ) ||
	( this_lcl->lpAttachListFrom != NULL ) ||
	( this->dwUsageCount != 0 ) ||
	( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) ||
	( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) ||
        ( this_lcl->dwFlags & (DDRAWISURF_HASPIXELFORMAT|DDRAWISURF_PARTOFPRIMARYCHAIN) ) )
    {
	/*
	 * can't move it to system memory
	 */
        // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF( 2, "Unable to move surface 0x%p to system memory", this_int );
	#ifdef DEBUG
	    if( this_lcl->lpAttachList != NULL )
	    {
		DPF( 4, "AttachList is non-NULL" );
	    }
	    if( this_lcl->lpAttachListFrom != NULL )
	    {
		DPF( 4, "AttachListFrom is non-NULL" );
	    }
	    if( this->dwUsageCount != 0 )
	    {
		DPF( 4, "dwusageCount=%ld", this->dwUsageCount );
	    }
	    if( this_lcl->dwFlags & DDRAWISURF_PARTOFPRIMARYCHAIN )
	    {
		DPF( 4, "part of the primary chain" );
	    }
	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
	    {
		DPF( 4, "Is a hardware overlay" );
	    }
	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
	    {
		DPF( 4, "Is already in system memory" );
	    }
	    if( this_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	    {
		DPF( 4, "Has a different pixel format" );
	    }
	#endif
	return DDERR_GENERIC;
    }

    /*
     * save the current state just in case the HEL
     * CreateSurface call fails.
     */
    savevidmem = this->fpVidMem;
    savevidmemheap = this->lpVidMemHeap;
    savereserved = this->dwReserved1;
    savereserved_lcl= this_lcl->dwReserved1;
    savepitch = this->lPitch;
    saveddscaps = this_lcl->ddsCaps.dwCaps;
    savehddsurface = this_lcl->hDDSurface;

    /*
     * lock the vram
     */
    if( hasvram )
    {
	while( 1 )
	{
	    if( use_full_lock )
	    {
		ddsd.dwSize = sizeof( ddsd );
		ddrval = DD_Surface_Lock(
				(LPDIRECTDRAWSURFACE) this_int,
				NULL,
				(LPDDSURFACEDESC)&ddsd,
				0,
				NULL );
		if( ddrval == DD_OK )
		{
		    pbits = ddsd.lpSurface;
		}
	    }
	    else
	    {
		ddrval = InternalLock( this_lcl, &pbits, NULL, 0 );
	    }
	    if( ddrval == DDERR_WASSTILLDRAWING )
	    {
		continue;
	    }
	    break;
	}
	if( ddrval != DD_OK )
	{
	    DPF( 0, "*** MoveToSystemMemory: Lock failed! rc = %08lx", ddrval );
	    return ddrval;
	}
    }

    /*
     * mark this object as system memory.  NT needs this done before the
     * CreateSurface HEL call, otherwise it gets confused about whether
     * it's supposed to be a video memory or system memory surface.
     */
    this_lcl->ddsCaps.dwCaps &= ~(DDSCAPS_VIDEOMEMORY|DDSCAPS_NONLOCALVIDMEM|DDSCAPS_LOCALVIDMEM);
    this_lcl->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

    /*
     * set up for a call to the HEL
     */
    FillDDSurfaceDesc2( this_lcl, &ddsd );
    slistx = this_lcl;
    csd.lpDD = this->lpDD;
    csd.lpDDSurfaceDesc = (LPDDSURFACEDESC)&ddsd;
    csd.lplpSList = &slistx;
    csd.dwSCnt = 1;
    rc = this_lcl->lpSurfMore->lpDD_lcl->lpDDCB->HELDD.CreateSurface( &csd );
    if( (rc == DDHAL_DRIVER_NOTHANDLED) || (csd.ddRVal != DD_OK) )
    {
	this->fpVidMem = savevidmem;
	this->lpVidMemHeap = savevidmemheap;
	this->lPitch = savepitch;
	this->dwReserved1 = savereserved;
        this_lcl->dwReserved1 = savereserved_lcl;
        this_lcl->ddsCaps.dwCaps = saveddscaps;
        this_lcl->hDDSurface = savehddsurface;
	if( hasvram )
	{
	    if( use_full_lock )
	    {
		DD_Surface_Unlock( (LPDIRECTDRAWSURFACE) this_int, NULL );
	    }
	    else
	    {
		InternalUnlock( this_lcl, NULL, NULL, 0 );
	    }
	}
	DPF( 0, "*** MoveToSystemMemory: HEL CreateSurface failed! rc = %08lx", csd.ddRVal );
	return csd.ddRVal;
    }

    /*
     * copy the bits from vidmem to systemmem
     */
    if( hasvram )
    {
        lpvidmem = (LPBYTE)pbits;
        lpsysmem = (LPBYTE)this_lcl->lpGbl->fpVidMem;
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
	{
	    bytecount = this->dwLinearSize;
	    wHeight   = 1;
	}
	else
	{
	    bytecount = this->wWidth * ddsd.ddpfPixelFormat.dwRGBBitCount / 8;
	    wHeight   = this->wHeight;
	}

        TRY
        {
            for( line=0; line<wHeight; line++)
	    {
	        memcpy( lpsysmem, lpvidmem, bytecount );
	        lpvidmem += savepitch;
	        lpsysmem += this->lPitch;
            }
        }
        EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
	    DPF_ERR( "Exception encountered moving from video to system memory" );
	    this->fpVidMem = savevidmem;
	    this->lpVidMemHeap = savevidmemheap;
	    this->lPitch = savepitch;
	    this->dwReserved1 = savereserved;
            this_lcl->dwReserved1 = savereserved_lcl;
            this_lcl->ddsCaps.dwCaps = saveddscaps;
            this_lcl->hDDSurface = savehddsurface;
	    if( hasvram )
	    {
	        if( use_full_lock )
	        {
		    DD_Surface_Unlock( (LPDIRECTDRAWSURFACE) this_int, NULL );
	        }
	        else
	        {
		    InternalUnlock( this_lcl, NULL, NULL, 0 );
	        }
	    }
	    return DDERR_EXCEPTION;
        }

    }

    /*
     * it worked, temporarily reset values and unlock surface
     */
    if( hasvram )
    {
	newvidmem = this->fpVidMem;
//	newvidmemheap = this->lpVidMemHeap; THIS IS NOT SET BY THE HEL
	newreserved = this->dwReserved1;
        newreserved_lcl = this_lcl->dwReserved1;
	newpitch = this->lPitch;
        newddscaps = this_lcl->ddsCaps.dwCaps;
        newhddsurface = this_lcl->hDDSurface;

	this->fpVidMem = savevidmem;
	this->lpVidMemHeap = savevidmemheap;
	this->lPitch = savepitch;
	this->dwReserved1 = savereserved;
        this_lcl->dwReserved1 = savereserved_lcl;
        this_lcl->ddsCaps.dwCaps = saveddscaps;
        this_lcl->hDDSurface = savehddsurface;

	if( use_full_lock )
	{
	    DD_Surface_Unlock( (LPDIRECTDRAWSURFACE) this_int, NULL );
	}
	else
	{
	    InternalUnlock( this_lcl, NULL, NULL, 0 );
	}

	// Free the video memory, allow the driver to destroy the surface
	DestroySurface( this_lcl );
	// We just freed the memory but system memory surfaces never have
	// this flag set so unset it.
	this_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;

	this->fpVidMem = newvidmem;
//	this->lpVidMemHeap = newvidmemheap;
	this->lpVidMemHeap = NULL;		// should be NULL after HEL
	this->lPitch = newpitch;
	this->dwReserved1 = newreserved;
        this_lcl->dwReserved1 = newreserved_lcl;
        this_lcl->ddsCaps.dwCaps = newddscaps;
        this_lcl->hDDSurface = newhddsurface;
    }


    /*
     * the hel needs to know we touched the memory
     */
    if( use_full_lock )
    {
	DD_Surface_Lock( (LPDIRECTDRAWSURFACE) this_int, NULL,
					(LPDDSURFACEDESC)&ddsd, 0, NULL );
	DD_Surface_Unlock( (LPDIRECTDRAWSURFACE) this_int, NULL );
    }
    else
    {
	InternalLock( this_lcl, &pbits, NULL, 0 );
	InternalUnlock( this_lcl, NULL, NULL, 0 );
    }

    // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF( 2, "Moved surface 0x%p to system memory", this_int );
    return DD_OK;

} /* MoveToSystemMemory */


/*
 * invalidateSurface
 *
 * invalidate one surface
 */
void invalidateSurface( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    if( !SURFACE_LOST( this_lcl ) )
    {
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
	{
	    #ifdef USE_ALIAS
		/*
		 * If the surface is locked then break the locks now.
		 * When a broken lock is finally unlocked by the API the
		 * driver is not called. So we get Create->Lock->Destroy
		 * rather than Create->Lock->Destroy->Unlock. Thus, drivers
		 * must be able to cope with Destroy undo any pending locks
		 * at the driver level but they should be able to cope with
		 * this as it could happen even before the alias changes.
		 */
                if(!(this_lcl->dwFlags & DDRAWISURF_DRIVERMANAGED) ||
                    (this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST))
                {
		    if( this_lcl->lpGbl->dwUsageCount > 0)
		    {
                        // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		        DPF( 4, "Breaking locks held on the surface 0x%p", this_lcl );
		        BreakSurfaceLocks( this_lcl->lpGbl );
                    }
                }
	    #endif /* USE_ALIAS */
            if (!(this_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_SYSMEMEXECUTEBUFFER))
            {
                if((this_lcl->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
                    !(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST))
                {
                    LooseManagedSurface( this_lcl );
                    return;
                }
                else
                    DestroySurface( this_lcl );
            }
	}
	if( (!(this_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED) ||
	     (this_lcl->dwFlags & DDRAWISURF_PARTOFPRIMARYCHAIN) )  &&
            (!(this_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_SYSMEMEXECUTEBUFFER)) ) 
	{
	    this_lcl->dwFlags |= DDRAWISURF_INVALID;
	    BUMP_SURFACE_STAMP(this_lcl->lpGbl);
	}
    }
} /* invalidateSurface */

/*
 * invalidateAttachments
 *
 * invalidate all attachments to a surface
 */
static void invalidateAttachments( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    LPATTACHLIST		pattachlist;
    LPDDRAWI_DDRAWSURFACE_INT	curr_int;

    pattachlist = this_lcl->lpAttachList;
    while( pattachlist != NULL )
    {
	curr_int = pattachlist->lpIAttached;

	if( curr_int->lpLcl->dwFlags & DDRAWISURF_IMPLICITCREATE )
	{
	    invalidateSurface( curr_int->lpLcl );
	    invalidateAttachments( curr_int->lpLcl );
	}
	pattachlist = pattachlist->lpLink;
    }

} /* invalidateAttachments */

/*
 * InvalidateAllPrimarySurfaces
 *
 * Traverses the driver object list and sets the invalid bit on all primary
 * surfaces.
 */
void InvalidateAllPrimarySurfaces( LPDDRAWI_DIRECTDRAW_GBL this )
{
    LPDDRAWI_DIRECTDRAW_LCL     curr_lcl;

    DPF(4, "******** invalidating all primary surfaces");

    /*
     * traverse the driver object list and invalidate all primaries for
     * the specificed driver
     */
    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	if( curr_lcl->lpGbl == this )
	{
	    if( curr_lcl->lpPrimary != NULL )
	    {
		invalidateSurface( curr_lcl->lpPrimary->lpLcl );
		invalidateAttachments( curr_lcl->lpPrimary->lpLcl );
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }

} /* InvalidateAllPrimarySurfaces */

#undef DPF_MODNAME
#define DPF_MODNAME "InvalidateAllSurfaces"

/*
 * We define the page lock IOCTLs here so that we don't have to include ddvxd.h.
 * These must match the corresponding entries in ddvxd.h
 */
#define DDVXD_IOCTL_MEMPAGELOCK             28
#define DDVXD_IOCTL_MEMPAGEUNLOCK           29

/*
 * InvalidateAllSurfaces
 */
void InvalidateAllSurfaces( LPDDRAWI_DIRECTDRAW_GBL this, HANDLE hDDVxd, BOOL fRebuildAliases )
{
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   pTempLcl;

#pragma message( REMIND( "Failure conditions on InvalidateAllSurfaces need to be considered" ) )

#ifdef WIN95
    BackupAllSurfaces(this);
    CleanupD3D8(this, FALSE, 0);
#endif

    DPF(4, "******** invalidating all surfaces");

    #ifdef USE_ALIAS
	/*
	 * As surface memory is about to be destroyed we need to ensure that
	 * anyone with outstanding locks is talking to dummy memory rather
	 * than real video memory
	 *
	 * NOTE: Not a lot we can do on failure here.
	 */
	if( ( NULL != this->phaiHeapAliases ) && ( this->phaiHeapAliases->dwRefCnt > 1UL ) )
	{
            DDASSERT( INVALID_HANDLE_VALUE != hDDVxd );
            if( FAILED( MapHeapAliasesToDummyMem( hDDVxd, this->phaiHeapAliases ) ) )
	    {
                // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		DPF( 0, "Could not map heap aliases for driver object 0x%p", this );
		DDASSERT( FALSE );
	    }

	    if( fRebuildAliases )
	    {
                ReleaseHeapAliases( hDDVxd, this->phaiHeapAliases );
		this->phaiHeapAliases = NULL;
                if( FAILED( CreateHeapAliases( hDDVxd, this ) ) )
		{
                    // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		    DPF( 0, "Could not create the heap aliases for driver object 0x%p", this );
		    DDASSERT( FALSE );
		    /*
		     * Not much we can do if anything goes wrong so simply fail over to needing
		     * to hold the Win16 lock.
		     */
		    this->dwFlags |= DDRAWI_NEEDSWIN16FORVRAMLOCK;
		}
	    }
	}
    #endif /* USE_ALIAS */

    psurf_int = this->dsList;

    while( psurf_int != NULL )
    {
        pTempLcl = psurf_int->lpLcl;
	psurf_int = psurf_int->lpLink;
	invalidateSurface( pTempLcl );
    }

} /* InvalidateAllSurfaces */

/*
 * FindGlobalPrimary
 *
 * Traverses the driver object list and looks for a primary surface (it doesn't
 * matter if it is invalid).  If it finds one, it returns a pointer to the
 * global portion of that surface.  If it doesn't, it returns NULL
 */
LPDDRAWI_DDRAWSURFACE_GBL FindGlobalPrimary( LPDDRAWI_DIRECTDRAW_GBL this )
{
    LPDDRAWI_DIRECTDRAW_LCL	curr_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;

    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	if( curr_lcl->lpGbl == this )
	{
	    psurf_int = curr_lcl->lpPrimary;
	    if( psurf_int && !SURFACE_LOST( psurf_int->lpLcl ) )
	    {
		return psurf_int->lpLcl->lpGbl;
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }

    return NULL;

} /* FindGlobalPrimary */

#ifdef SHAREDZ
/*
 * FindGlobalZBuffer
 *
 * Traverses the driver object list and looks for a global shared Z. If it
 * finds one, it returns a pointer to the global portion of that surface.
 * If it doesn't, it returns NULL.
 *
 * NOTE: This function will return a shared Z buffer even if it has been lost.
 * However, it will only return a shared Z buffer if it was created in the
 * current mode. The idea being that there is one shared Z-buffer per mode
 * and we will only return the shared Z-buffer for the current mode.
 */
LPDDRAWI_DDRAWSURFACE_GBL FindGlobalZBuffer( LPDDRAWI_DIRECTDRAW_GBL this )
{
    LPDDRAWI_DIRECTDRAW_LCL	curr_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;

    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	if( curr_lcl->lpGbl == this )
	{
	    psurf_lcl = curr_lcl->lpSharedZ;
	    if( psurf_lcl && ( psurf_lcl->dwModeCreatedIn == this->dwModeIndex ) )
	    {
		return psurf_lcl->lpGbl;
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }

    return NULL;

} /* FindGlobalZBuffer */

/*
 * FindGlobalBackBuffer
 *
 * Traverses the driver object list and looks for a global shared back-buffer.
 * If it finds one, it returns a pointer to the global portion of that surface.
 * If it doesn't, it returns NULL.
 *
 * NOTE: This function will return a shared back buffer even if it has been lost.
 * However, it will only return a shared back buffer if it was created in the
 * current mode. The idea being that there is one shared back-buffer per mode and
 * we will only return the shared back-buffer for the current mode.
 */
LPDDRAWI_DDRAWSURFACE_GBL FindGlobalBackBuffer( LPDDRAWI_DIRECTDRAW_GBL this )
{
    LPDDRAWI_DIRECTDRAW_LCL	curr_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;

    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	if( curr_lcl->lpGbl == this )
	{
	    psurf_lcl = curr_lcl->lpSharedBack;
	    if( psurf_lcl && ( psurf_lcl->dwModeCreatedIn == this->dwModeIndex ) )
	    {
		return psurf_lcl->lpGbl;
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }

    return NULL;

} /* FindGlobalBackBuffer */
#endif

/*
 * MatchPrimary
 *
 * Traverses the driver object list and looks for valid primary surfaces.  If
 * a valid primary surface is found, it attempts to verify that the
 * surface described by lpDDSD is compatible with the existing primary.  If
 * it is, the process continues until all valid primary surfaces have been
 * checked.  If a primary surface is not compatible, lpDDSD is modified to
 * show a surface description which would have succeeded and FALSE is returned.
 */
BOOL MatchPrimary( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDSURFACEDESC2 lpDDSD )
{
    /*
     * right now, the only requirement for two primary surfaces to be
     * compatible is that they must both be allocated in video memory or in
     * system memory.  Traverse the driver object list until a valid primary
     * surface is found.  If a surface is found, verify that it is compatible
     * with the requested surface.  If no valid primary surface is found,
     * return TRUE.
     */
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	curr_lcl;

    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	/*
	 * is this object pointing to the same driver data?
	 */
	if( curr_lcl->lpGbl == pdrv )
	{
	    psurf_int = curr_lcl->lpPrimary;
	    if( psurf_int && !SURFACE_LOST( psurf_int->lpLcl ) )
	    {
		psurf_lcl = psurf_int->lpLcl;
		if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
		    (lpDDSD->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) )
		{
		    lpDDSD->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
		    lpDDSD->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
		    return FALSE;
		}
		if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
		    (lpDDSD->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
		{
		    lpDDSD->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
		    lpDDSD->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
		    return FALSE;
		}
		break;
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }
    return TRUE;

} /* MatchPrimary */

#ifdef SHAREDZ
/*
 * MatchSharedZBuffer
 *
 * Traverses the driver object list and looks for valid shared Z buffers.  If
 * a valid shared Z buffer is found, it attempts to verify that the
 * surface described by lpDDSD is compatible with the existing shared Z buffer.
 * If it is, the process continues until all valid shared Z buffers have been
 * checked.  If a shared Z buffer is not compatible, lpDDSD is modified to
 * show a surface description which would have succeeded and FALSE is returned.
 */
BOOL MatchSharedZBuffer( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDSURFACEDESC lpDDSD )
{
    /*
     * Currently we allow one shared Z-buffer per mode. So we don't care if we
     * don't match against any other shared Z-buffers in different modes. We
     * only need to match against shared Z-buffers created in the current mode.
     *
     * If we do come across another shared Z-buffer in the same mode then we
     * check to ensure that its in the same type of memory (SYSTEM or VIDEO)
     * and that the requested depths match.
     */
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf;
    LPDDRAWI_DIRECTDRAW_LCL	curr_lcl;
    LPDDPIXELFORMAT             lpddpf;

    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	/*
	 * is this object pointing to the same driver data?
	 */
	if( curr_lcl->lpGbl == pdrv )
	{
	    psurf_lcl = curr_lcl->lpSharedZ;
	    if( psurf_lcl && ( psurf_lcl->dwModeCreatedIn == pdrv->dwModeIndex ) )
	    {
		if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
		    (lpDDSD->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) )
		{
		    lpDDSD->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
		    lpDDSD->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
		    return FALSE;
		}
		if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
		    (lpDDSD->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
		{
		    lpDDSD->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
		    lpDDSD->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
		    return FALSE;
		}

                psurf = psurf_lcl->lpGbl;
                /*
                 * !!! NOTE: For when I finally get round to putting
                 * asserts in the code.
                 * ASSERT( psurf != NULL );
                 */
                GET_PIXEL_FORMAT( psurf_lcl, psurf, lpddpf );
                /*
                 * ASSERT( lpddpf != NULL );
                 * ASSERT( lpddpf->dwFlags & DDPF_ZBUFFER );
                 */
                if( lpddpf->dwZBufferBitDepth != lpDDSD->dwZBufferBitDepth )
                {
                    lpDDSD->dwZBufferBitDepth = lpddpf->dwZBufferBitDepth;
                    return FALSE;
                }
		break;
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }
    return TRUE;

} /* MatchSharedZBuffer */

/*
 * MatchSharedBackBuffer
 *
 * Traverses the driver object list and looks for valid shared back buffers.  If
 * a valid shared back buffer is found, it attempts to verify that the
 * surface described by lpDDSD is compatible with the existing shared back buffer.
 * If it is, the process continues until all valid shared back buffers have been
 * checked.  If a shared back buffer is not compatible, lpDDSD is modified to
 * show a surface description which would have succeeded and FALSE is returned.
 */
BOOL MatchSharedBackBuffer( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDSURFACEDESC lpDDSD )
{
    /*
     * Currently we allow one shared back-buffer per mode. So we don't care if we
     * don't match against any other shared back-buffers in different modes. We
     * only need to match against shared back-buffers created in the current mode.
     *
     * If we do come across another shared back-buffer in the same mode then we
     * check to ensure that its in the same type of memory (SYSTEM or VIDEO)
     * and that its pixel format matches.
     */
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf;
    LPDDRAWI_DIRECTDRAW_LCL	curr_lcl;
    LPDDPIXELFORMAT             lpddpf1;
    LPDDPIXELFORMAT             lpddpf2;

    if( lpDDSD->dwFlags & DDSD_PIXELFORMAT )
        lpddpf2 = &lpDDSD->ddpfPixelFormat;
    else
        lpddpf2 = &pdrv->vmiData.ddpfDisplay;

    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	/*
	 * is this object pointing to the same driver data?
	 */
	if( curr_lcl->lpGbl == pdrv )
	{
	    psurf_lcl = curr_lcl->lpSharedBack;
	    if( psurf_lcl && ( psurf_lcl->dwModeCreatedIn == pdrv->dwModeIndex ) )
	    {
		if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
		    (lpDDSD->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) )
		{
		    lpDDSD->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
		    lpDDSD->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
		    return FALSE;
		}
		if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
		    (lpDDSD->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
		{
		    lpDDSD->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
		    lpDDSD->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
		    return FALSE;
		}

                psurf = psurf_lcl->lpGbl;
                /*
                 * !!! NOTE: For when I finally get round to putting
                 * asserts in the code.
                 * ASSERT( psurf != NULL );
                 */
                GET_PIXEL_FORMAT( psurf_lcl, psurf, lpddpf1 );

                /*
                 * ASSERT( lpddpf1 != NULL );
                 */
                if( IsDifferentPixelFormat( lpddpf1, lpddpf2 ) )
                {
                    lpDDSD->dwFlags |= DDSD_PIXELFORMAT;
                    memcpy( &lpDDSD->ddpfPixelFormat, lpddpf1, sizeof( DDPIXELFORMAT ) );
                    return FALSE;
                }
		break;
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }
    return TRUE;

} /* MatchSharedBackBuffer */
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "PageLock"

/*
 * DD_Surface_PageLock
 *
 * Prevents a system memory surface from being paged out.
 */
HRESULT DDAPI DD_Surface_PageLock(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT			hr;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_PageLock");
    /* DPF_ENTERAPI(lpDDSurface); */

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

        if( dwFlags & ~DDPAGELOCK_VALID )
	{
	    DPF_ERR( "Invalid flags") ;
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

    // Don't pagelock video memory or emulated primary surface
    if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) &&
	!(this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
    {
	hr = InternalPageLock(this_lcl, pdrv_lcl);
    }
    else
    {
	// Succeed but don't do anything if surface has video memory
	// or if this is the emulated primary surface
	hr = DD_OK;
    }

    LEAVE_DDRAW();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "PageUnlock"

/*
 * DD_Surface_PageUnlock
 */
HRESULT DDAPI DD_Surface_PageUnlock(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT			hr;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_PageUnlock");

    /* DPF_ENTERAPI(lpDDSurface); */

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

        if( dwFlags & ~DDPAGEUNLOCK_VALID )
	{
	    DPF_ERR( "Invalid flags") ;
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    //
    // For now, if the current surface is optimized, quit
    //
    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
        DPF_ERR( "It is an optimized surface" );
        LEAVE_DDRAW();
        return DDERR_ISOPTIMIZEDSURFACE;
    }

    // Don't pageunlock video memory or emulated primary surface
    if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) &&
	!(this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
    {
	hr = InternalPageUnlock(this_lcl, pdrv_lcl);
    }
    else
    {
	// Succeed but don't do anything if surface has video memory
	// or if this is the emulated primary surface
	hr = DD_OK;
    }

    LEAVE_DDRAW();
    return hr;
}

/*
 * InternalPageLock
 *
 * Assumes driver lock is taken
 */

HRESULT InternalPageLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
			  LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    BOOL    rc;
    DWORD   cbReturned;
    DWORD   dwReturn;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE(this_lcl->lpGbl);

    struct _PLin
    {
	LPVOID	pMem;
	DWORD	cbBuffer;
	DWORD	dwFlags;
	LPDWORD pdwTable;
	LPDWORD	ppTable;
    } PLin;

#ifndef WINNT
    // If we're already locked; then just increment the count
    if( this_lcl->lpSurfMore->dwPageLockCount )
    {
        this_lcl->lpSurfMore->dwPageLockCount++;
	return DD_OK;
    }

    // Sanity Check
    DDASSERT( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY );
    DDASSERT( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) );

    // Initialize Parameters to pass to VXD
    PLin.pMem = (LPVOID)this_lcl->lpGbl->fpVidMem;
    DDASSERT( PLin.pMem );
    PLin.cbBuffer = this_lcl->lpSurfMore->dwBytesAllocated;
    DDASSERT( PLin.cbBuffer );
    PLin.dwFlags = 0;

    PLin.pdwTable = &lpSurfGblMore->dwPhysicalPageTable;
    PLin.ppTable = (LPDWORD) &lpSurfGblMore->pPageTable;

    DDASSERT( pdrv_lcl->hDDVxd );
    rc = DeviceIoControl( (HANDLE)(pdrv_lcl->hDDVxd),
        DDVXD_IOCTL_MEMPAGELOCK,
	&PLin,
	sizeof( PLin ),
	&dwReturn,
	sizeof( dwReturn ),
	&cbReturned,
	NULL );

    if( !rc )
    {
	lpSurfGblMore->dwPhysicalPageTable = 0;
	lpSurfGblMore->pPageTable = 0;
	lpSurfGblMore->cPages = 0;
	return DDERR_CANTPAGELOCK;
    }
    DDASSERT( cbReturned == sizeof(dwReturn));
    DDASSERT( *PLin.pdwTable && *PLin.ppTable );
    DDASSERT( lpSurfGblMore->dwPhysicalPageTable && lpSurfGblMore->pPageTable );

    // Massage Table
    {
	unsigned i;
	DWORD *rgdwPhysical = lpSurfGblMore->pPageTable;

	// Compute the number of pages
	DWORD cPages = (((DWORD)PLin.pMem & 0xFFF) + 0xFFF + PLin.cbBuffer)/4096;

	// Set the number of pages
	lpSurfGblMore->cPages = cPages;

	// Mask out the page-table flags
	for( i = 0; i < cPages; i++ )
	{
	    // Check that the page is present, user-accessible, and read/write
	    DDASSERT( rgdwPhysical[i] & 0x7 );
	    // Clear out the low bits
	    rgdwPhysical[i] &= 0xFFFFF000;
	}
	// Fix the first entry to point to the starting address
	rgdwPhysical[0] |= ((DWORD)PLin.pMem & 0xFFF);
    }

    this_lcl->lpSurfMore->dwPageLockCount++;
    DDASSERT( this_lcl->lpSurfMore->dwPageLockCount == 1 );

    // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF( 5, "Page Locked %d bytes at 0x%p (count=%d)", PLin.cbBuffer, PLin.pMem,
	this_lcl->lpSurfMore->dwPageLockCount );

#endif

    return DD_OK;
}

HRESULT InternalPageUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
			    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    BOOL    rc;
    DWORD   cbReturned;
    DWORD   dwReturn;
    struct _PLin
    {
	LPVOID	pMem;
	DWORD	cbBuffer;
	DWORD	dwFlags;
	LPDWORD pTable;
    } PLin;

#ifndef WINNT

    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE(this_lcl->lpGbl);

    DDASSERT( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY );
    DDASSERT( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) );

    if( this_lcl->lpSurfMore->dwPageLockCount <= 0 )
    {
	return DDERR_NOTPAGELOCKED;
    }

    // If we're already locked more than once; then just decrement the count
    if( this_lcl->lpSurfMore->dwPageLockCount > 1 )
    {
        this_lcl->lpSurfMore->dwPageLockCount--;
	return DD_OK;
    }

    /*
     * If it's a system memory surface, better wait for any pending DMA operations
     * to finish.
     */
    if( this_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
    {
        WaitForDriverToFinishWithSurface( pdrv_lcl, this_lcl );
    }

    PLin.pMem = (LPVOID)this_lcl->lpGbl->fpVidMem;
    DDASSERT( PLin.pMem );
    PLin.cbBuffer = this_lcl->lpSurfMore->dwBytesAllocated;
    DDASSERT( PLin.cbBuffer );
    PLin.dwFlags = 0;
    PLin.pTable = lpSurfGblMore->pPageTable;

    DDASSERT( pdrv_lcl->hDDVxd );
    rc = DeviceIoControl((HANDLE)(pdrv_lcl->hDDVxd),
        DDVXD_IOCTL_MEMPAGEUNLOCK,
	&PLin,
	sizeof( PLin ),
	&dwReturn,
	sizeof( dwReturn ),
	&cbReturned,
	NULL);

    if( !rc )
	return DDERR_CANTPAGEUNLOCK;
    DDASSERT( cbReturned == sizeof(dwReturn) );

    this_lcl->lpSurfMore->dwPageLockCount--;

    DDASSERT( this_lcl->lpSurfMore->dwPageLockCount == 0 );

    lpSurfGblMore->dwPhysicalPageTable = 0;
    lpSurfGblMore->pPageTable = 0;
    lpSurfGblMore->cPages = 0;

    // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF(5, "Page Unlocked %d bytes at 0x%p (count=%d)", PLin.cbBuffer, PLin.pMem,
	this_lcl->lpSurfMore->dwPageLockCount);

    // Increment a timestamp counter; this will help
    // a driver determine if the physical addresses have
    // changed between the time that they have cached it
    // and the time of the Blt/Render call
    lpSurfGblMore->cPageUnlocks++;

#endif

    return DD_OK;
}

HRESULT DDAPI DD_Surface_GetDDInterface(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPVOID FAR *lplpDD )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DIRECTDRAW_INT	pdrv_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetDDInterface");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	if( !VALID_PTR_PTR( lplpDD ) )
	{
	    DPF_ERR( "Invalid DirectDraw Interface ptr ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	pdrv_int = this_int->lpLcl->lpSurfMore->lpDD_int;
	*lplpDD = pdrv_int;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    // Addref the interface before giving it back to the app
    DD_AddRef( (LPDIRECTDRAW)pdrv_int );

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetDDInterface */

HRESULT InternalAssociateDC(
	HDC hdc,
	LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl )
{
    DCINFO *pdcinfo;

    DDASSERT( hdc != NULL );
    DDASSERT( pdds_lcl != NULL );

    pdcinfo = (DCINFO *)MemAlloc( sizeof( DCINFO ) );
    if( pdcinfo == NULL )
    {
	return DDERR_OUTOFMEMORY;
    }

    // initialize element
    pdcinfo->hdc = hdc;
    pdcinfo->pdds_lcl = pdds_lcl;

    // Add element to front of list
    pdcinfo->pdcinfoNext = g_pdcinfoHead;
    g_pdcinfoHead = pdcinfo;

    return DD_OK;
}

HRESULT InternalRemoveDCFromList(
	HDC hdc,
	LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl )
{
    // We may or may not have an hdc passed in.
    // However, this lets us do an error check for
    // some bad parameter cases.
    DCINFO *pdcinfo;
    DCINFO *pdcinfoPrev = NULL;

    DDASSERT( pdds_lcl != NULL );
    for( pdcinfo = g_pdcinfoHead; pdcinfo != NULL;
	    pdcinfoPrev = pdcinfo, pdcinfo = pdcinfo->pdcinfoNext )
    {
	DDASSERT( pdcinfo->pdds_lcl != NULL );

	if( pdds_lcl == pdcinfo->pdds_lcl || hdc == pdcinfo->hdc )
	{
	    // Check that punk & hdc are in synch -or-
	    // we didn't have an hdc passed in..
	    DDASSERT( hdc == NULL || (pdds_lcl == pdcinfo->pdds_lcl && hdc == pdcinfo->hdc) );

	    // Release this DC. We do this because it is dangerous
	    // to leave it around for windows to use because it points
	    // surface that we have just freed.
            //
            // However, don't release DCs that were created with the
            // GetDC flag since that is automatically cleaned up by
            // Windows. (Moreover, it wasn't allocated by DD16 who'll
            // get confused.)
	    if( hdc == NULL && !(pdds_lcl->dwFlags & DDRAWISURF_GETDCNULL) )
	    {
		DDASSERT( pdcinfo->hdc != NULL );
                // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		DPF( 1, "Releasing Leaked DC = 0x%p", pdcinfo->hdc );
#ifdef WIN95
		    DD16_ReleaseDC( pdcinfo->hdc );
#else
                    if( ( pdds_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY ) ||
                        !( pdds_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
                    {
	                DdReleaseDC( pdds_lcl );
                    }
#endif
            }

	    // Remove this dcinfo from the list.
	    if( pdcinfoPrev == NULL )
		g_pdcinfoHead = pdcinfo->pdcinfoNext;
	    else
		pdcinfoPrev->pdcinfoNext = pdcinfo->pdcinfoNext;

	    // Free this DcInfo
	    MemFree( pdcinfo );

	    return DD_OK;
	}
	// Not us? Then just sanity check the object we did find
	DDASSERT( pdcinfo->pdds_lcl->dwFlags & DDRAWISURF_HASDC );
    }

    DPF_ERR( "DC/Surface association not found?" );
    DDASSERT( 0 );
    return DDERR_NOTFOUND;
}

HRESULT InternalGetSurfaceFromDC(
	HDC hdc,
	LPDIRECTDRAWSURFACE *ppdds,
	HDC *phdcDriver,
        LPVOID pCallbacks)
{
    HRESULT ddrval = DDERR_INVALIDPARAMS;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: GetSurfaceFromDC");

    TRY
    {
	DCINFO *pdcinfo;

	if( !VALID_PTR_PTR( ppdds ) )
	{
	    DPF_ERR( "Invalid IDirectDrawSurface Interface ptr ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	// Default value
	*ppdds = NULL;
	*phdcDriver = NULL;

	ddrval = DDERR_GENERIC;

	for ( pdcinfo = g_pdcinfoHead; pdcinfo != NULL; pdcinfo = pdcinfo->pdcinfoNext )
	{
	    if( pdcinfo->hdc == hdc )
	    {
		DDASSERT( pdcinfo->pdds_lcl != NULL );
		DDASSERT( pdcinfo->pdds_lcl->dwFlags & DDRAWISURF_HASDC );
		*ppdds = (LPVOID)getDDSInterface( pdcinfo->pdds_lcl->lpGbl->lpDD,
			pdcinfo->pdds_lcl, pCallbacks );

		if( *ppdds == NULL )
		{
		    DPF_ERR( "GetSurfaceFromDC couldn't allocate interface" );
		    ddrval = DDERR_OUTOFMEMORY;
		}
		else
		{
		    *phdcDriver = (HDC)pdcinfo->pdds_lcl->lpSurfMore->lpDD_lcl->hDC;
    		    DD_Surface_AddRef( *ppdds );
		    ddrval = DD_OK;
		}
		LEAVE_DDRAW();
		return ddrval;
	    }
	}
	DPF( 1, "GetSurfaceFromDC didn't find HDC" );
	ddrval = DDERR_NOTFOUND;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	#ifdef DEBUG
	if (ddrval == DDERR_INVALIDPARAMS)
	    DPF_ERR( "Exception encountered validating parameters" );
	else
	{
	    DPF_ERR( "Unexpected error during GetSurfaceFromDC" );
	    DDASSERT( 0 );
	}
	#endif
    }

    LEAVE_DDRAW();
    return ddrval;
}

HRESULT EXTERN_DDAPI DD_GetSurfaceFromDC( LPDIRECTDRAW lpDD, HDC hdc, LPDIRECTDRAWSURFACE * pDDS)
{
    HDC     hdcTemp;
    lpDD;

    DPF(2,A,"ENTERAPI: DD_GetSurfaceFromDC");

    if (LOWERTHANDDRAW7( ((LPDDRAWI_DIRECTDRAW_INT)lpDD)) )
        return InternalGetSurfaceFromDC(hdc, pDDS, &hdcTemp, &ddSurfaceCallbacks);

    return InternalGetSurfaceFromDC(hdc, pDDS, &hdcTemp, &ddSurface7Callbacks);

}

HRESULT EXTERN_DDAPI GetSurfaceFromDC(
	HDC hdc,
	LPDIRECTDRAWSURFACE *ppdds,
	HDC *phdcDriver )
{
    return InternalGetSurfaceFromDC(hdc, ppdds, phdcDriver, (LPVOID) &ddSurfaceCallbacks );
}

#ifdef WIN95

void InitColorTable( RGBQUAD *rgColors, LPPALETTEENTRY lpPalette )
{
    int i;

    for( i = 0; i < 256; i++ )
    {
	rgColors[i].rgbBlue = lpPalette[i].peBlue;
	rgColors[i].rgbGreen = lpPalette[i].peGreen;
	rgColors[i].rgbRed = lpPalette[i].peRed;
	rgColors[i].rgbReserved = 0;
    }
    return;
}
// This function walks the list of outstanding DCs and figures out
// if the DC's colortable needs to be updated. It may be called in two ways:
//
// surface+pal -> this means that pal was attached to a surface
// just a surface -> this means that a palette was removed from a surface
void UpdateOutstandingDC( LPDDRAWI_DDRAWSURFACE_LCL psurf_lcl, LPDDRAWI_DDRAWPALETTE_GBL ppal_gbl )
{
    BOOL		fColorsInited = FALSE;
    RGBQUAD		rgColors[256];
    PALETTEENTRY	rgPalEntry[256];
    LPDDPIXELFORMAT	pddpf;
    DCINFO		*pdcinfo;
    LPDDPIXELFORMAT	pddpf_curr;

    DDASSERT( psurf_lcl );

    // Quick check to see if there are any DCs outstanding
    // If not, then we don't have to do all this work
    if( g_pdcinfoHead == NULL )
	return;

    GET_PIXEL_FORMAT( psurf_lcl, psurf_lcl->lpGbl, pddpf );

    // Ignore non-8bit surfaces
    if( !(pddpf->dwFlags & DDPF_PALETTEINDEXED8) )
	return;

    if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) )
    {
        // Primary?
	// If it is, then we need to find all the outstanding
	// DCs that are sharing the palette; and update them
	for ( pdcinfo = g_pdcinfoHead; pdcinfo != NULL; pdcinfo = pdcinfo->pdcinfoNext )
	{
	    DDASSERT( pdcinfo->pdds_lcl != NULL );
	    DDASSERT( pdcinfo->pdds_lcl->dwFlags & DDRAWISURF_HASDC );

	    GET_PIXEL_FORMAT( pdcinfo->pdds_lcl, pdcinfo->pdds_lcl->lpGbl, pddpf_curr );

	    // Ignore non palette-indexed 8-bit surfaces
	    if( !(pddpf_curr->dwFlags & DDPF_PALETTEINDEXED8) )
		continue;

	    // Ignore DCs handed out by other direct draw interfaces
	    if( pdcinfo->pdds_lcl->lpGbl->lpDD != psurf_lcl->lpGbl->lpDD )
		continue;

	    // Ignore surfaces that have their own palettes
	    // (except for our surface that is..)
	    if( pdcinfo->pdds_lcl->lpDDPalette != NULL &&
		pdcinfo->pdds_lcl != psurf_lcl )
		continue;

	    // We don't need to touch palettes that are of the
	    // DCNULL kind (it's already been updated
	    // because the DC isn't one of the ones we cooked ourselves)
	    if( pdcinfo->pdds_lcl->dwFlags & DDRAWISURF_GETDCNULL )
		continue;

	    // Ok, this DC needs updating
            // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF( 3, "Updating colortable for HDC(0x%p)", pdcinfo->hdc );

	    // Have we init'ed our colors?
	    if( !fColorsInited )
	    {
		if( ppal_gbl && ppal_gbl->dwFlags & DDRAWIPAL_EXCLUSIVE )
		{
		    // If we're exclusive then use our colors as is
		    InitColorTable( rgColors, ppal_gbl->lpColorTable );
		}
		else
		{
		    // Else, use the colors from current system palette
		    int n = GetSystemPaletteEntries( (HDC)psurf_lcl->lpSurfMore->lpDD_lcl->hDC,
			    0, 256, rgPalEntry );
		    DDASSERT( n == 256 );
		    InitColorTable( rgColors, rgPalEntry );
		}
    		fColorsInited = TRUE;
	    }
	    // Set the colors into the DC, this will have the
	    // extra effect of resetting any cached translation tables
	    // so GDI won't use a wrong one inadvertently.
	    DPF(5, "Dib Color Table entry #50 == 0x%x", rgColors[50]);
	    SetDIBColorTable( pdcinfo->hdc, 0, 256, rgColors);
	}
    }
    else
    {
	// Ordinary surface? Then find it in our list
	for ( pdcinfo = g_pdcinfoHead; pdcinfo != NULL; pdcinfo = pdcinfo->pdcinfoNext )
	{
	    DDASSERT( pdcinfo->pdds_lcl != NULL );
	    DDASSERT( pdcinfo->pdds_lcl->dwFlags & DDRAWISURF_HASDC );

	    // Ignored surfaces that have different global objects
	    if( pdcinfo->pdds_lcl->lpGbl != psurf_lcl->lpGbl )
		continue;

	    // Ignore non palette-indexed 8-bit surfaces
	    GET_PIXEL_FORMAT( pdcinfo->pdds_lcl, pdcinfo->pdds_lcl->lpGbl, pddpf_curr );
	    if( !(pddpf_curr->dwFlags & DDPF_PALETTEINDEXED8) )
		continue;

	    // Ok, this DC needs updating
            // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF( 3, "Updating colortable for non-primary HDC(0x%p)", pdcinfo->hdc );

	    if( !fColorsInited )
	    {
		if( ppal_gbl )
		{
		    // New color table for this offscreen surface?
		    // Use them directly
	    	    InitColorTable( rgColors, ppal_gbl->lpColorTable );
		    fColorsInited = TRUE;
		}
		else
		{
		    int n;

		    // Someone is removing a palette from an offscreen surface?
		    // Then if the primary is at 8bpp, then we should
		    // steal the colors from it.
		    LPDDRAWI_DDRAWSURFACE_INT lpPrimary = pdcinfo->pdds_lcl->lpSurfMore->lpDD_lcl->lpPrimary;
		    if( lpPrimary )
		    {
			// Check that the primary is 8bpp. If it is not,
			// then we leave this surface alone.
			GET_PIXEL_FORMAT( lpPrimary->lpLcl, lpPrimary->lpLcl->lpGbl, pddpf_curr );

			if( !(pddpf_curr->dwFlags & DDPF_PALETTEINDEXED8) )
			    return;
		    }
		    else
		    {
			// There is no primary surface attached to this
			// DDraw. So we have no where useful to get colors from
			// so return.
			return;
		    }

		    DDASSERT( lpPrimary != NULL );
		    DDASSERT( pddpf_curr->dwFlags & DDPF_PALETTEINDEXED8 );

		    // Else, use the colors from current system palette
		    n = GetSystemPaletteEntries( (HDC)lpPrimary->lpLcl->lpSurfMore->lpDD_lcl->hDC,
			    0, 256, rgPalEntry );
		    DDASSERT( n == 256 );
		    InitColorTable( rgColors, rgPalEntry );

		}
	    }

	    // Set the colors into the DC, this will have the
	    // extra effect of reseting any cached translation tables
	    // so GDI won't use a wrong one inadvertantly.
	    DPF(5, "Dib Color Table entry #50 == 0x%x", rgColors[50]);
	    SetDIBColorTable( pdcinfo->hdc, 0, 256, rgColors);
	}
    }

    return;
}

// This function handles the case when the entries of a
// palette have changed. We need to search for all the surfaces
// that may be affected and do something. However, we only

void UpdateDCOnPaletteChanges( LPDDRAWI_DDRAWPALETTE_GBL ppal_gbl )
{
    DCINFO		*pdcinfo;
    DDASSERT( ppal_gbl != NULL );

    // Quick check to see if there are any DCs outstanding
    // If not, then we don't have to do all this work
    if( g_pdcinfoHead == NULL )
	return;

    // Is this palette attached to our primary?
    // We have to do this explicitly without regard to the outstanding
    // DC list because the primary itself may have no outstanding DCs
    // but offscreen surfaces may be logically 'sharing' the primary's palette
    if( ppal_gbl->lpDD_lcl->lpPrimary &&
	ppal_gbl->lpDD_lcl->lpPrimary->lpLcl->lpDDPalette &&
	ppal_gbl->lpDD_lcl->lpPrimary->lpLcl->lpDDPalette->lpLcl->lpGbl == ppal_gbl )
    {
	// Update the palette for DCs associated with this primary
	UpdateOutstandingDC( ppal_gbl->lpDD_lcl->lpPrimary->lpLcl, ppal_gbl );
    }

    // We walk all outstanding DCs looking for
    // surfaces that are DIRECTLY affected this set entries.
    for ( pdcinfo = g_pdcinfoHead; pdcinfo != NULL; pdcinfo = pdcinfo->pdcinfoNext )
    {
	DDASSERT( pdcinfo->pdds_lcl != NULL );
	DDASSERT( pdcinfo->pdds_lcl->dwFlags & DDRAWISURF_HASDC );

	// Ignore surfaces that don't have a palette;
	// (If a surface doesn't have a palette, then that means
	// it's using the palette from the primary. We handle that case
	// above when we deal with the primary.)
	if( pdcinfo->pdds_lcl->lpDDPalette == NULL )
	    continue;

	// Ignore surfaces that aren't connected to us
	if( pdcinfo->pdds_lcl->lpDDPalette->lpLcl->lpGbl != ppal_gbl )
	    continue;

	// Ignore the primary that we already updated above
	if( ppal_gbl->lpDD_lcl->lpPrimary &&
	    ppal_gbl->lpDD_lcl->lpPrimary->lpLcl == pdcinfo->pdds_lcl )
	    continue;

	UpdateOutstandingDC( pdcinfo->pdds_lcl, ppal_gbl );
    }

    return;
}
#endif /* WIN95 */

#undef DPF_MODNAME
#define DPF_MODNAME "GetTopLevel"

LPDDRAWI_DDRAWSURFACE_LCL GetTopLevel(LPDDRAWI_DDRAWSURFACE_LCL lpLcl)
{
    // loop to find the top level surface of a mipmap chain
    for(; (lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL) != 0; 
        lpLcl = lpLcl->lpAttachListFrom->lpAttached);

    // if the top level surface is a cubemap face
    if((lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) != 0)
        // then we need to return the top level surface of the cubemap
        // The assumption here is that a cubemap is only one level deep
        // and a cubemap subface is attached from ONLY a cubemap top level face
        if(lpLcl->lpAttachListFrom != NULL)
            lpLcl = lpLcl->lpAttachListFrom->lpAttached;

    return lpLcl;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DD_Surface_SetSurfaceDesc"

/*
 * NOTE: There is a significant amount of code in this function that
 * deals with video memory surfaces yet you will notice a check explicitly
 * failing this function for surfaces which are not explicit system
 * memory. This is deliberate. The intention is to mutate this function
 * to work with video memory surfaces over time. The code is in place
 * to start this process however unresolved issues remain.
 */

HRESULT DDAPI DD_Surface_SetSurfaceDesc(
		LPDIRECTDRAWSURFACE3 lpDDSurface,
		LPDDSURFACEDESC      lpddsd,
		DWORD                dwFlags )
{
    DDSURFACEDESC2 ddsd2 = {sizeof(ddsd2)};

    DPF(2,A,"ENTERAPI: DD_Surface_SetSurfaceDesc");

    ZeroMemory(&ddsd2,sizeof(ddsd2));

    TRY
    {
	if( !VALID_DIRECTDRAWSURFACE_PTR( ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface) ) )
	{
	    DPF_ERR( "Invalid surface description passed" );
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
	    return DDERR_INVALIDOBJECT;
	}

	if( 0UL != dwFlags )
	{
	    DPF_ERR( "No flags are currently specified - 0 must be passed" );
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	    return DDERR_INVALIDPARAMS;
	}

	if( !VALID_DDSURFACEDESC_PTR( lpddsd ) )
	{
	    DPF_ERR( "Invalid surface description. Did you set the dwSize member?" );
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	    return DDERR_INVALIDPARAMS;
	}

        memcpy(&ddsd2,lpddsd,sizeof(*lpddsd));
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters: Bad LPDDSURFACEDESC" );
        DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	return DDERR_INVALIDPARAMS;
    }

    ddsd2.dwSize = sizeof(ddsd2);

    return DD_Surface_SetSurfaceDesc4(lpDDSurface, &ddsd2, dwFlags);
}

HRESULT DDAPI DD_Surface_SetSurfaceDesc4(
		LPDIRECTDRAWSURFACE3 lpDDSurface,
		LPDDSURFACEDESC2      lpddsd,
		DWORD                dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_INT	pdrv_int;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    BOOL                        emulation;
    DWORD                       dwDummyFlags;
    HRESULT                     ddres;
    DDSURFACEDESC2              ddsd;
    DDHAL_CANCREATESURFACEDATA	ccsd;
    LPDDHAL_CANCREATESURFACE	ccsfn;
    LPDDHAL_CANCREATESURFACE	ccshalfn;
    WORD                        wOldWidth;
    WORD                        wOldHeight;
    LONG                        lOldPitch;
    DDPIXELFORMAT               ddpfOldPixelFormat;
    BOOL                        bIsCompressedTexture = FALSE;
    WORD                        realwidth;
    WORD                        realheight;
    DWORD                       realsurfsize;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetSurfaceDesc4");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface description passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );
	this = this_lcl->lpGbl;
	DDASSERT( NULL != this );
	pdrv_int = this_lcl->lpSurfMore->lpDD_int;
	DDASSERT( NULL != pdrv_int );
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	DDASSERT( NULL != pdrv_lcl );
	pdrv = pdrv_lcl->lpGbl;
	DDASSERT( NULL != pdrv );

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( 0UL != dwFlags )
	{
	    DPF_ERR( "No flags are currently specified - 0 must be passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( !VALID_DDSURFACEDESC2_PTR( lpddsd ) )
	{
	    DPF_ERR( "Surface description is invalid" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( SURFACE_LOST( this_lcl ) )
	{
	    DPF_ERR( "Could not set surface pointer - surface is lost" );
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	if( this->dwUsageCount > 0UL )
	{
	    DPF_ERR( "Could not set surface pointer - surface is locked" );
	    LEAVE_DDRAW();
	    return DDERR_SURFACEBUSY;
	}

	/*
	 * Currently we don't allow anything but explicit system memory surfaces to
	 * have thier surface description (and pointer modified).
	 */
	#pragma message( REMIND( "Look into making SetSurfaceDesc work for video memory" ) )
	if( !( this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED ) )
	{
	    DPF_ERR( "Could not set surface pointer - surface is not explicit system memory" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDSURFACETYPE;
	}
	DDASSERT( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY );

	if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE     ) ||
	    ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACELEFT ) ||
	    ( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY            ) ||
	    ( this_lcl->ddsCaps.dwCaps & DDSCAPS_ALLOCONLOAD        ) ||
            ( this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE  ) ||
            ( this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_D3DTEXTUREMANAGE  ))
	{
	    DPF_ERR( "Could not set surface pointer - surface is primary, overlay or device specific" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDSURFACETYPE;
	}

	/*
	 * Don't mess with anything that is part of the primary chain. That could get
	 * very nasty (destroying the primary surface pointer and replacing it with
	 * some app. specific garbage).
	 */
	if( this_lcl->dwFlags & DDRAWISURF_PARTOFPRIMARYCHAIN )
	{
	    DPF_ERR( "Cannot set surface pointer - surface is part of the primary chain" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDSURFACETYPE;
	}

	if( lpddsd->dwFlags & ~( DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH |
				 DDSD_LPSURFACE | DDSD_PIXELFORMAT ) )
	{
	    DPF_ERR( "Can only specify caps, width, height, pitch, surface ptr and pixel format" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( ( lpddsd->dwFlags & DDSD_WIDTH ) && ( 0UL == lpddsd->dwWidth ) )
	{
	    DPF_ERR( "Invalid surface width specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( ( lpddsd->dwFlags & DDSD_HEIGHT ) && ( 0UL == lpddsd->dwHeight ) )
	{
	    DPF_ERR( "Invalid surface height specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( ( lpddsd->dwFlags & DDSD_PITCH ) && (( lpddsd->lPitch <= 0L ) || (lpddsd->lPitch % 4)) )
	{
	    DPF_ERR( "Invalid surface pitch specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( lpddsd->dwFlags & DDSD_PIXELFORMAT )
	{
	    if( !( this_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT ) )
	    {
		/*
		 * This is very cheesy but the alternative is pretty nasty.
		 * Reallocting the global object with a pixel format if it
		 * does not already have one.
		 */
		DPF_ERR( "Cannot change the pixel format of a surface which does not have one" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }

	    if( !VALID_DDPIXELFORMAT_PTR( ( &(this->ddpfSurface) ) ) )
	    {
		DPF_ERR( "Specifed pixel format is invalid" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}

	if( ( ( lpddsd->dwFlags & DDSD_WIDTH ) && !( lpddsd->dwFlags & DDSD_PITCH ) ) ||
	    ( ( lpddsd->dwFlags & DDSD_PITCH ) && !( lpddsd->dwFlags & DDSD_WIDTH ) ) )
	{
	    DPF_ERR( "If width or pitch is specified then both width AND pitch must be specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( !( lpddsd->dwFlags & DDSD_LPSURFACE ) )
	{
	    DPF_ERR( "Must specify a surface memory pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( NULL == lpddsd->lpSurface )
	{
	    DPF_ERR( "Surface memory pointer can't be NULL" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

        if( lpddsd->dwFlags & DDSD_CAPS )
	{
	    if( lpddsd->ddsCaps.dwCaps != 0 )
	    {
		DPF_ERR( "Illegal to set ddsCaps.dwCaps bits in surface desc" );
		LEAVE_DDRAW();
		return DDERR_INVALIDCAPS;
	    }

#if 0 // DDSCAPS2_LOCALALLOC, DDSCAPS2_COTASKMEM and DDRAWISURFGBL_DDFREESCLIENTMEM are gone
	    if( lpddsd->ddsCaps.dwCaps2 & ~(DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM) )
	    {
		DPF_ERR( "The only legal DDSCAPS2 flags are LOCALALLOC and COTASKMEM" );
		LEAVE_DDRAW();
		return DDERR_INVALIDCAPS;
	    }

	    if( !(~lpddsd->ddsCaps.dwCaps2 & (DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM)) )
	    {
		// Illegal to set LOCALALLOC and COTASKMEM flags simultaneously.
		DPF_ERR( "DDSCAPS2 flags LOCALALLOC and COTASKMEM are mutually exclusive" );
		LEAVE_DDRAW();
		return DDERR_INVALIDCAPS;
	    }
#endif // 0

	    if( lpddsd->ddsCaps.dwCaps3 != 0 )
	    {
		DPF_ERR( "Illegal to set ddsCaps.dwCaps3 bits in surface desc" );
		LEAVE_DDRAW();
		return DDERR_INVALIDCAPS;
	    }

	    if( lpddsd->ddsCaps.dwCaps4 != 0 )
	    {
		DPF_ERR( "Illegal to set ddsCaps.dwCaps4 bits in surface desc" );
		LEAVE_DDRAW();
		return DDERR_INVALIDCAPS;
	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Build a new surface description for the surface and fill in
     * the new width, height and pitch.
     */
    FillDDSurfaceDesc2( this_lcl, &ddsd );
    if( lpddsd->dwFlags & DDSD_WIDTH )
	ddsd.dwWidth   = lpddsd->dwWidth;
    if( lpddsd->dwFlags & DDSD_HEIGHT )
	ddsd.dwHeight  = lpddsd->dwHeight;
    if( lpddsd->dwFlags & DDSD_PITCH )
	ddsd.lPitch    = lpddsd->lPitch;
    if( lpddsd->dwFlags & DDSD_PIXELFORMAT )
	ddsd.ddpfPixelFormat = lpddsd->ddpfPixelFormat;

    emulation = ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY;

    /*
     * Validate that the new surface description makes some remote kind of
     * sense.
     */
    ddres = checkSurfaceDesc( &ddsd,
	                      pdrv,
			      &dwDummyFlags,
			      emulation,
			      this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED,
			      pdrv_int );
    if( FAILED( ddres ) )
    {
	DPF_ERR( "Invalid surface description passed" );
	LEAVE_DDRAW();
	return ddres;
    }

    /*
     * Ask the driver if it likes the look of this surface. We need to ask
     * the driver again (even though we already did it when the surface was
     * created) as the surface has changed size.
     */
    if( emulation )
    {
        if( ddsd.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
	    ccsfn = pdrv_lcl->lpDDCB->HELDDExeBuf.CanCreateExecuteBuffer;
        }
        else
        {
	    ccsfn = pdrv_lcl->lpDDCB->HELDD.CanCreateSurface;
        }
    	ccshalfn = ccsfn;
    }
    else
    {
        if( ddsd.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            ccsfn    = pdrv_lcl->lpDDCB->HALDDExeBuf.CanCreateExecuteBuffer;
    	    ccshalfn = pdrv_lcl->lpDDCB->cbDDExeBufCallbacks.CanCreateExecuteBuffer;
        }
        else
        {
            ccsfn    = pdrv_lcl->lpDDCB->HALDD.CanCreateSurface;
    	    ccshalfn = pdrv_lcl->lpDDCB->cbDDCallbacks.CanCreateSurface;
        }
    }

    if( ccshalfn != NULL )
    {
	BOOL    is_diff;
	HRESULT rc;

	if( ddsd.dwFlags & DDSD_PIXELFORMAT )
	{
	    is_diff = IsDifferentPixelFormat( &pdrv->vmiData.ddpfDisplay, &ddsd.ddpfPixelFormat );
	}
	else
	{
	    is_diff = FALSE;
	}
    	ccsd.CanCreateSurface        = ccshalfn;
	ccsd.lpDD                    = pdrv;
	ccsd.lpDDSurfaceDesc         = (LPDDSURFACEDESC)&ddsd;
	ccsd.bIsDifferentPixelFormat = is_diff;
        if( ddsd.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
	    DOHALCALL( CanCreateExecuteBuffer, ccsfn, ccsd, rc, emulation );
        }
        else
        {
	    DOHALCALL( CanCreateSurface, ccsfn, ccsd, rc, emulation );
        }
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( ccsd.ddRVal != DD_OK )
	    {
		DPF_ERR( "Driver says surface can't be created" );
		LEAVE_DDRAW();
		return ccsd.ddRVal;
	    }
	}
    }

    /*
     * Stash away the surface settings to we can put them back if anything
     * foes wrong.
     *
     * NOTE: We don't store away the heap or vid mem pointer if an error happens
     * after this point the surface ends up lost and will need to be restored.
     */
    wOldWidth  = this->wWidth;
    wOldHeight = this->wHeight;
    lOldPitch  = this->lPitch;
    if( this_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	ddpfOldPixelFormat = this->ddpfSurface;

    /* There could be pending TexBlts and stuff, so Sync with the token stream */
    FlushD3DStates( this_lcl );

    /*
     * The driver has okayed the creation so toast the existing surface memory.
     */
    DestroySurface( this_lcl );

    /*
     *  Remove any cached RLE stuff for source surface
     */
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
    {
	extern void FreeRleData(LPDDRAWI_DDRAWSURFACE_LCL);  //in junction.c

	FreeRleData( this_lcl );
    }

    /*
     * Now mutate the surface into its new form. Kind of spooky isn't it... a bit
     * like The Fly. Stash away the original settings in case we need to put them back
     * if something goes wrong.
     */
    if( lpddsd->dwFlags & DDSD_WIDTH )
	this->wWidth    = (WORD)lpddsd->dwWidth;
    if( lpddsd->dwFlags & DDSD_HEIGHT )
	this->wHeight   = (WORD)lpddsd->dwHeight;
    if( lpddsd->dwFlags & DDSD_PITCH )
	this->lPitch    = lpddsd->lPitch;
    if( lpddsd->dwFlags & DDSD_PIXELFORMAT )
    {
	this->ddpfSurface = lpddsd->ddpfPixelFormat;
	// Now that the pixel format may have changed, we need to reset the pixel-format
	// index that was previously cached by the HEL's AlphaBlt emulation routine.
	this_lcl->lpSurfMore->dwPFIndex = PFINDEX_UNINITIALIZED;
	// ATTENTION:  If pixel format has changed, are old color keys still valid?
    }
    this->lpVidMemHeap  = NULL;
    this->fpVidMem      = (FLATPTR)lpddsd->lpSurface;
#if 0 // DDRAWISURFGBL_DDFREESCLIENTMEM is gone
    this->dwGlobalFlags &= ~(DDRAWISURFGBL_MEMFREE | DDRAWISURFGBL_DDFREESCLIENTMEM);
#else
    this->dwGlobalFlags &= ~(DDRAWISURFGBL_MEMFREE);
#endif // 0
    this->dwGlobalFlags |= DDRAWISURFGBL_ISCLIENTMEM;
    this_lcl->dwFlags   &= ~DDRAWISURF_INVALID;
#if 0 // DDSCAPS2_LOCALALLOC, DDSCAPS2_COTASKMEM and DDRAWISURFGBL_DDFREESCLIENTMEM are gone
    this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~(DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM);

    if( lpddsd->dwFlags & DDSD_CAPS &&
            lpddsd->ddsCaps.dwCaps2 & (DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM) )
    {
	/*
	 * Remember that DirectDraw will be responsible for freeing the
	 * client-allocated surface memory when it's no longer needed.
	 */
	this->dwGlobalFlags |= DDRAWISURFGBL_DDFREESCLIENTMEM;

	this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 |=
			lpddsd->ddsCaps.dwCaps2 & (DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM);
    }
#endif // 0

    #ifdef USE_ALIAS
    {
	/*
	 * If this is a video memory surface then we need to recompute the alias offset of
	 * the surface for locking purposes.
	 */
	LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

	lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE( this );
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
        {
	    lpGblMore->fpAliasedVidMem = GetAliasedVidMem( pdrv_lcl, this_lcl, this_lcl->lpGbl->fpVidMem );
            // If we succeeded in getting an alias, cache it for future use. Also store the original
            // fpVidMem to compare with before using the cached pointer to make sure the cached value
            // is still valid
            if (lpGblMore->fpAliasedVidMem)
                lpGblMore->fpAliasOfVidMem = this_lcl->lpGbl->fpVidMem;
            else
                lpGblMore->fpAliasOfVidMem = 0;
        }
	else
        {
	    lpGblMore->fpAliasedVidMem = 0UL;
            lpGblMore->fpAliasOfVidMem = 0UL;
        }
    }
    #endif /* USE_ALIAS */

#if 0
    if( lpddsd->dwFlags & DDSD_LPSURFACE )
    {
#endif //0
        /*
         * Set the access counter to zero (which means ddraw has no information on the moment
         * to moment contents of the surface, so the driver should not cache).
         */
        GET_LPDDRAWSURFACE_GBL_MORE(this)->dwContentsStamp = 0;
#if 0
    }
    else
    {
        /*
         * Something probably changed
         */
        BUMP_SURFACE_STAMP(this);
    }
#endif //0

    #ifdef WINNT

    // The DDCreateSurfaceObject call fails when we
    // specify a FOURCC system memory surface with pitch = 0
    // and bits/pixel = 0.  We must ensure these parameters
    // are nonzero for the call.

    if ((this_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
        (this->ddpfSurface.dwFlags & DDPF_FOURCC) &&
        (GetDxtBlkSize(this->ddpfSurface.dwFourCC) != 0))
    {
        LONG blksize;
        WORD dx, dy;

        /*
         * This surface uses a FOURCC format that we understand.
         * Figure out how much memory we allocated for it.
         */
        blksize = GetDxtBlkSize(this->ddpfSurface.dwFourCC);
        DDASSERT(blksize != 0);

        DDASSERT(this->ddpfSurface.dwRGBBitCount == 0);
        DDASSERT(this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE);

        bIsCompressedTexture = TRUE;

        // Save the surface's real width and height so we can restore them.
        realwidth = this->wWidth;
        realheight = this->wHeight;
        realsurfsize = this->dwLinearSize;  // union with lPitch

        // The NT kernel won't let us create this surface unless we lie.
        // We have to make up a width, height, pitch, and pixel size
        // that GDI will accept as valid.
        dx = (WORD)((realwidth  + 3) >> 2);   // number of 4x4 blocks in a row
        dy = (WORD)((realheight + 3) >> 2);   // number of 4x4 blocks in a column

        this->wHeight = dy;                    // lie about height
        this->lPitch = dx*blksize;             // lie about pitch
        this->wWidth = (WORD)this->lPitch;   // lie about width
        this->ddpfSurface.dwRGBBitCount = 8;   // lie about pixel size

        // GDI will reserve lpsurf->wWidth*lpsurf->lPitch bytes of virtual
        // memory for the surface.  This had better be equal to the amount
        // of memory we actually allocated for the surface.  What a pain.
        DDASSERT(this_lcl->lpSurfMore->dwBytesAllocated ==
                                    (DWORD)this->wHeight*this->lPitch);
    }
    else if ((this->ddpfSurface.dwFourCC == MAKEFOURCC('U','Y','V','Y')) ||
             (this->ddpfSurface.dwFourCC == MAKEFOURCC('Y','U','Y','2')))
    {
        // These formats are really 8bpp; so we need to adjust
        // the bits-per-pixel parameter to make NT happy
        this->ddpfSurface.dwRGBBitCount = 16;
    }

    /*
     * We deleted the surface object above, so we must create a new
     * surface object before we return.  
     */
    if (!DdCreateSurfaceObject(this_lcl, FALSE))
    {
        if(!(DDSCAPS_SYSTEMMEMORY & this_lcl->ddsCaps.dwCaps))
        {
            DPF_ERR("GDI failed to create surface object!");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    if (bIsCompressedTexture)
    {
        // Restore the FOURCC surface's actual width, height, etc.
        this->wWidth = (WORD)realwidth;
        this->wHeight = (WORD)realheight;
        this->dwLinearSize = realsurfsize;
    }

    //(Fix for Manbug 40941)-->
    // The delete also killed any attachments the kernel may have to neighbouring surfaces.
    //If this is a mipmap, then we need to recreate the attachments now, before the CSEx
    //is called.
    //ISSUE: This fix doesn't address:
    //  -cubemaps or other more complex attachments
    //  -How do we guarantee the right linked list order in the kernel? We'll have
    //   to destroy all attachments, then re-attach them again. (The app in question runs
    //   the mipmap chain in the correct order to re-create attachments in the kernel's
    //   linked list in the right order.)

    // let the kernel know about the attachment only if the driver isn't emulated...
    if ( pdrv->hDD )
    {
        LPATTACHLIST		pal;

        // The current surface has been disassociated from the two
        // neighbouring levels. We need to repair two attachments:
        // the next highst level to this level, and then this level
        // to the next lowest level.
        pal = this_lcl->lpAttachList;

        if(pal) //while(pal) might be a better fix
        {
            DdAttachSurface( this_lcl, pal->lpAttached );
        }

        pal = this_lcl->lpAttachListFrom;

        if(pal) //while(pal) might be a better fix
        {
            DdAttachSurface( pal->lpAttached, this_lcl );
        }
    }
    //<--(End fix for Manbug 40941)

#endif //WINNT

    if(this_lcl->lpSurfMore->dwSurfaceHandle != 0)
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl = GetTopLevel(this_lcl);
        HRESULT HRet;
        DDASSERT( pdrv_lcl == lpLcl->lpSurfMore->lpDD_lcl);
        HRet = createsurfaceEx(lpLcl);
        if (DD_OK != HRet)
        {
            LEAVE_DDRAW();
            return HRet;
        }           
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DD_Surface_SetSurfaceDesc */


/*
 * GetNextMipMap
 */
LPDIRECTDRAWSURFACE GetNextMipMap(
    LPDIRECTDRAWSURFACE lpLevel)
{
    DDSCAPS                     ddsCaps;
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;
    LPATTACHLIST		pal;

    if (!lpLevel)
        return NULL;

    lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpLevel)->lpLcl;

    ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
    pal = lpLcl->lpAttachList;
    while( pal != NULL )
    {
        if ( ((pal->lpAttached->ddsCaps.dwCaps) & (DDSCAPS_TEXTURE | DDSCAPS_MIPMAP))
            == (DDSCAPS_TEXTURE | DDSCAPS_MIPMAP) )
        {
            /*
             * Got both the right caps
             */
            return (LPDIRECTDRAWSURFACE) pal->lpIAttached;
        }
        pal = pal->lpLink;
    }
    return NULL;
}

/*
 * LateAllocateSurfaceMem
 *
 * Called by the D3D to allocate memory for a compressed surface.
 * The input lpDDSurface must have certain state:
 * -DDSCAPS_VIDEOMEMORY or DDSCAPS_SYSTEMMEMORY are allowed.
 * -DDSCAPS_OPTIMIZED required.
 * -fpVidMem must be either DDHAL_PLEASEALLOC_BLOCKSIZE, DDHAL_PLEASEALLOC_NOMEMORY or DDHAL_PLEASEALLOC_LINEARSIZE
 *    -If BLOCKSIZE, the blocksizes must be filled,
 *    -If LINEARSIZE, the dwLinearSize must be filled.
 *    -If LINEARSIZE is specified. Only the linear heaps will be traversed.
 */
#undef DPF_MODNAME
#define DPF_MODNAME "LateAllocateSurfaceMem"
HRESULT DDAPI LateAllocateSurfaceMem(LPDIRECTDRAWSURFACE lpDDSurface, DWORD dwAllocationType, DWORD dwWidthOrSize, DWORD dwHeight)
{
    HRESULT                     ddrval;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
    LPDDRAWI_DDRAWSURFACE_LCL   surflist[1];
    LONG			lSurfacePitch;

    DPF(2,A,"ENTERAPI: LateAllocSurfaceMem");

    DDASSERT( lpDDSurface != 0 );
    DDASSERT((dwAllocationType == DDHAL_PLEASEALLOC_BLOCKSIZE) || (dwAllocationType == DDHAL_PLEASEALLOC_LINEARSIZE));

    psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
    psurf_lcl = psurf_int->lpLcl;
    psurf_gbl = psurf_lcl->lpGbl;

    /*
     * If driver has already filled in some memory for the surface then we'll just clean
     * up some state and return
     */
    if (psurf_gbl->fpVidMem)
    {
        DPF(4,V,"Driver has already allocated some space.");
        psurf_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
        psurf_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_LATEALLOCATELINEAR;
        if (dwAllocationType == DDHAL_PLEASEALLOC_LINEARSIZE)
        {
            psurf_gbl->dwGlobalFlags |= DDRAWISURFGBL_LATEALLOCATELINEAR;
        }
        return DD_OK;
    }

    /*
     * If the driver hasn't filled in itself, then we'd better have some sensible
     * input to decide what to do.
     */
    DDASSERT(dwWidthOrSize != 0);
    DDASSERT(dwAllocationType == DDHAL_PLEASEALLOC_LINEARSIZE || dwHeight != 0);

    /*
     * Assert some things that we don't want AllocSurfaceMem to see.
     */
    DDASSERT( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) == 0);
    DDASSERT( (psurf_gbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) == 0);

    if (dwAllocationType == DDHAL_PLEASEALLOC_BLOCKSIZE)
    {
        /*
         * Surface can be allocated in either rectangular or linear heaps.
         * (That's what the FALSE passed to AllocSurfaceMem means)
         */
        psurf_gbl->fpVidMem = (FLATPTR) DDHAL_PLEASEALLOC_BLOCKSIZE;
        psurf_gbl->dwBlockSizeX = dwWidthOrSize;
        psurf_gbl->dwBlockSizeY = dwHeight;
        if (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            surflist[0] = psurf_lcl;
            ddrval = AllocSurfaceMem(psurf_lcl->lpSurfMore->lpDD_lcl, surflist, 1 );
        }
        else
        {
            DWORD dwSurfaceSize;
            DDASSERT(psurf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
            ddrval = DDERR_OUTOFMEMORY;
            psurf_gbl->fpVidMem = (FLATPTR) HELAllocateSurfaceSysMem(
                                                        psurf_lcl,
                                                        psurf_gbl->dwBlockSizeX ,
                                                        psurf_gbl->dwBlockSizeY,
                                                        &dwSurfaceSize,
							&lSurfacePitch );
            /*
             * Clean up overloaded fields
             */
            psurf_gbl->lpRectList = NULL;
            psurf_gbl->lpVidMemHeap = NULL;
        }
        if (psurf_gbl->fpVidMem)
        {
            psurf_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
            ddrval = DD_OK;
        }
        else
        {
            DPF(0,"Out of memory in LateAllocateSurfaceMem");
        }
        return ddrval;
    }
    else if (dwAllocationType == DDHAL_PLEASEALLOC_LINEARSIZE)
    {
        DWORD dwSurfaceConsumption;

        if (0 == dwWidthOrSize)
        {
            /*
             * Bad driver!
             */
            DPF_ERR("Linear size set to 0 for a DDHAL_PLEASEALLOC_LINEARSIZE surface");
            return DDERR_INVALIDPARAMS;
        }
        dwSurfaceConsumption = dwWidthOrSize;
        psurf_gbl->dwGlobalFlags |= DDRAWISURFGBL_LATEALLOCATELINEAR;
        /*
         * Surface can only live in linear heaps.
         * (That's what the TRUE passed to AllocSurfaceMem means)
         */
        if (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            /*
             * Fool around with surface global data so that AllocSurfaceMem
             * will allocate the correct linear size.
             */
            psurf_gbl->dwLinearSize = dwWidthOrSize;
            psurf_gbl->wHeight = 1;
            psurf_gbl->fpVidMem = DDHAL_PLEASEALLOC_LINEARSIZE;
            surflist[0] = psurf_lcl;
            ddrval = AllocSurfaceMem(psurf_lcl->lpSurfMore->lpDD_lcl, surflist, 1 );
        }
        else
        {
            ddrval = DDERR_OUTOFMEMORY;
            DDASSERT(psurf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
            psurf_gbl->fpVidMem = (FLATPTR) HELAllocateSurfaceSysMem(
                                                        psurf_lcl,
                                                        dwWidthOrSize,
                                                        1 ,
                                                        &dwSurfaceConsumption,
							&lSurfacePitch );
            psurf_gbl->dwLinearSize = dwSurfaceConsumption;
            /*
             * Clean up overloaded fields
             */
            psurf_gbl->lpVidMemHeap = NULL;
            psurf_gbl->lpRectList = NULL;
        }
        if (psurf_gbl->fpVidMem)
        {
            psurf_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
            /*
             * The surface's size will be calculated using dwLinearSize
             */
            ddrval = DD_OK;
        }
        else
        {
            /*
             * Failed for some reason.
             */
            psurf_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_LATEALLOCATELINEAR;
            DPF(0,"Out of memory in LateAllocateSurfaceMem");
        }
        return ddrval;
    }
    else
        return DDERR_GENERIC;
}


#undef DPF_MODNAME
#define DPF_MODNAME "Resize"

#ifdef POSTPONED2
/*
 * DD_Surface_Resize
 */
HRESULT DDAPI DD_Surface_Resize(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags,
                DWORD dwWidth,
                DWORD dwHeight)
{
    DWORD	rc;
    LPDDHAL_RESIZE	pfn;
    DDHAL_RESIZEDATA	rszd;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this_gbl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv_gbl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Resize");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface;
        /*
         * Validate surface pointer.
         */
        if (!VALID_DIRECTDRAWSURFACE_PTR(this_int))
	{
    	    DPF_ERR("Invalid surface object");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

	this_lcl = this_int->lpLcl;    // internal local surface object
	this_gbl = this_lcl->lpGbl;    // internal global surface object

	/*
	 * If this surface is in the process of being freed, return immediately.
	 */
	if( this_lcl->dwFlags & DDRAWISURF_ISFREE )
	{
	    DPF(0, "Can't resize surface that's being freed" );
	    LEAVE_DDRAW();
	    return DDERR_GENERIC;
	}

	/*
	 * Avoid trying to resize an optimized surface.
	 */
	if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
	{
	    DPF_ERR( "Can't resize an optimized surface" );
	    LEAVE_DDRAW();
	    return DDERR_ISOPTIMIZEDSURFACE;
	}

	/*
	 * Avoid resizing a primary surface, a texture surface, a surface that is part of a
	 * flipping chain or any other complex surface, or a surface that is currently visible.
	 */
        if (this_lcl->ddsCaps.dwCaps & (DDSCAPS_COMPLEX | DDSCAPS_FLIP | DDSCAPS_VIDEOPORT |
					DDSCAPS_PRIMARYSURFACE | DDSCAPS_PRIMARYSURFACELEFT |
					DDSCAPS_TEXTURE | DDSCAPS_MIPMAP |	// redundant?
					DDSCAPS_EXECUTEBUFFER | DDSCAPS_VISIBLE))
        {
    	    DPF_ERR("Can't resize visible surface, texture surface, complex surface, or execute buffer");
            LEAVE_DDRAW();
	    return DDERR_INVALIDSURFACETYPE;
	}

	/*
	 * Avoid resizing an attached surface or a surface that has attached surfaces.
	 * (Note: Could have checked DDRAWISURF_ATTACHED and DDRAWISURF_ATTACHED_FROM
	 * bits in this_lcl->dwFlags, but these don't appear to be maintained properly.)
	 */
	if (this_lcl->lpAttachList != NULL || this_lcl->lpAttachListFrom != NULL)
	{
    	    DPF_ERR( "Can't resize surface that is attached or that has attached surfaces" );
            LEAVE_DDRAW();
	    return DDERR_INVALIDSURFACETYPE;
	}

	/*
	 * Avoid resizing a surface to which a D3D device is still attached.
	 */
	if (this_lcl->lpSurfMore->lpD3DDevIList != NULL)
        {
    	    DPF_ERR( "Can't resize a surface that a Direct3D device is still attached to" );
            LEAVE_DDRAW();
	    return DDERR_INVALIDSURFACETYPE;
	}

	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;	// internal local DD object
	pdrv_gbl = pdrv_lcl->lpGbl;			// internal global DD object
	#ifdef WINNT
            // Update DDraw handle in driver GBL object.
    	    pdrv_gbl->hDD = pdrv_lcl->hDD;
	#endif //WINNT

	/*
	 * Wait for driver to finish with any pending DMA operations
	 */
	if( this_gbl->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
	{
	    WaitForDriverToFinishWithSurface(pdrv_lcl, this_lcl);
	}

	/*
	 * Get pointer to driver's HAL callback Resize routine.
	 */
	if (this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
	{
	    /*
	     * Surface resides in video memory.  Use hardware driver callback.
	     */
	    pfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous2.Resize;
	}
	else
	{
	    /*
	     * Surface resides in system memory.  Use HEL emulation routine.
	     */
	    pfn = pdrv_lcl->lpDDCB->HELDDMiscellaneous2.Resize;
	}
	if (pfn == NULL)
	{
	    DPF_ERR("No driver support for Resize");
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR("Exception encountered validating parameters");
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Currently, no flags are defined for the Resize call.
     */
    if (dwFlags)
    {
	DPF_ERR( "dwFlags arg must be zero" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Validate width and height parameters.
     */
    if (dwWidth < 1 || dwHeight < 1)
    {
	DPF_ERR("Invalid surface width or height specified");
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Don't allow implicit surface to be resized.
     */
    if (this_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE)
    {
	DPF_ERR("Can't resize implicitly created surface");
	LEAVE_DDRAW();
	return DDERR_IMPLICITLYCREATED;
    }

    /*
     * Don't allow source surface for visible overlay sprite to be resized.
     */
    if (this_lcl->dwFlags & DDRAWISURF_INMASTERSPRITELIST)
    {
	DPF_ERR("Can't resize source surface for visible overlay sprite");
	LEAVE_DDRAW();
	return DDERR_INVALIDSURFACETYPE;
    }

    /*
     * Don't allow client-allocated surface memory to be resized.
     */
    if (this_gbl->dwGlobalFlags & DDRAWISURFGBL_ISCLIENTMEM)
    {
	DPF_ERR("Can't resize surface with client-allocated memory");
	LEAVE_DDRAW();
	return DDERR_INVALIDSURFACETYPE;
    }

    /*
     * Make sure we are in the same mode the surface was created in.
     */
#ifdef WIN95
    if (pdrv_gbl->dwModeIndex != this_lcl->dwModeCreatedIn)
#else
    if (!EQUAL_DISPLAYMODE(pdrv_gbl->dmiCurrent, this_lcl->lpSurfMore->dmiCreated))
#endif
    {
        DPF_ERR("Not in mode in which surface was created");
        LEAVE_DDRAW();
        return DDERR_WRONGMODE;
    }

    /*
     * Device busy?
     */
    if (*(pdrv_gbl->lpwPDeviceFlags) & BUSY)
    {
	DPF_ERR("Can't resize locked surface");
	LEAVE_DDRAW();
	return DDERR_SURFACEBUSY;
    }

    BUMP_SURFACE_STAMP(this_gbl);

    #ifdef WINNT
    /*
     * Once we delete the surface object, we are committed to
     * creating a new surface object before we return.  This is true
     * regardless of whether we succeed in resizing the surface.
     */
    if (!DdDeleteSurfaceObject(this_lcl))
    {
	/*
	 * Something is terribly wrong with GDI and/or DDraw!
	 */
	DPF_ERR("GDI failed to delete surface object!");
	LEAVE_DDRAW();
	return DDERR_GENERIC;
    }
    #endif //WINNT

    /*
     * Now call the driver to resize the surface for us.
     */
    rszd.lpDD = pdrv_gbl;
    rszd.lpDDSurface = this_lcl;
    rszd.dwFlags = dwFlags;
    rszd.dwWidth = dwWidth;
    rszd.dwHeight = dwHeight;
    rszd.ddRVal = 0;

    // The following definition allows DOHALCALL to be used
    // with thunkless, 32-bit callback.
    #define _DDHAL_Resize  NULL

    DOHALCALL(Resize, pfn, rszd, rc, 0);

    /*
     * If driver callback succeeded, DirectDraw is responsible for
     * updating the surface's width, height, etc.
     */
    if (rszd.ddRVal == DD_OK)
    {
        // Driver should have set these parameters itself:
	DDASSERT(this_gbl->fpVidMem != (FLATPTR)NULL);
	DDASSERT(this_lcl->lpSurfMore->dwBytesAllocated != 0);

	// Update surface parameters.
	this_gbl->wWidth  = (WORD)dwWidth;
	this_gbl->wHeight = (WORD)dwHeight;
        this_lcl->dwFlags &= ~DDRAWISURF_INVALID;
	this_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
    }

    #ifdef WINNT
    /*
     * We deleted the surface object above, so we must create a new
     * surface object before we return.  This is true regardless of
     * whether the driver call succeeded in resizing the surface.
     */
    if (!DdCreateSurfaceObject(this_lcl, FALSE))
    {
        if(!(DDSCAPS_SYSTEMMEMORY & this_lcl->ddsCaps.dwCaps))
        {
	    /*
	     * We hope this is rare and pathological condition because we
	     * just destroyed the surface object the client gave us.  Oops.
	     */
	    DPF_ERR("GDI failed to create surface object!");
	    rszd.ddRVal = DDERR_GENERIC;
        }
    }
    #endif //WINNT

    if (rc != DDHAL_DRIVER_HANDLED)
    {
	DPF_ERR("Driver wouldn't handle callback");
	LEAVE_DDRAW();
	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return rszd.ddRVal;

} /* DD_Surface_Resize */
#endif //POSTPONED2

#undef DPF_MODNAME
#define DPF_MODNAME "SetPriority"

HRESULT DDAPI DD_Surface_SetPriority(LPDIRECTDRAWSURFACE7 lpDDSurface, DWORD dwPriority)
{
    HRESULT                     rc;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;

#if DBG
    DPF(2,A,"ENTERAPI: DD_Surface_SetPriority");

    TRY
    {
#endif
	this_int = (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface;
#if DBG
        /*
         * Validate surface pointer.
         */
        if (!VALID_DIRECTDRAWSURFACE_PTR(this_int))
	{
    	    DPF_ERR("Invalid surface object");
	    return DDERR_INVALIDOBJECT;
	}
#endif
	this_lcl = this_int->lpLcl;    // internal local surface object
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;	// internal local DD object
#if DBG
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR("Exception encountered validating parameters");
	return DDERR_INVALIDPARAMS;
    }

    if(!IsToplevel(this_lcl))
    {
        DPF_ERR( "Cannot set priority on a mipmap sublevel or a cubemap subface" );
        return DDERR_INVALIDPARAMS;
    }

    if(this_lcl->lpSurfMore->lpTex == NULL)
    {
        DPF_ERR("SetPriority can only be called on a managed texture");
        return DDERR_INVALIDOBJECT;
    }

    if( pdrv_lcl->pD3DSetPriority == NULL )
    {
        DPF_ERR("D3D is not yet initialized or app didn't use DirectDrawCreateEx");
        return DDERR_D3DNOTINITIALIZED;
    }
#endif
    if(pdrv_lcl->dwLocalFlags & DDRAWILCL_MULTITHREADED)
    {
        ENTER_DDRAW();
        rc = pdrv_lcl->pD3DSetPriority(this_lcl->lpSurfMore->lpTex, dwPriority);
        LEAVE_DDRAW();
    }
    else
    {
        rc = pdrv_lcl->pD3DSetPriority(this_lcl->lpSurfMore->lpTex, dwPriority);
    }

    return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetPriority"

HRESULT DDAPI DD_Surface_GetPriority(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDWORD lpdwPriority)
{
    HRESULT                     rc;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetPriority");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface;
        /*
         * Validate surface pointer.
         */
        if (!VALID_DIRECTDRAWSURFACE_PTR(this_int))
	{
    	    DPF_ERR("Invalid surface object");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

        /*
         * Validate DWORD pointer.
         */
        if (!VALID_DWORD_PTR( lpdwPriority ))
        {
            DPF_ERR("Invalid DWORD pointer");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
        }

	this_lcl = this_int->lpLcl;    // internal local surface object
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;	// internal local DD object
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR("Exception encountered validating parameters");
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    if(!IsToplevel(this_lcl))
    {
        DPF_ERR( "Cannot get priority from a mipmap sublevel or a cubemap subface" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    if(this_lcl->lpSurfMore->lpTex == NULL)
    {
        DPF_ERR("GetPriority can only be called on a managed texture");
        LEAVE_DDRAW();
	return DDERR_INVALIDOBJECT;
    }

    if( pdrv_lcl->pD3DGetPriority == NULL )
    {
        DPF_ERR("D3D is not yet initialized or app didn't use DirectDrawCreateEx");
        LEAVE_DDRAW();
	return DDERR_D3DNOTINITIALIZED;
    }

    rc = pdrv_lcl->pD3DGetPriority(this_lcl->lpSurfMore->lpTex, lpdwPriority);

    LEAVE_DDRAW();

    return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SetLOD"

HRESULT DDAPI DD_Surface_SetLOD(LPDIRECTDRAWSURFACE7 lpDDSurface, DWORD dwLOD)
{
    HRESULT                     rc;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetLOD");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface;
        /*
         * Validate surface pointer.
         */
        if (!VALID_DIRECTDRAWSURFACE_PTR(this_int))
	{
    	    DPF_ERR("Invalid surface object");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

	this_lcl = this_int->lpLcl;    // internal local surface object
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;	// internal local DD object
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR("Exception encountered validating parameters");
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    if(!IsToplevel(this_lcl))
    {
        DPF_ERR( "Cannot set LOD on a mipmap sublevel or a cubemap subface" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    if(this_lcl->lpSurfMore->lpTex == NULL)
    {
        DPF_ERR("SetLOD can only be called on a managed texture");
        LEAVE_DDRAW();
	return DDERR_INVALIDOBJECT;
    }

    if( pdrv_lcl->pD3DSetLOD == NULL )
    {
        DPF_ERR("D3D is not yet initialized or app didn't use DirectDrawCreateEx");
        LEAVE_DDRAW();
	return DDERR_D3DNOTINITIALIZED;
    }

    rc = pdrv_lcl->pD3DSetLOD(this_lcl->lpSurfMore->lpTex, dwLOD);

    LEAVE_DDRAW();

    return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetLOD"

HRESULT DDAPI DD_Surface_GetLOD(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDWORD lpdwLOD)
{
    HRESULT                     rc;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetLOD");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface;
        /*
         * Validate surface pointer.
         */
        if (!VALID_DIRECTDRAWSURFACE_PTR(this_int))
	{
    	    DPF_ERR("Invalid surface object");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

        /*
         * Validate DWORD pointer.
         */
        if (!VALID_DWORD_PTR( lpdwLOD ))
        {
            DPF_ERR("Invalid DWORD pointer");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
        }

	this_lcl = this_int->lpLcl;    // internal local surface object
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;	// internal local DD object
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR("Exception encountered validating parameters");
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    if(!IsToplevel(this_lcl))
    {
        DPF_ERR( "Cannot get LOD from a mipmap sublevel or a cubemap subface" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    if(this_lcl->lpSurfMore->lpTex == NULL)
    {
        DPF_ERR("GetLOD can only be called on a managed texture");
        LEAVE_DDRAW();
	return DDERR_INVALIDOBJECT;
    }

    if( pdrv_lcl->pD3DGetLOD == NULL )
    {
        DPF_ERR("D3D is not yet initialized or app didn't use DirectDrawCreateEx");
        LEAVE_DDRAW();
	return DDERR_D3DNOTINITIALIZED;
    }

    rc = pdrv_lcl->pD3DGetLOD(this_lcl->lpSurfMore->lpTex, lpdwLOD);

    LEAVE_DDRAW();

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddvp.c ===
/*==========================================================================
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddvp.c
 *  Content: 	DirectDrawVideoPort
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   11-jun-96	scottm	created
 *   29-jan-97	smac	Various API changes and bug fixes
 *   31-jan-97  colinmc Bug 5457: Fixed problem with new aliased (no-Win16
 *                      lock) and multiple AMovie clips playing on old cards.
 *   03-mar-97  smac    Added kernel mode interface and fixed some bugs
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
    #include "ddkmmini.h"
    #include "ddkmapi.h"
#else
    #include "ddkmmini.h"
    #include "ddkmapip.h"
#endif
#define DPF_MODNAME "DirectDrawVideoPort"

#define MAX_VP_FORMATS		25
#define MAX_VIDEO_PORTS		10


DDPIXELFORMAT ddpfVPFormats[MAX_VP_FORMATS];
BOOL bInEnumCallback = FALSE;

HRESULT InternalUpdateVideo( LPDDRAWI_DDVIDEOPORT_INT, LPDDVIDEOPORTINFO );
HRESULT InternalStartVideo( LPDDRAWI_DDVIDEOPORT_INT, LPDDVIDEOPORTINFO );
LPDDPIXELFORMAT GetSurfaceFormat( LPDDRAWI_DDRAWSURFACE_LCL );
HRESULT CreateVideoPortNotify( LPDDRAWI_DDVIDEOPORT_INT, LPDIRECTDRAWVIDEOPORTNOTIFY *lplpVPNotify );


/*
 * This function 1) updates the surfaces in the chain so they know they
 * are no longer receiving video port data and 2) releases any implicitly
 * created kernel handles.
 */
VOID ReleaseVPESurfaces( LPDDRAWI_DDRAWSURFACE_INT surf_int, BOOL bRelease )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;

    DDASSERT( surf_int != NULL );
    surf_first = surf_int;
    do
    {
	if( bRelease &&
	    ( surf_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_IMPLICITHANDLE ) )
	{
	    InternalReleaseKernelSurfaceHandle( surf_int->lpLcl, FALSE );
	    surf_int->lpLcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_IMPLICITHANDLE;
	}
	surf_int->lpLcl->lpSurfMore->lpVideoPort = NULL;
    	surf_int = FindAttachedFlip( surf_int );
    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
}


/*
 * This function 1) updates the surfaces in the chain so they know they
 * are receiving video port data and 2) implicitly creates kernel handles
 * for each surface if one does not already exist so ring 0 can perform
 * software autoflipping or software bobbing.
 */
DWORD PrepareVPESurfaces( LPDDRAWI_DDRAWSURFACE_INT surf_int,
	LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, BOOL bAutoflipping )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    LPDDRAWI_DDRAWSURFACE_INT surf_first;
    ULONG_PTR dwHandle;
    DWORD ddRVal;

    DDASSERT( surf_int != NULL );
    surf_first = surf_int;
    do
    {
	/*
	 * Create a kernel handle if one doesn't already exist
	 */
	if( bAutoflipping )
	{
	    surf_int->lpLcl->lpSurfMore->lpVideoPort = lpVideoPort;
	}
    	lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( surf_int->lpLcl->lpGbl );
	if( ( lpSurfGblMore->hKernelSurface == 0 ) &&
	    !( lpVideoPort->dwFlags & DDRAWIVPORT_NOKERNELHANDLES ) )
	{
	    ddRVal = InternalCreateKernelSurfaceHandle( surf_int->lpLcl, &dwHandle );
	    if( ddRVal == DD_OK )
	    {
		surf_int->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_IMPLICITHANDLE;
	    }
	    else
	    {
		/*
		 * This is not a catastrophic failure, but it will stop us
		 * from software autoflipping.
		 */
		lpVideoPort->dwFlags |= DDRAWIVPORT_NOKERNELHANDLES;
	    }
	}
    	surf_int = FindAttachedFlip( surf_int );
    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );

    if( !bAutoflipping )
    {
	surf_first->lpLcl->lpSurfMore->lpVideoPort = lpVideoPort;
    }

    return DD_OK;
}


/*
 * GetVideoPortFromSurface
 *
 * Returns the video port associated with the surface.  The video
 * port can be anywhere in the surface list.
 */
LPDDRAWI_DDVIDEOPORT_LCL GetVideoPortFromSurface( LPDDRAWI_DDRAWSURFACE_INT surf_int )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;
    LPDDRAWI_DDVIDEOPORT_LCL lpVp;

    /*
     * Is it associated with video port?  If not explicitly, is another
     * surface in the chain explicitly associated?
     */
    lpVp = surf_int->lpLcl->lpSurfMore->lpVideoPort;
    if( lpVp == NULL )
    {
	surf_first = surf_int;
	do
	{
	    surf_int = FindAttachedFlip( surf_int );
	    if( surf_int != NULL )
	    {
	        lpVp = surf_int->lpLcl->lpSurfMore->lpVideoPort;
	    }
	}
	while( ( surf_int != NULL ) && ( lpVp == NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
    }

    return lpVp;
}


/*
 * Determines if the specified overlay surface can support autoflipping
 * Return:  0 = Not valid, 1 = software only, 2 = hardware autoflipping
 */
DWORD IsValidAutoFlipSurface( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int )
{
    LPDDRAWI_DDRAWSURFACE_INT lpFirstSurf;
    LPDDRAWI_DDRAWSURFACE_INT lpSurf;
    LPDDRAWI_DDVIDEOPORT_LCL lpVp;
    BOOL bFound;

    /*
     * Is it associated with video port?
     */
    lpVp = GetVideoPortFromSurface( lpSurface_int );
    if( lpVp == NULL )
    {
	return IVAS_NOAUTOFLIPPING;
    }

    /*
     * Is the video port autoflipping?  If not, then neither can the overlay.
     */
    if( !( lpVp->ddvpInfo.dwVPFlags & DDVP_AUTOFLIP ) )
    {
	return IVAS_NOAUTOFLIPPING;
    }

    /*
     * It's still possible that VBI is autoflipping, but not the regular
     * video (which applies to the overlay).
     */
    if( lpVp->dwNumAutoflip == 0 )
    {
	return IVAS_NOAUTOFLIPPING;
    }
    lpSurf = lpFirstSurf = lpVp->lpSurface;
    bFound = FALSE;
    if( lpFirstSurf != NULL )
    {
        do
        {
            if( lpSurf->lpLcl == lpSurface_int->lpLcl )
            {
                bFound = TRUE;
            }
            lpSurf = FindAttachedFlip( lpSurf );
        }  while( !bFound && ( lpSurf != NULL) && ( lpSurf->lpLcl != lpFirstSurf->lpLcl ) );
    }
    if( !bFound )
    {
	return IVAS_NOAUTOFLIPPING;
    }

    /*
     * If the video port is software autoflipping, then the overlay must
     * as well.
     */
    if( lpVp->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP )
    {
	return IVAS_SOFTWAREAUTOFLIPPING;
    }

    return IVAS_HARDWAREAUTOFLIPPING;
}


/*
 * Notifies the video port that the overlay will only allow software
 * autoflipping
 */
VOID RequireSoftwareAutoflip( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int )
{
    LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort;

    lpVideoPort = GetVideoPortFromSurface( lpSurface_int );
    if( lpVideoPort != NULL )
    {
    	lpVideoPort->dwFlags |= DDRAWIVPORT_SOFTWARE_AUTOFLIP;

	/*
	 * If they are already hardware autoflipping, make them switch
	 * to software.
	 */
	if( lpVideoPort->dwFlags & DDRAWIVPORT_ON )
	{
    	    LPDDRAWI_DDVIDEOPORT_INT lpVp_int;

	    /*
	     * The next function requires a DDVIDEOPORT_INT and all we
	     * have is a DDVIDEOPORT_LCL, so we need to search for it.
	     */
    	    lpVp_int = lpSurface_int->lpLcl->lpSurfMore->lpDD_lcl->lpGbl->dvpList;
    	    while( lpVp_int != NULL )
    	    {
		if( ( lpVp_int->lpLcl == lpVideoPort ) &&
		    !( lpVp_int->dwFlags & DDVPCREATE_NOTIFY ) )
		{
	    	    InternalUpdateVideo( lpVp_int,
	    		&( lpVp_int->lpLcl->ddvpInfo) );
		}
		lpVp_int = lpVp_int->lpLink;
	    }
	}
    }
}


/*
 * Determines if the overlay must be bobbed using software or whether
 * it should try software.
 */
BOOL MustSoftwareBob( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int )
{
    LPDDRAWI_DDVIDEOPORT_LCL lpVp;

    /*
     * Is it associated with video port?
     */
    lpVp = GetVideoPortFromSurface( lpSurface_int );
    if( lpVp == NULL )
    {
	return TRUE;
    }

    /*
     * If the video port is software autoflipping or software bobbing,
     * then the overlay must as well.
     */
    if( ( lpVp->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP ) ||
	( lpVp->dwFlags & DDRAWIVPORT_SOFTWARE_BOB ) )
    {
	return TRUE;
    }

    return FALSE;
}


/*
 * Notifies the video port that the overlay will only allow software
 * bobbing
 */
VOID RequireSoftwareBob( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int )
{
    LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort;

    lpVideoPort = GetVideoPortFromSurface( lpSurface_int );
    if( lpVideoPort != NULL )
    {
    	lpVideoPort->dwFlags |= DDRAWIVPORT_SOFTWARE_BOB;

	/*
	 * If they are already hardware autoflipping, make them switch
	 * to software.
	 */
	if( ( lpVideoPort->dwFlags & DDRAWIVPORT_ON ) &&
	    ( lpVideoPort->dwNumAutoflip > 0 ) &&
	    !( lpVideoPort->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP ) )
	{
    	    LPDDRAWI_DDVIDEOPORT_INT lpVp_int;

	    /*
	     * The next function requires a DDVIDEOPORT_INT and all we
	     * have is a DDVIDEOPORT_LCL, so we need to search for it.
	     */
    	    lpVp_int = lpSurface_int->lpLcl->lpSurfMore->lpDD_lcl->lpGbl->dvpList;
    	    while( lpVp_int != NULL )
    	    {
		if( ( lpVp_int->lpLcl == lpVideoPort ) &&
		    !( lpVp_int->dwFlags & DDVPCREATE_NOTIFY ) )
		{
	    	    InternalUpdateVideo( lpVp_int,
	    		&( lpVp_int->lpLcl->ddvpInfo) );
		}
		lpVp_int = lpVp_int->lpLink;
	    }
	}
    }
}


#ifdef WIN95
/*
 * OverrideOverlay
 *
 * Checks to see if there is a chance that the kernel mode interface
 * has changed the state from bob to weave or visa versa, or if it's
 * cahnged from hardware autoflipping to software autoflipping.  If the
 * chance exists, it calls down to ring 0 to get the state and if
 * it's changed, changes the overlay parameters accordingly.
 */
VOID OverrideOverlay( LPDDRAWI_DDRAWSURFACE_INT surf_int,
		      LPDWORD lpdwFlags )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    LPDDRAWI_DDRAWSURFACE_MORE lpSurfMore;
    LPDDRAWI_DDVIDEOPORT_LCL lpVp;
    DWORD dwStateFlags;

    /*
     * Ring 0 can change the state, so we need to call down to it.
     */
    lpSurfMore = surf_int->lpLcl->lpSurfMore;
    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( surf_int->lpLcl->lpGbl );
    if( lpSurfGblMore->hKernelSurface != 0 )
    {
	dwStateFlags = 0;
	GetKernelSurfaceState( surf_int->lpLcl, &dwStateFlags );
	if( dwStateFlags & DDSTATE_EXPLICITLY_SET )
	{
	    if( ( dwStateFlags & DDSTATE_BOB ) &&
		!( *lpdwFlags & DDOVER_BOB ) )
	    {
		// Switch from weave to bob
	    	*lpdwFlags |= DDOVER_BOB;
	    }
	    else if( ( dwStateFlags & DDSTATE_WEAVE ) &&
		( *lpdwFlags & DDOVER_BOB ) )
	    {
		// Switch from bob to weave
	    	*lpdwFlags &= ~DDOVER_BOB;
	    }
            else if( ( dwStateFlags & DDSTATE_SKIPEVENFIELDS ) &&
		( *lpdwFlags & DDOVER_BOB ) )
	    {
		// Switch from bob to weave
	    	*lpdwFlags &= ~DDOVER_BOB;
	    }
	}

	lpVp = GetVideoPortFromSurface( surf_int );
	if( ( dwStateFlags & DDSTATE_SOFTWARE_AUTOFLIP ) &&
	    ( lpVp != NULL ) &&
	    ( lpVp->ddvpInfo.dwVPFlags & DDVP_AUTOFLIP ) &&
	    !( lpVp->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP ) )
	{
	    RequireSoftwareAutoflip( surf_int );
	}
    }
}


/*
 * OverrideVideoPort
 *
 * Checks to see if there is a chance that the kernel mode interface
 * has changed the state from bob/weave to field skipping or visa versa.
 * If the chance exists, it calls down to ring 0 to get the state and if
 * it's changed, changes the overlay parameters accordingly.
 */
VOID OverrideVideoPort( LPDDRAWI_DDRAWSURFACE_INT surf_int,
		      LPDWORD lpdwFlags )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    LPDDRAWI_DDRAWSURFACE_MORE lpSurfMore;
    DWORD dwStateFlags;

    /*
     * Ring 0 can change the state, so we need to call down to it.
     */
    lpSurfMore = surf_int->lpLcl->lpSurfMore;
    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( surf_int->lpLcl->lpGbl );
    if( lpSurfGblMore->hKernelSurface != 0 )
    {
	dwStateFlags = 0;
	GetKernelSurfaceState( surf_int->lpLcl, &dwStateFlags );
	if( dwStateFlags & DDSTATE_EXPLICITLY_SET )
	{
            if( ( dwStateFlags & DDSTATE_SKIPEVENFIELDS ) &&
                !( *lpdwFlags & DDVP_SKIPODDFIELDS ) )
	    {
		// Switch from bob to weave
                *lpdwFlags &= ~DDVP_INTERLEAVE;
                *lpdwFlags |= DDVP_SKIPEVENFIELDS;
	    }
	}
    }
}
#endif


/*
 * UpdateInterleavedFlags
 *
 * We want to track whether the surface data came from a vidoe port or not
 * and if it did, was it interleaved.  This is important so we can
 * automatically set the DDOVER_INTERLEAVED flag while using the video port.
 */
VOID UpdateInterleavedFlags( LPDDRAWI_DDVIDEOPORT_LCL this_lcl, DWORD dwVPFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;
    LPDDRAWI_DDRAWSURFACE_INT surf_temp;

    /*
     * Since the interleaved flag is only used for calling UpdateOverlay,
     * we only need to handle this for the regular video.
     */
    surf_temp = this_lcl->lpSurface;
    if( surf_temp == NULL )
    {
	return;
    }

    /*
     * If autoflipping, update every surface in the chain.
     */
    if( ( dwVPFlags & DDVP_AUTOFLIP ) && ( this_lcl->dwNumAutoflip > 0 ) )
    {
	surf_first = surf_temp;
	do
	{
	    surf_temp->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_VPORTDATA;
	    if( dwVPFlags & DDVP_INTERLEAVE )
	    {
	    	surf_temp->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_VPORTINTERLEAVED;
	    }
	    else
	    {
	    	surf_temp->lpLcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_VPORTINTERLEAVED;
	    }
    	    surf_temp = FindAttachedFlip( surf_temp );
    	} while( ( surf_temp != NULL ) && ( surf_temp->lpLcl != surf_first->lpLcl ) );
    }
    else
    {
	surf_temp->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_VPORTDATA;
	if( dwVPFlags & DDVP_INTERLEAVE )
	{
	    surf_temp->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_VPORTINTERLEAVED;
	}
	else
	{
	    surf_temp->lpLcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_VPORTINTERLEAVED;
	}
    }
}


/*
 * InternalVideoPortFlip
 *
 * This fucntion acts differntly based on whether the flip is occurring
 * based on an overlay flip or whether an explicit flip was specified.
 */
HRESULT InternalVideoPortFlip( LPDDRAWI_DDVIDEOPORT_LCL this_lcl,
			       LPDDRAWI_DDRAWSURFACE_INT next_int,
			       BOOL bExplicit )
{
    LPDDRAWI_DDRAWSURFACE_LCL	next_lcl;
    LPDDHALVPORTCB_FLIP 	pfn;
    DDHAL_FLIPVPORTDATA		FlipData;
    DWORD rc;

    /*
     * surfaces must be in video memory
     */
    next_lcl = next_int->lpLcl;
    if( next_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
	if ( !( this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID].dwCaps &
	    DDVPCAPS_SYSTEMMEMORY ) )
    	{
	    DPF_ERR( "Surface must be in video memory" );
	    return DDERR_INVALIDPARAMS;
    	}
    	if( next_lcl->lpSurfMore->dwPageLockCount == 0 )
    	{
	    DPF_ERR( "Surface must be page locked" );
	    return DDERR_INVALIDPARAMS;
    	}
    }

    /*
     * surfaces must have the VIDEOPORT attribute
     */
    if( !( next_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT ) )
    {
	DPF_ERR( "Surface must have the DDSCAPS_VIDEOPORT attribute" );
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Tell the HAL to perform the flip
     */
    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.FlipVideoPort;
    if( pfn != NULL )
    {
    	FlipData.lpDD = this_lcl->lpDD;
    	FlipData.lpVideoPort = this_lcl;
    	FlipData.lpSurfCurr = this_lcl->lpSurface->lpLcl;
    	FlipData.lpSurfTarg = next_lcl;

	DOHALCALL( FlipVideoPort, pfn, FlipData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != FlipData.ddRVal )
	{
	    return FlipData.ddRVal;
	}
    }
    else
    {
	return DDERR_UNSUPPORTED;
    }

    /*
     * Update the surfaces so they know which one is connected to the
     * video port.
     */
    if( bExplicit )
    {
    	if( this_lcl->lpSurface != NULL )
    	{
    	    this_lcl->lpSurface->lpLcl->lpSurfMore->lpVideoPort = NULL;
    	}
    	next_int->lpLcl->lpSurfMore->lpVideoPort = this_lcl;

    	this_lcl->lpSurface = next_int;
    }
    UpdateInterleavedFlags( this_lcl, this_lcl->ddvpInfo.dwVPFlags );
    this_lcl->fpLastFlip = next_int->lpLcl->lpGbl->fpVidMem;

    return DD_OK;
}

/*
 * FlipVideoPortToN
 *
 * This flips the video port to the next N surface.  If N is 1, it flips it
 * to the next surface, etc.
 */
HRESULT FlipVideoPortToN( LPDDRAWI_DDVIDEOPORT_LCL this_lcl, DWORD dwSkipNum )
{
    LPDDRAWI_DDRAWSURFACE_INT	surf_int;
    DWORD i;

    /*
     * Get the target surface.  We can eliminate a lot of error checking
     * since this function is called from DD_Surface_Flip which already
     * performs the same error checking.
     */
    surf_int = this_lcl->lpSurface;
    for( i = 0; i < dwSkipNum; i++ )
    {
    	surf_int = FindAttachedFlip( surf_int );
    }

    if (surf_int == NULL)
    {
        // Better to do this instead of faulting.
        DPF_ERR("Couldn't find Nth flipping surface.");
        return DDERR_INVALIDPARAMS;
    }

    return InternalVideoPortFlip( this_lcl, surf_int, 0 );
}

/*
 * FlipVideoPortSurface
 *
 * Called when flipping a surface that is fed by a video port.  This searches
 * for each videoport associated with the surface and flips the video port.
 */
DWORD FlipVideoPortSurface( LPDDRAWI_DDRAWSURFACE_INT surf_int, DWORD dwNumSkipped )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;
    LPDDRAWI_DIRECTDRAW_GBL lpDD_Gbl;
    LPDDRAWI_DDVIDEOPORT_INT lpVp;
    LPDDRAWI_DDRAWSURFACE_INT lpSurface;
    BOOL bFound;
    DWORD rc;

    lpDD_Gbl = surf_int->lpLcl->lpSurfMore->lpDD_lcl->lpGbl;
    lpVp = lpDD_Gbl->dvpList;
    while( lpVp != NULL )
    {
    	bFound = FALSE;
	if( ( lpVp->lpLcl->lpSurface != NULL ) &&
	    !( lpVp->lpLcl->ddvpInfo.dwVPFlags & DDVP_AUTOFLIP ) &&
            !( lpVp->dwFlags & DDVPCREATE_NOTIFY ) )
	{
    	    surf_first = lpSurface = lpVp->lpLcl->lpSurface;
    	    do
    	    {
		if( lpSurface == surf_int )
	    	{
		    rc = FlipVideoPortToN( lpVp->lpLcl, dwNumSkipped );
		    bFound = TRUE;
	    	}
    		lpSurface = FindAttachedFlip( lpSurface );
    	    } while( ( lpSurface != NULL ) && ( lpSurface->lpLcl != surf_first->lpLcl ) );
	}
	lpVp = lpVp->lpLink;
    }
    return DD_OK;
}


/*
 * IndepenantVBIPossible
 *
 * Returns TRUE if the specified caps determine it is possible to manage the
 * VBI stream completely independant of the video stream.
 */
BOOL IndependantVBIPossible( LPDDVIDEOPORTCAPS lpCaps )
{
    if( ( lpCaps->dwCaps & ( DDVPCAPS_VBISURFACE|DDVPCAPS_OVERSAMPLEDVBI ) ) !=
	( DDVPCAPS_VBISURFACE | DDVPCAPS_OVERSAMPLEDVBI ) )
    {
	return FALSE;
    }
    if( ( lpCaps->dwFX & ( DDVPFX_VBINOSCALE | DDVPFX_IGNOREVBIXCROP |
	DDVPFX_VBINOINTERLEAVE ) ) != ( DDVPFX_VBINOSCALE |
	DDVPFX_IGNOREVBIXCROP | DDVPFX_VBINOINTERLEAVE ) )
    {
	return FALSE;
    }
    return TRUE;
}


/*
 * DDVPC_EnumVideoPorts
 */
HRESULT DDAPI DDVPC_EnumVideoPorts(
        LPDDVIDEOPORTCONTAINER lpDVP,
	DWORD dwReserved,
        LPDDVIDEOPORTCAPS lpCaps,
	LPVOID lpContext,
        LPDDENUMVIDEOCALLBACK lpEnumCallback )
{
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_LCL	this_lcl;
    LPDDVIDEOPORTCAPS		lpHALCaps;
    DWORD			rc;
    DWORD			dwMaxVideoPorts;
    DWORD			flags;
    DWORD			i;
    BOOL			bEnumThisOne;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDVPC_EnumVideoPorts");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * validate parameters
     */
    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDVP;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid video port container specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
	{
	    DPF_ERR( "Invalid callback routine" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( NULL == lpCaps )
	{
	    /*
	     * If a NULL description is defined, we will assume that they
	     * want to enum everything.
	     */
	    flags = 0;
	}
	else
	{
	    if( !VALID_DDVIDEOPORTCAPS_PTR( lpCaps ) )
	    {
	        DPF_ERR( "Invalid DDVIDEOPORTCAPS specified" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }

	    flags = lpCaps->dwFlags;

	    /*
	     * check height/width
	     */
	    if( ((flags & DDVPD_HEIGHT) && !(flags & DDVPD_WIDTH)) ||
		(!(flags & DDVPD_HEIGHT) && (flags & DDVPD_WIDTH)) )
	    {
		DPF_ERR( "Specify both height & width in video port desc" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }

    	    if( lpCaps->dwVideoPortID >= this_lcl->lpGbl->ddCaps.dwMaxVideoPorts )
    	    {
	        DPF_ERR( "Invalid video port ID specified" );
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
	}
    	if( NULL == this_lcl->lpGbl->lpDDVideoPortCaps )
	{
	    DPF_ERR( "Driver failed query for video port caps" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
	for( i = 0; i < this_lcl->lpGbl->ddCaps.dwMaxVideoPorts; i++ )
	{
    	    lpHALCaps = &(this_lcl->lpGbl->lpDDVideoPortCaps[i]);
    	    if( !VALID_DDVIDEOPORTCAPS_PTR( lpHALCaps ) )
    	    {
	        DPF_ERR( "Driver returned invalid DDVIDEOPORTCAPS" );
	    	LEAVE_DDRAW();
	    	return DDERR_UNSUPPORTED;
    	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Look at each video port and match it with the input description.
     */
    dwMaxVideoPorts = this_lcl->lpGbl->ddCaps.dwMaxVideoPorts;
    lpHALCaps = this_lcl->lpGbl->lpDDVideoPortCaps;
    for (i = 0; i < dwMaxVideoPorts; i++)
    {
	bEnumThisOne = TRUE;

	if( flags & DDVPD_WIDTH )
	{
	    if( lpCaps->dwMaxWidth > lpHALCaps->dwMaxWidth )
		bEnumThisOne = FALSE;
	}
	if( flags & DDVPD_HEIGHT )
	{
	    if( lpCaps->dwMaxHeight > lpHALCaps->dwMaxHeight )
		bEnumThisOne = FALSE;
	}
	if( flags & DDVPD_ID )
	{
	    if( lpCaps->dwVideoPortID != lpHALCaps->dwVideoPortID )
		bEnumThisOne = FALSE;
	}
	if( flags & DDVPD_CAPS )
	{
	    /*
	     * Simple check to make sure no caps were specified that are
	     * not returned by the HAL.
	     */
	    if ( (lpCaps->dwCaps & lpHALCaps->dwCaps) != lpCaps->dwCaps )
		bEnumThisOne = FALSE;
	}
	if( flags & DDVPD_FX )
	{
	    /*
	     * Simple check to make sure no FX were specified that are
	     * not returned by the HAL.
	     */
	    if ( (lpCaps->dwFX & lpHALCaps->dwFX) != lpCaps->dwFX )
		bEnumThisOne = FALSE;
	}

	if ( TRUE == bEnumThisOne )
	{
	    /*
	     * Don't trust the drivers to set this bit correctly (especially
	     * since we are adding it so late)
	     */
	    if( IndependantVBIPossible( lpHALCaps ) )
	    {
		lpHALCaps->dwCaps |= DDVPCAPS_VBIANDVIDEOINDEPENDENT;
	    }
	    else
	    {
		lpHALCaps->dwCaps &= ~DDVPCAPS_VBIANDVIDEOINDEPENDENT;
	    }

            /*
             * We added the dwNumPrefferedAutoflip for Memphis, so some
             * old drivers might not report this correctly.  For that reason,
             * we will attempt to fill in a valid value.
             */
            if( !( lpHALCaps->dwFlags & DDVPD_PREFERREDAUTOFLIP ) )
            {
                /*
                 * The driver did not set this, so we should force the
                 * value to 3.
                 */
                lpHALCaps->dwNumPreferredAutoflip = 3;
                lpHALCaps->dwFlags |= DDVPD_PREFERREDAUTOFLIP;
            }
            if( lpHALCaps->dwNumPreferredAutoflip > lpHALCaps->dwNumAutoFlipSurfaces )
            {
                lpHALCaps->dwNumPreferredAutoflip = lpHALCaps->dwNumAutoFlipSurfaces;
            }

	    bInEnumCallback = TRUE;
    	    rc = lpEnumCallback( lpHALCaps, lpContext );
	    bInEnumCallback = FALSE;
	    if( rc == 0 )
    	    {
    	        break;
    	    }
	}
	lpHALCaps++;
    }
    LEAVE_DDRAW();

    return DD_OK;

} /* DDVPC_EnumVideoPorts */


/*
 * DDVPC_GetVideoPortConnectInfo
 */
HRESULT DDAPI DDVPC_GetVideoPortConnectInfo(
        LPDDVIDEOPORTCONTAINER lpDVP,
        DWORD dwVideoPortID,
        LPDWORD lpdwNumEntries,
	LPDDVIDEOPORTCONNECT lpConnect )
{
    LPDDHALVPORTCB_GETVPORTCONNECT pfn;
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDVIDEOPORTCONNECT lpTemp;
    DDHAL_GETVPORTCONNECTDATA GetGuidData;
    DWORD rc;
    DWORD i;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDVPC_GetVideoPortConnectInfo");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDVP;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
            DPF_ERR ( "DDVPC_GetVideoPortConnectInfo: Invalid DirectDraw ptr");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	#ifdef WINNT
    	    // Update DDraw handle in driver GBL object.
	    this_lcl->lpGbl->hDD = this_lcl->hDD;
	#endif

    	if( dwVideoPortID >= this_lcl->lpGbl->ddCaps.dwMaxVideoPorts )
    	{
            DPF_ERR ( "DDVPC_GetVideoPortConnectInfo: invalid port ID");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( (lpdwNumEntries == NULL) || !VALID_BYTE_ARRAY( lpdwNumEntries, sizeof( LPVOID ) ) )
    	{
            DPF_ERR ( "DDVPC_GetVideoPortConnectInfo: numentries not valid");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( NULL != lpConnect )
    	{
	    if( 0 == *lpdwNumEntries )
    	    {
                DPF_ERR ( "DDVPC_GetVideoPortConnectInfo: numentries not valid");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	    if( !VALID_BYTE_ARRAY( lpConnect, *lpdwNumEntries * sizeof( DDVIDEOPORTCONNECT ) ) )
    	    {
                DPF_ERR ( "DDVPC_GetVideoPortConnectInfo: invalid array passed in");
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
      	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_int->lpLcl->lpDDCB->HALDDVideoPort.GetVideoPortConnectInfo;
    if( pfn != NULL )
    {
	/*
	 * Get the number of GUIDs
	 */
    	GetGuidData.lpDD = this_int->lpLcl;
    	GetGuidData.dwPortId = dwVideoPortID;
    	GetGuidData.lpConnect = NULL;

	DOHALCALL( GetVideoPortConnectInfo, pfn, GetGuidData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return GetGuidData.ddRVal;
	}
	else if( DD_OK != GetGuidData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetGuidData.ddRVal;
	}

	if( NULL == lpConnect )
	{
    	    *lpdwNumEntries = GetGuidData.dwNumEntries;
	}

	else
	{
	    /*
	     * Make sure we have enough room for GUIDs
	     */
	    if( GetGuidData.dwNumEntries > *lpdwNumEntries )
	    {
		lpTemp = (LPDDVIDEOPORTCONNECT) MemAlloc(
		    sizeof( DDVIDEOPORTCONNECT ) * GetGuidData.dwNumEntries );
    	        GetGuidData.lpConnect = lpTemp;
	    }
	    else
	    {
    	    	GetGuidData.lpConnect = lpConnect;
	    }

	    DOHALCALL( GetVideoPortConnectInfo, pfn, GetGuidData, rc, 0 );
	    if( DDHAL_DRIVER_HANDLED != rc )
	    {
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
	    else if( DD_OK != GetGuidData.ddRVal )
	    {
	        LEAVE_DDRAW();
	        return GetGuidData.ddRVal;
	    }

	    /*
	     * Make sure the reserved fields are set to 0
	     */
	    for( i = 0; i < *lpdwNumEntries; i++ )
	    {
		GetGuidData.lpConnect[i].dwReserved1 = 0;
	    }

	    if( GetGuidData.lpConnect != lpConnect )
	    {
		memcpy( lpConnect, lpTemp,
		    sizeof( DDVIDEOPORTCONNECT ) * *lpdwNumEntries );
		MemFree( lpTemp );
    		LEAVE_DDRAW();
		return DDERR_MOREDATA;
	    }
	    else
	    {
		*lpdwNumEntries = GetGuidData.dwNumEntries;
	    }
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DDVPC_GetVideoPortConnectInfo */

/*
 * DDVPC_QueryVideoPortStatus
 */
HRESULT DDAPI DDVPC_QueryVideoPortStatus(
        LPDDVIDEOPORTCONTAINER lpDVP,
        DWORD dwVideoPortID,
	LPDDVIDEOPORTSTATUS lpStatus )
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    LPDDRAWI_DDVIDEOPORT_INT lpVP_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDVPC_QueryVideoPortStatus");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDVP;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	this = this_lcl->lpGbl;
    	if( ( lpStatus == NULL ) || !VALID_DDVIDEOPORTSTATUS_PTR( lpStatus ) )
    	{
            DPF_ERR ( "DDVPC_QueryVideoPortStatus: Invalid DDVIDEOPORTSTATUS ptr");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
	memset( lpStatus, 0, sizeof( DDVIDEOPORTSTATUS ) );
	lpStatus->dwSize = sizeof( DDVIDEOPORTSTATUS );
	if( dwVideoPortID >= this->ddCaps.dwMaxVideoPorts )
	{
            DPF_ERR ( "DDVPC_QueryVideoPortStatus: Invalid Video Port ID specified");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Search the list of video ports to see if anybody's using this one
     */
    lpVP_int = this->dvpList;
    while( lpVP_int != NULL )
    {
	if( ( lpVP_int->lpLcl->ddvpDesc.dwVideoPortID == dwVideoPortID ) &&
            !( lpVP_int->dwFlags & DDVPCREATE_NOTIFY ) )
	{
	     /*
	      * One does exist - return info about it
	      */
	     lpStatus->bInUse = TRUE;
	     memcpy( &(lpStatus->VideoPortType),
		&(lpVP_int->lpLcl->ddvpDesc.VideoPortType),
		sizeof( DDVIDEOPORTCONNECT ) );
	     lpStatus->dwFlags |= lpVP_int->dwFlags;
	}
	lpVP_int = lpVP_int->lpLink;
    }
    if( ( lpStatus->dwFlags & DDVPCREATE_VBIONLY ) &&
	( lpStatus->dwFlags & DDVPCREATE_VIDEOONLY ) )
    {
	lpStatus->dwFlags = 0;
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DDVPC_QueryVideoPortStatus */


/*
 * InsertVideoPortInList
 */
VOID InsertVideoPortInList( LPDDRAWI_DIRECTDRAW_GBL lpGbl, LPDDRAWI_DDVIDEOPORT_INT lpNew )
{
    if( NULL == lpGbl->dvpList )
    {
	lpGbl->dvpList = lpNew;
    }
    else
    {
	LPDDRAWI_DDVIDEOPORT_INT lpTemp;

	lpTemp = lpGbl->dvpList;
	while( NULL != lpTemp->lpLink )
	{
	    lpTemp = lpTemp->lpLink;
	}
	lpTemp->lpLink = lpNew;
    }
}


/*
 * IncrementRefCounts
 *
 * Used to increment the reference count of all surfaces that could
 * receive data from the video port, insuring that a surface isn't released
 * while we are using it.
 */
VOID IncrementRefCounts( LPDDRAWI_DDRAWSURFACE_INT surf_int )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;

    surf_first = surf_int;
    do
    {
    	DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) surf_int );
    	surf_int = FindAttachedFlip( surf_int );
    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
}


/*
 * DecrementRefCounts
 *
 * Used to decrement the reference count of all surfaces that were previously
 * AddRefed because they were using the video port.
 */
VOID DecrementRefCounts( LPDDRAWI_DDRAWSURFACE_INT surf_int )
{
    LPDDRAWI_DDRAWSURFACE_INT *lpSurfList;
    LPDDRAWI_DDRAWSURFACE_INT surf_first;
    DWORD dwCnt;
    DWORD i;

    /*
     * We cannot simply walk the chain, releasing each surface as we go
     * because if the ref cnt goes to zero, the chain goes away and we
     * cannot get to the next surface becasue the current interface is
     * unusable.  For this reason, we cnt how many explicit surfaces are
     * in the chain, allocate a buffer to store all of them, and then
     * release them without walking the chain.
     *
     * We do not release the implicitly created surfaces since 1) DirectDraw
     * ignores this anyway and 2) they are immediately released when
     * releasing their explicit surface, so touching them can be dangerous.
     */
    dwCnt = 0;
    surf_first = surf_int;
    do
    {
    	if( !( surf_int->lpLcl->dwFlags & DDRAWISURF_IMPLICITCREATE ) )
	{
	    dwCnt++;
	}
    	surf_int = FindAttachedFlip( surf_int );
    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
    lpSurfList = (LPDDRAWI_DDRAWSURFACE_INT *) MemAlloc( dwCnt *
    	sizeof( surf_first ) );
    if( lpSurfList == NULL )
    {
	return;
    }

    /*
     * Now put the surfaces in the list
     */
    i = 0;
    surf_int = surf_first;
    do
    {
    	if( !( surf_int->lpLcl->dwFlags & DDRAWISURF_IMPLICITCREATE ) )
	{
	    lpSurfList[i++] = surf_int;
	}
    	surf_int = FindAttachedFlip( surf_int );
    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );

    /*
     * Now release them
     */
    for( i = 0; i < dwCnt; i++ )
    {
    	DD_Surface_Release( (LPDIRECTDRAWSURFACE) lpSurfList[i] );
    }
    MemFree( lpSurfList );
}


/*
 * MergeVPDescriptions
 *
 * This function takes two DDVIDEOPORTDESC structures (one for VBI and one
 * for video) and merges them into a single structure.  If only one is
 * passed, it does a memcpy.
 */
VOID MergeVPDescriptions( LPDDVIDEOPORTDESC lpOutDesc,
    LPDDVIDEOPORTDESC lpInDesc, LPDDRAWI_DDVIDEOPORT_INT lpOtherInt )
{
    memcpy( lpOutDesc, lpInDesc, sizeof( DDVIDEOPORTDESC ) );
    if( lpOtherInt != NULL )
    {
	if( lpOtherInt->dwFlags & DDVPCREATE_VIDEOONLY )
	{
	    lpOutDesc->dwFieldWidth = lpOtherInt->lpLcl->ddvpDesc.dwFieldWidth;
	}
	else
	{
	    lpOutDesc->dwVBIWidth = lpOtherInt->lpLcl->ddvpDesc.dwVBIWidth;
	}
	if( lpOtherInt->lpLcl->ddvpDesc.dwFieldHeight > lpOutDesc->dwFieldHeight )
	{
	    lpOutDesc->dwFieldHeight = lpOtherInt->lpLcl->ddvpDesc.dwFieldHeight;
	}
	if( lpOtherInt->lpLcl->ddvpDesc.dwMicrosecondsPerField >
	    lpOutDesc->dwMicrosecondsPerField )
	{
	    lpOutDesc->dwMicrosecondsPerField =
		lpOtherInt->lpLcl->ddvpDesc.dwMicrosecondsPerField;
	}
	if( lpOtherInt->lpLcl->ddvpDesc.dwMaxPixelsPerSecond >
	    lpOutDesc->dwMaxPixelsPerSecond )
	{
	    lpOutDesc->dwMaxPixelsPerSecond =
		lpOtherInt->lpLcl->ddvpDesc.dwMaxPixelsPerSecond;
	}
    }
}


/*
 * MergeVPInfo
 *
 * This function takes two DDVIDEOPORTINFO structures (one for VBI and one
 * for video) and merges them into a single structure.
 */
HRESULT MergeVPInfo( LPDDRAWI_DDVIDEOPORT_LCL lpVP, LPDDVIDEOPORTINFO lpVBIInfo,
    LPDDVIDEOPORTINFO lpVideoInfo, LPDDVIDEOPORTINFO lpOutInfo )
{
    /*
     * First, handle the case where only one interface is on.  Also, we
     * require that the following be true for VBI/Video-only video ports:
     * 1) They both must set the dwVBIHeight.
     * 2) Neither one can crop the area immediately adjacent to the other.
     */
    if( lpVBIInfo == NULL )
    {
        if( lpVideoInfo->dwVBIHeight == 0 )
	{
	    DPF_ERR( "Video-only video port failed to set dwVBIHeight" );
	    return DDERR_INVALIDPARAMS;
	}
	memcpy( lpOutInfo, lpVideoInfo, sizeof( DDVIDEOPORTINFO ) );

	if( lpVideoInfo->dwVPFlags & DDVP_CROP )
	{
	    if( lpVideoInfo->rCrop.top > (int) lpVideoInfo->dwVBIHeight )
	    {
		DPF_ERR( "rCrop.top > dwVBIHeight on video-only video port" );
		return DDERR_INVALIDPARAMS;
	    }
	    lpOutInfo->rCrop.top = lpVideoInfo->dwVBIHeight;
	}
	else
	{
	    lpOutInfo->dwVPFlags |= DDVP_CROP;
	    lpOutInfo->rCrop.top = lpVideoInfo->dwVBIHeight;
	    lpOutInfo->rCrop.left = 0;
	    lpOutInfo->rCrop.right = lpVP->lpVideoDesc->dwFieldWidth;
	    lpOutInfo->rCrop.bottom = lpVP->lpVideoDesc->dwFieldHeight;
	}
    }
    else if( lpVideoInfo == NULL )
    {
        if( lpVBIInfo->dwVBIHeight == 0 )
	{
	    DPF_ERR( "VBI-only video port failed to set dwVBIHeight" );
	    return DDERR_INVALIDPARAMS;
	}
	memcpy( lpOutInfo, lpVBIInfo, sizeof( DDVIDEOPORTINFO ) );

	if( lpVBIInfo->dwVPFlags & DDVP_CROP )
	{
	    if( lpVBIInfo->rCrop.bottom < (int) lpVBIInfo->dwVBIHeight )
	    {
		DPF_ERR( "rCrop.bottom < dwVBIHeight on VBI-only video port" );
		return DDERR_INVALIDPARAMS;
	    }
	    lpOutInfo->rCrop.bottom = lpVBIInfo->dwVBIHeight;
	}
	else
	{
	    lpOutInfo->dwVPFlags |= DDVP_CROP;
	    lpOutInfo->rCrop.top = 0;
	    lpOutInfo->rCrop.bottom = lpVBIInfo->dwVBIHeight;
	    lpOutInfo->rCrop.left = 0;
	    lpOutInfo->rCrop.right = lpVP->lpVBIDesc->dwVBIWidth;
	}
    }

    /*
     * Now handle the case where both are on and we have to truly merge them.
     */
    else
    {
	memset( lpOutInfo, 0, sizeof( DDVIDEOPORTINFO ) );
	lpOutInfo->dwSize = sizeof( DDVIDEOPORTINFO );
	lpOutInfo->dwOriginX = lpVideoInfo->dwOriginX;
	lpOutInfo->dwOriginY = lpVideoInfo->dwOriginY;
	lpOutInfo->dwVPFlags = lpVideoInfo->dwVPFlags | lpVBIInfo->dwVPFlags;
	lpOutInfo->dwVBIHeight = lpVBIInfo->dwVBIHeight;

	/*
	 * Fix up the cropping.
	 */
	if( lpOutInfo->dwVPFlags & DDVP_CROP )
	{
	    if( ( lpVBIInfo->dwVPFlags & DDVP_CROP ) &&
		( lpVBIInfo->rCrop.bottom < (int) lpVBIInfo->dwVBIHeight ) )
	    {
		DPF_ERR( "rCrop.bottom < dwVBIHeight on VBI-only video port" );
		return DDERR_INVALIDPARAMS;
	    }
	    if( ( lpVideoInfo->dwVPFlags & DDVP_CROP ) &&
		( lpVideoInfo->rCrop.top > (int) lpVideoInfo->dwVBIHeight ) )
	    {
		DPF_ERR( "rCrop.top > dwVBIHeight on video-only video port" );
		return DDERR_INVALIDPARAMS;
	    }
	    lpOutInfo->dwVPFlags |= DDVP_IGNOREVBIXCROP;
	    if( lpVBIInfo->dwVPFlags & DDVP_CROP )
	    {
		lpOutInfo->rCrop.top = lpVBIInfo->rCrop.top;
	    }
	    else
	    {
		lpOutInfo->rCrop.top = 0;
	    }
	    if( lpVideoInfo->dwVPFlags & DDVP_CROP )
	    {
		lpOutInfo->rCrop.bottom = lpVideoInfo->rCrop.bottom;
		lpOutInfo->rCrop.left = lpVideoInfo->rCrop.left;
		lpOutInfo->rCrop.right = lpVideoInfo->rCrop.right;
	    }
	    else
	    {
		lpOutInfo->rCrop.bottom = lpVP->lpVideoDesc->dwFieldHeight;
		lpOutInfo->rCrop.left = 0;
		lpOutInfo->rCrop.right = lpVP->lpVideoDesc->dwFieldWidth;
	    }
	}
	else if( lpVP->ddvpDesc.dwFieldHeight > lpVP->lpVideoDesc->dwFieldHeight )
	{
	    lpOutInfo->dwVPFlags |= DDVP_CROP;
	    lpOutInfo->rCrop.top = 0;
	    lpOutInfo->rCrop.bottom = lpVP->lpVideoDesc->dwFieldHeight;
	    lpOutInfo->rCrop.left = 0;
	    lpOutInfo->rCrop.right = lpVP->lpVideoDesc->dwFieldWidth;
	}

	/*
	 * Handle pre-scaling.  Assume that VBI video ports are not allowed
	 * to prescale.
	 */
	if( lpVBIInfo->dwVPFlags & DDVP_PRESCALE )
	{
	    DPF_ERR( "VBI-only video port set DDVP_PRESCALE" );
	    return DDERR_INVALIDPARAMS;
	}
	else if( lpVideoInfo->dwVPFlags & DDVP_PRESCALE )
	{
	    lpOutInfo->dwPrescaleWidth = lpVideoInfo->dwPrescaleWidth;
	    lpOutInfo->dwPrescaleHeight = lpVideoInfo->dwPrescaleHeight;
	}

	lpOutInfo->lpddpfInputFormat = lpVideoInfo->lpddpfInputFormat;
	lpOutInfo->lpddpfVBIInputFormat = lpVBIInfo->lpddpfVBIInputFormat;
	lpOutInfo->lpddpfVBIOutputFormat = lpVBIInfo->lpddpfVBIOutputFormat;
    }

    return DD_OK;
}


/*
 * DDVPC_CreateVideoPort
 */
HRESULT DDAPI DDVPC_CreateVideoPort(
	LPDDVIDEOPORTCONTAINER lpDVP,
	DWORD dwClientFlags,
        LPDDVIDEOPORTDESC lpDesc,
	LPDIRECTDRAWVIDEOPORT FAR *lplpDDVideoPort,
	IUnknown FAR *pUnkOuter )
{
    DDVIDEOPORTDESC ddTempDesc;
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    LPDDRAWI_DDVIDEOPORT_INT lpVPInt;
    LPDDRAWI_DDVIDEOPORT_INT lpEven;
    LPDDRAWI_DDVIDEOPORT_INT lpOdd;
    LPDDRAWI_DDVIDEOPORT_INT lpOtherInt = NULL;
    LPDDVIDEOPORTCAPS lpAvailCaps;
    LPDDHALVPORTCB_CANCREATEVIDEOPORT ccvppfn;
    LPDDHALVPORTCB_CREATEVIDEOPORT cvppfn;
    LPDDRAWI_DDVIDEOPORT_INT new_int;
    LPDDRAWI_DDVIDEOPORT_LCL new_lcl;
    DWORD dwAvailCaps;
    DWORD dwConnectFlags;
    DWORD rc;


    if( pUnkOuter != NULL )
    {
	return CLASS_E_NOAGGREGATION;
    }
    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDVPC_CreateVideoPort");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDVP;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	this = this_lcl->lpGbl;
	#ifdef WINNT
    	    // Update DDraw handle in driver GBL object.
	    this->hDD = this_lcl->hDD;
	#endif

	if( dwClientFlags & ~( DDVPCREATE_VBIONLY|DDVPCREATE_VIDEOONLY) )
	{
	    DPF_ERR( "Invalid flags specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwClientFlags == ( DDVPCREATE_VBIONLY | DDVPCREATE_VIDEOONLY ) )
	{
	    /*
	     * SPecifying boht flags is the same as specifying neither
	     */
	    dwClientFlags = 0;
	}
    	if( ( NULL == lpDesc ) || !VALID_DDVIDEOPORTDESC_PTR( lpDesc ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}

    	if( ( NULL == lplpDDVideoPort ) || !VALID_PTR_PTR( lplpDDVideoPort ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( NULL == this->lpDDVideoPortCaps )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    	if( lpDesc->dwVideoPortID >= this->ddCaps.dwMaxVideoPorts )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( lpDesc->VideoPortType.dwReserved1 != 0 ) ||
	    ( lpDesc->dwReserved1 != 0 ) ||
	    ( lpDesc->dwReserved2 != 0 ) ||
	    ( lpDesc->dwReserved3 != 0 ) )
	{
	    DPF_ERR( "Reserved field not set to zero" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    	lpAvailCaps = &(this->lpDDVideoPortCaps[lpDesc->dwVideoPortID]);
    	if( !VALID_DDVIDEOPORTCAPS_PTR( lpAvailCaps ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
    	}
	if( ( dwClientFlags & DDVPCREATE_VBIONLY ) &&
	    !IndependantVBIPossible( lpAvailCaps ) )
    	{
	    DPF_ERR( "DDVPCREATE_VBIONLY is not supported" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    if( this_lcl->dwProcessId != GetCurrentProcessId() )
    {
	DPF_ERR( "Process does not have access to object" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Is the requested video port available?
     */
    lpVPInt = this->dvpList;
    lpEven = lpOdd = NULL;
    while( NULL != lpVPInt )
    {
	if( ( lpVPInt->lpLcl->ddvpDesc.dwVideoPortID == lpDesc->dwVideoPortID ) &&
            !( lpVPInt->dwFlags & DDVPCREATE_NOTIFY ) )
	{
	    if( lpVPInt->lpLcl->ddvpDesc.VideoPortType.dwFlags &
	    	DDVPCONNECT_SHAREEVEN )
	    {
		lpEven = lpVPInt;
	    }
	    else if( lpVPInt->lpLcl->ddvpDesc.VideoPortType.dwFlags &
	    	DDVPCONNECT_SHAREODD )
	    {
		lpOdd = lpVPInt;
	    }
	    else if( !dwClientFlags || !(lpVPInt->dwFlags) ||
		( dwClientFlags & lpVPInt->dwFlags ) )
	    {
		lpEven = lpOdd = lpVPInt;
	    }
	    else
	    {
		/*
		 * Video has been opened for VBI/Video only use.  Remember
		 * the other interface because we will need it shortly.
		 */
		lpOtherInt = lpVPInt;
	    }
	}
	lpVPInt = lpVPInt->lpLink;
    }
    if( ( NULL != lpEven ) && ( NULL != lpOdd ) )
    {
	DPF_ERR( "video port already in use" );
	LEAVE_DDRAW();
	return DDERR_OUTOFCAPS;
    }

    /*
     * Get the caps of the specified video port
     */
    dwAvailCaps = lpAvailCaps->dwCaps;
    dwConnectFlags = lpDesc->VideoPortType.dwFlags;
    if( NULL != lpEven )
    {
	dwAvailCaps &= ~( DDVPCAPS_NONINTERLACED |
	    DDVPCAPS_SKIPEVENFIELDS | DDVPCAPS_SKIPODDFIELDS );
    	if( dwConnectFlags & DDVPCONNECT_SHAREEVEN )
	{
	    DPF_ERR( "Even field already used" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDCAPS;
	}
    }
    else if( NULL != lpOdd )
    {
	dwAvailCaps &= ~( DDVPCAPS_NONINTERLACED |
	    DDVPCAPS_SKIPEVENFIELDS | DDVPCAPS_SKIPODDFIELDS );
    	if( dwConnectFlags & DDVPCONNECT_SHAREODD )
	{
	    DPF_ERR( "Odd field already used" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDCAPS;
	}
    }
    else if( dwClientFlags )
    {
	dwAvailCaps &= ~( DDVPCAPS_SKIPEVENFIELDS | DDVPCAPS_SKIPODDFIELDS );
    }

    /*
     * Check for incompatible flags/caps
     */
    if( ( dwConnectFlags & DDVPCONNECT_INTERLACED ) &&
    	!( dwAvailCaps & DDVPCAPS_INTERLACED ) )
    {
	DPF_ERR( "DDVPCONNECT_INTERLACED not supported" );
	LEAVE_DDRAW();
	return DDERR_INVALIDCAPS;
    }
    if( !( dwConnectFlags & DDVPCONNECT_INTERLACED ) &&
    	!( dwAvailCaps & DDVPCAPS_NONINTERLACED ) )
    {
	DPF_ERR( "Non interlaced is not supported" );
	LEAVE_DDRAW();
	return DDERR_INVALIDCAPS;
    }
    if( ( dwConnectFlags &
    	(DDVPCONNECT_SHAREEVEN|DDVPCONNECT_SHAREODD) ) &&
    	!( dwAvailCaps & DDVPCAPS_SHAREABLE ) )
    {
	DPF_ERR( "DDVPCONNECT_SHAREEVEN/SHAREODD not supported" );
	LEAVE_DDRAW();
	return DDERR_INVALIDCAPS;
    }
    if( !( dwConnectFlags & DDVPCONNECT_INTERLACED ) )
    {
	if( dwConnectFlags & ( DDVPCONNECT_SHAREEVEN |
	    DDVPCONNECT_SHAREODD ) )
	{
	    DPF_ERR( "cap invalid with non-interlaced video" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDCAPS;
	}
    }
    if( ( dwConnectFlags & DDVPCONNECT_SHAREEVEN ) &&
    	( dwConnectFlags & DDVPCONNECT_SHAREODD ) )
    {
	DPF_ERR( "shareeven and share odd are mutually exclusive" );
	LEAVE_DDRAW();
	return DDERR_INVALIDCAPS;
    }
    if( ( ( NULL != lpEven ) && !( dwConnectFlags & DDVPCONNECT_SHAREODD ) ) ||
        ( ( NULL != lpOdd ) && !( dwConnectFlags & DDVPCONNECT_SHAREEVEN ) ) )
    {
	DPF_ERR( "specifed video port must be shared" );
	LEAVE_DDRAW();
	return DDERR_INVALIDCAPS;
    }

    if( lpAvailCaps->dwMaxWidth < lpDesc->dwFieldWidth )
    {
	DPF_ERR( "specified width is too large" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    if( lpAvailCaps->dwMaxHeight < lpDesc->dwFieldHeight )
    {
	DPF_ERR( "specified height is too large" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    if( lpDesc->dwMicrosecondsPerField == 0 )
    {
	DPF_ERR( "Microseconds/field not specified" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    if( lpDesc->dwMaxPixelsPerSecond == 0 )
    {
	DPF_ERR( "Max pixels per second not specified" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    if( NULL != lpEven )
    {
    	if( !( ( IsEqualIID( &(lpDesc->VideoPortType.guidTypeID),
		&(lpOdd->lpLcl->ddvpDesc.VideoPortType.guidTypeID) ) ) &&
	    ( lpDesc->VideoPortType.dwPortWidth ==
		lpOdd->lpLcl->ddvpDesc.VideoPortType.dwPortWidth ) &&
	    ( ( lpDesc->VideoPortType.dwFlags & lpOdd->lpLcl->ddvpDesc.VideoPortType.dwFlags )
	        == lpDesc->VideoPortType.dwFlags ) ) )
	{
	    DPF_ERR( "invalid GUID specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    else if( NULL != lpOdd )
    {
    	if( !( ( IsEqualIID( &(lpDesc->VideoPortType.guidTypeID),
		&(lpEven->lpLcl->ddvpDesc.VideoPortType.guidTypeID) ) ) &&
	    ( lpDesc->VideoPortType.dwPortWidth ==
		lpEven->lpLcl->ddvpDesc.VideoPortType.dwPortWidth ) &&
	    ( ( lpDesc->VideoPortType.dwFlags & lpEven->lpLcl->ddvpDesc.VideoPortType.dwFlags )
	        == lpDesc->VideoPortType.dwFlags ) ) )
	{
	    DPF_ERR( "invalid GUID specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    else if( NULL != lpOtherInt )
    {
	/*
	 * Since they are both sharing the exact same connection, fail
	 * unless the connections are identical.
	 */
	if( lpDesc->VideoPortType.dwPortWidth !=
	    lpOtherInt->lpLcl->ddvpDesc.VideoPortType.dwPortWidth )
	{
	    DPF_ERR( "connection info must match other interface" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( lpDesc->VideoPortType.dwFlags !=
	    lpOtherInt->lpLcl->ddvpDesc.VideoPortType.dwFlags )
	{
	    DPF_ERR( "connection info must match other interface" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( !IsEqualIID( &(lpDesc->VideoPortType.guidTypeID),
	    &(lpOtherInt->lpLcl->ddvpDesc.VideoPortType.guidTypeID) ) )
	{
	    DPF_ERR( "connection info must match other interface" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    else
    {
	LPDDVIDEOPORTCONNECT lpConnect;
	DWORD dwNumEntries;
	DWORD i;
	DWORD rc;

	/*
	 * Verify that the connection can be supported.
	 */
	rc = DDVPC_GetVideoPortConnectInfo( lpDVP,
	    lpDesc->dwVideoPortID, &dwNumEntries, NULL );
	if( rc != DD_OK )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	lpConnect = (LPDDVIDEOPORTCONNECT) MemAlloc(
	    sizeof( DDVIDEOPORTCONNECT ) * dwNumEntries );
	if( NULL == lpConnect )
	{
	    LEAVE_DDRAW();
	    return DDERR_OUTOFMEMORY;
	}
	rc = DDVPC_GetVideoPortConnectInfo( lpDVP,
	    lpDesc->dwVideoPortID, &dwNumEntries, lpConnect );
	if( rc != DD_OK )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	for (i = 0; i < dwNumEntries; i++)
	{
    	    if( ( IsEqualIID( &(lpDesc->VideoPortType.guidTypeID),
		    &(lpConnect[i].guidTypeID) ) ) &&
		( lpDesc->VideoPortType.dwPortWidth ==
		    lpConnect[i].dwPortWidth ) )
	    {
		break;
	    }
	}
	MemFree( lpConnect );
	if ( i == dwNumEntries )
	{
	    DPF_ERR( "invalid GUID specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }

    /*
     * Turn merge the description of the multiple interfaces into one.
     */
    MergeVPDescriptions( &ddTempDesc, lpDesc, lpOtherInt );

    /*
     * Things look good so far.  Lets call the HAL and see if they
     * can handle it.
     */
    ccvppfn = this_lcl->lpDDCB->HALDDVideoPort.CanCreateVideoPort;
    if( NULL != ccvppfn )
    {
	DDHAL_CANCREATEVPORTDATA CanCreateData;

    	CanCreateData.lpDD = this_lcl;
    	CanCreateData.lpDDVideoPortDesc = &ddTempDesc;

	DOHALCALL( CanCreateVideoPort, ccvppfn, CanCreateData, rc, 0 );
	if( ( DDHAL_DRIVER_HANDLED == rc ) &&  (DD_OK != CanCreateData.ddRVal ) )
	{
	    LEAVE_DDRAW();
	    return CanCreateData.ddRVal;
	}
    }

    /*
     * Allocate the sucker(s)
     */
    new_int = MemAlloc( sizeof( DDRAWI_DDVIDEOPORT_INT ) );
    if( NULL == new_int )
    {
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }
    new_int->lpVtbl = (LPVOID)&ddVideoPortCallbacks;
    new_int->dwFlags = dwClientFlags;

    if( lpOtherInt != NULL )
    {
	new_lcl = lpOtherInt->lpLcl;
    }
    else
    {
	new_lcl = MemAlloc( sizeof( DDRAWI_DDVIDEOPORT_LCL ) +
	    ( 2 * sizeof( DDPIXELFORMAT ) ) );
	if( NULL == new_lcl )
	{
	    LEAVE_DDRAW();
	    return DDERR_OUTOFMEMORY;
	}
	new_lcl->lpDD = this_lcl;
	new_lcl->lpSurface = NULL;
	new_lcl->lpVBISurface = NULL;
    }
    if( dwClientFlags & DDVPCREATE_VBIONLY )
    {
	new_lcl->dwVBIProcessID = GetCurrentProcessId();
    }
    else
    {
	new_lcl->dwProcessID = GetCurrentProcessId();
    }
    new_int->lpLcl = new_lcl;
    memcpy( &(new_lcl->ddvpDesc), &ddTempDesc, sizeof( DDVIDEOPORTDESC ));

    /*
     * If this is a VBI/VIDEOONLY interface, save the original description
     * for future use.
     */
    if( dwClientFlags & DDVPCREATE_VBIONLY )
    {
	new_lcl->lpVBIDesc = MemAlloc( sizeof( DDVIDEOPORTDESC ) );
	if( NULL == new_lcl->lpVBIDesc )
	{
	    LEAVE_DDRAW();
	    return DDERR_OUTOFMEMORY;
	}
	memcpy( new_lcl->lpVBIDesc, lpDesc, sizeof( DDVIDEOPORTDESC ));
    }
    else if( dwClientFlags & DDVPCREATE_VIDEOONLY )
    {
	new_lcl->lpVideoDesc = MemAlloc( sizeof( DDVIDEOPORTDESC ) );
	if( NULL == new_lcl->lpVideoDesc )
	{
	    LEAVE_DDRAW();
	    return DDERR_OUTOFMEMORY;
	}
	memcpy( new_lcl->lpVideoDesc, lpDesc, sizeof( DDVIDEOPORTDESC ));
    }

    /*
     * Notify the HAL that we created it
     */
    cvppfn = this_lcl->lpDDCB->HALDDVideoPort.CreateVideoPort;
    if( NULL != cvppfn )
    {
	DDHAL_CREATEVPORTDATA CreateData;

    	CreateData.lpDD = this_lcl;
    	CreateData.lpDDVideoPortDesc = &ddTempDesc;
    	CreateData.lpVideoPort = new_lcl;

	DOHALCALL( CreateVideoPort, cvppfn, CreateData, rc, 0 );
	if( ( DDHAL_DRIVER_HANDLED == rc ) &&  (DD_OK != CreateData.ddRVal ) )
	{
	    LEAVE_DDRAW();
	    return CreateData.ddRVal;
	}
    }
    InsertVideoPortInList( this, new_int );

    DD_VP_AddRef( (LPDIRECTDRAWVIDEOPORT )new_int );
    *lplpDDVideoPort = (LPDIRECTDRAWVIDEOPORT) new_int;

    /*
     * Notify  kernel mode of we created the video port
     */
    #ifdef WIN95
        if( lpOtherInt == NULL )
        {
	    UpdateKernelVideoPort( new_lcl, DDKMVP_CREATE );
        }
    #endif

    LEAVE_DDRAW();

    return DD_OK;
} /* DDVPC_CreateVideoPort */


/*
 * DD_VP_AddRef
 */
DWORD DDAPI DD_VP_AddRef( LPDIRECTDRAWVIDEOPORT lpDVP )
{
    LPDDRAWI_DDVIDEOPORT_INT	this_int;
    LPDDRAWI_DDVIDEOPORT_LCL	this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_AddRef");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return 0;
    }

    DPF( 5, "DD_VP_AddRef, pid=%08lx, obj=%08lx", GETCURRPID(), lpDVP );

    TRY
    {
	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * bump refcnt
     */
    this_lcl->dwRefCnt++;
    this_int->dwIntRefCnt++;

    LEAVE_DDRAW();

    return this_int->dwIntRefCnt;

} /* DD_VP_AddRef */


/*
 * DD_VP_QueryInterface
 */
HRESULT DDAPI DD_VP_QueryInterface(LPDIRECTDRAWVIDEOPORT lpDVP, REFIID riid, LPVOID FAR * ppvObj )
{
    LPDDRAWI_DDVIDEOPORT_INT		this_int;
    LPDDRAWI_DDVIDEOPORT_LCL		this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_QueryInterface");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid videoport pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF_ERR( "Invalid videoport interface pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*ppvObj = NULL;
	if( !VALIDEX_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * asking for IUnknown?
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
	IsEqualIID(riid, &IID_IDirectDrawVideoPort) )
    {
	/*
	 * Our IUnknown interface is the same as our V1
	 * interface.  We must always return the V1 interface
	 * if IUnknown is requested.
	 */
    	*ppvObj = (LPVOID) this_int;
	DD_VP_AddRef( *ppvObj );
	LEAVE_DDRAW();
	return DD_OK;
    }
    else if( IsEqualIID(riid, &IID_IDirectDrawVideoPortNotify) )
    {
        HRESULT ret;
        
        ret = CreateVideoPortNotify (this_int, (LPDIRECTDRAWVIDEOPORTNOTIFY*)ppvObj);
	LEAVE_DDRAW();
	return ret;
    }

    DPF_ERR( "IID not understood by DirectDraw" );

    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DD_VP_QueryInterface */


/*
 * DD_VP_Release
 */
DWORD DDAPI DD_VP_Release(LPDIRECTDRAWVIDEOPORT lpDVP )
{
    LPDDRAWI_DDVIDEOPORT_INT	this_int;
    LPDDRAWI_DDVIDEOPORT_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDHALVPORTCB_DESTROYVPORT pfn;
    DWORD 			dwIntRefCnt;
    DWORD			rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_Release");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return 0;
    }

    TRY
    {
	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid videoport pointer" );
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
	pdrv = this_lcl->lpDD->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * decrement the reference count.  if it hits zero, free the surface
     */
    this_lcl->dwRefCnt--;
    this_int->dwIntRefCnt--;

    DPF( 5, "DD_VP_Release, Reference Count: Local = %ld Int = %ld",
         this_lcl->dwRefCnt, this_int->dwIntRefCnt );

    /*
     * interface at zero?
     */
    dwIntRefCnt = this_int->dwIntRefCnt;
    if( dwIntRefCnt == 0 )
    {
	LPDDRAWI_DDVIDEOPORT_INT	curr_int;
	LPDDRAWI_DDVIDEOPORT_INT	last_int;

	/*
	 * remove videoport from list
	 */
	curr_int = pdrv->dvpList;
	last_int = NULL;
	while( curr_int != this_int )
	{
	    last_int = curr_int;
	    curr_int = curr_int->lpLink;
	    if( curr_int == NULL )
	    {
		DPF_ERR( "VideoPort not in list!" );
		LEAVE_DDRAW();
		return 0;
	    }
	}
	if( last_int == NULL )
	{
	    pdrv->dvpList = pdrv->dvpList->lpLink;
	}
	else
	{
	    last_int->lpLink = curr_int->lpLink;
	}

	/*
	 * Decrement the surface reference counts and clean things up
	 */
        if( !( this_int->dwFlags & DDVPCREATE_NOTIFY ) )
        {
	    DD_VP_StopVideo( (LPDIRECTDRAWVIDEOPORT) this_int );
            this_lcl->dwFlags &= ~DDRAWIVPORT_ON;
	    if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	    {
	        if( this_lcl->lpVBISurface != NULL )
	        {
		    DecrementRefCounts( this_lcl->lpVBISurface );
		    this_lcl->lpVBISurface = NULL;
	        }
	        if( this_lcl->lpVBIDesc != NULL )
	        {
		    MemFree( this_lcl->lpVBIDesc );
		    this_lcl->lpVBIDesc = NULL;
	        }
	        if( this_lcl->lpVBIInfo != NULL )
	        {
		    MemFree( this_lcl->lpVBIInfo );
		    this_lcl->lpVBIInfo = NULL;
	        }
	        this_lcl->dwVBIProcessID = 0;
	    }
	    else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
	    {
	        if( this_lcl->lpSurface != NULL )
	        {
		    DecrementRefCounts( this_lcl->lpSurface );
		    this_lcl->lpSurface = NULL;
	        }
	        if( this_lcl->lpVideoDesc != NULL )
	        {
		    MemFree( this_lcl->lpVideoDesc );
		    this_lcl->lpVideoDesc = NULL;
	        }
	        if( this_lcl->lpVideoInfo != NULL )
	        {
		    MemFree( this_lcl->lpVideoInfo );
		    this_lcl->lpVideoInfo = NULL;
	        }
	        this_lcl->dwProcessID = 0;
	    }
	    else
	    {
	        if( this_lcl->lpSurface != NULL )
	        {
		    DecrementRefCounts( this_lcl->lpSurface );
	        }
	        if( this_lcl->lpVBISurface != NULL )
	        {
		    DecrementRefCounts( this_lcl->lpVBISurface );
	        }
	        this_lcl->dwProcessID = 0;
	    }
        }
        else
        {
            this_lcl->lpVPNotify = NULL;
        }

	/*
	 * just in case someone comes back in with this pointer, set
	 * an invalid vtbl & data ptr.
	 */
	this_int->lpVtbl = NULL;
	this_int->lpLcl = NULL;
	MemFree( this_int );
    }

    /*
     * local object at zero?
     */
    if( this_lcl->dwRefCnt == 0 )
    {
	/*
	 * turn off the videoport hardware
	 */
	if( this_lcl->dwFlags & DDRAWIVPORT_ON )
	{
	    DD_VP_StopVideo( lpDVP );
	}
	#ifdef WIN95
    	    UpdateKernelVideoPort( this_lcl, DDKMVP_RELEASE );
	#endif

	/*
	 * Notify the HAL
	 */
    	pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.DestroyVideoPort;
	if( NULL != pfn )
	{
	    DDHAL_DESTROYVPORTDATA DestroyVportData;

	    DestroyVportData.lpDD = this_lcl->lpDD;
	    DestroyVportData.lpVideoPort = this_lcl;

	    DOHALCALL( DestroyVideoPort, pfn, DestroyVportData, rc, 0 );
	    if( ( DDHAL_DRIVER_HANDLED == rc ) && ( DD_OK != DestroyVportData.ddRVal ) )
	    {
	    	LEAVE_DDRAW();
	    	return DestroyVportData.ddRVal;
	    }
    	}
	MemFree( this_lcl->lpFlipInts );
	MemFree( this_lcl );
    }

    LEAVE_DDRAW();

    return dwIntRefCnt;
}

/*
 * DD_VP_SetTargetSurface
 */
HRESULT DDAPI DD_VP_SetTargetSurface(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE lpSurface, DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT surf_int;
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
    LPDDRAWI_DDRAWSURFACE_INT lpTemp;
    LPDDRAWI_DDRAWSURFACE_INT lpPrevious;
    BOOL bWasOn;
    DWORD ddRVal;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_SetTargetSurface");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	surf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpSurface;
    	if( ( NULL == lpSurface ) || !VALID_DIRECTDRAWSURFACE_PTR( surf_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
	surf_lcl = surf_int->lpLcl;

        /*
         * Make sure the surface and video port belong to the same device.
         */
        if (surf_lcl->lpSurfMore->lpDD_lcl->lpGbl != this_lcl->lpDD->lpGbl)
        {
            DPF_ERR("Video port and Surface must belong to the same device");
	    LEAVE_DDRAW();
	    return DDERR_DEVICEDOESNTOWNSURFACE;
        }

	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    if( dwFlags & DDVPTARGET_VIDEO )
	    {
		DPF_ERR( "DDVPTARGET_VIDEO specified on a VBI-only video port" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    dwFlags |= DDVPTARGET_VBI;
	}
	else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
	{
	    if( dwFlags & DDVPTARGET_VBI )
	    {
		DPF_ERR( "DDVPTARGET_VBI specified on a video-only video port" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    dwFlags |= DDVPTARGET_VIDEO;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Surface must have the video port flag set
     */
    if( !( surf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT ) )
    {
	DPF_ERR( "Specified surface doesnt have DDSCAPS_VIDEOPORT set" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Can surface live in system memory?
     */
    if( surf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
    {
	if( !( this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID].dwCaps &
	    DDVPCAPS_SYSTEMMEMORY ) )
	{
	    DPF_ERR( "Video port surface must live in video memory" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    	if( surf_lcl->lpSurfMore->dwPageLockCount == 0 )
    	{
	    DPF_ERR( "Surface must be page locked" );
            LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }

    /*
     * If another surface in the chain is attached to a different video
     * port, fail now.
     */
    surf_first = surf_int;
    do
    {
    	if( ( surf_int->lpLcl->lpSurfMore->lpVideoPort != NULL ) &&
    	    ( surf_int->lpLcl->lpSurfMore->lpVideoPort != this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    	surf_int = FindAttachedFlip( surf_int );
    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
    surf_int = surf_first;

    /*
     * If the video was on, we need to temporarily turn it off.  Otherwise,
     * we could lose our kernel surfaces while they are still in use.
     */
    bWasOn = FALSE;
    if( this_int->dwFlags & DDVPCREATE_VBIONLY )
    {
	if( this_lcl->lpVBIInfo != NULL )
	{
	    bWasOn = TRUE;
	}
    }
    else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
    {
	if( this_lcl->lpVideoInfo != NULL )
	{
	    bWasOn = TRUE;
	}
    }
    else if( this_lcl->dwFlags & DDRAWIVPORT_ON )
    {
	bWasOn = TRUE;
    }
    if( bWasOn )
    {
	DD_VP_StopVideo( lpDVP );
    }

    if( dwFlags & DDVPTARGET_VIDEO )
    {
	/*
	 * Set the new surface
	 */
	lpPrevious = this_lcl->lpSurface;
	lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) this_lcl->lpSurface;
	this_lcl->lpSurface = surf_int;
	IncrementRefCounts( surf_int );
    }
    else if( dwFlags & DDVPTARGET_VBI )
    {
	if( this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID].dwCaps & DDVPCAPS_VBISURFACE )
	{
	    /*
	     * Set the new surface
	     */
	    lpPrevious = this_lcl->lpVBISurface;
	    lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) this_lcl->lpVBISurface;
    	    this_lcl->lpVBISurface = surf_int;
	    IncrementRefCounts( surf_int );
	}
	else
	{
	    DPF_ERR( "device does not support attaching VBI surfaces" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDCAPS;
	}
    }
    else
    {
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * If the video port is already on, we should tell the hardware
     * to make this change.
     */
    if( bWasOn )
    {
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    ddRVal = DD_VP_StartVideo( lpDVP, this_lcl->lpVBIInfo );
	}
	else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
	{
	    ddRVal = DD_VP_StartVideo( lpDVP, this_lcl->lpVideoInfo );
	}
	else
	{
	    ddRVal = DD_VP_StartVideo( lpDVP, &(this_lcl->ddvpInfo) );
	}
	if( ddRVal != DD_OK )
	{
	    // Restore the old surface
	    DD_VP_SetTargetSurface( lpDVP,
		(LPDIRECTDRAWSURFACE) lpTemp, dwFlags );
	    if( lpTemp != NULL )
	    {
		DecrementRefCounts( lpTemp );
	    }
    	    LEAVE_DDRAW();
    	    return ddRVal;
	}
    }

    /*
     * Decrement the ref counts of the previously attached surfaces.  We
     * wait until now so we don't inadvertantly blast data to a surface that
     * has just been released.
     */
    if( lpPrevious != NULL )
    {
	DecrementRefCounts( lpPrevious );
    }

    LEAVE_DDRAW();
    return DD_OK;
}

/*
 * DD_VP_Flip
 */
HRESULT DDAPI DD_VP_Flip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE lpSurface, DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_LCL	surf_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	surf_int;
    LPDDRAWI_DDRAWSURFACE_GBL	surf;
    LPDDRAWI_DDRAWSURFACE_INT	surf_dest_int;
    LPDDRAWI_DDRAWSURFACE_LCL	surf_dest_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDVIDEOPORT_INT	this_int;
    LPDDRAWI_DDVIDEOPORT_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	next_save_int;
    LPDDRAWI_DDRAWSURFACE_INT	next_int;
    BOOL			found_dest;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_Flip");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    TRY
    {
	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;

	if( this_lcl->ddvpInfo.dwVPFlags & DDVP_AUTOFLIP )
	{
	    DPF_ERR( "cannot manually flip while autoflipping is enabled" );
	    LEAVE_DDRAW();
	    return DDERR_NOTFLIPPABLE;
	}

	surf_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpSurface;
	if( NULL != surf_dest_int )
	{
	    if( !VALID_DIRECTDRAWSURFACE_PTR( surf_dest_int ) )
	    {
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDOBJECT;
	    }
	    surf_dest_lcl = surf_dest_int->lpLcl;
	    if( SURFACE_LOST( surf_dest_lcl ) )
	    {
	    	LEAVE_DDRAW();
	    	return DDERR_SURFACELOST;
	    }
	}
	else
	{
	    surf_dest_lcl = NULL;
	}

	if( dwFlags & DDVPFLIP_VBI )
	{
	    surf_int = this_lcl->lpVBISurface;
	}
	else
	{
	    surf_int = this_lcl->lpSurface;
	}
	if( surf_int == NULL )
	{
	    DPF_ERR( "SetTargetSurface not yet called" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	surf_lcl = surf_int->lpLcl;
	if( NULL == surf_lcl )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACENOTATTACHED;
	}
	else if( SURFACE_LOST( surf_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
	surf = surf_lcl->lpGbl;

	/*
	 * device busy?
	 */
	pdrv_lcl = surf_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

	#ifdef USE_ALIAS
	    if( pdrv->dwBusyDueToAliasedLock > 0 )
	    {
		/*
		 * Aliased locks (the ones that don't take the Win16 lock) don't
		 * set the busy bit either (it can't or USER get's very confused).
		 * However, we must prevent blits happening via DirectDraw as
		 * otherwise we get into the old host talking to VRAM while
		 * blitter does at the same time. Bad. So fail if there is an
		 * outstanding aliased lock just as if the BUST bit had been
		 * set.
		 */
		DPF_ERR( "Graphics adapter is busy (due to a DirectDraw lock)" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */

	if( *(pdrv->lpwPDeviceFlags) & BUSY )
	{
            DPF( 0, "BUSY - Flip" );
	    LEAVE_DDRAW()
	    return DDERR_SURFACEBUSY;
	}

	/*
	 * make sure that it's OK to flip this surface
	 */
	if( !(surf_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP) )
	{
	    LEAVE_DDRAW();
	    return DDERR_NOTFLIPPABLE;
	}
	if( surf->dwUsageCount > 0 )
        {
            DPF_ERR( "Can't flip because surface is locked" );
            LEAVE_DDRAW();
            return DDERR_SURFACEBUSY;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * make sure no surfaces are in use
     */
    found_dest = FALSE;
    next_save_int = next_int = FindAttachedFlip( surf_int );
    if( next_int == NULL )
    {
	LEAVE_DDRAW();
	return DDERR_NOTFLIPPABLE;		// ACKACK: real error?
    }

    do
    {
	if( SURFACE_LOST( next_int->lpLcl ) )
	{
	    DPF_ERR( "Can't flip - back buffer is lost" );
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	if( next_int->lpLcl->lpGbl->dwUsageCount != 0 )
	{
	    LEAVE_DDRAW();
            return DDERR_SURFACEBUSY;
	}
        if( surf_dest_int->lpLcl == next_int->lpLcl )
	{
	    found_dest = TRUE;
	}
	next_int = FindAttachedFlip( next_int );
    } while( next_int->lpLcl != surf_lcl );

    /*
     * see if we can use the specified destination
     */
    if( surf_dest_int != NULL )
    {
	if( !found_dest )
	{
	    DPF_ERR( "Destination not part of flipping chain!" );
	    LEAVE_DDRAW();
	    return DDERR_NOTFLIPPABLE;		// ACKACK: real error?
	}
	next_save_int = surf_dest_int;
    }

    /*
     * found the linked surface we want to flip to
     */
    next_int = next_save_int;

    rc = InternalVideoPortFlip( this_lcl, next_int, 1 );

    LEAVE_DDRAW();
    return (HRESULT)rc;
}

/*
 * InternalGetBandwidth
 */
HRESULT InternalGetBandwidth( LPDDRAWI_DDVIDEOPORT_LCL this_lcl,
    LPDDPIXELFORMAT lpf, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags,
    LPDDVIDEOPORTBANDWIDTH lpBandwidth )

{
    LPDDHALVPORTCB_GETBANDWIDTH pfn;
    DDHAL_GETVPORTBANDWIDTHDATA GetBandwidthData;
    DWORD rc;

    lpBandwidth->dwCaps = 0;
    lpBandwidth->dwOverlay = (DWORD) -1;
    lpBandwidth->dwColorkey = (DWORD) -1;
    lpBandwidth->dwYInterpolate = (DWORD) -1;
    lpBandwidth->dwYInterpAndColorkey = (DWORD) -1;

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.GetVideoPortBandwidth;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
    	GetBandwidthData.lpDD = this_lcl->lpDD;
    	GetBandwidthData.lpVideoPort = this_lcl;
    	GetBandwidthData.lpddpfFormat = lpf;
    	GetBandwidthData.dwWidth = dwWidth;
    	GetBandwidthData.dwHeight = dwHeight;
    	GetBandwidthData.lpBandwidth = lpBandwidth;
    	GetBandwidthData.dwFlags = dwFlags;

	DOHALCALL( GetVideoPortBandwidthInfo, pfn, GetBandwidthData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != GetBandwidthData.ddRVal )
	{
	    return GetBandwidthData.ddRVal;
	}
	lpBandwidth->dwReserved1 = 0;
	lpBandwidth->dwReserved2 = 0;
    }
    else
    {
    	return DDERR_UNSUPPORTED;
    }

    return DD_OK;
}


/*
 * DD_VP_GetBandwidth
 */
HRESULT DDAPI DD_VP_GetBandwidth(LPDIRECTDRAWVIDEOPORT lpDVP,
    LPDDPIXELFORMAT lpf, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags,
    LPDDVIDEOPORTBANDWIDTH lpBandwidth )
{
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_Getbandwidth");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (lpf == NULL) || !VALID_DDPIXELFORMAT_PTR( lpf ) )
    	{
	    DPF_ERR( "Invalid LPDDPIXELFORMAT specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( (lpBandwidth == NULL) || !VALID_DDVIDEOPORTBANDWIDTH_PTR( lpBandwidth ) )
    	{
	    DPF_ERR( "Invalid LPDDVIDEOPORTBANDWIDTH specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( ( dwHeight == 0 ) || ( dwWidth == 0 ) ) &&
	    !( dwFlags & DDVPB_TYPE ) )
    	{
	    DPF_ERR( "Width and Height must be specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( dwFlags & DDVPB_VIDEOPORT ) && ( dwFlags & DDVPB_OVERLAY ) )
    	{
	    DPF_ERR( "Mutually exclusive flags specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( dwFlags & DDVPB_VIDEOPORT )
	{
            if( !( this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID].dwFX &
                ( DDVPFX_PRESTRETCHX | DDVPFX_PRESTRETCHY |
                  DDVPFX_PRESTRETCHXN | DDVPFX_PRESTRETCHYN ) ) )
            {
                if( ( dwWidth > this_lcl->ddvpDesc.dwFieldWidth ) ||
                    ( dwHeight > this_lcl->ddvpDesc.dwFieldHeight ) )
                {
                    DPF_ERR( "Invalid Width/Height specified" );
                    LEAVE_DDRAW();
                    return DDERR_INVALIDPARAMS;
                }
	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    rc = InternalGetBandwidth( this_lcl, lpf, dwWidth, dwHeight,
    	dwFlags, lpBandwidth );

    LEAVE_DDRAW();

    return rc;
}


/*
 * DD_VP_GetInputFormats
 */
HRESULT DDAPI DD_VP_GetInputFormats(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwNum, LPDDPIXELFORMAT lpf, DWORD dwFlags )
{
    LPDDHALVPORTCB_GETINPUTFORMATS pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    LPDDPIXELFORMAT lpTemp = NULL;
    DDHAL_GETVPORTINPUTFORMATDATA GetFormatData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_GetInputFormats");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (lpdwNum == NULL) || !VALID_BYTE_ARRAY( lpdwNum, sizeof( LPVOID ) ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( NULL != lpf )
    	{
	    if( 0 == *lpdwNum )
    	    {
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	    if( !VALID_BYTE_ARRAY( lpf, *lpdwNum * sizeof( DDPIXELFORMAT ) ) )
    	    {
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
      	}
	if( ( dwFlags == 0 ) ||
	   ( dwFlags & ~(DDVPFORMAT_VIDEO|DDVPFORMAT_VBI|DDVPFORMAT_NOFAIL) ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( ( this_int->dwFlags & DDVPCREATE_VBIONLY ) &&
	    !( dwFlags & DDVPFORMAT_NOFAIL ) )
	{
	    if( dwFlags & DDVPFORMAT_VIDEO )
	    {
		DPF_ERR( "DDVPFORMAT_VIDEO specified on a VBI-only video port" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    dwFlags |= DDVPFORMAT_VBI;
	}
	else if( ( this_int->dwFlags & DDVPCREATE_VIDEOONLY ) &&
	    !( dwFlags & DDVPFORMAT_NOFAIL ) )
	{
	    if( dwFlags & DDVPFORMAT_VBI )
	    {
		DPF_ERR( "DDVPFORMAT_VBI specified on a video-only video port" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    dwFlags |= DDVPFORMAT_VIDEO;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.GetVideoPortInputFormats;
    if( pfn != NULL )
    {
	/*
	 * Get the number of formats
	 */
    	GetFormatData.lpDD = this_lcl->lpDD;
    	GetFormatData.dwFlags = dwFlags;
    	GetFormatData.lpVideoPort = this_lcl;
    	GetFormatData.lpddpfFormat = NULL;

	DOHALCALL( GetVideoPortInputFormats, pfn, GetFormatData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return GetFormatData.ddRVal;
	}
	else if( DD_OK != GetFormatData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetFormatData.ddRVal;
	}

	if( NULL == lpf )
	{
    	    *lpdwNum = GetFormatData.dwNumFormats;
	}

	else
	{
	    /*
	     * Make sure we have enough room for formats
	     */
	    if( GetFormatData.dwNumFormats > *lpdwNum )
	    {
		lpTemp = (LPDDPIXELFORMAT) MemAlloc( sizeof( DDPIXELFORMAT ) *
	    	    GetFormatData.dwNumFormats );
    	        GetFormatData.lpddpfFormat = lpTemp;
	    }
	    else
	    {
    	    	GetFormatData.lpddpfFormat = lpf;
	    }

	    DOHALCALL( GetVideoPortInputFormats, pfn, GetFormatData, rc, 0 );
	    if( DDHAL_DRIVER_HANDLED != rc )
	    {
		MemFree( lpTemp );
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
	    else if( DD_OK != GetFormatData.ddRVal )
	    {
		MemFree( lpTemp );
	        LEAVE_DDRAW();
	        return GetFormatData.ddRVal;
	    }

	    if( GetFormatData.lpddpfFormat != lpf )
	    {
		memcpy( lpf, lpTemp, sizeof( DDPIXELFORMAT ) * *lpdwNum );
		MemFree( lpTemp );
    		LEAVE_DDRAW();
		return DDERR_MOREDATA;
	    }
	    else
	    {
		*lpdwNum = GetFormatData.dwNumFormats;
	    }
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
}

/*
 * DD_VP_GetOutputFormats
 */
HRESULT DDAPI DD_VP_GetOutputFormats(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDPIXELFORMAT lpddpfInput, LPDWORD lpdwNum, LPDDPIXELFORMAT lpddpfOutput, DWORD dwFlags )
{
    LPDDHALVPORTCB_GETOUTPUTFORMATS pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    LPDDPIXELFORMAT lpTemp = NULL;
    DDHAL_GETVPORTOUTPUTFORMATDATA GetFormatData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_GetOutputFormats");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( !VALID_DDPIXELFORMAT_PTR( lpddpfInput ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( (lpdwNum == NULL) || !VALID_BYTE_ARRAY( lpdwNum, sizeof( LPVOID ) ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( NULL != lpddpfOutput )
    	{
	    if( 0 == *lpdwNum )
    	    {
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	    if( !VALID_BYTE_ARRAY( lpddpfOutput, *lpdwNum * sizeof( DDPIXELFORMAT ) ) )
    	    {
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
      	}
	if( ( dwFlags == 0 ) ||
	    ( dwFlags & ~(DDVPFORMAT_VIDEO|DDVPFORMAT_VBI|DDVPFORMAT_NOFAIL) ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( ( this_int->dwFlags & DDVPCREATE_VBIONLY ) &&
	    !( dwFlags & DDVPFORMAT_NOFAIL ) )
	{
	    if( dwFlags & DDVPFORMAT_VIDEO )
	    {
		DPF_ERR( "DDVPFORMAT_VIDEO specified on a VBI-only video port" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    dwFlags |= DDVPFORMAT_VBI;
	}
	else if( ( this_int->dwFlags & DDVPCREATE_VIDEOONLY ) &&
	    !( dwFlags & DDVPFORMAT_NOFAIL ) )
	{
	    if( dwFlags & DDVPFORMAT_VBI )
	    {
		DPF_ERR( "DDVPFORMAT_VBI specified on a video-only video port" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    dwFlags |= DDVPFORMAT_VIDEO;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.GetVideoPortOutputFormats;
    if( pfn != NULL )
    {
	/*
	 * Get the number of formats
	 */
    	GetFormatData.lpDD = this_lcl->lpDD;
    	GetFormatData.dwFlags = dwFlags;
    	GetFormatData.lpVideoPort = this_lcl;
    	GetFormatData.lpddpfInputFormat = lpddpfInput;
    	GetFormatData.lpddpfOutputFormats = NULL;

	DOHALCALL( GetVideoPortOutputFormats, pfn, GetFormatData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
	else if( DD_OK != GetFormatData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetFormatData.ddRVal;
	}

	if( NULL == lpddpfOutput )
	{
    	    *lpdwNum = GetFormatData.dwNumFormats;
	}

	else
	{
	    /*
	     * Make sure we have enough room for formats
	     */
	    if( GetFormatData.dwNumFormats > *lpdwNum )
	    {
		lpTemp = (LPDDPIXELFORMAT) MemAlloc( sizeof( DDPIXELFORMAT ) *
	    	    GetFormatData.dwNumFormats );
    	        GetFormatData.lpddpfOutputFormats = lpTemp;
	    }
	    else
	    {
    	    	GetFormatData.lpddpfOutputFormats = lpddpfOutput;
	    }

	    DOHALCALL( GetVideoPortOutputFormats, pfn, GetFormatData, rc, 0 );
	    if( DDHAL_DRIVER_HANDLED != rc )
	    {
		MemFree( lpTemp );
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
	    else if( DD_OK != GetFormatData.ddRVal )
	    {
		MemFree( lpTemp );
	        LEAVE_DDRAW();
	        return GetFormatData.ddRVal;
	    }

	    if( GetFormatData.lpddpfOutputFormats != lpddpfOutput )
	    {
		memcpy( lpddpfOutput, lpTemp, sizeof( DDPIXELFORMAT ) * *lpdwNum );
		MemFree( lpTemp );
    		LEAVE_DDRAW();
		return DDERR_MOREDATA;
	    }
	    else
	    {
		*lpdwNum = GetFormatData.dwNumFormats;
	    }
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * DD_VP_GetField
 */
HRESULT DDAPI DD_VP_GetField(LPDIRECTDRAWVIDEOPORT lpDVP, LPBOOL lpField )
{
    LPDDHALVPORTCB_GETFIELD pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DWORD rc;
    DDHAL_GETVPORTFIELDDATA GetFieldData;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_GetField");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (NULL == lpField ) || !VALID_BOOL_PTR( lpField ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.GetVideoPortField;
    if( pfn != NULL )
    {
    	GetFieldData.lpDD = this_lcl->lpDD;
    	GetFieldData.lpVideoPort = this_lcl;
    	GetFieldData.bField = 0;

	DOHALCALL( GetVideoPortField, pfn, GetFieldData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
	else if( DD_OK != GetFieldData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetFieldData.ddRVal;
	}

	*lpField = GetFieldData.bField;
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * DD_VP_GetLine
 */
HRESULT DDAPI DD_VP_GetLine(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwLine )
{
    LPDDHALVPORTCB_GETLINE pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DWORD rc;
    DDHAL_GETVPORTLINEDATA GetLineData;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_GetLine");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (NULL == lpdwLine ) || !VALID_DWORD_PTR( lpdwLine ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.GetVideoPortLine;
    if( pfn != NULL )
    {
    	GetLineData.lpDD = this_lcl->lpDD;
    	GetLineData.lpVideoPort = this_lcl;
    	GetLineData.dwLine = 0;

	DOHALCALL( GetVideoPortLine, pfn, GetLineData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
	else if( DD_OK != GetLineData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetLineData.ddRVal;
	}

	*lpdwLine = GetLineData.dwLine;
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * ValidateVideoInfo
 */
HRESULT ValidateVideoInfo(LPDDRAWI_DDVIDEOPORT_INT this_int,
    LPDDVIDEOPORTINFO lpInfo, LPDWORD lpNumAutoFlip, LPDWORD lpNumVBIAutoFlip )
{
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    LPDDPIXELFORMAT lpOutputFormat;
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = NULL;
    DWORD rc;
    DWORD dwAvailCaps;
    DWORD dwAvailFX;
    DWORD dwConnectFlags;
    DWORD dwVPFlags;
    DWORD dwNum;
    DWORD i;

    this_lcl = this_int->lpLcl;
    *lpNumAutoFlip = 0;
    *lpNumVBIAutoFlip = 0;

    /*
     * Check for invalid caps
     */
    dwAvailCaps = this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID].dwCaps;
    dwAvailFX = this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID].dwFX;
    dwConnectFlags = this_lcl->ddvpDesc.VideoPortType.dwFlags;
    dwVPFlags = lpInfo->dwVPFlags;
    if( ( dwVPFlags & DDVP_AUTOFLIP ) && !( dwAvailCaps & DDVPCAPS_AUTOFLIP ) )
    {
	DPF_ERR( "Invalid autoflip capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & DDVP_INTERLEAVE ) && (
    	!( dwConnectFlags & DDVPCONNECT_INTERLACED ) ||
    	( dwConnectFlags & DDVPCONNECT_SHAREEVEN ) ||
    	( dwConnectFlags & DDVPCONNECT_SHAREODD ) ||
    	!( dwAvailFX & DDVPFX_INTERLEAVE ) ||
	( dwVPFlags & DDVP_SKIPODDFIELDS ) ||
	( dwVPFlags & DDVP_SKIPEVENFIELDS ) ) )
    {
	DPF_ERR( "Invalid interleave capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & DDVP_MIRRORLEFTRIGHT ) && !( dwAvailFX & DDVPFX_MIRRORLEFTRIGHT ) )
    {
	DPF_ERR( "Invalid mirror left/right capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & DDVP_MIRRORUPDOWN ) && !( dwAvailFX & DDVPFX_MIRRORUPDOWN ) )
    {
	DPF_ERR( "Invalid mirror up/down capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & DDVP_SKIPEVENFIELDS ) && (
    	!( dwConnectFlags & DDVPCONNECT_INTERLACED ) ||
    	( dwConnectFlags & DDVPCONNECT_SHAREEVEN ) ||
    	( dwConnectFlags & DDVPCONNECT_SHAREODD ) ||
    	!( dwAvailCaps & DDVPCAPS_SKIPEVENFIELDS ) ||
	( dwVPFlags & DDVP_SKIPODDFIELDS ) ) )
    {
	DPF_ERR( "Invalid skipevenfields capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & DDVP_SKIPODDFIELDS ) && (
    	!( dwConnectFlags & DDVPCONNECT_INTERLACED ) ||
    	( dwConnectFlags & DDVPCONNECT_SHAREEVEN ) ||
    	( dwConnectFlags & DDVPCONNECT_SHAREODD ) ||
    	!( dwAvailCaps & DDVPCAPS_SKIPODDFIELDS ) ) )
    {
	DPF_ERR( "Invalid skipoddfields capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & DDVP_VBINOSCALE ) && !( dwAvailFX & DDVPFX_VBINOSCALE ) )
    {
	DPF_ERR( "Invalid VBI no-scale capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & ( DDVP_VBICONVERT | DDVP_VBINOSCALE ) ) ||
    	( NULL != this_lcl->lpVBISurface ) )
    {
	if( ( lpInfo->dwVBIHeight == 0 ) ||
	    ( lpInfo->dwVBIHeight >= this_lcl->ddvpDesc.dwFieldHeight ) )
    	{
	    DPF_ERR( "Invalid dwVBIHeight specified" );
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( dwVPFlags & DDVP_CROP ) &&
	    ( lpInfo->rCrop.top > (int) lpInfo->dwVBIHeight ) )
	{
	    DPF_ERR( "Invalid dwVBIHeight specified" );
	    return DDERR_INVALIDPARAMS;
	}
    }
    if( dwVPFlags & DDVP_CROP )
    {
	if( lpInfo->rCrop.bottom > (int) this_lcl->ddvpDesc.dwFieldHeight )
	{
	    DPF_ERR( "Invalid cropping rectangle specified" );
	    return DDERR_SURFACENOTATTACHED;
	}
	if( !( dwAvailFX & ( DDVPFX_CROPY | DDVPFX_CROPTOPDATA ) ) && (
	        (lpInfo->rCrop.bottom - lpInfo->rCrop.top ) !=
	        (int) this_lcl->ddvpDesc.dwFieldHeight ) )
	{
	    DPF_ERR( "Invalid cropping rectangle specified" );
	    return DDERR_SURFACENOTATTACHED;
	}
	if( lpInfo->rCrop.top >= (int) lpInfo->dwVBIHeight )
	{
	    lpInfo->dwVBIHeight = 0;
	}

	/*
	 * Only do the extensive field width/height checking if the video
	 * region is involved
	 */
	if( lpInfo->rCrop.bottom > (int) lpInfo->dwVBIHeight )
	{
	    if( lpInfo->rCrop.right > (int) this_lcl->ddvpDesc.dwFieldWidth )
	    {
	        DPF_ERR( "Invalid cropping rectangle specified" );
	        return DDERR_SURFACENOTATTACHED;
	    }
	    if( !( dwAvailFX & DDVPFX_CROPX ) && (
	        (lpInfo->rCrop.right - lpInfo->rCrop.left ) !=
	        (int) this_lcl->ddvpDesc.dwFieldWidth ) )
	    {
	        DPF_ERR( "Invalid cropping rectangle specified" );
	        return DDERR_SURFACENOTATTACHED;
	    }
	    if( ( ( lpInfo->rCrop.right - lpInfo->rCrop.left ) ==
	        (int) this_lcl->ddvpDesc.dwFieldWidth ) &&
	        ( ( lpInfo->rCrop.bottom - lpInfo->rCrop.top ) ==
	        (int) this_lcl->ddvpDesc.dwFieldHeight ) )
	    {
	        dwVPFlags &= ~DDVP_CROP;
	        lpInfo->dwVPFlags &= ~DDVP_CROP;
	    }
	}
    }
    if( dwVPFlags & DDVP_PRESCALE )
    {
	DWORD dwPreWidth;
	DWORD dwPreHeight;

	if( dwVPFlags & DDVP_CROP )
	{
	    dwPreWidth = lpInfo->rCrop.right - lpInfo->rCrop.left;
	    dwPreHeight = lpInfo->rCrop.bottom - lpInfo->rCrop.top;
	}
	else
	{
	    dwPreWidth = this_lcl->ddvpDesc.dwFieldWidth;
	    dwPreHeight = this_lcl->ddvpDesc.dwFieldHeight;
	}
	if( lpInfo->dwPrescaleWidth > dwPreWidth )
	{
	    if( !( dwAvailFX & DDVPFX_PRESTRETCHX ) &&
	        !( ( dwAvailFX & DDVPFX_PRESTRETCHXN ) &&
		    ( lpInfo->dwPrescaleWidth % dwPreWidth ) ) )
	    {
	    	DPF_ERR( "Invalid stretch specified" );
	    	return DDERR_INVALIDPARAMS;
	    }
	}
	if( lpInfo->dwPrescaleHeight > dwPreHeight )
	{
	    if( !( dwAvailFX & DDVPFX_PRESTRETCHY ) &&
	        !( ( dwAvailFX & DDVPFX_PRESTRETCHYN ) &&
		    ( lpInfo->dwPrescaleHeight % dwPreHeight ) ) )
	    {
	    	DPF_ERR( "Invalid stretch specified" );
	    	return DDERR_INVALIDPARAMS;
	    }
	}

	if( lpInfo->dwPrescaleWidth < dwPreWidth )
	{
	    if( !( dwAvailFX & DDVPFX_PRESHRINKX ) &&
	        !( dwAvailFX & DDVPFX_PRESHRINKXS ) &&
	        !( dwAvailFX & DDVPFX_PRESHRINKXB ) )
	    {
	    	DPF_ERR( "Invalid shrink specified" );
	    	return DDERR_INVALIDPARAMS;
	    }
	}
	if( lpInfo->dwPrescaleHeight < dwPreHeight )
	{
	    if( !( dwAvailFX & DDVPFX_PRESHRINKY ) &&
	        !( dwAvailFX & DDVPFX_PRESHRINKYS ) &&
	        !( dwAvailFX & DDVPFX_PRESHRINKYB ) )
	    {
	    	DPF_ERR( "Invalid shrink specified" );
	    	return DDERR_INVALIDPARAMS;
	    }
	}
	if( ( lpInfo->dwPrescaleWidth == dwPreWidth ) &&
	    ( lpInfo->dwPrescaleHeight == dwPreHeight ) )
	{
	    dwVPFlags &= ~DDVP_PRESCALE;
	    lpInfo->dwVPFlags &= ~DDVP_PRESCALE;
	}
    }
    if( dwVPFlags & DDVP_VBINOINTERLEAVE )
    {
	if( !( dwAvailFX & DDVPFX_VBINOINTERLEAVE ) )
	{
	    DPF_ERR( "Device does not support DDVP_VBINOINTERLEAVE" );
	    return DDERR_INVALIDPARAMS;
	}
	if( this_lcl->lpVBISurface == NULL )
	{
	    DPF_ERR( "DDVP_VBINOINTERLEAVE only valid when using a separate VBI surface" );
	    return DDERR_INVALIDPARAMS;
	}
    }
    if( dwVPFlags & DDVP_HARDWAREDEINTERLACE )
    {
	if( !( dwAvailCaps & DDVPCAPS_HARDWAREDEINTERLACE ) )
	{
	    DPF_ERR( "DDVP_HARDWAREDEINTERLACE not supported by this device" );
	    return DDERR_INVALIDPARAMS;
	}
	if( ( this_lcl->lpSurface != NULL ) &&
	    !( this_lcl->lpSurface->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 &
	    DDSCAPS2_RESERVED4 ) )
	{
	    DPF_ERR( "DDSCAPS2_RESERVED4 not set on target surface" );
	    return DDERR_INVALIDPARAMS;
	}
	if( ( this_lcl->lpVBISurface != NULL ) &&
	    !( this_lcl->lpVBISurface->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 &
	    DDSCAPS2_RESERVED4 ) )
	{
	    DPF_ERR( "DDSCAPS2_RESERVED4 not set on target surface" );
	    return DDERR_INVALIDPARAMS;
	}
        if( dwVPFlags & DDVP_AUTOFLIP )
        {
	    DPF_ERR( "DDVP_HARDWAREDEINTERLACE not valid with DDVP_AUTOFLIP" );
	    return DDERR_INVALIDPARAMS;
	}
    }

    /*
     * Fail if neither a VBI or regular surface is attached
     */
    if( ( NULL == this_lcl->lpSurface ) && ( NULL == this_lcl->lpVBISurface ) )
    {
	DPF_ERR( "No surfaces are attached to the video port" );
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Validate the regular video data
     */
    if( ( NULL != this_lcl->lpSurface ) &&
        ( this_int->lpLcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
    {
	DWORD dwVidWidth;
	DWORD dwVidHeight;

	/*
	 * Validate the input format
	 */
	dwNum = MAX_VP_FORMATS;
	rc = DD_VP_GetInputFormats( (LPDIRECTDRAWVIDEOPORT) this_int,
	    &dwNum, ddpfVPFormats, DDVPFORMAT_VIDEO | DDVPFORMAT_NOFAIL );
	if( ( rc != DD_OK ) && ( rc != DDERR_MOREDATA ) )
	{
	    DPF_ERR( "Invalid input format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}
	i = 0;
	while( ( i < dwNum ) && IsDifferentPixelFormat( &(ddpfVPFormats[i]),
	    lpInfo->lpddpfInputFormat ) )
	{
	    i++;
	}
	if( i == dwNum )
	{
	    DPF_ERR( "Invalid input format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}

	/*
	 * Validate the output format
	 */
	dwNum = MAX_VP_FORMATS;
	rc = DD_VP_GetOutputFormats( (LPDIRECTDRAWVIDEOPORT) this_int,
	    lpInfo->lpddpfInputFormat, &dwNum, ddpfVPFormats,
	    DDVPFORMAT_VIDEO | DDVPFORMAT_NOFAIL );
	if( ( rc != DD_OK ) && ( rc != DDERR_MOREDATA ) )
	{
	    DPF_ERR( "Invalid output format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}
	i = 0;
	surf_lcl = this_lcl->lpSurface->lpLcl;
	lpOutputFormat = GetSurfaceFormat( surf_lcl );
	if( ( IsDifferentPixelFormat( lpInfo->lpddpfInputFormat,
	    lpOutputFormat ) ) && !( dwVPFlags |= DDVP_CONVERT ) )
	{
	    DPF_ERR( "Invalid output format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}
	while( ( i < dwNum ) && IsDifferentPixelFormat( &(ddpfVPFormats[i]),
	    lpOutputFormat ) )
	{
	    i++;
	}
	if( i == dwNum )
	{
	    DPF_ERR( "Invalid output format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}

	/*
	 * Make sure the video fits within the attached surface
	 */
	if( SURFACE_LOST( surf_lcl ) )
	{
	    DPF_ERR( "Target surface is lost" );
	    return DDERR_SURFACELOST;
	}

	if( dwVPFlags & DDVP_PRESCALE )
	{
	    dwVidWidth = lpInfo->dwPrescaleWidth;
	    dwVidHeight = lpInfo->dwPrescaleHeight;
	}
	else if( dwVPFlags & DDVP_CROP )
	{
	    dwVidWidth = lpInfo->rCrop.right - lpInfo->rCrop.left;
	    dwVidHeight = lpInfo->rCrop.bottom - lpInfo->rCrop.top;
	}
	else
	{
	    dwVidWidth = this_lcl->ddvpDesc.dwFieldWidth;
	    dwVidHeight = this_lcl->ddvpDesc.dwFieldHeight;
	}
        if( ( lpInfo->dwVBIHeight > 0 ) &&
            ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) &&
            ( NULL != this_lcl->lpVBISurface ) )
        {
            dwVidHeight -= lpInfo->dwVBIHeight;
        }
	if( dwVPFlags & DDVP_INTERLEAVE )
	{
	    dwVidHeight *= 2;
	}

	if( lpInfo->dwOriginX + dwVidWidth > (DWORD) surf_lcl->lpGbl->wWidth )
	{
	    DPF_ERR( "surface is not wide enough to hold the videoport data" );
	    return DDERR_TOOBIGWIDTH;
	}
	if( lpInfo->dwOriginY + dwVidHeight > (DWORD) surf_lcl->lpGbl->wHeight )
	{
	    DPF_ERR( "surface is not tall enough to hold the videoport data" );
	    return DDERR_TOOBIGHEIGHT;
	}
    }
    else if( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON )
    {
        DPF_ERR( "Video surface not specified" );
        return DDERR_INVALIDPARAMS;
    }

    /*
     * Validate the VBI formats.
     */
    if( ( lpInfo->dwVBIHeight > 0 ) &&
        ( this_int->lpLcl->dwFlags & DDRAWIVPORT_VBION ) )
    {
	if( lpInfo->lpddpfVBIInputFormat == NULL )
	{
	    DPF_ERR( "VBI input format not specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}
    }

    /*
     * Unless they want to convert the format, we don't do very much
     * error checking.
     */
    if( dwVPFlags & DDVP_VBICONVERT )
    {
	if( !( dwAvailFX & DDVPFX_VBICONVERT ) )
	{
	    DPF_ERR( "device cannot convert the VBI data" );
	    return DDERR_INVALIDCAPS;
	}

	/*
	 * Validate the VBI input format
	 */
    	dwNum = MAX_VP_FORMATS;
    	rc = DD_VP_GetInputFormats( (LPDIRECTDRAWVIDEOPORT) this_int,
    	    &dwNum, ddpfVPFormats, DDVPFORMAT_VBI | DDVPFORMAT_NOFAIL );
    	if( ( rc != DD_OK ) && ( rc != DDERR_MOREDATA ) )
    	{
	    DPF_ERR( "Invalid input VBI format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
    	}
    	i = 0;
    	while( ( i < dwNum ) && IsDifferentPixelFormat( &(ddpfVPFormats[i]),
    	    lpInfo->lpddpfVBIInputFormat ) )
    	{
	    i++;
    	}
    	if( i == dwNum )
    	{
	    DPF_ERR( "Invalid VBI input format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
    	}

    	/*
     	 * Validate the VBI output format
     	 */
	if( lpInfo->lpddpfVBIOutputFormat == NULL )
	{
	    DPF_ERR( "VBI output format not specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}
    	dwNum = MAX_VP_FORMATS;
    	rc = DD_VP_GetOutputFormats( (LPDIRECTDRAWVIDEOPORT) this_int,
    	    lpInfo->lpddpfVBIInputFormat, &dwNum, ddpfVPFormats,
	    DDVPFORMAT_VBI | DDVPFORMAT_NOFAIL );
    	if( ( rc != DD_OK ) && ( rc != DDERR_MOREDATA ) )
    	{
	    DPF_ERR( "Invalid output format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
    	}
    	i = 0;
    	while( ( i < dwNum ) && IsDifferentPixelFormat( &(ddpfVPFormats[i]),
    	    lpInfo->lpddpfVBIOutputFormat ) )
    	{
	    i++;
    	}
    	if( i == dwNum )
    	{
	    DPF_ERR( "Invalid VBI output format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
    	}
    }

    /*
     * Validate the VBI surface
     */
    if( ( lpInfo->dwVBIHeight > 0 ) &&
        ( this_int->lpLcl->dwFlags & DDRAWIVPORT_VBION ) )
    {
	DWORD dwVBIBytes;
        DWORD dwSurfaceBytes = 0;
	DWORD dwVBIHeight;

	/*
	 * Determine the height of the VBI data
	 */
	dwVBIHeight = lpInfo->dwVBIHeight;
	if( dwVPFlags & DDVP_CROP )
	{
	    if( lpInfo->rCrop.top < (int) lpInfo->dwVBIHeight )
	    {
	        dwVBIHeight -= lpInfo->rCrop.top;
	        if( lpInfo->rCrop.bottom < (int) lpInfo->dwVBIHeight )
	        {
	            dwVBIHeight -= (lpInfo->dwVBIHeight - (DWORD)lpInfo->rCrop.bottom);
		}
	    }
	    else
	    {
	        dwVBIHeight = 0;
	    }
	}
	if( ( dwVPFlags & DDVP_INTERLEAVE ) &&
	    !( dwVPFlags & DDVP_VBINOINTERLEAVE ) )
	{
	    dwVBIHeight *= 2;
	}

	/*
	 * Make sure that the data will fit in the surface
	 */
	if( ( dwVPFlags & DDVP_VBINOSCALE ) ||
	    !( dwVPFlags & DDVP_PRESCALE ) )
	{
	    dwVBIBytes = this_lcl->ddvpDesc.dwVBIWidth;
	}
	else
	{
	    dwVBIBytes = lpInfo->dwPrescaleWidth;
	}
	if( dwVPFlags & DDVP_VBICONVERT )
	{
	    lpOutputFormat = lpInfo->lpddpfVBIOutputFormat;
	}
	else
	{
	    lpOutputFormat = lpInfo->lpddpfVBIInputFormat;
	}
	if( lpOutputFormat->dwRGBBitCount )
	{
	    dwVBIBytes *= lpOutputFormat->dwRGBBitCount;
	    dwVBIBytes /= 8;
	}
	else
	{
	    dwVBIBytes *= 2;
	}
    	if( NULL != this_lcl->lpVBISurface )
    	{
	    if( SURFACE_LOST( this_lcl->lpVBISurface->lpLcl ) )
	    {
	    	DPF_ERR( "Target VBI surface is lost" );
	    	return DDERR_SURFACELOST;
	    }

	    dwSurfaceBytes = (DWORD) this_lcl->lpVBISurface->lpLcl->lpGbl->wWidth;
	    if( this_lcl->lpVBISurface->lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	    {
	    	dwSurfaceBytes *= this_lcl->lpVBISurface->lpLcl->lpGbl->ddpfSurface.dwRGBBitCount;
	    }
	    else
	    {
	    	dwSurfaceBytes *= this_lcl->lpDD->lpGbl->vmiData.ddpfDisplay.dwRGBBitCount;
	    }

	    if( dwVBIHeight > (DWORD) this_lcl->lpVBISurface->lpLcl->lpGbl->wHeight )
	    {
	    	DPF_ERR( "VBI surface is not tall enough to hold the VBI data" );
	    	return DDERR_TOOBIGHEIGHT;
	    }
	}
	else if( NULL != surf_lcl )
    	{
	    dwSurfaceBytes = (DWORD) surf_lcl->lpGbl->wWidth;
	    if( surf_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	    {
	    	dwSurfaceBytes *= surf_lcl->lpGbl->ddpfSurface.dwRGBBitCount;
	    }
	    else
	    {
	    	dwSurfaceBytes *= this_lcl->lpDD->lpGbl->vmiData.ddpfDisplay.dwRGBBitCount;
	    }
	    if( dwVBIHeight > (DWORD) this_lcl->lpSurface->lpLcl->lpGbl->wHeight )
	    {
	    	DPF_ERR( "Surface is not tall enough to hold the VBI data" );
	    	return DDERR_TOOBIGHEIGHT;
	    }
	}
	dwSurfaceBytes /= 8;

        if( dwSurfaceBytes == 0 )
	{
            DPF_ERR( "No VBI/Video surface is attached to hold VBI data" );
            return DDERR_INVALIDPARAMS;
	}

	if( dwVBIBytes > dwSurfaceBytes )
	{
	    DPF_ERR( "VBI surface is not wide enough to hold the VBI data" );
	    return DDERR_TOOBIGWIDTH;
	}
    }

    /*
     * Validate the autoflip parameters
     */
    if( dwVPFlags & DDVP_AUTOFLIP )
    {
	LPDDRAWI_DDRAWSURFACE_INT surf_first;
	LPDDRAWI_DDRAWSURFACE_INT surf_int;

	/*
	 * Count how many regular surfaces there are
	 */
    	if( ( NULL != this_lcl->lpSurface ) &&
            ( this_int->lpLcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
    	    surf_first = surf_int = this_lcl->lpSurface;
    	    do
    	    {
		(*lpNumAutoFlip)++;
		surf_int = FindAttachedFlip( surf_int );
	    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
	    if( *lpNumAutoFlip == 1 )
	    {
		*lpNumAutoFlip = 0;
	    }
	}

	/*
	 * Count how many VBI surfaces there are
	 */
    	if( ( NULL != this_lcl->lpVBISurface ) &&
            ( this_int->lpLcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
    	    surf_first = surf_int = this_lcl->lpVBISurface;
    	    do
    	    {
		(*lpNumVBIAutoFlip)++;
		surf_int = FindAttachedFlip( surf_int );
	    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
	    if( *lpNumVBIAutoFlip == 1 )
	    {
		*lpNumVBIAutoFlip = 0;
	    }
	}

	/*
	 * It's an error if neither one has sufficient surfaces to autoflip
	 */
	if( ( *lpNumAutoFlip == 0 ) && ( *lpNumVBIAutoFlip == 0 ) )
	{
	    DPF_ERR( "no autoflip surfaces are attached" );
	    return DDERR_INVALIDPARAMS;
	}
    }

    return DD_OK;
}


/*
 * FillFlipArray
 */
DWORD FillFlipArray( LPDDRAWI_DDRAWSURFACE_INT *lpArray,
	LPDDRAWI_DDRAWSURFACE_INT lpStart, LPDWORD lpdwCnt )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;

    *lpdwCnt = 0;
    surf_first = lpStart;
    do
    {
	if( SURFACE_LOST( lpStart->lpLcl ) )
	{
	    DPF_ERR( "Autoflip surface is lost" );
	    return (DWORD) DDERR_SURFACELOST;
	}
	(*lpdwCnt)++;
	*lpArray++ = lpStart;
    	lpStart = FindAttachedFlip( lpStart );
    } while( ( lpStart != NULL ) && ( lpStart->lpLcl != surf_first->lpLcl ) );

    return DD_OK;
}


/*
 * InternalStartVideo
 */
HRESULT InternalStartVideo(LPDDRAWI_DDVIDEOPORT_INT this_int,
    LPDDVIDEOPORTINFO lpInfo )
{
    LPDDHALVPORTCB_UPDATE pfn;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDHAL_UPDATEVPORTDATA UpdateData;
    DDVIDEOPORTBANDWIDTH Bandwidth;
    LPDDRAWI_DDRAWSURFACE_INT *lpTempFlipInts;
    LPDDVIDEOPORTCAPS lpAvailCaps;
    DWORD dwTempNumAutoFlip;
    DWORD dwTempNumVBIAutoFlip;
    DWORD rc;
    DWORD dwNumAutoFlip;
    DWORD dwNumVBIAutoFlip;
    DWORD dwTemp;

    /*
     * Validate the input parameters
     */
    rc = ValidateVideoInfo( this_int, lpInfo, &dwNumAutoFlip, &dwNumVBIAutoFlip );
    if( DD_OK != rc )
    {
	return rc;
    }
    this_lcl = this_int->lpLcl;
    lpAvailCaps = &(this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID]);

    /*
     * Setup the autoflip surfaces
     */
    lpTempFlipInts = NULL;
    if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
    {
	DWORD dwCnt;

	lpTempFlipInts = this_lcl->lpFlipInts;
	this_lcl->lpFlipInts = MemAlloc( sizeof( LPDDRAWI_DDRAWSURFACE_INT ) *
	    ( dwNumAutoFlip + dwNumVBIAutoFlip ) );
	if( NULL == this_lcl->lpFlipInts )
	{
	    DPF_ERR( "insufficient memory" );
	    this_lcl->lpFlipInts = lpTempFlipInts;
	    return DDERR_OUTOFMEMORY;
	}

	/*
	 * Now put the surface INTs into the array.
	 */
	if( dwNumAutoFlip )
	{
	    rc = FillFlipArray( this_lcl->lpFlipInts, this_lcl->lpSurface, &dwCnt );
	    if( rc != DD_OK )
	    {
		MemFree( this_lcl->lpFlipInts );
		this_lcl->lpFlipInts = lpTempFlipInts;
		return rc;
	    }
	    DDASSERT( dwCnt == dwNumAutoFlip );

	    if( dwNumAutoFlip > lpAvailCaps->dwNumAutoFlipSurfaces )
	    {
		DPF_ERR( "Too many autoflip surfaces" );
		MemFree( this_lcl->lpFlipInts );
		this_lcl->lpFlipInts = lpTempFlipInts;
		return DDERR_INVALIDPARAMS;
	    }
	}

	/*
	 * Now put the VBI surface INTs into the array.
	 */
	if( dwNumVBIAutoFlip )
	{
	    rc = FillFlipArray( &(this_lcl->lpFlipInts[dwNumAutoFlip]),
	    	this_lcl->lpVBISurface, &dwCnt );
	    if( rc != DD_OK )
	    {
	    	MemFree( this_lcl->lpFlipInts );
	    	this_lcl->lpFlipInts = lpTempFlipInts;
	    	return rc;
	    }
	    DDASSERT( dwCnt == dwNumVBIAutoFlip );

	    if( dwNumVBIAutoFlip > lpAvailCaps->dwNumVBIAutoFlipSurfaces )
	    {
		DPF_ERR( "Too many VBI autoflip surfaces" );
		MemFree( this_lcl->lpFlipInts );
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
    dwTempNumAutoFlip = this_lcl->dwNumAutoflip;
    dwTempNumVBIAutoFlip = this_lcl->dwNumVBIAutoflip;
    this_lcl->dwNumAutoflip = dwNumAutoFlip;
    this_lcl->dwNumVBIAutoflip = dwNumVBIAutoFlip;

    /*
     * The kernel interface may have switched from hardware autoflipping
     * to software autoflipping w/o us knowing.  We need to check for
     * this.
     */
    #ifdef WIN95
        if( ( lpInfo->dwVPFlags & DDVP_AUTOFLIP ) &&
    	    ( this_lcl->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP ) &&
    	    ( ( this_lcl->lpSurface != NULL ) || ( this_lcl->lpVBISurface != NULL ) ) )
        {
	    DWORD dwState;

	    dwState = 0;
	    if( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON )
	    {
	        GetKernelSurfaceState( this_lcl->lpSurface->lpLcl, &dwState );
	    }
	    else
	    {
	        GetKernelSurfaceState( this_lcl->lpVBISurface->lpLcl, &dwState );
	    }
	    if( dwState & DDSTATE_SOFTWARE_AUTOFLIP )
	    {
    	        this_lcl->dwFlags |= DDRAWIVPORT_SOFTWARE_AUTOFLIP;
	    }
        }
    #endif

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.UpdateVideoPort;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
	memset( &UpdateData, 0, sizeof( UpdateData ) );
    	UpdateData.lpDD = this_lcl->lpDD;
    	UpdateData.lpVideoPort = this_lcl;
    	UpdateData.lpVideoInfo = lpInfo;
    	UpdateData.dwFlags = DDRAWI_VPORTSTART;
	if( dwNumAutoFlip && ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    UpdateData.lplpDDSurface = this_lcl->lpFlipInts;
	    UpdateData.dwNumAutoflip = dwNumAutoFlip;
	}
	else if( this_lcl->lpSurface && ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    UpdateData.lplpDDSurface = &(this_lcl->lpSurface);
	}
	else
	{
	    UpdateData.lplpDDSurface = NULL;
	}
	if( dwNumVBIAutoFlip && ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    UpdateData.lplpDDVBISurface =
		&(this_lcl->lpFlipInts[this_lcl->dwNumAutoflip]);
    	    UpdateData.dwNumVBIAutoflip = dwNumVBIAutoFlip;
	}
	else if( this_lcl->lpVBISurface && ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    UpdateData.lplpDDVBISurface = &(this_lcl->lpVBISurface);
	}
	else
	{
	    UpdateData.lplpDDVBISurface = NULL;
	}
	dwTemp = lpInfo->dwVPFlags;
	if( this_lcl->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP )
	{
	    lpInfo->dwVPFlags &= ~DDVP_AUTOFLIP;
	}

	/*
	 * Before we call the HAL, create the implicit kernel surfaces if
	 * needed and update the list.  A failure here will tell us whether
	 * software autoflip, etc. is an option.
	 */
	if( ( this_lcl->lpSurface != NULL ) &&
	    ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    ReleaseVPESurfaces( this_lcl->lpSurface, FALSE );
	    PrepareVPESurfaces( this_lcl->lpSurface, this_lcl,
		dwNumAutoFlip > 0 );
	}
	if( ( this_lcl->lpVBISurface != NULL ) &&
	    ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    ReleaseVPESurfaces( this_lcl->lpVBISurface, FALSE );
	    PrepareVPESurfaces( this_lcl->lpVBISurface, this_lcl,
		dwNumVBIAutoFlip > 0 );
	}
#ifdef WIN95
        if( this_lcl->lpSurface != NULL )
        {
            OverrideVideoPort( this_lcl->lpSurface, &(lpInfo->dwVPFlags) );
        }
#endif

	DOHALCALL( UpdateVideoPort, pfn, UpdateData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    lpInfo->dwVPFlags = dwTemp;
	    if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
	    {
		MemFree( this_lcl->lpFlipInts );
	    	this_lcl->lpFlipInts = lpTempFlipInts;
                this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
                this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	    }
	    return DDERR_UNSUPPORTED;
	}
	else if( DD_OK != UpdateData.ddRVal )
	{
	    /*
	     * If we failed due to hardware autoflipping, try again w/o
	     */
	    #ifdef WIN95
	    if( ( lpInfo->dwVPFlags & DDVP_AUTOFLIP ) &&
	    	CanSoftwareAutoflip( this_lcl ) )
	    {
	    	lpInfo->dwVPFlags &= ~DDVP_AUTOFLIP;
	    	DOHALCALL( UpdateVideoPort, pfn, UpdateData, rc, 0 );
	    	if( ( DDHAL_DRIVER_HANDLED != rc ) ||
		    ( DD_OK != UpdateData.ddRVal ) )
	    	{
		    lpInfo->dwVPFlags = dwTemp;
		    MemFree( this_lcl->lpFlipInts );
	    	    this_lcl->lpFlipInts = lpTempFlipInts;
		    this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
		    this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	    	    return UpdateData.ddRVal;
	    	}
    	    	this_lcl->dwFlags |= DDRAWIVPORT_SOFTWARE_AUTOFLIP;
	    }
	    else
	    {
	    #endif
	    	lpInfo->dwVPFlags = dwTemp;
	    	if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
	    	{
		    MemFree( this_lcl->lpFlipInts );
	    	    this_lcl->lpFlipInts = lpTempFlipInts;
		    this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
		    this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	    	}
	    	return UpdateData.ddRVal;
	    #ifdef WIN95
	    }
	    #endif
	}
	MemFree( lpTempFlipInts );
	lpTempFlipInts = NULL;
	lpInfo->dwVPFlags = dwTemp;

	UpdateInterleavedFlags( this_lcl, lpInfo->dwVPFlags );
    	this_lcl->dwFlags |= DDRAWIVPORT_ON;
	memcpy( &(this_lcl->ddvpInfo), lpInfo, sizeof( DDVIDEOPORTINFO ) );
	if( NULL != lpInfo->lpddpfInputFormat )
	{
	    this_lcl->ddvpInfo.lpddpfInputFormat = (LPDDPIXELFORMAT)
    		((LPBYTE)this_lcl +
    		sizeof( DDRAWI_DDVIDEOPORT_LCL ) );
	    memcpy( this_lcl->ddvpInfo.lpddpfInputFormat,
	    lpInfo->lpddpfInputFormat, sizeof( DDPIXELFORMAT ) );
	}

	/*
	 * Determine if this can be colorkeyed and interpolated at
	 * the same time.
	 */
	if( NULL != lpInfo->lpddpfInputFormat )
	{
	    memset( &Bandwidth, 0, sizeof( Bandwidth ) );
	    Bandwidth.dwSize = sizeof( Bandwidth );
	    InternalGetBandwidth( this_lcl, lpInfo->lpddpfInputFormat,
	    	0, 0, DDVPB_TYPE, &Bandwidth );
	    if( Bandwidth.dwCaps & DDVPBCAPS_SOURCE )
	    {
	    	if( InternalGetBandwidth( this_lcl, lpInfo->lpddpfInputFormat,
	    	    this_lcl->ddvpDesc.dwFieldWidth,
	    	    this_lcl->ddvpDesc.dwFieldHeight,
		    DDVPB_OVERLAY,
		    &Bandwidth ) == DD_OK )
	    	{
		    if( Bandwidth.dwYInterpAndColorkey ==
		    	Bandwidth.dwYInterpolate )
		    {
		    	this_lcl->dwFlags |= DDRAWIVPORT_COLORKEYANDINTERP;
		    }
	    	}
	    }
	    else
	    {
	    	if( InternalGetBandwidth( this_lcl, lpInfo->lpddpfInputFormat,
	    	    this_lcl->ddvpDesc.dwFieldWidth,
	    	    this_lcl->ddvpDesc.dwFieldHeight,
		    DDVPB_VIDEOPORT,
		    &Bandwidth ) == DD_OK )
	    	{
		    if( Bandwidth.dwYInterpAndColorkey <= 2000 )
		    {
		    	this_lcl->dwFlags |= DDRAWIVPORT_COLORKEYANDINTERP;
		    }
	    	}
	    }
	}
    }
    else
    {
	this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
	this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
	{
	    MemFree( this_lcl->lpFlipInts );
	    this_lcl->lpFlipInts = lpTempFlipInts;
	}
	return DDERR_UNSUPPORTED;
    }

    /*
     * Notify  kernel mode of the change
     */
    #ifdef WIN95
        UpdateKernelVideoPort( this_lcl, DDKMVP_UPDATE );
    #endif

    return DD_OK;
}

/*
 * InternalStopVideo
 */
HRESULT InternalStopVideo( LPDDRAWI_DDVIDEOPORT_INT this_int )
{
    LPDDHALVPORTCB_UPDATE pfn;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDHAL_UPDATEVPORTDATA UpdateData;
    DWORD dwTemp2;
    DWORD dwTemp;
    DWORD rc;

    this_lcl = this_int->lpLcl;
    if( !( this_lcl->dwFlags & DDRAWIVPORT_ON ) )
    {
	// VPORT is not on
	return DD_OK;
    }

    /*
     * Notify  kernel mode of the change
     */
    dwTemp2 = this_lcl->dwFlags;
    this_lcl->dwFlags &= ~DDRAWIVPORT_ON;
    dwTemp = this_lcl->ddvpInfo.dwVPFlags;
    this_lcl->ddvpInfo.dwVPFlags &= ~DDVP_AUTOFLIP;
    this_lcl->dwNumAutoflip = 0;
    this_lcl->dwNumVBIAutoflip = 0;
    #ifdef WIN95
        UpdateKernelVideoPort( this_lcl, DDKMVP_UPDATE );
    #endif
    this_lcl->ddvpInfo.dwVPFlags = dwTemp;
    this_lcl->dwFlags = dwTemp2;

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.UpdateVideoPort;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
	memset( &UpdateData, 0, sizeof( UpdateData ) );
    	UpdateData.lpDD = this_lcl->lpDD;
    	UpdateData.lpVideoPort = this_lcl;
    	UpdateData.lpVideoInfo = &(this_lcl->ddvpInfo);
    	UpdateData.dwFlags = DDRAWI_VPORTSTOP;
    	UpdateData.dwNumAutoflip = 0;
    	UpdateData.dwNumVBIAutoflip = 0;
    	UpdateData.lplpDDSurface = NULL;
	dwTemp = this_lcl->ddvpInfo.dwVPFlags;
	this_lcl->ddvpInfo.dwVPFlags &= ~DDVP_AUTOFLIP;

	DOHALCALL( UpdateVideoPort, pfn, UpdateData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    this_lcl->ddvpInfo.dwVPFlags = dwTemp;
	    return DDERR_UNSUPPORTED;
	}
	else if( DD_OK != UpdateData.ddRVal )
	{
	    this_lcl->ddvpInfo.dwVPFlags = dwTemp;
	    return UpdateData.ddRVal;
	}
    	this_lcl->dwFlags &= ~DDRAWIVPORT_ON;
	this_lcl->ddvpInfo.dwVPFlags = dwTemp;
    }
    else
    {
	return DDERR_UNSUPPORTED;
    }

    /*
     * Update the surfaces and release implicit kernel handles.
     */
    if( this_lcl->lpSurface != NULL )
    {
        ReleaseVPESurfaces( this_lcl->lpSurface, TRUE );
    }
    if( this_lcl->lpVBISurface != NULL )
    {
	ReleaseVPESurfaces( this_lcl->lpVBISurface, TRUE );
    }

    return DD_OK;
}

/*
 * InternalUpdateVideo
 */
HRESULT InternalUpdateVideo(LPDDRAWI_DDVIDEOPORT_INT this_int,
    LPDDVIDEOPORTINFO lpInfo )
{
    LPDDHALVPORTCB_UPDATE pfn;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDHAL_UPDATEVPORTDATA UpdateData;
    LPDDRAWI_DDRAWSURFACE_INT *lpTempFlipInts;
    LPDDVIDEOPORTCAPS lpAvailCaps;
    DWORD dwTempNumAutoFlip;
    DWORD dwTempNumVBIAutoFlip;
    DWORD rc;
    DWORD dwNumAutoFlip;
    DWORD dwNumVBIAutoFlip;
    DWORD dwTemp;

    /*
     * Validate the input parameters
     */
    rc = ValidateVideoInfo( this_int, lpInfo, &dwNumAutoFlip, &dwNumVBIAutoFlip );
    if( DD_OK != rc )
    {
	return rc;
    }
    this_lcl = this_int->lpLcl;
    lpAvailCaps = &(this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID]);

    if( !( this_lcl->dwFlags & DDRAWIVPORT_ON ) )
    {
	// VPORT is not on - nothing to update
	return DD_OK;
    }

    /*
     * Setup the autoflip surfaces
     */
    lpTempFlipInts = NULL;
    if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
    {
	DWORD dwCnt;

	lpTempFlipInts = this_lcl->lpFlipInts;
	this_lcl->lpFlipInts = MemAlloc( sizeof( LPDDRAWI_DDRAWSURFACE_INT ) *
	    ( dwNumAutoFlip + dwNumVBIAutoFlip ) );
	if( NULL == this_lcl->lpFlipInts )
	{
	    DPF_ERR( "insufficient memory" );
	    this_lcl->lpFlipInts = lpTempFlipInts;
	    return DDERR_OUTOFMEMORY;
	}

	/*
	 * Now put the surface INTs into the array.
	 */
	if( dwNumAutoFlip )
	{
	    rc = FillFlipArray( this_lcl->lpFlipInts, this_lcl->lpSurface, &dwCnt );
	    if( rc != DD_OK )
	    {
		MemFree( this_lcl->lpFlipInts );
		this_lcl->lpFlipInts = lpTempFlipInts;
		return rc;
	    }
	    DDASSERT( dwCnt == dwNumAutoFlip );

	    if( dwNumAutoFlip > lpAvailCaps->dwNumAutoFlipSurfaces )
	    {
		DPF_ERR( "Too many autoflip surfaces" );
		MemFree( this_lcl->lpFlipInts );
		this_lcl->lpFlipInts = lpTempFlipInts;
		return DDERR_INVALIDPARAMS;
	    }
	}

	/*
	 * Now put the VBI surface INTs into the array.
	 */
	if( dwNumVBIAutoFlip )
	{
	    rc = FillFlipArray( &(this_lcl->lpFlipInts[dwNumAutoFlip]),
	    	this_lcl->lpVBISurface, &dwCnt );
	    if( rc != DD_OK )
	    {
	    	MemFree( this_lcl->lpFlipInts );
	    	this_lcl->lpFlipInts = lpTempFlipInts;
	    	return rc;
	    }
	    DDASSERT( dwCnt == dwNumVBIAutoFlip );

	    if( dwNumVBIAutoFlip > lpAvailCaps->dwNumVBIAutoFlipSurfaces )
	    {
		DPF_ERR( "Too many VBI autoflip surfaces" );
		MemFree( this_lcl->lpFlipInts );
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
    dwTempNumAutoFlip = this_lcl->dwNumAutoflip;
    dwTempNumVBIAutoFlip = this_lcl->dwNumVBIAutoflip;
    this_lcl->dwNumAutoflip = dwNumAutoFlip;
    this_lcl->dwNumVBIAutoflip = dwNumVBIAutoFlip;

    /*
     * The kernel interface may have switched from hardware autoflipping
     * to software autoflipping w/o us knowing.  We need to check for
     * this.
     */
    #ifdef WIN95
        if( ( lpInfo->dwVPFlags & DDVP_AUTOFLIP ) &&
    	    ( this_lcl->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP ) &&
    	    ( ( this_lcl->lpSurface != NULL ) || ( this_lcl->lpVBISurface != NULL ) ) )
        {
	    DWORD dwState;

	    dwState = 0;
	    if( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON )
	    {
	        GetKernelSurfaceState( this_lcl->lpSurface->lpLcl, &dwState );
	    }
	    else
	    {
	        GetKernelSurfaceState( this_lcl->lpVBISurface->lpLcl, &dwState );
	    }
	    if( dwState & DDSTATE_SOFTWARE_AUTOFLIP )
	    {
    	        this_lcl->dwFlags |= DDRAWIVPORT_SOFTWARE_AUTOFLIP;
	    }
        }
    #endif

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.UpdateVideoPort;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
	memset( &UpdateData, 0, sizeof( UpdateData ) );
    	UpdateData.lpDD = this_lcl->lpDD;
    	UpdateData.lpVideoPort = this_lcl;
    	UpdateData.lpVideoInfo = lpInfo;
    	UpdateData.dwFlags = DDRAWI_VPORTSTART;
	if( dwNumAutoFlip && ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    UpdateData.lplpDDSurface = this_lcl->lpFlipInts;
	    UpdateData.dwNumAutoflip = dwNumAutoFlip;
	}
	else if( this_lcl->lpSurface && ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    UpdateData.lplpDDSurface = &(this_lcl->lpSurface);
	}
	else
	{
	    UpdateData.lplpDDSurface = NULL;
	}
	if( dwNumVBIAutoFlip && ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    UpdateData.lplpDDVBISurface =
		&(this_lcl->lpFlipInts[this_lcl->dwNumAutoflip]);
    	    UpdateData.dwNumVBIAutoflip = dwNumVBIAutoFlip;
	}
	else if( this_lcl->lpVBISurface && ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    UpdateData.lplpDDVBISurface = &(this_lcl->lpVBISurface);
	}
	else
	{
	    UpdateData.lplpDDVBISurface = NULL;
	}
	dwTemp = lpInfo->dwVPFlags;
    	if( this_lcl->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP )
	{
	    lpInfo->dwVPFlags &= ~DDVP_AUTOFLIP;
	}
#ifdef WIN95
        if( this_lcl->lpSurface != NULL )
        {
            OverrideVideoPort( this_lcl->lpSurface, &(lpInfo->dwVPFlags) );
        }
#endif

	DOHALCALL( UpdateVideoPort, pfn, UpdateData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    lpInfo->dwVPFlags = dwTemp;
	    if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
	    {
		MemFree( this_lcl->lpFlipInts );
	    	this_lcl->lpFlipInts = lpTempFlipInts;
                this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
                this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	    }
	    return DDERR_UNSUPPORTED;
	}
	else if( DD_OK != UpdateData.ddRVal )
	{
	    /*
	     * If we failed due to hardware autoflipping, try again w/o
	     */
	    if( ( lpInfo->dwVPFlags & DDVP_AUTOFLIP ) ||
	    	CanSoftwareAutoflip( this_lcl ) )
	    {
	    	lpInfo->dwVPFlags &= ~DDVP_AUTOFLIP;
	    	DOHALCALL( UpdateVideoPort, pfn, UpdateData, rc, 0 );
	    	if( ( DDHAL_DRIVER_HANDLED != rc ) &&
		    ( DD_OK != UpdateData.ddRVal ) )
	    	{
		    lpInfo->dwVPFlags = dwTemp;
		    MemFree( this_lcl->lpFlipInts );
	    	    this_lcl->lpFlipInts = lpTempFlipInts;
		    this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
		    this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	    	    return UpdateData.ddRVal;
	    	}
    	    	this_lcl->dwFlags |= DDRAWIVPORT_SOFTWARE_AUTOFLIP;
	    }
	    else
	    {
	    	lpInfo->dwVPFlags = dwTemp;
	    	if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
	    	{
		    MemFree( this_lcl->lpFlipInts );
	    	    this_lcl->lpFlipInts = lpTempFlipInts;
		    this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
		    this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	    	}
	    	return UpdateData.ddRVal;
	    }
	}
	MemFree( lpTempFlipInts );
	lpTempFlipInts = NULL;
	lpInfo->dwVPFlags = dwTemp;

	/*
	 * If they are changing to or from autoflipping, we need to update
	 * the surfaces.
	 */
	if( ( dwNumAutoFlip > dwTempNumAutoFlip ) &&
	    ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    DDASSERT( this_lcl->lpSurface != NULL );
	    PrepareVPESurfaces( this_lcl->lpSurface, this_lcl, TRUE );
	}
	if( ( dwNumVBIAutoFlip > dwTempNumVBIAutoFlip ) &&
	    ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    DDASSERT( this_lcl->lpVBISurface != NULL );
	    PrepareVPESurfaces( this_lcl->lpVBISurface, this_lcl, TRUE );
	}
	if( ( dwNumAutoFlip < dwTempNumAutoFlip ) &&
	    ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    DDASSERT( this_lcl->lpSurface != NULL );
	    ReleaseVPESurfaces( this_lcl->lpSurface, FALSE );
	    PrepareVPESurfaces( this_lcl->lpSurface, this_lcl, FALSE );
	}
	if( ( dwNumVBIAutoFlip < dwTempNumVBIAutoFlip ) &&
	    ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    DDASSERT( this_lcl->lpVBISurface != NULL );
	    ReleaseVPESurfaces( this_lcl->lpVBISurface, FALSE );
	    PrepareVPESurfaces( this_lcl->lpVBISurface, this_lcl, FALSE );
	}

	UpdateInterleavedFlags( this_lcl, lpInfo->dwVPFlags );
	memcpy( &(this_lcl->ddvpInfo), lpInfo, sizeof( DDVIDEOPORTINFO ) );
	if( NULL != lpInfo->lpddpfInputFormat )
	{
	    this_lcl->ddvpInfo.lpddpfInputFormat = (LPDDPIXELFORMAT)
    		((LPBYTE)this_lcl +
    		sizeof( DDRAWI_DDVIDEOPORT_LCL ) );
	    memcpy( this_lcl->ddvpInfo.lpddpfInputFormat,
	    lpInfo->lpddpfInputFormat, sizeof( DDPIXELFORMAT ) );
	}
    }
    else
    {
	this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
	this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
	{
	    MemFree( this_lcl->lpFlipInts );
	    this_lcl->lpFlipInts = lpTempFlipInts;
	}
	return DDERR_UNSUPPORTED;
    }

    /*
     * Notify  kernel mode of the change
     */
    #ifdef WIN95
        UpdateKernelVideoPort( this_lcl, DDKMVP_UPDATE );
    #endif

    return DD_OK;
}


/*
 * DD_VP_StartVideo
 */
HRESULT DDAPI DD_VP_StartVideo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDVIDEOPORTINFO lpInfo )
{
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    DDVIDEOPORTINFO TempInfo;
    DWORD dwTempFlags;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_StartVideo");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	if( (NULL == lpInfo) || !VALID_DDVIDEOPORTINFO_PTR( lpInfo ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( lpInfo->dwReserved1 != 0 ) ||
	    ( lpInfo->dwReserved2 != 0 ) )
	{
	    DPF_ERR( "Reserved field not set to zero" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    if( (NULL == lpInfo->lpddpfVBIInputFormat) ||
		!VALID_DDPIXELFORMAT_PTR( lpInfo->lpddpfVBIInputFormat ) )
	    {
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else if( (NULL == lpInfo->lpddpfInputFormat) ||
	    !VALID_DDPIXELFORMAT_PTR( lpInfo->lpddpfInputFormat ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    dwTempFlags = this_int->lpLcl->dwFlags;
    if( this_int->dwFlags )
    {
	rc = MergeVPInfo( this_int->lpLcl,
	    this_int->dwFlags & DDVPCREATE_VBIONLY ? lpInfo : this_int->lpLcl->lpVBIInfo,
	    this_int->dwFlags & DDVPCREATE_VIDEOONLY ? lpInfo : this_int->lpLcl->lpVideoInfo,
	    &TempInfo );
	if( rc == DD_OK )
	{
	    if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	    {
		this_int->lpLcl->dwFlags |= DDRAWIVPORT_VBION;
	    }
	    else
	    {
		this_int->lpLcl->dwFlags |= DDRAWIVPORT_VIDEOON;
	    }
	    rc = InternalStartVideo( this_int, &TempInfo );
	}
    }
    else
    {
	this_int->lpLcl->dwFlags |= DDRAWIVPORT_VIDEOON | DDRAWIVPORT_VBION;
	rc = InternalStartVideo( this_int, lpInfo );
    }

    if( ( rc == DD_OK ) && this_int->dwFlags )
    {
	/*
	 * Save the original info
	 */
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    if( this_int->lpLcl->lpVBIInfo == NULL )
	    {
	    	this_int->lpLcl->lpVBIInfo = MemAlloc( sizeof( TempInfo ) +
		    ( 2 * sizeof( DDPIXELFORMAT)) );
	    }
	    if( this_int->lpLcl->lpVBIInfo != NULL )
	    {
		memcpy( this_int->lpLcl->lpVBIInfo, lpInfo, sizeof( TempInfo ) );
		this_int->lpLcl->lpVBIInfo->lpddpfVBIInputFormat = (LPDDPIXELFORMAT)
		    ((LPBYTE)this_int->lpLcl->lpVBIInfo + sizeof( DDVIDEOPORTINFO ));
		this_int->lpLcl->lpVBIInfo->lpddpfVBIOutputFormat = (LPDDPIXELFORMAT)
		    ((LPBYTE)this_int->lpLcl->lpVBIInfo + sizeof( DDVIDEOPORTINFO ) +
		    sizeof( DDPIXELFORMAT ) );
		memcpy( this_int->lpLcl->lpVBIInfo->lpddpfVBIInputFormat,
		    lpInfo->lpddpfVBIInputFormat, sizeof( DDPIXELFORMAT ) );
		if( lpInfo->lpddpfVBIOutputFormat != NULL )
		{
		    memcpy( this_int->lpLcl->lpVBIInfo->lpddpfVBIOutputFormat,
			lpInfo->lpddpfVBIOutputFormat, sizeof( DDPIXELFORMAT ) );
		}
	    }
	}
	else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
	{
	    if( this_int->lpLcl->lpVideoInfo == NULL )
	    {
	    	this_int->lpLcl->lpVideoInfo = MemAlloc( sizeof( TempInfo ) );
	    }
	    if( this_int->lpLcl->lpVideoInfo != NULL )
	    {
		memcpy( this_int->lpLcl->lpVideoInfo, lpInfo, sizeof( TempInfo ) );
		this_int->lpLcl->lpVideoInfo->lpddpfInputFormat =
		    this_int->lpLcl->ddvpInfo.lpddpfInputFormat;
	    }
	}
    }
    else if( rc != DD_OK )
    {
	this_int->lpLcl->dwFlags = dwTempFlags;
    }

    LEAVE_DDRAW();

    return rc;
}


/*
 * DD_VP_StopVideo
 */
HRESULT DDAPI DD_VP_StopVideo(LPDIRECTDRAWVIDEOPORT lpDVP )
{
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDVIDEOPORTINFO TempInfo;
    BOOL bChanged;
    DWORD rc = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_StopVideo");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
	this_lcl = this_int->lpLcl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Three special things are done for VBI/Video-only video ports:
     * 1. Remove the lpVBI/VideoInfo reference so we know we are no
     *    longer on.
     * 2. If the other interface is running, instead of stoping the
     *    video stream, we simply crop it out so the other stream can
     *    continue un-interrupted.
     * 3. Release the kernel handles.
     */
    if( this_int->dwFlags )
    {
	bChanged = FALSE;
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    if( this_lcl->lpVBIInfo != NULL )
	    {
	        MemFree( this_lcl->lpVBIInfo );
	        this_lcl->lpVBIInfo = NULL;
	        bChanged = TRUE;
	    }
	    if( this_lcl->lpVBISurface != NULL )
	    {
		ReleaseVPESurfaces( this_lcl->lpVBISurface, TRUE );
    	    }
	    this_lcl->dwFlags &= ~DDRAWIVPORT_VBION;
	}
	else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
	{
	    if( this_lcl->lpVideoInfo != NULL )
	    {
	        MemFree( this_lcl->lpVideoInfo );
	        this_lcl->lpVideoInfo = NULL;
	        bChanged = TRUE;
	    }
	    if( this_lcl->lpSurface != NULL )
	    {
		ReleaseVPESurfaces( this_lcl->lpSurface, TRUE );
    	    }
	    this_lcl->dwFlags &= ~DDRAWIVPORT_VIDEOON;
	}
	if( bChanged && ( ( this_lcl->lpVideoInfo != NULL ) ||
	    ( this_lcl->lpVBIInfo != NULL ) ) )
	{
	    rc = MergeVPInfo( this_lcl,
		this_lcl->lpVBIInfo,
		this_lcl->lpVideoInfo,
		&TempInfo );
	    if( rc == DD_OK )
	    {
		rc = InternalUpdateVideo( this_int, &TempInfo );
	    }
	}
	else if( bChanged )
	{
	    rc = InternalStopVideo( this_int );
	}
    }
    else
    {
	this_lcl->dwFlags &= ~( DDRAWIVPORT_VIDEOON | DDRAWIVPORT_VBION );
	rc = InternalStopVideo( this_int );
    }

    LEAVE_DDRAW();

    return rc;
}

/*
 * DD_VP_UpdateVideo
 */
HRESULT DDAPI DD_VP_UpdateVideo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDVIDEOPORTINFO lpInfo )
{
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    DDVIDEOPORTINFO TempInfo;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_UpdateVideo");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	if( (NULL == lpInfo) || !VALID_DDVIDEOPORTINFO_PTR( lpInfo ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( lpInfo->dwReserved1 != 0 ) ||
	    ( lpInfo->dwReserved2 != 0 ) )
	{
	    DPF_ERR( "Reserved field not set to zero" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    if( (NULL == lpInfo->lpddpfVBIInputFormat) ||
		!VALID_DDPIXELFORMAT_PTR( lpInfo->lpddpfVBIInputFormat ) )
	    {
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else if( (NULL == lpInfo->lpddpfInputFormat) ||
	    !VALID_DDPIXELFORMAT_PTR( lpInfo->lpddpfInputFormat ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    if( this_int->dwFlags )
    {
	rc = MergeVPInfo( this_int->lpLcl,
	    this_int->dwFlags & DDVPCREATE_VBIONLY ? lpInfo : this_int->lpLcl->lpVBIInfo,
	    this_int->dwFlags & DDVPCREATE_VIDEOONLY ? lpInfo : this_int->lpLcl->lpVideoInfo,
	    &TempInfo );
	if( rc == DD_OK )
	{
	    rc = InternalUpdateVideo( this_int, &TempInfo );
	}
    }
    else
    {
	rc = InternalUpdateVideo( this_int, lpInfo );
    }

    if( ( rc == DD_OK ) && this_int->dwFlags )
    {
	/*
	 * Save the original info
	 */
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    if( this_int->lpLcl->lpVBIInfo != NULL )
	    {
		memcpy( this_int->lpLcl->lpVBIInfo, lpInfo, sizeof( TempInfo ) );
		this_int->lpLcl->lpVBIInfo->lpddpfVBIInputFormat = (LPDDPIXELFORMAT)
		    ((LPBYTE)this_int->lpLcl->lpVBIInfo + sizeof( DDVIDEOPORTINFO ));
		this_int->lpLcl->lpVBIInfo->lpddpfVBIOutputFormat = (LPDDPIXELFORMAT)
		    ((LPBYTE)this_int->lpLcl->lpVBIInfo + sizeof( DDVIDEOPORTINFO ) +
		    sizeof( DDPIXELFORMAT ) );
		memcpy( this_int->lpLcl->lpVBIInfo->lpddpfVBIInputFormat,
		    lpInfo->lpddpfVBIInputFormat, sizeof( DDPIXELFORMAT ) );
		if( lpInfo->lpddpfVBIOutputFormat != NULL )
		{
		    memcpy( this_int->lpLcl->lpVBIInfo->lpddpfVBIOutputFormat,
			lpInfo->lpddpfVBIOutputFormat, sizeof( DDPIXELFORMAT ) );
		}
	    }
	}
	else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
	{
	    if( this_int->lpLcl->lpVideoInfo != NULL )
	    {
		memcpy( this_int->lpLcl->lpVideoInfo, lpInfo, sizeof( TempInfo ) );
		this_int->lpLcl->lpVideoInfo->lpddpfInputFormat =
		    this_int->lpLcl->ddvpInfo.lpddpfInputFormat;
	    }
	}
    }

    LEAVE_DDRAW();

    return rc;
}

/*
 * DD_VP_WaitForSync
 */
HRESULT DDAPI DD_VP_WaitForSync(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwFlags, DWORD dwLine, DWORD dwTimeOut )
{
    LPDDHALVPORTCB_WAITFORSYNC pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DWORD rc;
    DDHAL_WAITFORVPORTSYNCDATA WaitSyncData;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_WaitForSync");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    if( !dwFlags || ( dwFlags > 3 ) )
    {
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.WaitForVideoPortSync;
    if( pfn != NULL )
    {
    	WaitSyncData.lpDD = this_lcl->lpDD;
    	WaitSyncData.lpVideoPort = this_lcl;
    	WaitSyncData.dwFlags = dwFlags;
    	WaitSyncData.dwLine = dwLine;
	if( dwTimeOut != 0 )
	{
    	    WaitSyncData.dwTimeOut = dwTimeOut;
	}
	else
	{
    	    WaitSyncData.dwTimeOut = this_lcl->ddvpDesc.dwMicrosecondsPerField * 3;
	}

	DOHALCALL( WaitForVideoPortSync, pfn, WaitSyncData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return WaitSyncData.ddRVal;
}


/*
 * DD_VP_GetSignalStatus
 */
HRESULT DDAPI DD_VP_GetSignalStatus(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwStatus )
{
    LPDDHALVPORTCB_GETSIGNALSTATUS pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDHAL_GETVPORTSIGNALDATA GetSignalData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_GetSignalStatus");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (NULL == lpdwStatus ) || !VALID_DWORD_PTR( lpdwStatus ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.GetVideoSignalStatus;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
    	GetSignalData.lpDD = this_lcl->lpDD;
    	GetSignalData.lpVideoPort = this_lcl;
    	GetSignalData.dwStatus = DDVPSQ_NOSIGNAL;	// Let the HAL tell us otherwise

	DOHALCALL( GetVideoSignalStatus, pfn, GetSignalData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != GetSignalData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetSignalData.ddRVal;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }
    *lpdwStatus = GetSignalData.dwStatus;

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * DD_VP_GetColorControls
 */
HRESULT DDAPI DD_VP_GetColorControls(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDCOLORCONTROL lpColor )
{
    LPDDHALVPORTCB_COLORCONTROL pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDHAL_VPORTCOLORDATA ColorData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_GetColorControls");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (NULL == lpColor ) || !VALID_DDCOLORCONTROL_PTR( lpColor ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    DPF_ERR( "Unable to set color controls on a VBI-only video port" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.ColorControl;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
    	ColorData.lpDD = this_lcl->lpDD;
    	ColorData.lpVideoPort = this_lcl;
	ColorData.dwFlags = DDRAWI_VPORTGETCOLOR;
	ColorData.lpColorData = lpColor;

	DOHALCALL( VideoColorControl, pfn, ColorData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != ColorData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return ColorData.ddRVal;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * DD_VP_SetColorControls
 */
HRESULT DDAPI DD_VP_SetColorControls(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDCOLORCONTROL lpColor )
{
    LPDDHALVPORTCB_COLORCONTROL pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDHAL_VPORTCOLORDATA ColorData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_SetColorControls");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (NULL == lpColor ) || !VALID_DDCOLORCONTROL_PTR( lpColor ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    DPF_ERR( "Unable to set color controls on a VBI-only video port" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.ColorControl;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
    	ColorData.lpDD = this_lcl->lpDD;
    	ColorData.lpVideoPort = this_lcl;
	ColorData.dwFlags = DDRAWI_VPORTSETCOLOR;
	ColorData.lpColorData = lpColor;

	DOHALCALL( VideoColorControl, pfn, ColorData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != ColorData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return ColorData.ddRVal;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * GetSurfaceFormat
 *
 * Fills in the DDPIXELFORMAT structure with the surface's format
 */
LPDDPIXELFORMAT GetSurfaceFormat( LPDDRAWI_DDRAWSURFACE_LCL surf_lcl )
{
    if( surf_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
    {
	return &(surf_lcl->lpGbl->ddpfSurface);
    }
    else
    {
	return &(surf_lcl->lpSurfMore->lpDD_lcl->lpGbl->vmiData.ddpfDisplay);
    }
    return NULL;
}


/*
 * CreateVideoPortNotify
 */
HRESULT CreateVideoPortNotify( LPDDRAWI_DDVIDEOPORT_INT lpDDVPInt, LPDIRECTDRAWVIDEOPORTNOTIFY *lplpVPNotify )
{
#ifdef WINNT
    OSVERSIONINFOEX             osvi;
    DWORDLONG                   dwlConditionMask = 0;
    LPDDRAWI_DDVIDEOPORT_INT    lpInt;
#endif

    *lplpVPNotify = NULL;

#ifdef WIN95
    // This is available on Win9X
    return DDERR_UNSUPPORTED;
#else
    // This is only available on whistler

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osvi.dwMajorVersion = 5;
    osvi.dwMinorVersion = 1;

    VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, 
        VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, 
        VER_GREATER_EQUAL );

    if (!VerifyVersionInfo(&osvi, VER_MAJORVERSION|VER_MINORVERSION, dwlConditionMask))
    {
        return DDERR_UNSUPPORTED;
    }

    // Only one notification interface can be active at any time for a single
    // video port

    if (lpDDVPInt->lpLcl->lpVPNotify != NULL)
    {
        DPF_ERR("A IDirectDrawVideoPortNotify interface already exists for this video port");
        return DDERR_CURRENTLYNOTAVAIL;
    }

    lpInt = MemAlloc(sizeof(DDRAWI_DDVIDEOPORT_INT));
    if (lpInt == NULL)
    {
        return DDERR_OUTOFMEMORY;
    }
    lpInt->lpVtbl = (LPVOID)&ddVideoPortNotifyCallbacks;
    lpInt->lpLcl = lpDDVPInt->lpLcl;
    lpInt->dwFlags = DDVPCREATE_NOTIFY | lpDDVPInt->dwFlags;

    DD_VP_AddRef( (LPDIRECTDRAWVIDEOPORT )lpInt );
    *lplpVPNotify = (LPDIRECTDRAWVIDEOPORTNOTIFY) lpInt;

    lpInt->lpLink = lpDDVPInt->lpLcl->lpDD->lpGbl->dvpList;
    lpDDVPInt->lpLcl->lpDD->lpGbl->dvpList = lpInt;
#endif
    return DD_OK;
}


/*
 * DDAPI DD_VP_Notify_AcquireNotification
 */
HRESULT DDAPI DD_VP_Notify_AcquireNotification( LPDIRECTDRAWVIDEOPORTNOTIFY lpNotify, HANDLE* pEvent, LPDDVIDEOPORTNOTIFY pBuffer )
{
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    HRESULT                  rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_Notify_AcquireNotification");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpNotify;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (pBuffer == NULL) || !VALID_DDVIDEOPORTNOTIFY_PTR( pBuffer ) )
    	{
	    DPF_ERR( "Invalid LPDDVIDEOPORTNOTIFY specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( (pEvent == NULL) || !VALID_HANDLE_PTR( pEvent ) )
    	{
	    DPF_ERR( "Invalid event handle ptr specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    *pEvent = NULL;
    rc = DDERR_UNSUPPORTED;

#ifdef WINNT
    this_lcl->lpDD->lpGbl->lpDDCBtmp->HALDDVPE2.AcquireNotification(this_lcl, pEvent, pBuffer);
    if (*pEvent != NULL)
    {
        rc = DD_OK;
    }
#endif

    LEAVE_DDRAW();

    return rc;
}


/*
 * DDAPI DD_VP_Notify_AcquireNotification
 */
HRESULT DDAPI DD_VP_Notify_ReleaseNotification( LPDIRECTDRAWVIDEOPORTNOTIFY lpNotify, HANDLE pEvent )
{
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_Notify_ReleaseNotification");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpNotify;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

#ifdef WINNT
    this_lcl->lpDD->lpGbl->lpDDCBtmp->HALDDVPE2.ReleaseNotification(this_lcl, pEvent);
#endif

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * ProcessVideoPortCleanup
 *
 * A process is done, clean up any videoports that it may have locked.
 *
 * NOTE: we enter with a lock taken on the DIRECTDRAW object.
 */
void ProcessVideoPortCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDVIDEOPORT_INT	pvport_int;
    LPDDRAWI_DDVIDEOPORT_LCL	pvport_lcl;
    LPDDRAWI_DDVIDEOPORT_INT	pvpnext_int;
    DWORD			rcnt;
    ULONG			rc;
    DWORD			vp_id;

    /*
     * run through all videoports owned by the driver object, and find ones
     * that have been accessed by this process.  If the pdrv_lcl parameter
     * is non-null, only delete videoports created by that local driver object.
     */
    pvport_int = pdrv->dvpList;
    DPF( 4, "ProcessVideoPortCleanup" );
    while( pvport_int != NULL )
    {
	pvport_lcl = pvport_int->lpLcl;
	pvpnext_int = pvport_int->lpLink;
	rc = 1;
	if( pvport_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    vp_id = pvport_lcl->dwVBIProcessID;
	}
	else
	{
	    vp_id = pvport_lcl->dwProcessID;
	}
	if( ( vp_id == pid ) &&
	    ( (NULL == pdrv_lcl) || (pvport_lcl->lpDD == pdrv_lcl) ) )
	{
	    /*
	     * release the references by this process
	     */
	    rcnt = pvport_int->dwIntRefCnt;
	    DPF( 5, "Process %08lx had %ld accesses to videoport %08lx", pid, rcnt, pvport_int );
	    while( rcnt >  0 )
	    {
		DD_VP_Release( (LPDIRECTDRAWVIDEOPORT) pvport_int );
		pvpnext_int = pdrv->dvpList;
		if( rc == 0 )
		{
		    break;
		}
		rcnt--;
	    }
	}
	else
	{
	    DPF( 5, "Process %08lx had no accesses to videoport %08lx", pid, pvport_int );
	}
	pvport_int = pvpnext_int;
    }
    DPF( 4, "Leaving ProcessVideoPortCleanup");

} /* ProcessVideoPortCleanup */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\edid.h ===
//
// This include file contains the format of the VESA EDID data structure as
// described in the VESA Display Data Channel (DDC) Specification.  It should
// be included in any assembly language program that requires knowledge of the
// EDID data structure.
//
typedef struct VESA_EDID {
        BYTE    veHeader[8];        // 0,FFH,FFH,FFH,FFH,FFH,FFH,0
        BYTE    veManufactID[2];    // in compressed format - see spec
        BYTE    veProductCode[2];   // vendor assigned code
        DWORD   veSerialNbr;        // 32 bit serial nbr (LSB first)
        BYTE    veWeekMade;         // week of manufacture (0-53)
        BYTE    veYearMade;         // year of manufacture - 1990
        BYTE    veEDIDVersion;      // version number of EDID
        BYTE    veEDIDRevision;     // revision number of EDID
        BYTE    veVidInputDef;      // video input definition
        BYTE    veMaxHorizSize;     // horizontal image size in cm
        BYTE    veMaxVertSize;      // vertical image size in cm
        BYTE    veGammaXFER;        // (gamma * 100) - 100 (1.00-3.55)
        BYTE    veDPMSFeatures;     // DPMS feature support
        BYTE    veRedGreenLow;      // Rx1Rx0Ry1Ry0Gx1Gx0Gy1Gy0
        BYTE    veBlueWhiteLow;     // Bx1Bx0By1By0Wx1Wx0Wy1Wy0
        BYTE    veRedx;             // red X bit 9 - 2
        BYTE    veRedy;             // red Y bit 9 - 2
        BYTE    veGreenx;           // green X bit 9 - 2
        BYTE    veGreeny;           // green Y bit 9 - 2
        BYTE    veBluex;            // blue X bit 9 - 2
        BYTE    veBluey;            // blue Y bit 9 - 2
        BYTE    veWhitex;           // white X bit 9 - 2
        BYTE    veWhitey;           // white Y bit 9 - 2
        BYTE    veEstTime1;         // established timings I
        BYTE    veEstTime2;         // established timings II
        BYTE    veEstTime3;         // established timings II
        WORD    veStdTimeID1;       //
        WORD    veStdTimeID2;       //
        WORD    veStdTimeID3;       //
        WORD    veStdTimeID4;       //
        WORD    veStdTimeID5;       //
        WORD    veStdTimeID6;       //
        WORD    veStdTimeID7;       //
        WORD    veStdTimeID8;       //
        BYTE    veDetailTime1[18];  //
        BYTE    veDetailTime2[18];  //
        BYTE    veDetailTime3[18];  //
        BYTE    veDetailTime4[18];  //
        BYTE    veExtensionFlag;    // nbr of 128 EDID extensions
        BYTE    veChecksum;         // sum of all bytes == 0
}       VESA_EDID;

/*ASM
.errnz  size VESA_EDID - 128                    ;must be 128 bytes long!
*/

//
// bit definitions for the veEstTime1 field
//
#define veEstTime1_720x400x70Hz     0x80   // 720x400x70Hz  VGA,IBM
#define veEstTime1_720x400x88Hz     0x40   // 720x400x88Hz  XGA2,IBM
#define veEstTime1_640x480x60Hz     0x20   // 640x480x60Hz  VGA,IBM
#define veEstTime1_640x480x67Hz     0x10   // 640x480x67Hz  MacII,Apple
#define veEstTime1_640x480x72Hz     0x08   // 640x480x72Hz  VESA
#define veEstTime1_640x480x75Hz     0x04   // 640x480x75Hz  VESA
#define veEstTime1_800x600x56Hz     0x02   // 800x600x56Hz  VESA
#define veEstTime1_800x600x60Hz     0x01   // 800x600x60Hz  VESA

//
// bit definitions for the veEstTime2 field
//
#define veEstTime2_800x600x72Hz     0x80   // 800x600x72Hz   VESA
#define veEstTime2_800x600x75Hz     0x40   // 800x600x75Hz   VESA
#define veEstTime2_832x624x75Hz     0x20   // 832x624x75Hz   MacII,Apple
#define veEstTime2_1024x768x87Hz    0x10   // 1024x768x87Hz  IBM
#define veEstTime2_1024x768x60Hz    0x08   // 1024x768x60Hz  VESA
#define veEstTime2_1024x768x70Hz    0x04   // 1024x768x70Hz  VESA
#define veEstTime2_1024x768x75Hz    0x02   // 1024x768x75Hz  VESA
#define veEstTime2_1280x1024x75Hz   0x01   // 1280x1024x75Hz VESA

//
// bit definitions for the veEstTime3 field (was veManTimes in DDC 1)
//
#define veEstTime3_1152x870x75Hz    0x80   // 800x600x72Hz   MacII,Apple
#define veEstTime3_640x480x85Hz     0x40   // 640x480x85Hz   VESA
#define veEstTime3_800x600x85Hz     0x20   // 800x600x85Hz   VESA
#define veEstTime3_1280x1024x85Hz   0x10   // 1280x1024x85Hz VESA
#define veEstTime3_1024x768x85Hz    0x08   // 1024x768x85Hz  VESA
#define veEstTime3_1600x1200x75Hz   0x04   // 1600x1200x75Hz VESA
#define veEstTime3_1600x1200x85Hz   0x02   // 1600x1200x85Hz VESA
#define veEstTime3_ManReservedTime  0x01   // manufacturer's reserved timings

//
// bit definitions for the veStdTime field
//
#define veStdTime_HorzResMask       0x00FF    // HorzRes = (X + 31) * 8
#define veStdTime_RefreshRateMask   0x1F00    // RefreshRate = X + 60Hz
#define veStdTime_AspectRatioMask   0xC000    //
#define veStdTime_AspectRatio1to1   0x0000    // 1:1
#define veStdTime_AspectRatio4to3   0x4000    // 4:3
#define veStdTime_AspectRatio5to4   0x8000    // 5:4
#define veStdTime_AspectRatio16to9  0xC000    // 16:9
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllinit.c
 *  Content:	DDRAW.DLL initialization
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   21-feb-95	craige	disconnect anyone who forgot to do it themselves,
 *			use critical sections on Win95
 *   27-feb-95	craige 	new sync. macros
 *   30-mar-95	craige	process tracking/cleanup for Win95
 *   01-apr-95	craige	happy fun joy updated header file
 *   12-apr-95	craige	debug stuff for csects
 *   12-may-95	craige	define GUIDs
 *   24-jun-95	craige	track which processes attach to the DLL
 *   25-jun-95	craige	one ddraw mutex
 *   13-jul-95	craige	ENTER_DDRAW is now the win16 lock;
 *			proper initialization of csects
 *   16-jul-95	craige	work around weird kernel "feature" of getting a
 *			process attach of the same process during process detach
 *   19-jul-95	craige	process detach too much grief; let DDNotify handle it
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   19-aug-95 davidmay restored call to disconnect thunk from 19-jul change
 *   26-sep-95	craige	bug 1364: create new csect to avoid dsound deadlock
 *   08-dec-95 jeffno 	For NT, critical section macros expand to use mutexes
 *   16-mar-96  colinmc Callback table initialization now happens on process
 *                      attach
 *   20-mar-96  colinmc Bug 13341: Made MemState() dump in process detach
 *                      thread safe
 *   07-may-96  colinmc Bug 20219: Simultaneous calls to LoadLibrary cause
 *                      a deadlock
 *   09-may-96  colinmc Bug 20219 (again): Yes the deadlock again - previous
 *                      fix was not enough.
 *   19-jan-97  colinmc AGP support
 *   26-jan-97	ketand	Kill globals for multi-mon.
 *   24-feb-97	ketand	Set up callback from DDHelp to update rects.
 *   03-mar-97  jeffno  Structure name change to avoid conflict w/ ActiveAccessibility
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   31-jul-97 jvanaken Bug 7907: Notify Memphis GDI when ddraw starts up
 *
 ***************************************************************************/

/*
 * unfortunately we have to break our pre-compiled headers to get our
 * GUIDS defined...
 */
#define INITGUID
#include "ddrawpr.h"
#include <initguid.h>
#ifdef WINNT
    #undef IUnknown
    #include <objbase.h>
#endif
#include "apphack.h"

#include "aclapi.h"

#ifdef WIN95
int main; // this is so we can avoid calling DllMainCRTStartup

extern BOOL _stdcall thk3216_ThunkConnect32(LPSTR      pszDll16,
                                 LPSTR      pszDll32,
                                 HINSTANCE  hInst,
                                 DWORD      dwReason);

extern BOOL _stdcall thk1632_ThunkConnect32(LPSTR      pszDll16,
                                 LPSTR      pszDll32,
                                 HINSTANCE  hInst,
                                 DWORD      dwReason);

DWORD _stdcall wWinMain(DWORD a, DWORD b, DWORD c, DWORD d)
{
#ifdef DEBUG
    OutputDebugString("WARNING: wWinMain called. \n");
#endif // DEBUG
    return 0;
}
#endif

#ifdef USE_CRITSECTS
    #define TMPDLLEVENT	"__DDRAWDLL_EVENT__"
#endif

#ifndef WIN16_SEPARATE
    #ifdef WIN95
        #define INITCSINIT() \
	        ReinitializeCriticalSection( &csInit ); \
	        MakeCriticalSectionGlobal( &csInit );
        #define ENTER_CSINIT() EnterCriticalSection( &csInit )
        #define LEAVE_CSINIT() LeaveCriticalSection( &csInit )
        extern CRITICAL_SECTION ddcCS;
        #define INITCSDDC() \
	        ReinitializeCriticalSection( &ddcCS ); \
	        MakeCriticalSectionGlobal( &ddcCS );
    #else
        #define CSINITMUTEXNAME "InitMutexName"
        #define INITCSINIT() \
                csInitMutex = CreateMutex(NULL,FALSE,CSINITMUTEXNAME);
        #define ENTER_CSINIT() \
                WaitForSingleObject(csInitMutex,INFINITE);
        #define LEAVE_CSINIT() \
                ReleaseMutex(csInitMutex);
        #define INITDDC()
    #endif
#endif

#ifdef WIN95
#define INITCSWINDLIST() \
	ReinitializeCriticalSection( &csWindowList ); \
	MakeCriticalSectionGlobal( &csWindowList );
#define INITCSDRIVEROBJECTLIST() \
	ReinitializeCriticalSection( &csDriverObjectList ); \
	MakeCriticalSectionGlobal( &csDriverObjectList );
#define FINIWINDLIST() 
#define FINICSDRIVEROBJECTLIST() 
#else
    // Each process needs its own handle, so these are not initialised so theyu won't end up in shared mem
    HANDLE              hDirectDrawMutex=(HANDLE)0;
    //This counts recursions into ddraw, so we don't try to do the mode uniqueness thing on recursive entries into ddraw
    DWORD               gdwRecursionCount=0;

    HANDLE              hWindowListMutex; //=(HANDLE)0;
    HANDLE              hDriverObjectListMutex; //=(HANDLE)0;
    HANDLE              csInitMutex;

    DWORD               dwNumLockedWhenModeSwitched;

    #define WINDOWLISTMUTEXNAME "DDrawWindowListMutex"
    #define DRIVEROBJECTLISTMUTEXNAME "DDrawDriverObjectListMutex"
    #define INITCSWINDLIST() \
	hWindowListMutex = CreateMutex(NULL,FALSE,WINDOWLISTMUTEXNAME);
    #define INITCSDRIVEROBJECTLIST() \
	hDriverObjectListMutex = CreateMutex(NULL,FALSE,DRIVEROBJECTLISTMUTEXNAME);
    #define FINIWINDLIST() CloseHandle(hWindowListMutex);
    #define FINICSDRIVEROBJECTLIST() CloseHandle(hDriverObjectListMutex);


#endif //win95

DWORD		            dwRefCnt=0;

DWORD                       dwLockCount=0;

DWORD                       dwFakeCurrPid=0;
DWORD                       dwGrimReaperPid=0;

LPDDWINDOWINFO	            lpWindowInfo=0;  // the list of WINDOWINFO structures
LPDDRAWI_DIRECTDRAW_LCL     lpDriverLocalList=0;
LPDDRAWI_DIRECTDRAW_INT     lpDriverObjectList=0;
volatile DWORD	            dwMarker=0;
    /*
     * This is the globally maintained list of clippers not owned by any
     * DirectDraw object. All clippers created with DirectDrawClipperCreate
     * are placed on this list. Those created by IDirectDraw_CreateClipper
     * are placed on the clipper list of thier owning DirectDraw object.
     *
     * The objects on this list are NOT released when an app's DirectDraw
     * object is released. They remain alive until explictly released or
     * the app. dies.
     */
LPDDRAWI_DDRAWCLIPPER_INT   lpGlobalClipperList=0;

HINSTANCE		    hModule=0;
LPATTACHED_PROCESSES        lpAttachedProcesses=0;
BOOL		            bFirstTime=0;

#ifdef DEBUG
    int	                    iDLLCSCnt=0;
    int	                    iWin16Cnt=0;
#endif

    /*
     * These variable are so we can handle more than one window in the
     * topmost window timer.
     */
HWND 			    ghwndTopmostList[MAX_TIMER_HWNDS];
int 			    giTopmostCnt = 0;

        /*
         * Winnt specific global statics
         */
#ifdef WINNT
    ULONG                   uDisplaySettingsUnique=0;
#endif

        /*
         *Hel globals:
         */

    // used to count how many drivers are currently using the HEL
DWORD	                    dwHELRefCnt=0;
    // keep these around to pass to blitlib. everytime we blt to/from a surface, we
    // construct a BITMAPINFO for that surface using gpbmiSrc and gpbmiDest
LPBITMAPINFO                gpbmiSrc=0;
LPBITMAPINFO                gpbmiDest=0;

#ifdef DEBUG
        // these are used by myCreateSurface
    int                     gcSurfMem=0; // surface memory in bytes
    int                     gcSurf=0;  // number of surfaces
#endif

DWORD	                    dwHelperPid=0;

#ifdef USE_CHEAP_MUTEX
    #ifdef WINNT
        #pragma data_seg("share")
    #endif

    GLOBAL_SHARED_CRITICAL_SECTION CheapMutexCrossProcess={0};

    #ifdef WINNT
        #pragma data_seg(".data")
    #endif

#endif //0

/*
 * App compatibility stuff. Moved here from apphack.c
 */

BOOL	                    bReloadReg=FALSE;
BOOL		            bHaveReadReg=FALSE;
LPAPPHACKS	            lpAppList=NULL;
LPAPPHACKS	            *lpAppArray=NULL;
DWORD		            dwAppArraySize=0;

/*
 * Global head of DC/Surface association list
 * This list is usually very very short, so we take the hit of extra pointers
 * just so that we don't have to traverse the entire list of surfaces.
 */
DCINFO *g_pdcinfoHead = NULL;


BYTE szDeviceWndClass[] = "DirectDrawDeviceWnd";

/*
 * Gamma calibration globals.  This determines weather a calibrator exists
 * and the handle to the DLL if it's loaded.
 */
BOOL                       bGammaCalibratorExists=FALSE;
BYTE                       szGammaCalibrator[MAX_PATH]="";

/*
 * Optional refresh rate to force for all modes.
 */
DWORD dwForceRefreshRate;

/*
 * Spinlocks for startup synchronization.
 * It's just too hard to use events when NT ddraw is per-process and 9x is cross-
 */
DWORD   dwSpinStartup=0;
DWORD   dwHelperSpinStartup=0;


#ifdef USE_CHEAP_MUTEX
    /*
     * This is the global variable pointer.
     */
    GLOBAL_LOCAL_CRITICAL_SECTION CheapMutexPerProcess;
#endif

/*
 * These two keep w95help.c happy. They point to the dwHelperPid and hModule entries in the process's
 * mapping of the GLOBALS structure.
 */
DWORD	* pdwHelperPid=&dwHelperPid;
HANDLE	* phModule=&hModule;

#ifdef WINNT
/*
 * This mutex is owned by the exclusive mode owner
 */
HANDLE              hExclusiveModeMutex=0;
HANDLE              hCheckExclusiveModeMutex=0;
#define EXCLUSIVE_MODE_MUTEX_NAME "__DDrawExclMode__"
#define CHECK_EXCLUSIVE_MODE_MUTEX_NAME "__DDrawCheckExclMode__"
#endif

//#endif

/*
 *-------------------------------------------------------------------------
 */

#if defined(WIN95) || defined(NT_USES_CRITICAL_SECTION)
    static CRITICAL_SECTION DirectDrawCSect;
    CSECT_HANDLE	lpDDCS;
#endif

/*
 * Win95 specific global statics
 */

#ifdef WIN95
    LPVOID	        lpWin16Lock;

    static CRITICAL_SECTION csInit = {0};
    CRITICAL_SECTION	csWindowList;
    CRITICAL_SECTION    csDriverObjectList;
#endif

#define HELPERINITDLLEVENT "__DDRAWDLL_HELPERINIT_EVENT__"

/*
 * DllMain
 */
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    LPATTACHED_PROCESSES	lpap;
    DWORD			pid;
    BOOL                        didhelp;

    dwMarker = 0x56414C4D;

    pid = GetCurrentProcessId();

    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        pdwHelperPid=&dwHelperPid;
        phModule=&hModule;


        DisableThreadLibraryCalls( hmod );
	DPFINIT();

	/*
	 * create the DirectDraw csect
	 */
	DPF( 4, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
			pid, GetCurrentThreadId() );

	#ifdef WIN95
	    if( lpWin16Lock == NULL )
	    {
		GetpWin16Lock( &lpWin16Lock );
	    }
	#endif
	#ifdef USE_CRITSECTS
	{

	    #if defined( WIN16_SEPARATE ) && (defined(WIN95) || defined(NT_USES_CRITICAL_SECTION))
		lpDDCS = &DirectDrawCSect;
	    #endif

	    /*
	     * is this the first time?
	     */
	    if( FALSE == InterlockedExchange( &bFirstTime, TRUE ) )
	    {
		#ifdef WIN16_SEPARATE
		    INIT_DDRAW_CSECT();
		    INITCSWINDLIST();
		    INITCSDRIVEROBJECTLIST();
		    ENTER_DDRAW_INDLLMAIN();
		#else
		    INITCSDDC();		// used in DirectDrawCreate
		    INITCSINIT();
		    ENTER_CSINIT();
		#endif

                hModule = hmod;
	        /*
	         * This event is signaled when DDHELP has successfully finished
	         * initializing. Threads other that the very first one to connect
	         * and the one spawned by DDHELP must wait for this event to
	         * be signaled as deadlock will result if they run through
	         * process attach before the DDHELP thread has.
	         *
	         * NOTE: The actual deadlock this prevents is pretty unusual so
	         * if we fail to create this event we will simply continue. Its
	         * highly unlikely anyone will notice (famous last words).
	         *
	         * CMcC
	         */
                /*
                 * Replaced events with spinlocks to work around a handle leak
                 */
                InterlockedExchange( & dwSpinStartup , 1);
	    }
	    /*
	     * second or later time through, wait for first time to
	     * finish and then take the csect
	     */
	    else
	    {
                /*
                 * Spin waiting for the first thread to exit the clause above
                 * This strange construction works around a compiler bug.
                 * while (dwHelperSpinStartup==1); generates an infinite loop.
                 */
                while (1)
                {
                    if (dwSpinStartup==1)
                        break;
                }

		#ifdef WIN16_SEPARATE
                #if defined( WINNT )
                    //Each process needs its own handle in NT
		    INIT_DDRAW_CSECT();
                #endif
		    ENTER_DDRAW_INDLLMAIN();
		#else
		    ENTER_CSINIT();
		#endif

	    }
	}
	#endif

        #ifdef WINNT
            {
                SECURITY_ATTRIBUTES sa;
                SID_IDENTIFIER_AUTHORITY sia = SECURITY_WORLD_SID_AUTHORITY;
                PSID adminSid = 0;
                ULONG cbAcl;
                PACL acl=0;
                PSECURITY_DESCRIPTOR pSD;
                BYTE buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
                BOOL bSecurityGooSucceeded = FALSE;
                //Granny's old fashioned LocalAlloc:
                BYTE Buffer1[256];
                BYTE Buffer2[16];

                // Create the SID for world
                cbAcl = GetSidLengthRequired(1);
                if (cbAcl < sizeof(Buffer2))
                {
                    adminSid = (PSID) Buffer2;
                    InitializeSid(
                        adminSid,
                        &sia,
                        1
                        );
                    *GetSidSubAuthority(adminSid, 0) = SECURITY_WORLD_RID;
                  
                   // Create an ACL giving World all access.
                    cbAcl = sizeof(ACL) +
                                 (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                                 GetLengthSid(adminSid);
                    if (cbAcl < sizeof(Buffer1))
                    {
                        acl = (PACL)&Buffer1;
                        if (InitializeAcl(
                            acl,
                            cbAcl,
                            ACL_REVISION
                            ))
                        {
                            if (AddAccessAllowedAce(
                                acl,
                                ACL_REVISION,
                                SYNCHRONIZE|MUTANT_QUERY_STATE|DELETE|READ_CONTROL, //|WRITE_OWNER|WRITE_DAC,
                                adminSid
                                ))
                            {
                                // Create a security descriptor with the above ACL.
                                pSD = (PSECURITY_DESCRIPTOR)buffer;
                                if (InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
                                {
                                    if (SetSecurityDescriptorDacl(pSD, TRUE, acl, FALSE))
                                    {
                                        // Fill in the SECURITY_ATTRIBUTES struct.
                                        sa.nLength = sizeof(sa);
                                        sa.lpSecurityDescriptor = pSD;
                                        sa.bInheritHandle = TRUE;

                                        bSecurityGooSucceeded = TRUE;
                                    }
                                }
                            }
                        }
                    }
                } 

                // Use the security attributes to create the mutexes
                DDASSERT(0 == hExclusiveModeMutex);
                hExclusiveModeMutex = CreateMutex( 
                    bSecurityGooSucceeded ? &sa : NULL,     //use default access if security goo failed.
                    FALSE, 
                    EXCLUSIVE_MODE_MUTEX_NAME );

                if (0 == hExclusiveModeMutex)
                {
                    hExclusiveModeMutex = OpenMutex(
                        SYNCHRONIZE|DELETE,  // access flag
                        FALSE,    // inherit flag
                        EXCLUSIVE_MODE_MUTEX_NAME          // pointer to mutex-object name
                        );
                }
 
	        if( hExclusiveModeMutex == 0 )
	        {
		    DPF_ERR("Could not create exclusive mode mutex. exiting" );
		    #ifdef WIN16_SEPARATE
		        LEAVE_DDRAW();
		    #else
		        LEAVE_CSINIT();
		    #endif
		    return FALSE;
	        }

                DDASSERT(0 == hCheckExclusiveModeMutex);
                hCheckExclusiveModeMutex = CreateMutex( 
                    bSecurityGooSucceeded ? &sa : NULL,     //use default access if security goo failed.
                    FALSE, 
                    CHECK_EXCLUSIVE_MODE_MUTEX_NAME );

                if (0 == hCheckExclusiveModeMutex)
                {
                    hCheckExclusiveModeMutex = OpenMutex(
                        SYNCHRONIZE|DELETE,  // access flag
                        FALSE,    // inherit flag
                        CHECK_EXCLUSIVE_MODE_MUTEX_NAME          // pointer to mutex-object name
                        );
                }

	        if( hCheckExclusiveModeMutex == 0 )
	        {
		    DPF_ERR("Could not create exclusive mode check mutex. exiting" );
                    CloseHandle( hExclusiveModeMutex );
		    #ifdef WIN16_SEPARATE
		        LEAVE_DDRAW();
		    #else
		        LEAVE_CSINIT();
		    #endif
		    return FALSE;
	        }
            }
        #endif


	#ifdef WIN95
	{
	    DWORD	hpid;

	    /*
	     * get the helper process started
	     */
	    didhelp = CreateHelperProcess( &hpid );
	    if( hpid == 0 )
	    {
		DPF( 0, "Could not start helper; exiting" );
		#ifdef WIN16_SEPARATE
		    LEAVE_DDRAW();
		#else
		    LEAVE_CSINIT();
		#endif
		return FALSE;
	    }


	    /*
	     * You get three kinds of threads coming through
	     * process attach:
	     *
	     * 1) A thread belonging to the first process to
	     *    connect to DDRAW.DLL. This is distinguished as
	     *    it performs lots of one time initialization
	     *    including starting DDHELP and getting DDHELP
	     *    to load its own copy of DDRAW.DLL. Threads
	     *    of this type are identified by didhelp being
	     *    TRUE in their context
	     * 2) A thread belonging to DDHELP when it loads
	     *    its own copy of DDHELP in response to a
	     *    request from a thread of type 1. Threads of
	     *    this type are identified by having a pid
	     *    which is equal to hpid (DDHELP's pid)
	     * 3) Any other threads belonging to subsequent
	     *    processes connecting to DDRAW.DLL
	     *
	     * As a thread of type 1 causes a thread of type 2
	     * to enter process attach before it itself has finished
	     * executing process attach itself we open our selves up
	     * to lots of deadlock problems if we let threads of
	     * type 3 through process attach before the other threads
	     * have completed their work.
	     *
	     * Therefore, the rule is that subsequent process
	     * attachement can only be allowed to execute the
	     * remainder of process attach if both the type 1
	     * and type 2 thread have completed their execution
	     * of process attach. We assure this with a combination
	     * of the critical section and an event which is signaled
	     * once DDHELP has initialized. Threads of type 3 MUST
	     * wait on this event before continuing through the
	     * process attach code. This is what the following
	     * code fragment does.
	     */
            /*
             * These events have been replaced with spinlocks, since
             * the old way leaked events, and it's just too hard to make them work.
             */
	    if( !didhelp && ( pid != hpid ) )
	    {
		{
		    /*
		     * NOTE: If we hold the DirectDraw critical
		     * section when we wait on this event we WILL
		     * DEADLOCK. Don't do it! Release the critical
		     * section before and take it again after. This
		     * guarantees that we won't complete process
		     * attach before the initial thread and the
		     * DDHELP thread have exited process attach.
		     */
		    #ifdef WIN16_SEPARATE
			LEAVE_DDRAW();
		    #else
			LEAVE_CSINIT();
		    #endif
                    /*
                     * This strange construction works around a compiler bug.
                     * while (dwHelperSpinStartup==1); generates an infinite loop.
                     */
                    while (1)
                    {
                        if ( dwHelperSpinStartup == 1)
                            break;
                    }
		    #ifdef WIN16_SEPARATE
			ENTER_DDRAW_INDLLMAIN();
		    #else
			ENTER_CSINIT();
		    #endif
		}
	    }
	}

	/*
	 * Win95 thunk connection...
	 */
	    DPF( 4, "Thunk connects" );
	    if (!(thk3216_ThunkConnect32(DDHAL_DRIVER_DLLNAME,
				    DDHAL_APP_DLLNAME,
				    hmod,
				    dwReason)))
	    {
		#ifdef WIN16_SEPARATE
		    LEAVE_DDRAW();
		#else
		    LEAVE_CSINIT();
		#endif
		DPF( 0, "LEAVING, COULD NOT thk3216_THUNKCONNECT32" );
		return FALSE;
	    }
	    if (!(thk1632_ThunkConnect32(DDHAL_DRIVER_DLLNAME,
				    DDHAL_APP_DLLNAME,
				    hmod,
				    dwReason)))
	    {
		#ifdef WIN16_SEPARATE
		    LEAVE_DDRAW();
		#else
		    LEAVE_CSINIT();
		#endif
		DPF( 0, "LEAVING, COULD NOT thk1632_THUNKCONNECT32" );
		return FALSE;
	    }

	/*
	 * initialize memory used to be done here. Jeffno 960609
	 */


	    /*
	     * signal the new process being added
	     */
	    if( didhelp )
	    {
		DPF( 4, "Waiting for DDHELP startup" );
		#ifdef WIN16_SEPARATE
		    LEAVE_DDRAW();
		#else
		    LEAVE_CSINIT();
		#endif
		if( !WaitForHelperStartup() )
		{
                    /*
                     * NT Setup loads DDRAW.DLL and sometimes this fails, so we don't 
                     * actually want fail loading the DLL or else setup might fail.
                     * Instead, we will suceed the load but then fail any other ddraw
                     * calls.
                     */
		    DPF( 0, "WaitForHelperStartup FAILED - disabling DDRAW" );
                    dwHelperPid = 0;
		    return TRUE;
		}
		HelperLoadDLL( DDHAL_APP_DLLNAME, NULL, 0 );

		/*
		 * For now, only call this on a multi-monitor system because
		 * it does cause a behavior change and we aren't able to
		 * provide adequate test covereage in the DX5 timeframe.
		 */
		if( IsMultiMonitor() )
		{
		   HelperSetOnDisplayChangeNotify( (void *)&UpdateAllDeviceRects);
		}

		#ifdef WIN16_SEPARATE
		    ENTER_DDRAW_INDLLMAIN();
		#else
		    ENTER_CSINIT();
		#endif

		/*
		 * As we were the first process through we now signal
		 * the completion of DDHELP initialization. This will
		 * release any subsequent threads waiting to complete
		 * process attach.
		 *
		 * NOTE: Threads waiting on this event will not immediately
		 * run process attach to completion as they will immediately
		 * try to take the DirectDraw critical section which we hold.
		 * Thus, they will not be allowed to continue until we have
		 * released the critical section just prior to existing
		 * below.
		 */
                InterlockedExchange( & dwHelperSpinStartup , 1);
	    }
	    SignalNewProcess( pid, DDNotify );
  	#endif //w95

        /*
         * We call MemInit here in order to guarantee that MemInit is called for
         * the first time on ddhelp's process. Why? Glad you asked. On wx86
         * (NT's 486 emulator) controlled instances of ddraw apps, we get a fault
         * whenever the ddraw app exits. This is because the app creates the RTL
         * heap inside a view of a file mapping which gets uncomitted (rightly)
         * when the app calls MemFini on exit. In this scenario, imagehlp.dll has
         * also created a heap, and calls a ntdll function which attempts to walk
         * the list of heaps, which requires a peek at the ddraw app's heap which
         * has been mapped out. Krunch.
         * We can't destroy the heap on MemFini because of the following scenario:
         * App A starts, creates heap. App b starts, maps a view of heap. App A
         * terminates, destroys heap. App b tries to use destroyed heap. Krunch
         * Jeffno 960609
         */
	if( dwRefCnt == 0 )
        {
            if ( !MemInit() )
            {
                #ifdef WINNT
                    CloseHandle( hExclusiveModeMutex );
                    CloseHandle( hCheckExclusiveModeMutex );
                #endif

		#ifdef WIN16_SEPARATE
		    LEAVE_DDRAW();
		#else
		    LEAVE_CSINIT();
		#endif
                DPF( 0,"LEAVING, COULD NOT MemInit");
                return FALSE;
            }

            #ifdef WIN95
	    /*
	     * The Memphis version of GDI calls into DirectDraw, but GDI
	     * needs to be notified that DirectDraw has actually loaded.
	     * (While GDI could check for itself to see whether ddraw.dll
	     * has loaded, this would be sloooooow if it hasn't yet.)
	     * The code below executes when ddraw.dll first starts up.
	     */
	    {
		HANDLE h;
		VOID (WINAPI *p)();

		h = LoadLibrary("msimg32.dll");    // GDI DLL
		if (h)
		{
		    p = (VOID(WINAPI *)())GetProcAddress(h, "vSetDdrawflag");
		    if (p)
		    {		   // vSetDdrawflag is a private call to
			(*p)();    // signal GDI that DDraw has loaded
		    }
		    FreeLibrary(h);
		}
	    }
	    #endif //WIN95
	}
        dwRefCnt++;


	/*
	 * remember this process (moved this below MemInit when it moved -Jeffno 960609
	 */
	lpap = MemAlloc( sizeof( ATTACHED_PROCESSES ) );
	if( lpap != NULL )
	{
	    lpap->lpLink = lpAttachedProcesses;
	    lpap->dwPid = pid;
            #ifdef WINNT
                lpap->dwNTToldYet=0;
            #endif
	    lpAttachedProcesses = lpap;
	}

	/*
	 * Initialize callback tables for this process.
	 */

	InitCallbackTables();

	#ifdef WIN16_SEPARATE
	    LEAVE_DDRAW();
	#else
	    LEAVE_CSINIT();
	#endif

	DPF( 4, "====> EXIT: DLLMAIN(%08lx): Process Attach: %08lx", DllMain,
			pid );
        break;

    case DLL_PROCESS_DETACH:
	DPF( 4, "====> ENTER: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
		DllMain, pid, GetCurrentThreadId() );
	    /*
	     * disconnect from thunk, even if other cleanup code commented out...
	     */
	    #ifdef WIN95
	        thk3216_ThunkConnect32(DDHAL_DRIVER_DLLNAME,
				        DDHAL_APP_DLLNAME,
				        hmod,
				        dwReason);
	        thk1632_ThunkConnect32(DDHAL_DRIVER_DLLNAME,
				        DDHAL_APP_DLLNAME,
				        hmod,
				        dwReason);
	    #endif

            #ifdef WINNT        //win NT needs to close file mapping handle for each process
                FreeAppHackData();
                RemoveProcessFromDLL(pid);
		FINI_DDRAW_CSECT(); //Cheap mutexes need to close semaphore handle for each process
                MemFini();

                DDASSERT(0 != hExclusiveModeMutex);
                CloseHandle( hCheckExclusiveModeMutex );
                CloseHandle( hExclusiveModeMutex );
                FINIWINDLIST();
                FINICSDRIVEROBJECTLIST();
            #endif

	DPF( 4, "====> EXIT: DLLMAIN(%08lx): Process Detach %08lx",
		DllMain, pid );
        break;

    /*
     * we don't ever want to see thread attach/detach
     */
    #ifdef DEBUG
	case DLL_THREAD_ATTACH:
	    DPF( 4, "THREAD_ATTACH");
	    break;

	case DLL_THREAD_DETACH:
	    DPF( 4,"THREAD_DETACH");
	    break;
    #endif
    default:
        break;
    }

    return TRUE;

} /* DllMain */


/*
 * RemoveProcessFromDLL
 *
 * Find & remove a pid from the list.
 * Assumes ddlock taken
 */
BOOL RemoveProcessFromDLL( DWORD pid )
{
    LPATTACHED_PROCESSES	lpap;
    LPATTACHED_PROCESSES	prev;

    lpap = lpAttachedProcesses;
    prev = NULL;
    while( lpap != NULL )
    {
	if( lpap->dwPid == pid )
	{
	    if( prev == NULL )
	    {
		lpAttachedProcesses = lpap->lpLink;
	    }
	    else
	    {
		prev->lpLink = lpap->lpLink;
	    }
	    MemFree( lpap );
	    DPF( 5, "Removing process %08lx from list", pid );
	    return TRUE;
	}
	prev = lpap;
	lpap = lpap->lpLink;
    }
    DPF( 5, "Process %08lx not in DLL list", pid );
    return FALSE;

} /* RemoveProcessFromDLL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\dmemmgr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dmemmgr.h
 *  Content:	Direct Memory Manager include file
 *
 ***************************************************************************/

#ifndef __DMEMMGR_INCLUDED__
#define __DMEMMGR_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __NTDDKCOMP__

/*
 * pointer to video memory
 */
typedef ULONG_PTR FLATPTR;

typedef struct _VIDMEM *LPVIDMEM;

#else

/*
 * pointer to video memory, potentially 64-bit
 */
typedef ULONG_PTR FLATPTR;

typedef struct _VIDEOMEMORY *LPVIDMEM;

#endif

/*
 * Structure for querying extended heap alignment requirements
 */

typedef struct _SURFACEALIGNMENT
{
    union
    {
        struct
        {
            DWORD       dwStartAlignment;
            DWORD       dwPitchAlignment;
            DWORD       dwReserved1;
            DWORD       dwReserved2;
        } Linear;
        struct
        {
            DWORD       dwXAlignment;
            DWORD       dwYAlignment;
            DWORD       dwReserved1;
            DWORD       dwReserved2;
        } Rectangular;
    };
} SURFACEALIGNMENT;
typedef struct _SURFACEALIGNMENT FAR *LPSURFACEALIGNMENT;

typedef struct _HEAPALIGNMENT
{
    DWORD                dwSize;
    DDSCAPS              ddsCaps;       /* Indicates which alignment fields are valid.*/
    DWORD                dwReserved;
    SURFACEALIGNMENT     ExecuteBuffer; /* Surfaces tagged with DDSCAPS_EXECUTEBUFFER */
    SURFACEALIGNMENT     Overlay;       /* Surfaces tagged with DDSCAPS_OVERLAY       */
    SURFACEALIGNMENT     Texture;       /* Surfaces tagged with DDSCAPS_TEXTURE       */
    SURFACEALIGNMENT     ZBuffer;       /* Surfaces tagged with DDSCAPS_ZBUFFER       */
    SURFACEALIGNMENT     AlphaBuffer;   /* Surfaces tagged with DDSCAPS_ALPHA         */
    SURFACEALIGNMENT     Offscreen;     /* Surfaces tagged with DDSCAPS_OFFSCREENPLAIN*/
    SURFACEALIGNMENT     FlipTarget;    /* Surfaces whose bits are potential primaries i.e. back buffers*/
} HEAPALIGNMENT;
typedef struct _HEAPALIGNMENT FAR *LPHEAPALIGNMENT;

/*
 * video memory manager structures
 */
typedef struct _VMEML
{
    struct _VMEML 	FAR *next;
    FLATPTR		ptr;
    DWORD		size;
} VMEML, FAR *LPVMEML, FAR * FAR *LPLPVMEML;

typedef struct _VMEMR
{
    struct _VMEMR 	FAR *next;
    struct _VMEMR       FAR *prev;
    /*
     * The pUp, pDown, pLeft and pRight members were removed in DX5
     */
    struct _VMEMR 	FAR *pUp;
    struct _VMEMR 	FAR *pDown;
    struct _VMEMR 	FAR *pLeft;
    struct _VMEMR 	FAR *pRight;
    FLATPTR		ptr;
    DWORD		size;
    DWORD               x;
    DWORD               y;
    DWORD               cx;
    DWORD               cy;
    DWORD		flags;
    FLATPTR             pBits;
} VMEMR, FAR *LPVMEMR, FAR * FAR *LPLPVMEMR;

typedef struct _VMEMHEAP
{
    DWORD		        dwFlags;
    DWORD                       stride;
    LPVOID		        freeList;
    LPVOID		        allocList;
    DWORD                       dwTotalSize;
    FLATPTR                     fpGARTLin;      /* AGP: GART linear base of heap (app. visible)   */
    FLATPTR                     fpGARTDev;      /* AGP: GART device base of heap (driver visible) */
    DWORD                       dwCommitedSize; /* AGP: Number of bytes commited to heap          */
    /*
     * Extended alignment data:
     * Filled in by DirectDraw in response to a GetHeapAlignment HAL call.
     */
    DWORD                       dwCoalesceCount;
    HEAPALIGNMENT               Alignment;
    /*
     * These are analogous to VIDMEM.ddsCaps and VIDMEM.ddsCapsAlt. These values are queried from the
     * driver by a GetDriverInfo call. See the documentation for GUID_DDMoreSurfaceCaps
     */
    DDSCAPSEX                   ddsCapsEx;
    DDSCAPSEX                   ddsCapsExAlt;
#ifndef IS_16
    // Full physical address of heap base for NT AGP heaps.
    LARGE_INTEGER               liPhysAGPBase;
#endif
    // hdev for use with VidMemAllocAligned on NT.  Set by the system at
    // initialization time.
    HANDLE                      hdevAGP;
    // Physical reservation handle for NT heaps.
    LPVOID                      pvPhysRsrv;
} VMEMHEAP;

typedef VMEMHEAP FAR *LPVMEMHEAP;

#define VMEMHEAP_LINEAR			0x00000001l /* Heap is linear                    */
#define VMEMHEAP_RECTANGULAR		0x00000002l /* Heap is rectangular               */
#define VMEMHEAP_ALIGNMENT  		0x00000004l /* Heap has extended alignment info  */

/*
 * This legacy export doesn't handle nonlocal heaps
 * This function is not available on Windows NT
 */
#ifndef __NTDDKCOMP__
extern FLATPTR WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD width, DWORD height );
#endif

/*
 * This export can be used by drivers to allocate aligned surfaces from heaps which
 * they have previously exposed to DirectDraw. This function can allocate from nonlocal heaps.
 */
extern FLATPTR WINAPI HeapVidMemAllocAligned(
                LPVIDMEM lpVidMem,
                DWORD dwWidth,
                DWORD dwHeight,
                LPSURFACEALIGNMENT lpAlignment ,
                LPLONG lpNewPitch );

/*
 * This export can free memory allocated via either allocation function
 */
extern void WINAPI VidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\drvinfo.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	drvinfo.c
 *  Content:	DirectDraw driver info implementation
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   17-jun-98	jeffno  initial implementation, after michael lyons and toddla
 *   14-jun-99  mregen  return WHQL certification level -- postponed
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "ddrawpr.h"

#include <tchar.h>
#include <stdio.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <softpub.h>
#include <mscat.h>



//========================================================================
//
// just some handy forward declarations
//
DWORD GetWHQLLevel(LPTSTR lpszDriver, LPSTR lpszWin9xDriver);
DWORD IsFileDigitallySigned(LPTSTR lpszDriver);
BOOL FileIsSignedOld(LPTSTR lpszFile);

//
//  These functions are defined in mscat.h. They are not available on win95,
//  so we have to use LoadLibrary to load mscat32.dll and wincrypt.dll
//
typedef HCATINFO WINAPI funcCryptCATAdminEnumCatalogFromHash(HCATADMIN hCatAdmin,
                                                             BYTE *pbHash,
                                                             DWORD cbHash,
                                                             DWORD dwFlags,
                                                             HCATINFO *phPrevCatInfo);
typedef BOOL WINAPI funcCryptCATAdminCalcHashFromFileHandle(HANDLE hFile,
                                                            DWORD *pcbHash,
                                                            BYTE *pbHash,
                                                            DWORD dwFlags);
typedef HANDLE WINAPI funcCryptCATOpen( LPWSTR pwszFileName, 
                                        DWORD fdwOpenFlags,
                                        HCRYPTPROV hProv,
                                        DWORD dwPublicVersion,
                                        DWORD dwEncodingType);
typedef BOOL WINAPI funcCryptCATClose(IN HANDLE hCatalog);
typedef CRYPTCATATTRIBUTE * WINAPI funcCryptCATGetCatAttrInfo( HANDLE hCatalog,
                                                           LPWSTR pwszReferenceTag);
typedef BOOL WINAPI      funcCryptCATAdminAcquireContext(HCATADMIN *phCatAdmin, 
                                                        GUID *pgSubsystem, 
                                                        DWORD dwFlags);
typedef BOOL WINAPI      funcCryptCATAdminReleaseContext(HCATADMIN hCatAdmin,
                                                         DWORD dwFlags);
typedef BOOL WINAPI funcCryptCATAdminReleaseCatalogContext(HCATADMIN hCatAdmin,
                                                       HCATINFO hCatInfo,
                                                       DWORD dwFlags);
typedef BOOL WINAPI funcCryptCATCatalogInfoFromContext(HCATINFO hCatInfo,
                                                   CATALOG_INFO *psCatInfo,
                                                   DWORD dwFlags);

typedef CRYPTCATATTRIBUTE * WINAPI funcCryptCATEnumerateCatAttr(HCATINFO hCatalog,
                                                           CRYPTCATATTRIBUTE *lpCat);


//
//  function defined in wincrypt.dll
//
typedef LONG WINAPI funcWinVerifyTrust(HWND hwnd, GUID *pgActionID,
                                  LPVOID pWVTData);

//
//  our storage for the mscat32/wincrypt dll loader
//
typedef struct tagCatApi {
    BOOL bInitialized;
    HINSTANCE hLibMSCat;
    HINSTANCE hLibWinTrust;
    HCATADMIN hCatAdmin;
    funcCryptCATClose *pCryptCATClose;
    funcCryptCATGetCatAttrInfo *pCryptCATGetCatAttrInfo;
    funcCryptCATOpen *pCryptCATOpen;
    funcCryptCATAdminEnumCatalogFromHash *pCryptCATAdminEnumCatalogFromHash;
    funcCryptCATAdminCalcHashFromFileHandle *pCryptCATAdminCalcHashFromFileHandle;
    funcCryptCATAdminAcquireContext *pCryptCATAdminAcquireContext;
    funcCryptCATAdminReleaseContext *pCryptCATAdminReleaseContext;
    funcCryptCATAdminReleaseCatalogContext *pCryptCATAdminReleaseCatalogContext;
    funcCryptCATCatalogInfoFromContext *pCryptCATCatalogInfoFromContext;
    funcCryptCATEnumerateCatAttr *pCryptCATEnumerateCatAttr;
    funcWinVerifyTrust *pWinVerifyTrust;
} CATAPI,* LPCATAPI;

//========================================================================
//
// some helper functions to open/close crypt API
//

BOOL InitCATAPI(LPCATAPI lpCatApi)
{
    UINT uiOldErrorMode;
    HINSTANCE hLibMSCat;
    HINSTANCE hLibWinTrust;

    DDASSERT(lpCatApi!=NULL);
    ZeroMemory( lpCatApi, sizeof(CATAPI));

    // already initialized by ZeroMemory
    // lpCatApi->bInitialized=FALSE:

    uiOldErrorMode=SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hLibMSCat=LoadLibrary("mscat32.dll");
    hLibWinTrust=LoadLibrary("wintrust.dll");

    if (hLibMSCat!=NULL &&
        hLibWinTrust!=NULL)
    {
        lpCatApi->pCryptCATOpen=(funcCryptCATOpen *)
            GetProcAddress ( hLibMSCat, "CryptCATOpen");
        lpCatApi->pCryptCATClose=(funcCryptCATClose *)
            GetProcAddress ( hLibMSCat, "CryptCATClose");
        lpCatApi->pCryptCATGetCatAttrInfo=(funcCryptCATGetCatAttrInfo *)
            GetProcAddress ( hLibMSCat, "CryptCATGetCatAttrInfo");
        lpCatApi->pCryptCATAdminCalcHashFromFileHandle=(funcCryptCATAdminCalcHashFromFileHandle*)
            GetProcAddress ( hLibMSCat, "CryptCATAdminCalcHashFromFileHandle");
        lpCatApi->pCryptCATAdminEnumCatalogFromHash=(funcCryptCATAdminEnumCatalogFromHash*)
            GetProcAddress ( hLibMSCat, "CryptCATAdminEnumCatalogFromHash");
        lpCatApi->pCryptCATAdminAcquireContext=(funcCryptCATAdminAcquireContext*)
            GetProcAddress ( hLibMSCat, "CryptCATAdminAcquireContext");
        lpCatApi->pCryptCATAdminReleaseContext=(funcCryptCATAdminReleaseContext*)
            GetProcAddress ( hLibMSCat, "CryptCATAdminReleaseContext");
        lpCatApi->pCryptCATAdminReleaseCatalogContext=(funcCryptCATAdminReleaseCatalogContext*)
            GetProcAddress ( hLibMSCat, "CryptCATAdminReleaseCatalogContext");
        lpCatApi->pCryptCATCatalogInfoFromContext=(funcCryptCATCatalogInfoFromContext*)
            GetProcAddress ( hLibMSCat, "CryptCATCatalogInfoFromContext");
        lpCatApi->pCryptCATEnumerateCatAttr=(funcCryptCATEnumerateCatAttr*)
            GetProcAddress ( hLibMSCat, "CryptCATEnumerateCatAttr");
        lpCatApi->pWinVerifyTrust=(funcWinVerifyTrust*)
            GetProcAddress ( hLibWinTrust,"WinVerifyTrust");

        if (lpCatApi->pCryptCATOpen!=NULL &&
            lpCatApi->pCryptCATClose!=NULL &&
            lpCatApi->pCryptCATGetCatAttrInfo!=NULL &&
            lpCatApi->pCryptCATAdminCalcHashFromFileHandle!=NULL &&
            lpCatApi->pCryptCATAdminEnumCatalogFromHash!=NULL &&
            lpCatApi->pCryptCATAdminAcquireContext!=NULL &&
            lpCatApi->pCryptCATAdminReleaseContext!=NULL &&
            lpCatApi->pCryptCATAdminReleaseCatalogContext!=NULL &&
            lpCatApi->pCryptCATCatalogInfoFromContext!=NULL &&
            lpCatApi->pCryptCATEnumerateCatAttr !=NULL &&
            lpCatApi->pWinVerifyTrust!=NULL
            )
        {
            if ((*lpCatApi->pCryptCATAdminAcquireContext)(&lpCatApi->hCatAdmin,NULL,0))
            {
                lpCatApi->hLibMSCat=hLibMSCat;
                lpCatApi->hLibWinTrust=hLibWinTrust;
                lpCatApi->bInitialized=TRUE;
            }
        } 
    }

    if (!lpCatApi->bInitialized)
    {
       FreeLibrary(hLibMSCat);
       FreeLibrary(hLibWinTrust);
    }

    SetErrorMode(uiOldErrorMode);

    return lpCatApi->bInitialized;
}

BOOL ReleaseCATAPI(LPCATAPI lpCatApi)
{
    DDASSERT(lpCatApi!=NULL);

    if (lpCatApi->bInitialized)
    {
        (*lpCatApi->pCryptCATAdminReleaseContext)( lpCatApi->hCatAdmin, 0);

        FreeLibrary(lpCatApi->hLibMSCat);
        FreeLibrary(lpCatApi->hLibWinTrust);
        ZeroMemory( lpCatApi, sizeof(CATAPI));        

        return TRUE;
    }

    return FALSE;
}

//========================================================================
//
// _strstr
//
// String-in-string function, written to avoid RTL inclusion necessity.
//
//========================================================================
char *_strstr(char *s1, char *s2)
{
	if (s1 && s2)
	{
		while (*s1)
		{
			char *p1=s1;
			char *p2=s2;

			while (*p2 && (*p1==*p2))
			{
				p1++;
				p2++;
			}
			if (*p2==0)
				return s1;

			s1++;
		}
	}

	return NULL;
}
//***&&*%**!!ing c runtime

DWORD _atoi(char * p)
{
    DWORD dw=0;
    while ( (*p >= '0' && *p <= '9') || (*p >= 'A' && *p <= 'F') || (*p >= 'A' && *p <= 'F') )
    {
        dw = dw*16;
        if (*p >= 'a')
            dw += *p-'a' + 10;
        else if (*p >= 'A')
            dw += *p-'A' + 10;
        else
            dw += *p-'0';

        p++;
    }
    return dw;
}

char *FindLast(char * s, char c)
{
    char * pFound=0;
    if (s)
    {
        while (*s)
        {
            if (*s == c)
                pFound = s;
            s++;
        }
    }
    return pFound;
}

//========================================================================
// hard-coded vendor IDs
//========================================================================
#define VEN_3DFX			"VEN_121A"
#define VEN_3DFXVOODOO1                 "VEN_121A&DEV_0001"
#define VEN_POWERVR			"VEN_1033"

#ifdef WIN95

void GetFileVersionData(
    LPDDDRIVERINFOEX pDI)
{
    void *				buffer;
    VS_FIXEDFILEINFO *	verinfo;
    DWORD				dwSize;
    DWORD                               dwHi,dwLo;

    //Failure means 0 returned
    pDI->di.liDriverVersion.HighPart = 0;
    pDI->di.liDriverVersion.LowPart = 0;


    dwSize=GetFileVersionInfoSize(pDI->di.szDriver, 0);

    if (!dwSize)
	    return;

    buffer=LocalAlloc(LPTR, dwSize);
    if (!buffer)
	    return;

    if (!GetFileVersionInfo(pDI->di.szDriver, 0, dwSize, buffer))
    {
	    LocalFree(buffer);
	    return;
    }

    if (!VerQueryValue(buffer, "\\", (void **)&verinfo, (UINT *)&dwSize))
    {
	    LocalFree(buffer);
	    return;
    }

    pDI->di.liDriverVersion.HighPart = verinfo->dwFileVersionMS;
    pDI->di.liDriverVersion.LowPart  = verinfo->dwFileVersionLS;

    LocalFree(buffer);
}


extern HRESULT _GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, LPDDDRIVERINFOEX pDI);

/*
 * following are all the 9x-specific version functions
 */
void GetHALName(
    LPDDRAWI_DIRECTDRAW_GBL pdrv,
    LPDDDRIVERINFOEX        pDI)
{
    pDI->di.szDriver[0] = 0;
    lstrcpyn(pDI->di.szDriver, pdrv->dd32BitDriverData.szName, sizeof(pDI->di.szDriver) );
}


BOOL CheckPowerVR(LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDDRIVERINFOEX pDI)
{
    BOOL    bFound=FALSE;
    HKEY    hKey;
    DWORD   dwSize;
    DWORD   dwType;

    if (pdrv->dwFlags & DDRAWI_SECONDARYDRIVERLOADED)
    {
        /*
         * Any secondary driver information in the registry at all? (assert this is true)
         */
        if( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE,
				         REGSTR_PATH_SECONDARY,
				         &hKey ) )
        {
	    /*
	     * Extract the name of the secondary driver's DLL. (assert this works)
	     */
	    dwSize = sizeof( pDI->di.szDriver ) - 1;
	    if( ERROR_SUCCESS == RegQueryValueEx( hKey,
					          REGSTR_VALUE_SECONDARY_DRIVERNAME,
					          NULL,
					          &dwType,
					          pDI->di.szDriver,
					          &dwSize ) )
	    {
	        if( REG_SZ == dwType )
	        {
                    GetFileVersionData(pDI);
                }
            }
            RegCloseKey(hKey);
        }

        if (SUCCEEDED(_GetDriverInfoFromRegistry(NULL, "Display", VEN_POWERVR, pDI)))
        {
            //got PVR data...
            bFound = TRUE;
        }
    }
    return bFound;
}

HRESULT Check3Dfx(LPDDDRIVERINFOEX pDI)
{
    HRESULT hr = DD_OK;

    if (FAILED(_GetDriverInfoFromRegistry(NULL, "Display", VEN_3DFX, pDI)))
    {
        DPF_ERR("Couldn't get registry data for this device");
        hr = DDERR_NOTFOUND;
    }

    return hr;
}

HRESULT GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, LPDDDRIVERINFOEX pDI)
{
    return _GetDriverInfoFromRegistry(szClass, szClassNot, szVendor, pDI);
}

/*
 * Given a DISPLAY_DEVICE, get driver name
 * NOTE::: THIS FUNCTION NUKES THE DISPLAY_DEVICE.DeviceKey STRING!!!!
 */
void GetWin9XDriverName(DISPLAY_DEVICEA * pdd, LPSTR pDrvName)
{
    HKEY hKey;

    lstrcat( pdd->DeviceKey, "\\DEFAULT" );
    if( ERROR_SUCCESS == RegOpenKeyEx( 
                            HKEY_LOCAL_MACHINE,
                            pdd->DeviceKey,
                            0,
                            KEY_QUERY_VALUE ,
                            &hKey ) )
    {
        DWORD dwSize = MAX_DDDEVICEID_STRING;
        DWORD dwType = 0;

        RegQueryValueEx( hKey,
                         TEXT("drv"),
                         NULL,
                         &dwType,
                         pDrvName,
                         &dwSize );

        RegCloseKey(hKey);
    }
}

#else //win95

/*
 * following are all the NT-specific version functions
 */
void GetFileVersionData(
    LPDDDRIVERINFOEX pDI)
{
    //Failure means 0 returned
    pDI->di.liDriverVersion.HighPart = 0;
    pDI->di.liDriverVersion.LowPart = 0;
}

void GetHALName(
    LPDDRAWI_DIRECTDRAW_GBL pdrv,
    LPDDDRIVERINFOEX pDI)
{
    pDI->di.szDriver[0] = 0;
}

BOOL CheckPowerVR(LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDDRIVERINFOEX pdi)
{
    return FALSE;
}

HRESULT Check3Dfx(LPDDDRIVERINFOEX pDI)
{
    return DDERR_GENERIC;
}

HRESULT GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, LPDDDRIVERINFOEX pDI)
{
    return DDERR_GENERIC;
}

/*
 * Given a DISPLAY_DEVICE, get driver name, assuming winnt5
 * NOTE::: THIS FUNCTION NUKES THE DISPLAY_DEVICE.DeviceKey STRING!!!!
 */
void GetNTDriverNameAndVersion(DISPLAY_DEVICEA * pdd, LPDDDRIVERINFOEX pDI)
{
    HKEY hKey;

    //
    //  old style to determine display driver...returns name of miniport!
    //

    char * pTemp;

    // The device key has the form blah\blah\services\<devicekey>\DeviceN
    // So we back up one node:
    if ( (pTemp = FindLast(pdd->DeviceKey,'\\')) )
    {
        char * pTempX;
        char cOld=*pTemp;
        *pTemp = 0;

        //If we back up one node, we'll have the registry key under which the driver is stored. Let's use that!
        if ( (pTempX = FindLast(pdd->DeviceKey,'\\')) )
        {
            lstrcpyn(pDI->di.szDriver, pTemp+1, sizeof(pDI->di.szDriver));
            //ATTENTION No point getting version data without a filname:
            //We need a new service or something to get the used display driver name
            //GetFileVersionData(pDI);
        }

        *pTemp=cOld;
    }

    //
    //  we can find the display driver in a registry key
    //
    //  note: InstalledDisplayDrivers can contain several entries
    //  to display drivers Since there is no way to find out which
    //  one is the active one, we always return the first as being
    //  the display driver!
    //
    if( ERROR_SUCCESS == RegOpenKeyEx( 
                         HKEY_LOCAL_MACHINE,
				         pdd->DeviceKey+18,
                         0,
                         KEY_QUERY_VALUE ,
				         &hKey ) )
    {
        DWORD dwSize=sizeof(pDI->di.szDriver), dwType=0;
        if( ERROR_SUCCESS == RegQueryValueEx( hKey,
					          TEXT("InstalledDisplayDrivers"),
					          NULL,
					          &dwType,
					          pDI->di.szDriver,
					          &dwSize ) )
        {   
            lstrcat(pDI->di.szDriver, TEXT(".dll"));
        }

        RegCloseKey(hKey);
    }
}
#endif //win95



void GenerateIdentifier(LPDDDRIVERINFOEX pDI)
{
    LPDWORD pdw;

    CopyMemory(&pDI->di.guidDeviceIdentifier, &CLSID_DirectDraw, sizeof(pDI->di.guidDeviceIdentifier));

    //The device IDs get XORed into the whole GUID with the vendor and device ID in the 
    //first two DWORDs so they don't get XORed with anything else. This makes it 
    DDASSERT(sizeof(GUID) >= 4*sizeof(DWORD));
    pdw = (LPDWORD) &pDI->di.guidDeviceIdentifier;
    pdw[0] ^= pDI->di.dwVendorId;
    pdw[1] ^= pDI->di.dwDeviceId;
    pdw[2] ^= pDI->di.dwSubSysId;
    pdw[3] ^= pDI->di.dwRevision;

    // The driver version gets XORed into the last two DWORDs of the GUID:
    pdw[2] ^= pDI->di.liDriverVersion.LowPart;
    pdw[3] ^= pDI->di.liDriverVersion.HighPart;
}


void ParseDeviceId(LPDDDRIVERINFOEX pDI)
{
    char * p;

    DPF(5,"Parsing %s",pDI->szDeviceID);

    pDI->di.dwVendorId = 0;
    pDI->di.dwDeviceId = 0;
    pDI->di.dwSubSysId = 0;
    pDI->di.dwRevision = 0;

    if(p =_strstr(pDI->szDeviceID, "VEN_"))
        pDI->di.dwVendorId = _atoi( p + 4);

    if(p = _strstr(pDI->szDeviceID, "DEV_"))
        pDI->di.dwDeviceId = _atoi( p + 4);

    if(p = _strstr(pDI->szDeviceID, "SUBSYS_"))
        pDI->di.dwSubSysId = _atoi( p + 7);

    if(p = _strstr(pDI->szDeviceID, "REV_"))
        pDI->di.dwRevision = _atoi( p + 4);
}


HRESULT DDAPI DD_GetDeviceIdentifier( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER pDI, DWORD dwFlags)
{
    DDDEVICEIDENTIFIER2         ddi2;
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    HRESULT                     hr;

    ZeroMemory(&ddi2, sizeof(ddi2));

    hr = DD_GetDeviceIdentifier7(lpDD, &ddi2, dwFlags);

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( VALID_DIRECTDRAW_PTR( this_int ) )
        {
            if (VALIDEX_DDDEVICEIDENTIFIER_PTR( pDI ))
            {
                CopyMemory(pDI,&ddi2,sizeof(*pDI));
            }
            else
            {
	        DPF_ERR( "Invalid version struct passed" );
	        hr = DDERR_INVALIDPARAMS;
            }
        }
        else
	{
	    DPF_ERR( "Invalid driver object passed" );
	    hr = DDERR_INVALIDOBJECT;
	}
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("Exception encountered querying device info");
        hr = DDERR_INVALIDPARAMS;
    }


    return hr;
}

HRESULT InternalGetDeviceIdentifier7( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER2 pDI, DWORD dwFlags, BOOL bWHQL)
{
    HRESULT                     hr=DD_OK;
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    int                         n;
    DISPLAY_DEVICEA             dd;
    DDDRIVERINFOEX              di;
    BOOL                        bFound;
#ifndef WINNT
    static char                 szWin9xName[MAX_DDDEVICEID_STRING];
#endif

    ENTER_DDRAW();

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( VALID_DIRECTDRAW_PTR( this_int ) )
        {
	    this_lcl = this_int->lpLcl;
	    pdrv = this_lcl->lpGbl;

            if (VALIDEX_DDDEVICEIDENTIFIER2_PTR( pDI ))
            {
                /*
                 * Reset to something sensible
                 */
                ZeroMemory(&di,sizeof(di));
                #ifndef WINNT
                    szWin9xName[0] = '\0';
                #endif

                if (0 == (dwFlags & ~DDGDI_VALID) )
                {
                    /*
                     * First step: version info and name for the ddraw HAL driver (on 9x), and format it into a string
                     */
                    GetHALName(pdrv, &di);
                    GetFileVersionData(&di);

                    /* 
                     * If it's a 3dfx, it's easy
                     */
                    if ( 0 == (pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
                    {
                        hr = Check3Dfx(&di);
                    }
                    else
                    {
                        /*
                         * Not a 3dfx.
                         */

                        /*
                         * Next step: Figure out which display device we really are and get description string for it
                         */
                        ZeroMemory(&dd, sizeof(dd));
                        dd.cb = sizeof(dd);

                        bFound=FALSE;

                        for( n=0; xxxEnumDisplayDevicesA( NULL, n, &dd, 0 ); n++ )
                        {
                            char * pDeviceName = pdrv->cDriverName;
            
                            //DDraw has this convention that the primary device is always DISPLAY. 

                            if (0 == _stricmp(dd.DeviceName, pdrv->cDriverName ) || 
                                ((dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) &&
                                 (0 == _stricmp(pdrv->cDriverName , "DISPLAY")) ) )
                            {
                                /*
                                 * Found the device. Now we can get some data for it.
                                 */
                                lstrcpyn(di.di.szDescription, dd.DeviceString, sizeof(di.di.szDescription));
                                lstrcpyn(di.szDeviceID, dd.DeviceID, sizeof(di.szDeviceID) );

                                bFound = TRUE;

#ifdef WINNT
                                GetNTDriverNameAndVersion(&dd,&di);
#else

                                GetWin9XDriverName(&dd, szWin9xName);
                                if( di.di.szDriver[0] == '\0' )
                                {
                                    lstrcpyn( di.di.szDriver, szWin9xName, sizeof(di.di.szDriver) );
                                }
#endif

                                break;
                            }

                            ZeroMemory(&dd, sizeof(dd));
                            dd.cb = sizeof(dd);
                        }

                        /*
                         * Final step: Go get the pnp id of the chipset
                         */
                        if (!bFound)
                        {
                            /*
                             * Didn't find it: xxxEnumDisplayDevices failed, i.e. we're on 9x or NT4,
                             */
                            if (FAILED(GetDriverInfoFromRegistry("Display", NULL, NULL, &di)))
		            {
			        DPF_ERR("Couldn't get registry data for display");
                                hr = DDERR_NOTFOUND;
		            }
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        ParseDeviceId(&di);

                        /*
                         * Finally, for the primary only, check if a PowerVR is in and functioning
                         */
                        if (0 == (dwFlags & DDGDI_GETHOSTIDENTIFIER) )
                        {
                            if (IsVGADevice(pdrv->cDriverName) && CheckPowerVR(pdrv, &di))
                            {
                                ParseDeviceId(&di);
                            }
                        }

                        /*
                         * Munge driver version and ID into the identifier GUID.
                         */
                        GenerateIdentifier(&di);
                    }

                }
                else
                {
	            DPF_ERR( "Invalid flags passed" );
	            hr = DDERR_INVALIDPARAMS;
                }

                /*
                 * Finally copy the struct, or 0s if failed, to the app's buffer
                 */
                CopyMemory(pDI,&di.di,offsetof(DDDEVICEIDENTIFIER2,dwWHQLLevel) + sizeof(DWORD));

                /*
                 * Our compiler packs structs to 8 byte boundaries, but this struct is only 4 byte aligned.
                 * In short, sizeof(*pDI) == 1072, but the actual size is 1068, so we cannot copy the 
                 * buffer using sizeof, so we instead do the above wackiness.  We need to assert, however,
                 * so we can fix this if this structure ever grows.
                 */
                DDASSERT((sizeof(*pDI) - (offsetof(DDDEVICEIDENTIFIER2,dwWHQLLevel) + sizeof(DWORD))) <= 4);

                if (bWHQL)
                {
                    #ifdef WINNT
                        pDI->dwWHQLLevel=GetWHQLLevel((LPTSTR)&di.di.szDriver, NULL);
                    #else
                        pDI->dwWHQLLevel=GetWHQLLevel((LPTSTR)&di.di.szDriver, szWin9xName);
                    #endif
                }
                else
                {
                    pDI->dwWHQLLevel = 0;
                }

                /*
                 * lets find out here if driver is WHQL certified
                 */

            }
            else
            {
	        DPF_ERR( "Invalid version struct passed" );
	        hr = DDERR_INVALIDPARAMS;
            }
        }
        else
	{
	    DPF_ERR( "Invalid driver object passed" );
	    hr = DDERR_INVALIDOBJECT;
	}
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("Exception encountered querying device info");
        hr = DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return hr;
}


HRESULT DDAPI DD_GetDeviceIdentifier7( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER2 pDI, DWORD dwFlags)
{
    return InternalGetDeviceIdentifier7 (lpDD, pDI, dwFlags, TRUE);
}


/*
 * Voodoo1GoodToGo
 *
 * The Voodoo 1 driver will succeed the CreateDC call on Voodoo 2, Voodoo 3,
 * or Banshee hardware, but if we use the driver beyond that it will hang
 * the hardware.  This is a work around to not enumerate a Voodoo 1
 * driver if the hardware isn't there.
 *
 * To our knowledge, only two guids were ever used to enumerate Voodoo1
 * hardware, so we will look for those guids and assume that anything else
 * doesn't need to be checked.
 */
BOOL Voodoo1GoodToGo( GUID * pGuid )
{
    DDDRIVERINFOEX DI;

    if (IsEqualIID(pGuid, &guidVoodoo1A) || IsEqualIID(pGuid, &guidVoodoo1B) )
    {
        #ifdef WIN95
            /*
             * Now search the hardware enum key to see if Voodoo 1 hardware exists
             */
            if (FAILED(_GetDriverInfoFromRegistry(NULL, "Display", VEN_3DFXVOODOO1, &DI)))
            {
                return FALSE;
            }
        #else
            return FALSE;
        #endif
    }
    return TRUE;
}

#ifndef WINNT
/****************************************************************************
 *
 *  FileIsSignedOld
 *
 *  find win95 style of signature
 *
 ****************************************************************************/
BOOL FileIsSignedOld(LPTSTR lpszFile)
{
typedef struct tagIMAGE_DOS_HEADER      // DOS .EXE header
{
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER, FAR* LPIMAGE_DOS_HEADER;

typedef struct tagIMAGE_OS2_HEADER      // OS/2 .EXE header
{
    WORD   ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    WORD   ne_enttab;                   // Offset of Entry Table
    WORD   ne_cbenttab;                 // Number of bytes in Entry Table
    LONG   ne_crc;                      // Checksum of whole file
    WORD   ne_flags;                    // Flag word
    WORD   ne_autodata;                 // Automatic data segment number
    WORD   ne_heap;                     // Initial heap allocation
    WORD   ne_stack;                    // Initial stack allocation
    LONG   ne_csip;                     // Initial CS:IP setting
    LONG   ne_sssp;                     // Initial SS:SP setting
    WORD   ne_cseg;                     // Count of file segments
    WORD   ne_cmod;                     // Entries in Module Reference Table
    WORD   ne_cbnrestab;                // Size of non-resident name table
    WORD   ne_segtab;                   // Offset of Segment Table
    WORD   ne_rsrctab;                  // Offset of Resource Table
    WORD   ne_restab;                   // Offset of resident name table
    WORD   ne_modtab;                   // Offset of Module Reference Table
    WORD   ne_imptab;                   // Offset of Imported Names Table
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table
    WORD   ne_cmovent;                  // Count of movable entries
    WORD   ne_align;                    // Segment alignment shift count
    WORD   ne_cres;                     // Count of resource segments
    BYTE   ne_exetyp;                   // Target Operating system
    BYTE   ne_flagsothers;              // Other .EXE flags
    WORD   ne_pretthunks;               // offset to return thunks
    WORD   ne_psegrefbytes;             // offset to segment ref. bytes
    WORD   ne_swaparea;                 // Minimum code swap area size
    WORD   ne_expver;                   // Expected Windows version number
} IMAGE_OS2_HEADER, * PIMAGE_OS2_HEADER, FAR* LPIMAGE_OS2_HEADER;

typedef struct tagWINSTUB
{
    IMAGE_DOS_HEADER idh;
    BYTE             rgb[14];
} WINSTUB, * PWINSTUB, FAR* LPWINSTUB;

typedef struct tagFILEINFO
{
    BYTE   cbInfo[0x120];
} FILEINFO, * PFILEINFO, FAR* LPFILEINFO;


    FILEINFO           fi;
    int                nRC;
    LPIMAGE_DOS_HEADER lpmz;
    LPIMAGE_OS2_HEADER lpne;
    BYTE               cbInfo[9+32+2];
    BOOL               IsSigned = FALSE;
    OFSTRUCT           OpenStruct;
    HFILE              hFile;

    static WINSTUB winstub = {
        {
            IMAGE_DOS_SIGNATURE,            /* magic */
            0,                              /* bytes on last page - varies */
            0,                              /* pages in file - varies */
            0,                              /* relocations */
            4,                              /* paragraphs in header */
            1,                              /* min allocation */
            0xFFFF,                         /* max allocation */
            0,                              /* initial SS */
            0xB8,                           /* initial SP */
            0,                              /* checksum (ha!) */
            0,                              /* initial IP */
            0,                              /* initial CS */
            0x40,                           /* lfarlc */
            0,                              /* overlay number */
            { 0, 0, 0, 0},                 /* reserved */
           0,                              /* oem id */
            0,                              /* oem info */
            0,                              /* compiler bug */
            { 0},                          /* reserved */
            0x80,                           /* lfanew */
        },
        {
            0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
            0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21,
        }
    };

    OpenStruct.cBytes = sizeof( OpenStruct );
    lstrcpyn( OpenStruct.szPathName, lpszFile, OFS_MAXPATHNAME );
    hFile = OpenFile(lpszFile, &OpenStruct, OF_READ);
    if (hFile == HFILE_ERROR )
    {
        return FALSE;
    }

    nRC = 0;
    ReadFile( (HANDLE) hFile, (LPVOID)&fi, sizeof(FILEINFO), &nRC, NULL);
    if (nRC != sizeof(FILEINFO))
    {
        goto FileIsSigned_exit;
    }

    lpmz = (LPIMAGE_DOS_HEADER)(&fi);
    lpne = (LPIMAGE_OS2_HEADER)((WORD)&fi + 0x80);

    winstub.idh.e_cblp = lpmz->e_cblp;
    winstub.idh.e_cp   = lpmz->e_cp;

    if (memcmp(&fi, &winstub, sizeof(winstub)) == 0)
    {
        goto FileIsSigned_exit;
    }

    memcpy(cbInfo, &((PWINSTUB)(&fi)->cbInfo)->rgb[14], sizeof(cbInfo));

    if ( (cbInfo[4]      != ' ' ) ||    // space
         (cbInfo[8]      != ' ' ) ||    // space
         (cbInfo[9+32]   != '\n') ||    // return
         (cbInfo[9+32+1] != '$' ) )     // Dollar Sign
    {
        goto FileIsSigned_exit;
    }

    cbInfo[4] = 0;
    cbInfo[8] = 0;

    if ( (strcmp((const char*)&cbInfo[0], "Cert") != 0) ||
         (strcmp((const char*)&cbInfo[5], "DX2")  != 0) )
    {
        goto FileIsSigned_exit;
    }

    IsSigned=TRUE;

    FileIsSigned_exit:

    _lclose( hFile );

    return IsSigned;
}
#endif


/*
 * GetWHQLLevel - On Win95, look for old stamp only.  On Win2000, use digital
 *		signature only.  On Win98, look for old stamp first, then digital signature
 *		if no old stamp.
 *
 *      return 0 -- unsigned or uncertified
 *      return 1 -- driver certified
 *      return 1997 -- driver certified, PC97 compliant...
 *      return 1998...
 *
 *
 * arguments:
 *      
 * lpszDriver----Path of driver file
 * 
 */

DWORD GetWHQLLevel(LPTSTR lpszDriver, LPSTR lpszWin9xDriver)
{
    TCHAR szTmp[MAX_PATH];
    DWORD dwWhqlLevel = 0;

    // here we should rather call 
    if (GetSystemDirectory( szTmp, MAX_PATH-lstrlen(lpszDriver)-2)==0)
        return 0;

    lstrcat( szTmp, TEXT("\\"));
    lstrcat( szTmp, lpszDriver); 
    _tcslwr( szTmp);

    //
    // Look for a digital signature
    //
    dwWhqlLevel = IsFileDigitallySigned(szTmp);
    if( dwWhqlLevel != 0 )
    {
        return dwWhqlLevel;
    }


#ifndef WINNT 
    
    // It wasn't digitally signed, but it may still have been signed
    // the old way.  On Win9X, however, lpszDriver actually contains the
    // 32 bit HAL name rather than the display driver, but we typically only
    // signed the display driver, so we should use lpszWin9xDriver.

    if( lpszWin9xDriver[0] != '\0' )
    {
        GetSystemDirectory( szTmp, MAX_PATH-lstrlen(lpszWin9xDriver)-2);
        lstrcat( szTmp, TEXT("\\"));
        lstrcat( szTmp, lpszWin9xDriver); 
    }
    else
    {
        GetSystemDirectory( szTmp, MAX_PATH-lstrlen(lpszDriver)-2);
        lstrcat( szTmp, TEXT("\\"));
        lstrcat( szTmp, lpszDriver); 
    }

    if (FileIsSignedOld(szTmp))
    {
        return 1;
    }
#endif

    return 0;
}


DWORD IsFileDigitallySigned(LPTSTR lpszDriver)
{
    DWORD  dwWHQLLevel=0;         // default, driver not certified
    CATAPI catapi;
    WCHAR *lpFileName;
    DRIVER_VER_INFO VerInfo;
    TCHAR szBuffer[50];
    LPSTR lpAttr;
#ifndef UNICODE
    WCHAR wszDriver[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, lpszDriver, -1, wszDriver, MAX_PATH);
    lpFileName = wcsrchr(wszDriver, TEXT('\\'));
    if (lpFileName==NULL)
    {
        lpFileName = wszDriver;
    }
    else
    {
        lpFileName++;
    }
#else
    lpFileName = _tcsrchr(lpszDriver, TEXT('\\'));
    if (lpFileName==NULL) lpFileName = lpszDriver;
#endif


    //
    //  try to load and initialize the mscat32.dll and wintrust.dll
    //  these dlls are not available on win95
    //
    if (InitCATAPI(&catapi))
    {
        HANDLE hFile;
        DWORD  cbHashSize=0;
        BYTE  *pbHash;
        BOOL   bResult;

        //
        //  create a handle to our driver, because cat api wants handle to file
        //
        hFile = CreateFile( lpszDriver,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            0
                            );

        if (hFile!=INVALID_HANDLE_VALUE) 
        {
            // first query hash size...
            bResult=(*catapi.pCryptCATAdminCalcHashFromFileHandle)(hFile,
                                &cbHashSize,
                                NULL,
                                0);
            pbHash=NULL;
            if (bResult)
            {
                // allocate hash
                pbHash = LocalAlloc( LPTR, cbHashSize);                                       
            } 

            if (pbHash!=NULL)
            {
                HCATINFO hPrevCat=NULL;
                HANDLE hCatalog=NULL;
                WINTRUST_DATA WinTrustData;
                WINTRUST_CATALOG_INFO WinTrustCatalogInfo;
                GUID  guidSubSystemDriver = DRIVER_ACTION_VERIFY;
                CRYPTCATATTRIBUTE *lpCat = NULL;

                //
                //  Now get the hash for our file
                //

                bResult=(*catapi.pCryptCATAdminCalcHashFromFileHandle)(hFile,
                                    &cbHashSize,
                                    pbHash,
                                    0);

                if (bResult)
                {
                    hCatalog=(*catapi.pCryptCATAdminEnumCatalogFromHash)(
                                    catapi.hCatAdmin,
                                    pbHash,
                                    cbHashSize,
                                    0,
                                    &hPrevCat);
                }

                //
                // Initialize the structures that
                // will be used later on in calls to WinVerifyTrust.
                //
                ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
                WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
                WinTrustData.dwUIChoice = WTD_UI_NONE;
                WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
                WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
                WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
                WinTrustData.pPolicyCallbackData = (LPVOID)&VerInfo;

                ZeroMemory(&VerInfo, sizeof(DRIVER_VER_INFO));
                VerInfo.cbStruct = sizeof(DRIVER_VER_INFO);

                WinTrustData.pCatalog = &WinTrustCatalogInfo;
        
                ZeroMemory(&WinTrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
                WinTrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
                WinTrustCatalogInfo.pbCalculatedFileHash = pbHash;
                WinTrustCatalogInfo.cbCalculatedFileHash = cbHashSize;
                WinTrustCatalogInfo.pcwszMemberTag = lpFileName;

                while (hCatalog)
                {
                    CATALOG_INFO CatInfo;

                    ZeroMemory(&CatInfo, sizeof(CATALOG_INFO));
                    CatInfo.cbStruct = sizeof(CATALOG_INFO);
                    if((*catapi.pCryptCATCatalogInfoFromContext)(hCatalog, &CatInfo, 0)) 
                    {
                        HRESULT hRes;

                        WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

                        // Now verify that the file is an actual member of the catalog.
                        hRes = (*catapi.pWinVerifyTrust)
                            (NULL, &guidSubSystemDriver, &WinTrustData);

                        if (hRes == ERROR_SUCCESS)
                        {
                            //
                            // Our driver is certified!  Now see if the cat
                            // info contains the WHQL level
                            //
                            CRYPTCATATTRIBUTE *lpCat = NULL;
                            HANDLE hCat;

                            dwWHQLLevel=1;              // return "certified"

                            hCat =  (*catapi.pCryptCATOpen)(CatInfo.wszCatalogFile, (DWORD)CRYPTCAT_OPEN_EXISTING, (HCRYPTPROV)NULL, 0, 0);
                            lpCat = (*catapi.pCryptCATGetCatAttrInfo) (hCat, L"KV_DISPLAY");
                            if( lpCat != NULL )
                            {
                                WideCharToMultiByte(CP_ACP, 0, (PUSHORT)lpCat->pbValue, -1, szBuffer, 50, NULL, NULL);

                                // The value looks like "1:yyyy-mm-dd".
          
                                lpAttr = _strstr( szBuffer, ":");
                                lpAttr++;
                                lpAttr[4] = '\0';
                                dwWHQLLevel = atoi( lpAttr ) * 0x10000;
                                lpAttr[7] = '\0';
                                dwWHQLLevel |= atoi( &lpAttr[5]) * 0x100;
                                dwWHQLLevel |= atoi( &lpAttr[8]);
                            }

                            (*catapi.pCryptCATClose)(hCat);
                            break;
                        }
                    }

                    //
                    // iterate through catalogs...
                    //
                    hPrevCat=hCatalog;
                    hCatalog=(*catapi.pCryptCATAdminEnumCatalogFromHash)(
                                catapi.hCatAdmin,
                                pbHash,
                                cbHashSize,
                                0,
                                &hPrevCat);
                }

                //
                // we might have to free a catalog context!
                //
                if (hCatalog)
                {
                    (*catapi.pCryptCATAdminReleaseCatalogContext)
                        (catapi.hCatAdmin, hCatalog, 0);
                }

                //
                //  free hash
                //
                LocalFree(pbHash);

            }

            CloseHandle(hFile);
        }
    }

    ReleaseCATAPI(&catapi);

    return dwWHQLLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\dvpp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dvp.h
 *  Content:	DirectDrawVideoPort include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   11-jun-96	scottm	initial implementation
 *   29-jan-97	smac	Various API changes
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DVP_INCLUDED__
#define __DVP_INCLUDED__

/*
 * GUIDS used by DirectDrawVideoPort objects
 */
#if defined( _WIN32 ) && (!defined( _NO_COM ) || defined( DEFINE_GUID ))
DEFINE_GUID( IID_IDDVideoPortContainer,		0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawVideoPort,		0xB36D93E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDrawVideoPortNotify,    0xA655FB94,0x0589,0x4E57,0xB3,0x33,0x56,0x7A,0x89,0x46,0x8C,0x88);



DEFINE_GUID( DDVPTYPE_E_HREFH_VREFH, 0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFH_VREFL, 0x92783220L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFH, 0xA07A02E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFL, 0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_CCIR656,	     0xFCA326A0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_BROOKTREE,     0x1352A560L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_PHILIPS,	     0x332CF160L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
#endif

#ifndef GUID_DEFS_ONLY

#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#endif

/*
 * These definitions are required to allow polymorphic structure members (i.e. those
 * that are referred to both as DWORDs and as pointers) to resolve into a type
 * of correct size to hold the largest of those two types (i.e. pointer) on 64 bit
 * systems. For 32 bit environments, ULONG_PTR resolves to a DWORD.
 */
#ifndef MAXULONG_PTR
#define ULONG_PTR    DWORD
#endif //MAXULONG_PTR

#ifdef __cplusplus
extern "C" {
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
struct IDirectDrawSurfaceComposition;
#endif
#ifdef STREAMING
struct IDirectDrawSurfaceStreaming;
#endif
//@@END_MSINTERNAL
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoPortContainer            FAR *LPDDVIDEOPORTCONTAINER;
typedef struct IDirectDrawVideoPort             FAR *LPDIRECTDRAWVIDEOPORT;
typedef struct IDirectDrawVideoPortNotify       FAR *LPDIRECTDRAWVIDEOPORTNOTIFY;

typedef struct _DDVIDEOPORTCONNECT              FAR *LPDDVIDEOPORTCONNECT;
typedef struct _DDVIDEOPORTCAPS                 FAR *LPDDVIDEOPORTCAPS;
typedef struct _DDVIDEOPORTDESC                 FAR *LPDDVIDEOPORTDESC;
typedef struct _DDVIDEOPORTINFO                 FAR *LPDDVIDEOPORTINFO;
typedef struct _DDVIDEOPORTBANDWIDTH            FAR *LPDDVIDEOPORTBANDWIDTH;
typedef struct _DDVIDEOPORTSTATUS               FAR *LPDDVIDEOPORTSTATUS;
typedef struct _DDVIDEOPORTNOTIFY               FAR *LPDDVIDEOPORTNOTIFY;

typedef struct IDDVideoPortContainerVtbl        DDVIDEOPORTCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoPortVtbl         DIRECTDRAWVIDEOPORTCALLBACKS;
typedef struct IDirectDrawVideoPortNotifyVtbl   DIRECTDRAWVIDEOPORTNOTIFYCALLBACKS;


/*
 * API's
 */
typedef HRESULT (FAR PASCAL * LPDDENUMVIDEOCALLBACK)(LPDDVIDEOPORTCAPS, LPVOID);


/*
 * INTERACES FOLLOW:
 *	IDirectDrawVideoPort
 *	IVideoPort
 */

/*
 * IDirectDrawVideoPortContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoPortContainer
DECLARE_INTERFACE_( IDDVideoPortContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawVideoPort methods ***/
    STDMETHOD(CreateVideoPort)(THIS_ DWORD, LPDDVIDEOPORTDESC, LPDIRECTDRAWVIDEOPORT FAR *, IUnknown FAR *) PURE;
    STDMETHOD(EnumVideoPorts)(THIS_ DWORD, LPDDVIDEOPORTCAPS, LPVOID,LPDDENUMVIDEOCALLBACK ) PURE;
    STDMETHOD(GetVideoPortConnectInfo)(THIS_ DWORD, LPDWORD, LPDDVIDEOPORTCONNECT ) PURE;
    STDMETHOD(QueryVideoPortStatus)(THIS_ DWORD, LPDDVIDEOPORTSTATUS ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IVideoPortContainer_Release(p)                      (p)->lpVtbl->Release(p)
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->lpVtbl->CreateVideoPort(p, a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->lpVtbl->EnumVideoPorts(p, a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->lpVtbl->GetVideoPortConnectInfo(p, a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->lpVtbl->QueryVideoPortStatus(p, a, b)
#else
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->AddRef()
#define IVideoPortContainer_Release(p)                      (p)->Release()
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->CreateVideoPort(a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->EnumVideoPorts(a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->GetVideoPortConnectInfo(a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->QueryVideoPortStatus(a, b)
#endif

#endif


/*
 * IDirectDrawVideoPort
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoPort
DECLARE_INTERFACE_( IDirectDrawVideoPort, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IVideoPort methods ***/
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetBandwidthInfo)(THIS_ LPDDPIXELFORMAT, DWORD, DWORD, DWORD, LPDDVIDEOPORTBANDWIDTH) PURE;
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(GetInputFormats)(THIS_ LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetOutputFormats)(THIS_ LPDDPIXELFORMAT, LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetFieldPolarity)(THIS_ LPBOOL) PURE;
    STDMETHOD(GetVideoLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVideoSignalStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetTargetSurface)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(StartVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(StopVideo)(THIS) PURE;
    STDMETHOD(UpdateVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(WaitForSync)(THIS_ DWORD, DWORD, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPort_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoPort_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IVideoPort_Release(p)                   (p)->lpVtbl->Release(p)
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->lpVtbl->SetTargetSurface(p,a,b)
#define IVideoPort_Flip(p,a,b)			(p)->lpVtbl->Flip(p,a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->lpVtbl->GetBandwidthInfo(p,a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->lpVtbl->GetColorControls(p,a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->lpVtbl->GetInputFormats(p,a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->lpVtbl->GetOutputFormats(p,a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->lpVtbl->GetFieldPolarity(p,a)
#define IVideoPort_GetVideoLine(p,a)		(p)->lpVtbl->GetVideoLine(p,a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->lpVtbl->GetVideoSignalStatus(p,a)
#define IVideoPort_SetColorControls(p,a)	(p)->lpVtbl->SetColorControls(p,a)
#define IVideoPort_StartVideo(p,a)		(p)->lpVtbl->StartVideo(p,a)
#define IVideoPort_StopVideo(p)			(p)->lpVtbl->StopVideo(p)
#define IVideoPort_UpdateVideo(p,a)		(p)->lpVtbl->UpdateVideo(p,a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->lpVtbl->WaitForSync(p,a,b,c)
#else
#define IVideoPort_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IVideoPort_AddRef(p)                    (p)->AddRef()
#define IVideoPort_Release(p)                   (p)->Release()
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->SetTargetSurface(a,b)
#define IVideoPort_Flip(p,a,b)			(p)->Flip(a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->GetBandwidthInfo(a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->GetColorControls(a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->GetInputFormats(a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->GetOutputFormats(a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->GetFieldPolarity(a)
#define IVideoPort_GetVideoLine(p,a)		(p)->GetVideoLine(a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->GetVideoSignalStatus(a)
#define IVideoPort_SetColorControls(p,a)	(p)->SetColorControls(a)
#define IVideoPort_StartVideo(p,a)		(p)->StartVideo(a)
#define IVideoPort_StopVideo(p)			(p)->StopVideo()
#define IVideoPort_UpdateVideo(p,a)		(p)->UpdateVideo(a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->WaitForSync(a,b,c)
#endif

#endif

/*
 * IDirectDrawVideoPort
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoPortNotify
DECLARE_INTERFACE_( IDirectDrawVideoPortNotify, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IVideoPort methods ***/
    STDMETHOD(AcquireNotification)(THIS_ HANDLE *, LPDDVIDEOPORTNOTIFY) PURE;
    STDMETHOD(ReleaseNotification)(THIS_ HANDLE) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPortNotify_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoPortNotify_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoPortNotify_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoPortNotify_AcquireNotification(p,a,b) (p)->lpVtbl->AcquireNotification(p,a,b)
#define IVideoPortNotify_ReleaseNotification(p,a)   (p)->lpVtbl->ReleaseNotification(p,a)
#else
#define IVideoPortNotify_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoPortNotify_AddRef(p)                  (p)->AddRef()
#define IVideoPortNotify_Release(p)                 (p)->Release()
#define IVideoPortNotify_AcquireNotification(p,a,b) (p)->lpVtbl->AcquireNotification(a,b)
#define IVideoPortNotify_ReleaseNotification(p,a)   (p)->lpVtbl->ReleaseNotification(a)
#endif

#endif

/*
 * DDVIDEOPORTCONNECT
 */
typedef struct _DDVIDEOPORTCONNECT
{
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    ULONG_PTR dwReserved1;      // Reserved, set to zero.
} DDVIDEOPORTCONNECT;


/*
 * DDVIDEOPORTCAPS
 */
typedef struct _DDVIDEOPORTCAPS
{
    DWORD dwSize;			// size of the DDVIDEOPORTCAPS structure
    DWORD dwFlags;			// indicates which fields contain data
    DWORD dwMaxWidth;			// max width of the video port field
    DWORD dwMaxVBIWidth;		// max width of the VBI data
    DWORD dwMaxHeight; 			// max height of the video port field
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwCaps;			// Video port capabilities
    DWORD dwFX;				// More video port capabilities
    DWORD dwNumAutoFlipSurfaces;	// Max number of autoflippable surfaces allowed
    DWORD dwAlignVideoPortBoundary;	// Byte restriction of placement within the surface
    DWORD dwAlignVideoPortPrescaleWidth;// Byte restriction of width after prescaling
    DWORD dwAlignVideoPortCropBoundary;	// Byte restriction of left cropping
    DWORD dwAlignVideoPortCropWidth;	// Byte restriction of cropping width
    DWORD dwPreshrinkXStep;		// Width can be shrunk in steps of 1/x
    DWORD dwPreshrinkYStep;		// Height can be shrunk in steps of 1/x
    DWORD dwNumVBIAutoFlipSurfaces;	// Max number of VBI autoflippable surfaces allowed
    DWORD dwNumPreferredAutoflip;	// Optimal number of autoflippable surfaces for hardware
    WORD  wNumFilterTapsX;              // Number of taps the prescaler uses in the X direction (0 - no prescale, 1 - replication, etc.)
    WORD  wNumFilterTapsY;              // Number of taps the prescaler uses in the Y direction (0 - no prescale, 1 - replication, etc.)
} DDVIDEOPORTCAPS;

/*
 * The dwMaxWidth and dwMaxVBIWidth members are valid
 */
#define DDVPD_WIDTH		0x00000001l

/*
 * The dwMaxHeight member is valid
 */
#define DDVPD_HEIGHT		0x00000002l

/*
 * The dwVideoPortID member is valid
 */
#define DDVPD_ID		0x00000004l

/*
 * The dwCaps member is valid
 */
#define DDVPD_CAPS		0x00000008l

/*
 * The dwFX member is valid
 */
#define DDVPD_FX		0x00000010l

/*
 * The dwNumAutoFlipSurfaces member is valid
 */
#define DDVPD_AUTOFLIP		0x00000020l

/*
 * All of the alignment members are valid
 */
#define DDVPD_ALIGN		0x00000040l

/*
 * The dwNumPreferredAutoflip member is valid
 */
#define DDVPD_PREFERREDAUTOFLIP 0x00000080l

/*
 * The wNumFilterTapsX and wNumFilterTapsY fields are valid
 */
#define DDVPD_FILTERQUALITY     0x00000100l

/*
 * DDVIDEOPORTDESC
 */
typedef struct _DDVIDEOPORTDESC
{
    DWORD dwSize;			// size of the DDVIDEOPORTDESC structure
    DWORD dwFieldWidth;			// width of the video port field
    DWORD dwVBIWidth;			// width of the VBI data
    DWORD dwFieldHeight;		// height of the video port field
    DWORD dwMicrosecondsPerField;	// Microseconds per video field
    DWORD dwMaxPixelsPerSecond;		// Maximum pixel rate per second
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwReserved1;			// Reserved for future use - set to zero (struct padding)
    DDVIDEOPORTCONNECT VideoPortType; 	// Description of video port connection
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved3;		// Reserved for future use - set to zero
} DDVIDEOPORTDESC;


/*
 * DDVIDEOPORTINFO
 */
typedef struct _DDVIDEOPORTINFO
{
    DWORD dwSize;			// Size of the structure
    DWORD dwOriginX;			// Placement of the video data within the surface.
    DWORD dwOriginY;			// Placement of the video data within the surface.
    DWORD dwVPFlags;			// Video port options
    RECT rCrop;				// Cropping rectangle (optional).
    DWORD dwPrescaleWidth;		// Determines pre-scaling/zooming in the X direction (optional).
    DWORD dwPrescaleHeight;		// Determines pre-scaling/zooming in the Y direction (optional).
    LPDDPIXELFORMAT lpddpfInputFormat;	// Video format written to the video port
    LPDDPIXELFORMAT lpddpfVBIInputFormat; // Input format of the VBI data
    LPDDPIXELFORMAT lpddpfVBIOutputFormat;// Output format of the data
    DWORD dwVBIHeight;			// Specifies the number of lines of data within the vertical blanking interval.
    ULONG_PTR dwReserved1;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTINFO;


/*
 * DDVIDEOPORTBANDWIDTH
 */
typedef struct _DDVIDEOPORTBANDWIDTH
{
    DWORD dwSize;			// Size of the structure
    DWORD dwCaps;
    DWORD dwOverlay;           		// Zoom factor at which overlay is supported
    DWORD dwColorkey;			// Zoom factor at which overlay w/ colorkey is supported
    DWORD dwYInterpolate;		// Zoom factor at which overlay w/ Y interpolation is supported
    DWORD dwYInterpAndColorkey;		// Zoom factor at which ovelray w/ Y interpolation and colorkeying is supported
    ULONG_PTR dwReserved1;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTBANDWIDTH;


/*
 * DDVIDEOPORTSTATUS
 */
typedef struct _DDVIDEOPORTSTATUS
{
    DWORD dwSize;			// Size of the structure
    BOOL  bInUse;			// TRUE if video port is currently being used
    DWORD dwFlags;           		// Currently not used
    DWORD dwReserved1;			// Reserved for future use
    DDVIDEOPORTCONNECT VideoPortType;	// Information about the connection
    ULONG_PTR dwReserved2;		// Reserved for future use
    ULONG_PTR dwReserved3;		// Reserved for future use
} DDVIDEOPORTSTATUS;

/*
 * DDVIDEOPORTNOTIFY
 */
typedef struct _DDVIDEOPORTNOTIFY
{
    LARGE_INTEGER ApproximateTimeStamp;	// Timestamp in the event notification
    LONG lField;                        // 0 if even, 1 if odd, -1 if unknown
    UINT dwSurfaceIndex;                // Index in the surface chain of the surface that received the sample
    LONG lDone;                         // Call InterlockedIncrement on this when done with sample
} DDVIDEOPORTNOTIFY;


/*============================================================================
 *
 * Video Port Flags
 *
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTCONNECT FLAGS
 *
 ****************************************************************************/

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of double clocking the data.
 * When this is set by the client, this indicates that the video port
 * should enable double clocking.  This flag is only valid with external
 * syncs.
 */
#define DDVPCONNECT_DOUBLECLOCK			0x00000001l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of using an external VACT
 * signal. When this is set by the client, this indicates that the
 * video port should use the external VACT signal.
 */
#define DDVPCONNECT_VACT			0x00000002l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of treating even fields
 * like odd fields and visa versa.  When this is set by the client,
 * this indicates that the video port should treat even fields like odd
 * fields.
 */
#define DDVPCONNECT_INVERTPOLARITY		0x00000004l

/*
 * Indicates that any data written to the video port during the VREF
 * period will not be written into the frame buffer. This flag is read only.
 */
#define DDVPCONNECT_DISCARDSVREFDATA		0x00000008l

/*
 * When this is set be the driver and passed to the client, this
 * indicates that the device will write half lines into the frame buffer
 * if half lines are provided by the decoder.  If this is set by the client,
 * this indicates that the decoder will be supplying half lines.
 */
#define DDVPCONNECT_HALFLINE			0x00000010l

/*
 * Indicates that the signal is interlaced. This flag is only
 * set by the client.
 */
#define DDVPCONNECT_INTERLACED			0x00000020l

/*
 * Indicates that video port is shareable and that this video port
 * will use the even fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREEVEN			0x00000040l

/*
 * Indicates that video port is shareable and that this video port
 * will use the odd fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREODD			0x00000080l

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC CAPS
 *
 ****************************************************************************/

/*
 * Flip can be performed automatically to avoid tearing.
 */
#define DDVPCAPS_AUTOFLIP			0x00000001l

/*
 * Supports interlaced video
 */
#define DDVPCAPS_INTERLACED			0x00000002l

/*
 * Supports non-interlaced video
 */
#define DDVPCAPS_NONINTERLACED			0x00000004l

/*
 * Indicates that the device can return whether the current field
 * of an interlaced signal is even or odd.
 */
#define DDVPCAPS_READBACKFIELD			0x00000008l

/*
 * Indicates that the device can return the current line of video
 * being written into the frame buffer.
 */
#define DDVPCAPS_READBACKLINE			0x00000010l

/*
 * Allows two gen-locked video streams to share a single video port,
 * where one stream uses the even fields and the other uses the odd
 * fields. Separate parameters (including address, scaling,
 * cropping, etc.) are maintained for both fields.)
 */
#define DDVPCAPS_SHAREABLE			0x00000020l

/*
 * Even fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPEVENFIELDS			0x00000040l

/*
 * Odd fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPODDFIELDS			0x00000080l

/*
 * Indicates that the device is capable of driving the graphics
 * VSYNC with the video port VSYNC.
 */
#define DDVPCAPS_SYNCMASTER			0x00000100l

/*
 * Indicates that data within the vertical blanking interval can
 * be written to a different surface.
 */
#define DDVPCAPS_VBISURFACE			0x00000200l

/*
 * Indicates that the video port can perform color operations
 * on the incoming data before it is written to the frame buffer.
 */
#define DDVPCAPS_COLORCONTROL			0x00000400l

/*
 * Indicates that the video port can accept VBI data in a different
 * width or format than the regular video data.
 */
#define DDVPCAPS_OVERSAMPLEDVBI			0x00000800l

/*
 * Indicates that the video port can write data directly to system memory
 */
#define DDVPCAPS_SYSTEMMEMORY			0x00001000l

/*
 * Indicates that the VBI and video portions of the video stream can
 * be controlled by an independent processes.
 */
#define DDVPCAPS_VBIANDVIDEOINDEPENDENT		0x00002000l

/*
 * Indicates that the video port contains high quality hardware
 * de-interlacing hardware that should be used instead of the
 * bob/weave algorithms.
 */
#define DDVPCAPS_HARDWAREDEINTERLACE		0x00004000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC FX
 *
 ****************************************************************************/

/*
 * Limited cropping is available to crop out the vertical interval data.
 */
#define DDVPFX_CROPTOPDATA			0x00000001l

/*
 * Incoming data can be cropped in the X direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPX				0x00000002l

/*
 * Incoming data can be cropped in the Y direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPY				0x00000004l

/*
 * Supports interleaving interlaced fields in memory.
 */
#define DDVPFX_INTERLEAVE			0x00000008l

/*
 * Supports mirroring left to right as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORLEFTRIGHT			0x00000010l

/*
 * Supports mirroring top to bottom as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORUPDOWN			0x00000020l

/*
 * Data can be arbitrarily shrunk in the X direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKX			0x00000040l

/*
 * Data can be arbitrarily shrunk in the Y direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKY			0x00000080l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the X
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXB			0x00000100l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the Y
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYB			0x00000200l

/*
 * Data can be shrunk in increments of 1/x in the X direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkXStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXS			0x00000400l

/*
 * Data can be shrunk in increments of 1/x in the Y direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkYStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYS			0x00000800l

/*
 * Data can be arbitrarily stretched in the X direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHX			0x00001000l

/*
 * Data can be arbitrarily stretched in the Y direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHY			0x00002000l

/*
 * Data can be integer stretched in the X direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHXN			0x00004000l

/*
 * Data can be integer stretched in the Y direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHYN			0x00008000l

/*
 * Indicates that data within the vertical blanking interval can
 * be converted independently of the remaining video data.
 */
#define DDVPFX_VBICONVERT			0x00010000l

/*
 * Indicates that scaling can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOSCALE			0x00020000l

/*
 * Indicates that the video data can ignore the left and right
 * cropping coordinates when cropping oversampled VBI data.
 */
#define DDVPFX_IGNOREVBIXCROP			0x00040000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOINTERLEAVE			0x00080000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTINFO FLAGS
 *
 ****************************************************************************/

/*
 * Perform automatic flipping.   Auto-flipping is performed between
 * the overlay surface that was attached to the video port using
 * IDirectDrawVideoPort::AttachSurface and the overlay surfaces that
 * are attached to the surface via the IDirectDrawSurface::AttachSurface
 * method.  The flip order is the order in which the overlay surfaces
 * were. attached.
 */
#define DDVP_AUTOFLIP				0x00000001l

/*
 * Perform conversion using the ddpfOutputFormat information.
 */
#define DDVP_CONVERT				0x00000002l

/*
 * Perform cropping using the specified rectangle.
 */
#define DDVP_CROP				0x00000004l

/*
 * Indicates that interlaced fields should be interleaved in memory.
 */
#define DDVP_INTERLEAVE				0x00000008l

/*
 * Indicates that the data should be mirrored left to right as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORLEFTRIGHT			0x00000010l

/*
 * Indicates that the data should be mirrored top to bottom as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORUPDOWN			0x00000020l

/*
 * Perform pre-scaling/zooming based on the pre-scale parameters.
 */
#define DDVP_PRESCALE				0x00000040l

/*
 * Ignore input of even fields.
 */
#define DDVP_SKIPEVENFIELDS			0x00000080l

/*
 * Ignore input of odd fields.
 */
#define DDVP_SKIPODDFIELDS			0x00000100l

/*
 * Drive the graphics VSYNCs using the video port VYSNCs.
 */
#define DDVP_SYNCMASTER				0x00000200l

/*
 * The ddpfVBIOutputFormatFormat member contains data that should be used
 * to convert the data within the vertical blanking interval.
 */
#define DDVP_VBICONVERT				0x00000400l

/*
 * Indicates that data within the vertical blanking interval
 * should not be scaled.
 */
#define DDVP_VBINOSCALE				0x00000800l

/*
 * Indicates that these bob/weave decisions should not be
 * overriden by other interfaces.
 */
#define DDVP_OVERRIDEBOBWEAVE			0x00001000l

/*
 * Indicates that the video data should ignore the left and right
 * cropping coordinates when cropping the VBI data.
 */
#define DDVP_IGNOREVBIXCROP			0x00002000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVP_VBINOINTERLEAVE			0x00004000l

/*
 * Indicates that the video port should use the hardware
 * de-interlacing hardware.
 */
#define DDVP_HARDWAREDEINTERLACE		0x00008000l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETINPUTFORMAT/GETOUTPUTFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * Return formats for the video data
 */
#define DDVPFORMAT_VIDEO			0x00000001l

/*
 * Return formats for the VBI data
 */
#define DDVPFORMAT_VBI				0x00000002l
//@@BEGIN_MSINTERNAL

/*
 * Internal flag to disable the VBI/video-only check
 */
#define DDVPFORMAT_NOFAIL			0x08000000l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT SETTARGETSURFACE FLAGS
 *
 ****************************************************************************/

/*
 * Surface should receive video data (and VBI data if a surface
 * is not explicitly attached for that purpose)
 */
#define DDVPTARGET_VIDEO			0x00000001l

/*
 * Surface should receive VBI data
 */
#define DDVPTARGET_VBI				0x00000002l


/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT WAITFORSYNC FLAGS
 *
 ****************************************************************************/

/*
 * Waits until the beginning of the next VSYNC
 */
#define DDVPWAIT_BEGIN				0x00000001l

/*
 * Waits until the end of the next/current VSYNC
 */
#define DDVPWAIT_END				0x00000002l

/*
 * Waits until the beginning of the specified line
 */
#define DDVPWAIT_LINE				0x00000003l

/****************************************************************************
 *
 * DIRECTDRAWVIDEOPORT FLIP FLAGS
 *
 ****************************************************************************/

/*
 * Flips the normal video surface
 */
#define DDVPFLIP_VIDEO				0x00000001l

/*
 * Flips the VBI surface
 */
#define DDVPFLIP_VBI				0x00000002l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETVIDEOSIGNALSTATUS VALUES
 *
 ****************************************************************************/

/*
 * No video signal is present at the video port
 */
#define DDVPSQ_NOSIGNAL				0x00000001l

/*
 * A valid video signal is present at the video port
 */
#define DDVPSQ_SIGNALOK				0x00000002l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Flags
 *
 ****************************************************************************/

/*
 * The specified height/width refer to the size of the video port data
 * written into memory, after prescaling has occured.
 */
#define DDVPB_VIDEOPORT				0x00000001l

/*
 * The specified height/width refer to the source size of the overlay.
 */
#define DDVPB_OVERLAY				0x00000002l

/*
 * This is a query for the device to return which caps this device requires.
 */
#define DDVPB_TYPE				0x00000004l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Caps
 *
 ****************************************************************************/

/*
 * The bandwidth for this device is dependant on the overlay source size.
 */
#define DDVPBCAPS_SOURCE			0x00000001l

/*
 * The bandwidth for this device is dependant on the overlay destination
 * size.
 */
#define DDVPBCAPS_DESTINATION			0x00000002l

/****************************************************************************
 *
 * DDVIDEOPORTCONTAINER CreateVideoPort flags
 *
 ****************************************************************************/

/*
 * The process only wants to control the VBI portion of the video stream.
 */
#define DDVPCREATE_VBIONLY			0x00000001l

/*
 * The process only wants to control the non-VBI (video) portion of
 * the video stream.
 */
#define DDVPCREATE_VIDEOONLY			0x00000002l
//@@BEGIN_MSINTERNAL

/*
 * Internal flag indicating interface is for the IDirectDrawVidoePortNotify object
 */
#define DDVPCREATE_NOTIFY			0x80000000l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DDVIDEOPORTSTATUS flags
 *
 ****************************************************************************/

/*
 * The video port interface is only controlling the VBI portion of the
 * video stream
 */
#define DDVPSTATUS_VBIONLY			0x00000001l

/*
 * The video port interface is only controlling the video portion of the
 * video stream
 */
#define DDVPSTATUS_VIDEOONLY			0x00000002l


#ifdef __cplusplus
};
#endif

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\init.cpp ===
#define INITGUID

#define this _this
#include "ddrawpr.h"
#undef this
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\dx8priv.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dx8priv.h
 *  Content:    Private header file for all changes that are truly
 *              private to Dx8.
 *
 ***************************************************************************/

#include "d3d8typesp.h"
#include "d3d8ddi.h"

#ifdef WIN95
    extern ULONG giDisplaySettingsUniqueness;
#endif

#ifdef IS_32

extern HRESULT InternalDirectDrawCreate( GUID * lpGUID, LPDIRECTDRAW *lplpDD, LPDDRAWI_DIRECTDRAW_INT pnew_int, DWORD dwFlags, char* pDeviceName );

extern HRESULT InternalCreateSurface( LPDDRAWI_DIRECTDRAW_LCL thisg, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *lplpDDSurface, LPDDRAWI_DIRECTDRAW_INT this_int, LPDDSURFACEINFO pSysMemInfo, DWORD DX8Flags );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\mmdd.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mmdd.H
 *  Content:	DDRAW.DLL initialization for MMOSA/Native platforms
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   15-may-95  scottle created it
 *
 ***************************************************************************/
#ifdef MMOSA
#pragma message("Including MMDD.H")
#include <mmosa.h>
#include <mmhal.h>
#include <drivers.h>
BOOL MMOSA_Driver_Attach(void);
BOOL MMOSA_Driver_Detach(void);
int MMOSA_DDHal_Escape( HDC  hdc, int  nEscape, int  cbInput, LPCTSTR  lpszInData, int  cbOutput, LPTSTR  lpszOutData);

extern BOOL bGraphicsInit;
extern PIFILE pDisplay;

// Function Replacements
#define lstrncmpi(a,b) StrCmp(a,b)
#define lstrcmpi(a,b)  StrCmp(a,b)
#define strcpy(a,b)	   StrCpy(a,b)
#define ExtEscape(hdc, ccmd, szcmd, pcmd, szdata, pdata) MMOSA_DDHal_Escape(hdc, ccmd, szcmd, pcmd, szdata, pdata)

// Important typedefs not supported in Win32e
#define QUERYESCSUPPORT 8

#define MMOSA_DISPLAY_DRIVER_NAME TEXT("display")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\sources.inc ===
TARGETNAME = main
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = \
    $(INCLUDES);          \
    ..\..\ddhelp;         \
    ..\..\ddhel;          \
    $(DXROOT)\dxg\inc

USE_ATL=1

C_DEFINES = $(C_DEFINES) /DNEW_DPF /DDIRECT3D_VERSION=0x0800

SOURCES = \
    ..\_dpf.c       \
    ..\_memallo.c   \
    ..\apphack.c    \
    ..\classfac.c   \
    ..\cliprgn.c    \
    ..\ddcallbk.c   \
    ..\ddclip.c     \
    ..\ddcolor.c    \
    ..\ddcreate.c   \
    ..\ddcsurf.c    \
    ..\dddefwp.c    \
    ..\ddesurf.c    \
    ..\ddfake.c     \
    ..\ddgamma.c    \
    ..\ddiunk.c     \
    ..\ddpal.c      \
    ..\ddraw.c      \
    ..\ddsacc.c     \
    ..\ddsatch.c    \
    ..\ddsblt.c     \
    ..\ddsckey.c    \
    ..\ddsiunk.c    \
    ..\ddsover.c    \
    ..\ddsurf.c     \
    ..\ddvp.c       \
    ..\ddmc.c       \
    ..\dllmain.c    \
    ..\drvinfo.c    \
    ..\misc.c       \
    ..\ddkernel.c   \
    ..\ddrestor.c   \
    ..\private.c    \
    ..\init.cpp     \
    ..\ddrefrsh.c

#    ..\alphablt.c   \
#    ..\ddstream.cpp \
#    ..\factory.c    \
#    ..\ddsprite.c   \
#    ..\ddoptsur.c   \
#    ..\decoder.cpp  \
#    ..\ddagpnt.c    \

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\ddrawpr.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\factory.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	factory.c
 *  Content:	DirectDrawFactory implementation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-oct-97	jeffno  initial implementation
 *
 ***************************************************************************/

#include "ddrawpr.h"

HRESULT InternalCreateDDFactory2(void ** ppvObj, IUnknown * pUnkOuter)
{
    LPDDFACTORY2 lpFac = NULL;

    DDASSERT(ppvObj);

    if (pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    /*
     * If any allocations are added to this function, make sure to update the
     * cleanup code in classfac.c
     */
    lpFac = MemAlloc(sizeof(DDFACTORY2));

    if (!lpFac)
    {
        return DDERR_OUTOFMEMORY;
    }

    lpFac->lpVtbl = &ddFactory2Callbacks;
    lpFac->dwRefCnt = 0;

    *ppvObj = (IUnknown*) lpFac;

    return DD_OK;
}


/*
 * DDFac2_QueryInterface
 */
HRESULT DDAPI DDFac2_QueryInterface(
		LPDIRECTDRAWFACTORY2 lpDDFac,
		REFIID riid,
		LPVOID FAR * ppvObj )
{
    LPDDFACTORY2   this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDFac2_QueryInterface");

    /*
     * validate parms
     */
    TRY
    {
	this = (LPDDFACTORY2) lpDDFac;
	if( !VALID_DIRECTDRAWFACTORY2_PTR( this ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF( 1, "Invalid clipper pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
	}
	if( !VALIDEX_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
	}
	*ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * check guids
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
	IsEqualIID(riid, &IID_IDirectDrawFactory2) )
    {
        ((IUnknown*)this)->lpVtbl->AddRef((IUnknown*)this);
	*ppvObj = (LPVOID) this;
	LEAVE_DDRAW();
	return DD_OK;
    }
    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DDFac2_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "DDFactory2::AddRef"

/*
 * DDFac2_AddRef
 */
DWORD DDAPI DDFac2_AddRef( LPDIRECTDRAWFACTORY2 lpDDFac )
{
    LPDDFACTORY2   this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDFac2_AddRef");

    /*
     * validate parms
     */
    TRY
    {
	this = (LPDDFACTORY2) lpDDFac;
	if( !VALID_DIRECTDRAWFACTORY2_PTR( this ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * update reference count
     */
    this->dwRefCnt++;

    DPF( 5, "DDFactory %08lx addrefed, refcnt = %ld", this, this->dwRefCnt );

    LEAVE_DDRAW();
    return this->dwRefCnt;

} /* DDFac2_AddRef */

#undef DPF_MODNAME
#define DPF_MODNAME "DDFactory2::Release"

ULONG DDAPI DDFac2_Release( LPDIRECTDRAWFACTORY2 lpDDFac )
{
    LPDDFACTORY2   this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDFac2_Release");

    /*
     * validate parms
     */
    TRY
    {
	this = (LPDDFACTORY2) lpDDFac;
	if( !VALID_DIRECTDRAWFACTORY2_PTR( this ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * update reference count
     */
    this->dwRefCnt--;

    DPF( 5, "DDFactory %08lx releaseed, refcnt = %ld", this, this->dwRefCnt );

    if (this->dwRefCnt == 0)
    {
        this->lpVtbl = 0;
        MemFree(this);
        LEAVE_DDRAW();
        return 0;
    }                 

    LEAVE_DDRAW();
    return this->dwRefCnt;

} /* DDFac2_Release */


HRESULT DDAPI DDFac2_CreateDirectDraw(
        LPDIRECTDRAWFACTORY2 lpDDFac, 
        GUID FAR*rDeviceGuid, 
        HWND hWnd, 
        DWORD dwCoopLevelFlags, 
        DWORD dwFlags, 
        IUnknown FAR *pUnkOuter, 
        IDirectDraw4 FAR **ppDDraw)
{
    LPDIRECTDRAW lpDD;

    HRESULT hr = DirectDrawCreate( rDeviceGuid, &lpDD, pUnkOuter );

    lpDDFac;

    DPF(2,A,"ENTERAPI: DDFac2_CreateDirectDraw");

    if( SUCCEEDED(hr) )
    {
	hr = lpDD->lpVtbl->QueryInterface(lpDD,&IID_IDirectDraw4,(void**) ppDDraw);
        lpDD->lpVtbl->Release(lpDD);

        if( SUCCEEDED(hr) )
        {
    	    hr = (*ppDDraw)->lpVtbl->SetCooperativeLevel(*ppDDraw, hWnd, dwCoopLevelFlags);
        }
    }
    return hr;
} /* DDFac2_CreateDirectDraw */

HRESULT DDAPI DDFac2_DirectDrawEnumerate(LPDIRECTDRAWFACTORY2 lpDDFac, LPDDENUMCALLBACKEX lpCallback, LPVOID lpContext , DWORD dwFlags)
{
    DPF(2,A,"ENTERAPI: DDFac2_DirectDrawEnumerate");

    return DirectDrawEnumerateExA(lpCallback, lpContext, dwFlags);
} /* DDFac2_DirectDrawEnumerate */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\private.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       private.c
 *  Content:	DirectDraw Private Client Data support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  10/08/97    jeffno  Initial Implementation
 *  24/11/97    t-craigs Added support for palettes, flags, et al
 *
 ***************************************************************************/
#include "ddrawpr.h"

void FreePrivateDataNode(LPPRIVATEDATANODE pData)
{
    /*
     * Check to see whether we should release the
     * memory our data pointer might be pointing to.
     */
    if (pData->dwFlags & DDSPD_IUNKNOWNPOINTER)
    {
        IUnknown *pUnk = (IUnknown *) pData->pData;
        /*
         * Better try-except, or Gershon will get on my back
         */
        TRY
        {
            pUnk->lpVtbl->Release(pUnk);
        }
        EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
	    DPF_ERR( "Exception encountered releasing private IUnknown pointer" );
        }
    }
    else
    {
        MemFree(pData->pData);
    }
    MemFree(pData);
}

void FreeAllPrivateData(LPPRIVATEDATANODE * ppListHead)
{
    LPPRIVATEDATANODE pData = (*ppListHead);

    while(pData)
    {
        LPPRIVATEDATANODE pPrevious = pData;
        pData=pData->pNext;
        FreePrivateDataNode(pPrevious);
    }
    (*ppListHead) = NULL;
}

/*
 * Helpers called from API entry points
 */
HRESULT InternalFreePrivateData(LPPRIVATEDATANODE * ppListHead, REFGUID rGuid)
{
    LPPRIVATEDATANODE pData = * ppListHead;
    LPPRIVATEDATANODE pPrevious = NULL;

    while (pData)
    {
        if ( IsEqualGUID(&pData->guid, rGuid))
        {
            /*
             * Check to see whether we should release the
             * memory our data pointer might be pointing to.
             */
            if (pPrevious)
                pPrevious->pNext = pData->pNext;
            else
                *ppListHead = pData->pNext;

            FreePrivateDataNode(pData);

            return DD_OK;
        }
        pPrevious = pData;
        pData=pData->pNext;
    }

    return DDERR_NOTFOUND;
}

HRESULT InternalSetPrivateData(
		LPPRIVATEDATANODE       *ppListHead,
                REFGUID                 rGuid,
                LPVOID                  pData,
                DWORD                   cbData,
                DWORD                   dwFlags,
                DWORD                   dwContentsStamp)
{
    HRESULT                     hr = DD_OK;
    LPPRIVATEDATANODE           pDataNode = NULL;
    BOOL                        bPtr;

    if( 0UL == cbData )
    {
	DPF_ERR( "Zero is invalid size of private data");
	return DDERR_INVALIDPARAMS;
    }

    if( !VALID_IID_PTR( rGuid ) )
    {
	DPF_ERR( "GUID reference is invalid" );
	return DDERR_INVALIDPARAMS;
    }

    if( !VALID_PTR( pData, cbData ) )
    {
	DPF_ERR( "Private data pointer is invalid" );
	return DDERR_INVALIDPARAMS;
    }

    if( dwFlags & ~DDSPD_VALID )
    {
	DPF_ERR( "Invalid flags" );
	return DDERR_INVALIDPARAMS;
    }

    bPtr = dwFlags & DDSPD_IUNKNOWNPOINTER;
    
    /*
     * First check if GUID already exists, squish it if so.
     * Don't care about return value.
     */
    InternalFreePrivateData(ppListHead, rGuid);

    /*
     * Now we can add the guid and know it's unique
     */
    pDataNode = MemAlloc(sizeof(PRIVATEDATANODE));

    if (!pDataNode)
        return DDERR_OUTOFMEMORY;

    /*
     * If we have a "special" pointer, as indicated by one of the flags,
     * then we copy that pointer.
     * Otherwise we copy a certain number of bytes from
     * the location pointed to.
     */
    if (bPtr)
    {
        IUnknown * pUnk;

        if (sizeof(IUnknown*) != cbData)
        {
            MemFree(pDataNode);
            DPF_ERR("cbData must be set to sizeof(IUnknown *) when DDSPD_IUNKNOWNPOINTER is used");
            return DDERR_INVALIDPARAMS;
        }
        pDataNode->pData = pData;

        /*
         * Now addref the pointer. We'll release it again when the data are freed
         */
        pUnk = (IUnknown*) pData;

        TRY
        {
            pUnk->lpVtbl->AddRef(pUnk);
        }
        EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            MemFree(pDataNode);
	    DPF_ERR( "Exception encountered releasing private IUnknown pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    else
    {
        pDataNode->pData = MemAlloc(cbData);

        if (!pDataNode->pData)
        {
            MemFree(pDataNode);
            return DDERR_OUTOFMEMORY;
        }

        memcpy(pDataNode->pData,pData,cbData);
    }
    
    memcpy(&pDataNode->guid,rGuid,sizeof(*rGuid));
    pDataNode->cbData = cbData;
    pDataNode->dwFlags = dwFlags;
    pDataNode->dwContentsStamp = dwContentsStamp;

    /*
     * Insert the node at the head of the list
     */
    pDataNode->pNext = *ppListHead;
    *ppListHead = pDataNode;

    return DD_OK;
}

HRESULT InternalGetPrivateData(
		LPPRIVATEDATANODE       *ppListHead,
                REFGUID                 rGuid,
                LPVOID                  pData,
                LPDWORD                 pcbData,
                DWORD                   dwCurrentStamp)
{
    HRESULT                     hr = DD_OK; 
    LPPRIVATEDATANODE           pDataNode = *ppListHead;

    if( !VALID_PTR( pcbData, sizeof(DWORD) ) )
    {
	DPF_ERR( "Private data count pointer is invalid" );
	return DDERR_INVALIDPARAMS;
    }

    if( !VALID_IID_PTR( rGuid ) )
    {
        *pcbData = 0;
	DPF_ERR( "GUID reference is invalid" );
	return DDERR_INVALIDPARAMS;
    }

    if (*pcbData)
    {
	if( !VALID_PTR( pData, *pcbData ) )
	{
            *pcbData = 0;
	    DPF_ERR( "Private data pointer is invalid" );
	    return DDERR_INVALIDPARAMS;
        }
    }

    while (pDataNode)
    {
        if ( IsEqualGUID(&pDataNode->guid, rGuid))
        {
            /*
             * Check if possibly volatile contents are still valid.
             */
            if (pDataNode->dwFlags & DDSPD_VOLATILE)
            {
                if ((dwCurrentStamp == 0) || (pDataNode->dwContentsStamp != dwCurrentStamp))
                {
                    DPF_ERR("Private data is volatile and state has changed");
                    *pcbData = 0;
                    return DDERR_EXPIRED;
                }
            }

            if (*pcbData < pDataNode->cbData)
            {
                *pcbData = pDataNode->cbData;
                return DDERR_MOREDATA;
            }

            if (pDataNode->dwFlags & DDSPD_IUNKNOWNPOINTER)
            {
                memcpy(pData,&(pDataNode->pData),pDataNode->cbData);
            }
            else
            {
                memcpy(pData,pDataNode->pData,pDataNode->cbData);
            }
            *pcbData = pDataNode->cbData;
            return DD_OK;
        }
        pDataNode=pDataNode->pNext;
    }

    return DDERR_NOTFOUND;
}

/* 
 * API entry points
 */


/*
 * SetPrivateData - Surface
 */
HRESULT DDAPI DD_Surface_SetPrivateData(
		LPDIRECTDRAWSURFACE     lpDDSurface,
                REFGUID                 rGuid,
                LPVOID                  pData,
                DWORD                   cbData,
                DWORD                   dwFlags)
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    HRESULT                     hr = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetPrivateData");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface description passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

      	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );

        hr = InternalSetPrivateData(
            &this_lcl->lpSurfMore->pPrivateDataHead,
            rGuid,
            pData, 
            cbData, 
            dwFlags,
            GET_LPDDRAWSURFACE_GBL_MORE( this_lcl->lpGbl )->dwContentsStamp );

        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	LEAVE_DDRAW();
	DPF_ERR( "Exception encountered validating parameters" );
	return DDERR_INVALIDPARAMS;
    }

}


/*
 * GetPrivateData - Surface
 */
HRESULT DDAPI DD_Surface_GetPrivateData(
		LPDIRECTDRAWSURFACE     lpDDSurface,
                REFGUID                 rGuid,
                LPVOID                  pData,
                LPDWORD                 pcbData)
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetPrivateData");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
            *pcbData = 0;
	    DPF_ERR( "Invalid surface description passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );

        hr = InternalGetPrivateData(
            &this_lcl->lpSurfMore->pPrivateDataHead,
            rGuid,
            pData, 
            pcbData, 
            GET_LPDDRAWSURFACE_GBL_MORE( this_lcl->lpGbl )->dwContentsStamp );

        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}


/*
 * FreePrivateData - Surface
 */
HRESULT DDAPI DD_Surface_FreePrivateData(
		LPDIRECTDRAWSURFACE     lpDDSurface,
                REFGUID                 rGuid)
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_FreePrivateData");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface description passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );

	if( !VALID_IID_PTR( rGuid ) )
	{
	    DPF_ERR( "GUID reference is invalid" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        hr = InternalFreePrivateData( &this_lcl->lpSurfMore->pPrivateDataHead, rGuid);

        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}


/*
 * SetPrivateData - Palette
 */
HRESULT DDAPI DD_Palette_SetPrivateData(
		LPDIRECTDRAWPALETTE     lpDDPalette,
                REFGUID                 rGuid,
                LPVOID                  pData,
                DWORD                   cbData,
                DWORD                   dwFlags)
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    HRESULT                     hr = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_SetPrivateData");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
            DPF_ERR( "Invalid palette pointer passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

      	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );

        hr =  InternalSetPrivateData(
            &this_lcl->pPrivateDataHead,
            rGuid,
            pData, 
            cbData, 
            dwFlags, 
            this_lcl->lpGbl->dwContentsStamp );

        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	LEAVE_DDRAW();
	DPF_ERR( "Exception encountered validating parameters" );
	return DDERR_INVALIDPARAMS;
    }

}


/*
 * GetPrivateData - Palette
 */
HRESULT DDAPI DD_Palette_GetPrivateData(
		LPDIRECTDRAWPALETTE     lpDDPalette,
                REFGUID                 rGuid,
                LPVOID                  pData,
                LPDWORD                 pcbData)
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_GetPrivateData");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
            *pcbData = 0;
	    DPF_ERR( "Invalid palette pointer passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );

        hr = InternalGetPrivateData(
            &this_lcl->pPrivateDataHead, 
            rGuid,
            pData,
            pcbData,
            this_lcl->lpGbl->dwContentsStamp );

        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}


/*
 * FreePrivateData - Palette
 */
HRESULT DDAPI DD_Palette_FreePrivateData(
                LPDIRECTDRAWPALETTE     lpDDPalette,
                REFGUID                 rGuid)
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_FreePrivateData");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid palette pointer passed");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );

	if( !VALID_IID_PTR( rGuid ) )
	{
	    DPF_ERR( "GUID reference is invalid" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        hr = InternalFreePrivateData( & this_lcl->pPrivateDataHead, rGuid);

        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}

/*
 * GetUniquenessValue - Surface
 */
HRESULT EXTERN_DDAPI DD_Surface_GetUniquenessValue(
                LPDIRECTDRAWSURFACE lpDDSurface,
                LPDWORD lpValue )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetUniquenessValue");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface pointer passed");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
        this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );
	
        if (!VALID_PTR(lpValue, sizeof(LPVOID)))
        {
            DPF_ERR("lpValue may not be NULL");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        
        (*lpValue) = GET_LPDDRAWSURFACE_GBL_MORE( this_lcl->lpGbl )->dwContentsStamp;
        
        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}

/*
 * GetUniquenessValue - Palette
 */
HRESULT EXTERN_DDAPI DD_Palette_GetUniquenessValue(
                LPDIRECTDRAWPALETTE lpDDPalette,
                LPDWORD lpValue )
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_GetUniquenessValue");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid palette pointer passed");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
        this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );
	
        if (!VALID_PTR(lpValue, sizeof(LPVOID)))
        {
            DPF_ERR("lpValue may not be NULL");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        
        (*lpValue) = this_lcl->lpGbl->dwContentsStamp;
        
        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}

/*
 * ChangeUniquenessValue -  Surface
 */
HRESULT EXTERN_DDAPI DD_Surface_ChangeUniquenessValue(
                LPDIRECTDRAWSURFACE lpDDSurface )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_ChangeUniquenessValue");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface pointer passed");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
        this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );
	
        BUMP_SURFACE_STAMP(this_lcl->lpGbl);
        
        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}


/*
 * ChangeUniquenessValue -  Palette
 */
HRESULT EXTERN_DDAPI DD_Palette_ChangeUniquenessValue(
                LPDIRECTDRAWPALETTE lpDDPalette )
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_ChangeUniquenessValue");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid palette pointer passed");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
        this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );
	
        BUMP_PALETTE_STAMP(this_lcl->lpGbl);
        
        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\mmdd.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mmdd.c
 *  Content:	DDRAW.DLL initialization for MMOSA/Native platforms
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   15-may-95  scottle created it
 *
 ***************************************************************************/

#ifdef MMOSA
#include <ddrawpr.h>
#include "mmdd.h"

BOOL bGraphicsInit = FALSE;
PIFILE pDisplay = NULL;

///////////////////////////////////////////////////////////////////////
//
// MMOSA_Driver_Attach() - Called during DDraw.DLL load on
//		a MMOSA/Native platform.
//		Performs MMOSA/Native device driver specific initialization
//
///////////////////////////////////////////////////////////////////////
BOOL MMOSA_Driver_Attach(void)
{
	// During the DLL attach...
	PINAMESPACE pIName;
	PIUNKNOWN pUnk;
	SCODE Sc;
	
	// Create/Register/Bind the "display" namespace object to this process
	pIName = CurrentNameSpace();
	Sc = pIName->v->Bind( pIName, TEXT("display"), F_READ|F_WRITE, &pUnk);
	if (FAILED(Sc))
	{
		DPF(1, "Could not open display device (%x)\n", Sc);
		return FALSE;
	}
	
	// Get a pointer to the IFile driver interface object, we'll use it
	//	for our display device interface.
	Sc = pUnk->v->QueryInterface(pUnk,&IID_IFile,(void **)&pDisplay);
	pUnk->v->Release(pUnk);
	
	if (FAILED(Sc))
	{
	    DPF(2, "Bogus display device (%x)\n", Sc);
		return FALSE;
	}
	
 	bGraphicsInit = TRUE;
	return TRUE;
} // End MMOSA_Driver_Attach
	
///////////////////////////////////////////////////////////////////////
//
// MMOSA_Driver_Detach() - Called during DDraw.DLL unload on
//		a MMOSA/Native platform.
//		Performs MMOSA/Native device driver specific deinitialization
//
///////////////////////////////////////////////////////////////////////
BOOL MMOSA_Driver_Detach(void)
{
	///////////////////////
	// During the detach...
	///////////////////////
	// Shutdown the graphics 
	if (bGraphicsInit)
	{
	    (void) pDisplay->v->SetSize( pDisplay, (UINT64) 3);
	    pDisplay->v->Release(pDisplay);
		pDisplay = NULL;
		bGraphicsInit = FALSE;
	}
	return TRUE;
} // End MMOSA_Driver_Attach


int MMOSA_DDHal_Escape( HDC  hdc, int  nEscape, int  cbInput, LPCTSTR  lpszInData, int  cbOutput, LPTSTR  lpszOutData)
{
	return 0;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\misc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	misc.c
 *  Content:	DirectDraw misc. routines
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   13-mar-95	craige	initial implementation
 *   19-mar-95	craige	use HRESULTs, added DeleteFromActiveProcessList
 *   23-mar-95	craige	added DeleteFromFlippableList
 *   29-mar-95	craige	DeleteFromActiveProcessList return codes
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	split out process list stuff
 *   13-jun-95	kylej	moved in FindAttachedFlip, added CanBeFlippable
 *   16-jun-95	craige	new surface structure
 *   26-jun-95	craige	reorganized surface structure
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consistency with Direct3D
 *   07-dec-95  colinmc support for mip-maps (flippable mip-maps can get
 *                      pretty complex)
 *   08-jan-96	kylej	added interface structures
 *   17-mar-96  colinmc Bug 13124: flippable mip-maps.
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   08-dec-96  colinmc Initial AGP support
 *   24-mar-97  jeffno  Optimized Surfaces
 *   07-may-97  colinmc Move AGP detection stuff to ddagp.c
 *
 ***************************************************************************/
#include "ddrawpr.h"

#define DIRECTXVXDNAME "\\\\.\\DDRAW.VXD"

#if 0
/*
 * DeleteFromFlippableList
 */
BOOL DeleteFromFlippableList(
		LPDDRAWI_DIRECTDRAW pdrv,
		LPDDRAWI_DDRAWSURFACE_GBL psurf )
{
    LPDDRAWI_DDRAWSURFACE_GBL	curr;
    LPDDRAWI_DDRAWSURFACE_GBL	last;

    curr = pdrv->dsFlipList;
    if( curr == NULL )
    {
	return FALSE;
    }
    last = NULL;
    while( curr != psurf )
    {
	last = curr;
	curr = curr->lpFlipLink;
	if( curr == NULL )
	{
	    return FALSE;
	}
    }
    if( last == NULL )
    {
	pdrv->dsFlipList = pdrv->dsFlipList->lpFlipLink;
    }
    else
    {
	last->lpFlipLink = curr->lpFlipLink;
    }
    return TRUE;

} /* DeleteFromFlippableList */
#endif

#define DDSCAPS_FLIPPABLETYPES \
	    (DDSCAPS_OVERLAY | \
	     DDSCAPS_TEXTURE | \
	     DDSCAPS_ALPHA   | \
	     DDSCAPS_ZBUFFER)

/*
 * CanBeFlippable
 *
 * Check to see if these two surfaces can be part of a flippable chain
 */
BOOL CanBeFlippable( LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
		     LPDDRAWI_DDRAWSURFACE_LCL this_attach_lcl)
{
    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_FLIPPABLETYPES ) ==
	( this_attach_lcl->ddsCaps.dwCaps & DDSCAPS_FLIPPABLETYPES ) )
    {
        /*
         * Flipping chains of optimized mipmaps have DDSCAPS_MIPMAP on every
         * surface in the list (since each surface represents an entire mipmap
         * chain. So, if both surfaces are optimized mipmaps, then they can
         * be flipped
         */
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            /*
             * We are definitely dealing with an optimized surface, so we're safe to
             * make the decision any way we like without fear of regressing other
             * flipping behaviour
             */
            if ( (this_lcl->ddsCaps.dwCaps & (DDSCAPS_OPTIMIZED|DDSCAPS_MIPMAP)) ==
                (DDSCAPS_OPTIMIZED|DDSCAPS_MIPMAP) )
            {
                if ( (this_attach_lcl->ddsCaps.dwCaps & (DDSCAPS_OPTIMIZED|DDSCAPS_MIPMAP)) ==
                    (DDSCAPS_OPTIMIZED|DDSCAPS_MIPMAP) )
                {
                    return TRUE;
                }
            }
            DPF(1,"Optimized mip-maps not flippable");
            return FALSE;
        }
        /*
         * No longer enough to see if both surfaces are exactly the same
         * type of flippable surface. A mip-map can have both a mip-map and
         * a non-mip-map texture attached both of which are marked as
         * flippable. A mip-map also flips with the non-mip-map texture (not
         * the other mip-map. Therefore, if both surfaces are textures we need
         * to check to also check that they are not both mip-maps before declaring
         * them flippable.
         */
        if( ( ( this_lcl->ddsCaps.dwCaps & this_attach_lcl->ddsCaps.dwCaps ) &
              ( DDSCAPS_TEXTURE | DDSCAPS_MIPMAP ) ) == ( DDSCAPS_TEXTURE | DDSCAPS_MIPMAP ) )
            return FALSE;
        else
            return TRUE;
    }
    else
    {
        return FALSE;
    }
} /* CanBeFlippable */

/*
 * FindAttachedFlip
 *
 * find an attached flipping surface of the same type
 */
LPDDRAWI_DDRAWSURFACE_INT FindAttachedFlip(
		LPDDRAWI_DDRAWSURFACE_INT this_int )
{
    LPATTACHLIST		ptr;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;

    if( this_int == NULL)
    {
	return NULL;
    }
    this_lcl = this_int->lpLcl;
    for( ptr = this_lcl->lpAttachList; ptr != NULL; ptr = ptr->lpLink )
    {
	psurf_int = ptr->lpIAttached;
	psurf_lcl = psurf_int->lpLcl;
	if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP) &&
	    CanBeFlippable( this_lcl, psurf_lcl ) )
	{
	    return psurf_int;
	}
    }
    return NULL;

} /* FindAttachedFlip */

/*
 * FindAttachedSurfaceLeft
 *
 * find an attached left surface
 */
LPDDRAWI_DDRAWSURFACE_INT FindAttachedSurfaceLeft(
		LPDDRAWI_DDRAWSURFACE_INT this_int )
{
    LPATTACHLIST		ptr;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;

    if( this_int == NULL)
    {
	return NULL;
    }
    this_lcl = this_int->lpLcl;
    for( ptr = this_lcl->lpAttachList; ptr != NULL; ptr = ptr->lpLink )
    {
	psurf_int = ptr->lpIAttached;
	psurf_lcl = psurf_int->lpLcl;
    if (psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT)
	    return psurf_int;
    }
    return NULL;

} /* FindAttachedSurfaceLeft */


/*
 * FindAttachedMipMap
 *
 * find an attached mip-map surface
 */
LPDDRAWI_DDRAWSURFACE_INT FindAttachedMipMap(
		LPDDRAWI_DDRAWSURFACE_INT this_int )
{
    LPATTACHLIST		ptr;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;

    if( this_int == NULL)
	return NULL;
    this_lcl = this_int->lpLcl;
    for( ptr = this_lcl->lpAttachList; ptr != NULL; ptr = ptr->lpLink )
    {
	psurf_int = ptr->lpIAttached;
	psurf_lcl = psurf_int->lpLcl;
	if( psurf_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
	    return psurf_int;
    }
    return NULL;

} /* FindAttachedMipMap */

/*
 * FindParentMipMap
 *
 * find the parent mip-map level of the given level
 */
LPDDRAWI_DDRAWSURFACE_INT FindParentMipMap(
		LPDDRAWI_DDRAWSURFACE_INT this_int )
{
    LPATTACHLIST		ptr;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;

    if( this_int == NULL)
	return NULL;
    this_lcl = this_int->lpLcl;
    DDASSERT( this_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP );
    for( ptr = this_lcl->lpAttachListFrom; ptr != NULL; ptr = ptr->lpLink )
    {
	psurf_int = ptr->lpIAttached;
	psurf_lcl = psurf_int->lpLcl;
	if( psurf_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
	    return psurf_int;
    }
    return NULL;

} /* FindParentMipMap */

#ifdef WINNT

/*
 * IsDifferentPixelFormat
 *
 * determine if two pixel formats are the same or not
 *
 * (CMcC) 12/14/95 Really useful - so no longer static
 *
 * This is the WINNT copy, since the video memory management files
 * it normally resides in (ddheap.c) is no longer part of the 
 * user-mode ddraw.dll
 */
BOOL IsDifferentPixelFormat( LPDDPIXELFORMAT pdpf1, LPDDPIXELFORMAT pdpf2 )
{
    /*
     * same flags?
     */
    if( pdpf1->dwFlags != pdpf2->dwFlags )
    {
	VDPF(( 5, S, "Flags differ!" ));
	return TRUE;
    }

    /*
     * same bitcount for non-YUV surfaces?
     */
    if( !(pdpf1->dwFlags & (DDPF_YUV | DDPF_FOURCC)) )
    {
	if( pdpf1->dwRGBBitCount != pdpf2->dwRGBBitCount )
	{
	    VDPF(( 5, S, "RGB Bitcount differs!" ));
	    return TRUE;
	}
    }

    /*
     * same RGB properties?
     */
    if( pdpf1->dwFlags & DDPF_RGB )
    {
	if( pdpf1->dwRBitMask != pdpf2->dwRBitMask )
	{
	    VDPF(( 5, S, "RBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwGBitMask != pdpf2->dwGBitMask )
	{
	    VDPF(( 5, S, "GBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwBBitMask != pdpf2->dwBBitMask )
	{
	    VDPF(( 5, S, "BBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwRGBAlphaBitMask != pdpf2->dwRGBAlphaBitMask )
	{
	    VDPF(( 5, S, "RGBAlphaBitMask differs!" ));
	    return TRUE;
	}
    }

    /*
     * same YUV properties?
     */
    if( pdpf1->dwFlags & DDPF_YUV )
    {
	VDPF(( 5, S, "YUV???" ));
	if( pdpf1->dwFourCC != pdpf2->dwFourCC )
	{
	    return TRUE;
	}
	if( pdpf1->dwYUVBitCount != pdpf2->dwYUVBitCount )
	{
	    return TRUE;
	}
	if( pdpf1->dwYBitMask != pdpf2->dwYBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwUBitMask != pdpf2->dwUBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwVBitMask != pdpf2->dwVBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwYUVAlphaBitMask != pdpf2->dwYUVAlphaBitMask )
	{
	    return TRUE;
	}
    }

    /*
     * Possible to use FOURCCs w/o setting the DDPF_YUV flag
     * ScottM 7/11/96
     */
    else if( pdpf1->dwFlags & DDPF_FOURCC )
    {
	VDPF(( 5, S, "FOURCC???" ));
	if( pdpf1->dwFourCC != pdpf2->dwFourCC )
	{
	    return TRUE;
	}
    }

    /*
     *	If Interleaved Z then check Z bit masks are the same
     */
    if( pdpf1->dwFlags & DDPF_ZPIXELS )
    {
	VDPF(( 5, S, "ZPIXELS???" ));
	if( pdpf1->dwRGBZBitMask != pdpf2->dwRGBZBitMask )
	    return TRUE;
    }

    return FALSE;

} /* IsDifferentPixelFormat */

#endif //WINNT

/*
 * Get a handle for communicating with the DirectX VXD (DDRAW.VXD).
 */
#ifdef WIN95
    HANDLE GetDXVxdHandle( void )
    {
	HANDLE hvxd;

	hvxd = CreateFile( DIRECTXVXDNAME,
			   GENERIC_WRITE,
			   FILE_SHARE_WRITE,
			   NULL,
			   OPEN_EXISTING,
			   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
			   NULL);
	#ifdef DEBUG
	    if( INVALID_HANDLE_VALUE == hvxd )
		DPF_ERR( "Could not connect to the DirectX VXD" );
	#endif /* DEBUG */

	return hvxd;
    } /* GetDXVxdHandle */
#endif /* WIN95 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\getri.c ===
//========================================================================
//
// GetRegistryInfo.CPP
//
// DirectDraw/Direct3D driver information grabber
// (c) Copyright 1998 Microsoft Corp.
// Written by Michael Lyons (mlyons@microsoft.com)
//
// Registry access functions, for querying device stuff from the
// registry
//
// Function names that begin with an underscore are internal only!
//
//========================================================================


#include "ddrawpr.h"

//#include "GetDriverInfo.h"
//#include "GetDriverInfoInt.h"

//========================================================================
// local functions
//========================================================================
BOOL _FindDevice(int    iDevice, LPCSTR szDeviceClass, LPCSTR szDeviceClassNot, LPSTR szHardwareKey, BOOL bIgnoreProblems);
static BOOL _GetDeviceValue(LPCSTR szHardwareKey, LPCSTR szKey,	LPCSTR szValue,	BYTE* buf, DWORD cbbuf);
extern char *_strstr(char *s1, char *s2);

//========================================================================
//
// GetDeviceValue
//
// read	a value	from the HW	or SW of a PnP device
//
// in:
//	szHardwareKey	the hardware key
//	szKey			the sub-key
//	szValue			the value to query
//	cbbuf			the size of the output buffer
//
// out:
//	buf				the destination buffer
//	
// returns:
//	success status
//
//========================================================================
static BOOL _GetDeviceValue(LPCSTR szHardwareKey, LPCSTR szKey,	LPCSTR szValue,	BYTE* buf, DWORD cbbuf)
{
	HKEY	hkeyHW;
	HKEY	hkeySW;
	BOOL	f =	FALSE;
	DWORD	cb;
	char	szSoftwareKey[MAX_DDDEVICEID_STRING];

	//
	// open	the	HW key
	//
	if (RegOpenKey(HKEY_LOCAL_MACHINE, szHardwareKey, &hkeyHW) == ERROR_SUCCESS)
	{
		//
		// try to read the value from the HW key
		//
		*buf = 0;
		cb = cbbuf;
		if (RegQueryValueEx(hkeyHW,	szValue, NULL, NULL, buf, &cb) == ERROR_SUCCESS)
		{
			f =	TRUE;
		}
		else
		{
			//
			// now try the SW key
			//
			static char	szSW[] = "System\\CurrentControlSet\\Services\\Class\\";

			lstrcpy(szSoftwareKey, szSW);
			cb = sizeof(szSoftwareKey) - sizeof(szSW);
			RegQueryValueEx(hkeyHW,	"Driver", NULL,	NULL, (BYTE	*)&szSoftwareKey[sizeof(szSW) -	1],	&cb);

			if (szKey)
			{
				lstrcat(szSoftwareKey, "\\");
				lstrcat(szSoftwareKey, szKey);
			}

			if (RegOpenKey(HKEY_LOCAL_MACHINE, szSoftwareKey, &hkeySW) == ERROR_SUCCESS)
			{
				*buf = 0;
				cb = cbbuf;
				if (RegQueryValueEx(hkeySW,	szValue, NULL, NULL, buf, &cb) == ERROR_SUCCESS)
				{
					f =	TRUE;
				}

				RegCloseKey(hkeySW);
			}
		}

		RegCloseKey(hkeyHW);
	}

	return f;
}



//========================================================================
//
// FindDevice
//
// enum	the	started	PnP	devices	looking	for	a device of	a particular class
//
//	iDevice			what device	to return (0= first	device,	1=second et)
//	szDeviceClass	what class device (ie "Display") NULL will match all
//	szDeviceID		buffer to return the hardware ID (MAX_DDDEVICEID_STRING bytes)
//
// return TRUE if a	device was found.
//
// example:
//
//		for	(int i=0; FindDevice(i,	"Display", DeviceID); i++)
//		{
//		}
//
//========================================================================
BOOL _FindDevice(int iDevice, LPCSTR szDeviceClass, LPCSTR szDeviceClassNot, LPSTR szHardwareKey, BOOL bIgnoreProblems)
{
	HKEY	hkeyPnP;
	HKEY	hkey;
	DWORD	n;
	DWORD	cb;
	DWORD	dw;
	char	ach[MAX_DDDEVICEID_STRING];

	if (RegOpenKey(HKEY_DYN_DATA, "Config Manager\\Enum", &hkeyPnP)	!= ERROR_SUCCESS)
		return FALSE;

	for	(n=0; RegEnumKey(hkeyPnP, n, ach, sizeof(ach)) == 0; n++)
	{
		static char	szHW[] = "Enum\\";

		if (RegOpenKey(hkeyPnP,	ach, &hkey)	!= ERROR_SUCCESS)
			continue;

		lstrcpy(szHardwareKey, szHW);
		cb = MAX_DDDEVICEID_STRING -	sizeof(szHW);
		RegQueryValueEx(hkey, "HardwareKey", NULL, NULL, (BYTE*)szHardwareKey +	sizeof(szHW) - 1, &cb);

		dw = 0;
		cb = sizeof(dw);
		RegQueryValueEx(hkey, "Problem", NULL, NULL, (BYTE*)&dw, &cb);
		RegCloseKey(hkey);

		if ((!bIgnoreProblems) && (dw != 0))		// if this device has a	problem	skip it
			continue;

		if (szDeviceClass || szDeviceClassNot)
		{
			_GetDeviceValue(szHardwareKey, NULL,	"Class", (BYTE *)ach, sizeof(ach));

			if (szDeviceClass && lstrcmpi(szDeviceClass, ach) != 0)
				continue;

			if (szDeviceClassNot && lstrcmpi(szDeviceClassNot, ach) == 0)
				continue;
		}

		//
		// we found	a device, make sure	it is the one the caller wants
		//
		if (iDevice-- == 0)
		{
			RegCloseKey(hkeyPnP);
			return TRUE;
		}
	}

	RegCloseKey(hkeyPnP);
	return FALSE;
}


//========================================================================
//
// _GetDriverInfoFromRegistry
//
// This function goes through the registry and tries to fill in
// information about a driver given a class and maybe a vendor ID
//
// in:
//	szClass		the class name (i.e., "Display")
//	szVendor	the vendor name (i.e., "VEN_121A" for 3Dfx" or NULL
//				if any vendor of the class will do
//
// out:
//	pDI			pointer to a DDDRIVERINFOEX structure to be filled in
//
// returns:
//	success status
//
//========================================================================
HRESULT _GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, LPDDDRIVERINFOEX pDI)
{
	char szDevice[MAX_DDDEVICEID_STRING];
        int i;

	pDI->szDeviceID[0]=0;
	pDI->di.szDescription[0]=0;


	for (i=0 ; ; i++)
	{
		if (!_FindDevice(i, szClass, szClassNot, szDevice, FALSE))
			break;

		if ((szVendor == NULL) || (_strstr(szDevice, szVendor)))
		{
			//
			// skip the first 5 characters "Enum\"
			//
			strcpy(pDI->szDeviceID, &szDevice[5]);
			_GetDeviceValue((LPCSTR)szDevice, NULL,		"DeviceDesc",	(BYTE *)pDI->di.szDescription, sizeof(pDI->di.szDescription));
			//_GetDeviceValue((LPCSTR)szDevice, NULL,		"Mfg",			(BYTE *)pDI->szManufacturer, sizeof(pDI->szManufacturer));
			//_GetDeviceValue((LPCSTR)szDevice, "DEFAULT","drv",			(BYTE *)pDI->szGDIDriver, sizeof(pDI->szGDIDriver));

			return S_OK;
		}
	}

	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\_dpf.c ===
#include "ddrawpr.h"

#include "..\..\misc\dpf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\swddi.c ===
#include "ddrawpr.h"
#include "..\..\..\d3d8\inc\d3d8ddi.h"
#include "d3d8sddi.h"
#include "ddithunk.h"


HRESULT
SwDDICreateSurface( PD3D8_CREATESURFACEDATA pCreateSurface, DDSURFACEDESC2* pSurfDesc)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv =
        ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pSwDD->lpLcl;
    DDHAL_CREATESURFACEDATA CreateSurfaceData;
    PD3D8_SWCALLBACKS pCallbacks =
        (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;
    DWORD i;


    if( pCallbacks->CreateSurface )
    {
        memset(&CreateSurfaceData, 0, sizeof(CreateSurfaceData));
        CreateSurfaceData.lpDD = pDrv->lpGbl;
        CreateSurfaceData.lpDDSurfaceDesc = (DDSURFACEDESC*)pSurfDesc;
        CreateSurfaceData.lplpSList = NULL;
        CreateSurfaceData.dwSCnt = pCreateSurface->dwSCnt;
        CreateSurfaceData.lplpSList = (LPDDRAWI_DDRAWSURFACE_LCL*)
            MemAlloc(sizeof(LPDDRAWI_DDRAWSURFACE_LCL) * CreateSurfaceData.dwSCnt);
        if (CreateSurfaceData.lplpSList == NULL)
        {
            return DDERR_OUTOFMEMORY;
        }

        for (i = 0; i < CreateSurfaceData.dwSCnt; i++)
        {
            CreateSurfaceData.lplpSList[i] =
                ((PDDSURFACE)pCreateSurface->pSList[i].hKernelHandle)->pTempHeavy->lpLcl;
        }

        dwRet = pCallbacks->CreateSurface( &CreateSurfaceData );

        // Now copy the fpVidMem and the pitch that the driver setup
        // back to the permanent structures

        for (i = 0; i < CreateSurfaceData.dwSCnt; i++)
        {
            pCreateSurface->pSList[i].pbPixels = (BYTE*)
                CreateSurfaceData.lplpSList[i]->lpGbl->fpVidMem;
            pCreateSurface->pSList[i].iPitch =
                CreateSurfaceData.lplpSList[i]->lpGbl->lPitch;
        }

        // Now clean everything up

        MemFree(CreateSurfaceData.lplpSList);

        if( dwRet == DDHAL_DRIVER_NOTHANDLED )
        {
            return DDERR_UNSUPPORTED;
        }
        return CreateSurfaceData.ddRVal;
    }
    else
    {
        return DDERR_UNSUPPORTED;
    }
}

void
SwDDIAttachSurfaces( LPDDRAWI_DDRAWSURFACE_LCL psurf_from_lcl,
                     LPDDRAWI_DDRAWSURFACE_LCL psurf_to_lcl )
{
    LPATTACHLIST    pal_from = NULL;
    LPATTACHLIST    pal_to = NULL;

    /*
     * allocate attachment structures
     */
    pal_from = MemAlloc(sizeof(ATTACHLIST));
    pal_to   = MemAlloc(sizeof(ATTACHLIST));
    if (pal_to == NULL || pal_from == NULL)
    {
        if( pal_from ) MemFree( pal_from );
        if( pal_to ) MemFree( pal_to );

        DPF_ERR("Failed memalloc, not attaching");
        return;
    }

    /*
     * connect the surfaces
     */
    pal_from->lpAttached = psurf_to_lcl;
    pal_from->dwFlags = DDAL_IMPLICIT;
    pal_from->lpLink = psurf_from_lcl->lpAttachList;
    psurf_from_lcl->lpAttachList = pal_from;
    psurf_from_lcl->dwFlags |= DDRAWISURF_ATTACHED;

    pal_to->lpAttached = psurf_from_lcl;
    pal_to->dwFlags = DDAL_IMPLICIT;
    pal_to->lpLink = psurf_to_lcl->lpAttachListFrom;
    psurf_to_lcl->lpAttachListFrom = pal_to;
    psurf_to_lcl->dwFlags |= DDRAWISURF_ATTACHED_FROM;
}

void
SwDDICreateSurfaceEx(LPDDRAWI_DIRECTDRAW_LCL pDrv,
                     LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    PD3D8_SWCALLBACKS           pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_CREATESURFACEEXDATA   CreateExData;

    if ((pLcl != NULL) &&
        (pCallbacks->CreateSurfaceEx != NULL))
    {
        CreateExData.dwFlags = 0;
        CreateExData.lpDDLcl = pDrv;
        CreateExData.lpDDSLcl = pLcl;

        pCallbacks->CreateSurfaceEx(&CreateExData);
    }
}

void BreakOutstandingLocks(PDDSURFACE pSurf, LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    D3D8_UNLOCKDATA   UnlockData;

    while (pLcl->lpGbl->dwUsageCount > 0)
    {
        SwDDIUnlock(pSurf->pDevice, pSurf, &UnlockData, pLcl);
    }
}

DWORD
SwDDIDestroySurface( HANDLE hDD, PDDSURFACE pSurf, LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)hDD)->pSwDD->lpLcl;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_DESTROYSURFACEDATA DestroyData;

    DestroyData.lpDD = pDrv->lpGbl;
    DestroyData.lpDDSurface = pLcl;
    DestroyData.ddRVal = DD_OK;

    BreakOutstandingLocks(pSurf, pLcl);

    if (pCallbacks->DestroySurface != NULL)
    {
        pCallbacks->DestroySurface(&DestroyData);
    }

    return DestroyData.ddRVal;
}

DWORD WINAPI
SwContextCreate(PD3D8_CONTEXTCREATEDATA pCreateContext)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)pCreateContext->hDD)->pSwDD->lpLcl;
    PD3D8_SWCALLBACKS   pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    D3DHAL_CONTEXTCREATEDATA    ContextData;
    DWORD                       dwRet = DDHAL_DRIVER_NOTHANDLED;

    if (pCallbacks->CreateContext != NULL)
    {
        ContextData.lpDDLcl = pDrv;
        DDASSERT(((PDDSURFACE)pCreateContext->hSurface)->dwFlags & DDSURFACE_HEAVYWEIGHT);
        ContextData.lpDDSLcl = ((PDDSURFACE)pCreateContext->hSurface)->Surface.pHeavy->lpLcl;
        if (pCreateContext->hDDSZ == NULL)
        {
            ContextData.lpDDSZLcl = NULL;
        }
        else
        {
            DDASSERT(((PDDSURFACE)pCreateContext->hDDSZ)->dwFlags & DDSURFACE_HEAVYWEIGHT);
            ContextData.lpDDSZLcl = ((PDDSURFACE)pCreateContext->hDDSZ)->Surface.pHeavy->lpLcl;
        }
        ContextData.dwPID = pCreateContext->dwPID;
        ContextData.dwhContext = pCreateContext->dwhContext;

        dwRet = pCallbacks->CreateContext(&ContextData);

        pCreateContext->dwhContext = ContextData.dwhContext;
        pCreateContext->ddrval = MapLegacyResult(ContextData.ddrval);
    }

    return dwRet;
}

DWORD WINAPI
SwDrawPrimitives2(PD3D8_DRAWPRIMITIVES2DATA pdp2data)
{
    LPDDRAWI_DIRECTDRAW_LCL     pDrv = ((PDDSURFACE)pdp2data->hDDCommands)->pDevice->pSwDD->lpLcl;
    PD3D8_SWCALLBACKS           pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    D3DHAL_DRAWPRIMITIVES2DATA  DP2Data;
    HRESULT                     hr;
    DWORD                       dwRet;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyCommand;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyVertex = NULL;
    DDSURFACE*                  pSurfCommand;
    DDSURFACE*                  pSurfVertex = NULL;

    dwRet = DDHAL_DRIVER_NOTHANDLED;
    if (pCallbacks->DrawPrimitives2 != NULL)
    {
        memcpy(&DP2Data, pdp2data, sizeof(DP2Data));

        ENTER_DDRAW();
        pSurfCommand = pdp2data->hDDCommands;
        if (pSurfCommand->dwFlags & DDSURFACE_LIGHTWEIGHT)
        {
            pHeavyCommand = MapLightweightSurface(pSurfCommand);
        }
        else
        {
            pHeavyCommand = pSurfCommand->Surface.pHeavy;
        }
        if (pHeavyCommand != NULL)
        {
            DP2Data.ddrval = DD_OK;
            DP2Data.lpDDCommands    = pHeavyCommand->lpLcl;
            if (!(DP2Data.dwFlags & D3DHALDP2_USERMEMVERTICES))
            {
                pSurfVertex = pdp2data->hDDCommands;
                if (pSurfVertex->dwFlags & DDSURFACE_LIGHTWEIGHT)
                {
                    pHeavyVertex = MapLightweightSurface(pSurfVertex);
                }
                else
                {
                    pHeavyVertex = pSurfVertex->Surface.pHeavy;
                }
                if (pHeavyVertex != NULL)
                {
                    DP2Data.lpDDVertex  = pHeavyVertex->lpLcl;
                }
                else
                {
                    DP2Data.ddrval = DDERR_OUTOFMEMORY;
                }
            }
            if (DP2Data.ddrval == DD_OK)
            {
                dwRet = pCallbacks->DrawPrimitives2(&DP2Data);

                pdp2data->ddrval        = DP2Data.ddrval;
                pdp2data->dwErrorOffset = DP2Data.dwErrorOffset;
            }
        }
        if ((pHeavyCommand != NULL) &&
            (pSurfCommand->dwFlags & DDSURFACE_LIGHTWEIGHT ))
        {
            UnmapLightweightSurface(pSurfCommand);
        }
        if ((pHeavyVertex != NULL) &&
            (pSurfVertex->dwFlags & DDSURFACE_LIGHTWEIGHT ))
        {
            UnmapLightweightSurface(pSurfVertex);
        }
        LEAVE_DDRAW();
    }

    return dwRet;
}

HRESULT
SwDDILock( HANDLE hDD, PDDSURFACE pSurf, PD3D8_LOCKDATA pLockData, LPDDRAWI_DDRAWSURFACE_LCL pLcl )
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)hDD)->pSwDD->lpLcl;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_LOCKDATA          LockData;
    DWORD                   dwRet = DDHAL_DRIVER_HANDLED;

    LockData.lpDD = pDrv->lpGbl;
    LockData.lpDDSurface = pLcl;
    LockData.bHasRect = pLockData->bHasRect;
    LockData.rArea = pLockData->rArea;
    LockData.dwFlags = pLockData->dwFlags;
    LockData.ddRVal = DDERR_WASSTILLDRAWING;

    if (pLockData->bHasBox)
    {
        LockData.bHasRect = TRUE;
        LockData.rArea.left = pLockData->box.Left;
        LockData.rArea.right = pLockData->box.Right;
        LockData.rArea.top = pLockData->box.Top;
        LockData.rArea.bottom = pLockData->box.Bottom;
        LockData.rArea.left |= (pLockData->box.Front << 16);
        LockData.rArea.right |= (pLockData->box.Back << 16);
    }

    pLcl->lpGbl->dwUsageCount++;
    while (LockData.ddRVal == DDERR_WASSTILLDRAWING)
    {
        if (pCallbacks->Lock != NULL)
        {
            dwRet = pCallbacks->Lock(&LockData);
        }
        else
        {
            LockData.ddRVal = DD_OK;
        }
    }

    if (LockData.ddRVal != DD_OK)
    {
        pLcl->lpGbl->dwUsageCount--;
    }

    pLockData->lpSurfData = LockData.lpSurfData;

    return LockData.ddRVal;
}

HRESULT
SwDDIUnlock( HANDLE hDD, PDDSURFACE pSurf, D3D8_UNLOCKDATA* pUnlockData, LPDDRAWI_DDRAWSURFACE_LCL pLcl )
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)hDD)->pSwDD->lpLcl;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_UNLOCKDATA        UnlockData;
    DWORD                   dwRet = DDHAL_DRIVER_HANDLED;;

    UnlockData.lpDD = pDrv->lpGbl;
    UnlockData.lpDDSurface = pLcl;
    UnlockData.ddRVal = DD_OK;

    pLcl->lpGbl->dwUsageCount--;
    if (pCallbacks->Unlock != NULL)
    {
        pCallbacks->Unlock(&UnlockData);
    }

    return UnlockData.ddRVal;
}

DWORD APIENTRY SwDdSetColorkey( PD3D8_SETCOLORKEYDATA pSetColorkey)
{
#if 0
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)pSetColorkey->hDD)->pSwDD->lpLcl;
//    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = ((PDDSURFACE)pSetColorkey->hSurface)->Surface.pLight->lpLcl;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;

    surf_lcl->ddckCKSrcBlt.dwColorSpaceLowValue = pSetColorkey->ColorValue;
    surf_lcl->dwFlags |= DDRAWISURF_HASCKEYSRCBLT;
    pSetColorkey->ddRVal = DD_OK;

    if (pCallbacks->SetColorkey != NULL)
    {
        DDHAL_SETCOLORKEYDATA   data;

        data.lpDD                       = pDrv->lpGbl;
        data.lpDDSurface                = surf_lcl;
        data.dwFlags                    = DDCKEY_SRCBLT;
        data.ckNew.dwColorSpaceLowValue = pSetColorkey->ColorValue;
        data.ddRVal                     = DD_OK;

        pCallbacks->SetColorkey(&data);
        pSetColorkey->ddRVal = data.ddRVal;
    }
#endif
    return DDHAL_DRIVER_HANDLED;
}

LPDDRAWI_DIRECTDRAW_INT
SwDDICreateDirectDraw( void)
{
    LPDDRAWI_DIRECTDRAW_INT pInt;
    LPDDRAWI_DIRECTDRAW_LCL pLcl;
    LPDDRAWI_DIRECTDRAW_GBL pGbl;
    BYTE*                   pTemp;

    pInt = (LPDDRAWI_DIRECTDRAW_INT)MemAlloc(sizeof(DDRAWI_DIRECTDRAW_LCL) +
        sizeof(DDRAWI_DIRECTDRAW_GBL) +
        sizeof(DDRAWI_DIRECTDRAW_INT));
    if (pInt == NULL)
    {
        return NULL;
    }

    pTemp = (BYTE*)pInt;
    pTemp += sizeof(DDRAWI_DIRECTDRAW_INT);
    pLcl = (LPDDRAWI_DIRECTDRAW_LCL) pTemp;
    pInt->lpLcl = pLcl;
    pTemp += sizeof(DDRAWI_DIRECTDRAW_LCL);
    pGbl = (LPDDRAWI_DIRECTDRAW_GBL) pTemp;
    pLcl->lpGbl = pGbl;

    pLcl->dwLocalRefCnt = 1;
    pGbl->dwRefCnt = 1;

    return pInt;
}


void
SwDDIMungeCaps( HINSTANCE           hLibrary,
                HANDLE              hDD,
                PD3D8_DRIVERCAPS    pDriverCaps,
                PD3D8_CALLBACKS     pCallbacks,
                LPDDSURFACEDESC     pTextureFormats,
                UINT*               pcTextureFormats,
                VOID*               pInitFunction
                )
{
    PD3D8GetSWInfo          pfnGetSWInfo;
    D3DCAPS8                swCaps;
    D3D8_SWCALLBACKS        swCallbacks;
    LPDDRAWI_DIRECTDRAW_LCL pLcl;
    LPDDRAWI_DIRECTDRAW_GBL pGbl;
    PDDDEVICEHANDLE         pDevice = (PDDDEVICEHANDLE) hDD;
    DWORD                   i;
    DWORD                   NumTex = 0;
    DDSURFACEDESC*          pTexList = NULL;

    // Get the info from the software driver
    memset (&swCaps, 0, sizeof(swCaps));
    memset (&swCallbacks, 0, sizeof(swCallbacks));
    if (hLibrary != NULL)
    {
        pfnGetSWInfo = (PD3D8GetSWInfo)GetProcAddress (hLibrary, D3D8HOOK_GETSWINFOPROCNAME);
    }
    else if ((hLibrary == NULL) && (pDevice->DeviceType == D3DDEVTYPE_REF))
    {
        HINSTANCE hLibraryD3D8 = NULL;

        // No hLibrary or an init function...it means time to fall
        // back on crippled ref.
        DPF(0,"Could not find d3dref8.dll, loading internal crippled ReferenceDevice, no rendering will take place\n");
        
        hLibraryD3D8 = LoadLibrary("d3d8.dll");
        if (hLibraryD3D8 != NULL)
        {
            pfnGetSWInfo = (PD3D8GetSWInfo)GetProcAddress (hLibraryD3D8, D3D8HOOK_GETSWINFOPROCNAME);
            FreeLibrary( hLibraryD3D8 );
        }
        else
        {
            DPF(0,"Could not find d3d8.dll to get the crippled reference device, a really bad problem indeed!!!\n");
            return;
        }
    }
    else
    {
        pfnGetSWInfo = (PD3D8GetSWInfo)pInitFunction;
    }

    if (pfnGetSWInfo != NULL )
    {
        (*pfnGetSWInfo)(&swCaps, &swCallbacks, &NumTex, &pTexList);
    }
    
    // Fill in out DDraw structure with the info that we have

    pLcl = pDevice->pSwDD->lpLcl;
    pGbl = pLcl->lpGbl;
    strcpy (pGbl->cDriverName, pDevice->szDeviceName);
    pGbl->vmiData.dwDisplayWidth = pDriverCaps->DisplayWidth;
    pGbl->vmiData.dwDisplayHeight = pDriverCaps->DisplayHeight;
    ConvertToOldFormat( &pGbl->vmiData.ddpfDisplay, pDriverCaps->DisplayFormatWithAlpha);

    // Overwite the hardware caps w/ the software caps
    memcpy (&pDriverCaps->D3DCaps, &swCaps, sizeof(swCaps));
    pDriverCaps->dwFlags |= DDIFLAG_D3DCAPS8;

    // Copy over our texture format list if required.
    *pcTextureFormats = NumTex;
    if (pTextureFormats && pTexList)
    {
        memcpy(
            pTextureFormats,
            pTexList,
            sizeof (*pTexList) * NumTex);
    }


    // Now change the callback table to point to the ones for the SW drivers

    if (swCallbacks.CreateContext == NULL)
    {
        pCallbacks->CreateContext           = NULL;
    }
    else
    {
        pCallbacks->CreateContext           = SwContextCreate;
    }
    pCallbacks->ContextDestroy              = (PD3D8DDI_CONTEXTDESTROY) swCallbacks.ContextDestroy;
    pCallbacks->ContextDestroyAll           = (PD3D8DDI_CONTEXTDESTROYALL) swCallbacks.ContextDestroyAll;
    pCallbacks->RenderState                 = (PD3D8DDI_RENDERSTATE) swCallbacks.RenderState;
    pCallbacks->RenderPrimitive             = (PD3D8DDI_RENDERPRIMITIVE) swCallbacks.RenderPrimitive;
    if (swCallbacks.DrawPrimitives2 == NULL)
    {
        pCallbacks->DrawPrimitives2         = NULL;
    }
    else
    {
        pCallbacks->DrawPrimitives2         = SwDrawPrimitives2;
    }
    pCallbacks->GetDriverState              = (PD3D8DDI_GETDRIVERSTATE) swCallbacks.GetDriverState;
    pCallbacks->ValidateTextureStageState   = (PD3D8DDI_VALIDATETEXTURESTAGESTATE) swCallbacks.ValidateTextureStageState;
    pCallbacks->SceneCapture                = (PD3D8DDI_SCENECAPTURE) swCallbacks.SceneCapture;
    pCallbacks->Clear2                      = (PD3D8DDI_CLEAR2) swCallbacks.Clear2;
    pCallbacks->SetColorkey                 = (PD3D8DDI_SETCOLORKEY) SwDdSetColorkey;

    // Save the original software callbacks so we can call the software driver later

    if (pGbl->lpDDCBtmp == NULL)
    {
        pGbl->lpDDCBtmp = (LPDDHAL_CALLBACKS) MemAlloc(sizeof(D3D8_SWCALLBACKS));
    }
    if (pGbl->lpDDCBtmp != NULL)
    {
        memcpy(pGbl->lpDDCBtmp, &swCallbacks, sizeof(swCallbacks));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\w95dci.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95dci.c
 *  Content:	DCI thunk helper code
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   19-jun-95	craige	initial implementation
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dpf.h"
#include "memalloc.h"
#include "dciman.h"

extern int WINAPI DCICreatePrimary32( HDC hdc, LPDCISURFACEINFO lpSurface );
extern void WINAPI DCIDestroy32( LPDCISURFACEINFO pdci );

/*
 * DCICreatePrimary
 */
int WINAPI DCICreatePrimary( HDC hdc, LPDCISURFACEINFO *lplpSurface )
{
    int                     rc;
    LPDCISURFACEINFO        lpSurface;

    *lplpSurface = NULL;

    lpSurface = MemAlloc( sizeof( *lpSurface ) );
    if( lpSurface == NULL )
    {
	return DCI_ERR_OUTOFMEMORY;
    }
    lpSurface->dwSize = sizeof( DCIPRIMARY );
    rc = DCICreatePrimary32( hdc, lpSurface );
    if( rc < 0 )
    {
	DPF( 2, "DCICreatePrimary32: rc = %ld", rc );
	MemFree( lpSurface );
	return rc;
    }
    *lplpSurface = lpSurface;
    return rc;

} /* DCICreatePrimary */

/*
 * DCIDestroy
 */
void WINAPI DCIDestroy( LPDCISURFACEINFO pdci )
{
    DCIDestroy32( pdci );
    MemFree( pdci );

} /* DCIDestroy */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\w95csect.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95csect.c
 *  Content:	code for managing critical sections on Win95
 *		We trade a performance hit when 2 threads try to use a surface
 *		for only using 4 bytes (pointer) instead of 24 bytes for a
 *		critical section object PER SURFACE.
 *
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-feb-95	craige	initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "ddrawpr.h"

#if 0
#ifdef USE_CRITSECTS

/*
 * MyReinitializeCriticalSection
 */
BOOL MyReinitializeCriticalSection( LPVOID *lplpCriticalSection )
{
    *lplpCriticalSection = NULL;
    return TRUE;

} /* MyReinitializeCriticalSection */

/*
 * MyEnterCriticalSection
 */
BOOL MyEnterCriticalSection( LPVOID *lplpCriticalSection )
{
    LPCRITICAL_SECTION	pcs;

    if( *lplpCriticalSection != hDLLMutex )
    {
	EnterCriticalSection( hDLLMutex );
    }
    if( *lplpCriticalSection == NULL )
    {
	OutputDebugString( "DOING MALLOC" );
	pcs = MemAlloc( sizeof( CRITICAL_SECTION ) );
	if( pcs == NULL )
	{
	    DPF( 0, "OUT OF MEMORY CREATING CRITICAL SECTION" );
	    LeaveCriticalSection( hDLLMutex );
	    return FALSE;
	}
	ReinitializeCriticalSection( pcs );
	*lplpCriticalSection = pcs;
    }
    // ACKACK: ALWAYS WANT TO SEE THIS MESSAGE
    if( *lplpCriticalSection != hDLLMutex )
    {
//	OutputDebugString( "DCIENG32: EnterCriticalSection\r\n" );
    }
    EnterCriticalSection( *lplpCriticalSection );
    if( *lplpCriticalSection != hDLLMutex )
    {
	LeaveCriticalSection( hDLLMutex );
    }
    return TRUE;

} /* MyEnterCriticalSection */

/*
 * MyLeaveCriticalSection
 */
void MyLeaveCriticalSection( LPVOID *lplpCriticalSection )
{
    if( *lplpCriticalSection == NULL )
    {
	DPF( 0, "TRYING TO LEAVE NULL CRITICAL SECTION" );
	LeaveCriticalSection( hDLLMutex );
	return;
    }
    // ALWAYS WANT TO SEE THIS MESSAGE
    if( *lplpCriticalSection != hDLLMutex )
    {
//	OutputDebugString( "DCIENG32: LeaveCriticalSection\r\n" );
    }
    LeaveCriticalSection( *lplpCriticalSection );

} /* MyLeaveCriticalSection */

/*
 * MyDeleteCriticalSection
 */
void MyDeleteCriticalSection( LPVOID *lplpCriticalSection )
{
    EnterCriticalSection( hDLLMutex );
    if( *lplpCriticalSection == NULL )
    {
	LeaveCriticalSection( hDLLMutex );
	return;
    }
    DeleteCriticalSection( *lplpCriticalSection );
    MemFree( *lplpCriticalSection );
    *lplpCriticalSection = NULL;
    LeaveCriticalSection( hDLLMutex );

} /* MyDeleteCriticalSection */
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\w95hack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hack.c
 *  Content:	Win95 hack-o-rama code
 *		This is a HACK to handle the fact that Win95 doesn't notify
 *		a DLL when a process is destroyed.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   28-mar-95	craige	initial implementation
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	reworked for new ddhelp
 *   11-apr-95	craige	bug where dwFakeCurrPid was getting set and
 *			other processes were ending up using it!
 *   24-jun-95	craige	call RemoveProcessFromDLL; use that to fiddle
 *			with DLL refcnt
 *   25-jun-95	craige	one ddraw mutex
 *   19-jul-95	craige	notify DDHELP to clean up DC list on last object detach
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   18-jan-97  colinmc ddhelp vxd handling is no longer win16 lock specific
 *                      we now need it for agp support
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"

/*
 * HackGetCurrentProcessId
 *
 * This call is used in place of GetCurrentProcessId on Win95.
 * This allows us to substitute the pid of the terminated task passed to
 * us from DDHELP as the "current" process.
 */
DWORD HackGetCurrentProcessId( void )
{
    DWORD	pid;

    pid = GetCurrentProcessId();
    if( pid == dwGrimReaperPid )
    {
	return dwFakeCurrPid;
    }
    else
    {
	return pid;
    }

} /* HackGetCurrentProcessId */

/*
 * DDNotify
 *
 * called by DDHELP to notify us when a pid is dead
 */
BOOL DDAPI DDNotify( LPDDHELPDATA phd )
{
    BOOL		rc;
    //extern DWORD	dwRefCnt;

#ifdef USE_CHEAP_MUTEX
    DestroyPIDsLock (&CheapMutexCrossProcess,phd->pid,DDRAW_FAST_CS_NAME);
#endif

    ENTER_DDRAW();

    dwGrimReaperPid = GetCurrentProcessId();
    dwFakeCurrPid = phd->pid;
    DPF( 4, "************* DDNotify: dwPid=%08lx has died, calling CurrentProcessCleanup", phd->pid );
    rc = FALSE;

    CurrentProcessCleanup( TRUE );

    if( RemoveProcessFromDLL( phd->pid ) )
    {
	/*
	 * update refcnt if RemoveProcessFromDLL is successful.
	 * It is only successful if we had a process get blown away...
	 */
	DPF( 5, "DDNotify: DLL RefCnt = %lu", dwRefCnt );
       	if( dwRefCnt == 2 )
	{
	    DPF( 5, "DDNotify: On last refcnt, safe to kill DDHELP.EXE" );
            dwRefCnt = 1;
	    rc = TRUE;	// free the DC list
            FreeAppHackData();
	    #if defined( DEBUG ) && defined (WIN95)
                DPF( 6, "Memory state after automatic cleanup: (one allocation expected)" );
		MemState();
	    #endif
        }
	else if( dwRefCnt == 1 )
	{
	    DPF( 0, "ERROR! DLL REFCNT DOWN TO 1" );
	    #if 0
		MemFini();
		dwRefCnt = 0;
		strcpy( phd->fname, DDHAL_APP_DLLNAME );
	    #endif
	}
	else if( dwRefCnt > 0 )
	{
	    dwRefCnt--;
	}
    }
    /* order is important, clear dwGrimReaperPid first */
    dwGrimReaperPid = 0;
    dwFakeCurrPid = 0;
    DPF( 4, "************* DDNotify: *** DONE ***" );

    LEAVE_DDRAW();
    return rc;

} /* DDNotify */

/*
 * DDNotifyModeSet
 *
 * called by ddhelp when an extern modeset is done...
 *
 * NOTE: We can explicitly use the cached DDHELP
 * VXD handle as we know this code can only ever get
 * executed on a DDHELP thread.
 */
void DDAPI DDNotifyModeSet( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    BOOL bRestoreGamma;

    ENTER_DDRAW();

    /* DPF( 2, "DDNotifyModeSet, object %08lx", pdrv ); */

    /*
     * make sure the driver isn't trying to lie to us about the old object
     * This check should always be made at the top of this routine, since it's
     * possible in stress scenarios for ddhelp's modeset thread to wake up
     * just before it's killed at the end of DD_Release (since the code to kill
     * the mode set thread is executed AFTER the last LEAVE_DDRAW in DD_Release).
     */
    if( pdrv != NULL )
    {
	pdrv_lcl = lpDriverLocalList;
	while( pdrv_lcl != NULL )
	{
	    if( pdrv_lcl->lpGbl == pdrv )
	    {
		break;
	    }
	    pdrv_lcl = pdrv_lcl->lpLink;
	}
	if( pdrv_lcl == NULL )
	{
	    LEAVE_DDRAW();
	    return;
	}
    }

    bRestoreGamma = ( pdrv_lcl->lpPrimary != NULL ) &&
        ( pdrv_lcl->lpPrimary->lpLcl->lpSurfMore->lpGammaRamp != NULL ) &&
        ( pdrv_lcl->lpPrimary->lpLcl->dwFlags & DDRAWISURF_SETGAMMA );

    #ifdef WIN95
        DDASSERT( INVALID_HANDLE_VALUE != hHelperDDVxd );
        FetchDirectDrawData( pdrv, TRUE, 0, hHelperDDVxd, NULL, 0 , NULL );
    #else /* WIN95 */
        FetchDirectDrawData( pdrv, TRUE, 0, NULL, NULL, 0 , NULL );
    #endif /* WIN95 */

    /*
     * Some drivers reset the gamma after a mode change, so we need to
     * force it back.
     */
    if( bRestoreGamma )
    {
        SetGamma( pdrv_lcl->lpPrimary->lpLcl, pdrv_lcl );
    }

    LEAVE_DDRAW();
    DPF( 4, "DDNotifyModeSet DONE" );

} /* DDNotifyModeSet */

/*
 * DDNotifyDOSBox
 *
 * called by ddhelp when exiting from a DOS box...
 *
 * NOTE: We can explicitly use the cached DDHELP
 * VXD handle as we know this code can only ever get
 * executed on a DDHELP thread.
 */
void DDAPI DDNotifyDOSBox( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    BOOL bRestoreGamma;

    ENTER_DDRAW();

    /* DPF( 2, "DDNotifyDOSBox, object %08lx", pdrv ); */

    /*
     * make sure the driver isn't trying to lie to us about the old object
     * This check should always be made at the top of this routine, since it's
     * possible in stress scenarios for ddhelp's modeset thread to wake up
     * just before it's killed at the end of DD_Release (since the code to kill
     * the mode set thread is executed AFTER the last LEAVE_DDRAW in DD_Release).
     */
    if( pdrv != NULL )
    {
	pdrv_lcl = lpDriverLocalList;
	while( pdrv_lcl != NULL )
	{
	    if( pdrv_lcl->lpGbl == pdrv )
	    {
		break;
	    }
	    pdrv_lcl = pdrv_lcl->lpLink;
	}
	if( pdrv_lcl == NULL )
	{
	    LEAVE_DDRAW();
	    return;
	}
    }

    bRestoreGamma = ( pdrv_lcl->lpPrimary != NULL ) &&
        ( pdrv_lcl->lpPrimary->lpLcl->lpSurfMore->lpGammaRamp != NULL ) &&
        ( pdrv_lcl->lpPrimary->lpLcl->dwFlags & DDRAWISURF_SETGAMMA );

    #ifdef WIN95
        InvalidateAllSurfaces( pdrv, hHelperDDVxd, TRUE );
    #else
        InvalidateAllSurfaces( pdrv, NULL, TRUE );
    #endif

    /*
     * Invalidating the surfaces will mess up the gamma so we need to
     * restore it.
     */
    if( bRestoreGamma )
    {
        SetGamma( pdrv_lcl->lpPrimary->lpLcl, pdrv_lcl );
    }

    LEAVE_DDRAW();
    DPF( 4, "DDNotifyDOSBox DONE" );

} /* DDNotifyDOSBox */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\_memallo.c ===
#include "ddrawpr.h"
#ifndef WIN95
#define __DXGUSEALLOC
#endif
#include "..\..\..\misc\memalloc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\_w95help.c ===
#include "ddrawpr.h"

#include "..\..\misc\w95help.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\win9x\i386\16to32.inc ===
APILOGSL  macro   argName
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\w95priv.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95priv.c
 *  Content:	Private interface between DDRAW and the display driver
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   23-jan-95	craige	initial implementation
 *   27-feb-95	craige 	new sync. macros
 *   01-apr-95	craige	happy fun joy updated header file
 *   14-may-95	craige	cleaned out obsolete junk
 *   16-jun-95	craige	new surface structure
 *   19-jun-95	craige	added DD32_StreamingNotify
 *   22-jun-95	craige	added DD32_ClippingNotify
 *   24-jun-95	craige	trap faults in ClippinyNotify
 *   25-jun-95	craige	one ddraw mutex
 *   02-jul-95	craige	commented out streaming, clipper notification
 *   18-jan-97  colinmc AGP support
 *   31-oct-97 johnstep Added DD32_HandleExternalModeChange
 *
 ***************************************************************************/
#include "ddrawpr.h"

#ifdef STREAMING
/*
 * DD32_StreamingNotify
 */
void EXTERN_DDAPI DD32_StreamingNotify( DWORD ptr )
{

} /* DD32_StreamingNotify */
#endif

#ifdef CLIPPER_NOTIFY
/*
 * DD32_ClippingNotify
 */
void EXTERN_DDAPI DD32_ClippingNotify( LPWINWATCH pww, DWORD code )
{
    LPDDRAWI_DDRAWCLIPPER_LCL	this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL	this;

    try
    {
	this_lcl = pww->lpDDClipper;
	this = this_lcl->lpGbl;
	if( pww->lpCallback != NULL )
	{
	    pww->lpCallback( (LPDIRECTDRAWCLIPPER) this_lcl, (HWND) pww->hWnd,
				code, pww->lpContext );
	}
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF( 1, "Trapped Exception in ClippingNotify" );
    }

} /* DD32_ClippingNotify */

/*
 * DD32_WWClose
 */
void EXTERN_DDAPI DD32_WWClose( LPWINWATCH pww )
{
    WWClose( pww );

} /* DD32_WWClose */
#endif

/*
 * DDHAL32_VidMemAlloc
 */
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc(
		LPDDRAWI_DIRECTDRAW_GBL this,
		int heap,
		DWORD dwWidth,
		DWORD dwHeight )
{
    FLATPTR	ptr;

    ENTER_DDRAW();

    if( heap >= (int) this->vmiData.dwNumHeaps )
    {
	ptr = (FLATPTR) NULL;
    }
    else
    {
	HANDLE hdev;
        #ifdef    WIN95
            BOOLEAN close;
        #endif /* WIN95 */

	#ifdef    WIN95
            /* See if the global VXD handle contains a valid value. If not,
             * then just get a valid VXD handle from GetDXVxdHandle().
             * (snene 2/23/98)
             */
            if( INVALID_HANDLE_VALUE == (HANDLE)this->hDDVxd )
            {
	        /*
	         * As we may need to commit AGP memory we need a VXD handle
	         * to communicate with the DirectX VXD. Rather than hunting
	         * through the driver object list hoping we will find a
	         * local object for this process we just create a handle
	         * and discard it after the allocation. This should not be
	         * performance critical code to start with.
	         */
	        hdev = GetDXVxdHandle();
                if ( INVALID_HANDLE_VALUE == hdev )
                {
                    LEAVE_DDRAW()
                    return (FLATPTR) NULL;
                }
                close = TRUE;
            }
            /* If the global handle is valid, then we are being called as a
             * result of CreateSurface being called and so we just use the
             * global handle to speed things up.
             * (snene 2/23/98)
             */
            else
            {
                hdev = (HANDLE)this->hDDVxd;
                close = FALSE;
            }
	#else  /* WIN95 */
	    hdev = INVALID_HANDLE_VALUE;
	#endif /* WIN95 */

        /* Pass NULL Alignment and new pitch pointer */
	ptr = HeapVidMemAlloc( &(this->vmiData.pvmList[ heap ]),
			       dwWidth, dwHeight, hdev , NULL , NULL, NULL );

	#ifdef WIN95
            if( close )
	        CloseHandle( hdev );
	#endif /* WIN95 */
    }
    LEAVE_DDRAW()
    return ptr;

} /* DDHAL32_VidMemAlloc */

/*
 * DDHAL32_VidMemFree
 */
void EXTERN_DDAPI DDHAL32_VidMemFree(
		LPDDRAWI_DIRECTDRAW_GBL this,
		int heap,
		FLATPTR ptr )
{
    ENTER_DDRAW()

    if( this && heap < (int) this->vmiData.dwNumHeaps )
    {
	VidMemFree( this->vmiData.pvmList[ heap ].lpHeap, ptr );
    }
    LEAVE_DDRAW()

} /* DDHAL32_VidMemFree */

#ifdef POSTPONED
//=============================================================================
//
//  Function: DD32_HandleExternalModeChange
//
//  This function is ONLY called by DDRAw16 on an external mode change.
//
//  Parameters:
//
//      LPDEVMODE pdm [IN] - includes the name of the display device
//
//  Return:
//
//      FALSE if display settings should not be changed
//
//=============================================================================

static char szDisplay[] = "display";
static char szDisplay1[] = "\\\\.\\Display1";

BOOL EXTERN_DDAPI DD32_HandleExternalModeChange(LPDEVMODE pdm)
{
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    BOOL                    primary;

    //
    // This is ONLY called from DDRAW16 once we already have the Win16
    // lock. We have to give it up before enterint DDraw because some other
    // process may be inside DDraw.
    //

    INCW16CNT();
    LEAVE_WIN16LOCK();
    ENTER_DDRAW();
    ENTER_WIN16LOCK();

    //
    // We'll get szDisplay for the primary display, rather than szDisplay1,
    // but a multimon-aware app may have explicitly created a device object
    // for szDisplay1, so we need to handle this case.
    //

    primary = !lstrcmpi(pdm->dmDeviceName, szDisplay);

    for (pdrv_lcl = lpDriverLocalList; pdrv_lcl; pdrv_lcl = pdrv_lcl->lpLink)
    {
        if (!lstrcmpi(pdrv_lcl->lpGbl->cDriverName, pdm->dmDeviceName) ||
            (primary && !lstrcmpi(pdrv_lcl->lpGbl->cDriverName, szDisplay1)))
        {
            DPF(4, "Mode change on device: %s", pdrv_lcl->lpGbl->cDriverName);
            InvalidateAllSurfaces(pdrv_lcl->lpGbl, NULL, FALSE);
        }
    }

    LEAVE_DDRAW();
    DECW16CNT();

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\w95hal.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hal.c
 *  Content:	routines to invoke HAL on Win95
 *		These routines redirect the callbacks from the 32-bit
 *		side to the driver
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   03-feb-95	craige	performance tuning, ongoing work
 *   11-mar-95	craige	palette stuff
 *   01-apr-95	craige	happy fun joy updated header file
 *   07-apr-95	craige	check src surface ptrs for NULL in blt
 *   13-apr-95	craige	thunk pointer for WaitForVerticalBlank flip test
 *   15-apr-95	craige	more flags for pointer thunking in WaitForVerticalBlank
 *   14-may-95	craige	cleaned out obsolete junk
 *   22-may-95	craige	16:16 ptrs always avail. for surfaces/palettes
 *   28-may-95	craige	cleaned up HAL: added GetBltStatus; GetFlipStatus;
 *			GetScanLine
 *   19-jun-95	craige	removed _DDHAL_EnumAllSurfacesCallback
 *   26-jun-95	craige	reorganized surface structure
 *   27-jun-95	craige	duplicate surfaces caused crash
 *   29-jun-95	craige	fully alias CreateSurface
 *   10-jul-95	craige	support SetOverlayPosition
 *   10-aug-95  toddla  Blt, Lock, Flip need to not trash the driver data
 *                      because it might get reused if the DDXXX_WAIT flag
 *                      is used, or if a clipper is attached.
 *   10-dec-95  colinmc added dummy _DDHAL_ entry points for the execute
 *                      buffer HAL.
 *   13-apr-95  colinmc Bug 17736: No driver notfication of flip to GDI
 *   01-oct-96	ketand	added GetAvailDriverMemory
 *   20-jan-97  colinmc AGP support
 *
 ***************************************************************************/
#include "ddrawpr.h"

#ifdef WIN95

#define GETSURFALIAS( psurf_lcl ) \
		GetPtr16( psurf_lcl )

#define GETDATAALIAS( psx, sv ) \
		if( !(psx->dwFlags & DDRAWISURF_DATAISALIASED) ) \
		{ \
		    sv = psx->lpGbl; \
		    psx->lpGbl = GetPtr16( psx->lpGbl ); \
		    psx->dwFlags |= DDRAWISURF_DATAISALIASED; \
		}  \
		else \
		{ \
		    sv = (LPVOID) 0xffffffff; \
		}

#define RESTOREDATAALIAS( psx, sv ) \
		if( sv != (LPVOID) 0xffffffff ) \
		{ \
		    psx->lpGbl = sv; \
		    psx->dwFlags &= ~DDRAWISURF_DATAISALIASED; \
		}

/****************************************************************************
 *
 * DRIVER CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_CreatePalette
 */
DWORD DDAPI _DDHAL_CreatePalette( LPDDHAL_CREATEPALETTEDATA pcpd )
{
    DWORD	rc;

    /*
     * get 16:16 ptrs
     */
    pcpd->lpDD = pcpd->lpDD->lp16DD;

    /*
     * make the CreatePalette call in the driver
     */
    rc = DDThunk16_CreatePalette( pcpd );

    /*
     * clean up any 16:16 ptrs
     */
    return rc;

} /* _DDHAL_CreatePalette */

/*
 * _DDHAL_CreateSurface
 */
DWORD DDAPI _DDHAL_CreateSurface( LPDDHAL_CREATESURFACEDATA pcsd )
{
    DWORD			rc;
    int				i;
    LPVOID			FAR *ppslist;
    LPVOID			FAR *psave;
    LPDDRAWI_DDRAWSURFACE_LCL	FAR *slistx;
    DWORD			lplp16slist;

    /*
     * alias pointers to surfaces in new array...
     */
    pcsd->lpDDSurfaceDesc = (LPVOID) MapLS( pcsd->lpDDSurfaceDesc );
    if( pcsd->lpDDSurfaceDesc == NULL )
    {
	pcsd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }
    ppslist = MemAlloc( pcsd->dwSCnt * sizeof( DWORD ) );
    if( ppslist == NULL )
    {
	UnMapLS( (DWORD) pcsd->lpDDSurfaceDesc );
	pcsd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }
    psave = MemAlloc( pcsd->dwSCnt * sizeof( DWORD ) );
    if( psave == NULL )
    {
	MemFree( ppslist );
	UnMapLS( (DWORD) pcsd->lpDDSurfaceDesc );
	pcsd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }
    lplp16slist = MapLS( ppslist );
    if( lplp16slist == 0 )
    {
	MemFree( ppslist );
	MemFree( psave );
	UnMapLS( (DWORD) pcsd->lpDDSurfaceDesc );
	pcsd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }

    slistx = pcsd->lplpSList;
    for( i=0;i<(int)pcsd->dwSCnt;i++ )
    {
	ppslist[i] = GETSURFALIAS( slistx[i] );
	GETDATAALIAS( slistx[i], psave[i] );
    }

    /*
     * fix up structure with aliased ptrs
     */
    pcsd->lplpSList = (LPDDRAWI_DDRAWSURFACE_LCL FAR *)lplp16slist;
    pcsd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pcsd->lpDD->lp16DD;

    /*
     * make the CreateSurface call in the driver
     */
    rc = DDThunk16_CreateSurface( pcsd );

    /*
     * clean up any 16:16 ptrs
     */
    UnMapLS( lplp16slist );
    UnMapLS( (DWORD) pcsd->lpDDSurfaceDesc );
    for( i=0;i<(int)pcsd->dwSCnt;i++ )
    {
	RESTOREDATAALIAS( slistx[i], psave[i] );
    }
    MemFree( psave );
    MemFree( ppslist );

    return rc;

} /* _DDHAL_CreateSurface */

/*
 * _DDHAL_CanCreateSurface
 */
DWORD DDAPI _DDHAL_CanCreateSurface( LPDDHAL_CANCREATESURFACEDATA pccsd )
{
    DWORD		rc;

    pccsd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pccsd->lpDD->lp16DD;
    pccsd->lpDDSurfaceDesc = (LPVOID) MapLS( pccsd->lpDDSurfaceDesc );
    if( pccsd->lpDDSurfaceDesc == NULL )
    {
	pccsd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }

    /*
     * make the CanCreateSurface call in the driver
     */
    rc = DDThunk16_CanCreateSurface( pccsd );
    UnMapLS( (DWORD) pccsd->lpDDSurfaceDesc );

    return rc;

} /* _DDHAL_CanCreateSurface */

/*
 * _DDHAL_WaitForVerticalBlank
 */
DWORD DDAPI _DDHAL_WaitForVerticalBlank( LPDDHAL_WAITFORVERTICALBLANKDATA pwfvbd )
{
    DWORD			rc;

    pwfvbd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pwfvbd->lpDD->lp16DD;

    /*
     * make the WaitForVerticalBlank call in the driver
     */
    rc = DDThunk16_WaitForVerticalBlank( pwfvbd );

    return rc;

} /* _DDHAL_WaitForVerticalBlank */

/*
 * _DDHAL_DestroyDriver
 */
DWORD DDAPI _DDHAL_DestroyDriver( LPDDHAL_DESTROYDRIVERDATA pddd )
{
    DWORD	rc;

    pddd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pddd->lpDD->lp16DD;

    /*
     * make the DestroyDriver call in the driver
     */
    rc = DDThunk16_DestroyDriver( pddd );
    return rc;

} /* _DDHAL_DestroyDriver */

/*
 * _DDHAL_SetMode
 */
DWORD DDAPI _DDHAL_SetMode( LPDDHAL_SETMODEDATA psmd )
{
    DWORD		rc;

    psmd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) psmd->lpDD->lp16DD;

    /*
     * make the SetMode call in the driver
     */
    rc = DDThunk16_SetMode( psmd );

    return rc;

} /* _DDHAL_SetMode */

/*
 * _DDHAL_GetScanLine
 */
DWORD DDAPI _DDHAL_GetScanLine( LPDDHAL_GETSCANLINEDATA pgsld )
{
    DWORD	rc;

    pgsld->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pgsld->lpDD->lp16DD;

    /*
     * make the GetScanLine call in the driver
     */
    rc = DDThunk16_GetScanLine( pgsld );
    return rc;

} /* _DDHAL_GetScanLine */

/*
 * _DDHAL_SetExclusiveMode
 */
DWORD DDAPI _DDHAL_SetExclusiveMode( LPDDHAL_SETEXCLUSIVEMODEDATA psemd )
{
    DWORD       rc;

    psemd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) psemd->lpDD->lp16DD;

    /*
     * make the SetExclusiveMode call in the driver
     */
    rc = DDThunk16_SetExclusiveMode( psemd );
    return rc;

} /* _DDHAL_SetExclusiveMode */

/*
 * _DDHAL_FlipToGDISurface
 */
DWORD DDAPI _DDHAL_FlipToGDISurface( LPDDHAL_FLIPTOGDISURFACEDATA pftgsd )
{
    DWORD       rc;

    pftgsd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pftgsd->lpDD->lp16DD;

    /*
     * make the SetExclusiveMode call in the driver
     */
    rc = DDThunk16_FlipToGDISurface( pftgsd );
    return rc;

} /* _DDHAL_FlipToGDISurface */

/*
 * _DDHAL_GetAvailDriverMemory
 */
DWORD DDAPI _DDHAL_GetAvailDriverMemory( LPDDHAL_GETAVAILDRIVERMEMORYDATA pgadmd )
{
    DWORD rc;
    pgadmd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pgadmd->lpDD->lp16DD;
    rc = DDThunk16_GetAvailDriverMemory( pgadmd );
    return rc;
}

/*
 * _DDHAL_UpdateNonLocalHeap
 */
DWORD DDAPI _DDHAL_UpdateNonLocalHeap( LPDDHAL_UPDATENONLOCALHEAPDATA unlhd )
{
    DWORD rc;
    unlhd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) unlhd->lpDD->lp16DD;
    rc = DDThunk16_UpdateNonLocalHeap( unlhd );
    return rc;
}

/*
 * unmapSurfaceDescArray
 *
 * free an array of 16:16 ptrs
 */
static void unmapSurfaceDescArray( DWORD cnt, DWORD FAR *lp16sdlist )
{
    int	i;

    if( cnt == 0 )
    {
	return;
    }

    for( i=0;i<(int)cnt;i++ )
    {
	UnMapLS( lp16sdlist[i] );
    }
    MemFree( lp16sdlist );

} /* unmapSurfaceDescArray */

/*
 * mapSurfaceDescArray
 *
 * make 16:16 pointers for an array of surface descriptions
 */
static DWORD FAR *mapSurfaceDescArray( DWORD cnt, LPDDSURFACEDESC FAR *sdlist )
{
    DWORD	FAR *lp16sdlist;
    int		i;

    if( cnt == 0 || sdlist == NULL )
    {
	return NULL;
    }

    lp16sdlist = MemAlloc( cnt * sizeof( DWORD ) );
    if( lp16sdlist == NULL )
    {
	return NULL;
    }
    for( i=0;i<(int)cnt;i++ )
    {
	lp16sdlist[i] = MapLS( sdlist[i] );
	if( lp16sdlist[i] == 0 )
	{
	    unmapSurfaceDescArray( i, lp16sdlist );
	    return NULL;
	}
    }
    return lp16sdlist;

} /* mapSurfaceDescArray */

/****************************************************************************
 *
 * SURFACE CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_DestroySurface
 */
DWORD DDAPI _DDHAL_DestroySurface( LPDDHAL_DESTROYSURFACEDATA pdsd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    pdsd->lpDD = pdsd->lpDD->lp16DD;
    psurf_lcl = pdsd->lpDDSurface;
    pdsd->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_DestroySurface( pdsd );

    RESTOREDATAALIAS( psurf_lcl, save );
    return rc;

} /* _DDHAL_DestroySurface */

/*
 * _DDHAL_Flip
 */
DWORD DDAPI _DDHAL_Flip( LPDDHAL_FLIPDATA pfd )
{
    LPDDRAWI_DIRECTDRAW_GBL     lp32DD;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfcurrx;
    LPDDRAWI_DDRAWSURFACE_LCL	psurftargx;
    DWORD			rc;
    LPVOID			save1;
    LPVOID                      save2;

    /*
     * get 16:16 ptrs to original and target surface
     */
    lp32DD = pfd->lpDD;
    pfd->lpDD = pfd->lpDD->lp16DD;
    psurfcurrx = pfd->lpSurfCurr;
    pfd->lpSurfCurr = GETSURFALIAS( psurfcurrx );
    GETDATAALIAS( psurfcurrx, save1 );
    if( pfd->lpSurfTarg != NULL )
    {
	psurftargx = pfd->lpSurfTarg;
	pfd->lpSurfTarg = GETSURFALIAS( psurftargx );
	GETDATAALIAS( psurftargx, save2 );
    }
    else
    {
	psurftargx = NULL;
    }

    /*
     * make the Flip call in the driver
     */
    rc = DDThunk16_Flip( pfd );

    /*
     * restore original ptrs
     */
    RESTOREDATAALIAS( psurfcurrx, save1 );
    if( psurftargx != NULL )
    {
	RESTOREDATAALIAS( psurftargx, save2 );
    }

    pfd->lpDD = lp32DD;
    pfd->lpSurfCurr = psurfcurrx;
    pfd->lpSurfTarg = psurftargx;

    return rc;

} /* _DDHAL_Flip */

/*
 * _DDHAL_Blt
 */
DWORD DDAPI _DDHAL_Blt( LPDDHAL_BLTDATA pbd )
{
    DWORD			flags;
    DWORD			rc;
    LPDDRAWI_DIRECTDRAW_GBL     lp32DD;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfsrcx;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfdestx;
    LPDDRAWI_DDRAWSURFACE_LCL	ppatternsurf_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL	pzsrcsurf_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL	pzdestsurf_lcl;
    #ifdef USE_ALPHA
	LPDDRAWI_DDRAWSURFACE_LCL pasrcsurf_lcl;
	LPDDRAWI_DDRAWSURFACE_LCL padestsurf_lcl;
	LPVOID			saveasrc;
	LPVOID			saveadest;
    #endif
    LPVOID			savesrc;
    LPVOID			savedest;
    LPVOID			savepattern;
    LPVOID			savezsrc;
    LPVOID			savezdest;

    /*
     * get 16:16 ptrs to source and destination surfaces
     */
    lp32DD = pbd->lpDD;
    pbd->lpDD = pbd->lpDD->lp16DD;
    psurfsrcx = pbd->lpDDSrcSurface;
    if( psurfsrcx != NULL )
    {
	pbd->lpDDSrcSurface = GETSURFALIAS( psurfsrcx );
	GETDATAALIAS( psurfsrcx, savesrc );
    }
    psurfdestx = pbd->lpDDDestSurface;
    pbd->lpDDDestSurface = GETSURFALIAS( psurfdestx );
    GETDATAALIAS( psurfdestx, savedest );

    /*
     * see if we need to do any other surface aliases
     */
    flags = pbd->dwFlags;
    if( flags & (DDBLT_ALPHASRCSURFACEOVERRIDE|
    		 DDBLT_ALPHADESTSURFACEOVERRIDE|
		 DDBLT_PRIVATE_ALIASPATTERN |
		 DDBLT_ZBUFFERDESTOVERRIDE |
		 DDBLT_ZBUFFERSRCOVERRIDE ) )
    {

   	#ifdef USE_ALPHA
	    /*
	     * set up 16:16 ptr for alpha src
	     */
	    if( flags & DDBLT_ALPHASRCSURFACEOVERRIDE )
	    {
		pasrcsurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) pbd->bltFX.lpDDSAlphaSrc;
		pbd->bltFX.lpDDSAlphaSrc = GETSURFALIAS( pasrcsurf_lcl );
		GETDATAALIAS( pasrcsurf_lcl, saveasrc );
	    }

	    /*
	     * set up 16:16 ptr for alpha dest
	     */
	    if( flags & DDBLT_ALPHADESTSURFACEOVERRIDE )
	    {
		padestsurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) pbd->bltFX.lpDDSAlphaDest;
		pbd->bltFX.lpDDSAlphaDest = GETSURFALIAS( padestsurf_lcl );
		GETDATAALIAS( padestsurf_lcl, saveadest );
	    }
	#endif

	/*
	 * set up 16:16 ptr for pattern
	 */
	if( flags & DDBLT_PRIVATE_ALIASPATTERN )
	{
	    ppatternsurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) pbd->bltFX.lpDDSPattern;
	    pbd->bltFX.lpDDSPattern = GETSURFALIAS( ppatternsurf_lcl );
	    GETDATAALIAS( ppatternsurf_lcl, savepattern );
	}

	/*
	 * set up 16:16 ptr for Z Buffer src
	 */
	if( flags & DDBLT_ZBUFFERSRCOVERRIDE )
	{
	    pzsrcsurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) pbd->bltFX.lpDDSZBufferSrc;
	    pbd->bltFX.lpDDSZBufferSrc = GETSURFALIAS( pzsrcsurf_lcl );
	    GETDATAALIAS( pzsrcsurf_lcl, savezsrc );
	}

	/*
	 * set up 16:16 ptr for Z Buffer dest
	 */
	if( flags & DDBLT_ZBUFFERDESTOVERRIDE )
	{
	    pzdestsurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) pbd->bltFX.lpDDSZBufferDest;
	    pbd->bltFX.lpDDSZBufferDest = GETSURFALIAS( pzdestsurf_lcl );
	    GETDATAALIAS( pzdestsurf_lcl, savezdest );
	}
    }

    /*
     * make the Blt call in the driver
     */
    rc = DDThunk16_Blt( pbd );

    /*
     * see if we need to restore any surface ptrs
     */
    if( flags & (DDBLT_ALPHASRCSURFACEOVERRIDE|
    		 DDBLT_ALPHADESTSURFACEOVERRIDE|
		 DDBLT_PRIVATE_ALIASPATTERN |
		 DDBLT_ZBUFFERDESTOVERRIDE |
		 DDBLT_ZBUFFERSRCOVERRIDE ) )
    {
	#ifdef USE_ALPHA
	    if( flags & DDBLT_ALPHASRCSURFACEOVERRIDE )
	    {
		pbd->bltFX.lpDDSAlphaSrc = (LPDIRECTDRAWSURFACE) pasrcsurf_lcl;
		RESTOREDATAALIAS( pasrcsurf_lcl, saveasrc );
	    }
	    if( flags & DDBLT_ALPHADESTSURFACEOVERRIDE )
	    {
		pbd->bltFX.lpDDSAlphaDest = (LPDIRECTDRAWSURFACE) padestsurf_lcl;
		RESTOREDATAALIAS( padestsurf_lcl, saveadest );
	    }
	#endif
	if( flags & DDBLT_PRIVATE_ALIASPATTERN )
	{
	    pbd->bltFX.lpDDSPattern = (LPDIRECTDRAWSURFACE) ppatternsurf_lcl;
	    RESTOREDATAALIAS( ppatternsurf_lcl, savepattern );
	}
	if( flags & DDBLT_ZBUFFERSRCOVERRIDE )
	{
	    pbd->bltFX.lpDDSZBufferSrc = (LPDIRECTDRAWSURFACE) pzsrcsurf_lcl;
	    RESTOREDATAALIAS( pzsrcsurf_lcl, savezsrc );
	}
	if( flags & DDBLT_ZBUFFERDESTOVERRIDE )
	{
	    pbd->bltFX.lpDDSZBufferDest = (LPDIRECTDRAWSURFACE) pzdestsurf_lcl;
	    RESTOREDATAALIAS( pzdestsurf_lcl, savezdest );
	}
    }

    if( psurfsrcx != NULL )
    {
	RESTOREDATAALIAS( psurfsrcx, savesrc );
    }
    RESTOREDATAALIAS( psurfdestx, savedest );

    pbd->lpDD = lp32DD;
    pbd->lpDDSrcSurface = psurfsrcx;
    pbd->lpDDDestSurface = psurfdestx;

    return rc;

} /* _DDHAL_Blt */

/*
 * _DDHAL_Lock
 */
DWORD DDAPI _DDHAL_Lock( LPDDHAL_LOCKDATA pld )
{
    LPDDRAWI_DIRECTDRAW_GBL     lp32DD;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    lp32DD = pld->lpDD;
    pld->lpDD = pld->lpDD->lp16DD;
    psurf_lcl = pld->lpDDSurface;
    pld->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_Lock( pld );

    RESTOREDATAALIAS( psurf_lcl, save );

    pld->lpDD = lp32DD;
    pld->lpDDSurface = psurf_lcl;

    return rc;

} /* _DDHAL_Lock */

/*
 * _DDHAL_Unlock
 */
DWORD DDAPI _DDHAL_Unlock( LPDDHAL_UNLOCKDATA puld )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    puld->lpDD = puld->lpDD->lp16DD;
    psurf_lcl = puld->lpDDSurface;
    puld->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_Unlock( puld );

    RESTOREDATAALIAS( psurf_lcl, save );

    return rc;

} /* _DDHAL_UnLock */

/*
 * _DDHAL_AddAttachedSurface
 */
DWORD DDAPI _DDHAL_AddAttachedSurface( LPDDHAL_ADDATTACHEDSURFACEDATA paasd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfattachedx;
    DWORD			rc;
    LPVOID			save;
    LPVOID			saveattached;

    /*
     * get 16:16 ptrs to surface and surface to become attached
     */
    paasd->lpDD = paasd->lpDD->lp16DD;
    psurf_lcl = paasd->lpDDSurface;
    paasd->lpDDSurface = GETSURFALIAS( psurf_lcl );
    GETDATAALIAS( psurf_lcl, save );

    psurfattachedx = paasd->lpSurfAttached;
    paasd->lpSurfAttached = GETSURFALIAS( psurfattachedx );
    GETDATAALIAS( psurfattachedx, saveattached );

    /*
     * make the AddAttachedSurface call in the driver
     */
    rc = DDThunk16_AddAttachedSurface( paasd );

    /*
     * restore any ptrs
     */
    RESTOREDATAALIAS( psurf_lcl, save );
    RESTOREDATAALIAS( psurfattachedx, saveattached );

    return rc;

} /* _DDHAL_AddAttachedSurface */

/*
 * _DDHAL_SetColorKey
 */
DWORD DDAPI _DDHAL_SetColorKey( LPDDHAL_SETCOLORKEYDATA psckd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    psckd->lpDD = psckd->lpDD->lp16DD;
    psurf_lcl = psckd->lpDDSurface;
    psckd->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_SetColorKey( psckd );

    RESTOREDATAALIAS( psurf_lcl, save );

    return rc;

} /* _DDHAL_SetColorKey */

/*
 * _DDHAL_SetClipList
 */
DWORD DDAPI _DDHAL_SetClipList( LPDDHAL_SETCLIPLISTDATA pscld )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    pscld->lpDD = pscld->lpDD->lp16DD;
    psurf_lcl = pscld->lpDDSurface;
    pscld->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_SetClipList( pscld );

    RESTOREDATAALIAS( psurf_lcl, save );

    return rc;

} /* _DDHAL_SetClipList */

/*
 * _DDHAL_UpdateOverlay
 */
DWORD DDAPI _DDHAL_UpdateOverlay( LPDDHAL_UPDATEOVERLAYDATA puod )
{
    DWORD			rc;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfdestx;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfsrcx;
    #ifdef USE_ALPHA
	LPDDRAWI_DDRAWSURFACE_LCL psurfalphadestx;
	LPDDRAWI_DDRAWSURFACE_LCL psurfalphasrcx;
	LPVOID			savealphadest;
	LPVOID			savealphasrc;
    #endif
    LPVOID			savedest;
    LPVOID			savesrc;

    /*
     * get 16:16 ptrs to the dest surface and the overlay surface
     */
    puod->lpDD = puod->lpDD->lp16DD;
    psurfsrcx = puod->lpDDSrcSurface;
    puod->lpDDSrcSurface = GETSURFALIAS( psurfsrcx );
    psurfdestx = puod->lpDDDestSurface;
    puod->lpDDDestSurface = GETSURFALIAS( psurfdestx );
    GETDATAALIAS( psurfsrcx, savesrc );
    GETDATAALIAS( psurfdestx, savedest );

    #ifdef USE_ALPHA
	/*
	 * set up 16:16 ptr for alpha
	 */
	if( puod->dwFlags & DDOVER_ALPHASRCSURFACEOVERRIDE )
	{
	    psurfalphasrcx = (LPDDRAWI_DDRAWSURFACE_LCL) puod->overlayFX.lpDDSAlphaSrc;
	    puod->overlayFX.lpDDSAlphaSrc = GETSURFALIAS( psurfalphasrcx );
	    GETDATAALIAS( psurfalphasrcx, savealphasrc );
	}

	if( puod->dwFlags & DDOVER_ALPHADESTSURFACEOVERRIDE )
	{
	    psurfalphadestx = (LPDDRAWI_DDRAWSURFACE_LCL) puod->overlayFX.lpDDSAlphaDest;
	    puod->overlayFX.lpDDSAlphaDest = GETSURFALIAS( psurfalphadestx );
	    GETDATAALIAS( psurfalphadestx, savealphadest );
	}
    #endif

    /*
     * make the UpdateOverlay call in the driver
     */
    rc = DDThunk16_UpdateOverlay( puod );

    /*
     * restore any surfaces
     */
    #ifdef USE_ALPHA
	if( puod->dwFlags & DDOVER_ALPHASRCSURFACEOVERRIDE )
	{
	    puod->overlayFX.lpDDSAlphaSrc = (LPDIRECTDRAWSURFACE) psurfalphasrcx;
	    RESTOREDATAALIAS( psurfalphasrcx, savealphasrc );
	}
	if( puod->dwFlags & DDOVER_ALPHADESTSURFACEOVERRIDE )
	{
	    puod->overlayFX.lpDDSAlphaDest = (LPDIRECTDRAWSURFACE) psurfalphadestx;
	    RESTOREDATAALIAS( psurfalphadestx, savealphadest );
	}
    #endif
    RESTOREDATAALIAS( psurfsrcx, savesrc );
    RESTOREDATAALIAS( psurfdestx, savedest );
    return rc;

} /* _DDHAL_UpdateOverlay */

/*
 * _DDHAL_SetOverlayPosition
 */
DWORD DDAPI _DDHAL_SetOverlayPosition( LPDDHAL_SETOVERLAYPOSITIONDATA psopd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurfdestx;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfsrcx;
    DWORD			rc;
    LPVOID			savedest;
    LPVOID			savesrc;

    /*
     * get 16:16 ptrs to the dest surface and the overlay surface
     */
    psopd->lpDD = psopd->lpDD->lp16DD;
    psurfsrcx = psopd->lpDDSrcSurface;
    psopd->lpDDSrcSurface = GETSURFALIAS( psurfsrcx );
    psurfdestx = psopd->lpDDDestSurface;
    psopd->lpDDDestSurface = GETSURFALIAS( psurfdestx );
    GETDATAALIAS( psurfsrcx, savesrc );
    GETDATAALIAS( psurfdestx, savedest );

    /*
     * make the SetOverlayPosition call in the driver
     */
    rc = DDThunk16_SetOverlayPosition( psopd );

    /*
     * restore any surfaces
     */
    RESTOREDATAALIAS( psurfsrcx, savesrc );
    RESTOREDATAALIAS( psurfdestx, savedest );
    return rc;

} /* _DDHAL_SetOverlayPosition */

/*
 * _DDHAL_SetPalette
 */
DWORD DDAPI _DDHAL_SetPalette( LPDDHAL_SETPALETTEDATA pspd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    /*
     * get 16:16 ptrs
     */
    pspd->lpDD = pspd->lpDD->lp16DD;
    psurf_lcl = pspd->lpDDSurface;
    pspd->lpDDSurface = GETSURFALIAS( psurf_lcl );
    pspd->lpDDPalette = (LPDDRAWI_DDRAWPALETTE_GBL) MapLS( pspd->lpDDPalette );
    if( pspd->lpDDPalette == NULL )
    {
	pspd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }
    GETDATAALIAS( psurf_lcl, save );

    /*
     * make the SetPalette call in the driver
     */
    rc = DDThunk16_SetPalette( pspd );

    /*
     * clean up any 16:16 ptrs
     */
    UnMapLS( (DWORD) pspd->lpDDPalette );
    RESTOREDATAALIAS( psurf_lcl, save );
    return rc;

} /* _DDHAL_SetPalette */

/*
 * _DDHAL_GetBltStatus
 */
DWORD DDAPI _DDHAL_GetBltStatus( LPDDHAL_GETBLTSTATUSDATA pgbsd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    pgbsd->lpDD = pgbsd->lpDD->lp16DD;
    psurf_lcl = pgbsd->lpDDSurface;
    pgbsd->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_GetBltStatus( pgbsd );

    RESTOREDATAALIAS( psurf_lcl, save );
    return rc;

} /* _DDHAL_GetBltStatus */

/*
 * _DDHAL_GetFlipStatus
 */
DWORD DDAPI _DDHAL_GetFlipStatus( LPDDHAL_GETFLIPSTATUSDATA pgfsd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    pgfsd->lpDD = pgfsd->lpDD->lp16DD;
    psurf_lcl = pgfsd->lpDDSurface;
    pgfsd->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_GetFlipStatus( pgfsd );

    RESTOREDATAALIAS( psurf_lcl, save );

    return rc;

} /* _DDHAL_GetFlipStatus */

/****************************************************************************
 *
 * EXECUTE BUFFER CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_CanCreateExecuteBuffer
 *
 * NOTE: Dummy entry point just to keep DOHALCALL happy. Execute buffer
 * entry points must be 32-bit, no thunking support is provided.
 */
DWORD DDAPI _DDHAL_CanCreateExecuteBuffer( LPDDHAL_CANCREATESURFACEDATA pccsd )
{
    pccsd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_CanCreateExecuteBuffer */

/*
 * _DDHAL_CreateExecuteBuffer
 *
 * NOTE: Dummy entry point just to keep DOHALCALL happy. Execute buffer
 * entry points must be 32-bit, no thunking support is provided.
 */
DWORD DDAPI _DDHAL_CreateExecuteBuffer( LPDDHAL_CREATESURFACEDATA pcsd )
{
    pcsd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_CreateExecuteBuffer */

/*
 * NOTE: All these babies are dummy entry points. They are only here to keep
 * DOHALCALL happy. Execute buffer HAL functions must be true 32-bit code.
 * No thunking support is offered.
 */

/*
 * _DDHAL_DestroyExecuteBuffer
 */
DWORD DDAPI _DDHAL_DestroyExecuteBuffer( LPDDHAL_DESTROYSURFACEDATA pdsd )
{
    pdsd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_DestroySurface */

/*
 * _DDHAL_LockExecuteBuffer
 */
DWORD DDAPI _DDHAL_LockExecuteBuffer( LPDDHAL_LOCKDATA pld )
{
    pld->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_Lock */

/*
 * _DDHAL_UnlockExecuteBuffer
 */
DWORD DDAPI _DDHAL_UnlockExecuteBuffer( LPDDHAL_UNLOCKDATA puld )
{
    puld->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_UnlockExecuteBuffer */

/****************************************************************************
 *
 * VIDEO PORT CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_GetVideoPortConnectionGUID
 *
 * NOTE: Dummy entry point just to keep DOHALCALL happy. Video Port
 * entry points must be 32-bit, no thunking support is provided.
 */
DWORD DDAPI _DDHAL_GetVideoPortConnectInfo( LPDDHAL_GETVPORTCONNECTDATA lpGetTypeData )
{
    lpGetTypeData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortTypeGUID */

/*
 * _DDHAL_CanCreateVideoPort
 */
DWORD DDAPI _DDHAL_CanCreateVideoPort( LPDDHAL_CANCREATEVPORTDATA lpCanCreateData )
{
    lpCanCreateData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_CanCreateVideoPort */

/*
 * _DDHAL_CreateVideoPort
 */
DWORD DDAPI _DDHAL_CreateVideoPort( LPDDHAL_CREATEVPORTDATA lpCreateData )
{
    lpCreateData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_CreateVideoPort */

/*
 * _DDHAL_DestroyVideoPort
 */
DWORD DDAPI _DDHAL_DestroyVideoPort( LPDDHAL_DESTROYVPORTDATA lpDestroyData )
{
    lpDestroyData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_DestroyVideoPort */

/*
 * _DDHAL_GetVideoPortInputFormats
 */
DWORD DDAPI _DDHAL_GetVideoPortInputFormats( LPDDHAL_GETVPORTINPUTFORMATDATA lpGetFormatData )
{
    lpGetFormatData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortInputFormats */

/*
 * _DDHAL_GetVideoPortOutputFormats
 */
DWORD DDAPI _DDHAL_GetVideoPortOutputFormats( LPDDHAL_GETVPORTOUTPUTFORMATDATA lpGetFormatData )
{
    lpGetFormatData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortOutputFormats */

/*
 * _DDHAL_GetVideoPortBandwidthInfo
 */
DWORD DDAPI _DDHAL_GetVideoPortBandwidthInfo( LPDDHAL_GETVPORTBANDWIDTHDATA lpGetBandwidthData )
{
    lpGetBandwidthData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortBandwidthInfo */

/*
 * _DDHAL_UpdateVideoPort
 */
DWORD DDAPI _DDHAL_UpdateVideoPort( LPDDHAL_UPDATEVPORTDATA lpUpdateData )
{
    lpUpdateData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_UpdateVideoPort */

/*
 * _DDHAL_GetVideoPortField
 */
DWORD DDAPI _DDHAL_GetVideoPortField( LPDDHAL_GETVPORTFIELDDATA lpGetFieldData )
{
    lpGetFieldData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortField */

/*
 * _DDHAL_GetVideoPortLine
 */
DWORD DDAPI _DDHAL_GetVideoPortLine( LPDDHAL_GETVPORTLINEDATA lpGetLineData )
{
    lpGetLineData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortLine */

/*
 * _DDHAL_WaitForVideoPortSync
 */
DWORD DDAPI _DDHAL_WaitForVideoPortSync( LPDDHAL_WAITFORVPORTSYNCDATA lpWaitSyncData )
{
    lpWaitSyncData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_WaitForVideoPortSync */

/*
 * _DDHAL_FlipVideoPort
 */
DWORD DDAPI _DDHAL_FlipVideoPort( LPDDHAL_FLIPVPORTDATA lpFlipData )
{
    lpFlipData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_FlipVideoPort */

/*
 * _DDHAL_GetVideoPortFlipStatus
 */
DWORD DDAPI _DDHAL_GetVideoPortFlipStatus( LPDDHAL_GETVPORTFLIPSTATUSDATA lpFlipData )
{
    lpFlipData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortFlipStatus */

/*
 * _DDHAL_GetVideoSignalStatus
 */
DWORD DDAPI _DDHAL_GetVideoSignalStatus( LPDDHAL_GETVPORTSIGNALDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoSignalStatus */

/*
 * _DDHAL_VideoColorControl
 */
DWORD DDAPI _DDHAL_VideoColorControl( LPDDHAL_VPORTCOLORDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_VideoColorControl */

/****************************************************************************
 *
 * COLORCONTROL CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_ColorControl
 */
DWORD DDAPI _DDHAL_ColorControl( LPDDHAL_COLORCONTROLDATA pccd )
{
    LPDDRAWI_DIRECTDRAW_GBL     lp32DD;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf;
    LPVOID			save1;
    DWORD			rc;

    /*
     * get 16:16 ptr to surface
     */
    lp32DD = pccd->lpDD;
    pccd->lpDD = pccd->lpDD->lp16DD;
    psurf = pccd->lpDDSurface;
    pccd->lpDDSurface = GETSURFALIAS( psurf );
    GETDATAALIAS( psurf, save1 );

    /*
     * make the ColorControl call in the driver
     */
    rc = DDThunk16_ColorControl( pccd );

    /*
     * restore original ptrs
     */
    RESTOREDATAALIAS( psurf, save1 );

    pccd->lpDD = lp32DD;
    pccd->lpDDSurface = psurf;

    return rc;

} /* _DDHAL_ColorControl */

/****************************************************************************
 *
 * KERNEL CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_SyncSurfaceData
 */
DWORD DDAPI _DDHAL_SyncSurfaceData( LPDDHAL_SYNCSURFACEDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_SyncSurfaceData */

/*
 * _DDHAL_SyncVideoPortData
 */
DWORD DDAPI _DDHAL_SyncVideoPortData( LPDDHAL_SYNCVIDEOPORTDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_SyncVideoPortData */

/****************************************************************************
 *
 * MOTION COMP CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_GetMoCompGuids
 */
DWORD DDAPI _DDHAL_GetMoCompGuids( LPDDHAL_GETMOCOMPGUIDSDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoGuids */

/*
 * _DDHAL_GetMoCompFormats
 */
DWORD DDAPI _DDHAL_GetMoCompFormats( LPDDHAL_GETMOCOMPFORMATSDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetMoCompFormats */

/*
 * _DDHAL_CreateMoComp
 */
DWORD DDAPI _DDHAL_CreateMoComp( LPDDHAL_CREATEMOCOMPDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_CreateMoComp */

/*
 * _DDHAL_GetMoCompBuffInfo
 */
DWORD DDAPI _DDHAL_GetMoCompBuffInfo( LPDDHAL_GETMOCOMPCOMPBUFFDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetMoCompBuffInfo */

/*
 * _DDHAL_GetInternalMoCompInfo
 */
DWORD DDAPI _DDHAL_GetInternalMoCompInfo( LPDDHAL_GETINTERNALMOCOMPDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetInternalMoCompInfo */

/*
 * _DDHAL_DestroyMoComp
 */
DWORD DDAPI _DDHAL_DestroyMoComp( LPDDHAL_DESTROYMOCOMPDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_DestroyMoComp */

/*
 * _DDHAL_BeginMoCompFrame
 */
DWORD DDAPI _DDHAL_BeginMoCompFrame( LPDDHAL_BEGINMOCOMPFRAMEDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_BeginMoCompFrame */

/*
 * _DDHAL_EndMoCompFrame
 */
DWORD DDAPI _DDHAL_EndMoCompFrame( LPDDHAL_ENDMOCOMPFRAMEDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_EndMoCompFrame */

/*
 * _DDHAL_RenderMoComp
 */
DWORD DDAPI _DDHAL_RenderMoComp( LPDDHAL_RENDERMOCOMPDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_RenderMoComp */

/*
 * _DDHAL_QueryMoCompStatus
 */
DWORD DDAPI _DDHAL_QueryMoCompStatus( LPDDHAL_QUERYMOCOMPSTATUSDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_QueryMoCompStatus */

/****************************************************************************
 *
 * PALETTE CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_DestroyPalette
 */
DWORD DDAPI _DDHAL_DestroyPalette( LPDDHAL_DESTROYPALETTEDATA pdpd )
{
    DWORD	rc;

    /*
     * get 16:16 ptrs
     */
    pdpd->lpDD = pdpd->lpDD->lp16DD;
    pdpd->lpDDPalette = (LPDDRAWI_DDRAWPALETTE_GBL) MapLS( pdpd->lpDDPalette );
    if( pdpd->lpDDPalette == NULL )
    {
	pdpd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }

    /*
     * make the DestroyPalette call in the driver
     */
    rc = DDThunk16_DestroyPalette( pdpd );

    /*
     * clean up any 16:16 ptrs
     */
    UnMapLS( (DWORD) pdpd->lpDDPalette );
    return rc;

} /* _DDHAL_DestroyPalette */

/*
 * _DDHAL_SetEntries
 */
DWORD DDAPI _DDHAL_SetEntries( LPDDHAL_SETENTRIESDATA psed )
{
    DWORD	rc;

    /*
     * get 16:16 ptrs
     */
    psed->lpDD = psed->lpDD->lp16DD;
    psed->lpDDPalette = (LPDDRAWI_DDRAWPALETTE_GBL) MapLS( psed->lpDDPalette );
    if( psed->lpDDPalette == NULL )
    {
	psed->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }

    /*
     * make the DestroyPalette call in the driver
     */
    rc = DDThunk16_SetEntries( psed );

    /*
     * clean up any 16:16 ptrs
     */
    UnMapLS( (DWORD) psed->lpDDPalette );
    return rc;

} /* _DDHAL_SetEntries */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\win9x\thktypes.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       thktypes.h
 *  Content:	base types used by thunk compiler
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   26-feb-95	craige	split out of ddraw\types.h
 *   22-jun-95	craige	added RECT
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
typedef unsigned short USHORT;
typedef          short  SHORT;
typedef unsigned long  ULONG;
typedef          long   LONG;
typedef unsigned int   UINT;
typedef          int    INT;
typedef unsigned char  UCHAR;
typedef hinstance HINSTANCE;
typedef		int	BOOL;

typedef void    VOID;
typedef void   *PVOID;
typedef void   *LPVOID;
typedef UCHAR   BYTE;
typedef USHORT  WORD;
typedef ULONG   DWORD;
typedef UINT    HANDLE;
typedef char   *LPSTR;
typedef BYTE   *PBYTE;
typedef BYTE   *LPBYTE;
typedef USHORT  SEL;
typedef INT    *LPINT;
typedef UINT   *LPUINT;
typedef DWORD  *LPDWORD;
typedef LONG   *LPLONG;
typedef WORD   *LPWORD;

typedef HANDLE  HWND;
typedef HANDLE  HDC;
typedef HANDLE  HBRUSH;
typedef HANDLE  HBITMAP;
typedef HANDLE  HRGN;
typedef HANDLE  HFONT;
typedef HANDLE  HCURSOR;
typedef HANDLE  HMENU;
typedef HANDLE  HPEN;
typedef HANDLE  HICON;
typedef HANDLE  HUSER;      /* vanilla user handle */
typedef HANDLE  HPALETTE;
typedef HANDLE  HMF;
typedef HANDLE  HEMF;
typedef HANDLE	HCOLORSPACE;
typedef HANDLE  HMEM;
typedef HANDLE  HGDI;       /* vanilla gdi handle */
typedef HANDLE  HGLOBAL;
typedef HANDLE  HRSRC;
typedef HANDLE  HACCEL;

typedef WORD    ATOM;

typedef struct tagRECTL {
    LONG         left;
    LONG         top;
    LONG         right;
    LONG         bottom;
} RECTL;
typedef RECTL *LPRECTL;

typedef struct tagRECT {
    UINT         left;
    UINT         top;
    UINT         right;
    UINT         bottom;
} RECT;
typedef RECT *LPRECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\win9x\types.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       types.h
 *  Content:	types used by thunk compiler
 *		** REMEMBER TO KEEP UP TO DATE WITH DDRAWI.H AND DDRAW.H **
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   26-feb-95	craige	split out base types
 *   03-mar-95	craige	WaitForVerticalBlank stuff
 *   11-mar-95	craige	palette stuff
 *   28-mar-95	craige	added dwBase to DDHAL_SETENTRIESDATA
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	added dwVidMemTotal, dwVidMemFree to DDCAPS
 *   14-may-95	craige	cleaned out obsolete junk
 *   24-may-95  kylej   removed obsolete ZOrder variables
 *   28-may-95	craige	cleaned up HAL: added GetBltStatus; GetFlipStatus;
 *			GetScanLine
 *   30-jun-95	craige	new fields in DDCAPS; cleanup
 *   02-jul-95	craige	added DEVMODE
 *   10-jul-95	craige	support SetOverlayPosition
 *   13-jul-95	craige	Get/SetOverlayPosition take LONGs
 *   14-jul-95	craige	added dwFlags to DDOVERLAYFX
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   02-aug-95	craige	added dwMinOverlayStretch/dwMaxOverlayStretch to DDCAPS
 *   13-aug-95	craige	added dwCaps2 and reserved fields to DDCAPS
 *   09-dec-95  colinmc execute buffer support
 *   13-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *   01-oct-96	ketand	added GetAvailDriverMemory
 *   20-jan-97  colinmc update non-local heap data
 *   08-mar-97  colinmc DDCAPS is now an API visible structure only.
 *                      DDCORECAPS is now passed in its place.
 *
 ***************************************************************************/
#include "thktypes.h"

typedef long	HRESULT;		// return values

/*
 * DDRAW.H STRUCTS FOLLOW
 */
typedef struct _DDSCAPS
{
    DWORD	dwCaps; 	// capabilities of surface wanted
} DDSCAPS;

typedef DDSCAPS * LPDDSCAPS;

typedef struct
{
    DWORD	dwSize; 	// size of structure
    DWORD	dwFlags;	// pixel format flags
    DWORD	dwFourCC;	// (FOURCC code)
    DWORD	dwBitCount;	// how many bits for alpha/z surfaces
    DWORD	dwRBitMask;	// mask for red bits
    DWORD	dwGBitMask;	// mask for green bits
    DWORD	dwBBitMask;	// mask for blue bits
    DWORD	dwRGBAlphaBitMask;// mask for alpha channel
} DDPIXELFORMAT;

typedef DDPIXELFORMAT * LPDDPIXELFORMAT;

typedef struct
{
    DWORD	dwColorSpaceLowValue;	// low boundary of color space that is to
    					// be treated as Color Key, inclusive
    DWORD	dwColorSpaceHighValue;	// high boundary of color space that is
    					// to be treated as Color Key, inclusive
} DDCOLORKEY;

typedef DDCOLORKEY * LPDDCOLORKEY;

typedef struct _DDSURFACEDESC
{
    DWORD		dwSize;			// size of the DDSURFACEDESC structure
    DWORD		dwFlags;		// determines what fields are valid
    DWORD		dwHeight;		// height of surface to be created
    DWORD		dwWidth;		// width of input surface
    LONG		lPitch;			// distance to start of next line (return value)
    DWORD		dwBackBufferCount;	// number of back buffers requested
    DWORD		dwZBufferBitDepth;	// depth of Z buffer requested
    DWORD		dwAlphaBitDepth;	// depth of alpha buffer requested
    DWORD		dwCompositionOrder;	// blt order for the surface, 0 is background
    DWORD		hWnd;			// window handle associated with surface
    DWORD		lpSurface;		// pointer to an associated surface memory
    DDCOLORKEY		ddckCKDestOverlay;	// color key for destination overlay use
    DDCOLORKEY		ddckCKDestBlt;		// color key for destination blt use
    DDCOLORKEY		ddckCKSrcOverlay;	// color key for source overlay use
    DDCOLORKEY		ddckCKSrcBlt;		// color key for source blt use
    DWORD		lpClipList;		// clip list (return value)
    DWORD		lpDDSurface;		// pointer to DirectDraw Surface struct (return value)
    DDPIXELFORMAT	ddpfPixelFormat; 	// pixel format description of the surface
    DDSCAPS		ddsCaps;		// direct draw surface capabilities
} DDSURFACEDESC;
typedef DDSURFACEDESC *LPDDSURFACEDESC;

typedef struct _DDCORECAPS
{
    DWORD	dwSize;			// size of the DDDRIVERCAPS structure
    DWORD	dwCaps;			// driver specific capabilities
    DWORD	dwCaps2;		// more driver specific capabilites
    DWORD	dwCKeyCaps;		// color key capabilities of the surface
    DWORD	dwFXCaps;		// driver specific stretching and effects capabilites
    DWORD	dwFXAlphaCaps;		// alpha driver specific capabilities
    DWORD	dwPalCaps;		// palette capabilities
    DWORD	dwSVCaps;		// stereo vision capabilities
    DWORD	dwAlphaBltConstBitDepths;	// DDBD_2,4,8
    DWORD	dwAlphaBltPixelBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaBltSurfaceBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaOverlayConstBitDepths;	// DDBD_2,4,8
    DWORD	dwAlphaOverlayPixelBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD	dwZBufferBitDepths;		// DDBD_8,16,24,32
    DWORD	dwVidMemTotal;		// total amount of video memory
    DWORD	dwVidMemFree;		// amount of free video memory
    DWORD	dwMaxVisibleOverlays;	// maximum number of visible overlays
    DWORD	dwCurrVisibleOverlays;	// current number of visible overlays
    DWORD	dwNumFourCCCodes;	// number of four cc codes
    DWORD	dwAlignBoundarySrc;	// source rectangle alignment
    DWORD	dwAlignSizeSrc;		// source rectangle byte size
    DWORD	dwAlignBoundaryDest;	// dest rectangle alignment
    DWORD	dwAlignSizeDest;	// dest rectangle byte size
    DWORD	dwAlignStrideAlign;	// stride alignment
    DWORD	dwRops[8];		// ROPS supported
    DDSCAPS	ddsCaps;		// DDSCAPS structure has all the general capabilities
    DWORD	dwMinOverlayStretch;	// minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxOverlayStretch;	// maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMinLiveVideoStretch;	// minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxLiveVideoStretch;	// maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMinHwCodecStretch;	// minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxHwCodecStretch;	// maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwReserved1;		// reserved
    DWORD	dwReserved2;		// reserved
    DWORD	dwReserved3;		// reserved
} DDCORECAPS;

typedef struct _DDBLTFX
{
    DWORD	dwSize;				// size of structure
    DWORD	dwDDFX;				// FX operations
    DWORD	dwROP;				// Win32 raster operations
    DWORD	dwDDROP;			// Raster operations new for DirectDraw
    DWORD	dwRotationAngle;		// Rotation angle for blt
    DWORD	dwZBufferOpCode;		// ZBuffer compares
    DWORD	dwZBufferLow;			// Low limit of Z buffer
    DWORD	dwZBufferHigh;			// High limit of Z buffer
    DWORD	dwZBufferBaseDest;		// Destination base value
    DWORD	dwConstZDestBitDepth;		// Bit depth used to specify Z constant for destination
    DWORD	dwConstZDest;			// Constant to use as Z buffer for dest
    DWORD	dwConstZSrcBitDepth;		// Bit depth used to specify Z constant for source
    DWORD	dwConstZSrc;			// Constant to use as Z buffer for src
    DWORD	dwAlphaEdgeBlendBitDepth;	// Bit depth used to specify constant for alpha edge blend
    DWORD	dwAlphaEdgeBlend;		// Alpha for edge blending
    DWORD	dwReserved;
    DWORD	dwConstAlphaDestBitDepth;	// Bit depth used to specify alpha constant for destination
    DWORD	dwConstAlphaDest;		// Constant to use as Alpha Channel
    DWORD	dwConstAlphaSrcBitDepth;	// Bit depth used to specify alpha constant for source
    DWORD	dwConstAlphaSrc;		// Constant to use as Alpha Channel
    DWORD	dwFillColor;			// color in RGB or Palettized
    DDCOLORKEY	ddckDestColorkey;		// DestColorkey override
    DDCOLORKEY	ddckSrcColorkey;		// SrcColorkey override
} DDBLTFX;
typedef DDBLTFX *LPDDBLTFX;

typedef struct _DDOVERLAYFX
{
    DWORD	dwSize; 			// size of structure
    DWORD	dwAlphaEdgeBlendBitDepth;	// Bit depth used to specify constant for alpha edge blend
    DWORD	dwAlphaEdgeBlend;		// Constant to use as alpha for edge blend
    DWORD	dwReserved;
    DWORD	dwConstAlphaDestBitDepth;	// Bit depth used to specify alpha constant for destination
    DWORD	alphaDest; 			// alpha src (const or surface)
    DWORD	dwConstAlphaSrcBitDepth;	// Bit depth used to specify alpha constant for source
    DWORD	alphaSrc; 			// alpha src (const or surface)
    DDCOLORKEY	dckDestColorkey;		// DestColorkey override
    DDCOLORKEY	dckSrcColorkey;			// DestColorkey override
    DWORD       dwDDFX;                         // Overlay FX
    DWORD	dwFlags;			// flags
} DDOVERLAYFX;
typedef DDOVERLAYFX *LPDDOVERLAYFX;

/*
 * DDBLTBATCH: BltBatch entry structure
 */
typedef struct _DDBLTBATCH
{
    DWORD		lprDest;
    DWORD		lpDDSSrc;
    DWORD		lprSrc;
    DWORD		dwFlags;
    DWORD		lpDDBltFx;
} DDBLTBATCH;
typedef DDBLTBATCH * LPDDBLTBATCH;


/*
 * Note this is intentionally different from but equivalent to the defn in dmemmgr.h
 * The thunk compiler barfs on nameless unions.
 */
typedef struct _SURFACEALIGNMENT
{
    DWORD       dwStartOrXAlignment;
    DWORD       dwPitchOrYAlignment;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
} SURFACEALIGNMENT;
typedef SURFACEALIGNMENT * LPSURFACEALIGNMENT;

/*
 * DDRAWI.H STRUCTS FOLLOW
 */
typedef unsigned long	FLATPTR;

typedef struct _VIDMEM
{
    DWORD		dwFlags;	//flags
    FLATPTR		fpStart;	// start of memory chunk
    FLATPTR		fpEnd;		// end of memory chunk
    DDSCAPS		ddCaps;		// what this memory CANNOT be used for
    DDSCAPS		ddCapsAlt;	// what this memory CANNOT be used for if it must
    DWORD		lpHeap;		// heap pointer, used by DDRAW
} VIDMEM;
typedef VIDMEM *LPVIDMEM;

typedef struct _VIDMEMINFO
{
    FLATPTR		fpPrimary;		// pointer to primary surface
    DWORD		dwFlags;		// flags
    DWORD		dwDisplayWidth;		// current display width
    DWORD		dwDisplayHeight;	// current display height
    LONG		lDisplayPitch;		// current display pitch
    DDPIXELFORMAT	ddpfDisplay;		// pixel format of display
    DWORD		dwOffscreenAlign;	// byte alignment for offscreen surfaces
    DWORD		dwOverlayAlign;		// byte alignment for overlays
    DWORD		dwTextureAlign;		// byte alignment for textures
    DWORD		dwZBufferAlign;		// byte alignment for z buffers
    DWORD		dwAlphaAlign;		// byte alignment for alpha
    DWORD		dwNumHeaps;		// number of memory heaps in vmList
    LPVIDMEM		pvmList;		// array of heaps
} VIDMEMINFO;
typedef VIDMEMINFO *LPVIDMEMINFO;

typedef struct _DDHAL_DDCALLBACKS
{
    DWORD	dwSize;
    DWORD	dwFlags;
    DWORD	DestroyDriver;
    DWORD	CreateSurface;
    DWORD	SetColorKey;
    DWORD	SetMode;
    DWORD	WaitForVerticalBlank;
    DWORD	CanCreateSurface;
    DWORD	CreatePalette;
    DWORD	GetScanLine;
    DWORD       SetExclusiveMode;
    DWORD       FlipToGDISurface;
} DDHAL_DDCALLBACKS;

typedef DDHAL_DDCALLBACKS *LPDDHAL_DDCALLBACKS;

typedef struct _DDHAL_DDSURFACECALLBACKS
{
    DWORD	dwSize;
    DWORD	dwFlags;
    DWORD	DestroySurface;
    DWORD	Flip;
    DWORD	SetClipList;
    DWORD	Lock;
    DWORD	Unlock;
    DWORD	Blt;
    DWORD	SetColorKey;
    DWORD	AddAttachedSurface;
    DWORD	GetBltStatus;
    DWORD	GetFlipStatus;
    DWORD	UpdateOverlay;
    DWORD	reserved3;
    DWORD	reserved4;
    DWORD	SetPalette;
} DDHAL_DDSURFACECALLBACKS;
typedef DDHAL_DDSURFACECALLBACKS *LPDDHAL_DDSURFACECALLBACKS;

typedef struct _DDHAL_DDPALETTECALLBACKS
{
    DWORD	dwSize;
    DWORD	dwFlags;
    DWORD	DestroyPalette;
    DWORD	SetEntries;
} DDHAL_DDPALETTECALLBACKS;

typedef DDHAL_DDPALETTECALLBACKS *LPDDHAL_DDPALETTECALLBACKS;

typedef struct _DDHAL_DDEXEBUFCALLBACKS
{
    DWORD	dwSize;
    DWORD	dwFlags;
    DWORD       CanCreateExecuteBuffer;
    DWORD       CreateExecuteBuffer;
    DWORD       DestroyExecuteBuffer;
    DWORD       LockExecuteBuffer;
    DWORD       UnlockExecuteBuffer;
} DDHAL_DDEXEBUFCALLBACKS;

typedef DDHAL_DDEXEBUFCALLBACKS *LPDDHAL_DDEXEBUFCALLBACKS;

typedef struct _DDHALMODEINFO
{
    DWORD	dwWidth;		// width (in pixels) of mode
    DWORD	dwHeight;		// height (in pixels) of mode
    LONG	lPitch;			// pitch (in bytes) of mode
    DWORD	dwBPP;			// bits per pixel
    DWORD	dwFlags;		// flags
    DWORD	dwRBitMask;		// red bit mask
    DWORD	dwGBitMask;		// green bit mask
    DWORD	dwBBitMask;		// blue bit mask
    DWORD	dwAlphaBitMask;		// alpha bit mask
} DDHALMODEINFO;
typedef DDHALMODEINFO *LPDDHALMODEINFO;

typedef struct _DDHALINFO
{
    DWORD			dwSize;
    LPDDHAL_DDCALLBACKS		lpDDCallbacks;		// direct draw object callbacks
    LPDDHAL_DDSURFACECALLBACKS	lpDDSurfaceCallbacks;	// surface object callbacks
    LPDDHAL_DDPALETTECALLBACKS	lpDDPaletteCallbacks;	// palette object callbacks
    VIDMEMINFO			vmiData;		// video memory info
    DDCORECAPS			ddCaps;			// hw specific caps
    DWORD			dwMonitorFrequency;	// monitor frequency in current mode
    DWORD			hWndListBox;		// list box for debug output
    DWORD			dwModeIndex;		// current mode: index into array
    DWORD			*lpdwFourCC;		// fourcc codes supported
    DWORD			dwNumModes;		// number of modes supported
    LPDDHALMODEINFO		lpModeInfo;		// mode information
    DWORD			dwFlags;		// create flags
    DWORD			lpPDevice;		// physical device
} DDHALINFO;
typedef DDHALINFO *LPDDHALINFO;

typedef struct
{
    DWORD	lpDD;			// driver struct
    DWORD	lpDDDestSurface;	// dest surface
    RECTL	rDest;			// dest rect
    DWORD	lpDDSrcSurface;		// src surface
    RECTL	rSrc;			// src rect
    DWORD	dwFlags;		// blt flags
    DWORD	dwROPFlags;		// ROP flags (valid for ROPS only)
    DDBLTFX	bltFX;			// blt FX
    HRESULT	ddRVal;			// return value
    DWORD	Blt;			// PRIVATE: ptr to callback
} DDHAL_BLTDATA;
typedef DDHAL_BLTDATA *LPDDHAL_BLTDATA;

typedef struct _DDHAL_LOCKDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    DWORD	bHasRect;	// rArea is valid
    RECTL	rArea;		// area being locked
    DWORD	lpSurfData;	// pointer to screen memory (return value)
    HRESULT	ddRVal;		// return value
    DWORD	Lock;		// PRIVATE: ptr to callback
} DDHAL_LOCKDATA;
typedef DDHAL_LOCKDATA *LPDDHAL_LOCKDATA;

typedef struct _DDHAL_UNLOCKDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    HRESULT	ddRVal;		// return value
    DWORD	Unlock;		// PRIVATE: ptr to callback
} DDHAL_UNLOCKDATA;
typedef DDHAL_UNLOCKDATA *LPDDHAL_UNLOCKDATA;

typedef struct _DDHAL_UPDATEOVERLAYDATA
{
    DWORD		lpDD;			// driver struct
    DWORD		lpDDDestSurface;	// dest surface
    RECTL		rDest;			// dest rect
    DWORD		lpDDSrcSurface;		// src surface
    RECTL		rSrc;			// src rect
    DWORD		dwFlags;		// flags
    DDOVERLAYFX		overlayFX;		// overlay FX
    HRESULT		ddRVal;			// return value
    DWORD 		UpdateOverlay;		// PRIVATE: ptr to callback
} DDHAL_UPDATEOVERLAYDATA;
typedef DDHAL_UPDATEOVERLAYDATA *LPDDHAL_UPDATEOVERLAYDATA;

typedef struct _DDHAL_SETOVERLAYPOSITIONDATA
{
    DWORD		lpDD;			// driver struct
    DWORD		lpDDSrcSurface;		// src surface
    DWORD		lpDDDestSurface;	// dest surface
    LONG		lXPos;			// x position
    LONG		lYPos;			// y position
    HRESULT		ddRVal;			// return value
    DWORD		SetOverlayPosition; 	// PRIVATE: ptr to callback
} DDHAL_SETOVERLAYPOSITIONDATA;
typedef DDHAL_SETOVERLAYPOSITIONDATA *LPDDHAL_SETOVERLAYPOSITIONDATA;

typedef struct _DDHAL_SETPALETTEDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    DWORD	lpDDPalette;	// palette to set to surface
    HRESULT	ddRVal;		// return value
    DWORD	SetPalette;	// PRIVATE: ptr to callback
} DDHAL_SETPALETTEDATA;
typedef DDHAL_SETPALETTEDATA *LPDDHAL_SETPALETTEDATA;

typedef struct _DDHAL_FLIPDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpSurfCurr;	// current surface
    DWORD	lpSurfTarg;	// target surface (to flip to)
    DWORD	dwFlags;	// flags
    HRESULT	ddRVal;		// return value
    DWORD	Flip;		// PRIVATE: ptr to callback
} DDHAL_FLIPDATA;
typedef DDHAL_FLIPDATA *LPDDHAL_FLIPDATA;

typedef struct _DDHAL_DESTROYSURFACEDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    HRESULT	ddRVal;		// return value
    DWORD 	DestroySurface;	// PRIVATE: ptr to callback
} DDHAL_DESTROYSURFACEDATA;
typedef DDHAL_DESTROYSURFACEDATA *LPDDHAL_DESTROYSURFACEDATA;

typedef struct _DDHAL_SETCLIPLISTDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    HRESULT	ddRVal;		// return value
    DWORD	SetClipList;	// PRIVATE: ptr to callback
} DDHAL_SETCLIPLISTDATA;
typedef DDHAL_SETCLIPLISTDATA *LPDDHAL_SETCLIPLISTDATA;

typedef struct _DDHAL_ADDATTACHEDSURFACEDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    DWORD	lpSurfAttached;	// surface to attach
    HRESULT	ddRVal;		// return value
    DWORD	AddAttachedSurface; // PRIVATE: ptr to callback
} DDHAL_ADDATTACHEDSURFACEDATA;
typedef DDHAL_ADDATTACHEDSURFACEDATA *LPDDHAL_ADDATTACHEDSURFACEDATA;

typedef struct _DDHAL_SETCOLORKEYDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    DWORD 	dwFlags;	// flags
    DDCOLORKEY ckNew;		// new color key
    HRESULT	ddRVal;		// return value
    DWORD	SetColorKey;	// PRIVATE: ptr to callback
} DDHAL_SETCOLORKEYDATA;
typedef DDHAL_SETCOLORKEYDATA *LPDDHAL_SETCOLORKEYDATA;

typedef struct _DDHAL_GETBLTSTATUSDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    DWORD	dwFlags;	// flags
    HRESULT	ddRVal;		// return value
    DWORD 	GetBltStatus;	// PRIVATE: ptr to callback
} DDHAL_GETBLTSTATUSDATA;
typedef DDHAL_GETBLTSTATUSDATA *LPDDHAL_GETBLTSTATUSDATA;

typedef struct _DDHAL_GETFLIPSTATUSDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    DWORD	dwFlags;	// flags
    HRESULT	ddRVal;		// return value
    DWORD 	GetFlipStatus;	// PRIVATE: ptr to callback
} DDHAL_GETFLIPSTATUSDATA;
typedef DDHAL_GETFLIPSTATUSDATA *LPDDHAL_GETFLIPSTATUSDATA;

typedef struct _DDHAL_CREATEPALETTEDATA
{
    DWORD	lpDD;		// driver struct
    HRESULT	ddRVal;		// return value
    DWORD	CreatePalette;	// PRIVATE: ptr to callback
} DDHAL_CREATEPALETTEDATA;
typedef DDHAL_CREATEPALETTEDATA *LPDDHAL_CREATEPALETTEDATA;

typedef struct _DDHAL_CREATESURFACEDATA
{
    DWORD		lpDD;		// driver struct
    DWORD		lpDDSurfaceDesc;// description of surface being created
    DWORD		lplpSList;	// list of created surface objects
    DWORD		dwSCnt;		// number of surfaces in SList
    HRESULT		ddRVal;		// return value
    DWORD		CreateSurface;	// PRIVATE: ptr to callback
} DDHAL_CREATESURFACEDATA;
typedef DDHAL_CREATESURFACEDATA *LPDDHAL_CREATESURFACEDATA;

typedef struct _DDHAL_CANCREATESURFACEDATA
{
    DWORD		lpDD;			// driver struct
    DWORD		lpDDSurfaceDesc;	// description of surface being created
    DWORD		bIsDifferentPixelFormat;// pixel format differs from primary surface
    HRESULT		ddRVal;			// return value
    DWORD	 	CanCreateSurface;	// PRIVATE: ptr to callback
} DDHAL_CANCREATESURFACEDATA;
typedef DDHAL_CANCREATESURFACEDATA *LPDDHAL_CANCREATESURFACEDATA;

typedef struct _DDHAL_WAITFORVERTICALBLANKDATA
{
    DWORD		lpDD;			// driver struct
    DWORD		dwFlags;		// flags
    DWORD		bIsInVB;		// curr scan line
    DWORD		hEvent;			// event
    HRESULT		ddRVal;			// return value
    DWORD	 	WaitForVerticalBlank;	// PRIVATE: ptr to callback
} DDHAL_WAITFORVERTICALBLANKDATA;
typedef DDHAL_WAITFORVERTICALBLANKDATA *LPDDHAL_WAITFORVERTICALBLANKDATA;

typedef struct _DDHAL_DESTROYDRIVERDATA
{
    DWORD	lpDD;		// driver struct
    HRESULT	ddRVal;		// return value
    DWORD	DestroyDriver;	// PRIVATE: ptr to callback
} DDHAL_DESTROYDRIVERDATA;
typedef DDHAL_DESTROYDRIVERDATA *LPDDHAL_DESTROYDRIVERDATA;

typedef struct _DDHAL_SETMODEDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	dwModeIndex;	// new mode index
    HRESULT	ddRVal;		// return value
    DWORD	SetMode;	// PRIVATE: ptr to callback
} DDHAL_SETMODEDATA;
typedef DDHAL_SETMODEDATA *LPDDHAL_SETMODEDATA;

typedef struct _DDHAL_SETEXCLUSIVEMODEDATA
{
    DWORD	lpDD;		  // driver struct
    DWORD       dwEnterExcl;      // TRUE if entering exclusive mode, FALSE if leaving
    DWORD       dwReserved;       // reserved for future use
    HRESULT	ddRVal;		  // return value
    DWORD	SetExclusiveMode; // PRIVATE: ptr to callback
} DDHAL_SETEXCLUSIVEMODEDATA;
typedef DDHAL_SETEXCLUSIVEMODEDATA *LPDDHAL_SETEXCLUSIVEMODEDATA;

typedef struct _DDHAL_FLIPTOGDISURFACEDATA
{
    DWORD	lpDD;		  // driver struct
    DWORD       dwToGDI;          // TRUE if flipping to the GDI surface, FALSE if flipping away
    DWORD       dwReserved;       // resereved for future use
    HRESULT	ddRVal;		  // return value
    DWORD	FlipToGDISurface; // PRIVATE: ptr to callback
} DDHAL_FLIPTOGDISURFACEDATA;
typedef DDHAL_FLIPTOGDISURFACEDATA *LPDDHAL_FLIPTOGDISURFACEDATA;

typedef struct _DDHAL_GETAVAILDRIVERMEMORYDATA
{
    DWORD	lpDD;		 // [in] driver struct
    DDSCAPS	DDSCaps;	 // [in] caps for type of surface memory
    DWORD	dwTotal;	 // [out] total memory for this kind of surface
    DWORD	dwFree;		 // [out] free memory for this kind of surfcae
    HRESULT	ddRVal;		 // [out] return value
    DWORD	GetAvailDriverMemory; // PRIVATE: ptr to callback
} DDHAL_GETAVAILDRIVERMEMORYDATA;
typedef DDHAL_GETAVAILDRIVERMEMORYDATA *LPDDHAL_GETAVAILDRIVERMEMORYDATA;

typedef struct _DDHAL_UPDATENONLOCALHEAPDATA
{
    DWORD	lpDD;		 // [in] driver struct
    DWORD	dwHeap;		 // [in] index of heap being updated
    DWORD	fpGARTLin;	 // [in] linear GART address of heap start
    DWORD	fpGARTDev;       // [in] high physical GART address of heap start
    HRESULT	ddRVal;		 // [out] return value
    DWORD	UpdateNonLocalHeap; // PRIVATE: ptr to callback
} DDHAL_UPDATENONLOCALHEAPDATA;
typedef DDHAL_UPDATENONLOCALHEAPDATA *LPDDHAL_UPDATENONLOCALHEAPDATA;

typedef struct _DDHAL_GETSCANLINEDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	dwScanLine;	// returned scan line
    HRESULT	ddRVal;		// return value
    DWORD	GetScanLine;	// PRIVATE: ptr to callback
} DDHAL_GETSCANLINEDATA;
typedef DDHAL_GETSCANLINEDATA *LPDDHAL_GETSCANLINEDATA;

typedef struct _DDHAL_DESTROYPALETTEDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDPalette;	// palette struct
    HRESULT	ddRVal;		// return value
    DWORD	DestroyPalette;	// PRIVATE: ptr to callback
} DDHAL_DESTROYPALETTEDATA;
typedef DDHAL_DESTROYPALETTEDATA *LPDDHAL_DESTROYPALETTEDATA;

typedef struct _DDHAL_SETENTRIESDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDPalette;	// palette struct
    DWORD	dwBase;		// base palette index
    DWORD	dwNumEntries;	// number of palette entries
    LPVOID	lpEntries;	// color table
    HRESULT	ddRVal;		// return value
    DWORD	SetEntries;	// PRIVATE: ptr to callback
} DDHAL_SETENTRIESDATA;
typedef DDHAL_SETENTRIESDATA *LPDDHAL_SETENTRIESDATA;

typedef struct _devicemodeA {
    BYTE   dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    short dmOrientation;
    short dmPaperSize;
    short dmPaperLength;
    short dmPaperWidth;
    short dmScale;
    short dmCopies;
    short dmDefaultSource;
    short dmPrintQuality;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE   dmFormName[32];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    DWORD  dmDisplayFlags;
    DWORD  dmDisplayFrequency;
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;
} DEVMODE;

typedef DEVMODE *LPDEVMODE;

typedef struct _DDCOLORCONTROL
{
    DWORD 		dwSize;
    DWORD		dwFlags;
    DWORD		lBrightness;
    DWORD		lContrast;
    DWORD		lHue;
    DWORD 		lSaturation;
    DWORD		lSharpness;
    DWORD		lGamma;
    DWORD		lEnable;
} DDCOLORCONTROL;

typedef struct _DDHAL_COLORCONTROLDATA
{
    DWORD		lpDD;			// driver struct
    DWORD		lpDDSurface;		// surface
    DDCOLORCONTROL 	ColorData;		// color control information
    DWORD		dwFlags;		// DDRAWI_GETCOLOR/DDRAWI_SETCOLOR
    HRESULT		ddRVal;			// return value
    DWORD		ColorControl;		// PRIVATE: ptr to callback
} DDHAL_COLORCONTROLDATA;
typedef DDHAL_COLORCONTROLDATA *LPDDHAL_COLORCONTROLDATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\win9x\makefile.inc ===
thunks:
  thunk -P2 -NC ddraw -t thk3216 32to16.thk -o $(O)\32to16.asm
  thunk -P2 -NC ddraw -t thk1632 16to32.thk -o $(O)\16to32.asm

headers:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\win9x\i386\thk.inc ===
f16ptr  typedef ptr far16
f32ptr  typedef ptr far32

;==============================================================================
; save all 16-bit registers, except dx:ax
;
;==============================================================================
SAVEALL     macro
    push    cx      ; save all 16-bit registers, except dx:ax
    push    bx
    push    bp
    push    si
    push    di
    push    ds
    push    es
endm


;==============================================================================
; restore all 16-bit registers, except dx:ax
;
;==============================================================================
RESTOREALL  macro  StackType:=<Stack16>
    POPW    es      ; restore all 16-bit registers, except dx:ax

    CHECKW  ds, StackType
    POPW    ds
    CHECKW  di, StackType
    pop     di

    CHECKW  si, StackType
    pop     si
    CHECKW  bp, StackType
    pop     bp

    pop     bx
    pop     cx
endm


;==============================================================================
; test two text macros for equality
;
;
;==============================================================================
TextEqual? macro   Text_1, Text_2
    ifidni <Text_1>, <Text_2>
        exitm <not 0>
    endif
    exitm <0>
endm


;==============================================================================
; test two text macros for difference
;
;
;==============================================================================
TextDiff? macro   Text_1, Text_2
    ifidni <Text_1>, <Text_2>
        exitm <0>
    endif
    exitm <not 0>
endm


;==============================================================================
; check a word on top of the stack
; if not equal, break
;
;==============================================================================
CHECKW    macro   CurrentReg, StackType:=<Stack16>

    if (@WordSize eq 4) and TextDiff? (&StackType&,Stack16)
    push    eax
    mov     ax,&CurrentReg&
    cmp     ax,word ptr [esp+4]
    pop     eax
    je      @F
    int     3
@@:
    else


    push    bp
    push    ax
    mov     ax,&CurrentReg&
    mov     bp,sp
    and     ebp,0ffffh
    cmp     ax,word ptr [ebp+4]
    pop     ax
    pop     bp
    je      @F
    int     3
@@:
    endif

endm


;==============================================================================
; pop word
;
;==============================================================================
POPW    macro   SegReg
    if @WordSize eq 4
        db      66h
    endif
    pop     SegReg
endm


;==============================================================================
; pop dword
;
;==============================================================================
POPD    macro   SegReg
    if @WordSize eq 2
        db      66h
    endif
    pop     SegReg
endm


;==============================================================================
; operand-size override
;
;==============================================================================
OTHER_OPERAND_SIZE  macro   arg
    db  66h
    arg
endm


;==============================================================================
; address-size override
;
;==============================================================================
OTHER_ADDRESS_SIZE  macro   arg
    db  67h
    arg
endm


;==============================================================================
; allocate and public a byte flag
;
;==============================================================================
PubByte  macro   name, value
    public  name
    name    db      value
endm


;==============================================================================
; log an api call, 16-bit
;
;==============================================================================
APILOG16  macro   argName, argFlag, argComment
        local   do_it,done,szApiName

ifdef DEBUG
externDef PCodeDebug16:far16
externDef OutputDebugString:far16

        push    ds
        push    ax
        mov     ax,seg &argFlag
        mov     ds,ax
        cmp     &argFlag,0
        je      done
        jmp     do_it

szApiName db 'Api 16=>32: &argName& &argComment&',0Ah,0Dh,0

do_it:
        push    seg    szApiName
        push    offset szApiName
        call    OutputDebugString
done:
        pop     ax
        pop     ds

        call    PCodeDebug16
endif
endm


;==============================================================================
; log an api call, 32-bit
;
;==============================================================================
APILOG  macro   argName, argFlag
        local   do_it,done,szApiName
ifdef DEBUG
;externDef _DbgPrint:near32

        ;;If argFlag is nonzero, print out the message.
        cmp     argFlag&,0
        jnz     do_it
        jmp     short done
;;Define the name here so we can pass it to _DbgPrint.
szApiName db '&argName&',0
do_it:
        push    offset FLAT:szApiName
        push    offset FLAT:szApiFmt
        ;call    _DbgPrint
        add     esp,2*4
done:
endif
endm


;==============================================================================
; log 16-bit api return, in 32-bit code
;
;==============================================================================
RETLOG  macro   argFlag
        local   do_it, done, szRetFmt
ifdef DEBUG
externDef argFlag&:byte
;externDef _DbgPrint:near32
        cmp     argFlag&,0
        je      done
        jmp     do_it

szRetFmt db "Ret 16=>32: %4x:%4x",0dh,0ah,0
do_it:
        push    eax             ;;save return code value
        push    edx

        push    word ptr 0      ;;parameters to _DbgPrint
        push    ax
        push    word ptr 0
        push    dx
        push    offset szRetFmt
        ;call    _DbgPrint
        add     esp,3*4

        pop     edx             ;;restore return code
        pop     eax
done:
endif
endm



;==============================================================================
; conditionally break
;
;==============================================================================
SWITCHABLE_INT3 macro argLabel, argFlag
externDef   argLabel :far16

        push    ds
        push    ax
        mov     ax,seg &argFlag
        mov     ds,ax
        cmp     &argFlag,0
        je      @F
argLabel& label far16
        int     3
@@:
        pop     ax
        pop     ds
endm


;==============================================================================
;
;
;==============================================================================
STUB0   macro   module, argLabel, nBytes, argComment:=<stub0>
externDef   argLabel&16 :far16
argLabel&16 label far16

ifdef FSAVEALL
        SAVEALL
endif
        APILOG16 argLabel&16, f&module&ApiLog, argComment
ifdef INT3
        SWITCHABLE_INT3 argLabel&_stub, f&module&Int3
endif
        xor     ax,ax
        cwd
ifdef FSAVEALL
        RESTOREALL
endif
        retf    &nBytes&
endm


;==============================================================================
;
;
;==============================================================================
STUB    macro   module, argLabel, nBytes, nRetAX, argComment:=<stub>
externDef   argLabel&16 :far16
externDef   PCodeDebug16 :far16
argLabel&16 label far16

ifdef FSAVEALL
        SAVEALL
endif
        APILOG16 argLabel&16, f&module&ApiLog, argComment nRetAX
ifdef INT3
        SWITCHABLE_INT3 argLabel&_stub, f&module&Int3
endif
        mov     ax,&nRetAX
ifdef FSAVEALL
        RESTOREALL
endif
        retf    nBytes
endm


;==============================================================================
; repack TEXTMETRIC from 32-bit to 16-bit
;
;==============================================================================
PACK_TEXTMETRIC_32_16   macro

        lodsd                           ; first 8 int widened
        stosw

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw

        add     esi,12                  ; 9 bytes moved to end

        movsd
        movsd
        movsb

        sub     esi,21                  ; final 3 int

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw
endm


;==============================================================================
; repack TEXTMETRIC from 16-bit to 32-bit
;
;==============================================================================
PACK_TEXTMETRIC_16_32   macro

        lodsw                           ; first 8 int widened
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        add     esi,9                   ; 3 ints after nine bytes

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        sub     esi,21                  ; now do the nine bytes

        movsd
        movsd
        movsb
endm


;==============================================================================
; repack BITMAP from 32-bit to 16-bit
;
;==============================================================================
PACK_BITMAP_32_16   macro

        lodsd                           ; first 4 int widened
        stosw

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw

        add     esi,4                   ; 2 bytes moved to end
        movsw

        sub     esi,6
        movsd                           ; bmBits
endm


;==============================================================================
; entry code for flat common callback
;
;==============================================================================
CALLBACK_PROLOGUE   macro

        pop     eax                     ; 16:16 callback
        pop     edx                     ; eip, API32

        push    cs                      ; flat cs
        push    edx                     ; eip, API32
        push    eax                     ; 16:16 callback

        push    ebp
        mov     ebp,esp

        push    ds                      ; save registers
        push    es
        push    ebx
        push    edi
        push    esi
endm


;==============================================================================
; exit code for flat common callback
;
;==============================================================================
CALLBACK_EPILOGUE   macro   size

        LOCAL   bad_esp

;--------------------------------------------------
; switch stacks and jump to 16:16 callback

; when the 16:16 callback does a retf, we will hit our cleanup routine

        push    dword ptr ADDR_THK_CLEANUP_&size

; prepare to transfer to the 16-bit callback function

        push    pCallback16

; get the ss16 we had when we entered the callback API16
; make the 16-bit ss:sp point to the same linear address as the flat ss:esp

        call    UsrQuerySS16
        mov     esi,eax                 ; save ss16
        push    eax
        call    GetSelectorBase32       ; LATER: LDT lookup
        xchg    eax,esp
        sub     eax,esp
        jb      bad_esp
        cmp     eax,65535
        ja      bad_esp

        mov     ss,si
        mov     sp,ax

; effectively, jmp to 16:16 callback
        retw

bad_esp:
        int     3

endm


;==============================================================================
; 16-bit callback cleanup code
;
;==============================================================================
CALLBACK_CLEANUP    macro   size

        pop     si                      ; get hMem
        pop     di
        mov     cx,si
        or      cx,di
        jz      @F

        push    di                      ; hMem !NULL, so dealloc
        push    si
        call    LocalFree
@@:
        call    UnmapLS                 ; thunk id already on stack
        add     sp,2                    ; flat setup pushed dword

        movzx   ecx,sp                  ; restore flat stack
        lss     esp,ss:[ecx]

        pop     esi                     ; restore registers
        pop     edi
        pop     ebx
        POPD    es
        POPD    ds
        pop     ebp

        pop     ecx                     ; discard 16:16 callback

        retd    size                    ; return to the 32-bit API
endm


;==============================================================================
; save flat stack and thunkID
;
;==============================================================================
SAVE_STACK_AND_THUNKID  macro

        lea     eax,[addr_registers]    ; save flat stack
        push    ss
        push    eax

        call    GetThunkID32
        push    eax                     ; save 16:16 thunkID
endm

;==============================================================================
; entry code for 16-bit common callback to 32-bit function
;
;==============================================================================
CALLBACK_BODY_16   macro     name, size, aliases
        local   callback_ret

CB16_&name label far16
for     x,<aliases>
        CB16_&x label far16
endm

        push    bp
        push    si
        push    di
        push    ds

        mov     ax,sp
        push    ss
        push    ax

        mov     ax,sp
        push    ss
        push    ax
        call    SelectorOffsetToLinear16
        mov     ebx,eax
        and     eax,not 3
        mov     cx,cs:FlatData
        mov     ss,cx
        mov     esp,eax
        mov     ds,cx
        mov     es,cx

        push    cs
        push    offset callback_ret
        jmp     f32ptr ptr pfn&name&Callback
callback_ret:

        lss     sp,ss:[ebx]
        pop     ds
        pop     di
        pop     si
        pop     bp

        retf    size                    ; return to the 16-bit API
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\inc\ddagp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagp.h
 *  Content:	AGP memory header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Split from ddrawpr.h for user/kernel portability.
 *
 ***************************************************************************/

#ifndef __DDAGP_INCLUDED__
#define __DDAGP_INCLUDED__

// This value controls how big a chunk of GART memory to commit each time
// we need to (rather than commiting just what we need to satisfy a surface
// request). This value is in bytes.  Currently 256KB.
#define DEFAULT_AGP_COMMIT_DELTA (256 * 1024)

extern DWORD dwAGPPolicyMaxBytes;
extern DWORD dwAGPPolicyCommitDelta;

//
// OS-specific functions for AGP manipulation.
//

#ifdef WIN95
#define OsGetAGPDeviceHandle(pHeap) GetDXVxdHandle()
#define OsCloseAGPDeviceHandle(h) CloseHandle(h)
#else
#define OsGetAGPDeviceHandle(pHeap) ((pHeap)->hdevAGP)
#define OsCloseAGPDeviceHandle(h)
#endif

BOOL OsAGPReserve( HANDLE hdev, DWORD dwNumPages, BOOL fIsUC, BOOL fIsWC,
                   FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                   LPVOID *ppvReservation );
BOOL OsAGPCommit( HANDLE hdev, LPVOID pvReservation,
                  DWORD dwPageOffset, DWORD dwNumPages );
BOOL OsAGPDecommitAll( HANDLE hdev, LPVOID pvReservation, DWORD dwNumPages );
BOOL OsAGPFree( HANDLE hdev, LPVOID pvReservation );

//
// Generic functions that use the OS-specific functions.
//

DWORD AGPReserve( HANDLE hdev, DWORD dwSize, BOOL fIsUC, BOOL fIsWC,
                  FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                  LPVOID *ppvReservation );
BOOL AGPCommit( HANDLE hdev, LPVOID pvReservation,
                DWORD dwOffset, DWORD dwSize );
BOOL AGPDecommitAll( HANDLE hdev, LPVOID pvReservation, DWORD dwSize );
BOOL AGPFree( HANDLE hdev, LPVOID pvReservation );

#ifndef __NTDDKCOMP__

#ifdef WIN95
BOOL vxdIsVMMAGPAware ( HANDLE hvxd );
#endif

BOOL OSIsAGPAware( HANDLE hdev );
#endif

#endif // __DDAGP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\inc\ddheap.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheap.h
 *  Content:	Heap manager header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Split from ddrawpr.h for user/kernel portability.
 *
 ***************************************************************************/

#ifndef __DDHEAP_INCLUDED__
#define __DDHEAP_INCLUDED__

#include "dmemmgr.h"

#ifndef VIDMEMONLY

BOOL linVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, FLATPTR end );
void linVidMemFini( LPVMEMHEAP pvmh );
void linVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );
FLATPTR linVidMemAlloc( LPVMEMHEAP pvmh, DWORD xsize, DWORD ysize,
                        LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment,
                        LPLONG lpNewPitch );
DWORD linVidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD linVidMemAmountFree( LPVMEMHEAP pvmh );
DWORD linVidMemLargestFree( LPVMEMHEAP pvmh );
    
BOOL rectVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, DWORD width, DWORD height,
                     DWORD stride );
void rectVidMemFini( LPVMEMHEAP pvmh );
FLATPTR rectVidMemAlloc( LPVMEMHEAP pvmh, DWORD cxThis, DWORD cyThis,
                         LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment );
void rectVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );
DWORD rectVidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD rectVidMemAmountFree( LPVMEMHEAP pvmh );

BOOL IsDifferentPixelFormat( LPDDPIXELFORMAT pdpf1, LPDDPIXELFORMAT pdpf2 );

#define DDHA_SKIPRECTANGULARHEAPS       0x0001
#define DDHA_ALLOWNONLOCALMEMORY        0x0002
#define DDHA_ALLOWNONLOCALTEXTURES      0x0004
#define DDHA_USEALTCAPS                 0x0008

FLATPTR DdHeapAlloc( DWORD dwNumHeaps,
                     LPVIDMEM pvmHeaps,
                     HANDLE hdev,
                     LPVIDMEMINFO lpVidMemInfo,
                     DWORD dwWidth,
                     DWORD dwHeight,
                     LPDDRAWI_DDRAWSURFACE_LCL lpSurfaceLcl,
                     DWORD dwFlags,
                     LPVIDMEM *ppvmHeap,
                     LPLONG plNewPitch,
                     LPDWORD pdwNewCaps,
                     LPDWORD pdwSize);

LPVMEMHEAP WINAPI HeapVidMemInit( LPVIDMEM lpVidMem, DWORD pitch, HANDLE hdev,
                                  LPHEAPALIGNMENT phad);
void WINAPI HeapVidMemFini( LPVIDMEM lpVidMem, HANDLE hdev );
FLATPTR WINAPI HeapVidMemAlloc( LPVIDMEM lpVidMem, DWORD x, DWORD y,
                                HANDLE hdev, LPSURFACEALIGNMENT lpAlignment,
                                LPLONG lpNewPitch, LPDWORD pdwSize );

#endif // VIDMEMONLY

LPVMEMHEAP WINAPI VidMemInit( DWORD flags, FLATPTR start, FLATPTR end_or_width,
                              DWORD height, DWORD pitch );
void WINAPI VidMemFini( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh );

#endif // __DDHEAP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\inc\ddreg.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddreg.h
 *  Content:	DirectDraw registry entries
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   16-aug-96	craige	initial implementation
 *   06-jan-97  colinmc Initial AGP work
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *
 ***************************************************************************/

#ifndef __DDRAWREG_INCLUDED__
#define __DDRAWREG_INCLUDED__

#define REGSTR_PATH_DDRAW 		   "Software\\Microsoft\\DirectDraw"

#define	REGSTR_VAL_DDRAW_MODEXONLY	   "ModeXOnly"
#define	REGSTR_VAL_DDRAW_EMULATIONONLY	   "EmulationOnly"
#define REGSTR_VAL_DDRAW_SHOWFRAMERATE	   "ShowFrameRate"
#define REGSTR_VAL_DDRAW_ENABLEPRINTSCRN   "EnablePrintScreen"
#define REGSTR_VAL_DDRAW_DISABLEWIDERSURFACES "DisableWiderSurfaces"
// this regkey is added purely for performance testing purposes to
// eliminate the refreshrate influence on framerate
#define REGSTR_VAL_D3D_FLIPNOVSYNC          "FlipNoVsync"
/*
 * This one is checked in DirectDrawMsg
 */
#define REGSTR_VAL_DDRAW_DISABLEDIALOGS    "DisableDialogs"
#define REGSTR_VAL_DDRAW_NODDSCAPSINDDSD   "DisableDDSCAPSInDDSD"

#define REGSTR_VAL_DDRAW_FORCEAGPSUPPORT   "ForceAGPSupport"
#define REGSTR_VAL_DDRAW_AGPPOLICYMAXPAGES "AGPPolicyMaxPages"
#define REGSTR_VAL_DDRAW_AGPPOLICYMAXBYTES "AGPPolicyMaxBytes"
#define REGSTR_VAL_DDRAW_AGPPOLICYCOMMITDELTA "AGPPolicyCommitDelta"
#define REGSTR_VAL_DDRAW_DISABLEAGPSUPPORT "DisableAGPSupport"

#define REGSTR_VAL_DDRAW_DISABLEMMX	   "DisableMMX"

#define REGSTR_VAL_DDRAW_FORCEREFRESHRATE  "ForceRefreshRate"

#define REGSTR_VAL_DDRAW_LOADDEBUGRUNTIME  "LoadDebugRuntime"

#ifdef WIN95
#define REGSTR_KEY_RECENTMONITORS          "MostRecentMonitors"
#define REGSTR_VAL_DDRAW_MONITORSORDER     "Order"
#endif

#ifdef DEBUG
    #define REGSTR_VAL_DDRAW_DISABLENOSYSLOCK  "DisableNoSysLock"
    #define REGSTR_VAL_DDRAW_FORCENOSYSLOCK    "ForceNoSysLock"
#endif /* DEBUG */
#define REGSTR_VAL_DDRAW_DISABLEINACTIVATE "DisableInactivate"

#define REGSTR_KEY_GAMMA_CALIBRATOR        "GammaCalibrator"
#define REGSTR_VAL_GAMMA_CALIBRATOR        "Path"

#define REGSTR_KEY_APPCOMPAT		   "Compatibility"

#define REGSTR_KEY_LASTAPP		   "MostRecentApplication"

#define REGSTR_VAL_DDRAW_NAME		   "Name"
#define REGSTR_VAL_DDRAW_APPID		   "ID"
#define REGSTR_VAL_DDRAW_FLAGS		   "Flags"

#define REGSTR_VAL_D3D_USENONLOCALVIDMEM   "UseNonLocalVidMem"

#define REGSTR_VAL_DDRAW_ENUMSECONDARY     "EnumerateAttachedSecondaries"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\inc\dwininfo.h ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	wndinfo.h
 *  Content:	Direct Draw window information structure
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   08-jul-95	craige	initial implementation
 *   18-jul-95	craige	keep track of dsound/ddraw hooks with flags
 *   13-aug-95  toddla  added WININFO_ACTIVELIE
 *   09-sep-95  toddla  added WININFO_INACTIVATEAPP
 *   17-may-96  colinmc Bug 23029: Removed WININFO_WASICONIC
 *
 ***************************************************************************/

#ifndef __WNDINFO_INCLUDED__
#define __WNDINFO_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DDWINDOWINFO
{
    DWORD                       dwSmag;
    struct _DDWINDOWINFO	*lpLink;
    WNDPROC			lpDSoundCallback;
    HWND			hWnd;
    WNDPROC			lpWndProc;
    DWORD			dwPid;
    DWORD			dwFlags;
    struct
    {
	LPDDRAWI_DIRECTDRAW_LCL	lpDD_lcl;
	DWORD			dwDDFlags;
    } DDInfo;
} DDWINDOWINFO, *LPDDWINDOWINFO;

#define WININFO_MAGIC                   0x42954295l
#define WININFO_DDRAWHOOKED		0x00000001l
#define WININFO_DSOUNDHOOKED		0x00000002l
#define WININFO_ZOMBIE                  0x00000008l
#define WININFO_UNHOOK                  0x00000010l
#define WININFO_IGNORENEXTALTTAB	0x00000020l
#define WININFO_SELFSIZE                0x00000040l
#define WININFO_INACTIVATEAPP           0x00000080l

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\misc\dpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:    debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-jan-95  craige  initial implementation
 *   03-mar-95  craige  added dprintf2
 *   31-mar-95  craige  add DPFInit to read WIN.INI for [DirectDraw] section;
 *                      added dprintf3
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   18-jun-95  craige  use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed DXdprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
    #include "newdpf.c"
#else   //use old debug:

    #undef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include "dpf.h"
    #include <stdarg.h>

    //#ifdef WINNT
    //int abs(int x)
    //{
    //    return x>=0?x:-x;
    //}
    //#endif

    #ifdef DEBUG

    #define USE_DDASSERT

    #ifndef START_STR
        #define START_STR       "DDRAW: "
    #endif
    #ifndef PROF_SECT
        #define PROF_SECT       "DirectDraw"
    #endif

    #define END_STR             "\r\n"

    HWND                hWndListBox;
    LONG                lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
        OutputDebugString( str );

        #ifdef DPF_HWND
            if( hWndListBox != NULL )
            {
                if( !IsWindow( hWndListBox ) )
                {
                    hWndListBox = NULL;
                }
            }
            if( hWndListBox != NULL )
            {
                UINT    sel;
                int     len;
                len = strlen( str );
                if( len > 0 )
                {
                    if( str[len-1] == '\r' || str[len-1] == '\n' )
                    {
                        str[len-1] = 0;
                    }
                    if( len > 1 )
                    {
                        if( str[len-2] == '\r' || str[len-2] == '\n' )
                        {
                            str[len-2] = 0;
                        }
                    }
                }
                SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
                sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
                if( sel != LB_ERR )
                {
                    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
                }
            }
        #endif

    } /* dumpStr */

    /*
     * DXdprintf
     */
    void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;
        va_list ap;
        va_start(ap,szFormat);


        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            //GetModuleFileName(NULL,str2,256);
            //if (strrchr(str2,'\\'))
            //    wsprintf(str+strlen(str),"%12s",strrchr(str2,'\\')+1);
            //strcat(str,":");
#ifdef WIN95
            char szTmp[512];
            char *psz = szTmp;
            strncpy(szTmp, szFormat, 512);

            // %p does not work on Windows95.
            // We look for each "%p" and substitute 'x' for 'p'
            // WARNING:  This code does not handle escape sequences using %p.  
            //           Extra code must be added to deal with that case 
            //          if necessary
            while (psz = strstr(psz, "%p"))  
                *(psz+1) = 'x';

            wvsprintf( str+lstrlen( str ), szTmp, ap);   //(LPVOID)(&szFormat+1) );
#else
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );
#endif //WIN95

            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

        va_end(ap);
    } /* DXdprintf */


    static void cdecl D3Dprintf( UINT lvl, LPSTR msgType, LPSTR szFormat, va_list ap)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;

        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            wsprintf( (LPSTR) str+lstrlen( str ), msgType );
#ifdef WIN95
            char szTmp[512];
            char *psz = szTmp;
            strncpy(szTmp, szFormat, 512);

            // %p does not work on Windows95.
            // We look for each "%p" and substitute 'x' for 'p'
            // WARNING:  This code does not handle escape sequences using %p.  
            //           Extra code must be added to deal with that case 
            //          if necessary
            while (psz = strstr(psz, "%p"))  
                *(psz+1) = 'x';

            wvsprintf( str+lstrlen( str ), szTmp, ap);
#else
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );
#endif // WIN95
            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

    } /* D3Dprintf */

    void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap, szFormat);

        D3Dprintf(lvl, "(INFO) :", szFormat, ap);

        va_end(ap);
    }

    void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap,szFormat);

        D3Dprintf(lvl, "(WARN) :", szFormat, ap);
        va_end(ap);
    }

    void cdecl D3DErrorPrintf( LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap,szFormat);

        D3Dprintf(0, "(ERROR) :", szFormat, ap);
        va_end(ap);
    }

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
        lDebugLevel = GetProfileInt( PROF_SECT, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
        char buffer[ASSERT_BUFFER_SIZE];

        /*
         * Build the debug stream message.
         */
        wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

        /*
         * Actually issue the message. These messages are considered error level
         * so they all go out at error level priority.
         */
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
        DXdprintf( ASSERT_MESSAGE_LEVEL, buffer );
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

        /*
         * Should we drop into the debugger?
         */
        if( GetProfileInt( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
        {
            /*
             * Into the debugger we go...
             */
            DEBUG_BREAK();
        }
    }

    #endif /* USE_DDASSERT */

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\misc\dxvalid.h ===
//--------------------------------------------------------------------------;
//
//  File: dxvalid.h
//
//  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//      This header contains common parameter validate macros for DirectX.
//
//  History:
//      02/14/96    angusm    Initial version
//      03/05/96    angusm    added VALIDEX_GUID_PTR
//
//--------------------------------------------------------------------------;


// _________________________________________________________________________
// VALIDEX_xxx 
//     macros are the same for debug and retail


#define VALIDEX_PTR( ptr, size ) \
	(!IsBadReadPtr( ptr, size) )

#define VALIDEX_GUID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( GUID ) ) )

#define VALIDEX_IID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( IID )) )

#define VALIDEX_PTR_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID )) )

#define VALIDEX_CODE_PTR( ptr ) \
	(!IsBadCodePtr( (LPVOID) ptr ) )


// _________________________________________________________________________
// VALID_xxx 
//     macros that check memory allocated and sent as API parameters


#ifndef DEBUG
#define FAST_CHECKING
#endif

#ifndef FAST_CHECKING

#define VALID_BOOL_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( BOOL ) ))
#define VALID_DDCOLORKEY_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( DDCOLORKEY ) ) )
#define VALID_RGNDATA_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( RGNDATA ) ) )
#define VALID_RECT_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( RECT ) ) )
#define VALID_PTR_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID )) )
#define VALID_IID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( IID )) )
#define VALID_HWND_PTR( ptr ) \
	(!IsBadWritePtr( (LPVOID) ptr, sizeof( HWND )) )
#define VALID_VMEM_PTR( ptr ) \
	(!IsBadWritePtr( (LPVOID) ptr, sizeof( VMEM )) )
#define VALID_POINTER_ARRAY( ptr, cnt ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID ) * cnt ) )
#define VALID_HANDLE_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( HANDLE )) )
#define VALID_DWORD_ARRAY( ptr, cnt ) \
	(!IsBadWritePtr( ptr, sizeof( DWORD ) * cnt ) )
#define VALID_GUID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( GUID ) ) )
#define VALID_BYTE_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( BYTE ) * cnt ) )
#define VALID_PTR( ptr, size ) \
	(!IsBadReadPtr( ptr, size) )

#else
#define VALID_PTR( ptr, size ) 		1
#define VALID_DIRECTDRAW_PTR( ptr )	1
#define VALID_DIRECTDRAWSURFACE_PTR( ptr )	1
#define VALID_DIRECTDRAWPALETTE_PTR( ptr )	1
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr )	1
#define VALID_DDSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC ))
#define VALID_BOOL_PTR( ptr )	1
#define VALID_HDC_PTR( ptr )	1
#define VALID_DDPIXELFORMAT_PTR( ptr ) (ptr->dwSize == sizeof( DDPIXELFORMAT ))
#define VALID_DDCOLORKEY_PTR( ptr )	1
#define VALID_RGNDATA_PTR( ptr )	1
#define VALID_RECT_PTR( ptr )	1
#define VALID_DDOVERLAYFX_PTR( ptr ) (ptr->dwSize == sizeof( DDOVERLAYFX ))
#define VALID_DDBLTFX_PTR( ptr ) (ptr->dwSize == sizeof( DDBLTFX ))
#define VALID_DDBLTBATCH_PTR( ptr )	1
#define VALID_DDMASK_PTR( ptr )	1
#define VALID_DDSCAPS_PTR( ptr )	1
#define VALID_PTR_PTR( ptr )	1
#define VALID_IID_PTR( ptr )	1
#define VALID_HWND_PTR( ptr )	1
#define VALID_VMEM_PTR( ptr )	1
#define VALID_POINTER_ARRAY( ptr, cnt ) 1
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt )	1
#define VALID_HANDLE_PTR( ptr )	1
#define VALID_DDCAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDCAPS ))
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt )	1
#define VALID_DWORD_ARRAY( ptr, cnt )	1
#define VALID_GUID_PTR( ptr )	1
#define VALID_BYTE_ARRAY( ptr, cnt ) 1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\misc\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
#include "newdpf.h"
#else

    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef DBG
        #define DEBUG
    #endif

    extern void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DErrorPrintf( LPSTR szFormat, ...);

    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPF_DECLARE(szName) char * __pszDpfName=#szName":"
        #define DPFINIT()   DPFInit()
        #define DPF         DXdprintf
        #define DPF_ERR(a)  DXdprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && defined(WIN95)
            #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
            #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT

        // New for D3D
        #define D3D_ERR       D3DErrorPrintf
        #define D3D_WARN      D3DWarnPrintf
        #define D3D_INFO      D3DInfoPrintf
    #else
        #pragma warning(disable:4002)
        #define DPF_DECLARE(szName)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()

        #define D3D_ERR(a)
        #define D3D_WARN()
        #define D3D_INFO()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD perf_clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= perf_clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += perf_clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\misc\dpfa.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:    debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-jan-95  craige  initial implementation
 *   03-mar-95  craige  added dprintf2
 *   31-mar-95  craige  add DPFInit to read WIN.INI for [DirectDraw] section;
 *                      added dprintf3
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   18-jun-95  craige  use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed dprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *       20-may-96      andyco  forced ansi entry points on all functions
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "dpf.h"
#include <stdarg.h>


#ifdef DEBUG

#define USE_DDASSERT

#ifndef START_STR
    #define START_STR   "DDRAW: "
#endif
#ifndef PROF_SECT
    #define PROF_SECT   "DirectDraw"
#endif

#define END_STR         "\r\n"

HWND            hWndListBox;
LONG            lDebugLevel = 0;

/*
 * dumpStr
 */
static void dumpStr( LPSTR str )
{
    OutputDebugStringA( str );

    #ifdef DPF_HWND
        if( hWndListBox != NULL )
        {
            if( !IsWindow( hWndListBox ) )
            {
                hWndListBox = NULL;
            }
        }
        if( hWndListBox != NULL )
        {
            UINT        sel;
            int len;
            len = strlen( str );
            if( len > 0 )
            {
                if( str[len-1] == '\r' || str[len-1] == '\n' )
                {
                    str[len-1] = 0;
                }
                if( len > 1 )
                {
                    if( str[len-2] == '\r' || str[len-2] == '\n' )
                    {
                        str[len-2] = 0;
                    }
                }
            }
            SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
            sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
            if( sel != LB_ERR )
            {
                SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
            }
        }
    #endif

} /* dumpStr */

/*
 * dprintf
 */
void cdecl dprintf( UINT lvl, LPSTR szFormat, ...)
{
    char        str[256];
    BOOL        allow = FALSE;
    va_list ap;
    va_start(ap,szFormat);


    if( lDebugLevel < 0 )
    {
#ifndef WIN95
        if( (UINT) abs( lDebugLevel ) == lvl )
#else
        if( (UINT) labs( lDebugLevel ) == lvl )
#endif
        {
            allow = TRUE;
        }
    }
    else if( (UINT) lDebugLevel >= lvl )
    {
        allow = TRUE;
    }

    if( allow )
    {
        wsprintfA( (LPSTR) str, START_STR );
        wvsprintfA( str+lstrlenA( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

        lstrcatA( (LPSTR) str, END_STR );
        dumpStr( str );
    }

    va_end(ap);
} /* dprintf */

/*
 * DPFInit
 */
void DPFInit( void )
{
    lDebugLevel = GetProfileIntA( PROF_SECT, "debug", 0 );

} /* DPFInit */

#ifdef USE_DDASSERT

/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    wsprintfA( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( GetProfileIntA( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
        /*
         * Into the debugger we go...
         */
        DEBUG_BREAK();
    }
}

#endif /* USE_DDASSERT */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\misc\logger.h ===
/*
	logger.h

	Use to write log info to a file.

	Multiple-instance aware. If one instance already owns the output
        file, another will sleep (up to 20s) until the first is done.
	Nicely outputs a header containing user, computer, and driver names,
	date/time and starting display resolution.


        You use it like this:

                CLogfile Log("test.log","your comment here");

                // or CLogfile Log("test.log");
                // for no comment, and overwriting the file.

                // or CLogfile Log("test.log","your comment here",TRUE);
                // to make it append to the file. Default is overwrite.
                
                Log << "\n\n42 decimal is " << 42ul <<" in hex\n";
                Log << "Hi"<<'!'<<'\n' ;
                Log << "The value of 0x2a is " << 0x2al << " in decimal\n";

				CLogfile Faults("faults.log","my test's faults",TRUE);	//append new faults
				Faults << "Encountered a booboo, here's what i did:\n";
				Faults << Log;		//copies contents of test.log to Fault
				Faults << "so now you can diagnose\n";

        The class will then write stuff like this to test.log:


                ----------------------------------------------------------
                EnumSurface test
                Beginning test at 10:38 on 1995/8/14
                User Name:jeffno
                Computer Name:JEFFNO2
                Display driver:S3 Vision864 PCI
                Starting resolution: 640x480x8
                - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
                42 decimal is 0000002a in hex
                Hi!
                The value of 0x2a is 42 in decimal
                ----------- Test ends at 10:38 on 1995/8/14 -------------
                
		And faults.log will get:
				< a header like above>
				Encountered a booboo, here's what i did:
				< a copy of the test.log contents surrounded by
					notes that say this is a snapshot of test.log >
				so now you can diagnose
				< a trailer like above (test ends at etc...)>



        The class can output DWORDS, which it does as an 8-digit hex number,
        LONGs which are output as decimal, chars and strings. As shown
		above you can output one log object to another, which copies 
		everything in the source file from the pos at which the source
		file was opened (if appending to a pre-existing file) up to
		the end.


        But wait! you also get...
                A routine called char * ErrorName(HRESULT) which takes
                a ddraw return value and returns a string describing it.
                Very handy.
                BTW: this header file includes a statically declared array
                full of names, at file level scope. This means you get a 2k
                array in your source wether you want ErrorName or not.
                Go ahead and edit this file if you don't want this array.

        NOTE: this uses WNetGetUser API, so you'll need to add mpr.lib
        to you LIBS line in your makefile.
*/

//#include <stdio.h>
#include <windows.h>
#include <windowsx.h> 


struct {
	char name[100];
	HRESULT errcode;
} ErrorLookup[] = {
				{"DD_OK",DD_OK},
				{"DDERR_ALREADYINITIALIZED",DDERR_ALREADYINITIALIZED},
				{"DDERR_CANNOTATTACHSURFACE",DDERR_CANNOTATTACHSURFACE},
				{"DDERR_CANNOTDETACHSURFACE",DDERR_CANNOTDETACHSURFACE},
				{"DDERR_CURRENTLYNOTAVAIL",DDERR_CURRENTLYNOTAVAIL},
				{"DDERR_EXCEPTION",DDERR_EXCEPTION},
				{"DDERR_GENERIC",DDERR_GENERIC},
				{"DDERR_HEIGHTALIGN",DDERR_HEIGHTALIGN},
				{"DDERR_INCOMPATIBLEPRIMARY",DDERR_INCOMPATIBLEPRIMARY},
				{"DDERR_INVALIDCAPS",DDERR_INVALIDCAPS},
				{"DDERR_INVALIDCLIPLIST",DDERR_INVALIDCLIPLIST},
				{"DDERR_INVALIDMODE",DDERR_INVALIDMODE},
				{"DDERR_INVALIDOBJECT",DDERR_INVALIDOBJECT},
				{"DDERR_INVALIDPARAMS",DDERR_INVALIDPARAMS},
				{"DDERR_INVALIDPIXELFORMAT",DDERR_INVALIDPIXELFORMAT},
				{"DDERR_INVALIDRECT",DDERR_INVALIDRECT},
				{"DDERR_LOCKEDSURFACES",DDERR_LOCKEDSURFACES},
				{"DDERR_NO3D",DDERR_NO3D},
				{"DDERR_NOALPHAHW",DDERR_NOALPHAHW},
				{"DDERR_NOANTITEARHW",DDERR_NOANTITEARHW},
				{"DDERR_NOBLTQUEUEHW",DDERR_NOBLTQUEUEHW},
				{"DDERR_NOCLIPLIST",DDERR_NOCLIPLIST},
				{"DDERR_NOCOLORCONVHW",DDERR_NOCOLORCONVHW},
				{"DDERR_NOCOOPERATIVELEVELSET",DDERR_NOCOOPERATIVELEVELSET},
				{"DDERR_NOCOLORKEY",DDERR_NOCOLORKEY},
				{"DDERR_NOCOLORKEYHW",DDERR_NOCOLORKEYHW},
				{"DDERR_NOEXCLUSIVEMODE",DDERR_NOEXCLUSIVEMODE},
				{"DDERR_NOFLIPHW",DDERR_NOFLIPHW},
				{"DDERR_NOGDI",DDERR_NOGDI},
				{"DDERR_NOMIRRORHW",DDERR_NOMIRRORHW},
				{"DDERR_NOTFOUND",DDERR_NOTFOUND},
				{"DDERR_NOOVERLAYHW",DDERR_NOOVERLAYHW},
				{"DDERR_NORASTEROPHW",DDERR_NORASTEROPHW},
				{"DDERR_NOROTATIONHW",DDERR_NOROTATIONHW},
				{"DDERR_NOSTRETCHHW",DDERR_NOSTRETCHHW},
				{"DDERR_NOT4BITCOLOR",DDERR_NOT4BITCOLOR},
				{"DDERR_NOT4BITCOLORINDEX",DDERR_NOT4BITCOLORINDEX},
				{"DDERR_NOT8BITCOLOR",DDERR_NOT8BITCOLOR},
				{"DDERR_NOTEXTUREHW",DDERR_NOTEXTUREHW},
				{"DDERR_NOVSYNCHW",DDERR_NOVSYNCHW},
				{"DDERR_NOZBUFFERHW",DDERR_NOZBUFFERHW},
				{"DDERR_NOZOVERLAYHW",DDERR_NOZOVERLAYHW},
				{"DDERR_OUTOFCAPS",DDERR_OUTOFCAPS},
				{"DDERR_OUTOFMEMORY",DDERR_OUTOFMEMORY},
				{"DDERR_OUTOFVIDEOMEMORY",DDERR_OUTOFVIDEOMEMORY},
				{"DDERR_OVERLAYCANTCLIP",DDERR_OVERLAYCANTCLIP},
				{"DDERR_OVERLAYCOLORKEYONLYONEACTIVE",DDERR_OVERLAYCOLORKEYONLYONEACTIVE},
				{"DDERR_PALETTEBUSY",DDERR_PALETTEBUSY},
				{"DDERR_COLORKEYNOTSET",DDERR_COLORKEYNOTSET},
				{"DDERR_SURFACEALREADYATTACHED",DDERR_SURFACEALREADYATTACHED},
				{"DDERR_SURFACEALREADYDEPENDENT",DDERR_SURFACEALREADYDEPENDENT},
				{"DDERR_SURFACEBUSY",DDERR_SURFACEBUSY},
				{"DDERR_SURFACEISOBSCURED",DDERR_SURFACEISOBSCURED},
				{"DDERR_SURFACELOST",DDERR_SURFACELOST},
				{"DDERR_SURFACENOTATTACHED",DDERR_SURFACENOTATTACHED},
				{"DDERR_TOOBIGHEIGHT",DDERR_TOOBIGHEIGHT},
				{"DDERR_TOOBIGSIZE",DDERR_TOOBIGSIZE},
				{"DDERR_TOOBIGWIDTH",DDERR_TOOBIGWIDTH},
				{"DDERR_UNSUPPORTED",DDERR_UNSUPPORTED},
				{"DDERR_UNSUPPORTEDFORMAT",DDERR_UNSUPPORTEDFORMAT},
				{"DDERR_UNSUPPORTEDMASK",DDERR_UNSUPPORTEDMASK},
				{"DDERR_VERTICALBLANKINPROGRESS",DDERR_VERTICALBLANKINPROGRESS},
				{"DDERR_WASSTILLDRAWING",DDERR_WASSTILLDRAWING},
				{"DDERR_XALIGN",DDERR_XALIGN},
				{"DDERR_INVALIDDIRECTDRAWGUID",DDERR_INVALIDDIRECTDRAWGUID},
				{"DDERR_DIRECTDRAWALREADYCREATED",DDERR_DIRECTDRAWALREADYCREATED},
				{"DDERR_NODIRECTDRAWHW",DDERR_NODIRECTDRAWHW},
				{"DDERR_PRIMARYSURFACEALREADYEXISTS",DDERR_PRIMARYSURFACEALREADYEXISTS},
				{"DDERR_NOEMULATION",DDERR_NOEMULATION},
				{"DDERR_REGIONTOOSMALL",DDERR_REGIONTOOSMALL},
				{"DDERR_CLIPPERISUSINGHWND",DDERR_CLIPPERISUSINGHWND},
				{"DDERR_NOCLIPPERATTACHED",DDERR_NOCLIPPERATTACHED},
				{"DDERR_NOHWND",DDERR_NOHWND},
				{"DDERR_HWNDSUBCLASSED",DDERR_HWNDSUBCLASSED},
				{"DDERR_HWNDALREADYSET",DDERR_HWNDALREADYSET},
				{"DDERR_NOPALETTEATTACHED",DDERR_NOPALETTEATTACHED},
				{"DDERR_NOPALETTEHW",DDERR_NOPALETTEHW},
				{"DDERR_BLTFASTCANTCLIP",DDERR_BLTFASTCANTCLIP},
				{"DDERR_NOBLTHW",DDERR_NOBLTHW},
				{"DDERR_NODDROPSHW",DDERR_NODDROPSHW},
				{"DDERR_OVERLAYNOTVISIBLE",DDERR_OVERLAYNOTVISIBLE},
				{"DDERR_NOOVERLAYDEST",DDERR_NOOVERLAYDEST},
				{"DDERR_INVALIDPOSITION",DDERR_INVALIDPOSITION},
				{"DDERR_NOTAOVERLAYSURFACE",DDERR_NOTAOVERLAYSURFACE},
				{"DDERR_EXCLUSIVEMODEALREADYSET",DDERR_EXCLUSIVEMODEALREADYSET},
				{"DDERR_NOTFLIPPABLE",DDERR_NOTFLIPPABLE},
				{"DDERR_CANTDUPLICATE",DDERR_CANTDUPLICATE},
				{"DDERR_NOTLOCKED",DDERR_NOTLOCKED},
				{"DDERR_CANTCREATEDC",DDERR_CANTCREATEDC},
				{"DDERR_NODC",DDERR_NODC},
				{"DDERR_WRONGMODE",DDERR_WRONGMODE},
				{"DDERR_IMPLICITLYCREATED",DDERR_IMPLICITLYCREATED},
				{"DDERR_NOTPALETTIZED",DDERR_NOTPALETTIZED},
				{"DDERR_UNSUPPORTEDMODE",DDERR_UNSUPPORTEDMODE},
				{"END",0}
};

inline char * ErrorName(HRESULT err)
{
	int e=0;
	while (strcmp(ErrorLookup[e].name,"END"))
	{
		if (err == ErrorLookup[e].errcode)
			return ErrorLookup[e].name;
		e++;
	};
	return "Unknown Error code";
}	


class CLogfile
{	
	private:
		char smalltemp[10];
		HFILE 	fh;
		OFSTRUCT of;
		BOOL bHeaderWritten;
		char *cComment;
		char line[1000];
		LONG lStartPos;
		char Path[200];
	public:
		CLogfile(char * path, char * comment = 0,BOOL bAppend=FALSE)
		{
			if (path)
				strncpy(Path,path,199);

			fh = HFILE_ERROR;
			bHeaderWritten = FALSE;
			lStartPos = 0;

			//if the file does not exist, create it:
			if (GetFileAttributes(path) == 0xffffffff)
				fh = OpenFile(path,&of,OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
			else
				//first attempt to get a lock on the file...
				for (int i=0;i<20 && fh==HFILE_ERROR;i++)
				{
					if (bAppend)
						fh = OpenFile(path,&of, OF_READWRITE|OF_SHARE_DENY_WRITE);
					else
						fh = OpenFile(path,&of, OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
					if (fh==HFILE_ERROR)
						Sleep(1000);
				}

			if (fh==HFILE_ERROR)
				return;

			lStartPos = _llseek(fh,0,SEEK_END);

			cComment = comment;
		}

		void OutputHeader(void)
		{
			//now we have the file, write user/computer info:

			//write separator, comment if necessary and date and time:
			SYSTEMTIME st;
			GetLocalTime(&st);
			wsprintf(line,"----------------------------------------------------------\r\n");
			_lwrite(fh,line,strlen(line));
			if (cComment && strlen(cComment))
			{
				wsprintf(line,"%s\r\n",cComment);
				_lwrite(fh,line,strlen(line));
			}
			wsprintf(line,"Beginning test at %d:%02d on %d/%d/%d\r\n",st.wHour,st.wMinute,st.wYear,st.wMonth,st.wDay);
			_lwrite(fh,line,strlen(line));


			//write user's name:
			DWORD length = 100;
			wsprintf(line,"User Name:");

			WNetGetUser(NULL,line+strlen(line),&length);
			_lwrite(fh,line,strlen(line));

			//write computer's name:
			wsprintf(line,"\r\nComputer Name:");
			GetComputerName(line+strlen(line),&length);
			_lwrite(fh,line,strlen(line));

			//write display driver's name:
			wsprintf(line,"\r\nDisplay driver:");
			GetPrivateProfileString("boot.description","display.drv","(Unknown)",line+strlen(line),100,"system.ini");
			_lwrite(fh,line,strlen(line));

			_lwrite(fh,"\r\n",2);

			HDC hdc = GetDC(NULL);
			if (hdc)
			{
				wsprintf(line,"Starting resolution: %dx%dx%d\r\n",
							GetDeviceCaps(hdc,HORZRES)
							,GetDeviceCaps(hdc,VERTRES)
							,GetDeviceCaps(hdc,BITSPIXEL) );
				_lwrite(fh,line,strlen(line));
				ReleaseDC(NULL,hdc);
			}
			wsprintf(line,"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n");
			_lwrite(fh,line,strlen(line));

			bHeaderWritten = TRUE;
		}
		~CLogfile()
		{
			SYSTEMTIME st;
			if(fh != HFILE_ERROR)
			{
				if (bHeaderWritten)
				{
					GetLocalTime(&st);
					wsprintf(line,"----------- Test ends at %d:%02d on %d/%d/%d -------------\r\n",st.wHour,st.wMinute,st.wYear,st.wMonth,st.wDay);
					_lwrite(fh,line,strlen(line));
				}
				_lclose(fh);
			}
		}
		CLogfile & operator << (DWORD dw)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			wsprintf(smalltemp,"%08x",dw);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (LONG dw)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			wsprintf(smalltemp,"%d",dw);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
                CLogfile & operator << (void * p)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
            wsprintf(smalltemp,"%08x",p);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (char * cp)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			while( *cp)
				*this << *cp++;
			return *this;
		}
		CLogfile & operator << (char  c)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			if (c=='\n')
			{
				wsprintf(smalltemp,"\r");
				_lwrite(fh,smalltemp,strlen(smalltemp));
			}
			wsprintf(smalltemp,"%c",c);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (CLogfile & log)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();

			LONG pos = _llseek(log.fh,0,FILE_CURRENT);
			LONG from = _llseek(log.fh,log.lStartPos,FILE_BEGIN);

			char ch;
			*this << "= = = = = = = Snapshot of ";
			if (log.Path)
				*this << log.Path;
			else
				*this << "Unknown file";
			*this << " = = = = = = =\n";

			for (LONG j=0;j<pos-from;j++)
			{
				_lread(log.fh,&ch,1);
				*this << ch;
			}

			*this << "= = = = = = = = = Snapshot ends = = = = = = = = = = =\n";
			return *this;
		}
			
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\misc\lists.h ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef	_LISTS_H
#define	_LISTS_H

#if __cplusplus
extern "C" {
#endif

#define LIST_ROOT(name, type) struct name {struct type *Root;}

#define LIST_MEMBER(type) struct { struct type **Prev; struct type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
	(root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define	LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define	TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   struct type *First;\
    struct type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   struct type *Next;\
    struct type **Prev;	/* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   struct type *Last;\
    struct type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   struct type *Prev;\
    struct type *Next;\
}

#define	CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
	(root)->Last->field.Next = (element);\
    else\
	(root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
	(root)->First->field.Prev = (element);\
    else\
	(root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
	(current_element)->field.Prev->field.Next = (element);\
    else\
	(root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define	CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
	(element)->field.Prev->field.Next = (element)->field.Next;\
    else\
	(root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.h"

void TestList(void)
{
    struct Foo
    {
	int a;
	LIST_MEMBER(Foo) ListStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
	int a;
	TAIL_QUEUE_MEMBER(Foo) TQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
	int a;
	CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
	CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
	MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
	MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
	MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
	switch(WhichInsert)
	{
	case END:
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    WhichInsert = ROOT;
	    break;
	case ROOT:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    WhichInsert = PREVIOUS;
	    break;
	case PREVIOUS:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
	    WhichInsert = DONE;
	    break;
	default:
	    assert(0);
	}

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

	pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
	pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
	assert(pFoo == &MyFoo3);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */

#if __cplusplus
}
#endif

#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\misc\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *   15-jun-98  linstev added DPF2
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>

#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && defined(WIN95)
        #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
        #define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

#ifdef __cplusplus
        extern "C" {
#endif
    /*
     * Debugging output/flow-control calls
     */
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
   extern int  DebugPrintf2(LPSTR cFilter, ...);
   extern void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...);
   extern void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...);
   extern void cdecl D3DErrorPrintf( LPSTR szFormat, ...);
#ifdef __cplusplus
    }
#endif

    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_MUTE()                              DPF_MUTEWHEN(TRUE)
    #define DPF_UNMUTE()                            DPF_MUTEWHEN(FALSE)

    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}

    #define D3D_ERR       D3DErrorPrintf
    #define D3D_WARN      D3DWarnPrintf
    #define D3D_INFO      D3DInfoPrintf
#else
    #pragma warning(disable:4002)
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_MUTE()
    #define DPF_UNMUTE()

    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()
    #define D3D_ERR(a)
    #define D3D_WARN()
    #define D3D_INFO()
#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= clock(), t ## N ++
    #define TIMESTOP(t)   t ## T += clock()
    #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(4, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\misc\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "dpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
    LONG                lAllocID;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;
static LONG             lAllocID;
static LONG             lBreakOnAllocID;
static LONG             lBreakOnMemLeak;

#if defined(_X86_)
	#define MyGetReturnAddress(first) (LPVOID) *(DWORD *)(((LPBYTE)&first)-4)
#else
	#define MyGetReturnAddress(first) _ReturnAddress()
#endif

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = MyGetReturnAddress(first); \
	pmt->dwPid = GetCurrentProcessId(); \
    pmt->lAllocID = lAllocID; \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
    if( lAllocID == lBreakOnAllocID ) \
    { \
	DebugBreak(); \
    } \
	lAllocID++; \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif

#ifndef  __DXGUSEALLOC
#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif
#endif  //!__DXGUSEALLOC

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
#ifdef __USECRTMALLOC
    return calloc( size, 1 );
#else /*__USECRTMALLOC */
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef  __DXGUSEALLOC
        #if DBG
            lptr = calloc( size, 1 );
        #else
            lptr = LocalAlloc( LPTR, size );
        #endif  //DBG
    #else 
        lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    #endif  //__DXGUSEALLOC
    DEBUG_TRACK( lptr, size );

    return lptr;
#endif //__USECRTMALLOC

} /* MemAlloc */

#ifndef  __DXGUSEALLOC
/*
 * MemSize - return size of object
 */
UINT __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return (UINT)HeapSize(hHeap, 0, lptr);
} /* MemSize */
#endif  //!__DXGUSEALLOC

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
#ifdef __USECRTMALLOC
    free( lptr );
#else /*__USECRTMALLOC */
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: lAllocID=%ld dwSize=%08lx, lpAddr=%08lx", 
            pmt, pmt->lAllocID, pmt->dwSize, pmt->lpAddr );
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: lAllocID=%ld dwSize=%08lx, lpAddr=%08lx", 
            pmt, pmt->lAllocID, pmt->dwSize, pmt->lpAddr );
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

		#ifndef NO_FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif /* !NO_FILL_ON_MEMFREE */
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

    #ifdef  __DXGUSEALLOC
        #if DBG
            free( lptr );
        #else
            LocalFree( lptr );
        #endif  //DBG
    #else 
	HeapFree( hHeap, 0, lptr );
    #endif  // __DXGUSEALLOC

    }
#endif /*__USECRTMALLOC */
} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
#ifdef __USECRTMALLOC
    return realloc( lptr, size );
#else /* __USECRTMALLOC */
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: lAllocID=%ld dwSize=%08lx, lpAddr=%08lx", 
            pmt, pmt->lAllocID, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    #ifdef  __DXGUSEALLOC
        #if DBG
            new = realloc( lptr, size );
        #else //DBG
            new = LocalReAlloc( lptr, size, LMEM_MOVEABLE|LMEM_ZEROINIT );
        #endif  //DBG
    #else //__DXGUSEALLOC
    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );
    #endif  //__DXGUSEALLOC

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	pmt->dwSize = size - sizeof( MEMTRACK );

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;
#endif /* __USECRTMALLOC */
} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    HKEY hKey = (HKEY) NULL;
#ifdef __USECRTMALLOC
    #include <crtdbg.h>
    int tmp = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
    tmp |= _CRTDBG_LEAK_CHECK_DF | _CRTDBG_ALLOC_MEM_DF;
    _CrtSetDbgFlag(tmp);
#else /* __USECRTMALLOC */
#ifndef  __DXGUSEALLOC
    if( hHeap == NULL )
    {
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
#endif  //!__DXGUSEALLOC
    #ifdef DEBUG
	lAllocCount = 0;
	lAllocID = 1;
    lBreakOnAllocID = 0;
    lBreakOnMemLeak = 0;
	lpHead = NULL;
	lpTail = NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        LONG result;
        DWORD dwType = REG_DWORD;
        DWORD dwSize = 4;
        DWORD value = 0;
        result =  RegQueryValueEx(hKey, "BreakOnAllocID", NULL, &dwType,
                                  (LPBYTE)(&value), &dwSize);
        if (result == ERROR_SUCCESS && dwType == REG_DWORD)
        {
            lBreakOnAllocID = value;
        }
        result =  RegQueryValueEx(hKey, "BreakOnMemLeak", NULL, &dwType,
                                  (LPBYTE)(&value), &dwSize);
        RegCloseKey(hKey);
        if (result == ERROR_SUCCESS && dwType == REG_DWORD)
        {
            lBreakOnMemLeak = value;
        }
    }
    #endif
#endif /* __USECRTMALLOC */
    return TRUE;
} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 6, "MemState" );
    #ifdef WIN95
    // Note: There is a well known leak of 8 bytes in Win9x, this is to discount it.
    if( lAllocCount > 1 )
    #else
    if( lAllocCount != 0 )
    #endif
    {
	DPF( 0, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 0, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    if( lBreakOnMemLeak != 0 )
    {
        DebugBreak();
    }
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 0, "Memory Address: %08lx lAllocID=%ld dwSize=%08lx, ReturnAddr=%08lx (pid=%08lx)", 
                (BYTE*)pmt + sizeof(MEMTRACK), // give the address that is returned 
                pmt->lAllocID, 
                pmt->dwSize, 
                pmt->lpAddr, 
                pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 0, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
#ifdef __USECRTMALLOC
#else /* __USECRTMALLOC */
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
#ifndef  __DXGUSEALLOC
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
	HeapDestroy( hHeap );
	hHeap = NULL;
    }
#endif  //!__DXGUSEALLOC
#endif /* __USECRTMALLOC */
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\misc\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern UINT __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\misc\w95help.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hack.c
 *  Content:    Win95 hack-o-rama code
 *              This is a HACK to handle the fact that Win95 doesn't notify
 *              a DLL when a process is destroyed.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   28-mar-95  craige  initial implementation
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  reworked for new ddhelp
 *   09-may-95  craige  loading any DLL
 *   16-sep-95  craige  bug 1117: must UnmapViewOfFile before closing handle
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96  andyco  added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo    return an HRESULT from HelperAddDPlayServer()
 *   29-jan-97  colinmc vxd handling stuff is no longer win16 lock specific
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "w95help.h"
#include "dpf.h"

#undef E_FAIL
#define E_FAIL  0x80004005L

//extern DWORD  * pdwHelperPid;
//extern HANDLE * phModule;     // must be defined
extern DWORD    dwHelperPid;
extern HINSTANCE hModule;       // must be defined


/*
 * sendRequest
 *
 * communicate a request to DDHELP
 */
static BOOL sendRequest( LPDDHELPDATA req_phd )
{
    LPDDHELPDATA        phd;
    HANDLE              hmem;
    HANDLE              hmutex;
    HANDLE              hackevent;
    HANDLE              hstartevent;
    BOOL                rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
        return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
        CloseHandle( hstartevent );
        return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( (HANDLE) 0xffffffff, NULL,
                PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
                DDHELP_SHARED_NAME );
    if( hmem == NULL )
    {
        DPF( 1, "Could not create file mapping!" );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }
    phd = (LPDDHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( phd == NULL )
    {
        DPF( 1, "Could not create view of file!" );
        CloseHandle( hmem );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DDHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
        DPF( 1, "Could not create mutex!" );
        UnmapViewOfFile( phd );
        CloseHandle( hmem );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DDHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DDHELPDATA ) );
    phd->req_id = hModule;
    if( SetEvent( hstartevent ) )
    {
        WaitForSingleObject( hackevent, INFINITE );
        memcpy( req_phd, phd, sizeof( DDHELPDATA ) );
        rc = TRUE;
    }
    else
    {
        DPF( 1, "Could not signal event to notify DDHELP" );
        rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    UnmapViewOfFile( phd );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */

/*
 * DoneWithHelperProcess
 */
void DoneWithHelperProcess( void )
{
    DDHELPDATA  hd;

    if( dwHelperPid == 0 )
    {
        return;
    }

    hd.req = DDHELPREQ_FREEDCLIST;
    sendRequest( &hd );

} /* DoneWithHelperProcess */

/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
    HANDLE      hevent;
    DWORD       rc;

    hevent = CreateEvent( NULL, TRUE, FALSE, DDHELP_STARTUP_EVENT_NAME );
    if( hevent == NULL )
    {
        return FALSE;
    }
    DPF( 3, "Wait DDHELP startup event to be triggered" );
    rc = WaitForSingleObject( hevent, 100000 );  // fail if this doesn't work within 100 seconds
    CloseHandle( hevent );
    if( rc == WAIT_TIMEOUT )
    {
        return FALSE;
    }
    return TRUE;

} /* WaitForHelperStartup */

/*
 * HelperLoadDLL
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context )
{
    DDHELPDATA  hd;
    DWORD       rc = 0;

    if( dllname != NULL )
    {
        hd.req = DDHELPREQ_LOADDLL;
        lstrcpy( hd.fname, dllname );
        if( fnname != NULL )
        {
            strcpy( hd.func, fnname );
            hd.context = context;
            DPF( 3, "Context=%08lx", context );
        }
        else
        {
            hd.func[0] = 0;
        }
        DPF( 3, "Asking DDHELP to load DLL %s", dllname );
        sendRequest( &hd );
        rc = (DWORD)hd.dwReturn;
    }

    return rc;

} /* HelperLoadDLL */


/*
 * HelperCreateThread
 */
void HelperCreateThread( void )
{
    DDHELPDATA  hd;

    hd.req = DDHELPREQ_CREATEHELPERTHREAD;
    sendRequest( &hd );

} /* HelperCreateThread */

/*
 * SignalNewProcess
 *
 * Signal DDHELP that a new process has arrived.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA  hd;

    if( pid == dwHelperPid )
    {
        DPF( 3, "Helper connected to DLL - no signal required" );
        return;
    }

    DPF( 3, "Signalling DDHELP that a new process has connected" );
    hd.req = DDHELPREQ_NEWPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */


/*
 * StopWatchProcess
 *
 * Signal DDHELP to stop watching a process.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void StopWatchProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA  hd;

    if( pid == dwHelperPid )
    {
        DPF( 3, "Helper connected to DLL - no signal required" );
        return;
    }

    DPF( 3, "Signalling DDHELP to stop watching a process" );
    hd.req = DDHELPREQ_STOPWATCHPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */

/*
 * SignalNewDriver
 *
 * Signal DDHELP that a new driver has been loaded.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewDriver( LPSTR fname, BOOL isdisp )
{
    DDHELPDATA  hd;

    DPF( 3, "Signalling DDHELP to create a new DC" );
    hd.req = DDHELPREQ_NEWDC;
    hd.isdisp = isdisp;
    lstrcpy( hd.fname, fname );
    sendRequest( &hd );

} /* SignalNewDriver */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
    if( dwHelperPid == 0 )
    {
        STARTUPINFO             si;
        PROCESS_INFORMATION     pi;
        HANDLE                  h;

        h = OpenEvent( SYNCHRONIZE, FALSE, DDHELP_STARTUP_EVENT_NAME );
        if( h == NULL )
        {
            si.cb = sizeof(STARTUPINFO);
            si.lpReserved = NULL;
            si.lpDesktop = NULL;
            si.lpTitle = NULL;
            si.dwFlags = 0;
            si.cbReserved2 = 0;
            si.lpReserved2 = NULL;

            DPF( 3, "Creating helper process now" );
            if( !CreateProcess(NULL, "ddhelp.exe",  NULL, NULL, FALSE,
                               NORMAL_PRIORITY_CLASS,
                               NULL, NULL, &si, &pi) )
            {
                DPF( 2, "Could not create DDHELP.EXE" );
                return FALSE;
            }
            dwHelperPid = pi.dwProcessId;
            DPF( 3, "Helper rocess created" );
        }
        else
        {
            DDHELPDATA  hd;
            DPF( 3, "DDHELP already exists, waiting for DDHELP event" );
            WaitForSingleObject( h, INFINITE );
            CloseHandle( h );
            DPF( 3, "Asking for DDHELP pid" );
            hd.req = DDHELPREQ_RETURNHELPERPID;
            sendRequest( &hd );
            dwHelperPid = hd.pid;
            DPF( 3, "DDHELP pid = %08lx", dwHelperPid );
        }
        *ppid = dwHelperPid;
        return TRUE;
    }
    *ppid = dwHelperPid;
    return FALSE;

} /* CreateHelperProcess */

#ifdef WIN95   //this is Just For Now... dsound will get the help it needs..jeffno 951206
/*
 * HelperWaveOpen
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx )
{
    DDHELPDATA  hd;

    if( (lphwo != NULL) && (pwfx != NULL) )
    {
        hd.req = DDHELPREQ_WAVEOPEN;
        hd.pData1 = lphwo;
        hd.dwData1 = dwDeviceID;
        hd.dwData2 = (DWORD)pwfx;
        DPF( 3, "Asking DDHELP to Open Wave Device %d", dwDeviceID );
        sendRequest( &hd );
        return hd.dwReturn;
    }
    else
    {
        DPF( 3, "Helper Wave Open param error");
        return MMSYSERR_ERROR;
    }

} /* HelperWaveOpen */

/*
 * HelperWaveClose
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveClose( DWORD hwo )
{
    DDHELPDATA  hd;

    if( (hwo != 0) )
    {
        hd.req = DDHELPREQ_WAVECLOSE;
        hd.dwData1 = hwo;
        DPF( 3, "Asking DDHELP to Close Wave Device ");
        sendRequest( &hd );
        return hd.dwReturn;
    }
    else
    {
        DPF( 3, "Helper Wave Close param error");
        return MMSYSERR_ERROR;
    }

} /* HelperWaveClose */

/*
 * HelperCreateTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperCreateTimer( DWORD dwResolution,
                         LPVOID pTimerProc,
                         DWORD dwInstanceData )
{
    DDHELPDATA  hd;

    if( (dwResolution != 0) && (pTimerProc != NULL)  )
    {
        hd.req = DDHELPREQ_CREATETIMER;
        hd.pData1 = pTimerProc;
        hd.dwData1 = dwResolution;
        hd.dwData2 = dwInstanceData;
        DPF( 3, "Asking DDHELP to Create Timer" );
        sendRequest( &hd );
        return hd.dwReturn;
    }
    else
    {
        DPF( 3, "Helper Wave Close param error");
        return MMSYSERR_ERROR;
    }

} /* HelperCreateTimer */

/*
 * HelperKillTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperKillTimer( DWORD dwTimerID )
{
    DDHELPDATA  hd;

    if( (dwTimerID != 0) )
    {
        hd.req = DDHELPREQ_KILLTIMER;
        hd.dwData1 = dwTimerID;
        DPF( 3, "Asking DDHELP to KILL Timer %X", dwTimerID );
        sendRequest( &hd );
        return hd.dwReturn;
    }
    else
    {
        DPF( 3, "Helper Wave Close param error");
        return MMSYSERR_ERROR;
    }

} /* HelperKillTimer */

/*
 * HelperCreateDSMixerThread
 *
 * get the helper to create a mixer thread.
 */
HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
                                  LPDWORD pdwThreadParam,
                                  DWORD dwFlags,
                                  LPDWORD pThreadId )
{
    DDHELPDATA  hd;

    hd.req = DDHELPREQ_CREATEDSMIXERTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSMixerThread

/*
 * HelperCreateDSFocusThread
 *
 * get the helper to create a sound focus thread.
 */
HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
                                  LPDWORD pdwThreadParam,
                                  DWORD dwFlags,
                                  LPDWORD pThreadId )
{
    DDHELPDATA  hd;

    hd.req = DDHELPREQ_CREATEDSFOCUSTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSFocusThread

/*
 * HelperCallDSEmulatorCleanup
 *
 * Call the DirectSound function which cleans up MMSYSTEM handles
 */
void HelperCallDSEmulatorCleanup( LPVOID callback,
                                  LPVOID pDirectSound )
{
    DDHELPDATA  hd;

    hd.req = DDHELPREQ_CALLDSCLEANUP;
    hd.pData1 = callback;
    hd.pData2 = pDirectSound;

    sendRequest( &hd );
}

#endif //not winnt -just for now-jeffno

/*
 * HelperCreateModeSetThread
 *
 * get the helper to load a DLL for us.
 */
BOOL HelperCreateModeSetThread(
                LPVOID callback,
                HANDLE *ph,
                LPVOID lpdd,
                DWORD hInstance )
{
    DDHELPDATA  hd;
    HANDLE      h;
    char        str[64];

    hd.req = DDHELPREQ_CREATEMODESETTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_MODESET_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
        DPF( 3, "Could not open modeset event!" );
        *ph = NULL;
        return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateModeSetThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateModeSetThread */

/*
 * HelperKillModeSetThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillModeSetThread( DWORD hInstance )
{
    DDHELPDATA  hd;

    hd.req = DDHELPREQ_KILLMODESETTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillModeSetThread */

#ifdef WIN95
/*
 * HelperCreateDOSBoxThread
 *
 * get the helper to create a thread so kernel mode can notify us of DOS box
 * changes.
 */
BOOL HelperCreateDOSBoxThread(
                LPVOID callback,
                HANDLE *ph,
                LPVOID lpdd,
                DWORD hInstance )
{
    DDHELPDATA  hd;
    HANDLE      h;
    char        str[64];

    hd.req = DDHELPREQ_CREATEDOSBOXTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_DOSBOX_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
        DPF( 3, "Could not open DOS box event!" );
        *ph = NULL;
        return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateDOSBoxThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateDOSBoxThread */

/*
 * HelperKillDOSBoxThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillDOSBoxThread( DWORD hInstance )
{
    DDHELPDATA  hd;

    hd.req = DDHELPREQ_KILLDOSBOXTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillDOSBoxThread */

#endif //!winnt

// notify dphelp.c that we have a new server on this system
DWORD HelperAddDPlayServer(DWORD port)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

        memset(&hd, 0, sizeof(DDHELPDATA));
    hd.req = DDHELPREQ_DPLAYADDSERVER;
    hd.pid = pid;
    hd. dwData1 = port;
    if (sendRequest(&hd))
                return (DWORD)hd.dwReturn;
        else
                return ((DWORD) E_FAIL);
} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(void)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    hd.req = DDHELPREQ_DPLAYDELETESERVER;
    hd.pid = pid;
    return sendRequest(&hd);

} // HelperDeleteDPlayServer

#ifdef WIN95
    /*
     * Get DDHELP to load the DirectSound VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDSVxd( void )
    {
        DDHELPDATA hd;
        hd.req = DDHELPREQ_GETDSVXDHANDLE;
        sendRequest( &hd );
        return (HANDLE) hd.dwReturn;
    } /* HelperGetDSVxd */

    /*
     * Get DDHELP to load the DirectDraw VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDDVxd( void )
    {
        DDHELPDATA hd;
        hd.req = DDHELPREQ_GETDDVXDHANDLE;
        sendRequest( &hd );
        return (HANDLE) hd.dwReturn;
    } /* HelperGetDDVxd */

#endif /* WIN95 */

/*
 * HelperSetOnDisplayChangeNotify
 *
 * get the helper to call us back if there is DisplayChange
 * message. (This is for multi-mon topology changes.)
 */
void HelperSetOnDisplayChangeNotify( void *pfn )
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_NOTIFYONDISPLAYCHANGE;
    hd.dwData1 = (DWORD_PTR)pfn;
    sendRequest( &hd );
    return;
}

HINSTANCE HelperLoadLibrary(LPCSTR pszLibraryName)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_LOADLIBRARY;
    hd.dwData1 = (DWORD_PTR)pszLibraryName;
    sendRequest(&hd);
    return (HINSTANCE)hd.dwReturn;
}

BOOL HelperFreeLibrary(HINSTANCE hInst)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_FREELIBRARY;
    hd.dwData1 = (DWORD_PTR)hInst;
    sendRequest(&hd);
    return (BOOL)hd.dwReturn;
}

void HelperAddDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_ADDDEVICECHANGENOTIFY;
    hd.pData1 = lpNotify;
    sendRequest(&hd);
}

void HelperDelDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_DELDEVICECHANGENOTIFY;
    hd.pData1 = lpNotify;
    sendRequest(&hd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\misc\w95help.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95help.h
 *  Content:	header file for Win95 helper interface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *
 ***************************************************************************/
#ifndef __W95HELP_INCLUDED__
#define __W95HELP_INCLUDED__
#include "ddhelp.h"

#ifdef __cplusplus
extern "C" {
#endif

extern void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void StopWatchProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void SignalNewDriver( LPSTR fname, BOOL isdisp );

extern BOOL CreateHelperProcess( LPDWORD ppid );

extern void DoneWithHelperProcess( void );

extern BOOL WaitForHelperStartup( void );

extern DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context );

extern void HelperCreateThread( void );

extern DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx );

extern DWORD HelperWaveClose( DWORD hwo );

extern DWORD HelperCreateTimer( DWORD dwResolution,LPVOID pTimerProc,DWORD dwInstanceData );

extern DWORD HelperKillTimer( DWORD dwTimerID );

#ifdef _WIN32
extern HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern void HelperCallDSEmulatorCleanup( LPVOID pCleanupFunc,
                                         LPVOID pDirectSound );

#endif

extern BOOL HelperCreateModeSetThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern BOOL HelperCreateDOSBoxThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern void HelperKillModeSetThread( DWORD hInstance );

extern void HelperKillDOSBoxThread( DWORD hInstance );

extern DWORD HelperAddDPlayServer(DWORD port);
extern BOOL HelperDeleteDPlayServer();

#ifdef WIN95
extern HANDLE HelperGetDSVxd( void );

extern HANDLE HelperGetDDVxd( void );

#endif

extern void HelperSetOnDisplayChangeNotify( void *pfn );
extern HINSTANCE HelperLoadLibrary(LPCSTR pszLibraryName);
extern BOOL HelperFreeLibrary(HINSTANCE hInst);
extern void HelperAddDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);
extern void HelperDelDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\misc\newdpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.c
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(DBG)

#ifdef IS_16
    #define OUTPUTDEBUGSTRING OutputDebugString
    #define GETPROFILESTRING GetProfileString
    #define GETPROFILEINT GetProfileInt
    #define WSPRINTF wsprintf
    #define WVSPRINTF wvsprintf
    #define LSTRLEN lstrlen
#else
    #define OUTPUTDEBUGSTRING OutputDebugStringA
    #define GETPROFILESTRING GetProfileStringA
    #define GETPROFILEINT GetProfileIntA
    #define WSPRINTF wsprintfA
    #define WVSPRINTF wvsprintfA
    #define LSTRLEN lstrlenA
#endif

#include "dpf.h"

#undef DEBUG_TOPIC
#define DEBUG_TOPIC(flag,name) {#flag,name,TRUE},

static
    struct {
        char cFlag[4];
        char cName[64];
        BOOL bOn;
} DebugTopics[] = {
    {"","Filler",FALSE},
    {"A","API Usage",TRUE},
#include "DBGTOPIC.H"
    {"","End",FALSE}
};

#ifndef PROF_SECT
#define PROF_SECT	"Direct3D"
#endif
#ifndef PROF_SECT_D3D
    #define PROF_SECT_D3D	"Direct3D"
#endif
#ifndef START_STR_D3D
#define START_STR_D3D       "Direct3D8: "
#endif
#define END_STR             "\r\n"


#undef DPF_MODULE_NAME
#define DPF_MODULE_NAME "Direct3D8: "

static DWORD bDetailOn = 1;

static BOOL bInited=FALSE;
static BOOL bAllowMisc=TRUE;
static bBreakOnAsserts=FALSE;
static bPrintLineNumbers=FALSE;
static bPrintFileNames=FALSE;
static bPrintExecutableName=FALSE;
static bPrintTID=FALSE;
static bPrintPID=FALSE;
static bIndentOnMessageLevel=FALSE;
static bPrintTopicsAndLevels=FALSE;
static bPrintModuleName=TRUE;
static bPrintFunctionName=FALSE;
static bRespectColumns=FALSE;
static bPrintAPIStats=FALSE;
static bPrintAllTopics=TRUE;
static bAdvancedDPFs=FALSE;

static DWORD dwFileLineTID=0;
static char cFile[100];
static char cFnName[100];
static DWORD dwLineNo;
static bMute=FALSE;

// Debug level for D3D
LONG                lD3dDebugLevel = 0;

DPF_PROC_STATS ProcStats[MAX_PROC_ORDINAL];
#ifdef cplusplus
	extern "C" {
#endif

void mystrncpy(char * to,char * from,int n)
{
    for(;n;n--)
        *(to++)=*(from++);
}

char * mystrrchr(char * in,char c)
{
    char * last=0;
    while (*in)
    {
        if (*in == c)
            last = in;
        in++;
    }
    return last;
}

char Junk[]="DPF_MODNAME undef'd";
char * DPF_MODNAME = Junk;

int DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber, LPSTR szFnName)
{
    if (!(bPrintFileNames||bPrintLineNumbers||bPrintFunctionName))
    {
        return 1;
    }
#ifdef WIN32
    dwFileLineTID = GetCurrentThreadId();
#endif
    mystrncpy (cFile,szFile,sizeof(cFile));
    mystrncpy (cFnName,szFnName,sizeof(cFnName));
    dwLineNo = dwLineNumber;
    return 1;
}

static void dumpStr( LPSTR str )
{
    /*
     * Have to warm the string, since OutputDebugString is buried
     * deep enough that it won't page the string in before reading it.
     */
    int i=0;
    if (str)
        while(str[i])
            i++;
    OUTPUTDEBUGSTRING( str );
    OUTPUTDEBUGSTRING("\n");
}

void DebugPrintfInit(void)
{
    signed int lDebugLevel;
    int i;
    char cTopics[100];

    lD3dDebugLevel = GetProfileInt( PROF_SECT_D3D, "debug", 0 );

    bDetailOn=1;

    for (i=0;i<LAST_TOPIC;i++)
        DebugTopics[i].bOn=FALSE;

    //ZeroMemory(ProcStats,sizeof(ProcStats));

    GETPROFILESTRING( "DirectX", DPF_CONTROL_LINE, "DefaultTopics", cTopics, sizeof(cTopics) );
    if (!strcmp(cTopics,"DefaultTopics"))
    {
        DebugSetTopicsAndLevels("");
        bAllowMisc=TRUE;
        bPrintAllTopics=TRUE;
        lDebugLevel = (signed int) GETPROFILEINT( PROF_SECT, "debug", 0 );
        if (lDebugLevel <0)
        {
            if (lDebugLevel < -9)
                lDebugLevel=-9;

            bDetailOn |= (1<<(-lDebugLevel));
        }
        else
        {
            for (i=0;i<= (lDebugLevel<10?lDebugLevel:10);i++)
                bDetailOn |= 1<<i;
        }
    }
    else
    {
        bAdvancedDPFs=TRUE;
        DebugSetTopicsAndLevels(cTopics);
        if (!strcmp(cTopics,"?") && !bInited)
        {
            dumpStr("--------------" DPF_MODULE_NAME " Debug Output Control -------------");
            dumpStr("Each character on the control line controls a topic, a detail");
            dumpStr("level or an extra info. E.g. 0-36A@ means print detail levels 0");
            dumpStr("through 3 and 6 for topic A with source file name and line numbers.");
            dumpStr("The extra info control characters are:");
            dumpStr("   !: Break on asserts");
            dumpStr("   ^: Print TID of calling thread");
            dumpStr("   #: Print PID of calling process");
            dumpStr("   >: Indent on message detail levels");
            dumpStr("   &: Print the topic and detail level of each message");
            dumpStr("   =: Print function name");
            dumpStr("   +: Print all topics, including topic-less");
            dumpStr("   / or -: do not allow topic-less messages");
            dumpStr("   @ or $: Print source filename and line number of DPF");
            dumpStr("Topics for this module are:");
            for(i=0;strcmp(DebugTopics[i].cName,"End");i++)
            {
                OUTPUTDEBUGSTRING("   ");
                OUTPUTDEBUGSTRING(DebugTopics[i].cFlag);
                OUTPUTDEBUGSTRING(": ");
                dumpStr(DebugTopics[i].cName);
            }
            dumpStr("Tip: Use 0-3A to get debug info about API calls");
        }
    }
    bInited=TRUE;
}


/*
 *
 * The full output can be:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn) Messagemessagemessage
 * or, if indentation turned on:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn)        Messagemessagemessage
 */
int DebugPrintf(DWORD dwDetail, ...)
{
#define MSGBUFFERSIZE  1000
    BOOL        bAllowed=FALSE;
    BOOL        bMiscMessage=TRUE;
    char        cMsg[MSGBUFFERSIZE];
    char        cTopics[20];
    DWORD_PTR   arg;
    LPSTR       szFormat;
    int         i;
#ifdef WIN95
    char        szTemp[MSGBUFFERSIZE];    
    char       *psz = NULL;
#endif

    va_list ap;


    if (!bInited)
        DebugPrintfInit();

    //error checking:
    if (dwDetail >= 10)
        return 1;

    if ( (bDetailOn & (1<<dwDetail)) == 0 )
        return 1;

    if (bMute)
        return 1;
    va_start(ap,dwDetail);
    WSPRINTF(cTopics,"%d",dwDetail);

    //Pull out which topics this DPF refers to
    while ( (arg = va_arg(ap,DWORD_PTR)) <256 )
    {
        if (arg>0 && arg < LAST_TOPIC)
        {
            bMiscMessage=FALSE;
            if (DebugTopics[arg].bOn)
                bAllowed = TRUE;
        }
    }

    //if this message has no topics, then it's a misc message.
    //we turn them on only if allowed (i.e. "-" is not in the enable string).
    //And level zero messages are always allowed
    if (bMiscMessage)
    {
        if (bAllowMisc || dwDetail == 0)
            bAllowed=TRUE;
    }
    else
    {
        //topic-ed message is only allowed if the advanced DPF line is set in [DirectX]
        if (!bAdvancedDPFs)
            bAllowed=FALSE;
    }

    //Advanced DPFs have the option ("+") to print every topic
    if (bAdvancedDPFs)
    {
        if ( bPrintAllTopics )
            bAllowed=TRUE;
    }

    if (!bAllowed)
        return FALSE;

    szFormat = (LPSTR) arg;

    cMsg[0]=0;

    /*
     * Add the module name first
     */

    if (bPrintModuleName)
    {
        WSPRINTF( cMsg+strlen(cMsg),DPF_MODULE_NAME);
    }

    if (dwDetail==0)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(ERROR) :" );
    }
    if (dwDetail==1)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(WARN) :" );
    }
    if (dwDetail==2)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(INFO) :" );
    }


    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"(");

#ifdef WIN32
#if 0
    /*
     * deleted due to RIP in GetModuleFilename on debug windows when win16 lock held
     */
    if (bPrintExecutableName)
    {
        GetModuleFileName(NULL,str,256);
        if (mystrrchr(str,'\\'))
            WSPRINTF(cMsg+strlen(cMsg),"%12s",mystrrchr(str,'\\')+1);
    }
#endif
    if (bPrintPID)
    {
        if (bPrintExecutableName)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Px%02x",GetCurrentProcessId());
    }

    if (bPrintTID)
    {
        if (bPrintExecutableName || bPrintPID)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Tx%04x",GetCurrentThreadId());
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"):");
#endif

    if (bPrintFunctionName)
    {
        WSPRINTF( cMsg+strlen(cMsg),cFnName);
    }

    if (bPrintFileNames || bPrintLineNumbers)
    {
        if (mystrrchr(cFile,'\\'))
            WSPRINTF( cMsg+strlen(cMsg),":%12s",mystrrchr(cFile,'\\')+1 );
        else
            WSPRINTF( cMsg+strlen(cMsg),":%12s",cFile);
        WSPRINTF( cMsg+strlen(cMsg),"@%d",dwLineNo);
    }

    if (bPrintTopicsAndLevels)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(%3s)",cTopics);
    }

    if (cMsg[strlen(cMsg)-1] != ':')
        WSPRINTF( cMsg+strlen(cMsg),":");

    if (bIndentOnMessageLevel)
    {
        for(i=0;(DWORD)i<dwDetail;i++)
            strcat(cMsg," ");
    }

    //  7/07/2000(RichGr) - IA64:  The %p format specifier that can handle either a 32-bit
    //     or a 64-bit pointer doesn't work on Win95 or Win98 - it's not recognized.  So it
    //     needs to be replaced in Win9x builds.
#ifdef WIN95
    strcpy(szTemp, szFormat);           // Copy to a local string that we can modify.

    //////////////////////////////////////////////////////////////////////////////////////////////
    //WARNING:  This code does not handle escape sequences using %p.  Extra code must be added to 
    //          deal with that case if necessary
    //////////////////////////////////////////////////////////////////////////////////////////////

    while (psz = strstr(szTemp, "%p"))  // Look for each "%p".
        *(psz+1) = 'x';                 // Substitute 'x' for 'p'.  Don't try to expand the string.

    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szTemp, ap);       // Use the local, modified string.
#else
    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szFormat, ap);     // Standard code for Win2K/Whistler/IA64.
#endif

    if (bAllowed)
        dumpStr( cMsg );

    va_end(ap);
    return 1;

}

void DebugSetMute(BOOL bMuteFlag)
{
    bMute=bMuteFlag;
}

void DebugEnterAPI(char *pFunctionName , LPDWORD pIface)
{
    DebugPrintf(2,A,"%08x->%s",pIface,pFunctionName);
}

void DebugSetTopicsAndLevels(char * cTopics)
{
    int i;
    int j;
    bAllowMisc=TRUE;
    bBreakOnAsserts=FALSE;
    bPrintLineNumbers=FALSE;
    bPrintFileNames=FALSE;
    bPrintExecutableName=FALSE;
    bPrintTID=FALSE;
    bPrintPID=FALSE;
    bIndentOnMessageLevel=FALSE;
    bPrintTopicsAndLevels=FALSE;
    bPrintFunctionName=FALSE;
    bPrintAPIStats=FALSE;
    bPrintAllTopics=FALSE;
    bDetailOn=1;    /* always print detail level 0*/


    for (i=0;(DWORD)i<strlen(cTopics);i++)
    {
        switch (cTopics[i])
        {
        case '/':
        case '-':
            bAllowMisc=FALSE;
            break;
        case '!':
            bBreakOnAsserts=TRUE;
            break;
        case '@':
            bPrintLineNumbers=TRUE;
            break;
        case '$':
            bPrintFileNames=TRUE;
            break;
#if 0
            /*
             * Currently deleted because GetModuleFilename causes a RIP on debug windows when the win16
             * lock is held.
             */
        case '?':
            bPrintExecutableName=TRUE;
            break;
#endif
        case '^':
            bPrintTID=TRUE;
            break;
        case '#':
            bPrintPID=TRUE;
            break;
        case '>':
            bIndentOnMessageLevel=TRUE;
            break;
        case '&':
            bPrintTopicsAndLevels=TRUE;
            break;
        case '=':
            bPrintFunctionName=TRUE;
            break;
        case '%':
            bPrintAPIStats=TRUE;
            break;
        case '+':
            bPrintAllTopics=TRUE;
            break;
        default:
            if (cTopics[i]>='0' && cTopics[i]<='9')
            {
                if (cTopics[i+1]=='-')
                {
                    if (cTopics[i+2]>='0' && cTopics[i+2]<='9')
                    {
                        for(j=cTopics[i]-'0';j<=cTopics[i+2]-'0';j++)
                            bDetailOn |= 1<<j;
                        i+=2;
                    }
                }
                else
                    bDetailOn |= 1<<(cTopics[i]-'0');
            }
            else
            {
                for(j=0;j<LAST_TOPIC;j++)
                    if (cTopics[i]==DebugTopics[j].cFlag[0])
                        DebugTopics[j].bOn=TRUE;
            }
        } //end switch
    }
}


/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    WSPRINTF( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( bBreakOnAsserts || GETPROFILEINT( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}

static void cdecl 
D3Dprintf( UINT lvl, LPSTR msgType, LPSTR szFormat, va_list ap)
{
    char    str[256];
    //char  str2[256];

    BOOL    allow = FALSE;

    if (bMute)
        return;

    if( lD3dDebugLevel < 0 )
    {
        if(  (UINT) -lD3dDebugLevel == lvl )
        {
            allow = TRUE;
        }
    }
    else if( (UINT) lD3dDebugLevel >= lvl )
    {
        allow = TRUE;
    }

    if( allow )
    {
        wsprintf( (LPSTR) str, START_STR_D3D );
        wsprintf( (LPSTR) str+lstrlen( str ), msgType );

#ifdef WIN95
        {
            char szTmp[512];
            char *psz = szTmp;
            strncpy(szTmp, szFormat, 512);

            // %p does not work on Windows95.
            // We look for each "%p" and substitute 'x' for 'p'
            // WARNING:  This code does not handle escape sequences using %p.  
            //           Extra code must be added to deal with that case 
            //          if necessary
            while (psz = strstr(psz, "%p"))  
                *(psz+1) = 'x';

            wvsprintf( str+lstrlen( str ), szTmp, ap); 
        }
#else
        wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );
#endif // WIN95

        lstrcat( (LPSTR) str, END_STR );
        dumpStr( str );
    }

} /* D3Dprintf */

void cdecl 
D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...)
{
    va_list ap;
    va_start(ap, szFormat);

    D3Dprintf(lvl, "(INFO) :", szFormat, ap);

    va_end(ap);
}

void cdecl 
D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...)
{
    va_list ap;
    va_start(ap,szFormat);

    D3Dprintf(lvl, "(WARN) :", szFormat, ap);
    va_end(ap);
}

void cdecl 
D3DErrorPrintf( LPSTR szFormat, ...)
{
    va_list ap;
    va_start(ap,szFormat);

    D3Dprintf(0, "(ERROR) :", szFormat, ap);
    va_end(ap);
}

#ifdef cplusplus
}
#endif

#else // !debug

void DebugSetMute(BOOL bMuteFlag)
{
}

#endif //defined debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\common\dxtn.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// dxtn.cpp
//
// Direct3D Reference Rasterizer - DXTn texture compression functions
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"

// Primary color components (use DirextX byte ordering)
#undef RED
#define RED   0
#undef GRN
#define GRN   1
#undef BLU
#define BLU   2
#undef ALFA
#define ALFA 3

typedef struct
{
    float       rgba[4];
} FCOLOR;       // internal color format

//
// Processing all primaries is such a common idiom
// that we define a macro for this action.
// Any self-respecting C compiler should easily optimize
// this by unrolling the loop!
//
#define ForAllPrimaries     for( primary = 0; primary < NUM_PRIMARIES; ++primary)

// Similarly, processing all pixels in a block is a common idiom.
#define ForAllPixels        for(pixel=0; pixel < DXT_BLOCK_PIXELS; ++pixel)

#define NUM_PRIMARIES   3
#define NUM_COMPONENTS  4
//
// Quantization constants for RGB565
//
#define PRIMARY_BITS    8

#define RED_BITS    5
#define GRN_BITS    6
#define BLU_BITS    5

#define RED_SHIFT       (PRIMARY_BITS-RED_BITS)
#define GRN_SHIFT       (PRIMARY_BITS-GRN_BITS)
#define BLU_SHIFT       (PRIMARY_BITS-BLU_BITS)

#if 0
#define RED_MASK    0xf8
#define GRN_MASK    0xfc
#define BLU_MASK    0xf8
#endif

// Weighting for each primary based on NTSC luminance
static  float   wtPrimary[NUM_PRIMARIES] =
{
    0.0820f,    // blue
    0.6094f,    // green
    0.3086f     // red
};

//-----------------------------------------------------------------------------
//
// unpack a fixed point color
//
//-----------------------------------------------------------------------------
static  void    RGBToColor (RGB565 *prgb, DXT_COLOR *pcolor)
{
    WORD    rgb;
    DXT_COLOR      color;

    rgb = *((WORD *)prgb);

    // pick off bits in groups of 5, 6, and 5
    color.rgba[BLU] = (unsigned char) rgb;
    rgb >>= BLU_BITS;
    color.rgba[GRN] = (unsigned char) rgb;
    rgb >>= GRN_BITS;
    color.rgba[RED] = (unsigned char) rgb;

    // shift primaries into the appropriate LSBs
    color.rgba[BLU] <<= BLU_SHIFT;
    color.rgba[GRN] <<= GRN_SHIFT;
    color.rgba[RED] <<= RED_SHIFT;

    // replicate primaries MSBs into LSBs
    color.rgba[BLU] |= color.rgba[BLU] >> BLU_BITS;
    color.rgba[GRN] |= color.rgba[GRN] >> GRN_BITS;
    color.rgba[RED] |= color.rgba[RED] >> RED_BITS;

    *pcolor = color;
}

//-----------------------------------------------------------------------------
//
// DecodeBlockRGB - decompress a color block
//
//-----------------------------------------------------------------------------
void DecodeBlockRGB (DXTBlockRGB *pblockSrc, DXT_COLOR colorDst[DXT_BLOCK_PIXELS])
{
    int     lev;
    DXT_COLOR      clut[4];
    PIXBM   pixbm;
    int     pixel;
    int     primary;

    // if source block is invalid, ...
    if (pblockSrc == NULL)
        return;

    // determine the number of color levels in the block
    lev = (pblockSrc->rgb0 <= pblockSrc->rgb1) ? 2 : 3;

    // Fill extrema values into pixel code lookup table.
    RGBToColor(&pblockSrc->rgb0, &clut[0]);
    RGBToColor(&pblockSrc->rgb1, &clut[1]);

    clut[0].rgba[ALFA] =
    clut[1].rgba[ALFA] =
    clut[2].rgba[ALFA] = 255;

    if (lev == 3)
    {   // No transparency info present, all color info.
        ForAllPrimaries
        {
            WORD temp0 = clut[0].rgba[primary];   // jvanaken fixed overflow bug
            WORD temp1 = clut[1].rgba[primary];
            clut[2].rgba[primary] = (BYTE)((2*temp0 + temp1 + 1)/3);
            clut[3].rgba[primary] = (BYTE)((temp0 + 2*temp1 + 1)/3);
        }
        clut[3].rgba[ALFA] = 255;
    }
    else
    {   // transparency info.
        ForAllPrimaries
        {
            WORD temp0 = clut[0].rgba[primary];   // jvanaken fixed overflow bug
            WORD temp1 = clut[1].rgba[primary];
            clut[2].rgba[primary] = (BYTE)((temp0 + temp1)/2);
            clut[3].rgba[primary] = 0;     // jvanaken added this
        }
        clut[3].rgba[ALFA] = 0;
    }

    // munge a local copy
    pixbm = pblockSrc->pixbm;

    // Look up the actual pixel color in the table.
    ForAllPixels
    {
        // lookup color from pixel bitmap
        ForAllPrimaries
            colorDst[pixel].rgba[primary] = clut[pixbm & 3].rgba[primary];

        colorDst[pixel].rgba[ALFA] = clut[pixbm & 3].rgba[ALFA];

        // prepare to extract next index
        pixbm >>= 2;
    }
}

//-----------------------------------------------------------------------------
// DecodeBlockAlpha4 - decompress a block with alpha at 4 BPP
//-----------------------------------------------------------------------------
void DecodeBlockAlpha4(DXTBlockAlpha4 *pblockSrc, DXT_COLOR colorDst[DXT_BLOCK_PIXELS])
{
    int     row, col;
    WORD    alpha;

    DecodeBlockRGB(&pblockSrc->rgb, colorDst);

    for (row = 0; row < 4; ++row)
    {
        alpha = pblockSrc->alphabm[row];

        for (col = 0; col < 4; ++col)
        {
            colorDst[4 * row + col].rgba[ALFA] =
                 ((alpha & 0xf) << 4)
                | (alpha & 0xf);
            alpha >>= 4;
        }
    }
}

//-----------------------------------------------------------------------------
//
// DecodeBlockAlpha3 - decompress a block with alpha at 3 BPP
//
//-----------------------------------------------------------------------------
void DecodeBlockAlpha3(DXTBlockAlpha3 *pblockSrc, DXT_COLOR colorDst[DXT_BLOCK_PIXELS])
{
    int     pixel;
    int     alpha[8];       // alpha lookup table
    DWORD   dwBM = 0;       // alpha bitmap in DWORD cache

    DecodeBlockRGB(&pblockSrc->rgb, colorDst);

    alpha[0] = pblockSrc->alpha0;
    alpha[1] = pblockSrc->alpha1;

    if (alpha[0] > alpha[1]) // 8 alpha ramp
    {   // interpolate intermediate colors
        alpha[2] = (6 * alpha[0] + 1 * alpha[1]) / 7;
        alpha[3] = (5 * alpha[0] + 2 * alpha[1]) / 7;
        alpha[4] = (4 * alpha[0] + 3 * alpha[1]) / 7;
        alpha[5] = (3 * alpha[0] + 4 * alpha[1]) / 7;
        alpha[6] = (2 * alpha[0] + 5 * alpha[1]) / 7;
        alpha[7] = (1 * alpha[0] + 6 * alpha[1]) / 7;
    }
    else // else 6 alpha ramp with 0 and 255
    {   // interpolate intermediate colors
        alpha[2] = (4 * alpha[0] + 1 * alpha[1]) / 5;
        alpha[3] = (3 * alpha[0] + 2 * alpha[1]) / 5;
        alpha[4] = (2 * alpha[0] + 3 * alpha[1]) / 5;
        alpha[5] = (1 * alpha[0] + 4 * alpha[1]) / 5;
        alpha[6] = 0;
        alpha[7] = 255;
    }

    ForAllPixels
    {   // reload bitmap dword cache every 8 pixels
        if ((pixel & 7) == 0)
        {
            if (pixel == 0)
            {   // pack 3 bytes into dword
                dwBM  = pblockSrc->alphabm[2];
                dwBM <<= 8;
                dwBM |= pblockSrc->alphabm[1];
                dwBM <<= 8;
                dwBM |= pblockSrc->alphabm[0];
            }
            else // pixel == 8
            {   // pack 3 bytes into dword
                dwBM  = pblockSrc->alphabm[5];
                dwBM <<= 8;
                dwBM |= pblockSrc->alphabm[4];
                dwBM <<= 8;
                dwBM |= pblockSrc->alphabm[3];
            }
        }

        // unpack bitmap dword 3 bits at a time
        colorDst[pixel].rgba[ALFA] = (BYTE)alpha[(dwBM & 7)];
        dwBM >>= 3;
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\common\debugmon.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// debugmon.cpp
//
// Direct3D Debug Monitor
//
///////////////////////////////////////////////////////////////////////////////
/*

WORKLIST

- vertex shader source <-> debugger

*/

#include "pch.cpp"
#pragma hdrstop

#include <process.h>
#include "d3ddm.hpp"

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
D3DDebugMonitor::D3DDebugMonitor( void )
{

    // get pid and create DebugTargetContext sharedmem
    int pid = _getpid();
    m_pTgtCtxSM = new D3DSharedMem( sizeof(DebugTargetContext), D3DDM_TGTCTX_SM "%d", pid );
    if( m_pTgtCtxSM == NULL )
    {
        DPFERR( "new D3DSharedMem failed" );
        m_pTgtCtx = NULL;
        m_pTgtCtxSM = NULL;
        m_hTgtEventBP = NULL;
        m_hTgtEventAck = NULL;
        goto Error_Return;
    }
    
    m_pTgtCtx = (DebugTargetContext*)(m_pTgtCtxSM->GetPtr());
    memset( m_pTgtCtx, 0x0, sizeof(DebugTargetContext) );
    m_pTgtCtx->ProcessID = pid;
    m_pTgtCtx->Version = D3DDM_VERSION;

    // create target events
    char name[128];
    _snprintf( name, 128, D3DDM_TGT_EVENTBP "%d", m_pTgtCtx->ProcessID );
    m_hTgtEventBP = CreateEvent( NULL, FALSE, FALSE, name );
    _ASSERT( m_hTgtEventBP ,"CreateEvent for target event BP failed")
    _snprintf( name, 128, D3DDM_TGT_EVENTACK "%d", m_pTgtCtx->ProcessID );
    m_hTgtEventAck = CreateEvent( NULL, FALSE, FALSE, name );
    _ASSERT( m_hTgtEventAck ,"CreateEvent for target event ACK failed");
    
Error_Return:

    // null out monitor connections
    m_pMonCtx = NULL;
    m_pMonCtxSM = NULL;
    m_pCmdData = NULL;
    m_pCmdDataSM = NULL;
    m_hMonEventCmd = 0;
    return;
    
}
//-----------------------------------------------------------------------------
D3DDebugMonitor::~D3DDebugMonitor( void )
{
    // send disconnect event to monitor
    m_pTgtCtx->EventStatus = D3DDM_EVENT_TARGETEXIT;
    SetEvent( m_hTgtEventBP );

    DetachMonitorConnection();
    CloseHandle( m_hTgtEventBP );
    CloseHandle( m_hTgtEventAck );
    delete m_pTgtCtxSM;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
HRESULT
D3DDebugMonitor::AttachToMonitor( int iMon )
{
#if(D3D_DEBUGMON>0x00)
    if (iMon < 1) return E_FAIL;
    if (MonitorConnected() || !m_bDbgMonConnectionEnabled)
    {
        return E_FAIL;
    }

    // attach to monitor context
    m_pMonCtxSM = new D3DSharedMem( sizeof(DebugMonitorContext), D3DDM_MONCTX_SM "%d", iMon );
    if ( (m_pMonCtxSM == NULL) || !m_pMonCtxSM->AlreadyExisted() ) goto _fail_return; // monitor not there

    // get pointer to monitor context bits
    m_pMonCtx = (const DebugMonitorContext*)m_pMonCtxSM->GetPtr();
    if (m_pMonCtx->TargetID) goto _fail_return; // monitor already taken

    // request attachment to this context (cast to non-const just this once...)
    ((DebugMonitorContext*)m_pMonCtx)->TargetIDRequest = m_pTgtCtx->ProcessID;

    // attach to monitor event acknowledge
    char name[128];
    _snprintf( name, 128, D3DDM_MON_EVENTCMD "%d", iMon );
    m_hMonEventCmd = OpenEvent( EVENT_ALL_ACCESS, NULL, name );

    // signal monitor via it's own event (just this once) and wait for reply on our ack
    DPFINFO("D3DDebugTarget - attempting to attach to monitor");
    SignalObjectAndWait( m_hMonEventCmd, m_hTgtEventAck, INFINITE, FALSE );
    if ( m_pMonCtx->TargetID != m_pTgtCtx->ProcessID ) goto _fail_return;

    // monitor is attached to this target
    m_pTgtCtx->MonitorID = iMon;

    // attach to command data SM
    m_pCmdDataSM = new D3DSharedMem( D3DDM_CMDDATA_SIZE,
        D3DDM_CMDDATA_SM "%d", m_pTgtCtx->MonitorID );
    m_pCmdData = (DebugMonitorContext*)(m_pCmdDataSM->GetPtr());

    // tell monitor that we are done attaching
    SetEvent( m_hTgtEventBP );
    DPFINFO("D3DDebugTarget - debug monitor attached");

    return S_OK;

_fail_return:
    if (m_pMonCtxSM) delete m_pMonCtxSM;
    m_pMonCtxSM = NULL;
    m_pMonCtx = NULL;
    if (m_hMonEventCmd) CloseHandle( m_hMonEventCmd ); m_hMonEventCmd = 0;
    return E_FAIL;
#else
    return E_FAIL;
#endif
}

//-----------------------------------------------------------------------------
// drop connection
//-----------------------------------------------------------------------------
void
D3DDebugMonitor::DetachMonitorConnection( void )
{
#if(D3D_DEBUGMON>0x00)
    if (MonitorConnected())
        DPFINFO("D3DDebugTarget - debug monitor detached");

    // drop attachment to monitor and delete monitor context attachment
    m_pTgtCtx->MonitorID = 0;   // let monitor know it is being dropped
    if (NULL != m_pMonCtxSM) delete m_pMonCtxSM; m_pMonCtxSM = NULL;
    m_pMonCtx = NULL;
    if (NULL != m_pCmdDataSM) delete m_pCmdDataSM; m_pCmdDataSM = NULL;
    m_pCmdData = NULL;
    ResetEvent( m_hMonEventCmd );
    if (m_hMonEventCmd) CloseHandle( m_hMonEventCmd ); m_hMonEventCmd = NULL;
#endif
}

//-----------------------------------------------------------------------------
// check for lost monitor connection, and clean up if necessary
//-----------------------------------------------------------------------------
BOOL
D3DDebugMonitor::CheckLostMonitorConnection( void )
{
#if(D3D_DEBUGMON>0x00)
    if ( !m_pMonCtx )
    {
        // not connected
        return TRUE;
    }

    if ( m_pMonCtx->TargetID != m_pTgtCtx->ProcessID )
    {
        // we have been disconnected
        DetachMonitorConnection();
        return TRUE;
    }
    return FALSE;
#else
    return TRUE;
#endif
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
BOOL
D3DDebugMonitor::IsEventBreak( UINT32 EventType )
{
    BOOL bReturn = FALSE;

#define _D3DDM_EVENT_CASE( _Event) \
    case D3DDM_EVENT_##_Event: if (MonitorEventBP() & D3DDM_EVENT_##_Event) { bReturn = TRUE; } break

    // keep this as single line per event - convenient place to set debugger breakpoints
    switch ( EventType )
    {

    _D3DDM_EVENT_CASE(RSTOKEN);
    _D3DDM_EVENT_CASE(BEGINSCENE);
    _D3DDM_EVENT_CASE(ENDSCENE);

    _D3DDM_EVENT_CASE(VERTEX);
    _D3DDM_EVENT_CASE(VERTEXSHADERINST);

    _D3DDM_EVENT_CASE(PRIMITIVE);
    _D3DDM_EVENT_CASE(PIXEL);
    _D3DDM_EVENT_CASE(PIXELSHADERINST);

    default: break;
    }
    return bReturn;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
HRESULT
D3DDebugMonitor::MonitorBreakpoint( void )
{
    CheckLostMonitorConnection();

    if ( !MonitorConnected() ) return S_OK;

    // tell monitor that we are at an event breakpoint
    SetEvent( m_hTgtEventBP );
    DPFINFO("D3DDebugTarget - stopped in debug monitor");

    // spin here responding to commands until command given to go
    BOOL bResume = FALSE;
    while ( !bResume )
    {
        // wait for command to be issued (or monitor dropped)
        WaitForSingleObject( m_hMonEventCmd, INFINITE );
        if ( CheckLostMonitorConnection() )
        {
            bResume = TRUE;
            break;
        }

        // process command
        switch ( m_pMonCtx->Command & D3DDM_CMD_MASK )
        {
        case D3DDM_CMD_GO:
            m_pTgtCtx->CommandBufferSize = 0;
            bResume = TRUE;
            break;
        default:
            ProcessMonitorCommand();
            break;
        }
        // acknowledge command processing done
        SetEvent( m_hTgtEventAck );
    }
    DPFINFO("D3DDebugTarget - resumed");

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\common\pixref.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// PixRef.cpp
//
// Direct3D Reference Device - Pixel Buffer Referencing
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

extern int g_DXTBlkSize[];

//-----------------------------------------------------------------------------
//
// PixelAddress - Form character address of locations within buffers using base
// pointer, pitch and type.
//
//-----------------------------------------------------------------------------

//
// common internal version
//
char*
PixelAddress(
    int iX, int iY, int iZ, int iSample,
    BYTE* pBits, int iYPitch, int iZPitch, int cSamples, RDSurfaceFormat SType )
{
    // initialize return value to start of scan line (pitch is always in bytes)
    BYTE* pPixAddr = pBits + iY*iYPitch + iZ*iZPitch;

    // bump along scan line depending on surface type to point to pixel data
    switch ( SType )
    {
    default:
        _ASSERTf(0, ("Unknown RDSurfaceFormat value %08x", SType));
        return NULL;
    case RD_SF_NULL:
        break;

    case RD_SF_B8G8R8A8:
    case RD_SF_B8G8R8X8:
    case RD_SF_U8V8L8X8:
    case RD_SF_Z24S8:
    case RD_SF_Z24X8:
    case RD_SF_S8Z24:
    case RD_SF_X8Z24:
    case RD_SF_Z24X4S4:
    case RD_SF_X4S4Z24:
    case RD_SF_Z32S0:
    case RD_SF_U8V8W8Q8:
    case RD_SF_U10V11W11:
    case RD_SF_U16V16:
    case RD_SF_R10G10B10A2:
    case RD_SF_R8G8B8A8:
    case RD_SF_R8G8B8X8:
    case RD_SF_R16G16:
    case RD_SF_U11V11W10:
    case RD_SF_U10V10W10A2:
    case RD_SF_U8V8X8A8:
    case RD_SF_U8V8X8L8:
        pPixAddr += (iX*cSamples*4 + iSample*4);
        break;

    case RD_SF_B5G6R5:
    case RD_SF_B5G5R5X1:
    case RD_SF_B5G5R5A1:
    case RD_SF_P8A8:
    case RD_SF_L8A8:
    case RD_SF_U8V8:
    case RD_SF_U5V5L6:
    case RD_SF_Z16S0:
    case RD_SF_Z15S1:
    case RD_SF_S1Z15:
    case RD_SF_B4G4R4A4:
    case RD_SF_B4G4R4X4:
    case RD_SF_YUY2:
    case RD_SF_UYVY:
    case RD_SF_B2G3R3A8:
        pPixAddr += (iX*cSamples*2 + iSample*2);
        break;

    case RD_SF_B8G8R8:
        pPixAddr += (iX*cSamples*3 + iSample*3);
        break;

    case RD_SF_PALETTE8:
    case RD_SF_L8:
    case RD_SF_A8:
    case RD_SF_B2G3R3:
    case RD_SF_L4A4:
        pPixAddr += (iX*cSamples*1 + iSample*1);
        break;

    case RD_SF_PALETTE4:
        pPixAddr += (iX>>1);
        break;

    // For the DXT texture formats, obtain the address of the
    // block from whih to decompress the texel from
    case RD_SF_DXT1:
    case RD_SF_DXT2:
    case RD_SF_DXT3:
    case RD_SF_DXT4:
    case RD_SF_DXT5:
        pPixAddr = pBits + iZ*iZPitch + (iY >> 2)*iYPitch + (iX>>2) *
            g_DXTBlkSize[(int)SType - (int)RD_SF_DXT1];
        break;
    }
    return (char *)pPixAddr;
}

//
// external versions
//
char*
PixelAddress(
    int iX, int iY, int iZ,
    BYTE* pBits, int iYPitch, int iZPitch, RDSurfaceFormat SType )
{
    return PixelAddress( iX, iY, iZ, 0, pBits, iYPitch, iZPitch, 1, SType );
}

char*
PixelAddress(
    int iX, int iY, int iZ, int iSample, RDSurface2D* pRT )
{
    return PixelAddress( iX, iY, iZ, iSample,
        pRT->GetBits(), pRT->GetPitch(), 0 /* pRT->GetSlicePitch() */,
        pRT->GetSamples(), pRT->GetSurfaceFormat() );
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\common\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////
#include "refdev.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\common\maplegcy.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// MapLegcy.cpp
//
// Direct3D Reference Rasterizer - Mapping Legacy Modes to Current Functionality
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// MapLegacyTextureFilter - Map filter state from renderstate to per-stage state.
// This is invoked when a texture is bound via the TEXTUREHANDLE renderstate,
// indicating that we are in 'legacy' texture mode.  The rasterizer always
// refers to per-stage filtering control state, so in legacy mode the filtering
// controls in the renderstate are mapped into the filtering controls associated
// with the texture object bound to D3DRS_TEXTUREHANDLE.
//
//-----------------------------------------------------------------------------
void
RefDev::MapLegacyTextureFilter( void )
{
    // first check if anisotropic filtering is enabled (indicated by the
    // limit value being set to > 1) - if so then aniso filter will be used
    // for linear mag filter or 'linear within map' min filter
    BOOL bAnisoEnabled = ( m_dwRenderState[D3DRENDERSTATE_ANISOTROPY] > 1 );

    // D3D legacy filter specifications are (XXXMIP)YYY where XXX is the
    // mip filter and YYY is the filter used within an LOD

    // map MAG filter - legacy support is point or linear (and maybe aniso)
    switch ( m_dwRenderState[D3DRENDERSTATE_TEXTUREMAG] )
    {
    default:
    case D3DFILTER_NEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MAGFILTER] = D3DTEXF_POINT;
        break;
    case D3DFILTER_LINEAR:
        // select based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MAGFILTER] =
            bAnisoEnabled ? D3DTEXF_ANISOTROPIC : D3DTEXF_LINEAR;
        break;
    }
    // map MIN and MIP filter at the same time - legacy support
    // has them intermingled...
    switch ( m_dwRenderState[D3DRENDERSTATE_TEXTUREMIN] )
    {
    case D3DFILTER_NEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] = D3DTEXF_POINT;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTEXF_NONE;
        break;
    case D3DFILTER_MIPNEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] = D3DTEXF_POINT;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTEXF_POINT;
        break;
    case D3DFILTER_LINEARMIPNEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] = D3DTEXF_POINT;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTEXF_LINEAR;
        break;
    case D3DFILTER_LINEAR:
        // select min filter based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] =
            bAnisoEnabled ? D3DTEXF_ANISOTROPIC : D3DTEXF_LINEAR;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTEXF_NONE;
        break;
    case D3DFILTER_MIPLINEAR:
        // select min filter based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] =
            bAnisoEnabled ? D3DTEXF_ANISOTROPIC : D3DTEXF_LINEAR;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTEXF_POINT;
        break;
    case D3DFILTER_LINEARMIPLINEAR:
        // select based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] =
            bAnisoEnabled ? D3DTEXF_ANISOTROPIC : D3DTEXF_LINEAR;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTEXF_LINEAR;
        break;
    }
}


//-----------------------------------------------------------------------------
//
// MapLegacyTextureBlend - Maps legacy (pre-DX6) texture blend modes to DX6
// texture blending controls.  Uses per-stage program mode (first stage only).
// This mapping is done whenever the legacy TBLEND renderstate is set, and
// does overwrite any previously set DX6 texture blending controls.
//
//-----------------------------------------------------------------------------
void
RefDev::MapLegacyTextureBlend( void )
{
    // disable texture blend processing stage 1 (this also disables subsequent stages)
    m_TextureStageState[1].m_dwVal[D3DTSS_COLOROP] = D3DTOP_DISABLE;

    // set texture blend processing stage 0 to match legacy mode
    switch ( m_dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND] )
    {
    default:
    case D3DTBLEND_DECALMASK: // unsupported - do decal
    case D3DTBLEND_DECAL:
    case D3DTBLEND_COPY:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_SELECTARG1;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG1;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        break;

    case D3DTBLEND_MODULATEMASK: // unsupported - do modulate
    case D3DTBLEND_MODULATE:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_MODULATE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        // a special legacy alpha operation is called for that depends
        // on the format of the texture
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_LEGACY_ALPHAOVR;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_MODULATEALPHA:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_MODULATE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_MODULATE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_DECALALPHA:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_BLENDTEXTUREALPHA;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_ADD:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_ADD;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\common\rdsurf.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// texmap.cpp
//
// Direct3D Reference Rasterizer - Texture Map Access Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// FindOutSurfFormat
//
// Converts a DDPIXELFORMAT to RDSurfaceFormat.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT  pDdPixFmt,
                  RDSurfaceFormat* pFmt,
                  BOOL*   pbIsDepth)
{
    if( pbIsDepth ) *pbIsDepth = FALSE;

    if (pDdPixFmt->dwFourCC == D3DFMT_Q8W8V8U8 )
    {
        *pFmt = RD_SF_U8V8W8Q8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_W11V11U10 )
    {
        *pFmt = RD_SF_U10V11W11;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_V16U16 )
    {
        *pFmt = RD_SF_U16V16;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_R8G8B8 )
    {
        *pFmt = RD_SF_B8G8R8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_A8 )
    {
        *pFmt = RD_SF_A8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_A8P8 )
    {
        *pFmt = RD_SF_P8A8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_X4R4G4B4 )
    {
        *pFmt = RD_SF_B4G4R4X4;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_A2B10G10R10)
    {
        *pFmt = RD_SF_R10G10B10A2;
    }
#if 0
    else if (pDdPixFmt->dwFourCC == D3DFMT_A8B8G8R8)
    {
        *pFmt = RD_SF_R8G8B8A8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_X8B8G8R8)
    {
        *pFmt = RD_SF_R8G8B8X8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_W10V11U11)
    {
        *pFmt = RD_SF_U11V11W10;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_A8X8V8U8)
    {
        *pFmt = RD_SF_U8V8X8A8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_L8X8V8U8)
    {
        *pFmt = RD_SF_U8V8X8L8;
    }
#endif
    else if (pDdPixFmt->dwFourCC == D3DFMT_G16R16)
    {
        *pFmt = RD_SF_R16G16;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_A2W10V10U10)
    {
        *pFmt = RD_SF_U10V10W10A2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y'))
    {
        *pFmt = RD_SF_UYVY;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2'))
    {
        *pFmt = RD_SF_YUY2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '1'))
    {
        *pFmt = RD_SF_DXT1;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '2'))
    {
        *pFmt = RD_SF_DXT2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '3'))
    {
        *pFmt = RD_SF_DXT3;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '4'))
    {
        *pFmt = RD_SF_DXT4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '5'))
    {
        *pFmt = RD_SF_DXT5;
    }
    else if (pDdPixFmt->dwFourCC == 0xFF000004)
    {
        // This is an example of a IHV-specific format
        // The HIWORD must be the PCI-ID of the IHV
        // and the third byte must be zero.
        // In this case, we're using a sample PCI-ID of
        // FF00, and we're denoting the 4th format
        // by that PCI-ID
        *pFmt = RD_SF_Z32S0;
    }
    else if (pDdPixFmt->dwFlags & DDPF_ZBUFFER)
    {
        if( pbIsDepth ) *pbIsDepth = TRUE;
        switch(pDdPixFmt->dwZBitMask)
        {
        default:
        case 0x0000FFFF: *pFmt = RD_SF_Z16S0; break;
        case 0xFFFFFF00:
            switch(pDdPixFmt->dwStencilBitMask)
            {
            default:
            case 0x00000000: *pFmt = RD_SF_Z24X8; break;
            case 0x000000FF: *pFmt = RD_SF_Z24S8; break;
            case 0x0000000F: *pFmt = RD_SF_Z24X4S4; break;
            }
            break;
        case 0x00FFFFFF:
            switch(pDdPixFmt->dwStencilBitMask)
            {
            default:
            case 0x00000000: *pFmt = RD_SF_X8Z24; break;
            case 0xFF000000: *pFmt = RD_SF_S8Z24; break;
            case 0x0F000000: *pFmt = RD_SF_X4S4Z24; break;
            }
            break;
        case 0x0000FFFE: *pFmt = RD_SF_Z15S1; break;
        case 0x00007FFF: *pFmt = RD_SF_S1Z15; break;
        case 0xFFFFFFFF: *pFmt = RD_SF_Z32S0; break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_BUMPDUDV)
    {
        UINT uFmt = pDdPixFmt->dwBumpDvBitMask;
        switch (uFmt)
        {
        case 0x0000ff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 32:
                *pFmt = RD_SF_U8V8L8X8;
                break;
            case 16:
                *pFmt = RD_SF_U8V8;
                break;
            }
            break;

        case 0x000003e0:
            *pFmt = RD_SF_U5V5L6;
            break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED8)
    {
        if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
        {
            *pFmt = RD_SF_P8A8;
        }
        else
        {
            *pFmt = RD_SF_PALETTE8;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED4)
    {
        *pFmt = RD_SF_PALETTE4;
    }
    else if (pDdPixFmt->dwFlags & DDPF_ALPHA)
    {
        if (pDdPixFmt->dwAlphaBitDepth == 8)
        {
            *pFmt = RD_SF_A8;
        }
        else
        {
            *pFmt = RD_SF_NULL;
        }
    }
    else
    {
        UINT uFmt = pDdPixFmt->dwGBitMask | pDdPixFmt->dwRBitMask;

        if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
        {
            uFmt |= pDdPixFmt->dwRGBAlphaBitMask;
        }

        switch (uFmt)
        {
        case 0x00ffff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 32:
                *pFmt = RD_SF_B8G8R8X8;
                break;
            case 24:
                *pFmt = RD_SF_B8G8R8;
                break;
            }
            break;
        case 0xffffff00:
            *pFmt = RD_SF_B8G8R8A8;
            break;
        case 0xffe0:
            if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
            {
                *pFmt = RD_SF_B5G5R5A1;
            }
            else
            {
                *pFmt = RD_SF_B5G6R5;
            }
            break;
        case 0x07fe0:
            *pFmt = RD_SF_B5G5R5X1;
            break;
        case 0xff0:
            *pFmt = RD_SF_B4G4R4X4;
            break;
        case 0xfff0:
            *pFmt = RD_SF_B4G4R4A4;
            break;
        case 0xff:
            if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
            {
                *pFmt = RD_SF_L4A4;
            }
            else
            {
                *pFmt = RD_SF_L8;
            }
            break;
        case 0xffff:
            *pFmt = RD_SF_L8A8;
            break;
        case 0xfc:
            *pFmt = RD_SF_B2G3R3;
            break;
        case 0xfffc:
            *pFmt = RD_SF_B2G3R3A8;
            break;
        default:
            *pFmt = RD_SF_NULL;
            break;
        }
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// ValidMipmapSize
//
// Computes size of next smallest mipmap level, clamping at 1
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize)
{
    if (iPreSize == 1)
    {
        if (iSize == 1)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return ((iPreSize >> 1) == iSize);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// RDPalette
//
//////////////////////////////////////////////////////////////////////////////
const DWORD RDPalette::RDPAL_ALPHAINPALETTE = (1 << 0);
const DWORD RDPalette::m_dwNumEntries = 256;

HRESULT
RDPalette::Update( WORD StartIndex, WORD wNumEntries, PALETTEENTRY* pEntries )
{
    _ASSERT( StartIndex < m_dwNumEntries, "Bad StartIndex\n" );
    _ASSERT( StartIndex+wNumEntries <= m_dwNumEntries, "Too many entries\n" );

    for( WORD i = 0; i < wNumEntries; i++ )
    {
        m_Entries[StartIndex+i] = D3DCOLOR_ARGB( pEntries[i].peFlags,
                                                 pEntries[i].peRed,
                                                 pEntries[i].peGreen,
                                                 pEntries[i].peBlue );
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
//
// Constructor/Destructor
//
//-----------------------------------------------------------------------------
RDSurface2D::RDSurface2D( void )
{
    m_pRefDev = NULL;
    m_uFlags = 0;
    m_iWidth = 0;
    m_iHeight = 0;
    m_iDepth = 0;
    m_cLOD = 0;
    m_SurfFormat = RD_SF_NULL;
    m_dwColorKey = 0;
    m_dwEmptyFaceColor = 0;
    m_pPalette = 0;
    m_pPalObj = NULL;
    m_cLODDDS = 0;
    m_hTex = 0;
    m_bHasAlpha = 0;

    memset(m_pBits, 0, sizeof(m_pBits));
    memset(m_iPitch, 0, sizeof(m_iPitch));
    memset(m_iSlicePitch, 0, sizeof(m_iSlicePitch));
    memset(m_pDDSLcl, 0, sizeof(m_pDDSLcl));

    m_cDimension = 0;
    memset(m_fTexels, 0, sizeof(m_fTexels));
    memset(m_cTexels, 0, sizeof(m_cTexels));
}
//-----------------------------------------------------------------------------
RDSurface2D::~RDSurface2D( void )
{
}

DWORD
RDSurface2D::ComputePitch( LPDDRAWI_DDRAWSURFACE_LCL pLcl,
                           RDSurfaceFormat SurfFormat,
                           DWORD width, DWORD height ) const
{
    if ((SurfFormat == RD_SF_DXT1) ||
        (SurfFormat == RD_SF_DXT2) ||
        (SurfFormat == RD_SF_DXT3) ||
        (SurfFormat == RD_SF_DXT4) ||
        (SurfFormat == RD_SF_DXT5))
    {
        // Note, here is the assumption that:
        // 1) width and height are reported correctly by the runtime.
        // 2) The allocation of the memory is contiguous (as done by hel)
        return (((width+3)>>2) *
                g_DXTBlkSize[(int)SurfFormat - (int)RD_SF_DXT1]);
    }
#if 0
    else if( (SurfFormat == RD_SF_YUY2) ||
             (SurfFormat == RD_SF_UYVY) )
    {
        // Same assumptions as for DXTn.
        return (DDSurf_Pitch(pLcl)/height);
    }
#endif
    else
    {
        return DDSurf_Pitch(pLcl);
    }
}

DWORD
RDSurface2D::ComputePitch( LPDDRAWI_DDRAWSURFACE_LCL pLcl ) const
{
    return ComputePitch( pLcl, m_SurfFormat, m_iWidth, m_iHeight );
}

//-----------------------------------------------------------------------------
//
// RDSurface2D::Initialize()
//
//-----------------------------------------------------------------------------
HRESULT
RDSurface2D::Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLcl )
{
    HRESULT hr = D3D_OK;
    RDSurfaceFormat SurfFormat;
    DDSCAPS2 ddscaps;
    LPDDRAWI_DDRAWSURFACE_GBL  pGbl = pLcl->lpGbl;
    LPDDRAWI_DDRAWSURFACE_MORE pMore = pLcl->lpSurfMore;
    memset(&ddscaps, 0, sizeof(ddscaps));

    UINT wMultiSampleCount = 0xfL & pMore->ddsCapsEx.dwCaps3;
    //Older than DX8 runtimes place a zero in this field
    if (wMultiSampleCount == 0)
        wMultiSampleCount = 1;

    if( pLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE )
        m_SurfType |= RR_ST_TEXTURE;

    if( pLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
    {
        m_iSamples = wMultiSampleCount;
        m_SurfType |= RR_ST_RENDERTARGETDEPTH;
    }

    if( pLcl->ddsCaps.dwCaps & DDSCAPS_3DDEVICE )
    {
        m_iSamples = wMultiSampleCount;
        m_SurfType |= RR_ST_RENDERTARGETCOLOR;
    }

    m_iWidth = DDSurf_Width(pLcl);
    m_iHeight = DDSurf_Height(pLcl);
    HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLcl)), &SurfFormat, NULL));
    m_SurfFormat = SurfFormat;

    if (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
    {
        // low word of ddsCaps.ddsCapsEx.dwCaps4 has depth
        // (volume texture only).
        m_iDepth = LOWORD(pMore->ddsCapsEx.dwCaps4);
    }
    else
    {
        m_iDepth = 0;
    }
    m_cTexels[0][0] = m_iWidth;
    m_cTexels[0][1] = m_iHeight;
    m_cTexels[0][2] = m_iDepth;
    m_fTexels[0][0] = (float)m_cTexels[0][0];
    m_fTexels[0][1] = (float)m_cTexels[0][1];
    m_fTexels[0][2] = (float)m_cTexels[0][2];

    m_cLOD = 0;

    if( wMultiSampleCount > 1 )
    {
        RDCREATESURFPRIVATE* pPriv = (RDCREATESURFPRIVATE*)pGbl->dwReserved1;
        m_pBits[0]  = pPriv->pMultiSampleBits;
        m_iPitch[0] = pPriv->dwMultiSamplePitch;
    }
    else
    {
        m_pBits[0] = (BYTE *)SURFACE_MEMORY(pLcl);
        m_iPitch[0] = ComputePitch( pLcl );
    }

    if (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
    {
        // set slice pitch (volume texture only).
        m_iSlicePitch[0] = pGbl->lSlicePitch;
    }
    else
    {
        m_iSlicePitch[0] = 0;
    }

    // If the surface is not a texture early out.
    if( (pLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) == 0 )
    {
        SetInitialized();
        return S_OK;
    }

    // Set the transparent bit and the transparent color with pDDS[0]
    if ((pLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) != 0)
    {
        m_uFlags |= RR_TEXTURE_HAS_CK;
        m_dwColorKey = pLcl->ddckCKSrcBlt.dwColorSpaceLowValue;
    }
    else
    {
        m_uFlags &= ~RR_TEXTURE_HAS_CK;
    }

    // set the empty face color with pDDS[0]
    // note that ddckCKDestOverlay is unioned with dwEmptyFaceColor,
    // but not in the internal structure
    m_dwEmptyFaceColor = pLcl->ddckCKDestOverlay.dwColorSpaceLowValue;

    if (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
    {
        m_uFlags |= RR_TEXTURE_VOLUME;
        m_cDimension = 3;
    }
    else
    {
        m_cDimension = 2;
    }

    // Compute sizes and pitches

    // We need to gather info on all surfaces under the top-level
    // mipmap face (This test is DX7+ runtime dependent)
    if ((0 == (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL)) &&
        (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) )
    {
        m_uFlags |= RR_TEXTURE_CUBEMAP;

        LPDDRAWI_DDRAWSURFACE_LCL pDDSNextLcl;
        ddscaps.dwCaps = DDSCAPS_TEXTURE;

        m_pDDSLcl[0]     = pLcl;
        m_pBits[0]       = (BYTE *)SURFACE_MEMORY(m_pDDSLcl[0]);
        m_iPitch[0]      = ComputePitch( m_pDDSLcl[0] );
        m_iSlicePitch[0] = 0;

        // get rest of top level surfaces, in order
        for (INT i = 1; i < 6; i++)
        {
            switch(i)
            {
            case 1: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEX; break;
            case 2: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_POSITIVEY; break;
            case 3: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEY; break;
            case 4: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_POSITIVEZ; break;
            case 5: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEZ; break;
            }
            ddscaps.dwCaps2 |= DDSCAPS2_CUBEMAP;
            pDDSNextLcl = NULL;
            hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pDDSNextLcl);
            if ((hr != D3D_OK) && (hr != DDERR_NOTFOUND))
            {
                return hr;
            }
            if (hr == DDERR_NOTFOUND)
            {
                m_pDDSLcl[i] = NULL;
                return hr;
            }
            else
            {
                m_pDDSLcl[i] = pDDSNextLcl;
            }

            m_pBits[i]       = (BYTE *)SURFACE_MEMORY(m_pDDSLcl[i]);
            m_iPitch[i]      = ComputePitch( m_pDDSLcl[i] );
            m_iSlicePitch[i] = 0;

            m_cTexels[i][0] = DDSurf_Width(m_pDDSLcl[i]);
            m_cTexels[i][1] = DDSurf_Height(m_pDDSLcl[i]);
            m_fTexels[i][0] = (float)m_cTexels[i][0];
            m_fTexels[i][1] = (float)m_cTexels[i][1];
        }

        for (i = 0; i < 6; i++)
        {
            pLcl = m_pDDSLcl[i];
            m_cLOD = 0;

            if (pLcl)
            {
                // Check for mipmap if any.
                LPDDRAWI_DDRAWSURFACE_LCL  pTmpSLcl;

                // iPreSizeU and iPreSizeV store the size(u and v) of the
                // previous level mipmap. They are init'ed with the first
                // texture size.
                INT16 iPreSizeU = (INT16)m_iWidth;
                INT16 iPreSizeV = (INT16)m_iHeight;
                for (;;)
                {
                    ddscaps.dwCaps = DDSCAPS_TEXTURE;
                    ddscaps.dwCaps2 = DDSCAPS2_MIPMAPSUBLEVEL;
                    pTmpSLcl = NULL;
                    hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pTmpSLcl);
                    if (hr != D3D_OK && hr != DDERR_NOTFOUND)
                    {
                        return hr;
                    }
                    if (hr == DDERR_NOTFOUND)
                    {
                        break;
                    }
                    pLcl = pTmpSLcl;
                    pGbl  = pLcl->lpGbl;
                    pMore = pLcl->lpSurfMore;
                    m_cLOD ++;
                    INT iMap = m_cLOD*6+i;
                    m_pDDSLcl[iMap] = pLcl;
                    m_pBits[iMap]   = (BYTE *)SURFACE_MEMORY(pLcl);
                    m_iPitch[iMap]  = ComputePitch( pLcl, m_SurfFormat,
                                                    m_iWidth>>m_cLOD,
                                                    m_iHeight>>m_cLOD );
                    if (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
                    {
                        // set slice pitch
                        // (volume texture only).
                        m_iSlicePitch[iMap] = pGbl->lSlicePitch;
                    }
                    else
                    {
                        m_iSlicePitch[iMap] = 0;
                    }
                    m_cTexels[iMap][0] = DDSurf_Width(pLcl);
                    m_cTexels[iMap][1] = DDSurf_Height(pLcl);
                    m_fTexels[iMap][0] = (float)m_cTexels[iMap][0];
                    m_fTexels[iMap][1] = (float)m_cTexels[iMap][1];

                    // Check for invalid mipmap texture size
                    if (!ValidMipmapSize(iPreSizeU,
                                         (INT16)DDSurf_Width(pLcl)) ||
                        !ValidMipmapSize(iPreSizeV,
                                         (INT16)DDSurf_Height(pLcl)))
                    {
                        return DDERR_INVALIDPARAMS;
                    }
                    iPreSizeU = (INT16)DDSurf_Width(pLcl);
                    iPreSizeV = (INT16)DDSurf_Height(pLcl);
                }
            }
        }
    }
    else if ((0 == (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL) &&
             (0 == (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP))) )

    {
        //This surface is not a top-level cubemap.
        //Maybe it's a top-level mipmap. Go find its sublevels.

        m_pDDSLcl[0] = pLcl;
        // Check for mipmap if any.
        LPDDRAWI_DDRAWSURFACE_LCL pTmpSLcl;
        // iPreSizeU and iPreSizeV store the size(u and v) of the previous
        // level mipmap. They are init'ed with the first texture size.
        INT16 iPreSizeU = (INT16)m_iWidth;
        INT16 iPreSizeV = (INT16)m_iHeight;
        for (;;)
        {
            ddscaps.dwCaps = DDSCAPS_TEXTURE;
            ddscaps.dwCaps2 = DDSCAPS2_MIPMAPSUBLEVEL;
            pTmpSLcl = NULL;
            hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pTmpSLcl);
            if (hr != D3D_OK && hr != DDERR_NOTFOUND)
            {
                return hr;
            }
            if (hr == DDERR_NOTFOUND)
            {
                break;
            }
            pLcl  = pTmpSLcl;
            pGbl  = pLcl->lpGbl;
            pMore = pLcl->lpSurfMore;
            m_cLOD ++;
            m_pDDSLcl[m_cLOD] = pLcl;

            // Save the pointer to the real bits and the pitch.
            m_pBits[m_cLOD] = (BYTE *)SURFACE_MEMORY(pLcl);
            m_iPitch[m_cLOD] = ComputePitch( pLcl, m_SurfFormat,
                                             m_iWidth>>m_cLOD,
                                             m_iHeight>>m_cLOD );
            if (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
            {
                // set slice pitch (volume texture only).
                m_iSlicePitch[m_cLOD] = pGbl->lSlicePitch;
            }
            else
            {
                m_iSlicePitch[m_cLOD] = 0;
            }

            // Check for invalid mipmap texture size
            if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width(pLcl)) ||
                !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height(pLcl)))
            {
                return DDERR_INVALIDPARAMS;
            }
            iPreSizeU = (INT16)DDSurf_Width(pLcl);
            iPreSizeV = (INT16)DDSurf_Height(pLcl);

            m_cTexels[m_cLOD][0] = DDSurf_Width(pLcl);
            m_cTexels[m_cLOD][1] = DDSurf_Height(pLcl);
            if (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
                m_cTexels[m_cLOD][2] = LOWORD(pMore->ddsCapsEx.dwCaps4);
            else
                m_cTexels[m_cLOD][2] = 0;
            m_fTexels[m_cLOD][0] = (float)m_cTexels[m_cLOD][0];
            m_fTexels[m_cLOD][1] = (float)m_cTexels[m_cLOD][1];
            m_fTexels[m_cLOD][2] = (float)m_cTexels[m_cLOD][2];
        }
    }

    // Copy the palette
    // UpdatePalette();

    m_cLODDDS = m_cLOD;

    if ( !(Validate()) )
    {
        return DDERR_GENERIC;
    }

    SetInitialized();
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// UpdatePalette
//
//----------------------------------------------------------------------------
void
RDSurface2D::UpdatePalette()
{
    // Update palette
    if (m_SurfFormat == RD_SF_PALETTE8 || m_SurfFormat == RD_SF_PALETTE4 || m_SurfFormat == RD_SF_P8A8 )
    {
#if 0
        // This code needs to be revived in case the DX6 DDI
        //  emulation is ever implemented in RefDev.
        if (m_pDDSLcl[0]->lpDDPalette)
        {
            LPDDRAWI_DDRAWPALETTE_GBL pPal =
                m_pDDSLcl[0]->lpDDPalette->lpLcl->lpGbl;
            m_pPalette = (DWORD*)pPal->lpColorTable;
            if (pPal->dwFlags & DDRAWIPAL_ALPHA)
            {
                m_uFlags |= RR_TEXTURE_ALPHAINPALETTE;
            }
            else
            {
                m_uFlags &= ~RR_TEXTURE_ALPHAINPALETTE;
            }
        }
#endif
        _ASSERT( m_pPalObj, "No Palette set for this paletted texture\n" );
        m_pPalette = m_pPalObj->GetEntries();
        if( m_SurfFormat == RD_SF_PALETTE8 || m_SurfFormat == RD_SF_PALETTE4 )
        {
            if( m_pPalObj->HasAlpha() )
            {
                m_uFlags |= RR_TEXTURE_ALPHAINPALETTE;
            }
            else
            {
                m_uFlags &= ~RR_TEXTURE_ALPHAINPALETTE;
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Validate - Updates private data.  Must be called anytime public data is
// altered.
//
//-----------------------------------------------------------------------------
BOOL
RDSurface2D::Validate( void )
{
    // validate inputs
    if ( m_cLOD >= RD_MAX_CLOD ) // too many LODs
    {
        DPFRR(1,"RDSurface2D::Validate failed. Too many LODs");
        return FALSE;
    }

    // compute the 'has alpha' flag
    m_bHasAlpha = FALSE;
    switch ( m_SurfFormat )
    {
    case RD_SF_A8:
    case RD_SF_P8A8:
    case RD_SF_B8G8R8A8:
    case RD_SF_B5G5R5A1:
    case RD_SF_B4G4R4A4:
    case RD_SF_L8A8:
    case RD_SF_L4A4:
    case RD_SF_B2G3R3A8:
    case RD_SF_DXT1:
    case RD_SF_DXT2:
    case RD_SF_DXT3:
    case RD_SF_DXT4:
    case RD_SF_DXT5:
        m_bHasAlpha = TRUE;
        break;
    case RD_SF_PALETTE4:
    case RD_SF_PALETTE8:
        m_bHasAlpha = ( m_uFlags & RR_TEXTURE_ALPHAINPALETTE ) ? TRUE : FALSE;
        break;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------

inline UINT8 CLAMP_BYTE(double f)
{
    if (f > 255.0) return 255;
    if (f < 0.0) return 0;
    return (BYTE) f;
}

//-----------------------------------------------------------------------------
// TexelFromBlock - decompress a color block and obtain texel color
//-----------------------------------------------------------------------------
UINT32 TexelFromBlock(RDSurfaceFormat surfType, char *pblockSrc,
                      int x, int y)
{
    UINT32 index = ((y & 0x3)<<2) + (x & 0x3);
    DDRGBA colorDst[DXT_BLOCK_PIXELS];

    switch(surfType)
    {
    case RD_SF_DXT1:
        DecodeBlockRGB((DXTBlockRGB *)pblockSrc, (DXT_COLOR *)colorDst);
        break;
    case RD_SF_DXT2:
    case RD_SF_DXT3:
        DecodeBlockAlpha4((DXTBlockAlpha4 *)pblockSrc,
                          (DXT_COLOR *)colorDst);
        break;
    case RD_SF_DXT4:
    case RD_SF_DXT5:
        DecodeBlockAlpha3((DXTBlockAlpha3 *)pblockSrc,
                          (DXT_COLOR *)colorDst);
        break;
    }

    return RGBA_MAKE(colorDst[index].red,
                     colorDst[index].green,
                     colorDst[index].blue,
                     colorDst[index].alpha);
}

//-----------------------------------------------------------------------------
//
// ReadTexelColor - Reads texel from texture map at given LOD; converts to
// RDColor format, applying palette if necessary; also performs colorkey by
// returning match information
//
//-----------------------------------------------------------------------------
void
RDSurface2D::ReadColor(
    INT32 iX, INT32 iY, INT32 iZ, INT32 iLOD,
    RDColor& Texel, BOOL &bColorKeyKill )
{
    if ( (iLOD > m_cLOD) && !(m_uFlags & RR_TEXTURE_CUBEMAP) )
    {
        return;
    }
    if ( NULL == m_pBits[iLOD] ) { return; }

    char* pSurfaceBits =
        PixelAddress( iX, iY, iZ, m_pBits[iLOD],
                      m_iPitch[iLOD], m_iSlicePitch[iLOD], m_SurfFormat );

    switch ( m_SurfFormat )
    {
    default:
        Texel.ConvertFrom( m_SurfFormat, pSurfaceBits );
        break;

    case RD_SF_P8A8:
        {
            UINT8 uIndex = *((UINT8*)pSurfaceBits);
            Texel.ConvertFrom( RD_SF_B8G8R8A8, (char*)((UINT32*)m_pPalette + uIndex) );
            Texel.A = *((UINT8*)pSurfaceBits+1)/255.f;
        }
        break;

    case RD_SF_PALETTE8:
        {
            UINT8 uIndex = *((UINT8*)pSurfaceBits);
            Texel.ConvertFrom( RD_SF_B8G8R8A8, (char*)((UINT32*)m_pPalette + uIndex) );
            if ( !( m_uFlags & RR_TEXTURE_ALPHAINPALETTE ) )  Texel.A = 1.f;
        }
        break;

    case RD_SF_PALETTE4:
        {
            UINT8 uIndex = *((INT8*)pSurfaceBits);
            if ((iX & 1) == 0) { uIndex &= 0xf; }
            else               { uIndex >>= 4;  }
            Texel.ConvertFrom( RD_SF_B8G8R8A8, (char*)((UINT32*)m_pPalette + uIndex) );
            if ( !( m_uFlags & RR_TEXTURE_ALPHAINPALETTE ) )  Texel.A = 1.f;
        }
        break;

    case RD_SF_UYVY:
    case RD_SF_YUY2:
        // Converts a given YUV (8bits each) to RGB scaled between 0 and 255
        // These are using the YCrCb to RGB algorithms given on page 30
        // in "VIDEO DEMYSTIFIED" by Keith Jack
        // ISBN#: 1-878707-09-4
        // IN PC graphics, even though they call it YUV, it is really YCrCb
        // formats that are used by most framegrabbers etc. Hence the pixel
        // data we will obtain in these YUV surfaces will most likely be this
        // and not the original YUV which is actually used in PAL broadcast
        // only (NTSC uses YIQ). So really, U should be called Cb (Blue color
        // difference) and V should be called Cr (Red color difference)
        //
        // These equations are meant to handle the following ranges
        // (from the same book):
        // Y (16 to 235), U and V (16 to 240, 128 = zero)
        //          -----------
        //           Y   U   V
        //          -----------
        // White  : 180 128 128
        // Black  : 16  128 128
        // Red    : 65  100 212
        // Green  : 112 72  58
        // Blue   : 35  212 114
        // Yellow : 162 44  142
        // Cyan   : 131 156 44
        // Magenta: 84  184 198
        //          -----------
        // It is assumed that the gamma corrected RGB range is (0 - 255)
        //
        // UYVY: U0Y0 V0Y1 U2Y2 V2Y3 (low byte always has current Y)
        // If iX is even, hight-byte has current U (Cb)
        // If iX is odd, hight-byte has previous V (Cr)
        //
        // YUY2: Y0U0 Y1V0 Y2U2 Y3V2 (high byte always has current Y)
        //       (UYVY bytes flipped)
        //
        // In this algorithm, we use U and V values from two neighboring
        // pixels
        {
            UINT8 Y, U, V;
            UINT16 u16Curr = *((UINT16*)pSurfaceBits);
            UINT16 u16ForU = 0; // Extract U from this
            UINT16 u16ForV = 0; // Extract V from this

            // By default we assume YUY2. Change it later if it is UYVY
            int uvShift = 8;
            int yShift  = 0;

            if (m_SurfFormat == RD_SF_UYVY)
            {
                uvShift = 0;
                yShift  = 8;
            }

            if ((iX & 1) == 0)
            {
                // For even numbered pixels:
                // Current U is available.
                // Current V is available in the next pixel.
                u16ForU = u16Curr;

                // Obtain V from the next pixel
                u16ForV = *((UINT16*)PixelAddress( iX+1, iY, iZ,
                                                   m_pBits[iLOD],
                                                   m_iPitch[iLOD],
                                                   m_iSlicePitch[iLOD],
                                                   m_SurfFormat ));

                U = (u16ForU >> uvShift) & 0xff;
                V = (u16ForV >> uvShift) & 0xff;
            }
            else
            {
                UINT16 u16ForU1 = 0, u16ForU2 = 0;
                UINT16 u16ForV1 = 0, u16ForV2 = 0;

                // For odd numbered pixels. Neither current U nor V are
                // available.

                // Obtain U by interpolating U from i-1 and i+1 pixels.
                _ASSERT( iX > 0, "iX is negative" );
                u16ForU1 = *((UINT16*)PixelAddress( iX-1, iY, iZ,
                                                    m_pBits[iLOD],
                                                    m_iPitch[iLOD],
                                                    m_iSlicePitch[iLOD],
                                                    m_SurfFormat ));

                if( (iX+1) < (m_iWidth >> iLOD) )
                {
                    u16ForU2 = *((UINT16*)PixelAddress( iX+1, iY, iZ,
                                                        m_pBits[iLOD],
                                                        m_iPitch[iLOD],
                                                        m_iSlicePitch[iLOD],
                                                        m_SurfFormat ));
                    U = (((u16ForU1 >> uvShift) & 0xff) +
                         ((u16ForU2 >> uvShift) & 0xff)) >> 1;

                }
                else
                {
                    U = (u16ForU1 >> uvShift) & 0xff;
                }

                // Obtain V by interpolating V from i and i+2 pixels.
                u16ForV1 = u16Curr;
                if( (iX+2) < (m_iWidth >> iLOD) )
                {
                    u16ForV2 = *((UINT16*)PixelAddress( iX+2, iY, iZ,
                                                        m_pBits[iLOD],
                                                        m_iPitch[iLOD],
                                                        m_iSlicePitch[iLOD],
                                                        m_SurfFormat ));
                    V = (((u16ForV1 >> uvShift) & 0xff) +
                         ((u16ForV2 >> uvShift) & 0xff)) >> 1;

                }
                else
                {
                    V = (u16ForV1 >> uvShift) & 0xff;
                }

            }

            Y = (u16Curr >> yShift) & 0xff;

            Texel = RGB_MAKE(
                CLAMP_BYTE(1.164*(Y-16) + 1.596*(V-128)),
                CLAMP_BYTE(1.164*(Y-16) - 0.813*(V-128) - 0.391*(U-128)),
                CLAMP_BYTE(1.164*(Y-16) + 2.018*(U-128))
                );
            Texel.A = 1.f;
        }
        break;

    // DXTn compressed formats:
    // We have the address to the block, now extract the actual color
    case RD_SF_DXT1:
    case RD_SF_DXT2:
    case RD_SF_DXT3:
    case RD_SF_DXT4:
    case RD_SF_DXT5:
        Texel = TexelFromBlock(m_SurfFormat, pSurfaceBits, iX, iY);
        break;
    }

    // colorkey
    if ( m_pRefDev->ColorKeyEnabled() )
    {
        DWORD dwBits;
        switch ( m_SurfFormat )
        {
        default:
        case RD_SF_NULL:
            return;     // don't colorkey unknown or null surfaces

        case RD_SF_PALETTE4:
            {
                UINT8 uIndex = *((INT8*)pSurfaceBits);
                if ((iX & 1) == 0) { uIndex &= 0xf; }
                else               { uIndex >>= 4;  }
                dwBits = (DWORD)uIndex;
                }
            break;

        case RD_SF_L8:
        case RD_SF_A8:
        case RD_SF_PALETTE8:
        case RD_SF_B2G3R3:
        case RD_SF_L4A4:
            {
                UINT8 uBits = *((UINT8*)pSurfaceBits);
                dwBits = (DWORD)uBits;
                }
            break;

        case RD_SF_B5G6R5:
        case RD_SF_B5G5R5X1:
        case RD_SF_B5G5R5A1:
        case RD_SF_B4G4R4A4:
        case RD_SF_B4G4R4X4:
        case RD_SF_L8A8:
        case RD_SF_P8A8:
        case RD_SF_B2G3R3A8:
            {
                UINT16 uBits = *((UINT16*)pSurfaceBits);
                dwBits = (DWORD)uBits;
            }
            break;

        case RD_SF_B8G8R8:
            {
                UINT32 uBits = 0;
                uBits |= ( *((UINT8*)pSurfaceBits+0) ) <<  0;
                uBits |= ( *((UINT8*)pSurfaceBits+1) ) <<  8;
                uBits |= ( *((UINT8*)pSurfaceBits+2) ) << 16;
                dwBits = (DWORD)uBits;
            }
            break;

        case RD_SF_B8G8R8A8:
        case RD_SF_B8G8R8X8:
            {
                UINT32 uBits = *((UINT32*)pSurfaceBits);
                dwBits = (DWORD)uBits;
            }
            break;
        }

        DWORD ColorKey = m_dwColorKey;
        if ( dwBits == ColorKey )
        {
            if (m_pRefDev->GetRS()[D3DRENDERSTATE_COLORKEYENABLE])
            {
                bColorKeyKill = TRUE;
            }
            if (m_pRefDev->GetRS()[D3DRENDERSTATE_COLORKEYBLENDENABLE])
            {
                Texel.R = 0.F;
                Texel.G = 0.F;
                Texel.B = 0.F;
                Texel.A = 0.F;
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\common\refdev.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// refdev.cpp
//
// Direct3D Reference Device - public interfaces
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// This is a global static array of the block sizes in bytes for the
// various DXTn compression formats
int g_DXTBlkSize[NUM_DXT_FORMATS] =
{
    sizeof(DXTBlockRGB),
    sizeof(DXTBlockAlpha4),
    sizeof(DXTBlockAlpha4),
    sizeof(DXTBlockAlpha3),
    sizeof(DXTBlockAlpha3),
};

//-----------------------------------------------------------------------------
//
// Memory management function installation
//
//-----------------------------------------------------------------------------

//  global pointers to memory allocation functions (used through MEM* macros)
LPVOID (__cdecl *g_pfnMemAlloc)( size_t size ) = NULL;
void   (__cdecl *g_pfnMemFree)( LPVOID lptr ) = NULL;
LPVOID (__cdecl *g_pfnMemReAlloc)( LPVOID ptr, size_t size ) = NULL;

// install memory management functions - must be called before instancing
// rasterizer object
void RefRastSetMemif(
    LPVOID(__cdecl *pfnMemAlloc)(size_t),
    void(__cdecl *pfnMemFree)(LPVOID),
    LPVOID(__cdecl *pfnMemReAlloc)(LPVOID,size_t))
{
    DPFRR(1, "RefRastSetMemif %08x %08x %08x\n",
        pfnMemAlloc,pfnMemFree,pfnMemReAlloc);
    g_pfnMemAlloc = pfnMemAlloc;
    g_pfnMemFree = pfnMemFree;
    g_pfnMemReAlloc = pfnMemReAlloc;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Interface Methods                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// SetRenderTarget -
//
//-----------------------------------------------------------------------------
void
RefDev::SetRenderTarget( RDRenderTarget* pRenderTarget )
{
    m_pRenderTarget = pRenderTarget;

    // update the W scaling values for mapping interpolated W's into buffer range
    m_fWBufferNorm[0] = pRenderTarget->m_fWRange[0];
    FLOAT fWRange = pRenderTarget->m_fWRange[1] - pRenderTarget->m_fWRange[0];
    m_fWBufferNorm[1] = ( 0. != fWRange ) ? ( 1./fWRange ) : ( 1. );

}

//-----------------------------------------------------------------------------
//
// SetTextureStageState -
//
//-----------------------------------------------------------------------------

// map DX6(&7) texture filtering enums to DX8 enums
static DWORD
MapDX6toDX8TexFilter( DWORD dwStageState, DWORD dwValue )
{
    switch (dwStageState)
    {
    case D3DTSS_MAGFILTER:
        switch (dwValue)
        {
        case D3DTFG_POINT           : return D3DTEXF_POINT;
        case D3DTFG_LINEAR          : return D3DTEXF_LINEAR;
        case D3DTFG_FLATCUBIC       : return D3DTEXF_FLATCUBIC;
        case D3DTFG_GAUSSIANCUBIC   : return D3DTEXF_GAUSSIANCUBIC;
        case D3DTFG_ANISOTROPIC     : return D3DTEXF_ANISOTROPIC;
        }
        break;
    case D3DTSS_MINFILTER:
        switch (dwValue)
        {
        case D3DTFN_POINT           : return D3DTEXF_POINT;
        case D3DTFN_LINEAR          : return D3DTEXF_LINEAR;
        case D3DTFN_ANISOTROPIC     : return D3DTEXF_ANISOTROPIC;
        }
        break;
    case D3DTSS_MIPFILTER:
        switch (dwValue)
        {
        case D3DTFP_NONE            : return D3DTEXF_NONE;
        case D3DTFP_POINT           : return D3DTEXF_POINT;
        case D3DTFP_LINEAR          : return D3DTEXF_LINEAR;
        }
        break;
    }
    return 0x0;
}

void
RefDev::SetTextureStageState(
    DWORD dwStage, DWORD dwStageState, DWORD dwValue )
{
    // check for range before continuing
    if ( dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        return;
    }
    if (dwStageState > D3DTSS_MAX)
    {
        return;
    }

    // set in internal per-stage state
    m_TextureStageState[dwStage].m_dwVal[dwStageState] = dwValue;
    if (m_pDbgMon) m_pDbgMon->StateChanged( D3DDM_SC_DEVICESTATE );


    m_dwRastFlags |= RDRF_TEXTURESTAGESTATE_CHANGED;

    switch ( dwStageState )
    {

    case D3DTSS_TEXTUREMAP:

        // bind texture indicated by handle to m_pTexture array
        if (IsDriverDX6AndBefore() || IsInterfaceDX6AndBefore())
        {
            // This is the legacy behavior (prev. to DX7)
            MapTextureHandleToDevice( dwStage );
        }
        else
        {
            // This is the new behavior (DX7 and beyond)
            SetTextureHandle( dwStage, dwValue );
        }
        m_dwRastFlags |= RDRF_LEGACYPIXELSHADER_CHANGED;
        if (m_pDbgMon) m_pDbgMon->StateChanged( D3DDM_SC_TEXTURE );
        break;

    case D3DTSS_COLOROP:
        m_dwRastFlags |= RDRF_LEGACYPIXELSHADER_CHANGED;
        break;

// not including legacy headers, so don't have D3DTSS_ADDRESS
//    case D3DTSS_ADDRESS:
//        // map single set ADDRESS to U, V controls (pre-DX8 interfaces only)
//        m_TextureStageState[dwStage].m_dwVal[D3DTSS_ADDRESSU] = dwValue;
//        m_TextureStageState[dwStage].m_dwVal[D3DTSS_ADDRESSV] = dwValue;
//        break;

    case D3DTSS_MAGFILTER:
    case D3DTSS_MINFILTER:
    case D3DTSS_MIPFILTER:
        if ( IsDriverDX7AndBefore() )
        {
            m_TextureStageState[dwStage].m_dwVal[dwStageState]
                = MapDX6toDX8TexFilter( dwStageState, dwValue );
        }
        break;
    }
}

//-----------------------------------------------------------------------------
//
// TextureCreate - Instantiates new RDSurface2D object, computes texture handle
// to associate with it, and returns both to caller.  Note that texture handle
// is a pointer and can be used to get at the corresponding texture object.
//
//-----------------------------------------------------------------------------
BOOL
RefDev::TextureCreate(
    LPD3DTEXTUREHANDLE phTex, RDSurface2D** ppTex )
{
    // allocate internal texture structure
    *ppTex = new RDSurface2D();
    _ASSERTa( NULL != *ppTex, "new failure on texture create", return FALSE; );

    // use separately allocated pointer for handle
    RDSurface2D** ppTexForHandle = (RDSurface2D**)MEMALLOC( sizeof(RDSurface2D*) );
    _ASSERTa( NULL != ppTexForHandle, "malloc failure on texture create", return FALSE; );
    *ppTexForHandle = *ppTex;

    // return texture handle
    (*ppTex)->m_hTex = (ULONG_PTR)ppTexForHandle;
    *phTex = (*ppTex)->m_hTex;

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// TextureDestroy -
//
//-----------------------------------------------------------------------------
BOOL
RefDev::TextureDestroy( D3DTEXTUREHANDLE hTex )
{
    // first check if texture about to be destroyed is mapped - if so then
    // unmap it
    for ( int iStage=0; iStage<D3DHAL_TSS_MAXSTAGES; iStage++ )
    {
        if ( hTex == m_TextureStageState[iStage].m_dwVal[D3DTSS_TEXTUREMAP] )
        {
            SetTextureStageState( iStage, D3DTSS_TEXTUREMAP, 0x0 );
        }
    }

    // resolve handle to RDSurface2D pointer
    RDSurface2D* pTex = MapHandleToTexture( hTex );
    if ( NULL == pTex ) { return FALSE; }

    // free the handle pointer
#ifdef _IA64_
    _ASSERTa(FALSE, "This will not work on IA64", return FALSE;);
#endif
    RDSurface2D** ppTex = (RDSurface2D**)ULongToPtr(hTex);
    if ( NULL != ppTex) { MEMFREE( ppTex ); }

    // free the RDSurface2D
    delete pTex;

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// TextureGetSurf -
//
//-----------------------------------------------------------------------------
DWORD
RefDev::TextureGetSurf( D3DTEXTUREHANDLE hTex )
{
    RDSurface2D* pTex = MapHandleToTexture(hTex);
    if ( NULL == pTex ) { return 0x0; }
    return PtrToUlong( pTex->m_pDDSLcl[0] );
}

//-----------------------------------------------------------------------------
//
// GetCurrentTextureMaps - This function fills in a passed array texture handles
// and pointers.  The array should be sized by D3DHAL_TSS_MAXSTAGES.
//
// This is used to facilitate external locking/unlocking of surfaces used for
// textures.
//
//-----------------------------------------------------------------------------
int
RefDev::GetCurrentTextureMaps(
    D3DTEXTUREHANDLE *phTex, RDSurface2D** pTex)
{
    UpdateActiveTexStageCount();

    for ( int i=0; i<m_cActiveTextureStages; i++ )
    {
        if ( NULL == m_pTexture[i] )
        {
            phTex[i] = 0x0;
            pTex[i] = NULL;
        }
        else
        {
            phTex[i] = m_pTexture[i]->m_hTex;
            pTex[i] = m_pTexture[i];
        }
    }
    return m_cActiveTextureStages;
}


//-----------------------------------------------------------------------------
//
// SceneCapture - Used to trigger fragment buffer resolve.
//
//-----------------------------------------------------------------------------
//#define DO_SCENE_RENDER_TIME

#ifdef DO_SCENE_RENDER_TIME
#include <mmsystem.h>
#endif
void
RefDev::SceneCapture( DWORD dwFlags )
{
static INT32 iScene = 0;
static INT32 iLastSceneEnd = 0;
#ifdef DO_SCENE_RENDER_TIME
static DWORD timeBS = 0;
#endif

    switch (dwFlags)
    {
    case D3DHAL_SCENE_CAPTURE_START:
        iScene++;
        if (m_pDbgMon) m_pDbgMon->NextEvent(D3DDM_EVENT_BEGINSCENE);
#ifdef DO_SCENE_RENDER_TIME
        timeBS = timeGetTime();
#endif
        break;
    case D3DHAL_SCENE_CAPTURE_END:
        if (iScene == iLastSceneEnd) break; // getting multiple END per BEGIN
        iLastSceneEnd = iScene;
#ifdef DO_SCENE_RENDER_TIME
        {

            DWORD timeES = timeGetTime();
            FLOAT dt = (FLOAT)(timeES - timeBS)/1000.f;
            timeBS = 0;
            RDDebugPrintf("SceneRenderTime: %f", dt );
        }
#endif
        {
            if (m_pDbgMon) m_pDbgMon->NextEvent(D3DDM_EVENT_ENDSCENE);
        }
        break;
    }
}

//-----------------------------------------------------------------------------
//
// Query functions to get pointer to current render target and render state.
//
//-----------------------------------------------------------------------------
RDRenderTarget*
RefDev::GetRenderTarget(void)
{
    return m_pRenderTarget;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
HRESULT
RefDev::UpdateRastState( void )
{
    // check 'dirty' flags
    if (m_dwRastFlags & RDRF_MULTISAMPLE_CHANGED)
    {
        // update multi-sample RS related state
        m_Rast.SetSampleMode(
            m_pRenderTarget->m_pColor->m_iSamples,
            m_dwRenderState[D3DRS_MULTISAMPLEANTIALIAS] );
        m_Rast.SetSampleMask(
            m_dwRenderState[D3DRS_MULTISAMPLEMASK] );
        m_dwRastFlags &= ~(RDRF_MULTISAMPLE_CHANGED);
    }
    if (m_dwRastFlags & RDRF_PIXELSHADER_CHANGED)
    {
        if (m_CurrentPShaderHandle)
        {
            m_Rast.m_pCurrentPixelShader =
                GetPShader(m_CurrentPShaderHandle);
            m_Rast.m_bLegacyPixelShade = FALSE;
        }
        else
        {
            // legacy pixel shader
            m_Rast.UpdateLegacyPixelShader();
            m_Rast.m_pCurrentPixelShader = m_Rast.m_pLegacyPixelShader;
            m_Rast.m_bLegacyPixelShade = TRUE;
        }
        UpdateActiveTexStageCount();

        m_dwRastFlags &= ~(RDRF_PIXELSHADER_CHANGED);
    }
    if (m_dwRastFlags & RDRF_LEGACYPIXELSHADER_CHANGED)
    {
        if (m_Rast.m_bLegacyPixelShade)
        {
            m_Rast.UpdateLegacyPixelShader();
            m_Rast.m_pCurrentPixelShader = m_Rast.m_pLegacyPixelShader;
            UpdateActiveTexStageCount();
        }
        m_dwRastFlags &= ~(RDRF_LEGACYPIXELSHADER_CHANGED);

    }
    if (m_dwRastFlags & RDRF_TEXTURESTAGESTATE_CHANGED)
    {
        m_Rast.UpdateTextureControls();
        m_dwRastFlags &= ~(RDRF_TEXTURESTAGESTATE_CHANGED);
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
//
// Begin/End bracket functions - Called before/after a list of primitives are
// rendered.
//
//-----------------------------------------------------------------------------
HRESULT
RefDev::BeginRendering( void )
{
    // If already in Begin, do nothing
    if( m_bInBegin ) return S_OK;
    
#ifdef _X86_
    // save floating point mode and set to extended precision mode
    {
        WORD wTemp, wSave;
        __asm
        {
            fstcw   wSave
            mov ax, wSave
            or ax, 300h    ;; extended precision mode
//            and ax, 00FFh    ;; single precision mode + round nearest or even
            mov wTemp, ax
            fldcw   wTemp
        }
        m_wSaveFP = wSave;
    }
#endif
    m_bInBegin = TRUE;
    return S_OK;
}
//-----------------------------------------------------------------------------
HRESULT
RefDev::EndRendering( void )
{
    if ( m_bInBegin )
    {
#ifdef _X86_
        // restore floating point mode
        {
            WORD wSave = m_wSaveFP;
            __asm {fldcw   wSave}
        }
#endif
        m_bInBegin = FALSE;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the render target
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
HRESULT RefDev::Clear(LPD3DHAL_DP2COMMAND pCmd)
{
    D3DHAL_DP2CLEAR *pData = (D3DHAL_DP2CLEAR*)(pCmd + 1);
    WORD i;
    INT32 x,y;
    RDColor fillColor(pData->dwFillColor);
    RDDepth fillDepth;
    if (m_pRenderTarget->m_pDepth)
    {
        fillDepth.SetSType(m_pRenderTarget->m_pDepth->GetSurfaceFormat());
    }

    fillDepth = pData->dvFillDepth;

    struct
    {
        D3DHAL_DP2COMMAND   cmd;
        D3DHAL_DP2CLEAR     data;
    } WholeViewport;

    if (!(pData->dwFlags & D3DCLEAR_COMPUTERECTS))
    {
        // Do nothing for non-pure device
    }
    else
    if (pCmd->wStateCount == 0)
    {
        // When wStateCount is zero we need to clear whole viewport
        WholeViewport.cmd = *pCmd;
        WholeViewport.cmd.wStateCount = 1;
        WholeViewport.data.dwFlags = pData->dwFlags;
        WholeViewport.data.dwFillColor = pData->dwFillColor;
        WholeViewport.data.dvFillDepth = pData->dvFillDepth;
        WholeViewport.data.dwFillStencil = pData->dwFillStencil;
        WholeViewport.data.Rects[0].left = m_Clipper.m_Viewport.dwX;
        WholeViewport.data.Rects[0].top = m_Clipper.m_Viewport.dwY;
        WholeViewport.data.Rects[0].right = m_Clipper.m_Viewport.dwX +
                                            m_Clipper.m_Viewport.dwWidth;
        WholeViewport.data.Rects[0].bottom = m_Clipper.m_Viewport.dwY +
                                             m_Clipper.m_Viewport.dwHeight;
        // Replace pointers and continue as usual
        pCmd = (LPD3DHAL_DP2COMMAND)&WholeViewport;
        pData = &WholeViewport.data;
    }
    else
    {
        // We need to cull all rects against the current viewport
        UINT nRects = pCmd->wStateCount;
        // Compute how much memory we need to process rects
        UINT NeededSize = sizeof(D3DHAL_DP2COMMAND) +
                          sizeof(D3DHAL_DP2CLEAR) +
                          (nRects-1) * sizeof(RECT); // One rect is in DP2CLEAR
        HRESULT hr = S_OK;
        HR_RET(m_ClearRectBuffer.Grow(NeededSize));

        RECT vwport;    // Viewport rectangle to cull against
        vwport.left   = m_Clipper.m_Viewport.dwX;
        vwport.top    = m_Clipper.m_Viewport.dwY;
        vwport.right  = m_Clipper.m_Viewport.dwX + m_Clipper.m_Viewport.dwWidth;
        vwport.bottom = m_Clipper.m_Viewport.dwY + m_Clipper.m_Viewport.dwHeight;

        // Go through input rects and build output rect array
        LPRECT pInputRects = pData->Rects;
        LPRECT pOutputRects = (LPRECT)(&m_ClearRectBuffer[0] +
                              sizeof(D3DHAL_DP2COMMAND) +
                              sizeof(D3DHAL_DP2CLEAR) -
                              sizeof(RECT));
        UINT nOutputRects = 0;
        for (UINT i = 0; i < nRects; i++)
        {
            if (IntersectRect(&pOutputRects[nOutputRects], &vwport,
                              &pInputRects[i]))
            {
                nOutputRects++;
            }
        }

        if (nOutputRects == 0)
            return S_OK;

        // Now replace pCmd and pData pointers and continue as usual
        LPD3DHAL_DP2CLEAR pOldData = pData;
        LPD3DHAL_DP2COMMAND pOldCmd = pCmd;

        pCmd = (LPD3DHAL_DP2COMMAND)&m_ClearRectBuffer[0];
        pData = (D3DHAL_DP2CLEAR*)(pCmd + 1);
        *pCmd = *pOldCmd;
        pCmd->wStateCount = (WORD)nOutputRects;
        pData->dwFlags       = pOldData->dwFlags;
        pData->dwFillColor   = pOldData->dwFillColor;
        pData->dvFillDepth   = pOldData->dvFillDepth;
        pData->dwFillStencil = pOldData->dwFillStencil;
    }

#ifdef _X86_
    // Float to integer conversion routines for 24+ bit buffers work
    // only with extended FPU mode.
    //
    WORD wSaveFP;
    // save floating point mode and set to extended precision mode
    {
        WORD wTemp, wSave;
        __asm
        {
            fstcw   wSaveFP
            mov ax, wSaveFP
            or ax, 300h    ;; extended precision mode
            mov wTemp, ax
            fldcw   wTemp
        }
    }
#endif

    if(pData->dwFlags & D3DCLEAR_TARGET)
    {
        if (m_dwRenderState[D3DRENDERSTATE_DITHERENABLE] == FALSE)
        {
            m_pRenderTarget->Clear(fillColor, pCmd);
        }
        else
        {
            for (i = 0; i < pCmd->wStateCount; i++)
            {
                for (y = pData->Rects[i].top; y < pData->Rects[i].bottom; ++y)
                {
                    for (x = pData->Rects[i].left; x < pData->Rects[i].right; ++x)
                    {
                        m_pRenderTarget->WritePixelColor(x, y, fillColor, TRUE);
                    }
                }
            }
        }
    }


    switch (pData->dwFlags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL))
    {
    case (D3DCLEAR_ZBUFFER):
        m_pRenderTarget->ClearDepth(fillDepth, pCmd);
        break;
    case (D3DCLEAR_STENCIL):
        m_pRenderTarget->ClearStencil(pData->dwFillStencil, pCmd);
        break;
    case (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL):
        m_pRenderTarget->ClearDepthStencil(fillDepth, pData->dwFillStencil, pCmd);
        break;
    }

#ifdef _X86_
    // restore floating point mode
    {
        __asm {fldcw   wSaveFP}
    }
#endif
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the render target
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RDRenderTarget::Clear(RDColor fillColor, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);
    UINT32 dwColor = 0;
    fillColor.ConvertTo( m_pColor->GetSurfaceFormat(), 0.5f, (char*)&dwColor);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = ( pData->Rects[i].right - x0 ) * m_pColor->GetSamples();
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, 0, 0, m_pColor );
        switch ( m_pColor->GetSurfaceFormat() )
        {
        case RD_SF_B8G8R8A8:
        case RD_SF_B8G8R8X8:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = dwColor;
                    }
                    pSurface += m_pColor->GetPitch();
                }
            }
            break;

        case RD_SF_B8G8R8:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = ((UINT8*)&dwColor)[0];
                        *p++ = ((UINT8*)&dwColor)[1];
                        *p++ = ((UINT8*)&dwColor)[2];
                    }
                    pSurface += m_pColor->GetPitch();
                }
            }
            break;

        case RD_SF_B4G4R4A4:
        case RD_SF_B5G6R5:
        case RD_SF_B5G5R5A1:
        case RD_SF_B5G5R5X1:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = (UINT16)dwColor;
                    }
                    pSurface += m_pColor->GetPitch();
                }
            }
            break;

        case RD_SF_B2G3R3:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = (UINT8)dwColor;
                    }
                    pSurface += m_pColor->GetPitch();
                }
            }
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelColor(x, y, fillColor, TRUE);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the depth buffer
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RDRenderTarget::ClearDepth(RDDepth fillDepth, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);

    if (!m_pDepth) return;
    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = ( pData->Rects[i].right - x0 ) * m_pDepth->GetSamples();
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, 0, 0, m_pDepth );
        switch ( m_pDepth->GetSurfaceFormat() )
        {
        case RD_SF_Z16S0:
            {
                UINT16 Depth = UINT16(fillDepth);
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = Depth;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z24S8:
        case RD_SF_Z24X8:
        case RD_SF_Z24X4S4:
            {
                UINT32 Depth = UINT32(fillDepth) << 8;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0xffffff00)) | Depth;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_S8Z24:
        case RD_SF_X8Z24:
        case RD_SF_X4S4Z24:
            {
                UINT32 Depth = UINT32(fillDepth) & 0x00ffffff;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0x00ffffff)) | Depth;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z15S1:
            {
                UINT16 Depth = UINT16(fillDepth) << 1;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0xfffe)) | Depth;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_S1Z15:
            {
                UINT16 Depth = UINT16(fillDepth) & 0x7fff;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0x7fff)) | Depth;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z32S0:
            {
                UINT32 Depth = UINT32(fillDepth);
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = Depth;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelDepth(x, y, fillDepth);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the stencil buffer
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RDRenderTarget::ClearStencil(UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = (pData->Rects[i].right - x0 ) * m_pDepth->GetSamples();
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, 0, 0, m_pDepth );
        switch ( m_pDepth->GetSurfaceFormat() )
        {
        case RD_SF_Z24S8:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p = uStencil;
                        p += 4;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_S8Z24:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)&pSurface[3];
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p = uStencil;
                        p += 4;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z24X4S4:
            {
                UINT32 stencil = uStencil & 0xf;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0x000000ff)) | stencil;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_X4S4Z24:
            {
                UINT32 stencil = (uStencil & 0xf) << 24;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0xff000000)) | stencil;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z15S1:
            {
                UINT16 stencil = uStencil & 0x1;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0x0001)) | stencil;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_S1Z15:
            {
                UINT16 stencil = uStencil << 15;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0x8000)) | stencil;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z16S0:
        case RD_SF_Z32S0:
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelStencil(x, y, uStencil);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the depth and stencil buffers
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RDRenderTarget::ClearDepthStencil(RDDepth fillDepth, UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = ( pData->Rects[i].right - x0 ) * m_pDepth->GetSamples();
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, 0, 0, m_pDepth );
        switch (m_pDepth->GetSurfaceFormat())
        {
        case RD_SF_Z16S0:
        case RD_SF_Z32S0:
            break;
        case RD_SF_Z24S8:
        case RD_SF_Z24X8:
        case RD_SF_S8Z24:
        case RD_SF_X8Z24:
        case RD_SF_Z24X4S4:
        case RD_SF_X4S4Z24:
            {
                UINT32 v;
                switch (m_pDepth->GetSurfaceFormat())
                {
                case RD_SF_Z24S8: v = (UINT32(fillDepth) << 8) + uStencil;    break;
                case RD_SF_Z24X8: v = (UINT32(fillDepth) << 8);    break;
                case RD_SF_S8Z24: v = (UINT32(fillDepth)  & 0x00ffffff) + (uStencil << 24); break;
                case RD_SF_X8Z24: v = (UINT32(fillDepth)  & 0x00ffffff); break;
                case RD_SF_Z24X4S4: v = (UINT32(fillDepth) << 8) + (uStencil & 0xf);  break;
                case RD_SF_X4S4Z24: v = (UINT32(fillDepth) & 0x00ffffff) + ((uStencil & 0xf) << 24); break;
                }
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = v;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z15S1:
        case RD_SF_S1Z15:
            {
                UINT16 v;
                switch (m_pDepth->GetSurfaceFormat())
                {
                case RD_SF_Z15S1:    v = (UINT16(fillDepth) << 1) + (uStencil & 0x1); break;
                case RD_SF_S1Z15:    v = (UINT16(fillDepth) & 0x7fff) + (uStencil << 15); break;
                }
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = v;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelDepth(x, y, fillDepth);
                        this->WritePixelStencil(x, y, uStencil);
                    }
                }
            }
        }
    }
}

#ifndef __D3D_NULL_REF
//-----------------------------------------------------------------------------
//
HRESULT WINAPI
D3D8CreateDebugMonitor( ULONG_PTR dwContext, BOOL bDbgMonConnectionEnabled, D3DDebugMonitor** ppDbgMon )
{
    RefDev* pRefDev = (RefDev*)dwContext;

    pRefDev->m_pDbgMon = new RDDebugMonitor(pRefDev, bDbgMonConnectionEnabled);
    if( pRefDev->m_pDbgMon == NULL )
    {
        return E_OUTOFMEMORY;
    }

    *ppDbgMon = (D3DDebugMonitor*)pRefDev->m_pDbgMon;
    pRefDev->m_pDbgMon->AttachToMonitor(1);
    return S_OK;
}
#endif //__D3D_NULL_REF
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\common\rddmon.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// rddmon.cpp
//
// Reference Device Debug Monitor
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// converts correctly for pre-snapped floats only
#define FLOATtoNDOT4( _fVal )  ((INT32)((_fVal)*16.))

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
RDDebugMonitor::RDDebugMonitor( RefDev* pRD, BOOL bDbgMonConnectionEnabled )
{
    m_pRD = pRD;
    UINT i;
    m_bDbgMonConnectionEnabled = bDbgMonConnectionEnabled;

    m_ScreenMask[0] = 0xFFFFFFFF; //0xcccccccc;
    m_ScreenMask[1] = 0xFFFFFFFF; //0xcccccccc;

    memset( (void*)&m_ShMemI, 0, sizeof(m_ShMemI) );
    m_NumShMemI = 0;
}
//-----------------------------------------------------------------------------
RDDebugMonitor::~RDDebugMonitor( void )
{
    for (UINT i=0; i<m_NumShMemI; i++)
    {
        if (m_ShMemI[i].pSM) delete m_ShMemI[i].pSM;
    }
}

//-----------------------------------------------------------------------------
void
RDDebugMonitor::NextEvent( UINT32 EventType )
{
    CheckLostMonitorConnection();

    BOOL bBreakpoint = D3DDebugMonitor::IsEventBreak( EventType );

    // do event-specific stuff (state update; actions; check for breakpoints)
    UINT i;
    switch ( EventType )
    {
    case D3DDM_EVENT_RSTOKEN:
        switch( m_pRD->m_dwRenderState[D3DRS_DEBUGMONITORTOKEN] )
        {
        case D3DDMT_ENABLE:
            m_bDbgMonConnectionEnabled = TRUE;
            break;
        case D3DDMT_DISABLE:
            if( m_pTgtCtx )
            {
                DetachMonitorConnection();
            }
            DPFINFO("D3DDebugTarget - debug monitor connection disabled by target");
            m_bDbgMonConnectionEnabled = FALSE;
            break;
        }
        break;

    case D3DDM_EVENT_BEGINSCENE:
        // try to attach if not attached
        if (!MonitorConnected())  AttachToMonitor(1);
        break;

    case D3DDM_EVENT_ENDSCENE:
        m_pTgtCtx->SceneCount++;
        {
            static DWORD bDoSM = 0;
            if (bDoSM)
                ShMemIRenderTarget( 0x0, 0 );
        }
        break;

    case D3DDM_EVENT_PRIMITIVE:
        m_pTgtCtx->PrimitiveCount++;
        if (m_pMonCtx && m_pMonCtx->PrimitiveCountBP)
        {
            if ( m_pTgtCtx->PrimitiveCount == m_pMonCtx->PrimitiveCountBP )
                bBreakpoint = TRUE;
        }
        break;

    case D3DDM_EVENT_PIXEL:
        m_pTgtCtx->PixelCount++;
        if (m_pMonCtx)
        {
            if (m_pMonCtx->PixelCountBP)
            {
                if ( m_pTgtCtx->PixelCount == m_pMonCtx->PixelCountBP )
                    bBreakpoint = TRUE;
            }
            if (m_pMonCtx->PixelBPEnable)
            {
                for (i=0; i<32; i++)
                {
                    if ( (1<<i) & m_pMonCtx->PixelBPEnable )
                    {
                        if ( ((UINT)m_pMonCtx->PixelBP[i][0] ==
                              (UINT)m_pRD->m_Rast.m_iX[m_pRD->m_Rast.m_iPix] ) &&
                             ((UINT)m_pMonCtx->PixelBP[i][1] ==
                              (UINT)m_pRD->m_Rast.m_iY[m_pRD->m_Rast.m_iPix] ) )
                        {
                            bBreakpoint = TRUE;
                        }
                    }
                }
            }
        }
        break;

    case D3DDM_EVENT_PIXELSHADERINST:
        break;
    }

    // invoke base class to talk to monitor and issue commands
    if (bBreakpoint)
    {
        m_pTgtCtx->EventStatus = EventType;
        D3DDebugMonitor::MonitorBreakpoint();
        m_pTgtCtx->EventStatus = 0x0;
    }
    return;
}

HRESULT
RDDebugMonitor::ProcessMonitorCommand( void )
{
    UINT32 Command = m_pMonCtx->Command;
    UINT i;
    RefRast* pRast = &m_pRD->m_Rast;

    // default case - no data
    UINT32 IncomingCommandBufferSize = m_pTgtCtx->CommandBufferSize;
    m_pTgtCtx->CommandBufferSize = 0;

    switch ( Command & D3DDM_CMD_MASK )
    {

    case D3DDM_CMD_GETDEVICESTATE:
        {
            D3DDMDeviceState* pDS = (D3DDMDeviceState*)m_pCmdData;
            memcpy( pDS->RenderState, m_pRD->m_dwRenderState, 4*D3DHAL_MAX_RSTATES );
            for (i=0; i<D3DHAL_TSS_MAXSTAGES; i++)
            {
                memcpy( pDS->TextureStageState[i],
                    m_pRD->m_TextureStageState[i].m_dwVal, 4*D3DTSS_MAX );
            }
            pDS->VertexShaderHandle = m_pRD->m_CurrentVShaderHandle;
            pDS->PixelShaderHandle = m_pRD->m_CurrentPShaderHandle;
            pDS->MaxVShaderHandle = (UINT)m_pRD->m_VShaderHandleArray.GetSize();
            if (pDS->MaxVShaderHandle) pDS->MaxVShaderHandle -= 1;
            while ( ( pDS->MaxVShaderHandle > 0 ) &&
                    ( NULL == m_pRD->m_VShaderHandleArray[pDS->MaxVShaderHandle].m_pShader ) )
            {
                pDS->MaxVShaderHandle--;
            }
            pDS->MaxPShaderHandle = (UINT)m_pRD->m_PShaderHandleArray.GetSize();
            if (pDS->MaxPShaderHandle) pDS->MaxPShaderHandle -= 1;
            while ( ( pDS->MaxPShaderHandle > 0 ) &&
                    ( NULL == m_pRD->m_PShaderHandleArray[pDS->MaxPShaderHandle].m_pShader ) )
            {
                pDS->MaxPShaderHandle--;
            }
            m_pTgtCtx->CommandBufferSize = sizeof(D3DDMDeviceState);
        }
        break;

    case D3DDM_CMD_GETVERTEXSHADER:
        {
            DWORD Handle = *(DWORD*)m_pCmdData;
            if ( !(Handle & D3DFVF_RESERVED0) ) break;
            if ( !m_pRD->m_VShaderHandleArray.IsValidIndex(Handle) ) break;
            RDVShader* pRDVS = m_pRD->m_VShaderHandleArray[Handle].m_pShader;
            if ( !pRDVS) break;
            D3DDMVertexShader* pVS = (D3DDMVertexShader*)m_pCmdData;
            m_pTgtCtx->CommandBufferSize = sizeof(D3DDMVertexShader);
        }
        break;

    case D3DDM_CMD_GETVERTEXSTATE:
        {
            D3DDMVertexState* pVSS = (D3DDMVertexState*)m_pCmdData;
            m_pRD->GetVM().GetData( D3DSPR_INPUT, 0, D3DDM_MAX_VSINPUTREG, (void*)(pVSS->InputRegs) );
            m_pTgtCtx->CommandBufferSize = sizeof(D3DDMVertexState);
        }
        break;
    case D3DDM_CMD_GETVERTEXSHADERCONST:
        {
            D3DDMVertexShaderConst* pVSC = (D3DDMVertexShaderConst*)m_pCmdData;
            m_pRD->GetVM().GetData( D3DSPR_CONST, 0, 96, (void*)(pVSC->ConstRegs) );
            m_pTgtCtx->CommandBufferSize = 96*4*sizeof(FLOAT);
        }
        break;
    case D3DDM_CMD_GETVERTEXSHADERINST:
        {
            DWORD Handle = *(DWORD*)m_pCmdData;
            if ( !(Handle & D3DFVF_RESERVED0) ) break;
            if ( !m_pRD->m_VShaderHandleArray.IsValidIndex(Handle) ) break;
            RDVShader* pRDVS = m_pRD->m_VShaderHandleArray[Handle].m_pShader;
            if ( !pRDVS ) break;
            RDVShaderCode* pShC = pRDVS->m_pCode;
            UINT Inst = (Command & 0xffff);
            if (pShC && (Inst < pShC->GetInstructionCount()))
            {
                D3DDMVertexShaderInst* pVSI = (D3DDMVertexShaderInst*)m_pCmdData;
                memcpy( pVSI->Inst, pShC->m_pInst[Inst].m_Tokens, RD_MAX_SHADERTOKENSPERINST );
                memcpy( pVSI->InstString, pShC->m_pInst[Inst].m_String, RD_MAX_SHADERINSTSTRING );
                m_pTgtCtx->CommandBufferSize = sizeof(D3DDMVertexShaderInst);
                if (pShC->m_pInst[Inst].m_CommentSize)
                {
                    memcpy( (void*)(pVSI+1), pShC->m_pInst[Inst].m_pComment, 4*pShC->m_pInst[Inst].m_CommentSize );
                    m_pTgtCtx->CommandBufferSize += 4*pShC->m_pInst[Inst].m_CommentSize;
                }
            }
        }
        break;
    case D3DDM_CMD_GETVERTEXSHADERSTATE:
        {
            D3DDMVertexShaderState* pVSS = (D3DDMVertexShaderState*)m_pCmdData;
            pVSS->CurrentInst = m_pRD->GetVM().GetCurrentInstIndex();
            m_pRD->GetVM().GetData( D3DSPR_TEMP, 0, D3DDM_MAX_VSTEMPREG, (void*)(pVSS->TempRegs) );
            m_pRD->GetVM().GetData( D3DSPR_RASTOUT, 0, D3DDM_MAX_VSRASTOUTREG, (void*)(pVSS->RastOutRegs) );
            m_pRD->GetVM().GetData( D3DSPR_ATTROUT, 0, D3DDM_MAX_VSATTROUTREG, (void*)(pVSS->AttrOutRegs) );
            m_pRD->GetVM().GetData( D3DSPR_TEXCRDOUT, 0, D3DDM_MAX_VSTEXCRDOUTREG, (void*)(pVSS->TexCrdOutRegs) );
            m_pRD->GetVM().GetData( D3DSPR_ADDR, 0, 1, (void*)(pVSS->AddressReg) );
            m_pTgtCtx->CommandBufferSize = sizeof(D3DDMVertexShaderState);
        }
        break;

    case D3DDM_CMD_GETPIXELSTATE:
        {
            D3DDMPixelState* pPS = (D3DDMPixelState*)m_pCmdData;
            UINT iPix = (Command & 0xffff);
            if (pRast->m_bPixelIn[iPix])
            {
                pPS->Location[0] = pRast->m_iX[iPix];
                pPS->Location[1] = pRast->m_iY[iPix];
                pPS->Depth = pRast->m_Depth[iPix];
                pPS->FogIntensity = pRast->m_FogIntensity[iPix];
                memcpy( pPS->InputRegs[0], pRast->m_InputReg[0][iPix], 16 );
                memcpy( pPS->InputRegs[1], pRast->m_InputReg[1][iPix], 16 );
                m_pTgtCtx->CommandBufferSize = sizeof(D3DDMPixelState);
            }
        }
        break;

    case D3DDM_CMD_GETPIXELSHADERCONST:
        {
            D3DDMPixelShaderConst* pPSC = (D3DDMPixelShaderConst*)m_pCmdData;
            memcpy( pPSC->ConstRegs[0], pRast->m_ConstReg[0][0], 16 );
            memcpy( pPSC->ConstRegs[1], pRast->m_ConstReg[1][0], 16 );
            memcpy( pPSC->ConstRegs[2], pRast->m_ConstReg[2][0], 16 );
            memcpy( pPSC->ConstRegs[3], pRast->m_ConstReg[3][0], 16 );
            memcpy( pPSC->ConstRegs[4], pRast->m_ConstReg[4][0], 16 );
            memcpy( pPSC->ConstRegs[5], pRast->m_ConstReg[5][0], 16 );
            memcpy( pPSC->ConstRegs[6], pRast->m_ConstReg[6][0], 16 );
            memcpy( pPSC->ConstRegs[7], pRast->m_ConstReg[7][0], 16 );
            m_pTgtCtx->CommandBufferSize = sizeof(D3DDMPixelShaderConst);
        }
        break;

    case D3DDM_CMD_GETPIXELSHADERINST:
        {
            DWORD Handle = *(DWORD*)m_pCmdData;
            if ( !m_pRD->m_PShaderHandleArray.IsValidIndex(Handle) ) break;
            RDPShader* pRDPS = m_pRD->m_PShaderHandleArray[Handle].m_pShader;
            if ( !pRDPS ) break;
            D3DDMPixelShaderInst* pPSI = (D3DDMPixelShaderInst*)m_pCmdData;
            UINT Inst = (Command & 0xffff);
            if ( Inst < pRDPS->m_cInst )
            {
                PixelShaderInstruction* pInst = pRDPS->m_pInst+Inst;
                pPSI->Inst[0] = pInst->Opcode;
                pPSI->Inst[1] = pInst->DstParam;
                pPSI->Inst[2] = pInst->SrcParam[0];
                pPSI->Inst[3] = pInst->SrcParam[1];
                pPSI->Inst[4] = pInst->SrcParam[2];
                memcpy( pPSI->InstString, pInst->Text, RD_MAX_SHADERINSTSTRING );
                m_pTgtCtx->CommandBufferSize = sizeof(D3DDMPixelShaderInst);
                if (pInst->CommentSize)
                {
                    memcpy( (void*)(pPSI+1), pInst->pComment, 4*pInst->CommentSize );
                    m_pTgtCtx->CommandBufferSize += 4*pInst->CommentSize;
                }
            }
            else
            {
                m_pTgtCtx->CommandBufferSize = 0;
            }
        }
        break;

    case D3DDM_CMD_GETPIXELSHADERSTATE:
        {
            D3DDMPixelShaderState* pPSS = (D3DDMPixelShaderState*)m_pCmdData;
            UINT iPix = (Command & 0xffff);
            pPSS->CurrentInst = pRast->m_CurrentPSInst;
            pPSS->Discard = pRast->m_bPixelDiscard[iPix];
            memcpy( pPSS->TempRegs[0], pRast->m_TempReg[0][iPix], 16 );
            memcpy( pPSS->TempRegs[1], pRast->m_TempReg[1][iPix], 16 );
            memcpy( pPSS->TextRegs[0], pRast->m_TextReg[0][iPix], 16 );
            memcpy( pPSS->TextRegs[1], pRast->m_TextReg[1][iPix], 16 );
            memcpy( pPSS->TextRegs[2], pRast->m_TextReg[2][iPix], 16 );
            memcpy( pPSS->TextRegs[3], pRast->m_TextReg[3][iPix], 16 );
            memcpy( pPSS->TextRegs[4], pRast->m_TextReg[4][iPix], 16 );
            memcpy( pPSS->TextRegs[5], pRast->m_TextReg[5][iPix], 16 );
            memcpy( pPSS->TextRegs[6], pRast->m_TextReg[6][iPix], 16 );
            memcpy( pPSS->TextRegs[7], pRast->m_TextReg[7][iPix], 16 );
            m_pTgtCtx->CommandBufferSize = sizeof(D3DDMPixelShaderState);
        }
        break;

    case D3DDM_CMD_DUMPTEXTURE:
        {
            int iSMI = (Command>>0)&0xf;
            int iSTG = (Command>>4)&0x7;
            int iLOD = (Command>>7)&0xf;
            int iIDX = (Command>>11)&0x1f;
            ShMemISurface2D( m_pRD->m_pTexture[iSTG], iLOD, 0x0, iSMI );
        }
        break;

    case D3DDM_CMD_DUMPRENDERTARGET:
        {
            int iSMI = (Command>>0)&0xf;
            ShMemIRenderTarget( 0x0, iSMI );
            break;
        }
        break;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void
RDDebugMonitor::GrowShMemArray( UINT ShMemI )
{
    if (ShMemI >= D3DDM_IMAGE_MAX) return;  // too many
    if (ShMemI < m_NumShMemI) return;       // already there
    UINT OldSmMemI = m_NumShMemI ? m_NumShMemI-1 : 0;
    m_NumShMemI = ShMemI+1;
    memset( (void*)&m_ShMemI, 0, sizeof(m_ShMemI) );
    for ( UINT i=OldSmMemI; i<m_NumShMemI; i++)
    {
        m_ShMemI[i].W = 400;
        m_ShMemI[i].H = 400;
        m_ShMemI[i].BPP = 4;
        m_ShMemI[i].SF = RD_SF_B8G8R8A8;
        m_ShMemI[i].pSM = new D3DSharedMem(
            16 + m_ShMemI[i].W*m_ShMemI[i].H*m_ShMemI[i].BPP,
            D3DDM_IMAGE_SM "%d", i );
        m_ShMemI[i].pBits = (void*)((char*)m_ShMemI[i].pSM->GetPtr()+16);
        *((DWORD*)m_ShMemI[i].pSM->GetPtr()+0) = m_ShMemI[i].W;
        *((DWORD*)m_ShMemI[i].pSM->GetPtr()+1) = m_ShMemI[i].H;
        *((DWORD*)m_ShMemI[i].pSM->GetPtr()+2) = m_ShMemI[i].BPP;
        *((DWORD*)m_ShMemI[i].pSM->GetPtr()+3) = m_ShMemI[i].SF;
    }
}

//-----------------------------------------------------------------------------
//
// Dumps render target image to specified shared memory segment.  Viewable by
// rddm_iview image viewer tool.
//
//-----------------------------------------------------------------------------
void
RDDebugMonitor::ShMemIRenderTarget( DWORD Flags, UINT iSM )
{
    GrowShMemArray( iSM );

    // copy to debug monitor shared memory
    int height = (int)min(
        (int)m_pRD->m_pRenderTarget->m_pColor->GetHeight(),
        (int)m_ShMemI[iSM].H);
    int width =  (int)min(
        (int)m_pRD->m_pRenderTarget->m_pColor->GetWidth(),
        (int)m_ShMemI[iSM].W);
    for (int iY = 0; iY < height; iY++)
    {
        for (int iX = 0; iX < width; iX++)
        {
            RDColor Color((UINT32)0);
            if( m_pRD->m_pRenderTarget->m_pColor->m_iSamples == 0 )
            {
                m_pRD->m_pRenderTarget->ReadPixelColor( iX, iY, 0, Color );
            }
            else
            {
                FLOAT fSampleScale = 1.F/((FLOAT)m_pRD->m_pRenderTarget->m_pColor->m_iSamples);
                for (UINT iS=0; iS<m_pRD->m_pRenderTarget->m_pColor->m_iSamples; iS++)
                {
                    RDColor SampleColor;
                    m_pRD->m_pRenderTarget->ReadPixelColor( iX, iY, iS, SampleColor );
                    Color.R += (SampleColor.R * fSampleScale);
                    Color.G += (SampleColor.G * fSampleScale);
                    Color.B += (SampleColor.B * fSampleScale);
                    Color.A += (SampleColor.A * fSampleScale);
                }
            }
            Color.ConvertTo( m_ShMemI[iSM].SF, 0.,
                (char*)m_ShMemI[iSM].pBits +
                 (m_ShMemI[iSM].W*m_ShMemI[iSM].BPP*iY) + (m_ShMemI[iSM].BPP*iX) );
        }
    }
    {
        char winstr[128]; _snprintf( winstr, 128, "D3DDM_I_%d", iSM );
        HWND hWnd = FindWindow( winstr, winstr );
        if (NULL != hWnd) SendMessage(hWnd, WM_USER, 0, 0);
    }
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void
RDDebugMonitor::ShMemISurface2D( RDSurface2D* pRS, INT32 iLOD, DWORD Flags, UINT iSM )
{
    GrowShMemArray( iSM );
    if (!pRS) return;

    // copy to debug monitor shared memory
    int height = (int)min(pRS->m_iHeight,(int)m_ShMemI[iSM].H);
    int width =  (int)min(pRS->m_iWidth,(int)m_ShMemI[iSM].W);
    for (int iY = 0; iY < height; iY++)
    {
        for (int iX = 0; iX < width; iX++)
        {
            RDColor Color; BOOL bDummy; pRS->ReadColor( iX, iY, 0, iLOD, Color, bDummy );
            Color.ConvertTo( m_ShMemI[iSM].SF, 0.,
                (char*)m_ShMemI[iSM].pBits +
                 (m_ShMemI[iSM].W*m_ShMemI[iSM].BPP*iY) + (m_ShMemI[iSM].BPP*iX) );
        }
    }
    {
        char winstr[128]; _snprintf( winstr, 128, "D3DDM_I_%d", iSM );
        HWND hWnd = FindWindow( winstr, winstr );
        if (NULL != hWnd) SendMessage(hWnd, WM_USER, 0, 0);
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\drv\init.c ===
#define INITGUID

#include <objbase.h>
#ifdef BUILD_MSREF
#include <d3dp.h>
#else   
#include <d3d.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\common\sources.inc ===
TARGETNAME = refcomm
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);..\..\drv

SOURCES = \
    ..\refdev.cpp    \
    ..\refdevi.cpp   \
    ..\debugmon.cpp  \
    ..\rddmon.cpp    \
    ..\dxtn.cpp      \
    ..\maplegcy.cpp  \
    ..\pixref.cpp    \
    ..\rdutil.cpp    \
    ..\rtarget.cpp   \
    ..\rdsurf.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\drv\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "refdev.hpp"

#include "refif.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\common\rdutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rdutil.cpp
//
// Direct3D Reference Device - Utilities
//
//
//
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// DPF support                                                                  //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

// control globals
int g_iDPFLevel = 0;
unsigned long g_uDPFMask = 0x0;

//-----------------------------------------------------------------------------
//
// RDDebugPrintf(L) - Utilities to print varargs-formatted strings of debugging
// info.  The 'L' version takes a level into account in deciding to print or
// not.
//
//-----------------------------------------------------------------------------
void
RDErrorPrintf( const char* pszFormat, ... )
{
    char tmp[1024];
    _snprintf( (LPSTR) tmp, 1024, "D3DRefDev:ERROR: ");
    va_list marker;
    va_start(marker, pszFormat);
    _vsnprintf(tmp+lstrlen(tmp), 1024-lstrlen(tmp), pszFormat, marker);
    _snprintf( (LPSTR) tmp, 1024, "%s\n", tmp );
    OutputDebugString(tmp);
    printf(tmp);
}

void
RDDebugPrintf( const char* pszFormat, ... )
{
    char tmp[1024];
    _snprintf( (LPSTR) tmp, 1024, "D3DRefDev: ");
    va_list marker;
    va_start(marker, pszFormat);
    _vsnprintf(tmp+lstrlen(tmp), 1024-lstrlen(tmp), pszFormat, marker);
    _snprintf( (LPSTR) tmp, 1024, "%s\n", tmp );
    OutputDebugString(tmp);
    printf(tmp);
}

void
RDDebugPrintfL( int iLevel, const char* pszFormat, ... )
{
    if ( (iLevel <= g_iDPFLevel) )
    {
        char tmp[1024];
        _snprintf( (LPSTR) tmp, 1024, "D3DRefDev: ");
        va_list marker;
        va_start(marker, pszFormat);
        _vsnprintf(tmp+lstrlen(tmp), 1024-lstrlen(tmp), pszFormat, marker);
        _snprintf( (LPSTR) tmp, 1024, "%s\n", tmp );
        OutputDebugString(tmp);
        printf(tmp);
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Assert Reporting
//
///////////////////////////////////////////////////////////////////////////////

// little-bit-o-state to track file and line number reporting - this is makes
// this code non-reentrant and non-threadsafe...  oh well...
static const char* _pszLastReportFile = NULL;
static int _iLastReportLine = -1;

//-----------------------------------------------------------------------------
void
RDAssertReport( const char* pszString, const char* pszFile, int iLine )
{
    char szTmp[1024];
    _snprintf( szTmp, 1024, "D3DRR ASSERT: <%d,%s> %s\n",
               iLine, pszFile, pszString );
    OutputDebugString( szTmp );
#if DBG
    DebugBreak();
#endif
}
//-----------------------------------------------------------------------------
void
RDAssertReportPrefix( const char* pszFile, int iLine )
{
    _pszLastReportFile = pszFile;
    _iLastReportLine = iLine;
}
//-----------------------------------------------------------------------------
void
RDAssertReportMessage( const char* pszFormat, ... )
{
    char szTmp[1024];
    va_list marker;
    va_start( marker, pszFormat );
    _vsnprintf( szTmp, 1024, pszFormat, marker );
    RDAssertReport( szTmp, _pszLastReportFile, _iLastReportLine );
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Generic bit twiddling utilities                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// CountSetBits - Returns number of set bits in a multibit value (up to
// 32 bits).
//
//-----------------------------------------------------------------------------
INT32
CountSetBits( UINT32 uVal, INT32 nBits )
{
    INT32 iRet = 0;
    for (INT32 i=0; i<nBits; i++) {
        if (uVal & (0x1<<i)) { iRet++; }
    }
    return iRet;
}

//-----------------------------------------------------------------------------
//
// FindFirstSetBit - Returns index of first set bit in a multibit value
// (up to 32 bits) or -1 if no bits are set.
//
//-----------------------------------------------------------------------------
INT32
FindFirstSetBit( UINT32 uVal, INT32 nBits )
{
    for (INT32 i=0; i<nBits; i++) {
        if (uVal & (0x1<<i)) { return i; }
    }
    return -1;
}

//-----------------------------------------------------------------------------
//
// FindMostSignificantSetBit - Returns index of first set bit in a
// multibit value (up to 32 bits) or 0 if no bits are set.
//
//-----------------------------------------------------------------------------
INT32
FindMostSignificantSetBit( UINT32 uVal, INT32 nBits )
{
    for (INT32 i=nBits; i>=0; i--) {
        if (uVal & (0x1<<i)) { return i+1; }
    }
    return 0;
}

//-----------------------------------------------------------------------------
//
// FindLastSetBit - Returns index of last set bit in a multibit value
// (up to 32 bits) or -1 if no bits are set.
//
//-----------------------------------------------------------------------------
INT32
FindLastSetBit( UINT32 uVal, INT32 nBits )
{
    for (INT32 i=0; i<nBits; i++) {
        if (uVal & (0x1<<(nBits-i-1))) { return (nBits-i-1); }
    }
    return -1;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Arithmetic utilities                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// LerpColor - Performs a linear interpolation between two RDColors
//
// uT is in 1.5 format (1<<5 represents a unit value)
//
//-----------------------------------------------------------------------------
void
LerpColor(
    RDColor& Color,
    const RDColor& Color0, const RDColor& Color1, UINT8 uT )
{
    FLOAT fT = (1./(FLOAT)(1<<5))*(FLOAT)uT;
    Color.A = Color0.A + (Color1.A - Color0.A)*fT;
    Color.R = Color0.R + (Color1.R - Color0.R)*fT;
    Color.G = Color0.G + (Color1.G - Color0.G)*fT;
    Color.B = Color0.B + (Color1.B - Color0.B)*fT;
}

//-----------------------------------------------------------------------------
//
// Bilerp - Performs bilinear interpolation of 4 RDColors returning one RDColor.
//
//-----------------------------------------------------------------------------
void
BiLerpColor(
    RDColor& OutColor,
    const RDColor& Color00, const RDColor& Color01,
    const RDColor& Color10, const RDColor& Color11,
    UINT8 uA, UINT8 uB )
{
    RDColor Color0, Color1;
    LerpColor( Color0, Color00, Color01, uA);
    LerpColor( Color1, Color10, Color11, uA);
    LerpColor( OutColor, Color0, Color1, uB);
}

void
BiLerpColor3D(
    RDColor& OutColor,
    const RDColor& Color000, const RDColor& Color010,
    const RDColor& Color100, const RDColor& Color110,
    const RDColor& Color001, const RDColor& Color011,
    const RDColor& Color101, const RDColor& Color111,
    UINT8 uA, UINT8 uB, UINT8 uC)
{
    RDColor Color0, Color1, OutColor0, OutColor1;
    LerpColor( Color0, Color000, Color010, uA);
    LerpColor( Color1, Color100, Color110, uA);
    LerpColor( OutColor0, Color0, Color1, uB);
    LerpColor( Color0, Color001, Color011, uA);
    LerpColor( Color1, Color101, Color111, uA);
    LerpColor( OutColor1, Color0, Color1, uB);
    LerpColor( OutColor, OutColor0, OutColor1, uC);
}

///////////////////////////////////////////////////////////////////////////////
//
// DDGetAttachedSurfaceLcl implementation
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
DDGetAttachedSurfaceLcl(
    LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
    LPDDSCAPS2 lpDDSCaps,
    LPDDRAWI_DDRAWSURFACE_LCL *lplpDDAttachedSurfaceLcl)
{
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    LPDDRAWI_DDRAWSURFACE_GBL   pgbl;

    LPATTACHLIST        pal;
    DWORD           caps;
    DWORD           testcaps;
    DWORD           ucaps;
    DWORD           caps2;
    DWORD           testcaps2;
    DWORD           ucaps2;
    DWORD           caps3;
    DWORD           testcaps3;
    DWORD           ucaps3;
    DWORD           caps4;
    DWORD           testcaps4;
    DWORD           ucaps4;
    BOOL            ok;

    pgbl = this_lcl->lpGbl;
    *lplpDDAttachedSurfaceLcl = NULL;
    pdrv = pgbl->lpDD;

    /*
     * look for the surface
     */
    pal = this_lcl->lpAttachList;
    testcaps = lpDDSCaps->dwCaps;
    testcaps2 = lpDDSCaps->dwCaps2;
    testcaps3 = lpDDSCaps->dwCaps3;
    testcaps4 = lpDDSCaps->dwCaps4;
    while( pal != NULL )
    {
        ok = TRUE;
        caps = pal->lpAttached->ddsCaps.dwCaps;
        caps2 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2;
        caps3 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps3;
        caps4 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps4;
        ucaps = caps & testcaps;
        ucaps2 = caps2 & testcaps2;
        ucaps3 = caps3 & testcaps3;
        ucaps4 = caps4 & testcaps4;
        if( ucaps | ucaps2 | ucaps3 | ucaps4 )
        {
            /*
             * there are caps in common, make sure that the caps to test
             * were all there
             */
            if( (ucaps & testcaps) == testcaps &&
                (ucaps2 & testcaps2) == testcaps2 &&
                (ucaps3 & testcaps3) == testcaps3 &&
                (ucaps4 & testcaps4) == testcaps4   )
            {
            }
            else
            {
                ok = FALSE;
            }
        }
        else
        {
            ok = FALSE;
        }


        if( ok )
        {
            *lplpDDAttachedSurfaceLcl = pal->lpAttached;
            return DD_OK;
        }
        pal = pal->lpLink;
    }
    return DDERR_NOTFOUND;

}

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//---------------------------------------------------------------------
BOOL
GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize)
{

    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD dwType;
        LONG result;
        result =  RegQueryValueEx(hKey, valueName, NULL, &dwType,
                                  (LPBYTE)value, &dwSize);
        RegCloseKey(hKey);

        return result == ERROR_SUCCESS && dwType == type;
    }
    else
        return FALSE;
}

//---------------------------------------------------------------------
// Gets the value from DIRECT3D Reference device registry key
// Returns TRUE if success
// If fails value is not changed
//---------------------------------------------------------------------
BOOL
GetD3DRefRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize)
{

    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3DREF, &hKey))
    {
        DWORD dwType;
        LONG result;
        result =  RegQueryValueEx(hKey, valueName, NULL, &dwType,
                                  (LPBYTE)value, &dwSize);
        RegCloseKey(hKey);

        return result == ERROR_SUCCESS && dwType == type;
    }
    else
        return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// RefAlignedBuffer32
///////////////////////////////////////////////////////////////////////////////
HRESULT
RefAlignedBuffer32::Grow(DWORD growSize)
{
    if (m_allocatedBuf)
        free(m_allocatedBuf);
    m_size = growSize;
    if ((m_allocatedBuf = malloc(m_size + 31)) == NULL)
    {
        m_allocatedBuf = 0;
        m_alignedBuf = 0;
        m_size = 0;
        return DDERR_OUTOFMEMORY;
    }
    m_alignedBuf = (LPVOID)(((ULONG_PTR)m_allocatedBuf + 31 ) & ~31);
    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\common\rtarget.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// rtarget.hpp
//
// Direct3D Reference Device - Render Target Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// Constructor/Destructor
//
//-----------------------------------------------------------------------------
RDRenderTarget::RDRenderTarget( void )
{
    memset( this, 0, sizeof(*this) );
}
//-----------------------------------------------------------------------------
RDRenderTarget::~RDRenderTarget( void )
{
    if( m_bPreDX7DDI )
    {
        if( m_pColor ) delete m_pColor;
        if( m_pDepth ) delete m_pDepth;
    }
    return;
}

//-----------------------------------------------------------------------------
//
// ReadPixelColor - Reads color buffer bits and expands out into an RDColor
// value.  Buffer types without alpha return a 1.0 value for alpha.  Low
// bits of <8 bit colors are returned as zero.
//
//-----------------------------------------------------------------------------
void
RDRenderTarget::ReadPixelColor(
    INT32 iX, INT32 iY, UINT Sample,
    RDColor& Color)
{
    if ( NULL == m_pColor->GetBits() ) return;

    char* pSurfaceBits = PixelAddress( iX, iY, 0, Sample, m_pColor );
    Color.ConvertFrom( m_pColor->GetSurfaceFormat(), pSurfaceBits );
}

//-----------------------------------------------------------------------------
//
// WritePixelColor - Takes an RDColor value, formats it for the color buffer
// format, and writes the value into buffer.
//
// Dithering is applied here, when enabled, for <8 bits/channel surfaces.
//
//-----------------------------------------------------------------------------
void
RDRenderTarget::WritePixelColor(
    INT32 iX, INT32 iY, UINT Sample,
    const RDColor& Color, BOOL bDither)
{
    if ( NULL == m_pColor->GetBits() ) return;

    // default to round to nearest
    FLOAT fRoundOffset = .5F;
    if ( bDither )
    {
        static  FLOAT fDitherTable[16] =
        {
            .03125f,  .53125f,  .15625f,  .65625f,
            .78125f,  .28125f,  .90625f,  .40625f,
            .21875f,  .71875f,  .09375f,  .59375f,
            .96875f,  .46875f,  .84375f,  .34375f
        };

        // form 4 bit offset into dither table (2 LSB's of x and y) and get offset
        unsigned uDitherOffset = ( ( iX << 2) & 0xc ) | (iY & 0x3 );
        fRoundOffset = fDitherTable[uDitherOffset];
    }

    char* pSurfaceBits = PixelAddress( iX, iY, 0, Sample, m_pColor );
    Color.ConvertTo( m_pColor->GetSurfaceFormat(), fRoundOffset, pSurfaceBits );
}

void
RDRenderTarget::WritePixelColor(
    INT32 iX, INT32 iY,
    const RDColor& Color, BOOL bDither)
{
    for (int i=0; i<m_pColor->GetSamples(); i++)
    {
        WritePixelColor( iX, iY, i, Color, bDither );
    }
}

//-----------------------------------------------------------------------------
//
// Read/WritePixelDepth - Read/write depth buffer
//
//-----------------------------------------------------------------------------
void
RDRenderTarget::WritePixelDepth(
    INT32 iX, INT32 iY, UINT Sample,
    const RDDepth& Depth )
{
    // don't write if no Z buffer
    if ( NULL == m_pDepth ) { return; }

    char* pSurfaceBits = PixelAddress( iX, iY, 0, Sample, m_pDepth );

    switch (m_pDepth->GetSurfaceFormat())
    {
    case RD_SF_Z16S0:
        *((UINT16*)pSurfaceBits) = UINT16(Depth);
        break;
    case RD_SF_Z24S8:
    case RD_SF_Z24X8:
    case RD_SF_Z24X4S4:
        {
            // need to do read-modify-write to not step on stencil
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0xffffff00);
            uBufferBits |= (UINT32(Depth) << 8);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_S8Z24:
    case RD_SF_X8Z24:
    case RD_SF_X4S4Z24:
        {
            // need to do read-modify-write to not step on stencil
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0x00ffffff);
            uBufferBits |= (UINT32(Depth) & 0x00ffffff);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_Z15S1:
        {
            // need to do read-modify-write to not step on stencil
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0xfffe);
            uBufferBits |= (UINT16(Depth) << 1);
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_S1Z15:
        {
            // need to do read-modify-write to not step on stencil
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0x7fff);
            uBufferBits |= (UINT16(Depth) & 0x7fff);
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_Z32S0:
        *((UINT32*)pSurfaceBits) = UINT32(Depth);
        break;
    }
}

void
RDRenderTarget::WritePixelDepth(
    INT32 iX, INT32 iY,
    const RDDepth& Depth )
{
    if ( NULL == m_pDepth ) { return; }
    for (int i=0; i<m_pDepth->GetSamples(); i++)
    {
        WritePixelDepth( iX, iY, i, Depth );
    }
}

//-----------------------------------------------------------------------------
void
RDRenderTarget::ReadPixelDepth(
    INT32 iX, INT32 iY, UINT Sample,
    RDDepth& Depth )
{
    // don't read if no Z buffer
    if ( NULL == m_pDepth ) { return; }

    char* pSurfaceBits = PixelAddress( iX, iY, 0, Sample, m_pDepth );

    switch (m_pDepth->GetSurfaceFormat())
    {
    case RD_SF_Z16S0:
        Depth = *((UINT16*)pSurfaceBits);
        break;
    case RD_SF_Z24S8:
    case RD_SF_Z24X8:
    case RD_SF_Z24X4S4:
        // take upper 24 bits aligned to LSB
        Depth = ( *((UINT32*)pSurfaceBits) ) >> 8;
        break;
    case RD_SF_S8Z24:
    case RD_SF_X8Z24:
    case RD_SF_X4S4Z24:
        // take lower 24 bits
        Depth = ( *((UINT32*)pSurfaceBits) ) & 0x00ffffff;
        break;
    case RD_SF_Z15S1:
        // take upper 15 bits aligned to LSB
        Depth = (UINT16)(( *((UINT16*)pSurfaceBits) ) >> 1);
        break;
    case RD_SF_S1Z15:
        // take lower 15 bits
        Depth = (UINT16)(( *((UINT16*)pSurfaceBits) ) & 0x7fff);
        break;
    case RD_SF_Z32S0:
        Depth = *((UINT32*)pSurfaceBits);
        break;
    }
}

//-----------------------------------------------------------------------------
//
// Read/WritePixelStencil - Read/Write of stencil bits within depth buffer
// surface; write is done with read-modify-write so depth bits are not disturbed;
// stencil mask is applied outside
//
//-----------------------------------------------------------------------------
void
RDRenderTarget::WritePixelStencil(
    INT32 iX, INT32 iY, UINT Sample,
    UINT8 uStencil)
{
    // don't write if no Z/Stencil buffer or no stencil in Z buffer
    if ( (NULL == m_pDepth ) ||
        ((RD_SF_Z24S8 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_S8Z24 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_S1Z15 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_Z15S1 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_Z24X4S4 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_X4S4Z24 != m_pDepth->GetSurfaceFormat())) ) { return; }

    char* pSurfaceBits = PixelAddress( iX, iY, 0, Sample, m_pDepth );

    // need to do read-modify-write to not step on Z
    switch(m_pDepth->GetSurfaceFormat())
    {
    case RD_SF_Z24S8:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0x000000ff);
            uBufferBits |= uStencil;
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_S8Z24:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0xff000000);
            uBufferBits |= (uStencil << 24);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_Z24X4S4:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0x000000ff);
            uBufferBits |= (uStencil & 0xf);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_X4S4Z24:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0xff000000);
            uBufferBits |= ((uStencil & 0xf) << 24);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_Z15S1:
        {
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0x0001);
            uBufferBits |= uStencil & 0x1;
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_S1Z15:
        {
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0x8000);
            uBufferBits |= uStencil << 15;
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    }

}

void
RDRenderTarget::WritePixelStencil(
    INT32 iX, INT32 iY,
    UINT8 uStencil)
{
    if ( NULL == m_pDepth ) { return; }
    for (int i=0; i<m_pDepth->GetSamples(); i++)
    {
        WritePixelStencil( iX, iY, i, uStencil );
    }
}

//-----------------------------------------------------------------------------
void
RDRenderTarget::ReadPixelStencil(
    INT32 iX, INT32 iY, UINT Sample,
    UINT8& uStencil)
{
    // don't read if no Z/Stencil buffer or no stencil in Z buffer
    if ( ( NULL == m_pDepth ) ||
        ((RD_SF_Z24S8 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_S8Z24 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_S1Z15 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_Z15S1 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_Z24X4S4 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_X4S4Z24 != m_pDepth->GetSurfaceFormat()) ) ) { return; }

    char* pSurfaceBits = PixelAddress( iX, iY, 0, Sample, m_pDepth );

    switch(m_pDepth->GetSurfaceFormat())
    {
    case RD_SF_Z24S8:
        uStencil = (UINT8)( ( *((UINT32*)pSurfaceBits) ) & 0xff );
        break;
    case RD_SF_S8Z24:
        uStencil = (UINT8)( ( *((UINT32*)pSurfaceBits) ) >> 24 );
        break;
    case RD_SF_Z15S1:
        uStencil = (UINT8)( ( *((UINT16*)pSurfaceBits) ) & 0x1 );
        break;
    case RD_SF_S1Z15:
        uStencil = (UINT8)( ( *((UINT16*)pSurfaceBits) ) >> 15 );
        break;
    case RD_SF_Z24X4S4:
        uStencil = (UINT8)( ( *((UINT32*)pSurfaceBits) ) & 0xf );
        break;
    case RD_SF_X4S4Z24:
        uStencil = (UINT8)( ( ( *((UINT32*)pSurfaceBits) ) >> 24 ) & 0xf);
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\drv\dprim2.cpp ===
//----------------------------------------------------------------------------
//
// dprim2.cpp
//
// Implements DrawPrimitives2.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

//---------------------------------------------------------------------
// Entry is texture count. Clears all texture format bits in the FVF DWORD,
// that correspond to the texture count
// for this count
//---------------------------------------------------------------------
const DWORD g_TextureFormatMask[9] = {
    ~0x0000FFFF,
    ~0x0003FFFF,
    ~0x000FFFFF,
    ~0x003FFFFF,
    ~0x00FFFFFF,
    ~0x03FFFFFF,
    ~0x0FFFFFFF,
    ~0x3FFFFFFF,
    ~0xFFFFFFFF
};

HRESULT
RDFVFCheckAndStride( DWORD dwFVF, DWORD* pdwStride )
{
    // If the runtime is DX8+, the dwFVF might be 0
    // in which case the stride is obtained from the streams
    if( dwFVF == 0 ) return S_OK;

    DWORD dwTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);
    DWORD vertexType = dwFVF & D3DFVF_POSITION_MASK;
    // Texture format bits above texture count should be zero
    // Reserved field 0 and 2 should be 0
    // Reserved 1 should be set only for LVERTEX
    // Only two vertex position types allowed
    if( dwFVF & g_TextureFormatMask[dwTexCoord] )
    {
        DPFERR( "FVF has incorrect texture format" );
        return DDERR_INVALIDPARAMS;
    }

    if( dwFVF & (D3DFVF_RESERVED2 | D3DFVF_RESERVED0) )
    {
        DPFERR( "FVF has reserved bit(s) set" );
        return DDERR_INVALIDPARAMS;
    }

    if( !(vertexType == D3DFVF_XYZRHW ||
          vertexType == D3DFVF_XYZ ||
          vertexType == D3DFVF_XYZB1 ||
          vertexType == D3DFVF_XYZB2 ||
          vertexType == D3DFVF_XYZB3 ||
          vertexType == D3DFVF_XYZB4 ||
          vertexType == D3DFVF_XYZB5) )
    {
        DPFERR( "FVF has incorrect position type" );
        return DDERR_INVALIDPARAMS;
    }

    if( (vertexType == D3DFVF_XYZRHW) && (dwFVF & D3DFVF_NORMAL) )
    {
        DPFERR( "Normal should not be used with XYZRHW position type" );
        return DDERR_INVALIDPARAMS;
    }

    *pdwStride = GetFVFVertexSize( dwFVF );
    return D3D_OK;
}


inline D3DPRIMITIVETYPE ConvertDP2OPToPrimType(D3DHAL_DP2OPERATION Dp2Op)
{
    switch (Dp2Op)
    {
    case D3DDP2OP_POINTS              :
        return D3DPT_POINTLIST;
    case D3DDP2OP_INDEXEDLINELIST     :
    case D3DDP2OP_INDEXEDLINELIST2    :
    case D3DDP2OP_LINELIST_IMM        :
    case D3DDP2OP_LINELIST            :
        return D3DPT_LINELIST;
    case D3DDP2OP_TRIANGLELIST        :
    case D3DDP2OP_INDEXEDTRIANGLELIST :
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        return D3DPT_TRIANGLELIST;
    case D3DDP2OP_LINESTRIP           :
    case D3DDP2OP_INDEXEDLINESTRIP    :
        return D3DPT_LINESTRIP;
    case D3DDP2OP_TRIANGLESTRIP       :
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        return D3DPT_TRIANGLESTRIP;
    case D3DDP2OP_TRIANGLEFAN         :
    case D3DDP2OP_INDEXEDTRIANGLEFAN  :
    case D3DDP2OP_TRIANGLEFAN_IMM     :
        return D3DPT_TRIANGLEFAN;
    case D3DDP2OP_RENDERSTATE         :
    case D3DDP2OP_TEXTURESTAGESTATE   :
    case D3DDP2OP_VIEWPORTINFO        :
    case D3DDP2OP_WINFO               :
    default:
        DPFM(4, DRV, ("(RefRast)Non primitive operation operation in DrawPrimitives2"));
        return (D3DPRIMITIVETYPE)0;
    }
}

//----------------------------------------------------------------------------
//
// FvfToRDVertex
//
// Converts a series of FVF vertices to RDVertices, which are the internal
// currency of the RefDev.
//
//----------------------------------------------------------------------------
void 
RefDev::FvfToRDVertex( PUINT8 pVtx, GArrayT<RDVertex>& dstArray, DWORD dwFvf, 
                       DWORD dwStride, UINT cVertices )
{
    for (DWORD i = 0; i < cVertices; i++)
    {
        dstArray[i].SetFvfData( (LPDWORD)pVtx, dwFvf );
        pVtx += dwStride;
    }
}

//----------------------------------------------------------------------------
//
// RefRastDrawPrimitives2
//
// This is called by D3DIM for API DrawPrimitives2 to draw a set of primitives
// using a vertex buffer.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data)
{
    HRESULT hr = D3D_OK;

    RefDev *pRefDev;
    DWORD dwStride = 0;
    DWORD dwFVF = pDPrim2Data->dwVertexType;
    PUINT8 pVtData = NULL;
    PUINT8 pUMVtx = NULL;
    DWORD dwNumVertices = pDPrim2Data->dwVertexLength;

    VALIDATE_REFRAST_CONTEXT("RefRastDrawPrimitives", pDPrim2Data);

    if( pDPrim2Data->lpVertices )
    {
        if (pDPrim2Data->dwFlags & D3DHALDP2_USERMEMVERTICES)
        {
            pUMVtx = (PUINT8)pDPrim2Data->lpVertices;
            pVtData = pUMVtx + pDPrim2Data->dwVertexOffset;
        }
        else
        {
            pVtData = (PUINT8)pDPrim2Data->lpDDVertex->lpGbl->fpVidMem +
                pDPrim2Data->dwVertexOffset;
        }
    }

    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)
                                ((PUINT8)pDPrim2Data->lpDDCommands->lpGbl->fpVidMem +
                                 pDPrim2Data->dwCommandOffset);
    UINT_PTR CmdBoundary = (UINT_PTR)pCmd +
                               pDPrim2Data->dwCommandLength;


    // Unconditionally get the vertex stride, since it can not change
    if ((pDPrim2Data->ddrval = RDFVFCheckAndStride(
                        (DWORD)pDPrim2Data->dwVertexType, &dwStride)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // If this is a pre-DX8 DDI, then the FVF shader needs to be set as
    // the current shader. ONLY IF it requires vertex processing.
    // Else, convert its data into the RDVertex array.
    //
    if( pRefDev->GetDDIType() < RDDDI_DX8HAL )
    {
        if( !FVF_TRANSFORMED( dwFVF ) )
        {
            BYTE CmdBytes[ sizeof( D3DHAL_DP2COMMAND ) +
                         sizeof( D3DHAL_DP2VERTEXSHADER ) ];

            D3DHAL_DP2COMMAND& cmd = *(LPD3DHAL_DP2COMMAND)CmdBytes;
            D3DHAL_DP2VERTEXSHADER& vs =
                *(LPD3DHAL_DP2VERTEXSHADER)((LPD3DHAL_DP2COMMAND)CmdBytes + 1);
            cmd.bCommand    = D3DDP2OP_SETVERTEXSHADER;
            cmd.wStateCount = 1;
            vs.dwHandle = dwFVF;
            pRefDev->Dp2SetVertexShader( (LPD3DHAL_DP2COMMAND)CmdBytes );

            // Set the 0th stream here as well.
            pRefDev->GetVStream( 0 ).m_pData = pVtData;
            pRefDev->GetVStream( 0 ).m_dwStride = dwStride;
        }
        else
        {
            // Ask the RefDev to grow its TLVBuf Array and copy the
            // FVF data into it.
            HR_RET( pRefDev->GrowTLVArray( dwNumVertices ) );
            pRefDev->FvfToRDVertex( pVtData, pRefDev->GetTLVArray(), dwFVF, 
                                    dwStride, dwNumVertices );
        }
    }

    // Skip state check and texture lock if the first thing is state change
    //
    // WINFO is excluded here because it currently does not affect RGB/MMX
    // and refrast does not care if it changes between begin/endrendering.
    //
    // VIEWPORTINFO is excluded here because it is OK to change the viewport
    // between begin/endrendering on both RGB/MMX and Ref.
    //

#ifndef __D3D_NULL_REF
    // Loop through the data, update render states
    // and then draw the primitive
    for (;;)
    {
        LPDWORD lpdwRStates;
        if (pDPrim2Data->dwFlags & D3DHALDP2_EXECUTEBUFFER)
            lpdwRStates = pDPrim2Data->lpdwRStates;
        else
            lpdwRStates = NULL;

        pDPrim2Data->ddrval = pRefDev->DrawPrimitives2( pUMVtx,
                                                         (UINT16)dwStride,
                                                         dwFVF,
                                                         dwNumVertices,
                                                         &pCmd,
                                                         lpdwRStates );
        if (pDPrim2Data->ddrval != D3D_OK)
        {
            if (pDPrim2Data->ddrval == D3DERR_COMMAND_UNPARSED)
            {
                pDPrim2Data->dwErrorOffset = (UINT32)((ULONG_PTR)pCmd -
                          (UINT_PTR)(pDPrim2Data->lpDDCommands->lpGbl->fpVidMem));
            }
            goto EH_Exit;
        }
        if ((UINT_PTR)pCmd >= CmdBoundary)
            break;
    }
 EH_Exit:
#else //__D3D_NULL_REF
    pDPrim2Data->ddrval = S_OK;
#endif //__D3D_NULL_REF


	hr = pRefDev->EndRendering();
    
    if (pDPrim2Data->ddrval == D3D_OK)
    {
        pDPrim2Data->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

#ifndef __D3D_NULL_REF
HRESULT FASTCALL
DoDrawIndexedTriList2( RefDev *pCtx,
                       WORD cPrims,
                       D3DHAL_DP2INDEXEDTRIANGLELIST *pTriList)
{
    INT i;
    D3DHAL_DP2INDEXEDTRIANGLELIST *pTri = pTriList;
    GArrayT<RDVertex>& VtxArray = pCtx->GetTLVArray();

    for (i = 0; i < cPrims; i ++)
    {
        HRESULT hr;

        PUINT8 pVtx0, pVtx1, pVtx2;
        RDVertex& Vtx0 = VtxArray[pTri->wV1];
        RDVertex& Vtx1 = VtxArray[pTri->wV2];
        RDVertex& Vtx2 = VtxArray[pTri->wV3];
        pCtx->DrawTriangle( &Vtx0, &Vtx1, &Vtx2, pTri->wFlags);
        pTri ++;
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawPrimitives2
//
// It's called by RefRastDrawPrimitives2. .
//
//----------------------------------------------------------------------------
HRESULT 
RefDev::DrawPrimitives2( PUINT8 pUMVtx,
                         UINT16 dwStride,
                         DWORD dwFvf,
                         DWORD dwNumVertices,
                         LPD3DHAL_DP2COMMAND *ppCmd,
                         LPDWORD lpdwRStates )
{
    LPD3DHAL_DP2COMMAND pCmd = *ppCmd;
    HRESULT hr = S_OK;
    
    DPFM(7, DRV, ("(RefRast)Read Ins: %08lx", *(LPDWORD)pCmd));

    BOOL bWireframe = 
        (GetRS()[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME);

    //
    // Lock textures and setup the floating point state if the
    // command is a drawing command, only if it has not been locked before
    //
    switch(pCmd->bCommand)
    {
    case D3DDP2OP_POINTS:
    case D3DDP2OP_LINELIST:
    case D3DDP2OP_LINESTRIP:
    case D3DDP2OP_TRIANGLELIST:
    case D3DDP2OP_TRIANGLESTRIP:
    case D3DDP2OP_TRIANGLEFAN:
    case D3DDP2OP_INDEXEDLINELIST:
    case D3DDP2OP_INDEXEDLINELIST2:
    case D3DDP2OP_INDEXEDLINESTRIP:
    case D3DDP2OP_INDEXEDTRIANGLELIST:
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
    case D3DDP2OP_TRIANGLEFAN_IMM:
    case D3DDP2OP_LINELIST_IMM:
        _ASSERT( GetDDIType() < RDDDI_DX8HAL, "Older drawing tokens"
                 " received for DX8+ DDI" );
        // Fall through
    case D3DDP2OP_DRAWPRIMITIVE:
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE:
    case D3DDP2OP_CLIPPEDTRIANGLEFAN:
    case D3DDP2OP_DRAWPRIMITIVE2:
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE2:
    case D3DDP2OP_DRAWRECTPATCH:
    case D3DDP2OP_DRAWTRIPATCH:
        // Turn off the TCI override, this will be set if needed later
        // on during vertex processing by the fixed function pipeline.
        m_bOverrideTCI = FALSE;
        // This stuff needs to be updated only on pre DX7 drivers.
        HR_RET(RefRastUpdatePalettes( this ));
        HR_RET(BeginRendering());
    }

    switch(pCmd->bCommand)
    {
    case D3DDP2OP_STATESET:
        {
            LPD3DHAL_DP2STATESET pStateSetOp = 
                (LPD3DHAL_DP2STATESET)(pCmd + 1);

            switch (pStateSetOp->dwOperation)
            {
            case D3DHAL_STATESETBEGIN  :
                HR_RET(BeginStateSet(pStateSetOp->dwParam));
                break;
            case D3DHAL_STATESETEND    :
                HR_RET(EndStateSet());
                break;
            case D3DHAL_STATESETDELETE :
                HR_RET(DeleteStateSet(pStateSetOp->dwParam));
                break;
            case D3DHAL_STATESETEXECUTE:
                HR_RET(ExecuteStateSet(pStateSetOp->dwParam));
                break;
            case D3DHAL_STATESETCAPTURE:
                HR_RET(CaptureStateSet(pStateSetOp->dwParam));
                break;
            case D3DHAL_STATESETCREATE:
                HR_RET(CreateStateSet(pStateSetOp->dwParam, 
                                    pStateSetOp->sbType));
                break;
            default :
                return DDERR_INVALIDPARAMS;
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pStateSetOp + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_VIEWPORTINFO:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetViewport(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2VIEWPORTINFO *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_WINFO:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetWRange(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2WINFO *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_RENDERSTATE:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetRenderStates(this, dwFvf, pCmd, 
                                                           lpdwRStates));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2RENDERSTATE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_TEXTURESTAGESTATE:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2TextureStageState(this, dwFvf, 
                                                             pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
               ((LPD3DHAL_DP2TEXTURESTAGESTATE)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    // This is a special case because it has edge flags. Other D3DDP2OP
    // can actually make use of DrawOneIndexedPrimitive/DrawOnePrimitive.
    case D3DDP2OP_INDEXEDTRIANGLELIST:
        {
            // This command is used in execute buffers. So untransformed
            // vertices are not expected by this refrast.
            _ASSERT( FVF_TRANSFORMED(dwFvf), "Untransformed vertices in "
                     "D3DDP2OP_INDEXEDTRIANGLELIST" );

            WORD cPrims = pCmd->wPrimitiveCount;
            HR_RET(DoDrawIndexedTriList2(
                this, cPrims, (D3DHAL_DP2INDEXEDTRIANGLELIST *)(pCmd + 1)));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(pCmd + 1) +
                            sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST) * cPrims);
        }
        break;
    case D3DDP2OP_INDEXEDLINELIST:
        {
            // This command is used in execute buffers. So untransformed
            // vertices are not expected by this refrast.
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_INDEXEDLINELIST" );

            HR_RET(DrawOneIndexedPrimitive( GetTLVArray(),
                                            0,
                                            (LPWORD)(pCmd + 1),
                                            0,
                                            pCmd->wPrimitiveCount * 2,
                                            D3DPT_LINELIST));

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(pCmd + 1) +
                    pCmd->wPrimitiveCount * sizeof(D3DHAL_DP2INDEXEDLINELIST));
        }
        break;
    // Following ops All use DrawOneIndexedPrimitive/DrawOnePrimitive.
    // There are some extra overheads introduced because those two functions
    // need to switch over the PrimTypes while we already know it here.
    // Striping out the code to add inline functions for each PrimType means
    // adding about twenty functions(considering the types of prim times types
    // of vertex). So I have used DrawOneIndexedPrimitive/DrawOnePrimitive
    // here anyway. We can later change it if necessary.
    case D3DDP2OP_POINTS:
        {
            WORD cPrims = pCmd->wPrimitiveCount;
            D3DHAL_DP2POINTS *pPt = (D3DHAL_DP2POINTS *)(pCmd + 1);
            WORD i;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                for (i = 0; i < cPrims; i++)
                {
                    HR_RET(ProcessPrimitive( D3DPT_POINTLIST,
                                             pPt->wVStart,
                                             pPt->wCount,
                                             0, 0 ));
                    pPt ++;
                }
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    for (i = 0; i < cPrims; i++)
                    {
                        HR_RET(m_Clipper.DrawOnePrimitive( GetTLVArray(),
                                                           pPt->wVStart,
                                                           D3DPT_POINTLIST,
                                                           pPt->wCount));
                        
                        // Clean up the FVFP_CLIP bit for the 
                        // copied vertices.
                        pPt ++;
                    }
                }
                else
                {
                    for (i = 0; i < cPrims; i++)
                    {
                        HR_RET(DrawOnePrimitive( GetTLVArray(),
                                                 pPt->wVStart,
                                                 D3DPT_POINTLIST,
                                                 pPt->wCount));
                        pPt ++;
                    }
                }
            }
            
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)pPt;
        }
        break;
    case D3DDP2OP_LINELIST:
        {
            D3DHAL_DP2LINELIST *pLine = (D3DHAL_DP2LINELIST *)(pCmd + 1);

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive( D3DPT_LINELIST, pLine->wVStart,
                                         pCmd->wPrimitiveCount * 2, 0, 0 ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOnePrimitive( 
                        GetTLVArray(),
                        pLine->wVStart,
                        D3DPT_LINELIST,
                        pCmd->wPrimitiveCount * 2));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOnePrimitive( 
                        GetTLVArray(),
                        pLine->wVStart,
                        D3DPT_LINELIST,
                        pCmd->wPrimitiveCount * 2));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pLine + 1);
        }
        break;
    case D3DDP2OP_INDEXEDLINELIST2:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount*2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Set the Index Stream
            m_IndexStream.m_pData = (LPBYTE)(lpStartVertex + 1);
            m_IndexStream.m_dwStride = 2;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive(
                    D3DPT_LINELIST,
                    lpStartVertex->wVStart,
                    dwNumVertices-lpStartVertex->wVStart,
                    0,
                    dwNumIndices ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_LINELIST));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_LINELIST));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                    pCmd->wPrimitiveCount * sizeof(D3DHAL_DP2INDEXEDLINELIST));
        }
        break;
    case D3DDP2OP_LINESTRIP:
        {
            D3DHAL_DP2LINESTRIP *pLine = (D3DHAL_DP2LINESTRIP *)(pCmd + 1);

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive( D3DPT_LINESTRIP,
                                         pLine->wVStart,
                                         pCmd->wPrimitiveCount + 1,
                                         0, 0 ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOnePrimitive( 
                        GetTLVArray(),
                        pLine->wVStart,
                        D3DPT_LINESTRIP,
                        pCmd->wPrimitiveCount + 1));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOnePrimitive( 
                        GetTLVArray(),
                        pLine->wVStart,
                        D3DPT_LINESTRIP,
                        pCmd->wPrimitiveCount + 1));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pLine + 1);
        }
        break;
    case D3DDP2OP_INDEXEDLINESTRIP:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount + 1;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Set the Index Stream
            m_IndexStream.m_pData = (LPBYTE)(lpStartVertex + 1);
            m_IndexStream.m_dwStride = 2;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive(
                    D3DPT_LINESTRIP,
                    lpStartVertex->wVStart,
                    dwNumVertices-lpStartVertex->wVStart,
                    0,
                    dwNumIndices ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_LINESTRIP));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_LINESTRIP));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLELIST:
        {
            D3DHAL_DP2TRIANGLELIST *pTri = (D3DHAL_DP2TRIANGLELIST *)(pCmd + 1);

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive( D3DPT_TRIANGLELIST,
                                         pTri->wVStart,
                                         pCmd->wPrimitiveCount * 3,
                                         0, 0 ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOnePrimitive( 
                        GetTLVArray(),
                        pTri->wVStart,
                        D3DPT_TRIANGLELIST,
                        pCmd->wPrimitiveCount * 3));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOnePrimitive( GetTLVArray(),
                                             pTri->wVStart,
                                             D3DPT_TRIANGLELIST,
                                             pCmd->wPrimitiveCount * 3));

                }
            }
            
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount*3;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Set the Index Stream
            m_IndexStream.m_pData = (LPBYTE)(lpStartVertex + 1);
            m_IndexStream.m_dwStride = 2;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive(
                    D3DPT_TRIANGLELIST,
                    lpStartVertex->wVStart,
                    dwNumVertices-lpStartVertex->wVStart,
                    0,
                    dwNumIndices));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_TRIANGLELIST));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_TRIANGLELIST));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLESTRIP:
        {
            D3DHAL_DP2TRIANGLESTRIP *pTri = (D3DHAL_DP2TRIANGLESTRIP *)(pCmd + 1);
            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive( D3DPT_TRIANGLESTRIP,
                                               pTri->wVStart,
                                               pCmd->wPrimitiveCount + 2,
                                               0, 0 ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOnePrimitive( 
                        GetTLVArray(),
                        pTri->wVStart,
                        D3DPT_TRIANGLESTRIP,
                        pCmd->wPrimitiveCount + 2));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOnePrimitive( 
                        GetTLVArray(),
                        pTri->wVStart,
                        D3DPT_TRIANGLESTRIP,
                        pCmd->wPrimitiveCount + 2));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount+2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Set the Index Stream
            m_IndexStream.m_pData = (LPBYTE)(lpStartVertex + 1);
            m_IndexStream.m_dwStride = 2;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive(
                    D3DPT_TRIANGLESTRIP,
                    lpStartVertex->wVStart,
                    dwNumVertices-lpStartVertex->wVStart,
                    0,
                    dwNumIndices ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_TRIANGLESTRIP));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_TRIANGLESTRIP));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLEFAN:
        {
            D3DHAL_DP2TRIANGLEFAN *pTri = (D3DHAL_DP2TRIANGLEFAN *)(pCmd + 1);

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive( D3DPT_TRIANGLEFAN,
                                               pTri->wVStart,
                                               pCmd->wPrimitiveCount + 2,
                                               0, 0 ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOnePrimitive( 
                        GetTLVArray(),
                        pTri->wVStart,
                        D3DPT_TRIANGLEFAN,
                        pCmd->wPrimitiveCount + 2));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOnePrimitive( 
                        GetTLVArray(),
                        pTri->wVStart,
                        D3DPT_TRIANGLEFAN,
                        pCmd->wPrimitiveCount + 2));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount + 2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Set the Index Stream
            m_IndexStream.m_pData = (LPBYTE)(lpStartVertex + 1);
            m_IndexStream.m_dwStride = 2;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive(
                    D3DPT_TRIANGLEFAN,
                    lpStartVertex->wVStart,
                    dwNumVertices-lpStartVertex->wVStart,
                    0,
                    dwNumIndices ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_TRIANGLEFAN));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_TRIANGLEFAN));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLEFAN_IMM:
        {
            DWORD vertexCount = pCmd->wPrimitiveCount + 2;
            // Make sure the pFanVtx pointer is DWORD aligned: (pFanVtx +3) % 4
            PUINT8 pFanVtx = (PUINT8)
                (((ULONG_PTR)(pCmd + 1) + 
                  sizeof(D3DHAL_DP2TRIANGLEFAN_IMM) + 3) & ~3);

            // Assert here. This case should never be reached.
            // This command is used by front end to give clipped
            // primitives inside the command itself. Since TL Hals
            // do their own clipping untransformed vertices but yet
            // clipped are not expected here.
            // Assert that only transformed vertices can reach here
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_TRIANGLEFAN_IMM" );

            GArrayT<RDVertex> ClipVtxArray;
            HR_RET(ClipVtxArray.Grow( vertexCount ) );
            FvfToRDVertex( pFanVtx, ClipVtxArray, dwFvf, dwStride,
                           vertexCount );
            if (bWireframe)
            {
                // Read edge flags
                UINT32 dwEdgeFlags =
                    ((LPD3DHAL_DP2TRIANGLEFAN_IMM)(pCmd + 1))->dwEdgeFlags;
                HR_RET(DrawOneEdgeFlagTriangleFan( ClipVtxArray,
                                                   vertexCount,
                                                   dwEdgeFlags));
            }
            else
            {
                HR_RET(DrawOnePrimitive( ClipVtxArray,
                                          0,
                                          D3DPT_TRIANGLEFAN,
                                          vertexCount));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)pFanVtx +
                                           vertexCount * dwStride);
        }
        break;
    case D3DDP2OP_LINELIST_IMM:
        {
            DWORD vertexCount = pCmd->wPrimitiveCount * 2;
            // Make sure the pLineVtx pointer is DWORD aligned:
            // (pLineVtx +3) % 4
            PUINT8 pLineVtx = (PUINT8)(((ULONG_PTR)(pCmd + 1) + 3) & ~3);

            // Assert here. This case should never be reached.
            // This command is used by front end to give clipped
            // primitives inside the command itself. Since TL Hals
            // do their own clipping untransformed vertices but yet
            // clipped are not expected here.
            // Assert that only transformed vertices can reach here
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_LINELIST_IMM" );

            GArrayT<RDVertex> ClipVtxArray;
            HR_RET(ClipVtxArray.Grow( vertexCount ) );
            FvfToRDVertex( pLineVtx, ClipVtxArray, dwFvf, dwStride,
                           vertexCount );
            HR_RET(DrawOnePrimitive( ClipVtxArray,
                                     0,
                                     D3DPT_LINELIST,
                                     vertexCount));

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)pLineVtx +
                                           vertexCount * dwStride);
        }
        break;
    case D3DDP2OP_DRAWPRIMITIVE:
        {
            HR_RET(Dp2DrawPrimitive(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWPRIMITIVE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_DRAWPRIMITIVE2:
        {
            HR_RET(Dp2DrawPrimitive2(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWPRIMITIVE2 *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_DRAWRECTPATCH:
        {
            LPD3DHAL_DP2DRAWRECTPATCH pDP = 
                (LPD3DHAL_DP2DRAWRECTPATCH)(pCmd + 1);
            for( int i = 0; i < pCmd->wStateCount; i++ )
            {
                HR_RET(DrawRectPatch(pDP));
                bool hassegs = (pDP->Flags & RTPATCHFLAG_HASSEGS) != 0;
                bool hasinfo = (pDP->Flags & RTPATCHFLAG_HASINFO) != 0;
                if(hassegs)
                {
                    pDP = (LPD3DHAL_DP2DRAWRECTPATCH)((BYTE*)(pDP + 1) + 
                                                      sizeof(FLOAT) * 4);
                }
                else
                {
                    ++pDP;
                }
                if(hasinfo)
                {
                    pDP = (LPD3DHAL_DP2DRAWRECTPATCH)((BYTE*)pDP + sizeof(D3DRECTPATCH_INFO));
                }
            }
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)pDP;
        }
        break;
    case D3DDP2OP_DRAWTRIPATCH:
        {
            LPD3DHAL_DP2DRAWTRIPATCH pDP = 
                (LPD3DHAL_DP2DRAWTRIPATCH)(pCmd + 1);
            for( int i = 0; i < pCmd->wStateCount; i++ )
            {
                HR_RET(DrawTriPatch(pDP));
                bool hassegs = (pDP->Flags & RTPATCHFLAG_HASSEGS) != 0;
                bool hasinfo = (pDP->Flags & RTPATCHFLAG_HASINFO) != 0;
                if(hassegs)
                {
                    pDP = (LPD3DHAL_DP2DRAWTRIPATCH)((BYTE*)(pDP + 1) + 
                                                      sizeof(FLOAT) * 3);
                }
                else
                {
                    ++pDP;
                }
                if(hasinfo)
                {
                    pDP = (LPD3DHAL_DP2DRAWTRIPATCH)((BYTE*)pDP + sizeof(D3DTRIPATCH_INFO));
                }
            }
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)pDP;
        }
        break;
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE:
        {
            HR_RET(Dp2DrawIndexedPrimitive(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWINDEXEDPRIMITIVE *)(pCmd + 1) +
                 pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE2:
        {
            HR_RET(Dp2DrawIndexedPrimitive2(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWINDEXEDPRIMITIVE2 *)(pCmd + 1) +
                 pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_CLIPPEDTRIANGLEFAN:
        {
            HR_RET(Dp2DrawClippedTriFan(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_CLIPPEDTRIANGLEFAN*)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_ZRANGE:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetZRange(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2ZRANGE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETMATERIAL:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetMaterial(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETMATERIAL *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETLIGHT:
        {
            DWORD dwSLStride = 0;
            HR_RET(pStateSetFuncTbl->pfnDp2SetLight(this, pCmd, &dwSLStride));
            *ppCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)pCmd  + dwSLStride);
        }
        break;
    case D3DDP2OP_CREATELIGHT:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2CreateLight(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2CREATELIGHT *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETTRANSFORM:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetTransform(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETTRANSFORM *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_MULTIPLYTRANSFORM:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2MultiplyTransform(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2MULTIPLYTRANSFORM *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_EXT:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetExtention(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2EXT *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETRENDERTARGET:
        {
            HR_RET(Dp2SetRenderTarget(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETRENDERTARGET*)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_CLEAR:
        {
            HR_RET(Clear(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pCmd + 1) +
                sizeof(D3DHAL_DP2CLEAR) + (pCmd->wStateCount - 1) * sizeof(RECT));
        }
        break;
    case D3DDP2OP_SETCLIPPLANE:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetClipPlane(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2SETCLIPPLANE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DOP_SPAN:
        // Skip over
        *ppCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pCmd + 1) +
                  pCmd->wPrimitiveCount * pCmd->bReserved );
        break;
    case D3DDP2OP_CREATEVERTEXSHADER:
    {
        LPD3DHAL_DP2CREATEVERTEXSHADER pCVS =
            (LPD3DHAL_DP2CREATEVERTEXSHADER)(pCmd + 1);
        WORD i;

        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pDecl = (LPDWORD)(pCVS + 1);
            LPDWORD pCode = (LPDWORD)((LPBYTE)pDecl + pCVS->dwDeclSize);
            hr = Dp2CreateVertexShader( pCVS->dwHandle,
                                        pCVS->dwDeclSize, pDecl,
                                        pCVS->dwCodeSize, pCode );
            if( FAILED( hr ) ) break;
            // Update the pointer
            pCVS = (LPD3DHAL_DP2CREATEVERTEXSHADER)((LPBYTE)pCode +
                                                    pCVS->dwCodeSize);
        }
        // Successful termination of the loop:
        // Update the command buffer pointer
        if( i == pCmd->wStateCount )
            *ppCmd = (LPD3DHAL_DP2COMMAND)pCVS;
        else
            return hr;
        break;
    }
    case D3DDP2OP_DELETEVERTEXSHADER:
        HR_RET(Dp2DeleteVertexShader(pCmd));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2VERTEXSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETVERTEXSHADER:
        HR_RET(pStateSetFuncTbl->pfnDp2SetVertexShader(this, pCmd));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2VERTEXSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETVERTEXSHADERCONST:
    {
        LPD3DHAL_DP2SETVERTEXSHADERCONST pSVC =
            (LPD3DHAL_DP2SETVERTEXSHADERCONST)(pCmd + 1);
        WORD i;
        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pData = (LPDWORD)(pSVC + 1);
            hr = pStateSetFuncTbl->pfnDp2SetVertexShaderConsts(
                this, pSVC->dwRegister, pSVC->dwCount, pData );
            if( FAILED( hr ) ) break;
            // Update the pointer
            pSVC = (LPD3DHAL_DP2SETVERTEXSHADERCONST)((LPBYTE)pData +
                                                      pSVC->dwCount * 4 *
                                                      sizeof( float ) );
        }

        // Successful termination of the loop:
        // Update the command buffer pointer
        if( i == pCmd->wStateCount )
            *ppCmd = (LPD3DHAL_DP2COMMAND)pSVC;
        else
            return hr;
        break;
    }
    case D3DDP2OP_SETSTREAMSOURCE:
        // This function also updates the ppCmd pointer
        HR_RET(pStateSetFuncTbl->pfnDp2SetStreamSource(this, pCmd));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETSTREAMSOURCE *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETSTREAMSOURCEUM:
        // This function also updates the ppCmd pointer
        HR_RET(Dp2SetStreamSourceUM( pCmd, pUMVtx ));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETSTREAMSOURCEUM *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETINDICES:
        // This function also updates the ppCmd pointer
        HR_RET(pStateSetFuncTbl->pfnDp2SetIndices(this, pCmd));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETINDICES *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_CREATEPIXELSHADER:
    {
        LPD3DHAL_DP2CREATEPIXELSHADER pCPS =
            (LPD3DHAL_DP2CREATEPIXELSHADER)(pCmd + 1);
        WORD i;

        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pCode = (LPDWORD)(pCPS + 1);
            hr = Dp2CreatePixelShader( pCPS->dwHandle,
                                             pCPS->dwCodeSize, pCode );
            if( FAILED( hr ) ) break;
            // Update the pointer
            pCPS = (LPD3DHAL_DP2CREATEPIXELSHADER)((LPBYTE)pCode +
                                                    pCPS->dwCodeSize);
        }
        // Successful termination of the loop:
        // Update the command buffer pointer
        if( i == pCmd->wStateCount )
            *ppCmd = (LPD3DHAL_DP2COMMAND)pCPS;
        else
            return hr;
        break;
    }
    case D3DDP2OP_DELETEPIXELSHADER:
        HR_RET(Dp2DeletePixelShader(pCmd));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2PIXELSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETPIXELSHADER:
        HR_RET(pStateSetFuncTbl->pfnDp2SetPixelShader(this, pCmd));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2PIXELSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETPIXELSHADERCONST:
    {
        LPD3DHAL_DP2SETPIXELSHADERCONST pSVC =
            (LPD3DHAL_DP2SETPIXELSHADERCONST)(pCmd + 1);
        WORD i;
        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pData = (LPDWORD)(pSVC + 1);
            hr = pStateSetFuncTbl->pfnDp2SetPixelShaderConsts(
                this, pSVC->dwRegister, pSVC->dwCount, pData );
            if( FAILED( hr ) ) break;
            // Update the pointer
            pSVC = (LPD3DHAL_DP2SETPIXELSHADERCONST)((LPBYTE)pData +
                                                      pSVC->dwCount * 4 *
                                                      sizeof( float ) );
        }

        // Successful termination of the loop:
        // Update the command buffer pointer
        if( i == pCmd->wStateCount )
            *ppCmd = (LPD3DHAL_DP2COMMAND)pSVC;
        else
            return hr;
        break;
    }
    case D3DDP2OP_SETPALETTE:
    {
        HR_RET(Dp2SetPalette(pCmd));
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETPALETTE *)(pCmd + 1) + pCmd->wStateCount);
        break;
    }
    case D3DDP2OP_UPDATEPALETTE:
    {
        LPD3DHAL_DP2UPDATEPALETTE pUP = (LPD3DHAL_DP2UPDATEPALETTE)(pCmd + 1);
        WORD i;
        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            PALETTEENTRY* pEntries = (PALETTEENTRY *)(pUP + 1);
            HR_RET(Dp2UpdatePalette(pUP, pEntries));
            pUP = (LPD3DHAL_DP2UPDATEPALETTE)(pEntries + pUP->wNumEntries);
        }
        if( i == pCmd->wStateCount )
            *ppCmd = (LPD3DHAL_DP2COMMAND)pUP;
        else
            return hr;
        break;
    }
    case D3DDP2OP_SETTEXLOD:
    {
        HR_RET(Dp2SetTexLod(pCmd));
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETTEXLOD *)(pCmd + 1) + pCmd->wStateCount);
        break;
    }
    case D3DDP2OP_SETPRIORITY:
    {
        // Skip these tokens. RefDev doesnt need to handle SetPriority
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETPRIORITY *)(pCmd + 1) + pCmd->wStateCount);
        break;
    }
    case D3DDP2OP_TEXBLT:
    {
        LPD3DHAL_DP2TEXBLT pTB = (LPD3DHAL_DP2TEXBLT)(pCmd + 1);
        for( WORD i = 0; i < pCmd->wStateCount ; i++ )
        {
            if( pTB->dwDDDestSurface == 0 )
            {
                // This is a PreLoad command, ignore it since 
                // RefDev just fakes driver management.
            }
            else
            {
                DPFERR( "TEXBLT not supported by RefDev\n" );
            }
            pTB++;
        }
        *ppCmd = (LPD3DHAL_DP2COMMAND)pTB;
        break;
    }
    case D3DDP2OP_BUFFERBLT:
    {
        LPD3DHAL_DP2BUFFERBLT pBB = (LPD3DHAL_DP2BUFFERBLT)(pCmd + 1);
        for( WORD i = 0; i < pCmd->wStateCount ; i++ )
        {
            if( pBB->dwDDDestSurface == 0 )
            {
                // This is a PreLoad command, ignore it since 
                // RefDev just fakes driver management.
            }
            else
            {
                DPFERR( "BUFFERBLT not supported by RefDev\n" );
            }
            pBB++;
        }
        *ppCmd = (LPD3DHAL_DP2COMMAND)pBB;
        break;
    }
    case D3DDP2OP_VOLUMEBLT:
    {
        LPD3DHAL_DP2VOLUMEBLT pVB = (LPD3DHAL_DP2VOLUMEBLT)(pCmd + 1);
        for( WORD i = 0; i < pCmd->wStateCount ; i++ )
        {
            if( pVB->dwDDDestSurface == 0 )
            {
                // This is a PreLoad command, ignore it since 
                // RefDev just fakes driver management.
            }
            else
            {
                DPFERR( "VOLUMEBLT not supported by RefDev\n" );
            }
            pVB++;
        }
        *ppCmd = (LPD3DHAL_DP2COMMAND)pVB;
        break;
    }
    case D3DOP_MATRIXLOAD:
    {
        DPFERR( "MATRIXLOAD not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_MATRIXMULTIPLY:
    {
        DPFERR( "MATRIXMULTIPLY not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_STATETRANSFORM:
    {
        DPFERR( "STATETRANSFORM not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_STATELIGHT:
    {
        DPFERR( "STATELIGHT not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_TEXTURELOAD:
    {
        DPFERR( "TEXTURELOAD not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_BRANCHFORWARD:
    {
        DPFERR( "BRANCHFORWARD not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_SETSTATUS:
    {
        DPFERR( "SETSTATUS not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_EXIT:
    {
        DPFERR( "EXIT not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_PROCESSVERTICES:
    {
        DPFERR( "PROCESSVERTICES not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    default:
        DPFERR( "Unknown command encountered" );
        return E_FAIL;
    }
    return hr;
}
#endif //__D3D_NULL_REF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\drv\refprov.hpp ===
//----------------------------------------------------------------------------
//
// refprov.hpp
//
// Base software HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _REFPROV_HPP_
#define _REFPROV_HPP_

//----------------------------------------------------------------------------
//
// RefHalProvider
//
// Implements the base HAL provider for the software rasterizers.
//
//----------------------------------------------------------------------------

class RefHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
};

//----------------------------------------------------------------------------
//
// RefRastHalProvider
//
// Specific provider for the reference rasterizer.
//
//----------------------------------------------------------------------------

class RefRastHalProvider : public RefHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
};

//----------------------------------------------------------------------------
//
// NullDeviceHalProvider
//
// Specific provider for the null device.
//
//----------------------------------------------------------------------------

class NullDeviceHalProvider : public RefHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
};

#endif // #ifndef _REFPROV_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\common\refdevi.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// refdevi.cpp
//
// Direct3D Reference Device - Main Internal Object Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// global controls                                                              //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////
float g_GammaTable[256];
UINT  g_iGamma = 150;

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// RefDev Methods                                                               //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Constructor/Destructor for renderer core object.
//
//-----------------------------------------------------------------------------
RefDev::RefDev( LPDDRAWI_DIRECTDRAW_LCL pDDLcl, DWORD dwInterfaceType,
                RDDDITYPE dwDDIType, D3DCAPS8* pCaps8 )
    : m_RefVP(), m_RefVM(), m_Clipper(),
      m_FVFShader()

{
    m_Caps8 = *pCaps8;
    m_pDbgMon = NULL;
    m_pDDLcl = NULL;
    m_wSaveFP = 0;
    m_bInBegin = FALSE;
    m_bPointSprite = 0;
    m_pRenderTarget = NULL;
    memset( m_fWBufferNorm, 0, sizeof( float)*2 );
    memset( m_dwRenderState, 0, sizeof( DWORD ) * D3DHAL_MAX_RSTATES );
    memset( &m_renderstate_override, 0, sizeof(m_renderstate_override) );
    m_cActiveTextureStages = 0;
    m_ReferencedTexCoordMask = 0;
    memset( m_pTexture, 0, sizeof(RDSurface2D*)*D3DHAL_TSS_MAXSTAGES );
    memset( m_dwTextureStageState, 0, sizeof(m_dwTextureStageState) );
    for (int i=0; i<D3DHAL_TSS_MAXSTAGES; i++) m_pTextureStageState[i] = m_dwTextureStageState[i];
    m_dwTexArrayLength = 0;
    m_LastState = 0;

    m_primType = (D3DPRIMITIVETYPE)0;
    m_dwNumVertices = 0;
    m_dwStartVertex = 0;
    m_dwNumIndices  = 0;
    m_dwStartIndex  = 0;

    m_RefVP.m_pDev = m_RefVM.m_pDev = m_Clipper.m_pDev = this;

    m_CurrentVShaderHandle = 0;
    m_pCurrentVShader      = NULL;
    m_qwFVFOut = 0;

    m_CurrentPShaderHandle = 0x0;

    m_Rast.Init( this );

    // All render and texture stage state is initialized by
    // DIRECT3DDEVICEI::stateInitialize

    m_dwInterfaceType = dwInterfaceType;
    m_dwDDIType = dwDDIType;
    m_pDDLcl = pDDLcl;

    // StateOverride initialize
    STATESET_INIT( m_renderstate_override );

    m_bOverrideTCI = FALSE;

    SetSetStateFunctions();

    // Set this renderstate so that the pre-DX8 emulations continue to work
    GetRS()[D3DRS_COLORWRITEENABLE] = 0xf;

    // set 'changed' flags
    m_dwRastFlags =
        RDRF_MULTISAMPLE_CHANGED|
        RDRF_PIXELSHADER_CHANGED|
        RDRF_LEGACYPIXELSHADER_CHANGED|
        RDRF_TEXTURESTAGESTATE_CHANGED;

    // make the gamma table
    {
        FLOAT   fGamma = (float)(log10(0.5f)/log10((float)g_iGamma/255));
        FLOAT   fOOGamma = 1/fGamma;
        FLOAT   fA = 0.018f;
        FLOAT   fS = (float)(((1-fOOGamma)*pow(fA,fOOGamma))/(1-(1-fOOGamma)*pow(fA,fOOGamma)));
        FLOAT   fGain = (float)((fOOGamma*pow(fA,(fOOGamma-1)))/(1-(1-fOOGamma)*pow(fA,fOOGamma)));
        FLOAT   fX;
        int     i;
        for (i = 0; i < 4; i++)
            g_GammaTable[i] = (float)(fGain*(((float)i)/255));
        for (i = 4; i < 256; i++)
            g_GammaTable[i] = (float)((1+fS)*pow((((float)i)/255),fOOGamma)-fS);
    }
}
//-----------------------------------------------------------------------------
RefDev::~RefDev( void )
{
    UINT i;

    // Clean up statesets
    for ( i = 0; i < m_pStateSets.ArraySize(); i++ )
    {
        if (m_pStateSets[i] != NULL)
            delete m_pStateSets[i];
    }

    // Clean up vertex shaders
    for( i=0; i<m_VShaderHandleArray.GetSize(); i++ )
    {
        delete m_VShaderHandleArray[i].m_pShader;
    }

    // Clean up pixel shaders
    for( i=0; i<m_PShaderHandleArray.GetSize(); i++ )
    {
        delete m_PShaderHandleArray[i].m_pShader;
    }

    // Clean up palette handles
    for( i=0; i<m_PaletteHandleArray.GetSize(); i++ )
    {
        delete m_PaletteHandleArray[i].m_pPal;
    }

    if (m_pDbgMon) delete m_pDbgMon;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// State Management Utilities                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// MapTextureHandleToDevice - This is called when texture handles change or
// when leaving legacy texture mode.  This maps the texture handle embedded
// in the per-stage state to texture object pointers.
//
//-----------------------------------------------------------------------------
void
RefDev::MapTextureHandleToDevice( int iStage )
{
    // map one
    m_pTexture[iStage] =
        MapHandleToTexture( m_TextureStageState[iStage].m_dwVal[D3DTSS_TEXTUREMAP] );
    m_pTexture[iStage]->SetRefDev(this);

    // update num active stages
    UpdateActiveTexStageCount();
}


//-----------------------------------------------------------------------------
//
// SetTextureHandle - On DX7, this is called when a texture handle is set.
// This maps the texture handle embedded in the per-stage state to texture
// object pointers.
//
//-----------------------------------------------------------------------------
HRESULT
RefDev::SetTextureHandle( int iStage, DWORD dwTexHandle )
{
    HRESULT hr = D3D_OK;

    // Special case, if texture handle == 0, then unmap the texture from the TSS
    if (dwTexHandle == 0)
    {
        m_pTexture[iStage] = NULL;

        // update num active stages
        UpdateActiveTexStageCount();
        return D3D_OK;
    }

    // Ask DDraw to decipher what this particular handle meant wrt. to the
    // the DDraw_Local associated with this instance of the Refrast
    RDSurface2D* pTex = (RDSurface2D *)g_SurfMgr.GetSurfFromList(m_pDDLcl,
                                                             dwTexHandle);
    if( pTex == NULL )
    {
        DPFERR( "Unable to obtain Texture from the list"  );
        return DDERR_INVALIDOBJECT;
    }

    // map one
    m_pTexture[iStage] = pTex;
    m_pTexture[iStage]->SetRefDev(this);

    // update num active stages
    UpdateActiveTexStageCount();
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// UpdateActiveTexStageCount - Updates number of texture coordinate/lookup
// stages that are active.
//
//-----------------------------------------------------------------------------
void
RefDev::UpdateActiveTexStageCount( void )
{
    m_dwRastFlags |= RDRF_TEXTURESTAGESTATE_CHANGED;

    // DX3/5 - always one active texture stage
    if ( NULL != m_dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] )
    {
        m_cActiveTextureStages = 1;
        m_ReferencedTexCoordMask = 0x1;
        return;
    }

    // DX8+ pixel shading model - count derived from shader code
    if (m_CurrentPShaderHandle)
    {
        RDPShader* pShader = GetPShader(m_CurrentPShaderHandle);

        if( pShader )
        {
            m_cActiveTextureStages = pShader->m_cActiveTextureStages;
            m_ReferencedTexCoordMask = pShader->m_ReferencedTexCoordMask;
        }
        else
        {
            m_cActiveTextureStages = 0;
            m_ReferencedTexCoordMask = 0;
        }
        return;
    }

    // DX6/7 pixel shading model
    m_cActiveTextureStages = 0;
    for ( int iStage=0; iStage<D3DHAL_TSS_MAXSTAGES; iStage++ )
    {
        // check for disabled stage (subsequent are thus inactive)
        if ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_DISABLE )
        {
            break;
        }

        // check for incorrectly enabled stage (may be legacy)
        if ( ( m_pTexture[iStage] == NULL ) &&
             ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLORARG1] == D3DTA_TEXTURE ) )
        {
            break;
        }

        // stage is active
        m_cActiveTextureStages++;
    }
    m_ReferencedTexCoordMask = (1<<m_cActiveTextureStages)-1;
}

//-----------------------------------------------------------------------------
//
// MapHandleToTexture - Map handle to RDSurface2D pointer.  Handle is a ppTex,
// so test it and reference it.
//
//-----------------------------------------------------------------------------
RDSurface2D*
RefDev::MapHandleToTexture( D3DTEXTUREHANDLE hTex )
{
    if ( 0x0 == hTex ) { return NULL; }
#ifdef _IA64_
    _ASSERTa(FALSE, "This will not work on IA64", return NULL;);
#endif
    return ( *(RDSurface2D**)ULongToPtr(hTex) );
}


#ifndef __D3D_NULL_REF
//-----------------------------------------------------------------------------
//
//  Generic shared memory object, implemented using Win32 file mapping.
//  _snprintf interface for name.
//
//-----------------------------------------------------------------------------
D3DSharedMem::D3DSharedMem( INT_PTR cbSize, const char* pszFormat, ... )
{
    m_pMem = NULL;

    char pszName[1024] = "\0";
    va_list marker;
    va_start(marker, pszFormat);
    _vsnprintf(pszName+lstrlen(pszName), 1024-lstrlen(pszName), pszFormat, marker);

    m_hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE,
            NULL, PAGE_READWRITE, 0, (DWORD)cbSize, pszName);

    // check if it existed already
    m_bAlreadyExisted = (m_hFileMap != NULL) && (GetLastError() == ERROR_ALREADY_EXISTS);

    if (NULL == m_hFileMap)
    {
        _ASSERT(0,"D3DSharedMem: file mapping failed")
    }
    else
    {
        // Map a view of the file into the address space.
        m_pMem = (void *)MapViewOfFile(m_hFileMap, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
        if (NULL == m_pMem)
        {
            _ASSERT(0,"D3DSharedMem: view map failed")
            if (NULL != m_hFileMap)  CloseHandle(m_hFileMap);
        }
    }
}
D3DSharedMem::~D3DSharedMem(void)
{
    if (NULL != m_pMem)  UnmapViewOfFile((LPVOID) m_pMem);
    if (NULL != m_hFileMap)  CloseHandle(m_hFileMap);
}

//------------------------------------------------------------------------
//
// Called upon loading/unloading DLL
//
//------------------------------------------------------------------------
BOOL WINAPI
DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return TRUE;
}
#endif //__D3D_NULL_REF

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\drv\drawprim.cpp ===
//----------------------------------------------------------------------------
//
// drawprim.cpp
//
// Implements DrawOnePrimitive, DrawOneIndexedPrimitive and
// DrawPrimitives.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

HRESULT
RefDev::DrawOnePrimitive( GArrayT<RDVertex>& VtxArray,
                          DWORD dwStartVertex,
                          D3DPRIMITIVETYPE PrimType,
                          UINT cVertices )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    HRESULT hr;
    DWORD dwCurrVtx = dwStartVertex;

    switch( PrimType )
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cVertices; i > 0; i--)
        {
            DrawPoint(&VtxArray[dwCurrVtx++]);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cVertices / 2; i > 0; i--)
        {
            pV0 = &VtxArray[dwCurrVtx++];
            pV1 = &VtxArray[dwCurrVtx++];
            DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            pV1 = &VtxArray[dwCurrVtx];

            // Disable last-pixel setting for shared verties and store prestate.
            StoreLastPixelState(TRUE);

            // Initial pV0.
            for (i = (INT)cVertices - 1; i > 1; i--)
            {
                pV0 = pV1;
                dwCurrVtx++;
                pV1 = &VtxArray[dwCurrVtx];
                DrawLine(pV0, pV1);
            }

            // Restore last-pixel setting.
            StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = &VtxArray[++dwCurrVtx];
                DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cVertices; i > 0; i -= 3)
        {
            pV0 = &VtxArray[dwCurrVtx++];
            pV1 = &VtxArray[dwCurrVtx++];
            pV2 = &VtxArray[dwCurrVtx++];
            DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = &VtxArray[dwCurrVtx++];
            pV2 = &VtxArray[dwCurrVtx++];

            for (i = (INT)cVertices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[dwCurrVtx++];
                DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[dwCurrVtx++];
                DrawTriangle(pV0, pV2, pV1);
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[dwCurrVtx];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = &VtxArray[dwCurrVtx++];
            // Preload initial pV0.
            pV1 = &VtxArray[dwCurrVtx++];
            for (i = (INT)cVertices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[dwCurrVtx++];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFERR( "Refrast Error: Unknown or unsupported primitive type "
                "requested of DrawOnePrimitive" );
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}


HRESULT 
RefDev::DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                 int  StartVertexIndex,
                                 LPWORD puIndices,
                                 DWORD StartIndex,
                                 UINT cIndices,
                                 D3DPRIMITIVETYPE PrimType )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    HRESULT hr;
    
    LPWORD pIndices = puIndices + StartIndex;
    
    switch( PrimType )
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + (*pIndices++)];
            DrawPoint(pV0);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            StoreLastPixelState(TRUE);
            // Initial pV1.
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawLine(pV0, pV1);
            }
            // Restore last-pixel setting.
            StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = &VtxArray[StartVertexIndex + (*pIndices)];
                DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
            DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV2, pV1);
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
            // Preload initial pV0.
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFERR( "Refrast Error: Unknown or unsupported primitive type "
                "requested of DrawOneIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

// DWORD index version
HRESULT 
RefDev::DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                 int   StartVertexIndex,
                                 LPDWORD puIndices,
                                 DWORD StartIndex,
                                 UINT cIndices,
                                 D3DPRIMITIVETYPE PrimType )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    HRESULT hr;

    LPDWORD pIndices = puIndices + StartIndex;

    switch( PrimType )
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + (*pIndices++)];
            DrawPoint(pV0);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            StoreLastPixelState(TRUE);
            // Initial pV1.
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawLine(pV0, pV1);
            }
            // Restore last-pixel setting.
            StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = &VtxArray[StartVertexIndex + (*pIndices)];
                DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
            DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV2, pV1);
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
            // Preload initial pV0.
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFERR( "Refrast Error: Unknown or unsupported primitive type "
                "requested of DrawOneIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawOneEdgeFlagTriangleFan
//
// Draw one list of triangle fans. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT
RefDev::DrawOneEdgeFlagTriangleFan( GArrayT<RDVertex>& VtxArray,
                                    UINT cVertices,
                                    UINT32 dwEdgeFlags )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    HRESULT hr;
    DWORD dwCurrVtx = 0;

    pV2 = &VtxArray[dwCurrVtx++];
    pV0 = &VtxArray[dwCurrVtx++];
    pV1 = &VtxArray[dwCurrVtx++];
    WORD wFlags = 0;
    if(dwEdgeFlags & 0x2)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    if(dwEdgeFlags & 0x1)
        wFlags |= D3DTRIFLAG_EDGEENABLE3;
    if(cVertices == 3) {
        if(dwEdgeFlags & 0x4)
            wFlags |= D3DTRIFLAG_EDGEENABLE2;
        DrawTriangle(pV0, pV1, pV2, wFlags);
        return D3D_OK;
    }
    DrawTriangle(pV0, pV1, pV2, wFlags);
    UINT32 dwMask = 0x4;
    for (i = (INT)cVertices - 4; i > 0; i--)
    {
        pV0 = pV1;
        pV1 = &VtxArray[dwCurrVtx++];
        if(dwEdgeFlags & dwMask)
        {
            DrawTriangle(pV0, pV1, pV2, D3DTRIFLAG_EDGEENABLE1);
        }
        else
        {
            DrawTriangle(pV0, pV1, pV2, 0);
        }
        dwMask <<= 1;
    }
    pV0 = pV1;
    pV1 = &VtxArray[dwCurrVtx++];
    wFlags = 0;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    dwMask <<= 1;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE2;
    DrawTriangle(pV0, pV1, pV2, wFlags);

    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\drv\refif.hpp ===
//----------------------------------------------------------------------------
//
// refif.hpp
//
// Refrast front-end/rasterizer interface header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _REFIF_HPP_
#define _REFIF_HPP_

// Vertex data is aligned on 32-byte boundaries.
#define DP_VTX_ALIGN 32


// Macros to check if a pointer is valid
#if DBG
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    if ((data_ptr) == NULL)   \
    {   \
        DPFM(0, DRV, ("in %s, data pointer = NULL", (caller_name)));  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
    pCtx = (type)((data_ptr)->dwhContext); \
    if (!pCtx) \
    {   \
        DPFM(0, DRV, ("in %s, dwhContext = NULL", (caller_name)));    \
        (data_ptr)->ddrval = D3DHAL_CONTEXT_BAD;  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}
#else // !DBG
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    pCtx = (type)((data_ptr)->dwhContext); \
}
#endif // !DBG

// Validate RefDev. pRefRast should be declared before this macro
#define VALIDATE_REFRAST_CONTEXT(caller_name, data_ptr)  \
{   \
    VALIDATE_CONTEXT(caller_name, data_ptr, pRefDev, RefDev*);\
}

#define CHECK_FVF(ret, pDCtx, dwFlags)  \
{   \
    if ((ret = pDCtx->CheckFVF(dwFlags)) != DD_OK)  \
    {   \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}

DWORD __stdcall
RefRastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data);

HRESULT
RefRastLockTarget(RefDev *pRefRast);
void
RefRastUnlockTarget(RefDev *pRefRast);
HRESULT
RefRastUpdatePalettes(RefDev *pRefRast);

#endif // #ifndef _REFIF_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\drv\surfman.cpp ===
//----------------------------------------------------------------------------
//
// surfman.cpp
//
// Reference rasterizer callback functions for D3DIM.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

// Global Surface Manager, one per process
RDSurfaceManager g_SurfMgr;


///////////////////////////////////////////////////////////////////////////////
//
// Helper functions
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
CreateAppropriateSurface( LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                          DWORD*                    pHandle,
                          RDSurface**               ppSurf )
{
    HRESULT hr = S_OK;

    *ppSurf = NULL;
    *pHandle = 0;

    // Obtain the Handle
    DWORD dwHandle = pDDSLcl->lpSurfMore->dwSurfaceHandle;
    *pHandle = dwHandle;

    // Figure out if we care for this surface. Currently,
    // we care only for:
    //     1) Textures (MipMaps and Cubemaps)
    //     2) RenderTargets & DepthBuffers

    if( pDDSLcl->ddsCaps.dwCaps  & 
        (DDSCAPS_TEXTURE | DDSCAPS_ZBUFFER | DDSCAPS_3DDEVICE) )
    {
        RDSurface2D* pSurf2D = new RDSurface2D();
        if( pSurf2D == NULL )
        {
            DPFERR("New RDSurface2D failed, out of memory" );
            return DDERR_OUTOFMEMORY;
        }
        *ppSurf = pSurf2D;
    }
    else if( pDDSLcl->ddsCaps.dwCaps  & DDSCAPS_EXECUTEBUFFER )
    {
        // Strictly speaking, RDVertexBuffer should be
        // called RDLinearBuffer (it could be vertex, index or command)
        // For the time being, there is no need to distinguish between
        // the three. There is not harm in recognizing it for the Index
        // and Command buffer case. In case in the future, we do need to
        // make a distinction between Vertex and Index buffers, we need
        // to make the following tests:
        // For VB:
        //     (pDDSLcl->pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
        //             DDSCAPS2_VERTEXBUFFER))
        // For IB:
        //     (pDDSLcl->pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
        //             DDSCAPS2_INDEXBUFFER))

        RDVertexBuffer* pVB = new RDVertexBuffer();
        if( pVB == NULL )
        {
            DPFERR("New RDVertexBuffer failed, out of memory" );
            return DDERR_OUTOFMEMORY;
        }
        *ppSurf = pVB;
    }
    else
    {
        DPFM(2, DRV, ("RefCreateSurfaceEx w/o "
                      "DDSCAPS_TEXTURE/3DDEVICE/ZBUFFER Ignored"
                      "dwCaps=%08lx dwSurfaceHandle=%08lx",
                      pDDSLcl->ddsCaps.dwCaps,
                      pDDSLcl->lpSurfMore->dwSurfaceHandle));
        return hr;
    }

    if( FAILED( hr = (*ppSurf)->Initialize( pDDSLcl ) ) )
    {
        DPFERR( "Initialize failed" );
        delete (*ppSurf);
        return hr;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// RDVertexBuffer implementation
//
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
// RDVertexBuffer::Initialize
//          Initializer.
//-----------------------------------------------------------------------------
HRESULT
RDVertexBuffer::Initialize( LPDDRAWI_DDRAWSURFACE_LCL pSLcl )
{
    HRESULT hr = S_OK;

    SetInitialized();

    m_SurfType =  RR_ST_VERTEXBUFFER;

    if( pSLcl->lpGbl->dwReserved1 )
    {
        RDCREATESURFPRIVATE* pPriv =
            (RDCREATESURFPRIVATE *)pSLcl->lpGbl->dwReserved1;
        m_pBits = pPriv->pBits;
        m_cbSize = (int)pPriv->dwVBSize;
        SetRefCreated();
    }
    else
    {
        m_pBits = (LPBYTE)SURFACE_MEMORY(pSLcl);
        m_cbSize = pSLcl->lpGbl->dwLinearSize;
    }
    
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// RDSurfaceArrayNode implementation
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// RDSurfaceArrayNode::RDSurfaceArrayNode
//          Constructor.
//-----------------------------------------------------------------------------
RDSurfaceArrayNode::RDSurfaceArrayNode(LPDDRAWI_DIRECTDRAW_LCL pDDLcl)
    : RDListEntry(), m_SurfHandleArray()
{
    m_pDDLcl = pDDLcl;
}

//-----------------------------------------------------------------------------
// RDSurfaceArrayNode::~RDSurfaceArrayNode
//          Destructor.
//-----------------------------------------------------------------------------
RDSurfaceArrayNode::~RDSurfaceArrayNode()
{
    // Release all the allocated surfaces
    for( DWORD i=0; i<m_SurfHandleArray.GetSize(); i++ )
    {
        delete m_SurfHandleArray[i].m_pSurf;
    }
}

//-----------------------------------------------------------------------------
// RDSurfaceArrayNode::AddSurface
//          Adds a surface to its internal growable array if not already
//          present. ppSurf can be NULL.
//-----------------------------------------------------------------------------
HRESULT
RDSurfaceArrayNode::AddSurface( LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl,
                                RDSurface**                 ppSurf )
{
    DWORD dwHandle = 0;
    HRESULT hr = S_OK;
    RDSurface* pSurf = NULL;

    if( FAILED(hr = CreateAppropriateSurface( pDDSLcl, &dwHandle, &pSurf ) ) )
    {
        return hr;
    }


    // If it is zero, there was something wrong
    if( pSurf == NULL || dwHandle == 0 ) return E_FAIL;

    hr = m_SurfHandleArray.Grow( dwHandle );
    if (FAILED(hr))
    {
        return hr;
    }

    if( m_SurfHandleArray[dwHandle].m_pSurf )
    {
#if DBG
        _ASSERT( m_SurfHandleArray[dwHandle].m_tag,
                 "A surface is associated with this handle even though it was never initialized!" );
#endif
        delete m_SurfHandleArray[dwHandle].m_pSurf;
    }

    m_SurfHandleArray[dwHandle].m_pSurf = pSurf;
#if DBG
    m_SurfHandleArray[dwHandle].m_tag = 1;
#endif

    if( ppSurf ) *ppSurf = pSurf;
    return S_OK;
}

//-----------------------------------------------------------------------------
// RDSurfaceArrayNode::GetSurface
//          Gets a surface from its internal array if present.
//-----------------------------------------------------------------------------
RDSurface*
RDSurfaceArrayNode::GetSurface( DWORD dwHandle )
{
    if( m_SurfHandleArray.IsValidIndex( dwHandle ) )
        return m_SurfHandleArray[dwHandle].m_pSurf;
    return NULL;
}

//-----------------------------------------------------------------------------
// RDSurfaceArrayNode::RemoveSurface
//          Removed the surface with the given handle from the list.
//-----------------------------------------------------------------------------
HRESULT
RDSurfaceArrayNode::RemoveSurface( DWORD dwHandle )
{
    if( m_SurfHandleArray.IsValidIndex( dwHandle ) &&
        m_SurfHandleArray[dwHandle].m_pSurf )
    {
        delete m_SurfHandleArray[dwHandle].m_pSurf;
        m_SurfHandleArray[dwHandle].m_pSurf = NULL;
        return S_OK;
    }
    
    DPFERR( "Bad handle passed for delete" );
    return DDERR_INVALIDPARAMS;
}

///////////////////////////////////////////////////////////////////////////////
//
// RDSurfaceManager implementation
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// RDSurfaceManager::AddLclNode
//          Adds a node with the given DDLcl to the list if not already
//          present.
//-----------------------------------------------------------------------------
RDSurfaceArrayNode*
RDSurfaceManager::AddLclNode( LPDDRAWI_DIRECTDRAW_LCL pDDLcl )
{
    RDSurfaceArrayNode* pCurrNode = m_pFirstNode;

    while( pCurrNode )
    {
        if( pDDLcl == pCurrNode->m_pDDLcl ) return pCurrNode;
        pCurrNode = pCurrNode->m_pNext;
    }

    // This means that we didnt find an existing node, create a
    // new one.
    RDSurfaceArrayNode* pTmpNode = m_pFirstNode;
    m_pFirstNode = new RDSurfaceArrayNode( pDDLcl );
    if( m_pFirstNode == NULL )
    {
        DPFERR("New Failed allocating a new RDSurfaceArrayNode\n");
        m_pFirstNode = pTmpNode;
                return NULL;
    }
    m_pFirstNode->m_pNext = pTmpNode;

    return m_pFirstNode;
}

//-----------------------------------------------------------------------------
// RDSurfaceManager::GetLclNode
//          Gets a node with the given DDLcl from the list if present.
//-----------------------------------------------------------------------------
RDSurfaceArrayNode*
RDSurfaceManager::GetLclNode( LPDDRAWI_DIRECTDRAW_LCL pDDLcl )
{
    RDSurfaceArrayNode* pCurrNode = m_pFirstNode;

    while( pCurrNode )
    {
        if( pDDLcl == pCurrNode->m_pDDLcl ) break;
        pCurrNode = pCurrNode->m_pNext;
    }

    return pCurrNode;
}

//-----------------------------------------------------------------------------
// RDSurfaceManager::AddSurfToList
//          Adds a surface to the node with a matching DDLcl. If the node
//          is not present it is created. The ppSurf param can be NULL.
//-----------------------------------------------------------------------------
HRESULT
RDSurfaceManager::AddSurfToList( LPDDRAWI_DIRECTDRAW_LCL     pDDLcl,
                                 LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl,
                                 RDSurface**                 ppSurf )
{
    HRESULT hr = S_OK;
    RDSurface* pSurf = NULL;

    RDSurfaceArrayNode* pCurrNode = AddLclNode( pDDLcl );
    if( pCurrNode )
    {
        hr = pCurrNode->AddSurface( pDDSLcl, &pSurf );
        if( ppSurf ) *ppSurf = pSurf;
        return hr;
    }

    return DDERR_OUTOFMEMORY;
}

//-----------------------------------------------------------------------------
// RDSurfaceManager::GetSurfFromList
//          Gets a surface with the matching handle from the node with a
//          matching DDLcl, if the node and the surface is present.
//-----------------------------------------------------------------------------
RDSurface*
RDSurfaceManager::GetSurfFromList( LPDDRAWI_DIRECTDRAW_LCL   pDDLcl,
                                   DWORD                     dwHandle )
{
    RDSurfaceArrayNode* pCurrNode = GetLclNode( pDDLcl );
    if( pCurrNode ) return pCurrNode->GetSurface( dwHandle );
    return NULL;
}

//-----------------------------------------------------------------------------
// RDSurfaceManager::RemoveSurfFromList
//          Deletes the surface handle.
//-----------------------------------------------------------------------------
HRESULT
RDSurfaceManager::RemoveSurfFromList( LPDDRAWI_DIRECTDRAW_LCL   pDDLcl,
                                      DWORD                     dwHandle )
{
    RDSurfaceArrayNode* pCurrNode = GetLclNode( pDDLcl );
    if( pCurrNode ) return pCurrNode->RemoveSurface( dwHandle );
    DPFERR("The DrawLcl is unrecognized\n");
    return DDERR_INVALIDPARAMS;
}

HRESULT
RDSurfaceManager::RemoveSurfFromList( LPDDRAWI_DIRECTDRAW_LCL   pDDLcl,
                                      LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl )
{
    RDSurfaceArrayNode* pCurrNode = GetLclNode( pDDLcl );
    if( pCurrNode ) return pCurrNode->RemoveSurface( 
        pDDSLcl->lpSurfMore->dwSurfaceHandle );
    DPFERR("The DrawLcl is unrecognized\n");
    return DDERR_INVALIDPARAMS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\drv\sources.inc ===
TARGETNAME=refdrv
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES =             \
    ..\refif.cpp      \
    ..\dprim2.cpp     \
    ..\primfns.cpp    \
    ..\drawprim.cpp   \
    ..\surfman.cpp    \
    ..\rralloc.cpp


PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\drv\rralloc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rrmem.cpp
//
// Direct3D Reference Implementation - Memory functions
//
//
//
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////
//
// RDAlloc method implementation
//
///////////////////////////////////////////////////////////////////////////////
void *
RDAlloc::operator new(size_t s)
{
    void* pMem = MEMALLOC( s );
    if (pMem == NULL)
    {
        DPFERR( "Malloc failed\n" );
    }
    return pMem;
}

void 
RDAlloc::operator delete(void* p, size_t)
{
    MEMFREE( p );
}


//////////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\drv\primfns.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// primfns.cpp
//
// Copyright (C) Microsoft Corporation, 1998.
//
//////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// Wrap functions
//
//----------------------------------------------------------------------------
HRESULT WrapDp2SetViewport( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetViewport(pCmd);
}

HRESULT WrapDp2SetWRange  ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetWRange(pCmd);
}

HRESULT WrapDp2SetZRange  ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetZRange(pCmd);
}

HRESULT WrapDp2SetRenderStates( RefDev *pRefDev,
                            DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                            LPDWORD lpdwRuntimeRStates )
{
    return pRefDev->Dp2SetRenderStates(dwFvf, pCmd, lpdwRuntimeRStates);
}

HRESULT WrapDp2SetTextureStageState( RefDev *pRefDev, DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetTextureStageState(dwFvf, pCmd);
}

HRESULT WrapDp2SetMaterial ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetMaterial(pCmd);
}

HRESULT WrapDp2SetLight( RefDev *pRefDev,
                         LPD3DHAL_DP2COMMAND pCmd,
                         LPDWORD pdwStride )
{
    return pRefDev->Dp2SetLight(pCmd, pdwStride);
}

HRESULT WrapDp2CreateLight ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2CreateLight(pCmd);
}

HRESULT WrapDp2SetTransform( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetTransform(pCmd);
}

HRESULT WrapDp2MultiplyTransform( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2MultiplyTransform(pCmd);
}

HRESULT WrapDp2SetExtention( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetExtention(pCmd);
}

HRESULT WrapDp2SetClipPlane( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetClipPlane(pCmd);
}

HRESULT
WrapDp2SetVertexShader( RefDev *pRefDev,
                        LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetVertexShader( pCmd );
}

HRESULT
WrapDp2SetVertexShaderConsts( RefDev *pRefDev,
                              DWORD StartReg, DWORD dwCount, LPDWORD pData )
{
    return pRefDev->Dp2SetVertexShaderConsts( StartReg, dwCount, pData );
}

HRESULT
WrapDp2SetPixelShader( RefDev *pRefDev,
                        LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetPixelShader( pCmd );
}

HRESULT
WrapDp2SetPixelShaderConsts( RefDev *pRefDev,
                              DWORD StartReg, DWORD dwCount, LPDWORD pData )
{
    return pRefDev->Dp2SetPixelShaderConsts( StartReg, dwCount, pData );
}

HRESULT
WrapDp2SetStreamSource( RefDev *pRefDev,
                        LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetStreamSource( pCmd );
}

HRESULT
WrapDp2SetIndices( RefDev *pRefDev,
                   LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetIndices( pCmd );
}


HRESULT WrapDp2RecViewport( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecViewport(pCmd);
}

HRESULT WrapDp2RecWRange  ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecWRange(pCmd);
}

HRESULT WrapDp2RecZRange  ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecZRange(pCmd);
}

HRESULT WrapDp2RecRenderStates( RefDev *pRefDev,
                            DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                            LPDWORD lpdwRuntimeRStates )
{
    return pRefDev->Dp2RecRenderStates(dwFvf, pCmd, lpdwRuntimeRStates);
}

HRESULT WrapDp2RecTextureStageState( RefDev *pRefDev, DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecTextureStageState(dwFvf, pCmd);
}

HRESULT WrapDp2RecMaterial ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecMaterial(pCmd);
}

HRESULT WrapDp2RecSetLight ( RefDev *pRefDev,
                             LPD3DHAL_DP2COMMAND pCmd,
                             LPDWORD pdwStride)
{
    return pRefDev->Dp2RecSetLight(pCmd, pdwStride);
}

HRESULT WrapDp2RecCreateLight( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecCreateLight(pCmd);
}

HRESULT WrapDp2RecTransform( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecTransform(pCmd);
}

HRESULT WrapDp2RecExtention( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecExtention(pCmd);
}

HRESULT WrapDp2RecClipPlane( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecClipPlane(pCmd);
}

HRESULT
WrapDp2RecSetVertexShader( RefDev* pRefDev,
                           LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecSetVertexShader( pCmd );
}

HRESULT
WrapDp2RecSetVertexShaderConsts( RefDev* pRefDev,
                                 DWORD StartReg, DWORD dwCount, LPDWORD pData )
{
    return pRefDev->Dp2RecSetVertexShaderConsts( StartReg, dwCount, pData );
}

HRESULT
WrapDp2RecSetPixelShader( RefDev* pRefDev,
                           LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecSetPixelShader( pCmd );
}

HRESULT
WrapDp2RecSetPixelShaderConsts( RefDev* pRefDev,
                                 DWORD StartReg, DWORD dwCount, LPDWORD pData )
{
    return pRefDev->Dp2RecSetPixelShaderConsts( StartReg, dwCount, pData );
}

HRESULT
WrapDp2RecSetStreamSource( RefDev* pRefDev,
                           LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecSetStreamSource( pCmd );
}

HRESULT
WrapDp2RecSetIndices( RefDev* pRefDev,
                      LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecSetIndices( pCmd );
}


static RD_STATESETFUNCTIONTBL StateRecFunctions =
{
    sizeof(RD_STATESETFUNCTIONTBL),
    WrapDp2RecRenderStates,
    WrapDp2RecTextureStageState,
    WrapDp2RecViewport,
    WrapDp2RecWRange,
    WrapDp2RecMaterial,
    WrapDp2RecZRange,
    WrapDp2RecSetLight,
    WrapDp2RecCreateLight,
    WrapDp2RecTransform,
    WrapDp2RecExtention,
    WrapDp2RecClipPlane,
    WrapDp2RecSetVertexShader,
    WrapDp2RecSetVertexShaderConsts,
    WrapDp2RecSetPixelShader,
    WrapDp2RecSetPixelShaderConsts,
    WrapDp2RecSetStreamSource,
    WrapDp2RecSetIndices
};

static RD_STATESETFUNCTIONTBL StateSetFunctions =
{
    sizeof(RD_STATESETFUNCTIONTBL),
    WrapDp2SetRenderStates,
    WrapDp2SetTextureStageState,
    WrapDp2SetViewport,
    WrapDp2SetWRange,
    WrapDp2SetMaterial,
    WrapDp2SetZRange,
    WrapDp2SetLight,
    WrapDp2CreateLight,
    WrapDp2SetTransform,
    WrapDp2SetExtention,
    WrapDp2SetClipPlane,
    WrapDp2SetVertexShader,
    WrapDp2SetVertexShaderConsts,
    WrapDp2SetPixelShader,
    WrapDp2SetPixelShaderConsts,
    WrapDp2SetStreamSource,
    WrapDp2SetIndices,
    WrapDp2MultiplyTransform
};

//----------------------------------------------------------------------------
//
// RefDev methods
//
//----------------------------------------------------------------------------
void
RefDev::StoreLastPixelState(BOOL bStore)
{
    if( bStore )
    {
        m_LastState = GetRS()[D3DRENDERSTATE_LASTPIXEL];
        SetRenderState(D3DRENDERSTATE_LASTPIXEL, 0);
    }
    else
    {
        SetRenderState(D3DRENDERSTATE_LASTPIXEL, m_LastState);
    }
}

void
RefDev::SetRecStateFunctions(void)
{
    pStateSetFuncTbl = &StateRecFunctions;
}

void
RefDev::SetSetStateFunctions(void)
{
    pStateSetFuncTbl = &StateSetFunctions;
}

HRESULT
RefDev::Dp2SetRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                           LPDWORD lpdwRuntimeRStates )
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr = D3D_OK;

    D3DHAL_DP2RENDERSTATE *pRenderState =
                                    (D3DHAL_DP2RENDERSTATE *)(pCmd + 1);

    for (i = 0; i < (INT)wStateCount; i++, pRenderState++)
    {
        UINT32 type = (UINT32) pRenderState->RenderState;

        // Check for overrides
        if( IS_OVERRIDE(type) )
        {
            UINT32 override = GET_OVERRIDE(type);

            if( pRenderState->dwState )
                STATESET_SET(m_renderstate_override, override);
            else
                STATESET_CLEAR(m_renderstate_override, override);
            continue;
        }

        if( STATESET_ISSET(m_renderstate_override, type) )
            continue;


        // Set the runtime copy (if necessary)
        if( NULL != lpdwRuntimeRStates )
        {
            lpdwRuntimeRStates[pRenderState->RenderState] = pRenderState->dwState;
        }

        // Set the state
        SetRenderState(pRenderState->RenderState, pRenderState->dwState);
    }

    return hr;
}

HRESULT
RefDev::Dp2SetTextureStageState( DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd )
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr = D3D_OK;

    D3DHAL_DP2TEXTURESTAGESTATE  *pTexStageState =
                                    (D3DHAL_DP2TEXTURESTAGESTATE  *)(pCmd + 1);

    for (i = 0; i < (INT)wStateCount; i++, pTexStageState++)
    {
        SetTextureStageState( pTexStageState->wStage, pTexStageState->TSState,
                              pTexStageState->dwValue );
    }

    return hr;
}

HRESULT
RefDev::Dp2SetViewport(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2VIEWPORTINFO pVpt;

    // Keep only the last viewport notification
    pVpt = (D3DHAL_DP2VIEWPORTINFO *)(pCmd + 1) + (pCmd->wStateCount - 1);

    // Update T&L viewport state
    D3DVIEWPORT7& vp = m_Clipper.m_Viewport;

    vp.dwX = pVpt->dwX;
    vp.dwY = pVpt->dwY;
    vp.dwWidth = pVpt->dwWidth;
    vp.dwHeight = pVpt->dwHeight;
    m_Clipper.m_dwFlags |= RefClipper::RCLIP_DIRTY_VIEWRECT;

    // get render target; update it; put it back
    RDRenderTarget *pRendTgt = this->GetRenderTarget();
    pRendTgt->m_Clip.left   = pVpt->dwX;
    pRendTgt->m_Clip.top    = pVpt->dwY;
    pRendTgt->m_Clip.right  = pVpt->dwX + pVpt->dwWidth - 1;
    pRendTgt->m_Clip.bottom = pVpt->dwY + pVpt->dwHeight - 1;
    SetRenderTarget( pRendTgt );
    return D3D_OK;
}

HRESULT
RefDev::Dp2SetWRange(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2WINFO pWInfo;

    // Keep only the last viewport notification
    pWInfo = (D3DHAL_DP2WINFO *)(pCmd + 1) + (pCmd->wStateCount - 1);

    // get render target; update it; put it back
    RDRenderTarget *pRendTgt = this->GetRenderTarget();
    pRendTgt->m_fWRange[0]  = pWInfo->dvWNear;
    pRendTgt->m_fWRange[1]  = pWInfo->dvWFar;
    this->SetRenderTarget( pRendTgt );
    return D3D_OK;
}

HRESULT
RefDev::Dp2SetZRange(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2ZRANGE pZRange;

    // Keep only the last viewport notification
    pZRange = (D3DHAL_DP2ZRANGE *)(pCmd + 1) + (pCmd->wStateCount - 1);

    // Update T&L viewport state
    D3DVIEWPORT7& vp = m_Clipper.m_Viewport;

    vp.dvMinZ = pZRange->dvMinZ;
    vp.dvMaxZ = pZRange->dvMaxZ;
    m_Clipper.m_dwFlags |= RefClipper::RCLIP_DIRTY_ZRANGE;

    return D3D_OK;
}


HRESULT
RefDev::Dp2SetMaterial(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2SETMATERIAL pSetMat;

    // Keep only the last material notification
    pSetMat = (D3DHAL_DP2SETMATERIAL *)(pCmd + 1) + (pCmd->wStateCount - 1);

    m_RefVP.m_Material = *(D3DMATERIAL7 *)pSetMat;
    m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_MATERIAL;

    return D3D_OK;
}


HRESULT
RefDev::Dp2CreateLight(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumCreateLight = pCmd->wStateCount;
    LPD3DHAL_DP2CREATELIGHT pCreateLight = (LPD3DHAL_DP2CREATELIGHT)(pCmd + 1);
    HRESULT hr = D3D_OK;

    for (int i = 0; i < wNumCreateLight; i++, pCreateLight++)
    {
        HR_RET(m_RefVP.GrowLightArray( pCreateLight->dwIndex ) );
    }

    return hr;
}

HRESULT
RefDev::Dp2SetLight(LPD3DHAL_DP2COMMAND pCmd,
                                 LPDWORD pdwStride)
{

    HRESULT hr = D3D_OK;
    WORD wNumSetLight = pCmd->wStateCount;
    _ASSERT( pdwStride != NULL, "pdwStride is Null" );
    *pdwStride = sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2SETLIGHT pSetLight = (LPD3DHAL_DP2SETLIGHT)(pCmd + 1);
    D3DLIGHT7 *pLightData = NULL;

    for (int i = 0; i < wNumSetLight; i++)
    {
        DWORD dwStride = sizeof(D3DHAL_DP2SETLIGHT);
        DWORD dwIndex = pSetLight->dwIndex;

        // Assert that create was not called here
        _ASSERTf( m_RefVP.m_LightArray.IsValidIndex( dwIndex ),
                ( "Create was not called prior to the SetLight for light %d",
                 dwIndex ));

        switch (pSetLight->dwDataType)
        {
        case D3DHAL_SETLIGHT_ENABLE:
            m_RefVP.LightEnable( dwIndex, TRUE );
            break;
        case D3DHAL_SETLIGHT_DISABLE:
            m_RefVP.LightEnable( dwIndex, FALSE );
            break;
        case D3DHAL_SETLIGHT_DATA:
            pLightData = (D3DLIGHT7 *)((LPBYTE)pSetLight + dwStride);
            dwStride += sizeof(D3DLIGHT7);
            HR_RET(m_RefVP.SetLightData( pSetLight->dwIndex, pLightData));
            break;
        default:
            DPFERR( "Unknown SetLight command" );
            hr = DDERR_INVALIDPARAMS;
        }

        *pdwStride += dwStride;
        // Update the command buffer pointer
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight +
                                           dwStride);
    }

    return hr;
}

static D3DMATRIX matIdent =
{
    1.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 1.0f
};

HRESULT
RefDev::Dp2SetTransform(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumXfrms = pCmd->wStateCount;
    D3DHAL_DP2SETTRANSFORM *pSetXfrm = (D3DHAL_DP2SETTRANSFORM*)(pCmd + 1);

    for (int i = 0; i < (int) wNumXfrms; i++, pSetXfrm++)
    {
        D3DMATRIX* pMat = &pSetXfrm->matrix;
        DWORD xfrmType = (DWORD)pSetXfrm->xfrmType;
        if ((DWORD)xfrmType >= RD_WORLDMATRIXBASE &&
            (DWORD)xfrmType < (RD_WORLDMATRIXBASE + RD_MAX_WORLD_MATRICES))
        {
            // World matrix is set
            UINT index = (DWORD)xfrmType - RD_WORLDMATRIXBASE;
            memcpy(&(m_RefVP.m_xfmWorld[index]), pMat, sizeof(D3DMATRIX));
            switch (index)
            {
            case 0:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLDXFM;
                break;
            case 1:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD1XFM;
                break;
            case 2:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD2XFM;
                break;
            case 3:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD3XFM;
                break;
            default:
                // m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLDNXFM;
                break;
            }
        }
        else
        {
            switch( xfrmType )
            {
            case D3DTRANSFORMSTATE_WORLD_DX7:
                memcpy(&(m_RefVP.m_xfmWorld[0]), pMat, sizeof(D3DMATRIX));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLDXFM;
                break;
            case D3DTRANSFORMSTATE_VIEW:
                memcpy(&m_RefVP.m_xfmView, pMat, sizeof(D3DMATRIX));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_VIEWXFM;
                break;
            case D3DTRANSFORMSTATE_PROJECTION:
                memcpy(&m_RefVP.m_xfmProj, pMat, sizeof(D3DMATRIX));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_PROJXFM;
                break;
            case D3DTRANSFORMSTATE_WORLD1_DX7:
                memcpy(&(m_RefVP.m_xfmWorld[1]), pMat, sizeof(D3DMATRIX));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD1XFM;
                break;
            case D3DTRANSFORMSTATE_WORLD2_DX7:
                memcpy(&(m_RefVP.m_xfmWorld[2]), pMat, sizeof(D3DMATRIX));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD2XFM;
                break;
            case D3DTRANSFORMSTATE_WORLD3_DX7:
                memcpy(&(m_RefVP.m_xfmWorld[3]), pMat, sizeof(D3DMATRIX));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD3XFM;
                break;
            case D3DTRANSFORMSTATE_TEXTURE0:
            case D3DTRANSFORMSTATE_TEXTURE1:
            case D3DTRANSFORMSTATE_TEXTURE2:
            case D3DTRANSFORMSTATE_TEXTURE3:
            case D3DTRANSFORMSTATE_TEXTURE4:
            case D3DTRANSFORMSTATE_TEXTURE5:
            case D3DTRANSFORMSTATE_TEXTURE6:
            case D3DTRANSFORMSTATE_TEXTURE7:
                memcpy(
                    &(m_RefVP.m_xfmTex[xfrmType - D3DTRANSFORMSTATE_TEXTURE0]),
                    pMat, sizeof(D3DMATRIX)
                    );
                break;
            default:
                DPFERR( "Ignoring unknown transform type" );
            }
        }
    }

    return D3D_OK;
}

extern void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b);

HRESULT
RefDev::Dp2MultiplyTransform(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumXfrms = pCmd->wStateCount;
    D3DHAL_DP2MULTIPLYTRANSFORM *pSetXfrm = (D3DHAL_DP2MULTIPLYTRANSFORM*)(pCmd + 1);

    for (int i = 0; i < (int) wNumXfrms; i++, pSetXfrm++)
    {
        D3DMATRIX* pMat = &pSetXfrm->matrix;
        DWORD xfrmType = (DWORD)pSetXfrm->xfrmType;
        if ((DWORD)xfrmType >= RD_WORLDMATRIXBASE &&
            (DWORD)xfrmType < (RD_WORLDMATRIXBASE + RD_MAX_WORLD_MATRICES))
        {
            // World matrix is set
            UINT index = (DWORD)xfrmType - RD_WORLDMATRIXBASE;
            MatrixProduct(&(m_RefVP.m_xfmWorld[index]), pMat,
                          &(m_RefVP.m_xfmWorld[index]));
            switch (index)
            {
            case 0:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLDXFM;
                break;
            case 1:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD1XFM;
                break;
            case 2:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD2XFM;
                break;
            case 3:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD3XFM;
                break;
            default:
                // m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLDNXFM;
                break;
            }
        }
        else
        {
            switch( xfrmType )
            {
            case D3DTRANSFORMSTATE_WORLD_DX7:
                MatrixProduct(&(m_RefVP.m_xfmWorld[0]), pMat,
                              &(m_RefVP.m_xfmWorld[0]));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLDXFM;
                break;
            case D3DTRANSFORMSTATE_VIEW:
                MatrixProduct(&m_RefVP.m_xfmView, pMat, &m_RefVP.m_xfmView);
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_VIEWXFM;
                break;
            case D3DTRANSFORMSTATE_PROJECTION:
                MatrixProduct(&m_RefVP.m_xfmProj, pMat, &m_RefVP.m_xfmProj);
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_PROJXFM;
                break;
            case D3DTRANSFORMSTATE_WORLD1_DX7:
                MatrixProduct(&(m_RefVP.m_xfmWorld[1]), pMat,
                              &(m_RefVP.m_xfmWorld[1]));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD1XFM;
                break;
            case D3DTRANSFORMSTATE_WORLD2_DX7:
                MatrixProduct(&(m_RefVP.m_xfmWorld[2]), pMat,
                              &(m_RefVP.m_xfmWorld[2]));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD2XFM;
                break;
            case D3DTRANSFORMSTATE_WORLD3_DX7:
                MatrixProduct(&(m_RefVP.m_xfmWorld[3]), pMat,
                              &(m_RefVP.m_xfmWorld[3]));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD3XFM;
                break;
            case D3DTRANSFORMSTATE_TEXTURE0:
            case D3DTRANSFORMSTATE_TEXTURE1:
            case D3DTRANSFORMSTATE_TEXTURE2:
            case D3DTRANSFORMSTATE_TEXTURE3:
            case D3DTRANSFORMSTATE_TEXTURE4:
            case D3DTRANSFORMSTATE_TEXTURE5:
            case D3DTRANSFORMSTATE_TEXTURE6:
            case D3DTRANSFORMSTATE_TEXTURE7:
                MatrixProduct(
                    &(m_RefVP.m_xfmTex[xfrmType - D3DTRANSFORMSTATE_TEXTURE0]),
                    pMat,
                    &(m_RefVP.m_xfmTex[xfrmType - D3DTRANSFORMSTATE_TEXTURE0])
                    );
                break;
            default:
                DPFERR( "Ignoring unknown transform type" );
            }
        }
    }

    return D3D_OK;
}

HRESULT
RefDev::Dp2SetClipPlane(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumClipPlanes = pCmd->wStateCount;
    LPD3DHAL_DP2SETCLIPPLANE pSetClipPlane =
        (LPD3DHAL_DP2SETCLIPPLANE)(pCmd + 1);

    for (int i = 0; i < (int) wNumClipPlanes; i++, pSetClipPlane++)
    {
        _ASSERTf( pSetClipPlane->dwIndex < RD_MAX_USER_CLIPPLANES,
                 ("Refrast does not support %d clip planes",
                  pSetClipPlane->dwIndex ) );

        memcpy( &(m_Clipper.m_userClipPlanes[pSetClipPlane->dwIndex]),
                pSetClipPlane->plane, sizeof(RDVECTOR4) );
    }
    return D3D_OK;
}

HRESULT
RefDev::Dp2SetExtention(LPD3DHAL_DP2COMMAND pCmd)
{
    return D3D_OK;
}

HRESULT
RefDev::Dp2RecRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                           LPDWORD lpdwRuntimeRStates )
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2RENDERSTATE);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
RefDev::Dp2RecTextureStageState(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd )
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2TEXTURESTAGESTATE);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
RefDev::Dp2RecViewport(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2VIEWPORTINFO));
}

HRESULT
RefDev::Dp2RecWRange(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2WINFO));
}

HRESULT
RefDev::Dp2RecZRange(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2ZRANGE));
}


HRESULT
RefDev::Dp2RecMaterial(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2SETMATERIAL));
}


HRESULT
RefDev::Dp2RecCreateLight(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2CREATELIGHT);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
RefDev::Dp2RecSetLight(LPD3DHAL_DP2COMMAND pCmd,
                                    LPDWORD pdwStride)
{
    WORD wNumSetLight = pCmd->wStateCount;
    _ASSERT(pdwStride != NULL, "pdwStride is NULL" );
    *pdwStride = sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2SETLIGHT pSetLight = (LPD3DHAL_DP2SETLIGHT)(pCmd + 1);

    for (int i = 0; i < wNumSetLight; i++)
    {
        DWORD dwStride = sizeof(D3DHAL_DP2SETLIGHT);

        switch (pSetLight->dwDataType)
        {
        case D3DHAL_SETLIGHT_ENABLE:
            break;
        case D3DHAL_SETLIGHT_DISABLE:
            break;
        case D3DHAL_SETLIGHT_DATA:
            dwStride += sizeof(D3DLIGHT7);
            break;
        }

        *pdwStride += dwStride;
        // Update the command buffer pointer
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight +
                                           dwStride);
    }

    return RecordStates((PUINT8)pCmd, *pdwStride);
}


HRESULT
RefDev::Dp2RecTransform(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2SETTRANSFORM);

    return RecordStates((PUINT8)pCmd, dwSize);
}


HRESULT
RefDev::Dp2RecExtention(LPD3DHAL_DP2COMMAND pCmd)
{
    return D3D_OK;
}

HRESULT
RefDev::Dp2RecClipPlane(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2SETCLIPPLANE);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
RefDev::Dp2RecSetVertexShader(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2VERTEXSHADER);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
RefDev::Dp2RecSetVertexShaderConsts( DWORD StartReg,
                                                  DWORD dwCount,
                                                  LPDWORD pData )
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) +
        dwCount*4*sizeof(float);

    LPBYTE pBytes = new BYTE[dwSize];
    if( pBytes == NULL ) return DDERR_OUTOFMEMORY;
    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)pBytes;
    LPD3DHAL_DP2SETVERTEXSHADERCONST pSVC =
        (LPD3DHAL_DP2SETVERTEXSHADERCONST)(pCmd + 1);
    LPDWORD pStuff = (LPDWORD)(pSVC + 1);

    // Set up pCmd
    pCmd->bCommand = D3DDP2OP_SETVERTEXSHADERCONST;
    pCmd->wStateCount = 1;

    // Set up pSVC
    pSVC->dwRegister = StartReg;
    pSVC->dwCount = dwCount;

    // Copy the data
    memcpy( pStuff, pData, dwCount*4*sizeof(float));

    HRESULT hr = RecordStates(pBytes, dwSize);
    delete [] pBytes;
    return hr;
}

HRESULT
RefDev::Dp2RecSetPixelShader(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2PIXELSHADER);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
RefDev::Dp2RecSetPixelShaderConsts( DWORD StartReg,
                                                  DWORD dwCount,
                                                  LPDWORD pData )
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETPIXELSHADERCONST) +
        dwCount*4*sizeof(float);

    LPBYTE pBytes = new BYTE[dwSize];
    if( pBytes == NULL ) return DDERR_OUTOFMEMORY;
    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)pBytes;
    LPD3DHAL_DP2SETPIXELSHADERCONST pSVC =
        (LPD3DHAL_DP2SETPIXELSHADERCONST)(pCmd + 1);
    LPDWORD pStuff = (LPDWORD)(pSVC + 1);

    // Set up pCmd
    pCmd->bCommand = D3DDP2OP_SETPIXELSHADERCONST;
    pCmd->wStateCount = 1;

    // Set up pSVC
    pSVC->dwRegister = StartReg;
    pSVC->dwCount = dwCount;

    // Copy the data
    memcpy( pStuff, pData, dwCount*4*sizeof(float));

    HRESULT hr = RecordStates(pBytes, dwSize);
    delete [] pBytes;
    return hr;
}

HRESULT
RefDev::Dp2RecSetStreamSource(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2SETSTREAMSOURCE);

    return RecordStates((PUINT8)pCmd, dwSize);
}


HRESULT
RefDev::Dp2RecSetIndices(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2SETINDICES);

    return RecordStates((PUINT8)pCmd, dwSize);
}


//-----------------------------------------------------------------------------
//
// RecordStates - This function copies the state data into the internal stateset
// buffer. It assumes that the current state set has already been properly set
// up in BeginStateSet().
//
//-----------------------------------------------------------------------------
HRESULT
RefDev::RecordStates(PUINT8 pData, DWORD dwSize)
{
    HRESULT ret;
    LPStateSetData pCurStateSets = m_pStateSets.CurrentItem();
    DWORD dwCurIdx = pCurStateSets->CurrentIndex();

    // Check if the buffer has enough space
    if( (ret = pCurStateSets->CheckAndGrow(dwCurIdx + dwSize,
                                            RD_STATESET_GROWDELTA)) != D3D_OK )
    {
        return ret;
    }
    // Copy the data and update the ptr.
    PUINT8 pDest = (PUINT8)&((*pCurStateSets)[dwCurIdx]);
    memcpy(pDest, pData, dwSize);
    pCurStateSets->SetCurrentIndex(dwCurIdx + dwSize);

    return D3D_OK;
}

HRESULT RefDev::RecordLastState(LPD3DHAL_DP2COMMAND pCmd,
                                             DWORD dwUnitSize)
{
    _ASSERT(pCmd->wStateCount != 0, "Number of states to record is zero" );
    if( pCmd->wStateCount == 1 )
    {
        return RecordStates((PUINT8)pCmd, sizeof(D3DHAL_DP2COMMAND) + dwUnitSize);
    }
    else
    {
        HRESULT ret;
        WORD wCount = pCmd->wStateCount;
        pCmd->wStateCount = 1;
        ret = RecordStates((PUINT8)pCmd, sizeof(D3DHAL_DP2COMMAND));
        if( ret != D3D_OK )
        {
            return ret;
        }
        ret = RecordStates((PUINT8)(pCmd + 1) + dwUnitSize * (wCount - 1),
                            dwUnitSize);
        if( ret != D3D_OK )
        {
            return ret;
        }
        pCmd->wStateCount = wCount;
        return D3D_OK;
    }
}

HRESULT
RefDev::BeginStateSet(DWORD dwHandle)
{
    HRESULT ret;

    // Grow the array if no more space left
    if( (ret = m_pStateSets.CheckAndGrow(dwHandle)) != D3D_OK )
    {
        return ret;
    }

    _ASSERT(m_pStateSets[dwHandle] == NULL, "pStateSets array is NULL" );

    // Create the new StateSet
    LPStateSetData pNewStateSet = new StateSetData;
    if( pNewStateSet == NULL )
    {
        return DDERR_OUTOFMEMORY;
    }

    m_pStateSets.SetCurrentIndex(dwHandle);
    m_pStateSets.SetCurrentItem(pNewStateSet);

    // Switch to record mode
    SetRecStateFunctions();

    return D3D_OK;
}

HRESULT
RefDev::EndStateSet(void)
{
    // Switch to execute mode
    SetSetStateFunctions();

    return D3D_OK;
}

HRESULT
RefDev::ExecuteStateSet(DWORD dwHandle)
{
    HRESULT ret;

    if( (ret = m_pStateSets.CheckRange(dwHandle)) != D3D_OK )
    {
        return ret;
    }

    LPStateSetData pStateSet = m_pStateSets[dwHandle];

    if( pStateSet == NULL )
    {
        return DDERR_INVALIDPARAMS;
    }

    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)&((*pStateSet)[0]);
    UINT_PTR CmdBoundary = (UINT_PTR)pCmd + pStateSet->CurrentIndex();

    // Loop through the data, update render states
    for (;;)
    {
        ret = DrawPrimitives2( NULL,
                               (UINT16)0,
                               (DWORD)0,
                               0,
                               &pCmd,
                               NULL );
        if( ret != D3D_OK )
        {
            return ret;
        }
        if( (UINT_PTR)pCmd >= CmdBoundary )
            break;
    }

    return D3D_OK;
}

HRESULT
RefDev::DeleteStateSet(DWORD dwHandle)
{
    HRESULT ret;

    if( (ret = m_pStateSets.CheckRange(dwHandle)) != D3D_OK )
    {
        return ret;
    }

    if( m_pStateSets[dwHandle] != NULL )
    {
        delete m_pStateSets[dwHandle];
        m_pStateSets[dwHandle] = NULL;
    }

    return D3D_OK;
}

HRESULT
RefDev::CaptureStateSet(DWORD dwHandle)
{
    HRESULT ret;

    if( (ret = m_pStateSets.CheckRange(dwHandle)) != D3D_OK )
    {
        return ret;
    }

    LPStateSetData pStateSet = m_pStateSets[dwHandle];

    if( pStateSet == NULL )
    {
        return DDERR_INVALIDPARAMS;
    }

    BYTE *p = &((*pStateSet)[0]);
    UINT_PTR pEnd = (UINT_PTR)(p + pStateSet->CurrentIndex());

    while((UINT_PTR)p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)p;
        p += sizeof(D3DHAL_DP2COMMAND);
        switch(pCmd->bCommand)
        {
        case D3DDP2OP_RENDERSTATE:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2RENDERSTATE pData = (LPD3DHAL_DP2RENDERSTATE)p;
                pData->dwState = GetRS()[pData->RenderState];
                p += sizeof(D3DHAL_DP2RENDERSTATE);
            }
            break;
        }
        case D3DDP2OP_SETLIGHT:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                p += sizeof(D3DHAL_DP2SETLIGHT);
                if( !m_RefVP.m_LightArray.IsValidIndex( pData->dwIndex ) )
                {
                    DPFERR( "The light index in capture is invalid\n" );
                    return D3DERR_INVALIDCALL;
                }
                switch (pData->dwDataType)
                {
                case D3DHAL_SETLIGHT_ENABLE:
                    if(!m_RefVP.m_LightArray[pData->dwIndex].IsEnabled())
                        pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
                    break;
                case D3DHAL_SETLIGHT_DISABLE:
                    if(m_RefVP.m_LightArray[pData->dwIndex].IsEnabled())
                        pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
                    break;
                case D3DHAL_SETLIGHT_DATA:
                    m_RefVP.m_LightArray[pData->dwIndex].GetLight((LPD3DLIGHT7)p);
                    p += sizeof(D3DLIGHT7);
                    break;
                }
            }
            break;
        }
        case D3DDP2OP_SETMATERIAL:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETMATERIAL pData = (LPD3DHAL_DP2SETMATERIAL)p;
                *pData = m_RefVP.m_Material;
                p += sizeof(D3DHAL_DP2SETMATERIAL);
            }
            break;
        }
        case D3DDP2OP_SETTRANSFORM:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETTRANSFORM pData = (LPD3DHAL_DP2SETTRANSFORM)p;
                switch(pData->xfrmType)
                {
                case D3DTRANSFORMSTATE_WORLD:
                    pData->matrix = m_RefVP.m_xfmWorld[0];
                    break;
                case D3DTRANSFORMSTATE_WORLD1:
                    pData->matrix = m_RefVP.m_xfmWorld[1];
                    break;
                case D3DTRANSFORMSTATE_WORLD2:
                    pData->matrix = m_RefVP.m_xfmWorld[2];
                    break;
                case D3DTRANSFORMSTATE_WORLD3:
                    pData->matrix = m_RefVP.m_xfmWorld[3];
                    break;
                case D3DTRANSFORMSTATE_VIEW:
                    pData->matrix = m_RefVP.m_xfmView;
                    break;
                case D3DTRANSFORMSTATE_PROJECTION:
                    pData->matrix = m_RefVP.m_xfmProj;
                    break;
                case D3DTRANSFORMSTATE_TEXTURE0:
                case D3DTRANSFORMSTATE_TEXTURE1:
                case D3DTRANSFORMSTATE_TEXTURE2:
                case D3DTRANSFORMSTATE_TEXTURE3:
                case D3DTRANSFORMSTATE_TEXTURE4:
                case D3DTRANSFORMSTATE_TEXTURE5:
                case D3DTRANSFORMSTATE_TEXTURE6:
                case D3DTRANSFORMSTATE_TEXTURE7:
                    pData->matrix = m_RefVP.m_xfmTex[pData->xfrmType - D3DTRANSFORMSTATE_TEXTURE0];
                    break;
                default:
                    if( ((DWORD)pData->xfrmType >= RD_WORLDMATRIXBASE) &&
                        ((DWORD)pData->xfrmType < (RD_WORLDMATRIXBASE +
                            RD_MAX_WORLD_MATRICES)) )
                    {
                        pData->matrix = m_RefVP.m_xfmWorld[
                            (DWORD)pData->xfrmType - RD_WORLDMATRIXBASE];
                    }
                    else
                    {
                        DPFERR( "Ignoring unknown transform type" );
                        return D3DERR_INVALIDCALL;
                    }
                    break;
                }
                p += sizeof(D3DHAL_DP2SETTRANSFORM);
            }
            break;
        }
        case D3DDP2OP_TEXTURESTAGESTATE:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                pData->dwValue = m_TextureStageState[pData->wStage].m_dwVal[pData->TSState];
                p += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
            }
            break;
        }
        case D3DDP2OP_VIEWPORTINFO:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                D3DVIEWPORT7 viewport;
                LPD3DHAL_DP2VIEWPORTINFO lpVwpData = (LPD3DHAL_DP2VIEWPORTINFO)p;
                D3DVIEWPORT7& vp = m_Clipper.m_Viewport;

                lpVwpData->dwX      = vp.dwX;
                lpVwpData->dwY      = vp.dwY;
                lpVwpData->dwWidth  = vp.dwWidth;
                lpVwpData->dwHeight = vp.dwHeight;
                p += sizeof(D3DHAL_DP2VIEWPORTINFO);
            }
            break;
        }
        case D3DDP2OP_ZRANGE:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2ZRANGE pData = (LPD3DHAL_DP2ZRANGE)p;
                D3DVIEWPORT7& vp = m_Clipper.m_Viewport;
                pData->dvMinZ = vp.dvMinZ;
                pData->dvMaxZ = vp.dvMaxZ;
                p += sizeof(D3DHAL_DP2ZRANGE);
            }
            break;
        }
        case D3DDP2OP_SETCLIPPLANE:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETCLIPPLANE pData = (LPD3DHAL_DP2SETCLIPPLANE)p;
                *((RDVECTOR4 *)pData->plane) =
                    m_Clipper.m_userClipPlanes[pData->dwIndex];
                p += sizeof(D3DHAL_DP2SETCLIPPLANE);
            }
            break;
        }
        case D3DDP2OP_SETVERTEXSHADER:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2VERTEXSHADER pData = (LPD3DHAL_DP2VERTEXSHADER)p;
                pData->dwHandle = m_CurrentVShaderHandle;
                p += sizeof(D3DHAL_DP2VERTEXSHADER);
            }
            break;
        }
        case D3DDP2OP_SETVERTEXSHADERCONST:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETVERTEXSHADERCONST pData =
                    (LPD3DHAL_DP2SETVERTEXSHADERCONST)p;
                m_RefVM.GetData( D3DSPR_CONST, pData->dwRegister,
                                 pData->dwCount, (LPVOID)(pData+1) );
                p += (sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) +
                      (pData->dwCount<<4));
            }
            break;
        }
        case D3DDP2OP_SETSTREAMSOURCE:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETSTREAMSOURCE pData =
                    (LPD3DHAL_DP2SETSTREAMSOURCE)p;
                pData->dwVBHandle = m_VStream[pData->dwStream].m_dwHandle;
                pData->dwStride = m_VStream[pData->dwStream].m_dwStride;
                p += sizeof(D3DHAL_DP2SETSTREAMSOURCE);
            }
            break;
        }
        case D3DDP2OP_SETINDICES:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETINDICES pData =
                    (LPD3DHAL_DP2SETINDICES)p;
                pData->dwVBHandle = m_IndexStream.m_dwHandle;
                pData->dwStride = m_IndexStream.m_dwStride;
                p += sizeof(D3DHAL_DP2SETINDICES);
            }
            break;
        }
        case D3DDP2OP_SETPIXELSHADER:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2PIXELSHADER pData = (LPD3DHAL_DP2PIXELSHADER)p;
                pData->dwHandle = m_CurrentPShaderHandle;
                p += sizeof(D3DHAL_DP2PIXELSHADER);
            }
            break;
        }
        case D3DDP2OP_SETPIXELSHADERCONST:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETPIXELSHADERCONST pData =
                    (LPD3DHAL_DP2SETPIXELSHADERCONST)p;
                FLOAT* pfData = (FLOAT*)(pData+1);
                for (UINT iR=pData->dwRegister; iR<pData->dwCount; iR++)
                {
                    *(pfData+0) = m_Rast.m_ConstReg[iR][0][0];
                    *(pfData+1) = m_Rast.m_ConstReg[iR][0][1];
                    *(pfData+2) = m_Rast.m_ConstReg[iR][0][2];
                    *(pfData+3) = m_Rast.m_ConstReg[iR][0][3];
                    pfData += 4;
                }
                p += (sizeof(D3DHAL_DP2SETPIXELSHADERCONST) +
                      (pData->dwCount<<4));
            }
            break;
        }
        default:
            _ASSERT(FALSE, "Ununderstood DP2 command in Capture");
        }
    }

    return D3D_OK;
}

HRESULT
RefDev::CreateStateSet(DWORD dwHandle, D3DSTATEBLOCKTYPE sbType)
{
    HRESULT hr = S_OK;

    // This DDI should be called only for drivers > DX7
    // and only for those which support TLHals.
    // It is called only when the device created is a pure-device
    // We need to add filtering code in DX9 to make the DDI emulation
    // work.
    _ASSERT( m_dwDDIType > RDDDI_DX8HAL, "This DDI should be called only"
        " for DX8TL\n" );

    // Begin a new stateset
    if( FAILED( hr = BeginStateSet( dwHandle ) ) )
    {
        DPFERR( "CreateStateSet: Begin failed\n" );
        return hr;
    }

    switch( sbType )
    {
    case D3DSBT_VERTEXSTATE:
        hr = RecordVertexState( dwHandle );
        if( FAILED( hr ) )
        {
            DPFERR( "RecordVertexState failed\n" );
        }
        break;
    case D3DSBT_PIXELSTATE:
        hr = RecordPixelState( dwHandle );
        if( FAILED( hr ) )
        {
            DPFERR( "RecordPixelState failed\n" );
        }
        break;
    case D3DSBT_ALL:
        hr = RecordAllState( dwHandle );
        if( FAILED( hr ) )
        {
            DPFERR( "RecordAllState failed\n" );
        }
        break;
    default:
        DPFERR( "Unknown StateBlock type for Creation\n" );
        hr = D3DERR_INVALIDCALL;
    }

    EndStateSet();
    return hr;
}


HRESULT
RefDev::RecordAllState( DWORD dwHandle )
{
    DWORD data_size = 0;
    DWORD i = 0;
    DWORD j = 0;
    GArrayT<BYTE> data;
    LPD3DHAL_DP2COMMAND pCmd = NULL;
    HRESULT hr = S_OK;
    
    static D3DRENDERSTATETYPE rstates[] =
    {
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRS_SOFTWAREVERTEXPROCESSING,
        D3DRS_POINTSIZE,
        D3DRS_POINTSIZE_MIN,
        D3DRS_POINTSPRITEENABLE,
        D3DRS_POINTSCALEENABLE,
        D3DRS_POINTSCALE_A,
        D3DRS_POINTSCALE_B,
        D3DRS_POINTSCALE_C,
        D3DRS_MULTISAMPLEANTIALIAS,
        D3DRS_MULTISAMPLEMASK,
        D3DRS_PATCHEDGESTYLE,
        D3DRS_PATCHSEGMENTS,
        D3DRS_POINTSIZE_MAX,
        D3DRS_INDEXEDVERTEXBLENDENABLE,
        D3DRS_COLORWRITEENABLE,
        D3DRS_TWEENFACTOR,
        D3DRS_BLENDOP,
    };
    static D3DTEXTURESTAGESTATETYPE tsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS,
        D3DTSS_ADDRESSW,
        D3DTSS_COLORARG0,
        D3DTSS_ALPHAARG0,
        D3DTSS_RESULTARG,
    };

    //
    // !!! Dont Capture vertex streams !!!
    // !!! Dont Capture index streams !!!
    // !!! Dont Capture textures !!!
    //

    //
    // Capture render-states
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2RENDERSTATE) *
        sizeof(rstates)/sizeof(D3DRENDERSTATETYPE);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount =  sizeof(rstates)/sizeof(D3DRENDERSTATETYPE);
    pCmd->bCommand        = D3DDP2OP_RENDERSTATE;
    D3DHAL_DP2RENDERSTATE* pRS = (D3DHAL_DP2RENDERSTATE*)(pCmd + 1);
    for( i = 0; i < sizeof(rstates)/sizeof(D3DRENDERSTATETYPE); ++i)
    {
        pRS->RenderState = rstates[i];
        pRS->dwState = GetRS()[rstates[i]];
        pRS++;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));


    //
    // Capture texture-stage-states
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXTURESTAGESTATE) *
        sizeof(tsstates)/sizeof(D3DTEXTURESTAGESTATETYPE)
        * D3DHAL_TSS_MAXSTAGES;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount =  sizeof(tsstates)/sizeof(D3DTEXTURESTAGESTATETYPE)
        * D3DHAL_TSS_MAXSTAGES;
    pCmd->bCommand        = D3DDP2OP_TEXTURESTAGESTATE;
    D3DHAL_DP2TEXTURESTAGESTATE* pTSS = (D3DHAL_DP2TEXTURESTAGESTATE*)(pCmd+1);
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++ )
    {
        for( DWORD j = 0; j < sizeof(tsstates)/
                 sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
        {
            pTSS->wStage = i;
            pTSS->TSState = tsstates[j];
            pTSS->dwValue = GetTSS( i )[tsstates[j]];
            pTSS++;
        }
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture viewport
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VIEWPORTINFO);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_VIEWPORTINFO;
    D3DHAL_DP2VIEWPORTINFO* pVP = (D3DHAL_DP2VIEWPORTINFO*)(pCmd+1);
    pVP->dwX = m_Clipper.m_Viewport.dwX;
    pVP->dwY = m_Clipper.m_Viewport.dwY;
    pVP->dwWidth  = m_Clipper.m_Viewport.dwWidth;
    pVP->dwHeight = m_Clipper.m_Viewport.dwHeight;
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2ZRANGE);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand       = D3DDP2OP_ZRANGE;
    D3DHAL_DP2ZRANGE* pZR = (D3DHAL_DP2ZRANGE*)(pCmd+1);
    D3DVIEWPORT7& vp = m_Clipper.m_Viewport;
    pZR->dvMinZ = m_Clipper.m_Viewport.dvMinZ; 
    pZR->dvMaxZ = m_Clipper.m_Viewport.dvMaxZ; 
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture transforms
    //
    // All the world-matrices, view, projection and the texture matrices
    // (one per stage)
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETTRANSFORM) *
        (RD_MAX_WORLD_MATRICES + D3DHAL_TSS_MAXSTAGES + 2);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = RD_MAX_WORLD_MATRICES + D3DHAL_TSS_MAXSTAGES + 2;
    pCmd->bCommand       = D3DDP2OP_SETTRANSFORM;
    D3DHAL_DP2SETTRANSFORM* pST = (D3DHAL_DP2SETTRANSFORM*)(pCmd+1);
    for( i = 0; i < RD_MAX_WORLD_MATRICES; i++ )
    {
        pST->xfrmType = (D3DTRANSFORMSTATETYPE)(RD_WORLDMATRIXBASE + i);
        pST->matrix = m_RefVP.m_xfmWorld[i];
        pST++;
    }
    // View Matrix
    pST->xfrmType = D3DTRANSFORMSTATE_VIEW;
    pST->matrix = m_RefVP.m_xfmView;
    pST++;
    // Projection Matrix
    pST->xfrmType = D3DTRANSFORMSTATE_PROJECTION;
    pST->matrix = m_RefVP.m_xfmProj;
    pST++;
    // Texture Matrices
    for( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++ )
    {
        pST->xfrmType =
            (D3DTRANSFORMSTATETYPE)(D3DTRANSFORMSTATE_TEXTURE0 + i);
        pST->matrix = m_RefVP.m_xfmTex[i];
        pST++;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));


    //
    // Capture clip-planes
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETCLIPPLANE) * RD_MAX_USER_CLIPPLANES;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = RD_MAX_USER_CLIPPLANES;
    pCmd->bCommand       = D3DDP2OP_SETCLIPPLANE;
    D3DHAL_DP2SETCLIPPLANE* pSCP = (D3DHAL_DP2SETCLIPPLANE*)(pCmd+1);
    for( i = 0; i < RD_MAX_USER_CLIPPLANES; i++ )
    {
        pSCP->dwIndex = i;
        for( j=0; j<4; j++ )
            pSCP->plane[j] = m_Clipper.m_userClipPlanes[i].v[j];
        pSCP++;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture material
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETMATERIAL);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETMATERIAL;
    D3DHAL_DP2SETMATERIAL* pSM = (D3DHAL_DP2SETMATERIAL*)(pCmd+1);
    *pSM = m_RefVP.m_Material;
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture lights
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DLIGHT7) +
        sizeof(D3DHAL_DP2SETLIGHT)*2;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 2;
    pCmd->bCommand = D3DDP2OP_SETLIGHT;
    D3DHAL_DP2SETLIGHT* pSL = (D3DHAL_DP2SETLIGHT *)(pCmd + 1);
    D3DHAL_DP2SETLIGHT* pSL2 = pSL + 1;
    pSL2->dwDataType = D3DHAL_SETLIGHT_DATA;
    for( i = 0; i < m_RefVP.m_LightArray.GetSize(); i++ )
    {
        if( m_RefVP.m_LightArray[i].IsRefered() )
        {
            pSL2->dwIndex = pSL->dwIndex = i;
            if( m_RefVP.m_LightArray[i].IsEnabled() )
            {
                pSL->dwDataType = D3DHAL_SETLIGHT_ENABLE;
            }
            else
            {
                pSL->dwDataType = D3DHAL_SETLIGHT_DISABLE;
            }

            m_RefVP.m_LightArray[i].GetLight((D3DLIGHT7*)(pSL2 + 1));
            HR_RET(RecordStates( (PUINT8)pCmd, data_size ));
        }
    }


    //
    // Capture current vertex shader
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VERTEXSHADER);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETVERTEXSHADER;
    D3DHAL_DP2VERTEXSHADER* pVS = (D3DHAL_DP2VERTEXSHADER*)(pCmd+1);
    pVS->dwHandle = m_CurrentVShaderHandle;
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture current pixel shader
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2PIXELSHADER);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETPIXELSHADER;
    D3DHAL_DP2PIXELSHADER* pPS = (D3DHAL_DP2PIXELSHADER*)(pCmd+1);
    pPS->dwHandle = m_CurrentPShaderHandle;
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture vertex shader constants
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + (RD_MAX_NUMCONSTREG << 4);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETVERTEXSHADERCONST;
    D3DHAL_DP2SETVERTEXSHADERCONST* pVSC =
        (D3DHAL_DP2SETVERTEXSHADERCONST*)(pCmd+1);
    pVSC->dwRegister = 0;
    pVSC->dwCount = RD_MAX_NUMCONSTREG;
    m_RefVM.GetData( D3DSPR_CONST, pVSC->dwRegister, pVSC->dwCount,
                     (LPVOID)(pVSC+1) );
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture pixel shader constants
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + (RDPS_MAX_NUMCONSTREG << 4);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETPIXELSHADERCONST;
    D3DHAL_DP2SETPIXELSHADERCONST* pPSC =
        (D3DHAL_DP2SETPIXELSHADERCONST*)(pCmd+1);
    pPSC->dwRegister = 0;
    pPSC->dwCount = RDPS_MAX_NUMCONSTREG;
    FLOAT* pfData = (FLOAT*)(pPSC+1);
    for (UINT iR=pPSC->dwRegister; iR<pPSC->dwCount; iR++)
    {
        *(pfData+0) = m_Rast.m_ConstReg[iR][0][0];
        *(pfData+1) = m_Rast.m_ConstReg[iR][0][1];
        *(pfData+2) = m_Rast.m_ConstReg[iR][0][2];
        *(pfData+3) = m_Rast.m_ConstReg[iR][0][3];
        pfData += 4;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));
    return hr;
}

HRESULT
RefDev::RecordVertexState( DWORD dwHandle )
{
    DWORD data_size = 0;
    DWORD i = 0;
    DWORD j = 0;
    GArrayT<BYTE> data;
    LPD3DHAL_DP2COMMAND pCmd = NULL;
    HRESULT hr = S_OK;
    
    static D3DRENDERSTATETYPE rstates[] =
    {
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRS_SOFTWAREVERTEXPROCESSING,
        D3DRS_POINTSIZE,
        D3DRS_POINTSIZE_MIN,
        D3DRS_POINTSPRITEENABLE,
        D3DRS_POINTSCALEENABLE,
        D3DRS_POINTSCALE_A,
        D3DRS_POINTSCALE_B,
        D3DRS_POINTSCALE_C,
        D3DRS_MULTISAMPLEANTIALIAS,
        D3DRS_MULTISAMPLEMASK,
        D3DRS_PATCHEDGESTYLE,
        D3DRS_PATCHSEGMENTS,
        D3DRS_POINTSIZE_MAX,
        D3DRS_INDEXEDVERTEXBLENDENABLE,
        D3DRS_TWEENFACTOR,
    };
    static D3DTEXTURESTAGESTATETYPE tsstates[] =
    {
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_TEXTURETRANSFORMFLAGS
    };

    //
    // Capture render-states
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2RENDERSTATE) *
        sizeof(rstates)/sizeof(D3DRENDERSTATETYPE);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount =  sizeof(rstates)/sizeof(D3DRENDERSTATETYPE);
    pCmd->bCommand        = D3DDP2OP_RENDERSTATE;
    D3DHAL_DP2RENDERSTATE* pRS = (D3DHAL_DP2RENDERSTATE*)(pCmd + 1);
    for( i = 0; i < sizeof(rstates)/sizeof(D3DRENDERSTATETYPE); ++i)
    {
        pRS->RenderState = rstates[i];
        pRS->dwState = GetRS()[rstates[i]];
        pRS++;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));


    //
    // Capture texture-stage-states
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TEXTURESTAGESTATE)
        * sizeof(tsstates)/sizeof(D3DTEXTURESTAGESTATETYPE)
        * D3DHAL_TSS_MAXSTAGES;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount =  sizeof(tsstates)/sizeof(D3DTEXTURESTAGESTATETYPE)
        * D3DHAL_TSS_MAXSTAGES;
    pCmd->bCommand        = D3DDP2OP_TEXTURESTAGESTATE;
    D3DHAL_DP2TEXTURESTAGESTATE* pTSS = (D3DHAL_DP2TEXTURESTAGESTATE*)(pCmd+1);
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++ )
    {
        for( DWORD j = 0; j < sizeof(tsstates)/
                 sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
        {
            pTSS->wStage = i;
            pTSS->TSState = tsstates[j];
            pTSS->dwValue = GetTSS( i )[tsstates[j]];
            pTSS++;
        }
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture lights
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DLIGHT7) +
        sizeof(D3DHAL_DP2SETLIGHT)*2;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 2;
    pCmd->bCommand = D3DDP2OP_SETLIGHT;
    D3DHAL_DP2SETLIGHT* pSL = (D3DHAL_DP2SETLIGHT *)(pCmd + 1);
    D3DHAL_DP2SETLIGHT* pSL2 = pSL + 1;
    pSL2->dwDataType = D3DHAL_SETLIGHT_DATA;
    for( i = 0; i < m_RefVP.m_LightArray.GetSize(); i++ )
    {
        if( m_RefVP.m_LightArray[i].IsRefered() )
        {
            pSL2->dwIndex = pSL->dwIndex = i;
            if( m_RefVP.m_LightArray[i].IsEnabled() )
            {
                pSL->dwDataType = D3DHAL_SETLIGHT_ENABLE;
            }
            else
            {
                pSL->dwDataType = D3DHAL_SETLIGHT_DISABLE;
            }

            m_RefVP.m_LightArray[i].GetLight((D3DLIGHT7*)(pSL2 + 1));
            HR_RET(RecordStates( (PUINT8)pCmd, data_size ));
        }
    }

    //
    // Capture vertex shader constants
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + (RD_MAX_NUMCONSTREG << 4);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETVERTEXSHADERCONST;
    D3DHAL_DP2SETVERTEXSHADERCONST* pVSC =
        (D3DHAL_DP2SETVERTEXSHADERCONST*)(pCmd+1);
    pVSC->dwRegister = 0;
    pVSC->dwCount = RD_MAX_NUMCONSTREG;
    m_RefVM.GetData( D3DSPR_CONST, pVSC->dwRegister, pVSC->dwCount,
                     (LPVOID)(pVSC+1) );
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture current vertex shader
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VERTEXSHADER);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETVERTEXSHADER;
    D3DHAL_DP2VERTEXSHADER* pVS =
        (D3DHAL_DP2VERTEXSHADER*)(pCmd+1);
    pVS->dwHandle = m_CurrentVShaderHandle;
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    return hr;
}

HRESULT
RefDev::RecordPixelState( DWORD dwHandle )
{
    DWORD data_size = 0;
    DWORD i = 0;
    DWORD j = 0;
    GArrayT<BYTE> data;
    LPD3DHAL_DP2COMMAND pCmd = NULL;
    HRESULT hr = S_OK;

    static D3DRENDERSTATETYPE rstates[] =
    {
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRS_COLORWRITEENABLE,
        D3DRS_BLENDOP,
    };
    static D3DTEXTURESTAGESTATETYPE tsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS,
        D3DTSS_ADDRESSW,
        D3DTSS_COLORARG0,
        D3DTSS_ALPHAARG0,
        D3DTSS_RESULTARG,
    };

    //
    // Capture render-states
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2RENDERSTATE) *
        sizeof(rstates)/sizeof(D3DRENDERSTATETYPE);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount =  sizeof(rstates)/sizeof(D3DRENDERSTATETYPE);
    pCmd->bCommand        = D3DDP2OP_RENDERSTATE;
    D3DHAL_DP2RENDERSTATE* pRS = (D3DHAL_DP2RENDERSTATE*)(pCmd + 1);
    for( i = 0; i < sizeof(rstates)/sizeof(D3DRENDERSTATETYPE); ++i)
    {
        pRS->RenderState = rstates[i];
        pRS->dwState = GetRS()[rstates[i]];
        pRS++;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));


    //
    // Capture texture-stage-states
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TEXTURESTAGESTATE)
        * sizeof(tsstates)/sizeof(D3DTEXTURESTAGESTATETYPE)
        * D3DHAL_TSS_MAXSTAGES;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount =  sizeof(tsstates)/sizeof(D3DTEXTURESTAGESTATETYPE)
        * D3DHAL_TSS_MAXSTAGES;
    pCmd->bCommand        = D3DDP2OP_TEXTURESTAGESTATE;
    D3DHAL_DP2TEXTURESTAGESTATE* pTSS = (D3DHAL_DP2TEXTURESTAGESTATE*)(pCmd+1);
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++ )
    {
        for( DWORD j = 0; j < sizeof(tsstates)/
                 sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
        {
            pTSS->wStage = i;
            pTSS->TSState = tsstates[j];
            pTSS->dwValue = GetTSS( i )[tsstates[j]];
            pTSS++;
        }
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture pixel shader constants
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + (RDPS_MAX_NUMCONSTREG << 4);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETPIXELSHADERCONST;
    D3DHAL_DP2SETPIXELSHADERCONST* pPSC =
        (D3DHAL_DP2SETPIXELSHADERCONST*)(pCmd+1);
    pPSC->dwRegister = 0;
    pPSC->dwCount = RDPS_MAX_NUMCONSTREG;
    FLOAT* pfData = (FLOAT*)(pPSC+1);
    for (UINT iR=pPSC->dwRegister; iR<pPSC->dwCount; iR++)
    {
        *(pfData+0) = m_Rast.m_ConstReg[iR][0][0];
        *(pfData+1) = m_Rast.m_ConstReg[iR][0][1];
        *(pfData+2) = m_Rast.m_ConstReg[iR][0][2];
        *(pfData+3) = m_Rast.m_ConstReg[iR][0][3];
        pfData += 4;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture current pixel shader
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2PIXELSHADER);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETPIXELSHADER;
    D3DHAL_DP2PIXELSHADER* pPS = (D3DHAL_DP2PIXELSHADER*)(pCmd+1);
    pPS->dwHandle = m_CurrentPShaderHandle;
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    return hr;
}


//-----------------------------------------------------------------------------
//
// SetRenderState -
//
//-----------------------------------------------------------------------------
void
RefDev::SetRenderState( DWORD dwState, DWORD dwValue )
{
    // check for range before continuing
    if(  dwState >= D3DHAL_MAX_RSTATES  )
    {
        return;
    }

    // set value in internal object
    m_dwRenderState[dwState] = dwValue;
    if( m_pDbgMon ) m_pDbgMon->StateChanged( D3DDM_SC_DEVICESTATE );

    // do special validation work for some render states
    switch ( dwState )
    {

    case D3DRS_DEBUGMONITORTOKEN:
        if( m_pDbgMon ) m_pDbgMon->NextEvent( D3DDM_EVENT_RSTOKEN );
        break;
    case D3DRENDERSTATE_ZENABLE:
        if( dwValue )
            m_Clipper.m_dwFlags |=  RefClipper::RCLIP_Z_ENABLE;
        else
            m_Clipper.m_dwFlags &=  ~RefClipper::RCLIP_Z_ENABLE;
        break;
    case D3DRENDERSTATE_LIGHTING:
        if( dwValue )
            m_RefVP.m_dwTLState |= RDPV_DOLIGHTING;
        else
            m_RefVP.m_dwTLState &= ~RDPV_DOLIGHTING;
        break;
    case D3DRS_INDEXEDVERTEXBLENDENABLE:
        if( dwValue )
            m_RefVP.m_dwTLState |= RDPV_DOINDEXEDVERTEXBLEND;
        else
            m_RefVP.m_dwTLState &= ~RDPV_DOINDEXEDVERTEXBLEND;
        break;
    case D3DRENDERSTATE_CLIPPING:
        if( dwValue )
            m_RefVP.m_dwTLState |=  RDPV_DOCLIPPING;
        else
            m_RefVP.m_dwTLState &=  ~RDPV_DOCLIPPING;
        break;
    case D3DRENDERSTATE_SHADEMODE:
        {
            if( dwValue == D3DSHADE_FLAT )
                m_Clipper.m_dwFlags |=  RefClipper::RCLIP_DO_FLATSHADING;
            else
                m_Clipper.m_dwFlags &=  ~RefClipper::RCLIP_DO_FLATSHADING;
        }
        break;
    case D3DRENDERSTATE_FILLMODE:
        {
            if( dwValue == D3DFILL_WIREFRAME )
                m_Clipper.m_dwFlags |=  RefClipper::RCLIP_DO_WIREFRAME;
            else
                m_Clipper.m_dwFlags &=  ~RefClipper::RCLIP_DO_WIREFRAME;
        }
        break;
    case D3DRENDERSTATE_NORMALIZENORMALS:
        {
            if( dwValue )
                m_RefVP.m_dwTLState |=  RDPV_NORMALIZENORMALS;
            else
                m_RefVP.m_dwTLState &=  ~RDPV_NORMALIZENORMALS;
        }
        break;
    case D3DRENDERSTATE_LOCALVIEWER:
        {
            if( dwValue )
                m_RefVP.m_dwTLState |=  RDPV_LOCALVIEWER;
            else
                m_RefVP.m_dwTLState &=  ~RDPV_LOCALVIEWER;
        }
        break;
    case D3DRENDERSTATE_SPECULARENABLE:
        {
            if( dwValue )
                m_RefVP.m_dwTLState |= RDPV_DOSPECULAR;
            else
                m_RefVP.m_dwTLState &= ~RDPV_DOSPECULAR;
        }
        break;
    case D3DRENDERSTATE_COLORVERTEX:
    case D3DRENDERSTATE_AMBIENTMATERIALSOURCE:
    case D3DRENDERSTATE_DIFFUSEMATERIALSOURCE:
    case D3DRENDERSTATE_SPECULARMATERIALSOURCE:
    case D3DRENDERSTATE_EMISSIVEMATERIALSOURCE:
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_COLORVTX;
        break;
    case D3DRENDERSTATE_FOGCOLOR:
        {
            m_RefVP.m_lighting.fog_color = (D3DCOLOR) dwValue;
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGTABLESTART:
        {
            m_RefVP.m_lighting.fog_start = *(D3DVALUE*)&dwValue;
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGTABLEEND:
        {
            m_RefVP.m_lighting.fog_end = *(D3DVALUE*)&dwValue;
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGTABLEDENSITY:
        {
            m_RefVP.m_lighting.fog_density = *(D3DVALUE*)&dwValue;
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGVERTEXMODE:
        {
            m_RefVP.m_lighting.fog_mode = (int) dwValue;
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_AMBIENT:
        {
            m_RefVP.m_lighting.ambient_red   =
                D3DVAL(RGBA_GETRED(dwValue))/D3DVALUE(255);
            m_RefVP.m_lighting.ambient_green =
                D3DVAL(RGBA_GETGREEN(dwValue))/D3DVALUE(255);
            m_RefVP.m_lighting.ambient_blue  =
                D3DVAL(RGBA_GETBLUE(dwValue))/D3DVALUE(255);
            m_RefVP.m_lighting.ambient_save  = dwValue;
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_MATERIAL;
        }
        break;
    //
    // map legacy texture to multi-texture stage 0
    //
    case D3DRENDERSTATE_TEXTUREMAPBLEND:
        // map legacy blending state to texture stage 0
        MapLegacyTextureBlend();
        break;

        // map legacy modes with one-to-one mappings to texture stage 0
    case D3DRENDERSTATE_TEXTUREADDRESS:
// not available in DX8 headers
//        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESS] =
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSU] =
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSV] = dwValue;
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSU:
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSU] = dwValue;
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSV:
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSV] = dwValue;
        break;
    case D3DRENDERSTATE_MIPMAPLODBIAS:
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPMAPLODBIAS] = dwValue;
        break;
    case D3DRENDERSTATE_BORDERCOLOR:
        m_TextureStageState[0].m_dwVal[D3DTSS_BORDERCOLOR] = dwValue;
        break;
    case D3DRENDERSTATE_ANISOTROPY:
        m_TextureStageState[0].m_dwVal[D3DTSS_MAXANISOTROPY] = dwValue;
        // fall thru to update filter state
    case D3DRENDERSTATE_TEXTUREMAG:
    case D3DRENDERSTATE_TEXTUREMIN:
        // map legacy filtering/sampling state to texture stage 0
        MapLegacyTextureFilter();
        break;

    case D3DRENDERSTATE_TEXTUREHANDLE:
        // map thru to set handle for first stage
        SetTextureStageState( 0, D3DTSS_TEXTUREMAP, dwValue );
        break;

    //
    // map legacy WRAPU/V state through to controls for tex coord 0
    //
    case D3DRENDERSTATE_WRAPU:
        m_dwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_U;
        m_dwRenderState[D3DRENDERSTATE_WRAP0] |= ((dwValue) ? D3DWRAP_U : 0);
        break;
    case D3DRENDERSTATE_WRAPV:
        m_dwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_V;
        m_dwRenderState[D3DRENDERSTATE_WRAP0] |= ((dwValue) ? D3DWRAP_V : 0);
        break;


    case D3DRS_MULTISAMPLEANTIALIAS:
    case D3DRS_MULTISAMPLEMASK:
        m_dwRastFlags |= RDRF_MULTISAMPLE_CHANGED;
        break;

    //
    // Scene Capture
    //
    case D3DRENDERSTATE_SCENECAPTURE:
        if( dwValue )
            SceneCapture(D3DHAL_SCENE_CAPTURE_START);
        else
            SceneCapture(D3DHAL_SCENE_CAPTURE_END);
        break;

    case D3DRS_POINTSIZE:
        m_RefVP.m_fPointSize = m_fRenderState[dwState];
        break;

    case D3DRS_POINTSCALE_A:
        m_RefVP.m_fPointAttA = m_fRenderState[dwState];
        break;

    case D3DRS_POINTSCALE_B:
        m_RefVP.m_fPointAttB = m_fRenderState[dwState];
        break;

    case D3DRS_POINTSCALE_C:
        m_RefVP.m_fPointAttC = m_fRenderState[dwState];
        break;

    case D3DRS_POINTSIZE_MIN:
        m_RefVP.m_fPointSizeMin = m_fRenderState[dwState];
        break;

    case D3DRS_POINTSIZE_MAX:
        m_RefVP.m_fPointSizeMax = min(RD_MAX_POINT_SIZE,
                                      m_fRenderState[dwState]);
        break;

    case D3DRS_TWEENFACTOR:
        m_RefVP.m_fTweenFactor = m_fRenderState[dwState];
        break;

    //
    // HOSurface DDI only renderstate
    //
    case D3DRS_DELETERTPATCH:
        if(dwValue < m_HOSCoeffs.GetSize())
        {
            RDHOCoeffs &coeffs = m_HOSCoeffs[dwValue];
            delete[] coeffs.m_pNumSegs;
            coeffs.m_pNumSegs = 0;
            for(unsigned i = 0; i < RD_MAX_NUMSTREAMS; ++i)
            {
                delete[] coeffs.m_pData[i];
                coeffs.m_pData[i] = 0;
            }
        }
    }
}

HRESULT
RefDev::Dp2SetRenderTarget(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2SETRENDERTARGET pSRTData;
    HRESULT hr;

    // Get new data by ignoring all but the last structure
    pSRTData = (D3DHAL_DP2SETRENDERTARGET*)(pCmd + 1) + (pCmd->wStateCount - 1);

    // set 'changed' flags
    m_dwRastFlags =
        RDRF_MULTISAMPLE_CHANGED|
        RDRF_PIXELSHADER_CHANGED|
        RDRF_LEGACYPIXELSHADER_CHANGED|
        RDRF_TEXTURESTAGESTATE_CHANGED;

    return GetRenderTarget()->Initialize( m_pDDLcl,
                                          pSRTData->hRenderTarget,
                                          pSRTData->hZBuffer );
}

HRESULT
RefDev::Dp2CreateVertexShader( DWORD handle,
                                            DWORD dwDeclSize, LPDWORD pDecl,
                                            DWORD dwCodeSize, LPDWORD pCode )
{
    HRESULT hr = S_OK;

    HR_RET( m_VShaderHandleArray.Grow( handle ) );

    //
    // Validation sequence
    //
#if DBG
    _ASSERT( m_VShaderHandleArray[handle].m_tag == 0,
             "A shader exists with the given handle, tag is non-zero" );
#endif
    _ASSERT( pDecl, "A declaration should exist" );
    _ASSERT( dwDeclSize, "A declaration size should be non-zero" );
    _ASSERT( m_VShaderHandleArray[handle].m_pShader == NULL,
             "A shader exists with the given handle" );


    RDVShader* pShader = m_VShaderHandleArray[handle].m_pShader =
        new RDVShader;

    if( pShader == NULL )
        return E_OUTOFMEMORY;

    //
    // Parse the declaration
    //
    if( FAILED( hr = pShader->m_Declaration.Parse( pDecl,
                                                   !(BOOL)dwCodeSize ) ) )
    {
        DPFERR( "Vertex Shader declaration parsing failed" );
        goto error_ret;
    }

    //
    // Now compile the shader code if any of it is given
    //
    if( dwCodeSize )
    {
        pShader->m_pCode = m_RefVM.CompileCode( dwCodeSize, pCode );
        if( pShader->m_pCode == NULL )
        {
            DPFERR( "Vertex Shader Code compilation failed" );
            hr = E_FAIL;
            goto error_ret;
        }
    }

#if DBG
    // Everything successful, mark this handle as in use.
    m_VShaderHandleArray[handle].m_tag = 1;
#endif
    if( m_pDbgMon ) m_pDbgMon->StateChanged( D3DDM_SC_VSMODIFYSHADERS );
    return S_OK;

error_ret:
    delete pShader;
    m_VShaderHandleArray[handle].m_pShader = NULL;
#if DBG
    m_VShaderHandleArray[handle].m_tag = 0;
#endif
    return hr;
}

HRESULT
RefDev::Dp2DeleteVertexShader(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;

    LPD3DHAL_DP2VERTEXSHADER pVS =
        (LPD3DHAL_DP2VERTEXSHADER)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        DWORD handle = pVS[i].dwHandle;

        _ASSERT( m_VShaderHandleArray.IsValidIndex( handle ),
                 "Such a shader does not exist" );

        _ASSERT( m_VShaderHandleArray[handle].m_pShader,
                 "Such a shader does not exist" );

        delete m_VShaderHandleArray[handle].m_pShader;
        m_VShaderHandleArray[handle].m_pShader = NULL;
#if DBG
        m_VShaderHandleArray[handle].m_tag = 0;
#endif

        if( handle == m_CurrentVShaderHandle )
        {
            m_CurrentVShaderHandle = 0;
            m_pCurrentVShader = NULL;
        }
    }
    if( m_pDbgMon ) m_pDbgMon->StateChanged( D3DDM_SC_VSMODIFYSHADERS );
    return hr;
}

HRESULT
RefDev::Dp2SetVertexShader(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;

    LPD3DHAL_DP2VERTEXSHADER pVS =
        (LPD3DHAL_DP2VERTEXSHADER)(pCmd + 1);

    // Just set the last Vertex Shader in this array
    DWORD handle = pVS[pCmd->wStateCount-1].dwHandle;

    //
    // Zero is a special handle that tells the driver to
    // invalidate the currently set shader.
    //

    if( handle == 0 )
    {
        m_pCurrentVShader = NULL;
        m_CurrentVShaderHandle = handle;
        return hr;
    }

    if( RDVSD_ISLEGACY(handle) )
    {
        // Make it parse the FVF and build the VertexElement array
        hr = m_FVFShader.m_Declaration.MakeVElementArray( handle );
        if( FAILED( hr ) )
        {
            DPFERR( "MakeVElementArray failed" );
            return hr;
        }

        m_pCurrentVShader = &m_FVFShader;
    }
    else
    {

        if( !m_VShaderHandleArray.IsValidIndex( handle ) || 
            (m_VShaderHandleArray[handle].m_pShader == NULL) )
        {
            DPFERR( "Such a Vertex Shader has not been created" );
            return E_INVALIDARG;
        }
        m_pCurrentVShader = m_VShaderHandleArray[handle].m_pShader;

        // Save the tesselator stride computed at parsing time.
        // This feature is only available when using a Declaration.
        m_VStream[RDVSD_STREAMTESS].m_dwStride =
            m_pCurrentVShader->m_Declaration.m_dwStreamTessStride;

    }

    if( m_pCurrentVShader->m_pCode )
    {
        hr = m_RefVM.SetActiveShaderCode( m_pCurrentVShader->m_pCode );
        if( FAILED( hr ) )
        {
            DPFERR( "SetActiveShaderCode failed" );
            return hr;
        }

        RDVConstantData* pConst =
            m_pCurrentVShader->m_Declaration.m_pConstants;
        while( pConst )
        {
            hr = m_RefVM.SetData( D3DSPR_CONST,
                                  pConst->m_dwAddress,
                                  pConst->m_dwCount,
                                  pConst->m_pData );
            if( FAILED( hr ) )
            {
                DPFERR( "SetVMData failed" );
                return hr;
            }
            pConst = static_cast<RDVConstantData *>(pConst->m_pNext);
        }
    }

    m_CurrentVShaderHandle = handle;
    if( m_pCurrentVShader->m_Declaration.m_qwInputFVF != m_RefVP.m_qwFVFIn )
    {
        m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_COLORVTX;
    }
    m_RefVP.m_qwFVFIn = m_pCurrentVShader->m_Declaration.m_qwInputFVF;
    if( m_pDbgMon ) m_pDbgMon->StateChanged( D3DDM_SC_VSSETSHADER );

    return hr;
}

HRESULT
RefDev::Dp2SetVertexShaderConsts( DWORD StartReg, DWORD dwCount,
                                               LPDWORD pData )
{
    HRESULT hr = m_RefVM.SetData( D3DSPR_CONST, StartReg, dwCount, pData );
    if( m_pDbgMon ) m_pDbgMon->StateChanged( D3DDM_SC_VSCONSTANTS );
    return hr;
}

HRESULT
RefDev::Dp2SetStreamSource(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;

    LPD3DHAL_DP2SETSTREAMSOURCE pSSS =
        (LPD3DHAL_DP2SETSTREAMSOURCE)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        RDVStream& Stream = m_VStream[pSSS[i].dwStream];

        // NULL handle means that the StreamSource should be unset.
        if( pSSS[i].dwVBHandle == 0 )
        {
            Stream.m_pData = NULL;
            Stream.m_dwStride = 0;
            Stream.m_dwHandle = 0;
        }
        else
        {

            // Check if the handle has a valid vertexbuffer
            RDSurface* pSurf =
                g_SurfMgr.GetSurfFromList(m_pDDLcl, pSSS[i].dwVBHandle);
            if( (pSurf == NULL) ||
                (pSurf->GetSurfaceType() != RR_ST_VERTEXBUFFER) )
            {
                DPFERR( "Invalid VB Handle passed in SetStreamSource" );
                return E_INVALIDARG;
            }

            RDVertexBuffer* pVB = static_cast<RDVertexBuffer *>(pSurf);
            Stream.m_pData = pVB->GetBits();
            Stream.m_dwStride = pSSS[i].dwStride;
            Stream.m_dwHandle = pSSS[i].dwVBHandle;
        }
    }
    return hr;
}

HRESULT
RefDev::Dp2SetStreamSourceUM( LPD3DHAL_DP2COMMAND pCmd,
                                           PUINT8 pUMVtx )
{
    HRESULT hr = S_OK;
    // Get new data by ignoring all but the last structure
    D3DHAL_DP2SETSTREAMSOURCEUM* pSSUM =
        (D3DHAL_DP2SETSTREAMSOURCEUM*)(pCmd + 1) + (pCmd->wStateCount - 1);

    // Access only the Zero'th stream
    m_VStream[pSSUM->dwStream].m_pData = pUMVtx;
    m_VStream[pSSUM->dwStream].m_dwStride = pSSUM->dwStride;
    m_VStream[pSSUM->dwStream].m_dwHandle = 0;

    return hr;
}

HRESULT
RefDev::Dp2SetIndices(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    // Get new data by ignoring all but the last structure
    D3DHAL_DP2SETINDICES* pSI =
        (D3DHAL_DP2SETINDICES*)(pCmd + 1) + (pCmd->wStateCount - 1);

    // NULL handle means that the StreamSource should be unset.
    if( pSI->dwVBHandle == 0 )
    {
        m_IndexStream.m_pData = NULL;
        m_IndexStream.m_dwStride = 0;
        m_IndexStream.m_dwHandle = 0;
    }
    else
    {
        // Check if the handle has a valid vertexbuffer
        RDSurface* pSurf = g_SurfMgr.GetSurfFromList(m_pDDLcl,
                                                     pSI->dwVBHandle);
        if( (pSurf == NULL) ||
            (pSurf->GetSurfaceType() != RR_ST_VERTEXBUFFER) )
        {
            DPFERR( "Invalid VB Handle passed in SetIndices" );
            return E_INVALIDARG;
        }
        RDVertexBuffer* pVB = static_cast<RDVertexBuffer *>(pSurf);
        m_IndexStream.m_pData = pVB->GetBits();
        m_IndexStream.m_dwStride = pSI->dwStride;
        m_IndexStream.m_dwHandle = pSI->dwVBHandle;
    }

    return hr;
}


HRESULT
RefDev::Dp2DrawPrimitive(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;

    //
    // Validation
    //
    _ASSERT( m_CurrentVShaderHandle, "No vertex shader currently bound" );

    LPD3DHAL_DP2DRAWPRIMITIVE pDP = (LPD3DHAL_DP2DRAWPRIMITIVE)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        if( FAILED( hr = DrawDX8Prim( &(pDP[i]) ) ) )
            return hr;
    }
    return hr;
}

HRESULT
RefDev::Dp2DrawPrimitive2(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;

    //
    // Validation
    //
    _ASSERT( m_CurrentVShaderHandle, "No vertex shader currently bound" );

    LPD3DHAL_DP2DRAWPRIMITIVE2 pDP = (LPD3DHAL_DP2DRAWPRIMITIVE2)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        if( FAILED( hr = DrawDX8Prim2( &(pDP[i]) ) ) )
            return hr;
    }
    return hr;
}

HRESULT
RefDev::Dp2DrawIndexedPrimitive(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    //
    // Validation
    //
    _ASSERT( m_CurrentVShaderHandle, "No vertex shader currently bound" );

    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pDIP =
        (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        if( FAILED( hr = DrawDX8IndexedPrim( &(pDIP[i]) ) ) )
            return hr;
    }
    return hr;
}

HRESULT
RefDev::Dp2DrawIndexedPrimitive2(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    //
    // Validation
    //
    _ASSERT( m_CurrentVShaderHandle, "No vertex shader currently bound" );

    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 pDIP =
        (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        if( FAILED( hr = DrawDX8IndexedPrim2( &(pDIP[i]) ) ) )
            return hr;
    }
    return hr;
}

HRESULT
RefDev::Dp2DrawClippedTriFan(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    //
    // Validation
    //
    _ASSERT( m_CurrentVShaderHandle, "No vertex shader currently bound" );

    LPD3DHAL_CLIPPEDTRIANGLEFAN pDIP =
        (LPD3DHAL_CLIPPEDTRIANGLEFAN)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        if( FAILED( hr = DrawDX8ClippedTriFan( &(pDIP[i]) ) ) )
            return hr;
    }
    return hr;
}


HRESULT
RefDev::Dp2SetPalette(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    LPD3DHAL_DP2SETPALETTE pSP = (LPD3DHAL_DP2SETPALETTE)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        HR_RET( m_PaletteHandleArray.Grow( pSP->dwPaletteHandle ) );
        if( m_PaletteHandleArray[pSP->dwPaletteHandle].m_pPal == NULL )
        {
            m_PaletteHandleArray[pSP->dwPaletteHandle].m_pPal = new RDPalette;
        }
        RDPalette* pPal = m_PaletteHandleArray[pSP->dwPaletteHandle].m_pPal;
        pPal->m_dwFlags = (pSP->dwPaletteFlags & DDRAWIPAL_ALPHA) ?
            RDPalette::RDPAL_ALPHAINPALETTE : 0;
        RDSurface2D* pSurf = (RDSurface2D *)g_SurfMgr.GetSurfFromList(
            m_pDDLcl, pSP->dwSurfaceHandle );
        if( pSurf == NULL ) return E_FAIL;
        if( (pSurf->GetSurfaceType() & RR_ST_TEXTURE) == 0 )
        {
            DPFERR( "Setting palette to a non-texture\n" );
            return E_FAIL;
        }
        pSurf->SetPalette( pPal );
    }
    return hr;
}

HRESULT
RefDev::Dp2UpdatePalette(LPD3DHAL_DP2UPDATEPALETTE pUP, PALETTEENTRY* pPalData)
{
    HRESULT hr = S_OK;
    HR_RET( m_PaletteHandleArray.Grow( pUP->dwPaletteHandle ) );
    if( m_PaletteHandleArray[pUP->dwPaletteHandle].m_pPal == NULL )
    {
        m_PaletteHandleArray[pUP->dwPaletteHandle].m_pPal = new RDPalette;
    }
    RDPalette* pPal = m_PaletteHandleArray[pUP->dwPaletteHandle].m_pPal;
    HR_RET( pPal->Update( pUP->wStartIndex, pUP->wNumEntries, pPalData ) );
    return hr;
}

HRESULT
RefDev::Dp2SetTexLod(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    LPD3DHAL_DP2SETTEXLOD pSTL = (LPD3DHAL_DP2SETTEXLOD)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        RDSurface2D* pSurf = (RDSurface2D *)g_SurfMgr.GetSurfFromList(
            m_pDDLcl, pSTL->dwDDSurface );
        if( pSurf == NULL ) return E_FAIL;
        if( (pSurf->GetSurfaceType() & RR_ST_TEXTURE) == 0 )
        {
            DPFERR( "Setting LOD  to a non-texture\n" );
            return E_FAIL;
        }
        HR_RET(pSurf->SetLod( pSTL->dwLOD ));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\hop\bezier.hpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bezier.hpp
 *  Content:    Declarations for Beziers
 *
 ****************************************************************************/

#ifndef _BEZIER_HPP
#define _BEZIER_HPP

#include "bspline.hpp"

class RDBezier : public RDBSpline
{
public:
    RDBezier(DWORD dwOrderU, DWORD dwOrderV);

    virtual double TexCoordU(double u) const;
    virtual double TexCoordV(double v) const;

private:
    double m_lut[13][13];

    virtual double Basis(unsigned i, unsigned n, double t) const;
    virtual double BasisPrime(unsigned i, unsigned n, double t) const;

    unsigned factorial(unsigned k) const
    {
        _ASSERT(k < 13, "Factorial out of range");
        for(unsigned i = 1, t = 1; i <= k; t *= i++);
        return t;
    }
};

#endif // _BEZIER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\drv\refif.cpp ===
//----------------------------------------------------------------------------
//
// refrastfn.cpp
//
// Reference rasterizer callback functions for D3DIM.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

// The DDI refrast is emulating
RDDDITYPE g_RefDDI;

// All the supported texture formats
DDSURFACEDESC g_ddsdTex[RD_MAX_NUM_TEXTURE_FORMATS];

// The current caps8 for newly created devices
static D3DCAPS8 g_RefCaps8;

// Maps D3DMULTISAMPLE_TYPE into the bit to use for the flags.
// Maps each of the multisampling values (2 to 16) to the bits[1] to bits[15]
// of wBltMSTypes and wFlipMSTypes
#define DDI_MULTISAMPLE_TYPE(x) (1 << ((x)-1))

//----------------------------------------------------------------------------
//
// RefRastUpdatePalettes
//
//----------------------------------------------------------------------------
HRESULT
RefRastUpdatePalettes(RefDev *pRefDev)
{
    INT i, j, k;
    RDSurface2D* pRDTex[D3DHAL_TSS_MAXSTAGES];
    D3DTEXTUREHANDLE phTex[D3DHAL_TSS_MAXSTAGES];
    HRESULT hr;
    int cActTex;

    if ((cActTex = pRefDev->GetCurrentTextureMaps(phTex, pRDTex)) == 0)
    {
        return D3D_OK;
    }

    for (j = 0; j < cActTex; j++)
    {
        // stages may not have texture bound
        if ( NULL == pRDTex[j] ) continue;
        pRDTex[j]->UpdatePalette();
    }

    return D3D_OK;

}

//----------------------------------------------------------------------------
//
// RDRenderTarget::Initialize
//
// Converts color and Z surface information into refrast form.
//
//----------------------------------------------------------------------------

HRESULT
RDRenderTarget::Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLclColor,
                            LPDDRAWI_DDRAWSURFACE_LCL pLclZ )
{
    HRESULT hr;
    RDSurfaceFormat ColorFmt;
    RDSurfaceFormat ZFmt;
    RDSurface2D* pOldColor = m_pColor;
    RDSurface2D* pOldDepth = m_pDepth;

    if( m_pColor )
    {
        m_pColor = NULL;
    }
    if( m_pDepth )
    {
        m_pDepth = NULL;
    }

    // Find the surfaces from the global surface manager
    // We are assuming that CreateSurfaceEx has been called on these
    // surfaces before this.
    RDSurface2D* pColor = m_pColor = new RDSurface2D;
    if( pColor == NULL )
    {
        DPFERR( "Color surface could not be allocated" );
        m_pColor = pOldColor;
        m_pDepth = pOldDepth;
        return DDERR_OUTOFMEMORY;
    }
    if( FAILED( hr = pColor->Initialize( pLclColor ) ) )
    {
        DPFERR( "Unable to initialize the color buffer" );
        delete pColor;
        m_pColor = pOldColor;
        m_pDepth = pOldDepth;
        return hr;
    }

    if (NULL != pLclZ)
    {
        RDSurface2D* pDepth = m_pDepth = new RDSurface2D;
        if( pDepth == NULL )
        {
            DPFERR( "Depth surface could not be allocated" );
            delete pColor;
            m_pColor = pOldColor;
            m_pDepth = pOldDepth;
            return DDERR_OUTOFMEMORY;
        }
        if( FAILED( hr = pDepth->Initialize( pLclZ ) ) )
        {
            DPFERR("Unable to initialize the Depth buffer");
            delete pColor;
            delete pDepth;
            m_pColor = pOldColor;
            m_pDepth = pOldDepth;
            return hr;
        }
    }

    m_Clip.left = 0;
    m_Clip.top = 0;
    m_Clip.bottom = pColor->GetHeight() - 1;
    m_Clip.right = pColor->GetWidth() - 1;

    m_bPreDX7DDI = TRUE;
    delete pOldColor;
    delete pOldDepth;
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RDRenderTarget::Initialize
//
// Converts color and Z surface information into refrast form.
//
//----------------------------------------------------------------------------

HRESULT
RDRenderTarget::Initialize( LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
                            LPDDRAWI_DDRAWSURFACE_LCL pLclColor,
                            LPDDRAWI_DDRAWSURFACE_LCL pLclZ )
{
    HRESULT hr;
    RDSurfaceFormat ColorFmt;
    RDSurfaceFormat ZFmt;
    RDSurface2D* pOldColor = m_pColor;
    RDSurface2D* pOldDepth = m_pDepth;

    if( m_pColor )
    {
        m_pColor = NULL;
    }
    if( m_pDepth )
    {
        m_pDepth = NULL;
    }

    // Find the surfaces from the global surface manager
    // We are assuming that CreateSurfaceEx has been called on these
    // surfaces before this.
    DWORD dwColorHandle = pLclColor->lpSurfMore->dwSurfaceHandle;
    RDSurface2D* pColor = m_pColor =
        (RDSurface2D *)g_SurfMgr.GetSurfFromList( pDDLcl,
                                                       dwColorHandle);
    if( pColor == NULL )
    {
        DPFERR("Color surface not found");
        m_pColor = pOldColor;
        m_pDepth = pOldDepth;
        return DDERR_INVALIDPARAMS;
    }

    if (NULL != pLclZ)
    {
        DWORD dwDepthHandle = pLclZ->lpSurfMore->dwSurfaceHandle;
        RDSurface2D* pDepth = m_pDepth =
            (RDSurface2D *)g_SurfMgr.GetSurfFromList( pDDLcl,
                                                           dwDepthHandle);
        if( pDepth == NULL )
        {
            DPFERR("Depth surface not found");
            m_pColor = pOldColor;
            m_pDepth = pOldDepth;
            return DDERR_INVALIDPARAMS;
        }
    }

    m_Clip.left = 0;
    m_Clip.top = 0;
    m_Clip.bottom = pColor->GetHeight() - 1;
    m_Clip.right = pColor->GetWidth() - 1;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RDRenderTarget::Initialize
//
// Converts color and Z surface information into refrast form.
//
//----------------------------------------------------------------------------

HRESULT
RDRenderTarget::Initialize( LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
                            DWORD dwColorHandle,
                            DWORD dwDepthHandle )
{
    HRESULT hr;
    RDSurfaceFormat ColorFmt;
    RDSurfaceFormat ZFmt;
    RDSurface2D* pOldColor = m_pColor;
    RDSurface2D* pOldDepth = m_pDepth;

    // Release objects we hold pointers to
    if( m_pColor )
    {
        m_pColor = NULL;
    }
    if( m_pDepth )
    {
        m_pDepth = NULL;
    }

    // Find the surfaces from the global surface manager
    // We are assuming that CreateSurfaceEx has been called on these
    // surfaces before this.
    RDSurface2D* pColor = m_pColor =
        (RDSurface2D *)g_SurfMgr.GetSurfFromList( pDDLcl,
                                                       dwColorHandle);
    if( pColor == NULL )
    {
        DPFERR("Color surface not found");
        m_pColor = pOldColor;
        m_pDepth = pOldDepth;
        return DDERR_INVALIDPARAMS;
    }

    if (0 != dwDepthHandle)
    {
        RDSurface2D* pDepth = m_pDepth =
            (RDSurface2D *)g_SurfMgr.GetSurfFromList( pDDLcl,
                                                           dwDepthHandle);
        if( pDepth == NULL )
        {
            DPFERR("Depth surface not found");
            m_pColor = pOldColor;
            m_pDepth = pOldDepth;
            return DDERR_INVALIDPARAMS;
        }
    }

    m_Clip.left = 0;
    m_Clip.top = 0;
    m_Clip.bottom = pColor->GetHeight() - 1;
    m_Clip.right = pColor->GetWidth() - 1;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RefRastContextCreate
//
// Creates a RefDev and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    RefDev *pRefDev;
    RDRenderTarget *pRendTgt;
    INT i;

    // Surface7 pointers for QI
    LPDDRAWI_DDRAWSURFACE_LCL pZLcl = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL pColorLcl = NULL;
    HRESULT ret;

    DPFM(0, DRV, ("In the new RefRast Dll\n"));

    // this only needs to be called once, but once per context won't hurt
    RefRastSetMemif(&malloc, &free, &realloc);

    if ((pRendTgt = new RDRenderTarget()) == NULL)
    {
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    // If it is expected to be a DX7+ driver
    if (g_RefDDI < RDDDI_DX7HAL)
    {
        if (pCtxData->lpDDS)
            pColorLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pCtxData->lpDDS))->lpLcl;
        if (pCtxData->lpDDSZ)
            pZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pCtxData->lpDDSZ))->lpLcl;

        // Collect surface information where the failures are easy to handle.
        pCtxData->ddrval = pRendTgt->Initialize( pColorLcl, pZLcl );
    }
    else
    {
        pColorLcl = pCtxData->lpDDSLcl;
        pZLcl     = pCtxData->lpDDSZLcl;

        // Collect surface information where the failures are easy to handle.
        pCtxData->ddrval = pRendTgt->Initialize( pCtxData->lpDDLcl, pColorLcl,
                                                 pZLcl );
    }

    if (pCtxData->ddrval != D3D_OK)
    {
        delete pRendTgt;
        return DDHAL_DRIVER_HANDLED;
    }


    // Note:
    // dwhContext is used by the runtime to inform the driver, which
    // d3d interface is calling the driver.
    if ( ( pRefDev = new RefDev( pCtxData->lpDDLcl,
                                               (DWORD)(pCtxData->dwhContext),
                                               g_RefDDI, &g_RefCaps8 ) ) == NULL )
    {
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    pRefDev->SetRenderTarget( pRendTgt );

    //  return RR object pointer as context handle
    pCtxData->dwhContext = (ULONG_PTR)pRefDev;

    pCtxData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastContextDestroy
//
// Destroy a RefDev.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData)
{
    RefDev *pRefDev;

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastContextDestroy", pCtxDestroyData);

    // Clean up override bits

    RDRenderTarget *pRendTgt = pRefDev->GetRenderTarget();
    if ( NULL != pRendTgt ) { delete pRendTgt; }

    delete pRefDev;

    pCtxDestroyData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastSceneCapture
//
// Pass scene capture callback to ref rast.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastSceneCapture(LPD3DHAL_SCENECAPTUREDATA pData)
{
    RefDev *pRefDev;

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastSceneCapture", pData);

    pRefDev->SceneCapture( pData->dwFlag );

    pData->ddrval = D3D_OK;        // Should this be changed to a QI ?

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastSetRenderTarget
//
// Update a RefRast context with the info from a new render target.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData)
{
    RefDev *pRefDev;
    LPDDRAWI_DDRAWSURFACE_LCL pZLcl = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL pColorLcl = NULL;
    HRESULT ret;

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastSetRenderTarget", pTgtData);

    _ASSERT( pRefDev->IsDriverDX6AndBefore(), "This callback should"
        "never be called on DDIs DX7 and beyond" )

    _ASSERT( pRefDev->IsInterfaceDX6AndBefore(), "An older interface should"
             "never call this DLL" )

    RDRenderTarget *pRendTgt = pRefDev->GetRenderTarget();
    if ( NULL == pRendTgt ) { return DDHAL_DRIVER_HANDLED; }

    if( pTgtData->lpDDS )
        pColorLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pTgtData->lpDDS))->lpLcl;
    if( pTgtData->lpDDSZ )
        pZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pTgtData->lpDDSZ))->lpLcl;

    // Collect surface information.
    pTgtData->ddrval = pRendTgt->Initialize( pColorLcl, pZLcl);
    if (pTgtData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    pRefDev->SetRenderTarget(pRendTgt);

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastValidateTextureStageState
//
// Validate current blend operations.  RefRast does everything.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData)
{
    RefDev *pRefDev;

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastValidateTextureStageState", pData);

    pData->dwNumPasses = 1;
    pData->ddrval = D3D_OK;

    return DDHAL_DRIVER_HANDLED;
}


//----------------------------------------------------------------------------
//
// RefRastTextureCreate
//
// Creates a RefRast texture and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastTextureCreate(LPD3DHAL_TEXTURECREATEDATA pTexData)
{
    RefDev *pRefDev;
    RDSurface2D* pRDTex;
    HRESULT hr;
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;

    if (pTexData->lpDDS)
    {
        pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pTexData->lpDDS)->lpLcl;
    }

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastTextureCreate", pTexData);

    // Runtime shouldnt be calling TextureCreate for DX7 and newer
    // driver models
    _ASSERT( pRefDev->IsDriverDX6AndBefore(), "This DDI should not"
             "be called from DDIs previous to DX7" );

    // assume OKness
    pTexData->ddrval = D3D_OK;

    // Allocate RDSurface2D
    if ( !(pRefDev->TextureCreate(
        (LPD3DTEXTUREHANDLE)&(pTexData->dwHandle), &pRDTex ) ) )
    {
        pTexData->ddrval = DDERR_GENERIC;
        return DDHAL_DRIVER_HANDLED;
    }

    // Init texturemap.
    hr = pRDTex->Initialize( pLcl );
    if (hr != D3D_OK)
    {
        pTexData->ddrval = hr;
        return DDHAL_DRIVER_HANDLED;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastTextureDestroy
//
// Destroy a RefRast texture.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pTexDestroyData)
{
    RefDev *pRefDev;

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastTextureDestroy", pTexDestroyData);

    // Runtime shouldnt be Calling TextureCreate for DX7 and newer
    // driver models
    _ASSERT( pRefDev->IsDriverDX6AndBefore(), "This DDI should not"
             "be called from DDIs previous to DX7" );

    if (!(pRefDev->TextureDestroy(pTexDestroyData->dwHandle)))
    {
        pTexDestroyData->ddrval = DDERR_GENERIC;
    }
    else
    {
        pTexDestroyData->ddrval = D3D_OK;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastTextureGetSurf
//
// Returns the surface pointer associate with a texture handle.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pTexGetSurf)
{
    RefDev *pRefDev;

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastTextureGetSurf", pTexGetSurf);

    pTexGetSurf->lpDDS = pRefDev->TextureGetSurf(pTexGetSurf->dwHandle);
    pTexGetSurf->ddrval = D3D_OK;

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastGetDriverState
//
// Called by the runtime to get any kind of driver information
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastGetDriverState(LPDDHAL_GETDRIVERSTATEDATA pGDSData)
{
    RefDev *pRefDev;

    // Check RefDev
#if DBG
    if ((pGDSData) == NULL)
    {
        DPFERR("in %s, data pointer = NULL", "RefRastGetDriverState");
        return DDHAL_DRIVER_HANDLED;
    }
    pRefDev = (RefDev *)ULongToPtr((pGDSData)->dwhContext);
    if (!pRefDev)
    {
        DPFERR("in %s, dwhContext = NULL", "RefRastGetDriverState");
        pGDSData->ddRVal = D3DHAL_CONTEXT_BAD;
        return DDHAL_DRIVER_HANDLED;
    }
#else // !DBG
    pRefDev = (RefDev *)ULongToPtr((pGDSData)->dwhContext);
#endif // !DBG

    //
    // No implementation yet, so nothing is understood yet
    //
    pGDSData->ddRVal = S_FALSE;

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// FindAttachedSurfaceCaps2
//
// Walks the attachment list for the surface, looking for an attachment
// that has any of the dwCaps2 bits (or ignores if zero) and none of the
// FindAttachedSurfaceCaps2NotPresent bits.
//
//----------------------------------------------------------------------------
LPDDRAWI_DDRAWSURFACE_LCL
FindAttachedSurfaceCaps2(
    LPDDRAWI_DDRAWSURFACE_LCL pLcl,
    DWORD dwCaps2)
{
    LPATTACHLIST lpAttachStruct = pLcl->lpAttachList;
    while(lpAttachStruct)
    {
        if ((dwCaps2 == 0) || (lpAttachStruct->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2 & dwCaps2))
            return lpAttachStruct->lpAttached;
        lpAttachStruct = lpAttachStruct->lpLink;
    }

    return 0;
}


//----------------------------------------------------------------------------
//
// ProcessPossibleMipMap
//
// Record private data structure for this surface and all attached mip
// sublevels.
//
//----------------------------------------------------------------------------
void
ProcessPossibleMipMap(
    LPDDHAL_CREATESURFACEEXDATA p,
    LPDDRAWI_DDRAWSURFACE_LCL lpDDSMipLcl
    )
{
    do
    {
        // This function should not deal with deletions. Assert this.
        _ASSERT( SURFACE_MEMORY(lpDDSMipLcl),
                 "Delete should have already taken place" );

        p->ddRVal = g_SurfMgr.AddSurfToList( p->lpDDLcl, lpDDSMipLcl, NULL );
        if (FAILED(p->ddRVal))
            return;

        // Now search down the 2nd+ order attachment: the chain
        // of mip sublevels.
        lpDDSMipLcl = FindAttachedSurfaceCaps2(lpDDSMipLcl,
                                               DDSCAPS2_MIPMAPSUBLEVEL);
    }
    while (lpDDSMipLcl);
}

//----------------------------------------------------------------------------
//
// RefRastCreateSurfaceEx
//
// Refrast implementation of CreateSurfaceEx. g_SurfMgr is the object
// that does the real job.
//
// CreateSurfaceEx is also used to inform the driver to create and destroy
// surface representations for a given handle. The way the driver can tell
// the difference between create and destroy is by looking at the fpVidmem
// pointer of the passed local. If it is null, it is a destroy.
//
// Create: This call is atomic. i.e. the attachments are all done by the
//         runtime. The driver is expected to walk through the attachment and
//         form its internal picture as described below.
// For complex surfaces (mipped textures, cubemaps), we need to record an
// internal representation for the top-level surface that includes all
// sub-surfaces. This is because the handle associated with the top-level
// surface is what's passed to SetTextureStage.
// However, we also need entries in our list that allow us to set any
// of the sublevels as render targets. Thus this top-level routine iterates
// across the entire attachment graph (to accomodate SRT on any subsurface)
// and the lower-level routine (RDSurface2D::Initialize) also iterates across
// the whole graph (to accomodate SetTexture on the top-level).
// A flipping chain is another structure that needs SRT to work on all
// contained surfaces.
//
// Destroy: The destruction unfortunately is not atomic. The driver gets
//          the call to destroy per sub-level. The attachment has no meaning
//          at this time, so the driver should only delete the level being
//          referred to.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastCreateSurfaceEx(LPDDHAL_CREATESURFACEEXDATA p)
{
#if DBG
    if( p == NULL )
    {
        DPFERR("CreateSurfaceExData ptr is NULL");
        return DDHAL_DRIVER_HANDLED;
    }
    if( p->lpDDLcl == NULL || p->lpDDSLcl == NULL )
    {
        DPFERR("DDLcl or the DDSLcl ptr is NULL");
        return DDHAL_DRIVER_HANDLED;
    }
#endif
    LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl = p->lpDDSLcl;
    p->ddRVal = DD_OK;

    //
    // Is it a Delete call ? If so simply delete the surface-rep associated
    // with this local and dont walk the local chain.
    //

    if( 0 == SURFACE_MEMORY(lpDDSLcl) )
    {
        g_SurfMgr.RemoveSurfFromList( p->lpDDLcl, lpDDSLcl );
        return DDHAL_DRIVER_HANDLED;
    }

    ProcessPossibleMipMap(p, lpDDSLcl);

    //Now we have two possibilities: cubemap or flipping chain.
    // Check cube map first:

    //+ve X is always the first face
    // (Note a DX7 driver would have to handle cubes w/o the +X face (since DX7
    // cubes may have any set of faces missing).)
    if (lpDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_POSITIVEX)
    {
        //Go find each attached cubemap face and process it as a mipmap
        for (int i=1;i<6;i++)
        {
            DWORD dwCaps2=0;
            switch(i)
            {
            case 1: dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEX; break;
            case 2: dwCaps2 = DDSCAPS2_CUBEMAP_POSITIVEY; break;
            case 3: dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEY; break;
            case 4: dwCaps2 = DDSCAPS2_CUBEMAP_POSITIVEZ; break;
            case 5: dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEZ; break;
            }

            //Find the top-level faces attached to the root
            //(there will be no mip sublevel of any of these five types
            //attached to the root).
            lpDDSLcl = FindAttachedSurfaceCaps2(p->lpDDSLcl, dwCaps2);
            if (lpDDSLcl) ProcessPossibleMipMap(p, lpDDSLcl);
        }
    }
    else if (
        0==(lpDDSLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) &&
        0 != lpDDSLcl->lpAttachList)
    {
        //just assert that we're not handling some of the other types
        //we know are passed to CSEx.
        _ASSERT(0==(lpDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE), "CSEx for an attached texture?");
        _ASSERT(0==(lpDDSLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER), "CSEx for an attached execute buffer?");

        // We processed mipmaps above, so either there will be no
        // more attachments (aside from the mipsublevels), or it's
        // a flipping chain.

        // The first member of the chain was processed above.
        // Npw we look around the ring, terminating when we hit the first surface
        // again.
        //
        // NOTE: DX8 software drivers will only ever see a chain, not a ring.
        // This code terminates at the end of the chain.
        //
        // A real driver may have to check for attached Z surfaces
        // here, as well as stereo left surfaces.

        lpDDSLcl = lpDDSLcl->lpAttachList->lpAttached;
        _ASSERT(lpDDSLcl, "Bad attachment List");

        while (lpDDSLcl && lpDDSLcl != p->lpDDSLcl) //i.e. not the first surface again
        {
            //We just reuse the "ProcessPossibleMipmap" function, and
            //assert that it will not have to traverse a mipmap here.
            _ASSERT(0==(lpDDSLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP),
                "Flipping chains should not be mipmaps");

            ProcessPossibleMipMap(p, lpDDSLcl);

            //This is the termination condition we expect for DX8 software
            //drivers.
            if (0 == lpDDSLcl->lpAttachList)
            {
                lpDDSLcl = 0;
                break;
            }

            lpDDSLcl = lpDDSLcl->lpAttachList->lpAttached;

            _ASSERT(lpDDSLcl, "Bad attachment List");
        }
    }
    // else we drop through and do no further attachment list processing
    // (typically on mipmaps or execute buffers).

    return DDHAL_DRIVER_HANDLED;
}


extern HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT  pDdPixFmt, RDSurfaceFormat* pFmt,
                  BOOL*   pbIsDepth);

//----------------------------------------------------------------------------
//
// RefRastCreateSurface
//
// Create a requested surface. Fake VIDMEM allocation.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastCreateSurface(LPDDHAL_CREATESURFACEDATA pData)
{
    LPDDRAWI_DDRAWSURFACE_LCL  pSLcl  = NULL;
    LPDDRAWI_DDRAWSURFACE_GBL  pSGbl  = NULL;
    LPDDRAWI_DDRAWSURFACE_MORE pSMore = NULL;
    DWORD dwBytesPerPixel = 0;
    DWORD dwBytesInVB = 0;
    DWORD dwNumBytes = 0;
    DWORD dwPitch = 0;
    DWORD dwSlicePitch = 0;
    DWORD i = 0, j = 0;
    BYTE* pBits = NULL;
    BOOL  isDXT = FALSE;
    UINT  MultiSampleCount;
    DWORD dwMultiSamplePitch = 0;
    BYTE* pMultiSampleBits = NULL;
    DWORD dwNumMultiSampleBytes = 0;
    HRESULT hr = S_OK;

    pData->ddRVal = DD_OK;

    //
    // Validation
    //

    // The surface count
    if( pData->dwSCnt < 1 )
    {
        DPFERR("At least one surface should be created");
        pData->ddRVal = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    // Primary surface cannot be handled here
    if( pData->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
    {
        DPFERR("Refrast cannot allocate Primary surface");
        pData->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }

    // Only Vidmem or Driver Managed allocations are handled here
    if(((pData->lpDDSurfaceDesc->ddsCaps.dwCaps &
          (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM)) == 0)
        &&
        ((pData->lplpSList[0]->lpSurfMore->ddsCapsEx.dwCaps2 &
          DDSCAPS2_TEXTUREMANAGE) == 0))
    {
        DPFERR("Refrast can only allocate Vidmem or DriverManaged surfaces");
        pData->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }

    // Dont allocate if the width or the height is not provided
    if( (pData->lpDDSurfaceDesc->dwFlags & (DDSD_WIDTH | DDSD_HEIGHT )) !=
        (DDSD_WIDTH | DDSD_HEIGHT ) )
    {
        DPFERR("No size provided for the surface");
        pData->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }

    // Currently, allocation takes place only if a pixel format is provided
    if( pData->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT )
    {
        dwBytesPerPixel =
            (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwRGBBitCount >> 3);

        // For FourCCs, we need to explicitly indicate the bytes per pixel

        if ((dwBytesPerPixel == 0) &&
            (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_FOURCC))
        {
            if( IsYUV( pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ) )
            {
                dwBytesPerPixel = 2;
            }
            else if( IsDXTn( pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ) )
            {
                dwBytesPerPixel = 1;
                isDXT = TRUE;
            }
            // All the new surface formats (introduced after DX7) are marked as
            // 4CC. Technically they are not 4CC, that field is overloaded to
            // mean the new DX8 style format ID.
            else if( (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ==
                      0xFF000004)    ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ==
                      (DWORD) D3DFMT_Q8W8V8U8) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ==
                      (DWORD) D3DFMT_V16U16) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ==
                      (DWORD) D3DFMT_W11V11U10) ||
                     // Formats introduced in DX8.1
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_A2B10G10R10) ||
#if 0
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_A8B8G8R8) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_X8B8G8R8) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_W10V11U11) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_A8X8V8U8) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_L8X8V8U8) ||
#endif
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_G16R16) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_A2W10V10U10)
                    )
            {
                // Private new format
                dwBytesPerPixel = 4;
            }
        }
    }
    else if( pData->lpDDSurfaceDesc->ddsCaps.dwCaps  & DDSCAPS_EXECUTEBUFFER )
    {
        dwBytesInVB = ((LPDDSURFACEDESC2)(pData->lpDDSurfaceDesc))->dwWidth;
    }
    else
    {
        // Note: for DX8 drivers, this case should never be encountered.
        // In the future, if RefDev is revamped to work with legacy interfaces
        // then this case needs to something real instead of failing:
        // If the pixel-formats are not provided, then the current primary
        // format should be assumed.
        DPFERR( "Refrast can only allocate if PixelFormat is provided" );
        pData->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // Allocate the memory and compute the Pitch for every surface on the
    // list.
    //

    // We should be guaranteed that this is the same for all surfaces in the
    // list
    MultiSampleCount = 0xf & (pData->lplpSList[0]->lpSurfMore->ddsCapsEx.dwCaps3);

    //This will be the case on older than DX8 runtimes
    if (MultiSampleCount == 0)
    {
        MultiSampleCount = 1;
    }


    for( i = 0; i < pData->dwSCnt; i++ )
    {
        RDCREATESURFPRIVATE* pPriv = NULL;

        pSLcl  = pData->lplpSList[i];
        pSGbl  = pSLcl->lpGbl;
        pSMore = pSLcl->lpSurfMore;
        DWORD dwHeight = pSGbl->wHeight;

        // If already allocated, just return
        if( pSGbl->fpVidMem || pSGbl->dwReserved1 )
        {
            DPFERR("Surface has already been allocated");
            pData->ddRVal = E_FAIL;
            break;
        }

        // Figure out if it is a vertex buffer
        if( dwBytesInVB )
        {
            dwNumBytes = dwBytesInVB;
            dwPitch = dwBytesInVB;
        }
        else
        {
            // Figure out the pitch and allocate
            switch( pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC )
            {
            case MAKEFOURCC('D', 'X', 'T', '1'):
                dwMultiSamplePitch = (MultiSampleCount *
                                      ((pSGbl->wWidth+3)>>2) *
                                      g_DXTBlkSize[0] + 7) & ~7;
                dwPitch = (((pSGbl->wWidth+3)>>2) * g_DXTBlkSize[0] + 7) & ~7;
                dwHeight = ((pSGbl->wHeight+3)>>2);
                break;
            case MAKEFOURCC('D', 'X', 'T', '2'):
                dwMultiSamplePitch = (MultiSampleCount *
                                      ((pSGbl->wWidth+3)>>2) *
                                      g_DXTBlkSize[1] + 7) & ~7;
                dwPitch = (((pSGbl->wWidth+3)>>2) * g_DXTBlkSize[1] + 7) & ~7;
                dwHeight = ((pSGbl->wHeight+3)>>2);
                break;
            case MAKEFOURCC('D', 'X', 'T', '3'):
                dwMultiSamplePitch = (MultiSampleCount *
                                      ((pSGbl->wWidth+3)>>2) *
                                      g_DXTBlkSize[2] + 7) & ~7;
                dwPitch = (((pSGbl->wWidth+3)>>2) *
                           g_DXTBlkSize[2] + 7) & ~7;
                dwHeight = ((pSGbl->wHeight+3)>>2);
                break;
            case MAKEFOURCC('D', 'X', 'T', '4'):
                dwMultiSamplePitch = (MultiSampleCount *
                                      ((pSGbl->wWidth+3)>>2) *
                                      g_DXTBlkSize[3] + 7) & ~7;
                dwPitch = (((pSGbl->wWidth+3)>>2) *
                           g_DXTBlkSize[3] + 7) & ~7;
                dwHeight = ((pSGbl->wHeight+3)>>2);
                break;
            case MAKEFOURCC('D', 'X', 'T', '5'):
                dwMultiSamplePitch = (MultiSampleCount *
                                      ((pSGbl->wWidth+3)>>2) *
                                      g_DXTBlkSize[4] + 7) & ~7;
                dwPitch = (((pSGbl->wWidth+3)>>2) *
                           g_DXTBlkSize[4] + 7) & ~7;
                dwHeight = ((pSGbl->wHeight+3)>>2);
                break;
            default:
                dwMultiSamplePitch = (MultiSampleCount
                                      * dwBytesPerPixel *
                                      pSGbl->wWidth + 7) & ~7;
                dwPitch = (dwBytesPerPixel *
                           pSGbl->wWidth + 7) & ~7;
                break;
            }

            if (!(pSMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME))
            {
                dwNumBytes = dwPitch * dwHeight;
                if( MultiSampleCount > 1 )
                    dwNumMultiSampleBytes = dwMultiSamplePitch *
                        pSGbl->wHeight;
            }
            else
            {
                _ASSERT( dwMultiSamplePitch == dwPitch,
                         "Cant have multisample for volume textures\n" );
                dwSlicePitch = dwPitch * dwHeight;

                // low word of ddsCaps.ddsCapsEx.dwCaps4 has depth
                // (volume texture only).
                dwNumBytes  = dwSlicePitch *
                    LOWORD(pSMore->ddsCapsEx.dwCaps4);
            }
        }

        pPriv = new RDCREATESURFPRIVATE;
        if( pPriv == NULL )
        {
            DPFERR("Allocation failed");
            pData->ddRVal = DDERR_OUTOFMEMORY;
            break;
        }

        pPriv->pBits = new BYTE[dwNumBytes];
        if( pPriv->pBits == NULL)
        {
            DPFERR("Allocation failed");
            delete pPriv;
            pData->ddRVal = DDERR_OUTOFMEMORY;
            break;
        }
        pPriv->dwPitch                 = dwPitch;

        // Allocate the private MultiSample buffer
        if( dwNumMultiSampleBytes )
        {
            pPriv->pMultiSampleBits = new BYTE[dwNumMultiSampleBytes];
            if( pPriv->pMultiSampleBits == NULL)
            {
                DPFERR("Multisample allocation failed");
                delete pPriv;
                pData->ddRVal = DDERR_OUTOFMEMORY;
                break;
            }
            pPriv->dwMultiSamplePitch = dwMultiSamplePitch;
            pPriv->wSamples = (WORD)MultiSampleCount;
            HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pSLcl)),
                                     &pPriv->SurfaceFormat, NULL));
        }

        // Save the stuff on the surface
        pSGbl->fpVidMem = (FLATPTR)pPriv->pBits;
        if ( isDXT )
        {
            pSGbl->lPitch = dwNumBytes;
            if (pSMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
            {
                // set slice pitch (volume texture only).
                pSGbl->lSlicePitch = dwSlicePitch;
            }
        }
        else
        {
            pSGbl->lPitch = pPriv->dwPitch;
            if (pSMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
            {
                // set slice pitch (volume texture only).
                pSGbl->lSlicePitch = dwSlicePitch;
            }
        }
        pSGbl->dwReserved1 = (ULONG_PTR)pPriv;
    }

    // The loop completed successfully
    if( i == pData->dwSCnt )
        return DDHAL_DRIVER_HANDLED;

    // Else the loop terminated abnormally,
    // Free up allocated memory and quit with the error
    for( j = 0; j < i; j++ )
    {
        pData->lplpSList[j]->lpGbl->lPitch = 0;
        if (pSMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
        {
            pData->lplpSList[j]->lpGbl->lSlicePitch = 0;
        }
        delete (RDCREATESURFPRIVATE *)pData->lplpSList[j]->lpGbl->dwReserved1;
        pData->lplpSList[j]->lpGbl->dwReserved1 = 0;
    }
    return DDHAL_DRIVER_HANDLED;
}


//----------------------------------------------------------------------------
//
// RefRastDestroySurface
//
// Destroy a requested surface.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastDestroySurface(LPDDHAL_DESTROYSURFACEDATA pData)
{
    pData->ddRVal = DD_OK;

    //
    // Validation
    //
    if( pData->lpDDSurface->lpGbl->dwReserved1 == NULL )
    {
        DPFERR("This surface was not created by refrast");
        pData->ddRVal = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    delete (RDCREATESURFPRIVATE *)pData->lpDDSurface->lpGbl->dwReserved1;
    pData->lpDDSurface->lpGbl->dwReserved1 = 0;

    // For vid-mem surfaces, runtime calls this DDI once per entire mip-chain
    // so this needs to be removed.
    // Now free the handle if it has been allocated for this surface
    pData->ddRVal = g_SurfMgr.RemoveSurfFromList(
        pData->lpDDSurface->lpSurfMore->lpDD_lcl,
        pData->lpDDSurface );

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastLock
//
// Locks the given surface.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastLock(LPDDHAL_LOCKDATA pData)
{
    DWORD dwBytesPerPixel = 0;
    LPDDRAWI_DDRAWSURFACE_LCL pSLcl = pData->lpDDSurface;
    LPDDRAWI_DDRAWSURFACE_GBL  pSGbl = pSLcl->lpGbl;
    pData->ddRVal = DD_OK;

    //
    // Validation
    //
    if( pSGbl->dwReserved1 == NULL )
    {
        DPFERR("This surface was not created by refrast");
        pData->ddRVal = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // Obtain the private data
    //
    RDCREATESURFPRIVATE* pPriv =
        (RDCREATESURFPRIVATE *)pSGbl->dwReserved1;

    if (g_RefDDI > RDDDI_DX7HAL)
    {
        // Figure out the device it is being used with.

        // If this is a Multisampled Rendertarget, need to filter down for
        // the runtime.
        if( pPriv->pMultiSampleBits )
        {
            BYTE* pBits   = pPriv->pBits;
            DWORD dwPitch = pPriv->dwPitch;

            BYTE* pMSBits   = pPriv->pMultiSampleBits;
            DWORD dwMSPitch = pPriv->dwMultiSamplePitch;

            RDSurfaceFormat sf = pPriv->SurfaceFormat;
            FLOAT fSampleScale = 1.F/((FLOAT)pPriv->wSamples);

            int width  = (int)DDSurf_Width(pSLcl);
            int height = (int)DDSurf_Height(pSLcl);
            for (int iY = 0; iY < height; iY++)
            {
                for (int iX = 0; iX < width; iX++)
                {
                    RDColor Color((UINT32)0);
                    for (UINT iS=0; iS<pPriv->wSamples; iS++)
                    {
                        RDColor SampleColor;
                        SampleColor.ConvertFrom(
                            sf, PixelAddress( iX, iY, 0, iS,
                                              pMSBits,
                                              dwMSPitch,
                                              0,
                                              pPriv->wSamples,
                                              sf ) );
                        Color.R += (SampleColor.R * fSampleScale);
                        Color.G += (SampleColor.G * fSampleScale);
                        Color.B += (SampleColor.B * fSampleScale);
                        Color.A += (SampleColor.A * fSampleScale);
                    }
                    Color.ConvertTo( sf, 0., PixelAddress( iX, iY, 0, pBits,
                                                           dwPitch, 0, sf ) );
                }
            }
        }
    }

    if( pData->bHasRect )
    {
        // If it is either a 1) VB, 2) IB or 3) CB then the
        // rect has a special meaning. rect.top - rect.bottom
        // gives the range of memory desired.
        // Note: it rect.bottom is the higher address and it is exclusive.
        if( pSLcl->ddsCaps.dwCaps  & DDSCAPS_EXECUTEBUFFER )
        {
            pData->lpSurfData = (LPVOID)(pPriv->pBits + pData->rArea.top);
        }
        else if( pSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME )
        {
            // If it is a volume texture, then the front and back are
            // or'd into the high word of rect->left and rect->right
            // respectively.
            DWORD front  = (pData->rArea.left >> 16);
            DWORD left   = pData->rArea.left & 0x0000ffff;
            DWORD top    = pData->rArea.top;
            DWORD slicePitch = pSGbl->lSlicePitch;
            if( IsDXTn( pSGbl->ddpfSurface.dwFourCC ) )
            {
                _ASSERT( FALSE, "Should not be reached without driver "
                         "managed support" );

            }
            else
            {
                dwBytesPerPixel = pSGbl->ddpfSurface.dwRGBBitCount >> 3;
                pData->lpSurfData = (LPVOID)(pPriv->pBits +
                                             front  * slicePitch +
                                             top    * pPriv->dwPitch +
                                             left   * dwBytesPerPixel);
            }
        }
        else
        {
            if( IsDXTn( pSGbl->ddpfSurface.dwFourCC ) )
            {
                _ASSERT( FALSE, "Should not be reached without driver "
                         "managed support" );

            }
            else
            {
                dwBytesPerPixel = pSGbl->ddpfSurface.dwRGBBitCount >> 3;
                pData->lpSurfData = (LPVOID)(pPriv->pBits +
                                             pData->rArea.top*pPriv->dwPitch +
                                             pData->rArea.left*dwBytesPerPixel);
            }
        }
    }
    else
    {
        pData->lpSurfData = (LPVOID)pPriv->pBits;
    }

    pPriv->Lock();
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastUnlock
//
// Unlocks the given surface.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastUnlock(LPDDHAL_UNLOCKDATA pData)
{
    pData->ddRVal = DD_OK;

    //
    // Validation
    //
    if( pData->lpDDSurface->lpGbl->dwReserved1 == NULL )
    {
        DPFERR("This surface was not created by refrast");
        pData->ddRVal = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // Obtain the private data
    //
    RDCREATESURFPRIVATE* pPriv =
        (RDCREATESURFPRIVATE *)pData->lpDDSurface->lpGbl->dwReserved1;

    pPriv->Unlock();
    return DDHAL_DRIVER_HANDLED;
}


//////////////////////////////////////////////////////////////////////////////
//
// Software DDI interface implementation
//
//////////////////////////////////////////////////////////////////////////////

//
// DX8 DDI caps
//

#define RESPATH_D3DREF  RESPATH_D3D "\\ReferenceDevice"
static void
ModifyDeviceCaps8( void )
{
    HKEY hKey = (HKEY) NULL;
    if( ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3DREF, &hKey) )
    {
        DWORD dwType;
        DWORD dwValue;
        char  dwString[128];
        DWORD dwSize;

        dwSize = sizeof(dwValue);
        if ( (ERROR_SUCCESS == RegQueryValueEx( hKey, "PixelShaderVersion", NULL,
                &dwType, (LPBYTE)&dwValue, &dwSize )) &&
             (dwType == REG_DWORD) )
        {
            g_RefCaps8.PixelShaderVersion = dwValue;
        }
        dwSize = sizeof(dwString);
        if ( (ERROR_SUCCESS == RegQueryValueEx( hKey, "MaxPixelShaderValue", NULL,
                &dwType, (LPBYTE)dwString, &dwSize )) &&
             (dwType == REG_SZ) )
        {
            sscanf( dwString, "%f", &g_RefCaps8.MaxPixelShaderValue );
        }

        RegCloseKey(hKey);
    }


}

static void
FillOutDeviceCaps8( RDDDITYPE ddi )
{
    g_RefCaps8.DevCaps=
        D3DDEVCAPS_EXECUTESYSTEMMEMORY  |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY  |
        D3DDEVCAPS_DRAWPRIMTLVERTEX     |
        D3DDEVCAPS_PUREDEVICE           |
        D3DDEVCAPS_DRAWPRIMITIVES2EX    |
        D3DDEVCAPS_HWVERTEXBUFFER       |
        D3DDEVCAPS_HWINDEXBUFFER        |
        0;

    g_RefCaps8.PrimitiveMiscCaps =
        D3DPMISCCAPS_MASKZ                 |
        D3DPMISCCAPS_LINEPATTERNREP        |
        D3DPMISCCAPS_CULLNONE              |
        D3DPMISCCAPS_CULLCW                |
        D3DPMISCCAPS_CULLCCW               |
        D3DPMISCCAPS_COLORWRITEENABLE      |
        D3DPMISCCAPS_CLIPTLVERTS           |
        D3DPMISCCAPS_TSSARGTEMP            |
        D3DPMISCCAPS_FOGINFVF              |
        D3DPMISCCAPS_BLENDOP               ;

#ifdef __D3D_NULL_REF
    g_RefCaps8.PrimitiveMiscCaps |= D3DPMISCCAPS_NULLREFERENCE;
#endif //__D3D_NULL_REF

    g_RefCaps8.RasterCaps =
        D3DPRASTERCAPS_DITHER              |
        D3DPRASTERCAPS_ZTEST               |
        D3DPRASTERCAPS_FOGVERTEX           |
        D3DPRASTERCAPS_FOGTABLE            |
        D3DPRASTERCAPS_MIPMAPLODBIAS       |
        D3DPRASTERCAPS_PAT                 |
//        D3DPRASTERCAPS_ZBIAS               |
        D3DPRASTERCAPS_FOGRANGE            |
        D3DPRASTERCAPS_ANISOTROPY          |
        D3DPRASTERCAPS_WBUFFER             |
        D3DPRASTERCAPS_WFOG                |
        D3DPRASTERCAPS_ZFOG                |
        D3DPRASTERCAPS_COLORPERSPECTIVE    ;

    g_RefCaps8.ZCmpCaps =
        D3DPCMPCAPS_NEVER        |
        D3DPCMPCAPS_LESS         |
        D3DPCMPCAPS_EQUAL        |
        D3DPCMPCAPS_LESSEQUAL    |
        D3DPCMPCAPS_GREATER      |
        D3DPCMPCAPS_NOTEQUAL     |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS       ;

    g_RefCaps8.SrcBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      |
        D3DPBLENDCAPS_BOTHSRCALPHA     |
        D3DPBLENDCAPS_BOTHINVSRCALPHA  ;

    g_RefCaps8.DestBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      ;

    g_RefCaps8.AlphaCmpCaps =
        D3DPCMPCAPS_NEVER        |
        D3DPCMPCAPS_LESS         |
        D3DPCMPCAPS_EQUAL        |
        D3DPCMPCAPS_LESSEQUAL    |
        D3DPCMPCAPS_GREATER      |
        D3DPCMPCAPS_NOTEQUAL     |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS       ;

    g_RefCaps8.ShadeCaps =
        D3DPSHADECAPS_COLORGOURAUDRGB       |
        D3DPSHADECAPS_SPECULARGOURAUDRGB    |
        D3DPSHADECAPS_ALPHAGOURAUDBLEND     |
        D3DPSHADECAPS_FOGGOURAUD            ;

    g_RefCaps8.TextureCaps =
        D3DPTEXTURECAPS_PERSPECTIVE              |
//        D3DPTEXTURECAPS_POW2                     |
        D3DPTEXTURECAPS_ALPHA                    |
        D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
        D3DPTEXTURECAPS_ALPHAPALETTE             |
        D3DPTEXTURECAPS_PROJECTED                |
        D3DPTEXTURECAPS_CUBEMAP                  |
        D3DPTEXTURECAPS_VOLUMEMAP                |
        D3DPTEXTURECAPS_MIPMAP                   |
        D3DPTEXTURECAPS_MIPVOLUMEMAP             |
        D3DPTEXTURECAPS_MIPCUBEMAP               |
        D3DPTEXTURECAPS_CUBEMAP_POW2             |
        D3DPTEXTURECAPS_VOLUMEMAP_POW2           ;

    g_RefCaps8.TextureFilterCaps =
        D3DPTFILTERCAPS_MINFPOINT           |
        D3DPTFILTERCAPS_MINFLINEAR          |
        D3DPTFILTERCAPS_MINFANISOTROPIC     |
        D3DPTFILTERCAPS_MIPFPOINT           |
        D3DPTFILTERCAPS_MIPFLINEAR          |
        D3DPTFILTERCAPS_MAGFPOINT           |
        D3DPTFILTERCAPS_MAGFLINEAR          |
        D3DPTFILTERCAPS_MAGFANISOTROPIC     ;

    g_RefCaps8.CubeTextureFilterCaps =
        D3DPTFILTERCAPS_MINFPOINT           |
        D3DPTFILTERCAPS_MINFLINEAR          |
        D3DPTFILTERCAPS_MIPFPOINT           |
        D3DPTFILTERCAPS_MIPFLINEAR          |
        D3DPTFILTERCAPS_MAGFPOINT           |
        D3DPTFILTERCAPS_MAGFLINEAR          ;

    g_RefCaps8.VolumeTextureFilterCaps =
        D3DPTFILTERCAPS_MINFPOINT           |
        D3DPTFILTERCAPS_MINFLINEAR          |
        D3DPTFILTERCAPS_MIPFPOINT           |
        D3DPTFILTERCAPS_MIPFLINEAR          |
        D3DPTFILTERCAPS_MAGFPOINT           |
        D3DPTFILTERCAPS_MAGFLINEAR          ;

    g_RefCaps8.TextureAddressCaps =
        D3DPTADDRESSCAPS_WRAP          |
        D3DPTADDRESSCAPS_MIRROR        |
        D3DPTADDRESSCAPS_CLAMP         |
        D3DPTADDRESSCAPS_BORDER        |
        D3DPTADDRESSCAPS_INDEPENDENTUV |
        D3DPTADDRESSCAPS_MIRRORONCE    ;

    g_RefCaps8.VolumeTextureAddressCaps =
        D3DPTADDRESSCAPS_WRAP          |
        D3DPTADDRESSCAPS_MIRROR        |
        D3DPTADDRESSCAPS_CLAMP         |
        D3DPTADDRESSCAPS_BORDER        |
        D3DPTADDRESSCAPS_INDEPENDENTUV |
        D3DPTADDRESSCAPS_MIRRORONCE    ;

    g_RefCaps8.LineCaps =
        D3DLINECAPS_TEXTURE     |
        D3DLINECAPS_ZTEST       |
        D3DLINECAPS_BLEND       |
        D3DLINECAPS_ALPHACMP    |
        D3DLINECAPS_FOG         ;

    g_RefCaps8.MaxTextureWidth  = 4096;
    g_RefCaps8.MaxTextureHeight = 4096;
    g_RefCaps8.MaxVolumeExtent  = 4096;

    g_RefCaps8.MaxTextureRepeat = 32768;
    g_RefCaps8.MaxTextureAspectRatio = 0;
    g_RefCaps8.MaxAnisotropy = 16;
    g_RefCaps8.MaxVertexW = 1.0e10;

    g_RefCaps8.GuardBandLeft   = -32768.f;
    g_RefCaps8.GuardBandTop    = -32768.f;
    g_RefCaps8.GuardBandRight  =  32767.f;
    g_RefCaps8.GuardBandBottom =  32767.f;

    g_RefCaps8.ExtentsAdjust = 0.;
    g_RefCaps8.StencilCaps =
        D3DSTENCILCAPS_KEEP   |
        D3DSTENCILCAPS_ZERO   |
        D3DSTENCILCAPS_REPLACE|
        D3DSTENCILCAPS_INCRSAT|
        D3DSTENCILCAPS_DECRSAT|
        D3DSTENCILCAPS_INVERT |
        D3DSTENCILCAPS_INCR   |
        D3DSTENCILCAPS_DECR;

    g_RefCaps8.FVFCaps = 8 | D3DFVFCAPS_PSIZE;

    g_RefCaps8.TextureOpCaps =
        D3DTEXOPCAPS_DISABLE                   |
        D3DTEXOPCAPS_SELECTARG1                |
        D3DTEXOPCAPS_SELECTARG2                |
        D3DTEXOPCAPS_MODULATE                  |
        D3DTEXOPCAPS_MODULATE2X                |
        D3DTEXOPCAPS_MODULATE4X                |
        D3DTEXOPCAPS_ADD                       |
        D3DTEXOPCAPS_ADDSIGNED                 |
        D3DTEXOPCAPS_ADDSIGNED2X               |
        D3DTEXOPCAPS_SUBTRACT                  |
        D3DTEXOPCAPS_ADDSMOOTH                 |
        D3DTEXOPCAPS_BLENDDIFFUSEALPHA         |
        D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
        D3DTEXOPCAPS_BLENDFACTORALPHA          |
        D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       |
        D3DTEXOPCAPS_BLENDCURRENTALPHA         |
        D3DTEXOPCAPS_PREMODULATE               |
        D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    |
        D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    |
        D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
        D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
        D3DTEXOPCAPS_BUMPENVMAP                |
        D3DTEXOPCAPS_BUMPENVMAPLUMINANCE       |
        D3DTEXOPCAPS_DOTPRODUCT3               |
        D3DTEXOPCAPS_MULTIPLYADD               |
        D3DTEXOPCAPS_LERP                      ;

    g_RefCaps8.MaxTextureBlendStages = 8;
    g_RefCaps8.MaxSimultaneousTextures = 8;

    g_RefCaps8.VertexProcessingCaps      = 0;
    g_RefCaps8.MaxActiveLights           = 0;
    g_RefCaps8.MaxUserClipPlanes         = 0;
    g_RefCaps8.MaxVertexBlendMatrices    = 0;
    g_RefCaps8.MaxVertexBlendMatrixIndex = 0;

    g_RefCaps8.MaxPointSize = RD_MAX_POINT_SIZE;

    g_RefCaps8.MaxPrimitiveCount = 0x001fffff;
    g_RefCaps8.MaxVertexIndex = 0x00ffffff;
    g_RefCaps8.MaxStreams = 1;
    g_RefCaps8.MaxStreamStride = 256;

    g_RefCaps8.VertexShaderVersion  = D3DVS_VERSION(0,0);
    g_RefCaps8.MaxVertexShaderConst = 0;

    g_RefCaps8.PixelShaderVersion   = D3DPS_VERSION(1,4);
    g_RefCaps8.MaxPixelShaderValue  = FLT_MAX;

    // Non 3D Caps
    g_RefCaps8.Caps  = 0;
    g_RefCaps8.Caps2 = DDCAPS2_CANMANAGERESOURCE | DDCAPS2_CANRENDERWINDOWED | DDCAPS2_DYNAMICTEXTURES;

    switch( ddi )
    {
    case RDDDI_DX8TLHAL:
    g_RefCaps8.DevCaps |=
        D3DDEVCAPS_HWTRANSFORMANDLIGHT  |
        D3DDEVCAPS_RTPATCHES            |
        D3DDEVCAPS_RTPATCHHANDLEZERO    |
        D3DDEVCAPS_NPATCHES             |
        D3DDEVCAPS_QUINTICRTPATCHES     |
        0;
        g_RefCaps8.VertexProcessingCaps =
            D3DVTXPCAPS_TEXGEN            |
            D3DVTXPCAPS_MATERIALSOURCE7   |
            D3DVTXPCAPS_DIRECTIONALLIGHTS |
            D3DVTXPCAPS_POSITIONALLIGHTS  |
            D3DVTXPCAPS_TWEENING          |
            D3DVTXPCAPS_LOCALVIEWER       ;
        g_RefCaps8.MaxActiveLights = 0xffffffff;
        g_RefCaps8.MaxUserClipPlanes = RD_MAX_USER_CLIPPLANES;
        g_RefCaps8.MaxVertexBlendMatrices = RD_MAX_BLEND_WEIGHTS;
        g_RefCaps8.MaxVertexBlendMatrixIndex = RD_MAX_WORLD_MATRICES - 1;
        g_RefCaps8.MaxStreams = RD_MAX_NUMSTREAMS;
        g_RefCaps8.VertexShaderVersion  = D3DVS_VERSION(1,1);
        g_RefCaps8.MaxVertexShaderConst = RD_MAX_NUMCONSTREG;
        break;
    }
}


//
// pre-DX8 DDI caps
//

static D3DHAL_GLOBALDRIVERDATA RefGDD = { 0 };
static D3DHAL_D3DEXTENDEDCAPS RefExtCaps = { 0 };

static void
FillOutDeviceCaps( BOOL bIsNullDevice, RDDDITYPE ddi )
{
    //
    //  set device description
    //
    RefGDD.dwSize = sizeof(RefGDD);
    RefGDD.hwCaps.dwDevCaps =
        D3DDEVCAPS_FLOATTLVERTEX        |
        D3DDEVCAPS_EXECUTESYSTEMMEMORY  |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY  |
        D3DDEVCAPS_DRAWPRIMTLVERTEX;

    RefGDD.dwNumVertices = (RD_MAX_VERTEX_COUNT - RD_MAX_CLIP_VERTICES);
    RefGDD.dwNumClipVertices = RD_MAX_CLIP_VERTICES;

    RefGDD.hwCaps.dpcTriCaps.dwSize = sizeof(D3DPRIMCAPS);
    RefGDD.hwCaps.dpcTriCaps.dwMiscCaps =
    D3DPMISCCAPS_MASKZ    |
    D3DPMISCCAPS_CULLNONE |
    D3DPMISCCAPS_CULLCW   |
    D3DPMISCCAPS_CULLCCW  ;
    RefGDD.hwCaps.dpcTriCaps.dwRasterCaps =
        D3DPRASTERCAPS_DITHER                   |
//        D3DPRASTERCAPS_ROP2                     |
//        D3DPRASTERCAPS_XOR                      |
//        D3DPRASTERCAPS_PAT                      |
        D3DPRASTERCAPS_ZTEST                    |
        D3DPRASTERCAPS_SUBPIXEL                 |
        D3DPRASTERCAPS_SUBPIXELX                |
        D3DPRASTERCAPS_FOGVERTEX                |
        D3DPRASTERCAPS_FOGTABLE                 |
//        D3DPRASTERCAPS_STIPPLE                  |
//        D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   |
        D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
//        D3DPRASTERCAPS_ANTIALIASEDGES           |
        D3DPRASTERCAPS_MIPMAPLODBIAS            |
//        D3DPRASTERCAPS_ZBIAS                    |
//        D3DPRASTERCAPS_ZBUFFERLESSHSR           |
        D3DPRASTERCAPS_FOGRANGE                 |
        D3DPRASTERCAPS_ANISOTROPY               |
        D3DPRASTERCAPS_WBUFFER                  |
        D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT |
        D3DPRASTERCAPS_WFOG |
        D3DPRASTERCAPS_ZFOG;
    RefGDD.hwCaps.dpcTriCaps.dwZCmpCaps =
        D3DPCMPCAPS_NEVER        |
        D3DPCMPCAPS_LESS         |
        D3DPCMPCAPS_EQUAL        |
        D3DPCMPCAPS_LESSEQUAL    |
        D3DPCMPCAPS_GREATER      |
        D3DPCMPCAPS_NOTEQUAL     |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS       ;
    RefGDD.hwCaps.dpcTriCaps.dwSrcBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      |
        D3DPBLENDCAPS_BOTHSRCALPHA     |
        D3DPBLENDCAPS_BOTHINVSRCALPHA  ;
    RefGDD.hwCaps.dpcTriCaps.dwDestBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      ;
    RefGDD.hwCaps.dpcTriCaps.dwAlphaCmpCaps =
    RefGDD.hwCaps.dpcTriCaps.dwZCmpCaps;
    RefGDD.hwCaps.dpcTriCaps.dwShadeCaps =
        D3DPSHADECAPS_COLORFLATRGB       |
        D3DPSHADECAPS_COLORGOURAUDRGB    |
        D3DPSHADECAPS_SPECULARFLATRGB    |
        D3DPSHADECAPS_SPECULARGOURAUDRGB |
        D3DPSHADECAPS_ALPHAFLATBLEND     |
        D3DPSHADECAPS_ALPHAGOURAUDBLEND  |
        D3DPSHADECAPS_FOGFLAT            |
        D3DPSHADECAPS_FOGGOURAUD         ;
    RefGDD.hwCaps.dpcTriCaps.dwTextureCaps =
        D3DPTEXTURECAPS_PERSPECTIVE              |
        D3DPTEXTURECAPS_POW2                     |
        D3DPTEXTURECAPS_ALPHA                    |
        D3DPTEXTURECAPS_TRANSPARENCY             |
        D3DPTEXTURECAPS_ALPHAPALETTE             |
        D3DPTEXTURECAPS_BORDER                   |
        D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
        D3DPTEXTURECAPS_ALPHAPALETTE             |
        D3DPTEXTURECAPS_PROJECTED                |
        D3DPTEXTURECAPS_CUBEMAP                  |
        D3DPTEXTURECAPS_COLORKEYBLEND;
    RefGDD.hwCaps.dpcTriCaps.dwTextureFilterCaps =
        D3DPTFILTERCAPS_NEAREST          |
        D3DPTFILTERCAPS_LINEAR           |
        D3DPTFILTERCAPS_MIPNEAREST       |
        D3DPTFILTERCAPS_MIPLINEAR        |
        D3DPTFILTERCAPS_LINEARMIPNEAREST |
        D3DPTFILTERCAPS_LINEARMIPLINEAR  |
        D3DPTFILTERCAPS_MINFPOINT        |
        D3DPTFILTERCAPS_MINFLINEAR       |
        D3DPTFILTERCAPS_MINFANISOTROPIC  |
        D3DPTFILTERCAPS_MIPFPOINT        |
        D3DPTFILTERCAPS_MIPFLINEAR       |
        D3DPTFILTERCAPS_MAGFPOINT        |
        D3DPTFILTERCAPS_MAGFLINEAR       |
        D3DPTFILTERCAPS_MAGFANISOTROPIC  ;
    RefGDD.hwCaps.dpcTriCaps.dwTextureBlendCaps =
        D3DPTBLENDCAPS_DECAL         |
        D3DPTBLENDCAPS_MODULATE      |
        D3DPTBLENDCAPS_DECALALPHA    |
        D3DPTBLENDCAPS_MODULATEALPHA |
        // D3DPTBLENDCAPS_DECALMASK     |
        // D3DPTBLENDCAPS_MODULATEMASK  |
        D3DPTBLENDCAPS_COPY          |
        D3DPTBLENDCAPS_ADD           ;
    RefGDD.hwCaps.dpcTriCaps.dwTextureAddressCaps =
        D3DPTADDRESSCAPS_WRAP          |
        D3DPTADDRESSCAPS_MIRROR        |
        D3DPTADDRESSCAPS_CLAMP         |
        D3DPTADDRESSCAPS_BORDER        |
        D3DPTADDRESSCAPS_INDEPENDENTUV ;
    RefGDD.hwCaps.dpcTriCaps.dwStippleWidth = 0;
    RefGDD.hwCaps.dpcTriCaps.dwStippleHeight = 0;

    //  line caps - copy tricaps and modify
    memcpy( &RefGDD.hwCaps.dpcLineCaps, &RefGDD.hwCaps.dpcTriCaps,
            sizeof(D3DPRIMCAPS) );

    //  disable antialias cap
    RefGDD.hwCaps.dpcLineCaps.dwRasterCaps =
        D3DPRASTERCAPS_DITHER                   |
//        D3DPRASTERCAPS_ROP2                     |
//        D3DPRASTERCAPS_XOR                      |
//        D3DPRASTERCAPS_PAT                      |
        D3DPRASTERCAPS_ZTEST                    |
        D3DPRASTERCAPS_SUBPIXEL                 |
        D3DPRASTERCAPS_SUBPIXELX                |
        D3DPRASTERCAPS_FOGVERTEX                |
        D3DPRASTERCAPS_FOGTABLE                 |
//        D3DPRASTERCAPS_STIPPLE                  |
//        D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   |
//        D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
//        D3DPRASTERCAPS_ANTIALIASEDGES           |
        D3DPRASTERCAPS_MIPMAPLODBIAS            |
//        D3DPRASTERCAPS_ZBIAS                    |
//        D3DPRASTERCAPS_ZBUFFERLESSHSR           |
        D3DPRASTERCAPS_FOGRANGE                 |
        D3DPRASTERCAPS_ANISOTROPY               |
        D3DPRASTERCAPS_WBUFFER                  |
//        D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT |
        D3DPRASTERCAPS_WFOG;

    RefGDD.hwCaps.dwDeviceRenderBitDepth = DDBD_16 | DDBD_24 | DDBD_32;
    RefGDD.hwCaps.dwDeviceZBufferBitDepth = DDBD_16 | DDBD_32;

    //
    //  set extended caps
    //
    RefExtCaps.dwSize = sizeof(RefExtCaps);

    RefExtCaps.dwMinTextureWidth = 1;
    RefExtCaps.dwMaxTextureWidth = 4096;
    RefExtCaps.dwMinTextureHeight = 1;
    RefExtCaps.dwMaxTextureHeight = 4096;
    RefExtCaps.dwMinStippleWidth = 0;   //  stipple unsupported
    RefExtCaps.dwMaxStippleWidth = 0;
    RefExtCaps.dwMinStippleHeight = 0;
    RefExtCaps.dwMaxStippleHeight = 0;

    RefExtCaps.dwMaxTextureRepeat = 32768;
    RefExtCaps.dwMaxTextureAspectRatio = 0; // no limit
    RefExtCaps.dwMaxAnisotropy = 16;

    RefExtCaps.dvGuardBandLeft   = (bIsNullDevice) ? (-2048.f) : (-32768.f);
    RefExtCaps.dvGuardBandTop    = (bIsNullDevice) ? (-2048.f) : (-32768.f);
    RefExtCaps.dvGuardBandRight  = (bIsNullDevice) ? ( 2047.f) : ( 32767.f);
    RefExtCaps.dvGuardBandBottom = (bIsNullDevice) ? ( 2047.f) : ( 32767.f);
    RefExtCaps.dvExtentsAdjust = 0.;    //  AA kernel is 1.0 x 1.0
    RefExtCaps.dwStencilCaps =
        D3DSTENCILCAPS_KEEP   |
        D3DSTENCILCAPS_ZERO   |
        D3DSTENCILCAPS_REPLACE|
        D3DSTENCILCAPS_INCRSAT|
        D3DSTENCILCAPS_DECRSAT|
        D3DSTENCILCAPS_INVERT |
        D3DSTENCILCAPS_INCR   |
        D3DSTENCILCAPS_DECR;
    RefExtCaps.dwFVFCaps = 8;   // max number of tex coord sets
    RefExtCaps.dwTextureOpCaps =
        D3DTEXOPCAPS_DISABLE                   |
        D3DTEXOPCAPS_SELECTARG1                |
        D3DTEXOPCAPS_SELECTARG2                |
        D3DTEXOPCAPS_MODULATE                  |
        D3DTEXOPCAPS_MODULATE2X                |
        D3DTEXOPCAPS_MODULATE4X                |
        D3DTEXOPCAPS_ADD                       |
        D3DTEXOPCAPS_ADDSIGNED                 |
        D3DTEXOPCAPS_ADDSIGNED2X               |
        D3DTEXOPCAPS_SUBTRACT                  |
        D3DTEXOPCAPS_ADDSMOOTH                 |
        D3DTEXOPCAPS_BLENDDIFFUSEALPHA         |
        D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
        D3DTEXOPCAPS_BLENDFACTORALPHA          |
        D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       |
        D3DTEXOPCAPS_BLENDCURRENTALPHA         |
        D3DTEXOPCAPS_PREMODULATE               |
        D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    |
        D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    |
        D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
        D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
        D3DTEXOPCAPS_BUMPENVMAP                |
        D3DTEXOPCAPS_BUMPENVMAPLUMINANCE       |
        D3DTEXOPCAPS_DOTPRODUCT3               ;
    RefExtCaps.wMaxTextureBlendStages = 8;
    RefExtCaps.wMaxSimultaneousTextures = 8;
    RefExtCaps.dwMaxActiveLights = 0xffffffff;
    RefExtCaps.dvMaxVertexW = 1.0e10;

    switch( ddi )
    {
    case RDDDI_DX7TLHAL:
        RefGDD.hwCaps.dwDevCaps |= D3DDEVCAPS_HWTRANSFORMANDLIGHT;
        RefExtCaps.dwVertexProcessingCaps = (D3DVTXPCAPS_TEXGEN            |
                                             D3DVTXPCAPS_MATERIALSOURCE7   |
                                             D3DVTXPCAPS_VERTEXFOG         |
                                             D3DVTXPCAPS_DIRECTIONALLIGHTS |
                                             D3DVTXPCAPS_POSITIONALLIGHTS  |
                                             D3DVTXPCAPS_LOCALVIEWER);
        RefExtCaps.wMaxUserClipPlanes = RD_MAX_USER_CLIPPLANES;
        RefExtCaps.wMaxVertexBlendMatrices = RD_MAX_BLEND_WEIGHTS;
        // Fall throug
    case RDDDI_DX7HAL:
        RefGDD.hwCaps.dwDevCaps |= D3DDEVCAPS_DRAWPRIMITIVES2EX;
    }
}

//----------------------------------------------------------------------------
//
// Pixel formats
//
// Returns all the pixel formats supported by our rasterizer, and what we
// can do with them.
// Called at device creation time.
//
//----------------------------------------------------------------------------

DWORD
GetRefFormatOperations( LPDDSURFACEDESC* lplpddsd )
{
    int i = 0;

    DDSURFACEDESC* ddsd = g_ddsdTex;

    // Here we list our DX8 texture formats.
    // A driver wishing to run against DX7 or earlier runtimes would duplicate
    // entries, placing a list of DDSURFACEDESCs before this list that contain
    // old-style DDPIXELFORMAT structures. Example of old style:
    //    /* 888 */
    //    ddsd[i].dwSize = sizeof(ddsd[0]);
    //    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    //    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    //    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    //    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    //    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    //    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    //    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    //    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;


    //-------------------------- (A)RGB Formats -----------------------------------------

    /* 888 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_R8G8B8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_3DACCELERATION |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* x888 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8R8G8B8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_3DACCELERATION |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* 8888 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8R8G8B8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* 565 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_R5G6B5;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_3DACCELERATION |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* x555 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X1R5G5B5;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_3DACCELERATION |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* 1555 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A1R5G5B5;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    // A formats for PC98 consistency
    // 4444 ARGB (it is already supported by S3 Virge)
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A4R4G4B4;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    // 4444 XRGB
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X4R4G4B4;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    // 332 8-bit RGB
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_R3G3B2;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    // 8332 16-bit ARGB
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8R3G3B2;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    //---------------------------- Palettized formats ------------------------------------
#if 0
    /* pal4 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD)
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES);
    i++;
#endif

    /* A8P8 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8P8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    /* pal8 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_P8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    //-------------------------- alpha/luminance formats -----------------------------------

    /* 8 bit luminance-only */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_L8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    /* 16 bit alpha-luminance */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8L8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    /* 8 bit alpha-luminance */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A4L4;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    /* A8 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    //-------------------------- YUV formats -----------------------------------

    // UYVY
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_UYVY;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // YUY2
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_YUY2;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    //-------------------------- DXT formats -----------------------------------

    // DXT compressed texture format 1
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_DXT1;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // DXT compressed texture format 2
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_DXT2;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;


    // DXT compressed texture format 3
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_DXT3;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;


    // DXT compressed texture format 4
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_DXT4;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;


    // DXT compressed texture format 5
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_DXT5;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    //-------------------------- Bump/luminance formats / Signed formats -----------------

    // V8U8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_V8U8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // L6V5U5
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_L6V5U5;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // X8L8V8U8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8L8V8U8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // V16U16
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_V16U16;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // Q8W8V8U8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_Q8W8V8U8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // W11V11U10
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_W11V11U10;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    //-------------- Formats introduced in DX8.1 -------------------------
#if 0
    // A8B8G8R8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8B8G8R8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // W10V11U11
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_W10V11U11;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // A8X8V8U8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8X8V8U8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // L8X8V8U8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_L8X8V8U8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // X8B8G8R8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8B8G8R8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;
#endif

    // A2W10V10U10
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A2W10V10U10;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // A2B10G10R10
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A2B10G10R10;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // G16R16
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_G16R16;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    //-------------------------- Z/Stencil buffer formats -----------------------------------

    /* 8 bit stencil; 24 bit Z  */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_S8D24;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* 1 bit stencil; 15 bit Z */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_S1D15;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* 4 bit stencil; 24 bit Z  */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_D24X4S4;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    //-------------------------- Z/Stencil/texture + shadow buffer formats -----------------------------------

    // Z16S0
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_D16_LOCKABLE;
    ddsd[i].ddpfPixelFormat.dwOperations =
#if 0
// for Shadow Buffer prototype API
        D3DFORMAT_OP_TEXTURE |
#endif
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;


    // Z32S0
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_D32;
    ddsd[i].ddpfPixelFormat.dwOperations =
#if 0
// for Shadow Buffer prototype API
        D3DFORMAT_OP_TEXTURE |
#endif
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* 24 bit Z  */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8D24;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    //
    // This is an example of a IHV-specific format
    // The HIWORD must be the PCI-ID of the IHV
    // and the third byte must be zero.
    // In this case, we're using a sample PCI-ID of
    // FF00, and we're denoting the 4th format
    // by that PCI-ID.
    //
    // In this case, we're exposing a non-standard Z-buffer format
    // that can be used as a texture and depth-stencil at
    // in the same format.(We are also choosing to
    // disallow it as valid for cubemaps and volumes.)
    //
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) 0xFF000004;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL |
        D3DFORMAT_OP_TEXTURE | 
        D3DFORMAT_OP_PIXELSIZE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 32;    // required for IHV formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    *lplpddsd = ddsd;

    _ASSERT(i<=RD_MAX_NUM_TEXTURE_FORMATS, "Not enough space in static texture list");

    return i;
}

#include <d3d8sddi.h>

HRESULT WINAPI
D3D8GetSWInfo( D3DCAPS8* pCaps, PD3D8_SWCALLBACKS pCallbacks,
               DWORD* pNumTextures, DDSURFACEDESC** ppTexList )
{
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

    // First query the registry to check if we were asked to
    // emulate any particular DDI.
    g_RefDDI = RDDDI_DX8TLHAL;
    HKEY hKey = (HKEY) NULL;
    if( ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey) )
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = sizeof(dwValue);
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "DriverStyle", NULL,
                                               &dwType, (LPBYTE) &dwValue,
                                               &dwSize ) &&
             dwType == REG_DWORD &&
             dwValue > 0
            )
        {
            g_RefDDI = (RDDDITYPE)dwValue;

            // NOTE: RefDev's DDI emulation is currently restricted to
            // DX8 TL and Non-TL HALs only.
            if(  g_RefDDI > RDDDI_DX8TLHAL )
            {
                DPFERR( "Bad Driver style set. Assuming DX8TLHAL" );
                g_RefDDI = RDDDI_DX8TLHAL;
            }
            if(  g_RefDDI < RDDDI_DX8HAL )
            {
                DPFERR( "Bad Driver style set. Assuming DX8HAL" );
                g_RefDDI = RDDDI_DX8HAL;
            }
        }
        RegCloseKey(hKey);
    }

    // NULL out all the callbacks first
    memset( pCallbacks, 0, sizeof(PD3D8_SWCALLBACKS) );

    // These callbacks are needed by everyone
    pCallbacks->CreateContext               = RefRastContextCreate;
    pCallbacks->ContextDestroy              = RefRastContextDestroy;
    pCallbacks->ContextDestroyAll           = NULL;
    pCallbacks->SceneCapture                = RefRastSceneCapture;
    pCallbacks->CreateSurface               = RefRastCreateSurface;
    pCallbacks->Lock                        = RefRastLock;
    pCallbacks->DestroySurface              = RefRastDestroySurface;
    pCallbacks->Unlock                      = RefRastUnlock;

    switch( g_RefDDI )
    {
    case RDDDI_DX8TLHAL:
    case RDDDI_DX8HAL:
    case RDDDI_DX7TLHAL:
    case RDDDI_DX7HAL:
        pCallbacks->GetDriverState              = RefRastGetDriverState;
        pCallbacks->CreateSurfaceEx             = RefRastCreateSurfaceEx;
        // Fall through
    case RDDDI_DP2HAL:
        pCallbacks->ValidateTextureStageState =
            RefRastValidateTextureStageState;
        pCallbacks->DrawPrimitives2           = RefRastDrawPrimitives2;
        pCallbacks->Clear2                    = NULL;
        // Fall through
    case RDDDI_DPHAL:
        pCallbacks->DrawOnePrimitive        = NULL;
        pCallbacks->DrawOneIndexedPrimitive = NULL;
        pCallbacks->DrawPrimitives          = NULL;
        pCallbacks->Clear                   = NULL;
        pCallbacks->SetRenderTarget         = RefRastSetRenderTarget;
        // Fall through
    case RDDDI_OLDHAL:
        pCallbacks->RenderState     = NULL;
        pCallbacks->RenderPrimitive = NULL;
        pCallbacks->TextureCreate   = RefRastTextureCreate;
        pCallbacks->TextureDestroy  = RefRastTextureDestroy;
        pCallbacks->TextureSwap     = NULL;
        pCallbacks->TextureGetSurf  = RefRastTextureGetSurf;
        break;
    default:
        DPFERR( "Unknown DDI style set" );
        return E_FAIL;
    }


    // Now deal with the caps
    FillOutDeviceCaps(FALSE, g_RefDDI);

    // Fill in the supported pixel format operations
    // In DX8 these operations are expressed through the texture
    // format list.
    *pNumTextures = GetRefFormatOperations( ppTexList );

    FillOutDeviceCaps8( g_RefDDI );
    ModifyDeviceCaps8();
    *pCaps = g_RefCaps8;

    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\hop\bezier.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bezier.cpp
 *  Content:    Implementation for Beziers
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// RefDev::ProcessBezier
//-----------------------------------------------------------------------------
HRESULT RefDev::ProcessBezier( DWORD dwOffW, DWORD dwOffH,
                               DWORD dwWidth, DWORD dwHeight,
                               DWORD dwStride, DWORD order,
                               FLOAT *pPrimSegments,
                               bool bDegenerate )
{
    if(order == 0)
    {
        order = 2;
    }
    else
    {
        ++order;
    }

    if(((dwWidth - 1) % (order - 1)) != 0 || ((dwHeight - 1) % (order - 1)) != 0)
    {
        DPFERR("Incorrect order specified for current width or height");
        return DDERR_INVALIDPARAMS;
    }

    RDBezier bz(order, order);

    static const unsigned M[4] = {0, 0, 0, 0}, N[4] = {0, 0, 0, 0};

    unsigned u_segs, v_segs, u_start, v_start;

    if(pPrimSegments != 0)
    {
        u_segs = unsigned(double(unsigned(pPrimSegments[0]) + unsigned(pPrimSegments[2])) / 2.0 + 0.5);
        v_segs = unsigned(double(unsigned(pPrimSegments[1]) + unsigned(pPrimSegments[3])) / 2.0 + 0.5);
        if(u_segs == 0)
        {
            u_segs = 1;
        }
        if(v_segs == 0)
        {
            v_segs = 1;
        }
        if(unsigned(pPrimSegments[0]) != unsigned(pPrimSegments[2]) || unsigned(pPrimSegments[1]) != unsigned(pPrimSegments[3]))
        {
            // First, gulp, the irregular outside
            // To make life easier, we don't want to deal with the case when u_segs or v_segs is one
            // This ensures that there is at least one inside point
            if(u_segs == 1)
            {
                u_segs = 2;
            }
            if(v_segs == 1)
            {
                v_segs = 2;
            }
            // Start with top edge
            unsigned segs = unsigned(pPrimSegments[0]);
            unsigned k_outer = 0;
            unsigned k_inner = 1;
            unsigned outer_inc = u_segs - 2;
            unsigned inner_inc = segs;
            unsigned outer = 0;
            unsigned inner = 0;
            double u0, v0, u1, v1, u2, v2;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer < segs))
            {
                bool D0, D1, D2;
                if(inner < outer)
                {
                    _ASSERT(k_inner < u_segs - 1, "Error in logic");
                    u0 = double(k_inner) / double(u_segs);    
                    v0 = 1.0 / double(v_segs);
                    D0 = false;
                    u1 = double(k_outer) / double(segs);    
                    v1 = 0.0;
                    D1 = bDegenerate;
                    u2 = double(k_inner + 1) / double(u_segs);    
                    v2 = v0;
                    D2 = false;
                    ++k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer < segs, "Error in logic");
                    u0 = double(k_inner) / double(u_segs);    
                    v0 = 1.0 / double(v_segs);
                    D0 = false;
                    u1 = double(k_outer) / double(segs);    
                    v1 = 0.0;
                    D1 = bDegenerate;
                    u2 = double(k_outer + 1) / double(segs);    
                    v2 = v1;
                    D2 = bDegenerate;
                    ++k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bz, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, 
                                         bDegenerate ? u0 * v0 : u0, v0, bDegenerate ? u1 * v1 : u1, v1, bDegenerate ? u2 * v2 : u2, v2, 
                                         D0, D1, D2);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // bottom edge
            segs = unsigned(pPrimSegments[2]);
            k_outer = segs;
            k_inner = u_segs - 1;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer > 0))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner > 1, "Error in logic");
                    u0 = double(k_inner) / double(u_segs);    
                    v0 = double(v_segs - 1) / double(v_segs);
                    u1 = double(k_outer) / double(segs);    
                    v1 = 1.0;
                    u2 = double(k_inner - 1) / double(u_segs);    
                    v2 = v0;
                    --k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer > 0, "Error in logic");
                    u0 = double(k_inner) / double(u_segs);    
                    v0 = double(v_segs - 1) / double(v_segs);
                    u1 = double(k_outer) / double(segs);    
                    v1 = 1.0;
                    u2 = double(k_outer - 1) / double(segs);    
                    v2 = v1;
                    --k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bz, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, 
                                         bDegenerate ? u0 * v0 : u0, v0, bDegenerate ? u1 * v1 : u1, v1, bDegenerate ? u2 * v2 : u2, v2, 
                                         false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // right edge
            segs = unsigned(pPrimSegments[1]);
            k_outer = 0;
            k_inner = 1;
            outer_inc = v_segs - 2;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer < segs))
            {
                bool D1;
                if(inner < outer)
                {
                    _ASSERT(k_inner < v_segs - 1, "Error in logic");
                    u0 = double(u_segs - 1) / double(u_segs);
                    v0 = double(k_inner) / double(v_segs);
                    u1 = 1.0;
                    v1 = double(k_outer) / double(segs);
                    D1 = (k_outer == 0) ? bDegenerate : false;
                    u2 = u0;
                    v2 = double(k_inner + 1) / double(v_segs);    
                    ++k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer < segs, "Error in logic");
                    u0 = double(u_segs - 1) / double(u_segs);
                    v0 = double(k_inner) / double(v_segs);
                    u1 = 1.0;
                    v1 = double(k_outer) / double(segs);
                    D1 = (k_outer == 0) ? bDegenerate : false;
                    u2 = u1;
                    v2 = double(k_outer + 1) / double(segs);    
                    ++k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bz, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, 
                                         bDegenerate ? u0 * v0 : u0, v0, bDegenerate ? u1 * v1 : u1, v1, bDegenerate ? u2 * v2 : u2, v2, 
                                         false, D1, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // left edge
            segs = unsigned(pPrimSegments[3]);
            k_outer = segs;
            k_inner = v_segs - 1;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer > 0))
            {
                bool D1, D2;
                if(inner < outer)
                {
                    _ASSERT(k_inner > 1, "Error in logic");
                    u0 = 1.0 / double(u_segs);
                    v0 = double(k_inner) / double(v_segs);
                    u1 = 0.0;
                    v1 = double(k_outer) / double(segs);
                    D1 = (k_outer == 0) ? bDegenerate : false;
                    u2 = u0;
                    v2 = double(k_inner - 1) / double(v_segs);    
                    D2 = false;
                    --k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer > 0, "Error in logic");
                    u0 = 1.0 / double(u_segs);
                    v0 = double(k_inner) / double(v_segs);
                    u1 = 0.0;
                    v1 = double(k_outer) / double(segs);
                    D1 = false; // since k_outer always > 0
                    u2 = u1;
                    v2 = double(k_outer - 1) / double(segs);    
                    D2 = (k_outer - 1 == 0) ? bDegenerate : false;
                    --k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bz, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, 
                                         bDegenerate ? u0 * v0 : u0, v0, bDegenerate ? u1 * v1 : u1, v1, bDegenerate ? u2 * v2 : u2, v2, 
                                         false, D1, D2);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // Now do the regular interior
            u_start = 1;
            v_start = 1;
        }
        else
        {
            // It can be done regularly
            u_start = 0;
            v_start = 0;
        }
    }
    else
    {
        unsigned segs = unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]);
        if(segs == 0)
        {
            segs = 1;
        }
        u_start = 0;
        v_start = 0;
        u_segs = segs;
        v_segs = segs;
    }

    for(unsigned i = v_start; i < v_segs - v_start; ++i)
    {
        double v0 = double(i) / double(v_segs);
        double v1 = double(i + 1) / double(v_segs);
        for(unsigned j = u_start; j < u_segs - u_start; ++j)
        {
            double u0 = double(j) / double(u_segs);    
            double u1 = double(j + 1) / double(u_segs);    
            if(i == 0 && bDegenerate)
            {
                HRESULT hr = DrawTessTri(bz, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u0, v1, u0 * v0, v0, u1 * v1, v1, u0 * v1, v1, true, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            else
            {
                HRESULT hr = DrawTessQuad(bz, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u0, v0, u1, v1, bDegenerate);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
    }
    
    return S_OK;
}

//-----------------------------------------------------------------------------
// RDBezier::RDBezier
//-----------------------------------------------------------------------------
RDBezier::RDBezier(DWORD dwOrderU, DWORD dwOrderV) 
                    : RDBSpline(dwOrderU, dwOrderV, dwOrderU - 1, dwOrderV - 1)
{
    for(unsigned n = 1; n <= 12; ++n)
    {
        for(unsigned i = 0; i <= n; ++i)
        {
            m_lut[n][i] = double(factorial(n)) / (double(factorial(i)) * double(factorial(n - i)));
        }
    }
}

//-----------------------------------------------------------------------------
// RDBSpline::TexCoordU
//-----------------------------------------------------------------------------
double RDBezier::TexCoordU(double u) const
{
    return u;
}

//-----------------------------------------------------------------------------
// RDBSpline::TexCoordV
//-----------------------------------------------------------------------------
double RDBezier::TexCoordV(double v) const
{
    return v;
}

//-----------------------------------------------------------------------------
// RDBezier::Basis
//-----------------------------------------------------------------------------
double RDBezier::Basis(unsigned i, unsigned n, double t) const
{
    _ASSERT(n < 13, "Order out of range");
    return m_lut[n][i] * pow(t, double(i)) * pow(1.0 - t, double(n - i));
}

//-----------------------------------------------------------------------------
// RDBezier::BasisPrime
//-----------------------------------------------------------------------------
double RDBezier::BasisPrime(unsigned i, unsigned n, double t) const
{
    _ASSERT(n < 13, "Order out of range");
    if(i == 0)
    {
        return m_lut[n][i] * -double(n) * pow(1 - t, n - 1);
    }
    else if(i == n)
    {
        return m_lut[n][i] * double(n) * pow(t, n - 1);
    }
    else
    {
        return (double(i) - double(n) * t) * (m_lut[n][i] * pow(t, double(i) - 1.0) * pow(1.0 - t, double(n - i) - 1.0));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\hop\bspline.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bspline.cpp
 *  Content:    Implementation for B-Splines
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// RefDev::ProcessBSpline
//-----------------------------------------------------------------------------
HRESULT RefDev::ProcessBSpline( DWORD dwOffW, DWORD dwOffH,
                                DWORD dwWidth, DWORD dwHeight,
                                DWORD dwStride, DWORD order,
                                FLOAT *pPrimSegments )
{
    if(order == 0)
    {
        order = 2;
    }
    else
    {
        ++order;
    }

    int u_range = dwWidth - (order - 1);
    int v_range = dwHeight - (order - 1);

    if(u_range <= 0 || v_range <= 0)
    {
        DPFERR("Insufficient control vertices for current order");
        return DDERR_INVALIDPARAMS;
    }

    RDBSpline bsp(dwWidth, dwHeight, order, order);

    static const unsigned M[4] = {0, 0, 0, 0}, N[4] = {0, 0, 0, 0};

    unsigned u_segs, v_segs, u_start, v_start;

    if(pPrimSegments != 0)
    {
        u_segs = unsigned(double(unsigned(pPrimSegments[0]) + unsigned(pPrimSegments[2])) / 2.0 + 0.5);
        v_segs = unsigned(double(unsigned(pPrimSegments[1]) + unsigned(pPrimSegments[3])) / 2.0 + 0.5);
        if(u_segs == 0)
        {
            u_segs = 1;
        }
        if(v_segs == 0)
        {
            v_segs = 1;
        }
        if(unsigned(pPrimSegments[0]) != unsigned(pPrimSegments[2]) || unsigned(pPrimSegments[1]) != unsigned(pPrimSegments[3]))
        {
            // First, gulp, the irregular outside
            // To make life easier, we don't want to deal with the case when u_segs or v_segs is one
            // This ensures that there is at least one inside point
            if(u_segs == 1)
            {
                u_segs = 2;
            }
            if(v_segs == 1)
            {
                v_segs = 2;
            }
            // Start with top edge
            unsigned segs = unsigned(pPrimSegments[0]);
            unsigned k_outer = 0;
            unsigned k_inner = 1;
            unsigned outer_inc = u_segs - 2;
            unsigned inner_inc = segs;
            unsigned outer = 0;
            unsigned inner = 0;
            double u0, v0, u1, v1, u2, v2;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer < segs))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner < u_segs - 1, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + double(order - 1);    
                    v0 = double(v_range) / double(v_segs) + double(order - 1);
                    u1 = double(u_range * k_outer) / double(segs) + double(order - 1);    
                    v1 = double(order - 1);
                    u2 = double(u_range * (k_inner + 1)) / double(u_segs) + double(order - 1);    
                    v2 = v0;
                    ++k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer < segs, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + double(order - 1);    
                    v0 = double(v_range) / double(v_segs) + double(order - 1);
                    u1 = double(u_range * k_outer) / double(segs) + double(order - 1);    
                    v1 = double(order - 1);
                    u2 = double(u_range * (k_outer + 1)) / double(segs) + double(order - 1);    
                    v2 = v1;
                    ++k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bsp, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2,
                                         bsp.TexCoordU(u0), bsp.TexCoordV(v0),
                                         bsp.TexCoordU(u1), bsp.TexCoordV(v1),
                                         bsp.TexCoordU(u2), bsp.TexCoordV(v2),
                                         false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // bottom edge
            segs = unsigned(pPrimSegments[2]);
            k_outer = segs;
            k_inner = u_segs - 1;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer > 0))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner > 1, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + double(order - 1);    
                    v0 = double(v_range * (v_segs - 1)) / double(v_segs) + double(order - 1);
                    u1 = double(u_range * k_outer) / double(segs) + double(order - 1);    
                    v1 = double(v_range + order - 1);
                    u2 = double(u_range * (k_inner - 1)) / double(u_segs) + double(order - 1);    
                    v2 = v0;
                    --k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer > 0, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + double(order - 1);    
                    v0 = double(v_range * (v_segs - 1)) / double(v_segs) + double(order - 1);
                    u1 = double(u_range * k_outer) / double(segs) + double(order - 1);    
                    v1 = double(v_range + order - 1);
                    u2 = double(u_range * (k_outer - 1)) / double(segs) + double(order - 1);    
                    v2 = v1;
                    --k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bsp, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2,
                                         bsp.TexCoordU(u0), bsp.TexCoordV(v0),
                                         bsp.TexCoordU(u1), bsp.TexCoordV(v1),
                                         bsp.TexCoordU(u2), bsp.TexCoordV(v2),
                                         false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // right edge
            segs = unsigned(pPrimSegments[1]);
            k_outer = 0;
            k_inner = 1;
            outer_inc = v_segs - 2;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer < segs))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner < v_segs - 1, "Error in logic");
                    u0 = double(u_range * (u_segs - 1)) / double(u_segs) + double(order - 1);
                    v0 = double(v_range * k_inner) / double(v_segs) + double(order - 1);
                    u1 = double(u_range + order - 1);
                    v1 = double(v_range * k_outer) / double(segs) + double(order - 1);
                    u2 = u0;
                    v2 = double(v_range * (k_inner + 1)) / double(v_segs) + double(order - 1);    
                    ++k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer < segs, "Error in logic");
                    u0 = double(u_range * (u_segs - 1)) / double(u_segs) + double(order - 1);
                    v0 = double(v_range * k_inner) / double(v_segs) + double(order - 1);
                    u1 = double(u_range + order - 1);
                    v1 = double(v_range * k_outer) / double(segs) + double(order - 1);
                    u2 = u1;
                    v2 = double(v_range * (k_outer + 1)) / double(segs) + double(order - 1);    
                    ++k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bsp, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2,
                                         bsp.TexCoordU(u0), bsp.TexCoordV(v0),
                                         bsp.TexCoordU(u1), bsp.TexCoordV(v1),
                                         bsp.TexCoordU(u2), bsp.TexCoordV(v2),
                                         false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // left edge
            segs = unsigned(pPrimSegments[3]);
            k_outer = segs;
            k_inner = v_segs - 1;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer > 0))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner > 1, "Error in logic");
                    u0 = double(u_range) / double(u_segs) + double(order - 1);
                    v0 = double(v_range * k_inner) / double(v_segs) + double(order - 1);
                    u1 = double(order - 1);
                    v1 = double(v_range * k_outer) / double(segs) + double(order - 1);
                    u2 = u0;
                    v2 = double(v_range * (k_inner - 1)) / double(v_segs) + double(order - 1);    
                    --k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer > 0, "Error in logic");
                    u0 = double(u_range) / double(u_segs) + double(order - 1);
                    v0 = double(v_range * k_inner) / double(v_segs) + double(order - 1);
                    u1 = double(order - 1);
                    v1 = double(v_range * k_outer) / double(segs) + double(order - 1);
                    u2 = u1;
                    v2 = double(v_range * (k_outer - 1)) / double(segs) + double(order - 1);    
                    --k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bsp, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2,
                                         bsp.TexCoordU(u0), bsp.TexCoordV(v0),
                                         bsp.TexCoordU(u1), bsp.TexCoordV(v1),
                                         bsp.TexCoordU(u2), bsp.TexCoordV(v2),
                                         false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // Now do the regular interior
            u_start = 1;
            v_start = 1;
        }
        else
        {
            // It can be done regularly
            u_start = 0;
            v_start = 0;
        }
    }
    else
    {
        unsigned segs = unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]);
        if(segs == 0)
        {
            segs = 1;
        }
        u_start = 0;
        v_start = 0;
        u_segs = segs;
        v_segs = segs;
    }

    for(unsigned i = v_start; i < v_segs - v_start; ++i)
    {
        double v0 = double(v_range * i) / double(v_segs) + double(order - 1);
        double v1 = double(v_range * (i + 1)) / double(v_segs) + double(order - 1);
        for(unsigned j = u_start; j < u_segs - u_start; ++j)
        {
            double u0 = double(u_range * j) / double(u_segs) + double(order - 1);    
            double u1 = double(u_range * (j + 1)) / double(u_segs) + double(order - 1);    
            HRESULT hr = DrawTessQuad(bsp, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1,
                                      bsp.TexCoordU(u0), bsp.TexCoordV(v0),
                                      bsp.TexCoordU(u1), bsp.TexCoordV(v1),
                                      false);
            if(FAILED(hr))
            {
                return hr;
            }
        }
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// RDBSpline::Sample
//-----------------------------------------------------------------------------
void RDBSpline::Sample(DWORD dwDataType, double u, double v, const BYTE *pRow, DWORD dwStride, DWORD dwPitch, BYTE *Q) const
{
    double Acc[4] = {0.0, 0.0, 0.0, 0.0};
    unsigned dwElements = 0;
    switch(dwDataType)
    {
        case D3DVSDT_FLOAT4:
            ++dwElements;
        case D3DVSDT_FLOAT3:
            ++dwElements;
        case D3DVSDT_FLOAT2:
            ++dwElements;
        case D3DVSDT_FLOAT1:
            ++dwElements;
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double N = Basis(i, m_dwOrderV, v);
                    const BYTE *pCol = pRow;
                    for(unsigned j = 0; j < m_dwWidth; ++j)
                    {
                        double NM = N * Basis(j, m_dwOrderU, u);
                        const FLOAT *B = (FLOAT*)pCol;
                        for(unsigned e = 0; e < dwElements; ++e)
                        {
                            Acc[e] += double(B[e]) * NM;
                        }
                        pCol += dwStride;
                    }
                    pRow += dwPitch;
                }
                for(unsigned e = 0; e < dwElements; ++e)
                {
                    ((FLOAT*)Q)[e] = FLOAT(Acc[e]);
                }
            }
            break;
        case D3DVSDT_D3DCOLOR:
        case D3DVSDT_UBYTE4:
            dwElements = 4;
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double N = Basis(i, m_dwOrderV, v);
                    const BYTE *pCol = pRow;
                    for(unsigned j = 0; j < m_dwWidth; ++j)
                    {
                        double NM = N * Basis(j, m_dwOrderU, u);
                        const BYTE *B = pCol;
                        for(unsigned e = 0; e < 4; ++e)
                        {
                            Acc[e] += double(B[e]) * NM;
                        }
                        pCol += dwStride;
                    }
                    pRow += dwPitch;
                }
                for(unsigned e = 0; e < 4; ++e)
                {
                    int t = int(Acc[e]);
                    Q[e] = BYTE(t < 0 ? 0 : (t > 255 ? 255 : t));
                }
            }
            break;
        case D3DVSDT_SHORT4:
            dwElements += 2;
        case D3DVSDT_SHORT2:
            dwElements += 2;
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double N = Basis(i, m_dwOrderV, v);
                    const BYTE *pCol = pRow;
                    for(unsigned j = 0; j < m_dwWidth; ++j)
                    {
                        double NM = N * Basis(j, m_dwOrderU, u);
                        const SHORT *B = (SHORT*)pCol;
                        for(unsigned e = 0; e < dwElements; ++e)
                        {
                            Acc[e] += double(B[e]) * NM;
                        }
                        pCol += dwStride;
                    }
                    pRow += dwPitch;
                }
                for(unsigned e = 0; e < dwElements; ++e)
                {
                    ((SHORT*)Q)[e] = SHORT(Acc[e]);
                }
            }
            break;
        default:
            _ASSERT(FALSE, "Ununderstood vertex element data type");
    }
}

//-----------------------------------------------------------------------------
// RDBSpline::SampleNormal
//-----------------------------------------------------------------------------
void RDBSpline::SampleNormal(DWORD dwDataType, double u, double v, const BYTE *pRow, DWORD dwStride, DWORD dwPitch, BYTE *Q) const
{
    double Acc[2][3] = {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
    // Fudge u and v if they are on the boundary. This is because the derivative is discontinuous on the boundary
    // and we really want it to be slightly inside the boundary.
    if(v == double(m_dwHeight))
    {
        v -= v * DBL_EPSILON;
    }
    if(u == double(m_dwWidth))
    {
        u -= u * DBL_EPSILON;
    }
    switch(dwDataType)
    {
        case D3DVSDT_FLOAT4:
        case D3DVSDT_FLOAT3:
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double N      = Basis(i, m_dwOrderV, v);
                    double NPrime = BasisPrime(i, m_dwOrderV, v);
                    const BYTE *pCol = pRow;
                    for(unsigned j = 0; j < m_dwWidth; ++j)
                    {
                        double NMPrime = N      * BasisPrime(j, m_dwOrderU, u);
                        double NPrimeM = NPrime * Basis(j, m_dwOrderU, u);
                        const FLOAT *B = (FLOAT*)pCol;
                        for(unsigned e = 0; e < 3; ++e)
                        {
                            Acc[0][e] += double(B[e]) * NMPrime;
                            Acc[1][e] += double(B[e]) * NPrimeM;
                        }
                        pCol += dwStride;
                    }
                    pRow += dwPitch;
                }
                ((FLOAT*)Q)[0] = FLOAT(Acc[0][1] * Acc[1][2] - Acc[0][2] * Acc[1][1]);
                ((FLOAT*)Q)[1] = FLOAT(Acc[0][2] * Acc[1][0] - Acc[0][0] * Acc[1][2]);
                ((FLOAT*)Q)[2] = FLOAT(Acc[0][0] * Acc[1][1] - Acc[0][1] * Acc[1][0]);
            }
            break;
        case D3DVSDT_D3DCOLOR:
        case D3DVSDT_UBYTE4:
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double N      = Basis(i, m_dwOrderV, v);
                    double NPrime = BasisPrime(i, m_dwOrderV, v);
                    const BYTE *pCol = pRow;
                    for(unsigned j = 0; j < m_dwWidth; ++j)
                    {
                        double NMPrime = N      * BasisPrime(j, m_dwOrderU, u);
                        double NPrimeM = NPrime * Basis(j, m_dwOrderU, u);
                        const BYTE *B = pCol;
                        for(unsigned e = 0; e < 3; ++e)
                        {
                            Acc[0][e] += double(B[e]) * NMPrime;
                            Acc[1][e] += double(B[e]) * NPrimeM;
                        }
                        pCol += dwStride;
                    }
                    pRow += dwPitch;
                }
                ((FLOAT*)Q)[0] = FLOAT(Acc[0][1] * Acc[1][2] - Acc[0][2] * Acc[1][1]);
                ((FLOAT*)Q)[1] = FLOAT(Acc[0][2] * Acc[1][0] - Acc[0][0] * Acc[1][2]);
                ((FLOAT*)Q)[2] = FLOAT(Acc[0][0] * Acc[1][1] - Acc[0][1] * Acc[1][0]);
            }
            break;
        case D3DVSDT_SHORT4:
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double N      = Basis(i, m_dwOrderV, v);
                    double NPrime = BasisPrime(i, m_dwOrderV, v);
                    const BYTE *pCol = pRow;
                    for(unsigned j = 0; j < m_dwWidth; ++j)
                    {
                        double NMPrime = N      * BasisPrime(j, m_dwOrderU, u);
                        double NPrimeM = NPrime * Basis(j, m_dwOrderU, u);
                        const SHORT *B = (SHORT*)pCol;
                        for(unsigned e = 0; e < 3; ++e)
                        {
                            Acc[0][e] += double(B[e]) * NMPrime;
                            Acc[1][e] += double(B[e]) * NPrimeM;
                        }
                        pCol += dwStride;
                    }
                    pRow += dwPitch;
                }
                ((FLOAT*)Q)[0] = FLOAT(Acc[0][1] * Acc[1][2] - Acc[0][2] * Acc[1][1]);
                ((FLOAT*)Q)[1] = FLOAT(Acc[0][2] * Acc[1][0] - Acc[0][0] * Acc[1][2]);
                ((FLOAT*)Q)[2] = FLOAT(Acc[0][0] * Acc[1][1] - Acc[0][1] * Acc[1][0]);
            }
            break;
        case D3DVSDT_SHORT2:
        case D3DVSDT_FLOAT2:
        case D3DVSDT_FLOAT1:
        default:
            _ASSERT(FALSE, "Ununderstood vertex element data type");
    }
}

//-----------------------------------------------------------------------------
// RDBSpline::SampleDegenerateNormal
//-----------------------------------------------------------------------------
void RDBSpline::SampleDegenerateNormal(DWORD dwDataType, const BYTE *pRow, DWORD dwStride, DWORD dwPitch, BYTE *Q) const
{
    double Acc[2][3] = {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
    switch(dwDataType)
    {
        case D3DVSDT_FLOAT4:
        case D3DVSDT_FLOAT3:
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double JPrime = BasisPrime(i, m_dwOrderV, 0.0);
                    const FLOAT *B1 = (FLOAT*)pRow;
                    const FLOAT *B2 = (FLOAT*)(pRow + (m_dwWidth - 1) * dwStride);
                    for(unsigned e = 0; e < 3; ++e)
                    {
                        Acc[0][e] += double(B2[e]) * JPrime;
                        Acc[1][e] += double(B1[e]) * JPrime;
                    }
                    pRow += dwPitch;
                }
                ((FLOAT*)Q)[0] = FLOAT(Acc[0][1] * Acc[1][2] - Acc[0][2] * Acc[1][1]);
                ((FLOAT*)Q)[1] = FLOAT(Acc[0][2] * Acc[1][0] - Acc[0][0] * Acc[1][2]);
                ((FLOAT*)Q)[2] = FLOAT(Acc[0][0] * Acc[1][1] - Acc[0][1] * Acc[1][0]);
            }
            break;
        case D3DVSDT_D3DCOLOR:
        case D3DVSDT_UBYTE4:
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double JPrime = BasisPrime(i, m_dwOrderV, 0.0);
                    const BYTE *B1 = pRow;
                    const BYTE *B2 = pRow + (m_dwWidth - 1) * dwStride;
                    for(unsigned e = 0; e < 3; ++e)
                    {
                        Acc[0][e] += double(B2[e]) * JPrime;
                        Acc[1][e] += double(B1[e]) * JPrime;
                    }
                    pRow += dwPitch;
                }
                ((FLOAT*)Q)[0] = FLOAT(Acc[0][1] * Acc[1][2] - Acc[0][2] * Acc[1][1]);
                ((FLOAT*)Q)[1] = FLOAT(Acc[0][2] * Acc[1][0] - Acc[0][0] * Acc[1][2]);
                ((FLOAT*)Q)[2] = FLOAT(Acc[0][0] * Acc[1][1] - Acc[0][1] * Acc[1][0]);
            }
            break;
        case D3DVSDT_SHORT4:
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double JPrime = BasisPrime(i, m_dwOrderV, 0.0);
                    const SHORT *B1 = (SHORT*)pRow;
                    const SHORT *B2 = (SHORT*)(pRow + (m_dwWidth - 1) * dwStride);
                    for(unsigned e = 0; e < 3; ++e)
                    {
                        Acc[0][e] += double(B2[e]) * JPrime;
                        Acc[1][e] += double(B1[e]) * JPrime;
                    }
                    pRow += dwPitch;
                }
                ((FLOAT*)Q)[0] = FLOAT(Acc[0][1] * Acc[1][2] - Acc[0][2] * Acc[1][1]);
                ((FLOAT*)Q)[1] = FLOAT(Acc[0][2] * Acc[1][0] - Acc[0][0] * Acc[1][2]);
                ((FLOAT*)Q)[2] = FLOAT(Acc[0][0] * Acc[1][1] - Acc[0][1] * Acc[1][0]);
            }
            break;
        case D3DVSDT_FLOAT2:
        case D3DVSDT_FLOAT1:
        case D3DVSDT_SHORT2:
        default:
            _ASSERT(FALSE, "Ununderstood vertex element data type");
    }
}

//-----------------------------------------------------------------------------
// RDBSpline::Basis
//-----------------------------------------------------------------------------
double RDBSpline::Basis(unsigned i, unsigned k, double s) const
{
    if(k == 1)
    {
        if(Knot(i) <= s && s < Knot(i + 1))
        {
            return 1.0;
        }
        else
        {
            return 0.0;
        }
    }
    else
    {
        _ASSERT(k != 0, "Arithmatic error in RDBSpline::Basis");
        return ((s - Knot(i)) * Basis(i, k - 1, s)) / (Knot(i + k - 1) - Knot(i)) + 
               ((Knot(i + k) - s) * Basis(i + 1, k - 1, s)) / (Knot(i + k) - Knot(i + 1));
    }
}

//-----------------------------------------------------------------------------
// RDBSpline::BasisPrime
//-----------------------------------------------------------------------------
double RDBSpline::BasisPrime(unsigned i, unsigned k, double s) const
{
    if(k == 1)
    {
        return 0.0;
    }
    else
    {
        _ASSERT(k != 0, "Arithmatic error in RDBSpline::BasisPrime");
        return (Basis(i, k - 1, s) + (s - Knot(i)) * BasisPrime(i, k - 1, s)) / (Knot(i + k - 1) - Knot(i)) + 
               ((Knot(i + k) - s) * BasisPrime(i + 1, k - 1, s) - Basis(i + 1, k - 1, s)) / (Knot(i + k) - Knot(i + 1));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\hop\catrom.hpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       catrom.hpp
 *  Content:    Declarations for Catmull-Rom splines
 *
 ****************************************************************************/

#ifndef _CATROM_HPP
#define _CATROM_HPP

#include "bspline.hpp"

class RDCatRomSpline : public RDBSpline
{
public:
    RDCatRomSpline() : RDBSpline(4, 4, 4, 4) {}

    double TexCoordU(double u) const;
    double TexCoordV(double v) const;

private:
    virtual double Basis(unsigned i, unsigned n, double t) const;
    virtual double BasisPrime(unsigned i, unsigned n, double t) const;
};

#endif // _CATROM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\hop\catrom.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       catrom.cpp
 *  Content:    Implementation for Catmull-Rom splines
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// RefDev::ProcessCatRomSpline
//-----------------------------------------------------------------------------
HRESULT RefDev::ProcessCatRomSpline( DWORD dwOffW, DWORD dwOffH,
                                                  DWORD dwWidth, DWORD dwHeight,
                                                  DWORD dwStride,
                                                  FLOAT *pPrimSegments )
{
    int u_range = dwWidth - 3;
    int v_range = dwHeight - 3;

    if(u_range <= 0 || v_range <= 0)
    {
        DPFERR("A Catmull-Rom spline needs at least 16 control points");
        return DDERR_INVALIDPARAMS;
    }

    RDCatRomSpline catrom;

    unsigned M[4], N[4];

    unsigned u_segs, v_segs, u_start, v_start;

    if(pPrimSegments != 0)
    {
        u_segs = unsigned(double(unsigned(pPrimSegments[0]) + unsigned(pPrimSegments[2])) / 2.0 + 0.5);
        v_segs = unsigned(double(unsigned(pPrimSegments[1]) + unsigned(pPrimSegments[3])) / 2.0 + 0.5);
        if(u_segs == 0)
        {
            u_segs = 1;
        }
        if(v_segs == 0)
        {
            v_segs = 1;
        }
        if(unsigned(pPrimSegments[0]) != unsigned(pPrimSegments[2]) || unsigned(pPrimSegments[1]) != unsigned(pPrimSegments[3]))
        {
            // First, gulp, the irregular outside
            // To make life easier, we don't want to deal with the case when u_segs or v_segs is one
            // This ensures that there is at least one inside point
            if(u_segs == 1)
            {
                u_segs = 2;
            }
            if(v_segs == 1)
            {
                v_segs = 2;
            }
            // Start with top edge
            unsigned segs = unsigned(pPrimSegments[0]);
            unsigned k_outer = 0;
            unsigned k_inner = 1;
            unsigned outer_inc = u_segs - 2;
            unsigned inner_inc = segs;
            unsigned outer = 0;
            unsigned inner = 0;
            double u0, v0, u1, v1, u2, v2, tu0, tv0, tu1, tv1, tu2, tv2;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer < segs))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner < u_segs - 1, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + 3.0;    
                    v0 = double(v_range) / double(v_segs) + 3.0;
                    u1 = double(u_range * k_outer) / double(segs) + 3.0;    
                    v1 = 0.0;
                    u2 = double(u_range * (k_inner + 1)) / double(u_segs) + 3.0;    
                    v2 = v0;
                    tu0 = double(k_inner) / double(u_segs);    
                    tv0 = 1.0 / double(v_segs);
                    tu1 = double(k_outer) / double(segs);    
                    tv1 = 0.0;
                    tu2 = double(k_inner + 1) / double(u_segs);    
                    tv2 = tv0;

                    M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u0 -= floor(u0);
                    if((u_range * k_outer) % segs == 0)
                    {
                        M[1] = unsigned(u1) - 4;
                        u1 = 1.0;
                    }
                    else
                    {
                        M[1] = unsigned(u1) - 3; // unsigned(u1) == floor(u1)
                        u1 -= floor(u1);
                    }
                    M[2] = unsigned(u2) - 3; // unsigned(u2) == floor(u2)
                    u2 -= floor(u2);
                    N[2] = N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v2 = v0 = v0 - floor(v0);
                    N[1] = 0;

                    ++k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer < segs, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + 3.0;    
                    v0 = double(v_range) / double(v_segs) + 3.0;
                    u1 = double(u_range * k_outer) / double(segs) + 3.0;    
                    v1 = 0.0;
                    u2 = double(u_range * (k_outer + 1)) / double(segs) + 3.0;    
                    v2 = v1;
                    tu0 = double(k_inner) / double(u_segs);    
                    tv0 = 1.0 / double(v_segs);
                    tu1 = double(k_outer) / double(segs);    
                    tv1 = 0.0;
                    tu2 = double(k_outer + 1) / double(segs);    
                    tv2 = tv1;

                    if((u_range * k_inner) % u_segs == 0)
                    {
                        M[0] = unsigned(u0) - 4;
                        u0 = 1.0;
                    }
                    else
                    {
                        M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                        u0 -= floor(u0);
                    }
                    M[1] = unsigned(u1) - 3; // unsigned(u1) == floor(u1)
                    u1 -= floor(u1);
                    if((u_range * (k_outer + 1)) % segs == 0)
                    {
                        M[2] = unsigned(u2) - 4;
                        u2 = 1.0;
                    }
                    else
                    {
                        M[2] = unsigned(u2) - 3; // unsigned(u2) == floor(u2)
                        u2 -= floor(u2);
                    }
                    N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v0 -= floor(v0);
                    N[2] = N[1] = 0;

                    ++k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(catrom, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, tu0, tv0, tu1, tv1, tu2, tv2, false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // bottom edge
            segs = unsigned(pPrimSegments[2]);
            k_outer = segs;
            k_inner = u_segs - 1;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer > 0))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner > 1, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + 3.0;    
                    v0 = double(v_range * (v_segs - 1)) / double(v_segs) + 3.0;
                    u1 = double(u_range * k_outer) / double(segs) + 3.0;    
                    v1 = double(v_range + 3);
                    u2 = double(u_range * (k_inner - 1)) / double(u_segs) + 3.0;    
                    v2 = v0;
                    tu0 = double(k_inner) / double(u_segs);    
                    tv0 = double(v_segs - 1) / double(v_segs);
                    tu1 = double(k_outer) / double(segs);    
                    tv1 = 1.0;
                    tu2 = double(k_inner - 1) / double(u_segs);    
                    tv2 = tv0;
        
                    M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u0 -= floor(u0);
                    if((u_range * k_outer) % segs == 0)
                    {
                        M[1] = unsigned(u1) - 4;
                        u1 = 1.0;
                    }
                    else
                    {
                        M[1] = unsigned(u1) - 3; // unsigned(u1) == floor(u1)
                        u1 -= floor(u1);
                    }
                    M[2] = unsigned(u2) - 3; // unsigned(u2) == floor(u2)
                    u2 -= floor(u2);
                    N[2] = N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v2 = v0 = v0 - floor(v0);
                    N[1] = dwHeight - 4;
                    v1 = 1.0;

                    --k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer > 0, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + 3.0;    
                    v0 = double(v_range * (v_segs - 1)) / double(v_segs) + 3.0;
                    u1 = double(u_range * k_outer) / double(segs) + 3.0;    
                    v1 = double(v_range + 3);
                    u2 = double(u_range * (k_outer - 1)) / double(segs) + 3.0;    
                    v2 = v1;
                    tu0 = double(k_inner) / double(u_segs);    
                    tv0 = double(v_segs - 1) / double(v_segs);
                    tu1 = double(k_outer) / double(segs);    
                    tv1 = 1.0;
                    tu2 = double(k_outer - 1) / double(segs);    
                    tv2 = tv1;

                    M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u0 -= floor(u0);
                    if((u_range * k_outer) % segs == 0)
                    {
                        M[1] = unsigned(u1) - 4;
                        u1 = 1.0;
                    }
                    else
                    {
                        M[1] = unsigned(u1) - 3; // unsigned(u1) == floor(u1)
                        u1 -= floor(u1);
                    }
                    M[2] = unsigned(u2) - 3; // unsigned(u2) == floor(u2)
                    u2 -= floor(u2);
                    N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v0 -= floor(v0);
                    N[2] = N[1] = dwHeight - 4;
                    v2 = v1 = 1.0;

                    --k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(catrom, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, tu0, tv0, tu1, tv1, tu2, tv2, false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // right edge
            segs = unsigned(pPrimSegments[1]);
            k_outer = 0;
            k_inner = 1;
            outer_inc = v_segs - 2;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer < segs))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner < v_segs - 1, "Error in logic");
                    u0 = double(u_range * (u_segs - 1)) / double(u_segs) + 3.0;
                    v0 = double(v_range * k_inner) / double(v_segs) + 3.0;
                    u1 = double(u_range + 3);
                    v1 = double(v_range * k_outer) / double(segs) + 3.0;
                    u2 = u0;
                    v2 = double(v_range * (k_inner + 1)) / double(v_segs) + 3.0;    
                    tu0 = double(u_segs - 1) / double(u_segs);
                    tv0 = double(k_inner) / double(v_segs);
                    tu1 = 1.0;
                    tv1 = double(k_outer) / double(segs);
                    tu2 = tu0;
                    tv2 = double(k_inner + 1) / double(v_segs);    

                    M[2] = M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u2 = u0 = u0 - floor(u0);
                    M[1] = dwWidth - 4;
                    u1 = 1.0;
                    N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v0 -= floor(v0);
                    if((v_range * k_outer) % segs == 0)
                    {
                        N[1] = unsigned(v1) - 4;
                        v1 = 1.0;
                    }
                    else
                    {
                        N[1] = unsigned(v1) - 3; // unsigned(v1) == floor(v1)
                        v1 -= floor(v1);
                    }
                    N[2] = unsigned(v2) - 3; // unsigned(v2) == floor(v2)
                    v2 -= floor(v2);

                    ++k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer < segs, "Error in logic");
                    u0 = double(u_range * (u_segs - 1)) / double(u_segs) + 3.0;
                    v0 = double(v_range * k_inner) / double(v_segs) + 3.0;
                    u1 = double(u_range + 3);
                    v1 = double(v_range * k_outer) / double(segs) + 3.0;
                    u2 = u1;
                    v2 = double(v_range * (k_outer + 1)) / double(segs) + 3.0;    
                    tu0 = double(u_segs - 1) / double(u_segs);
                    tv0 = double(k_inner) / double(v_segs);
                    tu1 = 1.0;
                    tv1 = double(k_outer) / double(segs);
                    tu2 = tu1;
                    tv2 = double(k_outer + 1) / double(segs);    

                    M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u0 -= floor(u0);
                    M[2] = M[1] = dwWidth - 4;
                    u2 = u1 = 1.0;
                    if((v_range * k_inner) % v_segs == 0)
                    {
                        N[0] = unsigned(v0) - 4;
                        v0 = 1.0;
                    }
                    else
                    {
                        N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                        v0 -= floor(v0);
                    }
                    N[1] = unsigned(v1) - 3; // unsigned(v1) == floor(v1)
                    v1 -= floor(v1);
                    if((v_range * (k_outer + 1)) % segs == 0)
                    {
                        N[2] = unsigned(v2) - 4;
                        v2 = 1.0;
                    }
                    else
                    {
                        N[2] = unsigned(v2) - 3; // unsigned(v2) == floor(v2)
                        v2 -= floor(v2);
                    }

                    ++k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(catrom, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, tu0, tv0, tu1, tv1, tu2, tv2, false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // left edge
            segs = unsigned(pPrimSegments[3]);
            k_outer = segs;
            k_inner = v_segs - 1;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer > 0))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner > 1, "Error in logic");
                    u0 = double(u_range) / double(u_segs) + 3.0;
                    v0 = double(v_range * k_inner) / double(v_segs) + 3.0;
                    u1 = 0.0;
                    v1 = double(v_range * k_outer) / double(segs) + 3.0;
                    u2 = u0;
                    v2 = double(v_range * (k_inner - 1)) / double(v_segs) + 3.0;    
                    tu0 = 1.0 / double(u_segs);
                    tv0 = double(k_inner) / double(v_segs);
                    tu1 = 0.0;
                    tv1 = double(k_outer) / double(segs);
                    tu2 = tu0;
                    tv2 = double(k_inner - 1) / double(v_segs);    

                    M[2] = M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u2 = u0 = u0 - floor(u0);
                    M[1] = 0;
                    N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v0 -= floor(v0);
                    if((v_range * k_outer) % segs == 0)
                    {
                        N[1] = unsigned(v1) - 4;
                        v1 = 1.0;
                    }
                    else
                    {
                        N[1] = unsigned(v1) - 3; // unsigned(v1) == floor(v1)
                        v1 -= floor(v1);
                    }
                    N[2] = unsigned(v2) - 3; // unsigned(v2) == floor(v2)
                    v2 -= floor(v2);

                    --k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer > 0, "Error in logic");
                    u0 = double(u_range) / double(u_segs) + 3.0;
                    v0 = double(v_range * k_inner) / double(v_segs) + 3.0;
                    u1 = 0.0;
                    v1 = double(v_range * k_outer) / double(segs) + 3.0;
                    u2 = u1;
                    v2 = double(v_range * (k_outer - 1)) / double(segs) + 3.0;    
                    tu0 = 1.0 / double(u_segs);
                    tv0 = double(k_inner) / double(v_segs);
                    tu1 = 0.0;
                    tv1 = double(k_outer) / double(segs);
                    tu2 = tu1;
                    tv2 = double(k_outer - 1) / double(segs);    

                    M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u0 -= floor(u0);
                    M[2] = M[1] = 0;
                    N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v0 -= floor(v0);
                    if((v_range * k_outer) % segs == 0)
                    {
                        N[1] = unsigned(v1) - 4;
                        v1 = 1.0;
                    }
                    else
                    {
                        N[1] = unsigned(v1) - 3; // unsigned(v1) == floor(v1)
                        v1 -= floor(v1);
                    }
                    N[2] = unsigned(v2) - 3; // unsigned(v2) == floor(v2)
                    v2 -= floor(v2);

                    --k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(catrom, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, tu0, tv0, tu1, tv1, tu2, tv2, false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // Now do the regular interior
            u_start = 1;
            v_start = 1;
        }
        else
        {
            // It can be done regularly
            u_start = 0;
            v_start = 0;
        }
    }
    else
    {
        unsigned segs = unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]);
        if(segs == 0)
        {
            segs = 1;
        }
        u_start = 0;
        v_start = 0;
        u_segs = segs;
        v_segs = segs;
    }

    for(unsigned i = v_start; i < v_segs - v_start; ++i)
    {
        double v0 = double(v_range * i) / double(v_segs) + 3.0;
        double v1 = double(v_range * (i + 1)) / double(v_segs) + 3.0;
        N[1] = N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
        if((v_range * (i + 1)) % v_segs == 0)
        {
            N[3] = N[2] = unsigned(v1) - 4;
            v1 = 1.0;
        }
        else
        {
            N[3] = N[2] = unsigned(v1) - 3; // unsigned(v1) == floor(v1)
            v1 -= floor(v1);
        }
        for(unsigned j = u_start; j < u_segs - u_start; ++j)
        {
            double u0 = (u_range * double(j)) / double(u_segs) + 3.0;    
            double u1 = (u_range * double(j + 1)) / double(u_segs) + 3.0;    
            M[3] = M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
            if((u_range * (j + 1)) % u_segs == 0)
            {
                M[2] = M[1] = unsigned(u1) - 4;
                u1 = 1.0;
            }
            else
            {
                M[2] = M[1] = unsigned(u1) - 3; // unsigned(u1) == floor(u1)
                u1 -= floor(u1);
            }
            HRESULT hr = DrawTessQuad(catrom, dwOffW, dwOffH, dwStride, M, N, 
                                      u0 - floor(u0), v0 - floor(v0), u1, v1,
                                      double(j) / double(u_segs), double(i) / double(v_segs),
                                      double(j + 1) / double(u_segs), double(i + 1) / double(v_segs),
                                      false);
            if(FAILED(hr))
            {
                return hr;
            }
        }
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// RDCatRomSpline::Basis
//-----------------------------------------------------------------------------
double RDCatRomSpline::Basis(unsigned i, unsigned k, double t) const
{
    static const double lut[4][4] = {{-1.0/2.0, 3.0/2.0, -3.0/2.0, 1.0/2.0},
                                     {1.0, -5.0/2.0, 2.0, -1.0/2.0},
                                     {-1.0/2.0, 0.0, 1.0/2.0, 0.0},
                                     {0.0, 1.0, 0.0, 0.0}};    
    _ASSERT(i < 4, "Catmull-Rom spline can be only cubic");
    return t * t * t * lut[0][i] + t * t * lut[1][i] + t * lut[2][i] + lut[3][i];
}

//-----------------------------------------------------------------------------
// RDCatRomSpline::BasisPrime
//-----------------------------------------------------------------------------
double RDCatRomSpline::BasisPrime(unsigned i, unsigned k, double t) const
{
    static const double lut[3][4] = {{-3.0/2.0, 9.0/2.0, -9.0/2.0, 3.0/2.0},
                                     {2.0, -5.0, 4.0, -1.0},
                                     {-1.0/2.0, 0.0, 1.0/2.0, 0.0}};    
    _ASSERT(i < 4, "Catmull-Rom spline can be only cubic");
    return t * t * lut[0][i] + t * lut[1][i] + lut[2][i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\hop\bspline.hpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bspline.hpp
 *  Content:    Declarations for B-Splines
 *
 ****************************************************************************/

#ifndef _BSPLINE_HPP
#define _BSPLINE_HPP

class RDBSpline 
{
public:
    RDBSpline(DWORD dwWidth, DWORD dwHeight, DWORD dwOrderU, DWORD dwOrderV)
    {
        m_dwWidth = dwWidth;
        m_dwHeight = dwHeight;
        m_dwOrderU = dwOrderU;
        m_dwOrderV = dwOrderV;
    }

    void Sample(DWORD dwDataType, double u, double v, const BYTE *B, DWORD dwStride, DWORD dwPitch, BYTE *Q) const;
    void SampleNormal(DWORD dwDataType, double u, double v, const BYTE *pRow, DWORD dwStride, DWORD dwPitch, BYTE *Q) const;
    void SampleDegenerateNormal(DWORD dwDataType, const BYTE *pRow, DWORD dwStride, DWORD dwPitch, BYTE *Q) const;

    double TexCoordU(double u) const
    {
        return (u - double(m_dwOrderU - 1)) / double(m_dwWidth - (m_dwOrderU - 1));
    }
    double TexCoordV(double v) const
    {
        return (v - double(m_dwOrderV - 1)) / double(m_dwHeight - (m_dwOrderV - 1));
    }

protected:
    virtual double Basis(unsigned i, unsigned k, double s) const;
    virtual double BasisPrime(unsigned i, unsigned k, double s) const;

private:
    DWORD m_dwWidth, m_dwHeight, m_dwOrderU, m_dwOrderV;

    double Knot(unsigned i) const { return double(i); }
};

#endif // _BSPLINE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\hop\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////
#include "refdev.hpp"

#include "bspline.hpp"
#include "bezier.hpp"
#include "npatch.hpp"
#include "catrom.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\hop\drawgrid.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drawgrid.cpp
 *  Content:    Implementation for high order surfaces
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// RDHOCoeffs::operator=
//-----------------------------------------------------------------------------
RDHOCoeffs& RDHOCoeffs::operator=(const RDHOCoeffs &coeffs)
{
    m_Width  = coeffs.m_Width;
    m_Height = coeffs.m_Height;
    m_Stride = coeffs.m_Stride;
    m_Basis  = coeffs.m_Basis;
    m_Order  = coeffs.m_Order;
    if(coeffs.m_pNumSegs != 0)
    {
        m_pNumSegs = new FLOAT[4];
        if(m_pNumSegs != 0)
        {
            memcpy(m_pNumSegs, coeffs.m_pNumSegs, sizeof(FLOAT) * 4);
        }
    }
    else
    {
        m_pNumSegs = 0;
    }
    for(unsigned i = 0; i < RD_MAX_NUMSTREAMS; ++i)
    {
        if(coeffs.m_pData[i] != 0)
        {
            m_DataSize[i] = coeffs.m_DataSize[i];
            m_pData[i] = new BYTE[m_DataSize[i]];
            if(m_pData[i] != 0)
            {
                memcpy(m_pData[i], coeffs.m_pData[i], m_DataSize[i]);
            }
        }
        else
        {
            m_pData[i] = 0;
        }
    }
    return *this;
}

//-----------------------------------------------------------------------------
// RefDev::DrawRectPatch
//-----------------------------------------------------------------------------
HRESULT 
RefDev::DrawRectPatch( LPD3DHAL_DP2DRAWRECTPATCH pDP )
{
    HRESULT hr = S_OK;
    
    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) )
    {
        //
        // The legacy FVF style: The Zero'th Stream is implied
        //
        DWORD dwFVF    = m_CurrentVShaderHandle;
        RDVStream& Stream = m_VStream[0];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwFVFSize = GetFVFVertexSize( dwFVF );

        if( Stream.m_pData == NULL || dwStride == 0 )
        {
            DPFERR("Zero'th stream doesnt have valid VB set");
            return DDERR_INVALIDPARAMS;
        }
        if( dwStride < dwFVFSize )
        {
            DPFERR("The stride set for the vertex stream is less than the FVF vertex size");
            return E_FAIL;
        }        
    }

    FLOAT *pSegs;
    D3DRECTPATCH_INFO Info, *pInfo;
    BYTE *TempData[RD_MAX_NUMSTREAMS + 1];

    if(pDP->Handle != 0)
    {
        if((pDP->Flags & RTPATCHFLAG_HASINFO) != 0) // Is either a first time or a recompute
        {
            HR_RET( m_HOSCoeffs.Grow(pDP->Handle) );

            if((pDP->Flags & RTPATCHFLAG_HASSEGS) != 0)
            {
                pInfo = (D3DRECTPATCH_INFO*)(((BYTE*)(pDP + 1) + sizeof(FLOAT) * 4));
                pSegs = (FLOAT*)(pDP + 1);
            }
            else
            {
                pInfo = (D3DRECTPATCH_INFO*)(pDP + 1);
                pSegs = 0;
            }

            RDHOCoeffs &coeffs = m_HOSCoeffs[pDP->Handle];
            coeffs.m_Width  = pInfo->Width;
            coeffs.m_Height = pInfo->Height;
            coeffs.m_Stride = pInfo->Width;
            coeffs.m_Basis  = pInfo->Basis;
            coeffs.m_Order  = pInfo->Order;

            delete[] coeffs.m_pNumSegs;
            if(pSegs != 0)
            {
                coeffs.m_pNumSegs = new FLOAT[4];
                if(coeffs.m_pNumSegs == 0)
                {
                    return E_OUTOFMEMORY;
                }
                memcpy(coeffs.m_pNumSegs, pSegs, sizeof(FLOAT) * 4);
            }
            else
            {
                coeffs.m_pNumSegs = 0;
            }

            RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
            for(unsigned i = 0; i < Decl.m_dwNumActiveStreams; ++i) 
            {
                RDVStreamDecl &StreamDecl = Decl.m_StreamArray[i];
                if(StreamDecl.m_dwStreamIndex < RD_MAX_NUMSTREAMS) // ignore the implicit stream
                {
                    RDVStream &Stream = m_VStream[StreamDecl.m_dwStreamIndex];
                    delete[] coeffs.m_pData[StreamDecl.m_dwStreamIndex];
                    coeffs.m_DataSize[StreamDecl.m_dwStreamIndex] = pInfo->Width * pInfo->Height * Stream.m_dwStride;
                    coeffs.m_pData[StreamDecl.m_dwStreamIndex] = new BYTE[coeffs.m_DataSize[StreamDecl.m_dwStreamIndex]];
                    if(coeffs.m_pData[StreamDecl.m_dwStreamIndex] == 0)
                    {
                        return E_OUTOFMEMORY;
                    }
                    for(unsigned k = 0; k < pInfo->Height; ++k)
                    {
                        memcpy(&coeffs.m_pData[StreamDecl.m_dwStreamIndex][k * pInfo->Width * Stream.m_dwStride],
                               &Stream.m_pData[((pInfo->StartVertexOffsetHeight + k) * pInfo->Stride + pInfo->StartVertexOffsetWidth) * Stream.m_dwStride],
                               pInfo->Width * Stream.m_dwStride);
                    }
                }
            }
        }

        // Guard against bad handles
        if(pDP->Handle >= m_HOSCoeffs.GetSize())
        {
            DPFERR("Invalid patch handle specified in Draw*Patch call");
            return E_FAIL;
        }

        RDHOCoeffs &coeffs = m_HOSCoeffs[pDP->Handle];
        Info.StartVertexOffsetWidth  = 0;
        Info.StartVertexOffsetHeight = 0;
        Info.Width                   = coeffs.m_Width;
        Info.Height                  = coeffs.m_Height;
        Info.Stride                  = coeffs.m_Stride;
        Info.Basis                   = coeffs.m_Basis;
        Info.Order                   = coeffs.m_Order;
        pInfo = &Info;

        if((pDP->Flags & RTPATCHFLAG_HASSEGS) != 0)
        {
            pSegs = (FLOAT*)(pDP + 1);
        }
        else
        {
            pSegs = coeffs.m_pNumSegs;
        }
        
        // Save current data stream pointers and replace with 
        // pointer to tessellation output
        hr = LinkCachedTessellatorOutput(pDP->Handle, TempData);
    }
    else
    {
        if((pDP->Flags & RTPATCHFLAG_HASINFO) == 0)
        {
            DPFERR("Need patch info if handle is zero");
            return DDERR_INVALIDPARAMS;
        }
        
        if((pDP->Flags & RTPATCHFLAG_HASSEGS) != 0)
        {
            pInfo = (D3DRECTPATCH_INFO*)(((BYTE*)(pDP + 1) + sizeof(FLOAT) * 4));
            pSegs = (FLOAT*)(pDP + 1);
        }
        else
        {
            pInfo = (D3DRECTPATCH_INFO*)(pDP + 1);
            pSegs = 0;
        }

        // Save current data stream pointers and replace with 
        // pointer to tessellation output
        hr = LinkTessellatorOutput();
    }

    if( SUCCEEDED(hr) )
    {
        switch(pInfo->Basis)
        {
        case D3DBASIS_BSPLINE:
            hr = ProcessBSpline(pInfo->StartVertexOffsetWidth, pInfo->StartVertexOffsetHeight,
                                pInfo->Width, pInfo->Height,
                                pInfo->Stride, pInfo->Order,
                                pSegs);
            break;
        case D3DBASIS_BEZIER:
            hr = ProcessBezier(pInfo->StartVertexOffsetWidth, pInfo->StartVertexOffsetHeight,
                               pInfo->Width, pInfo->Height,
                               pInfo->Stride, pInfo->Order,
                               pSegs,
                               false);
            break;
        case D3DBASIS_INTERPOLATE:
            hr = ProcessCatRomSpline(pInfo->StartVertexOffsetWidth, pInfo->StartVertexOffsetHeight,
                                     pInfo->Width, pInfo->Height,
                                     pInfo->Stride,
                                     pSegs);
            break;
        default:
            hr = E_NOTIMPL;
        }
    }

    if(pDP->Handle != 0)
    {
        // Restore back saved pointer
        UnlinkCachedTessellatorOutput(TempData);
    }
    else
    {
        // Restore back saved pointer
        UnlinkTessellatorOutput();
    }
    
    return hr;
}

//-----------------------------------------------------------------------------
// RefDev::ConvertLinearTriBezierToRectBezier
//-----------------------------------------------------------------------------
HRESULT
RefDev::ConvertLinearTriBezierToRectBezier(DWORD dwDataType, const BYTE *B, DWORD dwStride, BYTE *Q)
{
    DWORD dwElements = 0;
    switch(dwDataType)
    {
    case D3DVSDT_FLOAT4:
        ++dwElements;
    case D3DVSDT_FLOAT3:
        ++dwElements;
    case D3DVSDT_FLOAT2:
        ++dwElements;
    case D3DVSDT_FLOAT1:
        ++dwElements;
        {
            // Replicate first point twice to get a singular edge
            for(unsigned i = 0; i < 2; ++i)
            {
                memcpy(Q, B, sizeof(FLOAT) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 2; ++i)
            {
                memcpy(Q, B, sizeof(FLOAT) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    case D3DVSDT_D3DCOLOR:
    case D3DVSDT_UBYTE4:
        dwElements = 4;
        {
            // Replicate first point twice to get a singular edge
            for(unsigned i = 0; i < 2; ++i)
            {
                memcpy(Q, B, sizeof(BYTE) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 2; ++i)
            {
                memcpy(Q, B, sizeof(BYTE) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    case D3DVSDT_SHORT4:
        dwElements += 2;
    case D3DVSDT_SHORT2:
        dwElements += 2;
        {
            // Replicate first point twice to get a singular edge
            for(unsigned i = 0; i < 2; ++i)
            {
                memcpy(Q, B, sizeof(SHORT) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 2; ++i)
            {
                memcpy(Q, B, sizeof(SHORT) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    default:
        _ASSERT(FALSE, "Ununderstood vertex element data type");
        return DDERR_INVALIDPARAMS;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// RefDev::ConvertCubicTriBezierToRectBezier
//-----------------------------------------------------------------------------
HRESULT
RefDev::ConvertCubicTriBezierToRectBezier(DWORD dwDataType, const BYTE *B, DWORD dwStride, BYTE *Q)
{
    DWORD dwElements = 0;
    switch(dwDataType)
    {
    case D3DVSDT_FLOAT4:
        ++dwElements;
    case D3DVSDT_FLOAT3:
        ++dwElements;
    case D3DVSDT_FLOAT2:
        ++dwElements;
    case D3DVSDT_FLOAT1:
        ++dwElements;
        {
            // Replicate first point four times to get a singular edge
            for(unsigned i = 0; i < 4; ++i)
            {
                memcpy(Q, B, sizeof(FLOAT) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // For the next row, we simply copy the second point
            // followed by two interpolated control points
            // followed by the third point
            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            
            FLOAT *B021 = (FLOAT*)B, *B120 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B021[i] * 2.0 + B120[i]) / 3.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B021[i] + B120[i] * 2.0) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            
            FLOAT *B012 = (FLOAT*)B, *B111 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B012[i] + B111[i] * 2.0) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B210 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B111[i] * 2.0 + B210[i]) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 4; ++i)
            {
                memcpy(Q, B, sizeof(FLOAT) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    case D3DVSDT_D3DCOLOR:
    case D3DVSDT_UBYTE4:
        dwElements = 4;
        {
            // Replicate first point four times to get a singular edge
            for(unsigned i = 0; i < 4; ++i)
            {
                memcpy(Q, B, sizeof(BYTE) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // For the next row, we simply copy the second point
            // followed by two interpolated control points
            // followed by the third point
            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            
            BYTE *B021 = (BYTE*)B, *B120 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B021[i] * 2.0 + B120[i]) / 3.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B021[i] + B120[i] * 2.0) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            
            BYTE *B012 = (BYTE*)B, *B111 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B012[i] + B111[i] * 2.0) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B210 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B111[i] * 2.0 + B210[i]) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 4; ++i)
            {
                memcpy(Q, B, sizeof(BYTE) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    case D3DVSDT_SHORT4:
        dwElements += 2;
    case D3DVSDT_SHORT2:
        dwElements += 2;
        {
            // Replicate first point four times to get a singular edge
            for(unsigned i = 0; i < 4; ++i)
            {
                memcpy(Q, B, sizeof(SHORT) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // For the next row, we simply copy the second point
            // followed by two interpolated control points
            // followed by the third point
            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            
            SHORT *B021 = (SHORT*)B, *B120 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B021[i] * 2.0 + B120[i]) / 3.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B021[i] + B120[i] * 2.0) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            
            SHORT *B012 = (SHORT*)B, *B111 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B012[i] + B111[i] * 2.0) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B210 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B111[i] * 2.0 + B210[i]) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 4; ++i)
            {
                memcpy(Q, B, sizeof(SHORT) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    default:
        _ASSERT(FALSE, "Ununderstood vertex element data type");
        return DDERR_INVALIDPARAMS;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// RefDev::ConvertQuinticTriBezierToRectBezier
//-----------------------------------------------------------------------------
HRESULT
RefDev::ConvertQuinticTriBezierToRectBezier(DWORD dwDataType, const BYTE *B, DWORD dwStride, BYTE *Q)
{
    DWORD dwElements = 0;
    switch(dwDataType)
    {
    case D3DVSDT_FLOAT4:
        ++dwElements;
    case D3DVSDT_FLOAT3:
        ++dwElements;
    case D3DVSDT_FLOAT2:
        ++dwElements;
    case D3DVSDT_FLOAT1:
        ++dwElements;
        {
            // Replicate first point six times to get a singular edge
            for(unsigned i = 0; i < 6; ++i)
            {
                memcpy(Q, B, sizeof(FLOAT) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // For the next row, we simply copy the second point
            // followed by four interpolated control points
            // followed by the fifth point
            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            
            FLOAT *B041 = (FLOAT*)B, *B140 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B041[i] * 4.0 + B140[i]) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B041[i] * 3.0 + B140[i] * 2.0) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B041[i] * 2.0 + B140[i] * 3.0) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B041[i] + B140[i] * 4.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            
            FLOAT *B032 = (FLOAT*)B, *B131 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B032[i] * 3.0 + B131[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B230 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B032[i] * 3.0 + B131[i] * 6.0 + B230[i]) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B032[i] + B131[i] * 6.0 + B230[i] * 3.0) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B131[i] * 2.0 + B230[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            
            FLOAT *B023 = (FLOAT*)B, *B122 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B023[i] * 2.0 + B122[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B221 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B023[i] + B122[i] * 6.0 + B221[i] * 3.0) / 10.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B320 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B122[i] * 3.0 + B221[i] * 6.0 + B320[i]) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B221[i] * 3.0 + B320[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            
            FLOAT *B014 = (FLOAT*)B, *B113 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B014[i] + B113[i] * 4.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B212 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B113[i] * 2.0 + B212[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B311 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B212[i] * 3.0 + B311[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B410 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B311[i] * 4.0 + B410[i]) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 6; ++i)
            {
                memcpy(Q, B, sizeof(FLOAT) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    case D3DVSDT_UBYTE4:
    case D3DVSDT_D3DCOLOR:
        dwElements = 4;
        {
            // Replicate first point six times to get a singular edge
            for(unsigned i = 0; i < 6; ++i)
            {
                memcpy(Q, B, sizeof(BYTE) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // For the next row, we simply copy the second point
            // followed by four interpolated control points
            // followed by the fifth point
            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            
            BYTE *B041 = (BYTE*)B, *B140 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B041[i] * 4.0 + B140[i]) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B041[i] * 3.0 + B140[i] * 2.0) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B041[i] * 2.0 + B140[i] * 3.0) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B041[i] + B140[i] * 4.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            
            BYTE *B032 = (BYTE*)B, *B131 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B032[i] * 3.0 + B131[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B230 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B032[i] * 3.0 + B131[i] * 6.0 + B230[i]) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B032[i] + B131[i] * 6.0 + B230[i] * 3.0) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B131[i] * 2.0 + B230[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            
            BYTE *B023 = (BYTE*)B, *B122 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B023[i] * 2.0 + B122[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B221 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B023[i] + B122[i] * 6.0 + B221[i] * 3.0) / 10.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B320 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B122[i] * 3.0 + B221[i] * 6.0 + B320[i]) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B221[i] * 3.0 + B320[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            
            BYTE *B014 = (BYTE*)B, *B113 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B014[i] + B113[i] * 4.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B212 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B113[i] * 2.0 + B212[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B311 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B212[i] * 3.0 + B311[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B410 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B311[i] * 4.0 + B410[i]) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 6; ++i)
            {
                memcpy(Q, B, sizeof(BYTE) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    case D3DVSDT_SHORT4:
        dwElements += 2;
    case D3DVSDT_SHORT2:
        dwElements += 2;
        {
            // Replicate first point six times to get a singular edge
            for(unsigned i = 0; i < 6; ++i)
            {
                memcpy(Q, B, sizeof(SHORT) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // For the next row, we simply copy the second point
            // followed by four interpolated control points
            // followed by the fifth point
            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            
            SHORT *B041 = (SHORT*)B, *B140 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B041[i] * 4.0 + B140[i]) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B041[i] * 3.0 + B140[i] * 2.0) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B041[i] * 2.0 + B140[i] * 3.0) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B041[i] + B140[i] * 4.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            
            SHORT *B032 = (SHORT*)B, *B131 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B032[i] * 3.0 + B131[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B230 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B032[i] * 3.0 + B131[i] * 6.0 + B230[i]) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B032[i] + B131[i] * 6.0 + B230[i] * 3.0) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B131[i] * 2.0 + B230[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            
            SHORT *B023 = (SHORT*)B, *B122 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B023[i] * 2.0 + B122[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B221 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B023[i] + B122[i] * 6.0 + B221[i] * 3.0) / 10.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B320 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B122[i] * 3.0 + B221[i] * 6.0 + B320[i]) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B221[i] * 3.0 + B320[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            
            SHORT *B014 = (SHORT*)B, *B113 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B014[i] + B113[i] * 4.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B212 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B113[i] * 2.0 + B212[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B311 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B212[i] * 3.0 + B311[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B410 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B311[i] * 4.0 + B410[i]) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 6; ++i)
            {
                memcpy(Q, B, sizeof(SHORT) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    default:
        _ASSERT(FALSE, "Ununderstood vertex element data type");
        return DDERR_INVALIDPARAMS;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// RefDev::DrawTriPatch
//-----------------------------------------------------------------------------
HRESULT 
RefDev::DrawTriPatch( LPD3DHAL_DP2DRAWTRIPATCH pDP )
{
    HRESULT hr = S_OK;
    
    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) )
    {
        //
        // The legacy FVF style: The Zero'th Stream is implied
        //
        DWORD dwFVF    = m_CurrentVShaderHandle;
        RDVStream& Stream = m_VStream[0];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwFVFSize = GetFVFVertexSize( dwFVF );

        if( Stream.m_pData == NULL || dwStride == 0 )
        {
            DPFERR("Zero'th stream doesnt have valid VB set");
            return DDERR_INVALIDPARAMS;
        }
        if( dwStride < dwFVFSize )
        {
            DPFERR("The stride set for the vertex stream is less than the FVF vertex size");
            return E_FAIL;
        }        
    }

    FLOAT *pSegs;
    D3DRECTPATCH_INFO Info;
    BYTE *TempData[RD_MAX_NUMSTREAMS + 1];

    if(pDP->Handle == 0 && (pDP->Flags & RTPATCHFLAG_HASINFO) == 0)
    {
        DPFERR("Need patch info if handle is zero");
        return DDERR_INVALIDPARAMS;
    }

    if((pDP->Flags & RTPATCHFLAG_HASINFO) != 0) // Is either a first time or a recompute
    {
        HR_RET( m_HOSCoeffs.Grow(pDP->Handle) );

        D3DTRIPATCH_INFO *pInfo;
        if((pDP->Flags & RTPATCHFLAG_HASSEGS) != 0)
        {
            pInfo = (D3DTRIPATCH_INFO*)(((BYTE*)(pDP + 1) + sizeof(FLOAT) * 3));
            pSegs = (FLOAT*)(pDP + 1);
        }
        else
        {
            pInfo = (D3DTRIPATCH_INFO*)(pDP + 1);
            pSegs = 0;
        }

        RDHOCoeffs &coeffs = m_HOSCoeffs[pDP->Handle];
        coeffs.m_Width  = (DWORD)pInfo->Order + 1;
        coeffs.m_Height = (DWORD)pInfo->Order + 1;
        coeffs.m_Stride = (DWORD)pInfo->Order + 1;
        coeffs.m_Basis  = pInfo->Basis;
        coeffs.m_Order  = pInfo->Order;

        delete[] coeffs.m_pNumSegs;
        if(pSegs != 0)
        {
            coeffs.m_pNumSegs = new FLOAT[4];
            if(coeffs.m_pNumSegs == 0)
            {
                return E_OUTOFMEMORY;
            }
            coeffs.m_pNumSegs[0] = pSegs[2];
            memcpy(&coeffs.m_pNumSegs[1], pSegs, sizeof(FLOAT) * 3);
        }
        else
        {
            coeffs.m_pNumSegs = 0;
        }

        RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;

        // Allocate memory to hold rect patches rather than tri patches
        for(unsigned i = 0; i < Decl.m_dwNumActiveStreams; ++i) 
        {
            RDVStreamDecl &StreamDecl = Decl.m_StreamArray[i];
            if(StreamDecl.m_dwStreamIndex < RD_MAX_NUMSTREAMS) // ignore the implicit stream
            {
                RDVStream &Stream = m_VStream[StreamDecl.m_dwStreamIndex];
                delete[] coeffs.m_pData[StreamDecl.m_dwStreamIndex];
                coeffs.m_DataSize[StreamDecl.m_dwStreamIndex] = coeffs.m_Width * coeffs.m_Height * Stream.m_dwStride;
                coeffs.m_pData[StreamDecl.m_dwStreamIndex] = new BYTE[coeffs.m_DataSize[StreamDecl.m_dwStreamIndex]];
                if(coeffs.m_pData[StreamDecl.m_dwStreamIndex] == 0)
                {
                    return E_OUTOFMEMORY;
                }
            }
        }

        // Now go through tri patch data, convert it to rect patch and store it in
        // in the space that we allocated above
        for(unsigned e = 0; e < Decl.m_dwNumElements; ++e)
        {
            RDVElement &velem = Decl.m_VertexElements[e];
            if(!velem.m_bIsTessGen)
            {
                RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
                LPBYTE Q = coeffs.m_pData[velem.m_dwStreamIndex] + velem.m_dwOffset;
                LPBYTE B = vstream.m_pData + pInfo->StartVertexOffset * vstream.m_dwStride + velem.m_dwOffset;
                if(pInfo->Order == D3DORDER_LINEAR)
                {
                    hr = ConvertLinearTriBezierToRectBezier(velem.m_dwDataType, B, vstream.m_dwStride, Q);
                    if(FAILED(hr))
                    {
                        DPFERR("Conversion from Linear Tri Patch to Rect Patch failed");
                        return E_FAIL;
                    }
                }
                else if(pInfo->Order == D3DORDER_CUBIC)
                {
                    hr = ConvertCubicTriBezierToRectBezier(velem.m_dwDataType, B, vstream.m_dwStride, Q);
                    if(FAILED(hr))
                    {
                        DPFERR("Conversion from Cubic Tri Patch to Rect Patch failed");
                        return E_FAIL;
                    }
                }
                else if(pInfo->Order == D3DORDER_QUINTIC)
                {
                    hr = ConvertQuinticTriBezierToRectBezier(velem.m_dwDataType, B, vstream.m_dwStride, Q);
                    if(FAILED(hr))
                    {
                        DPFERR("Conversion from Quintic Tri Patch to Rect Patch failed");
                        return E_FAIL;
                    }
                }
                else
                {
                    DPFERR("Only cubic Bezier patches currently supported");
                    return E_FAIL;
                }
            }
        }
    }

    // Guard against bad handles
    if(pDP->Handle >= m_HOSCoeffs.GetSize())
    {
        DPFERR("Invalid patch handle specified in Draw*Patch call");
        return E_FAIL;
    }

    RDHOCoeffs &coeffs = m_HOSCoeffs[pDP->Handle];
    Info.StartVertexOffsetWidth  = 0;
    Info.StartVertexOffsetHeight = 0;
    Info.Width                   = coeffs.m_Width;
    Info.Height                  = coeffs.m_Height;
    Info.Stride                  = coeffs.m_Stride;
    Info.Basis                   = coeffs.m_Basis;
    Info.Order                   = coeffs.m_Order;
    D3DRECTPATCH_INFO *pInfo = &Info;

    FLOAT Segs[4];
    if((pDP->Flags & RTPATCHFLAG_HASSEGS) != 0)
    {
        Segs[0] = ((FLOAT*)(pDP + 1))[2];
        memcpy(&Segs[1], pDP + 1, sizeof(FLOAT) * 3);
        pSegs = &Segs[0];
    }
    else
    {
        pSegs = coeffs.m_pNumSegs;
    }
    
    // Save current data stream pointers and replace with 
    // pointer to tessellation output
    hr = LinkCachedTessellatorOutput(pDP->Handle, TempData);
    if( SUCCEEDED(hr) )
    {
        switch(pInfo->Basis)
        {
        case D3DBASIS_BEZIER:
            hr = ProcessBezier(pInfo->StartVertexOffsetWidth, pInfo->StartVertexOffsetHeight,
                               pInfo->Width, pInfo->Height,
                               pInfo->Stride, pInfo->Order,
                               pSegs,
                               true);
            break;
        default:
            hr = E_NOTIMPL;
        }
    }

    // Restore back saved pointer
    UnlinkCachedTessellatorOutput(TempData);

    return hr;
}

//---------------------------------------------------------------------
// RefDev::LinkTessellatorOutput
//---------------------------------------------------------------------
HRESULT RefDev::LinkTessellatorOutput()
{
    HRESULT hr = S_OK;
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned i = 0; i < Decl.m_dwNumActiveStreams; ++i) 
    {
        RDVStreamDecl &StreamDecl = Decl.m_StreamArray[i];
        RDVStream &Stream = m_VStream[StreamDecl.m_dwStreamIndex];
        // Make space for four vertices
        hr |= Stream.m_TessOut.Grow(StreamDecl.m_dwStride * 4);
        Stream.m_pSavedData = Stream.m_pData;
        Stream.m_pData = &Stream.m_TessOut[0];
    }
    return hr;
}

//---------------------------------------------------------------------
// RefDev::LinkCachedTessellatorOutput
//---------------------------------------------------------------------
HRESULT RefDev::LinkCachedTessellatorOutput(DWORD Handle, BYTE **pTempData)
{
    HRESULT hr = S_OK;
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned i = 0; i < Decl.m_dwNumActiveStreams; ++i) 
    {
        RDVStreamDecl &StreamDecl = Decl.m_StreamArray[i];
        RDVStream &Stream = m_VStream[StreamDecl.m_dwStreamIndex];
        // Make space for four vertices
        hr |= Stream.m_TessOut.Grow(StreamDecl.m_dwStride * 4);
        if(StreamDecl.m_dwStreamIndex < RD_MAX_NUMSTREAMS) // ignore the implicit stream
        {
            Stream.m_pSavedData = m_HOSCoeffs[Handle].m_pData[StreamDecl.m_dwStreamIndex];
            if(Stream.m_pSavedData == 0)
            {
                DPFERR("Deleted or unspecified patch was requested to be drawn");
                hr |= E_FAIL;
            }
        }
        else
        {
            Stream.m_pSavedData = 0;
        }
        pTempData[StreamDecl.m_dwStreamIndex] = Stream.m_pData;
        Stream.m_pData = &Stream.m_TessOut[0];
    }
    return hr;
}

//---------------------------------------------------------------------
// RefDev::UnlinkTessellatorOuput
//---------------------------------------------------------------------
void RefDev::UnlinkTessellatorOutput()
{
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned i = 0; i < Decl.m_dwNumActiveStreams; ++i) 
    {
        RDVStreamDecl &StreamDecl = Decl.m_StreamArray[i];
        RDVStream &Stream = m_VStream[StreamDecl.m_dwStreamIndex];
        Stream.m_pData = Stream.m_pSavedData;
        Stream.m_pSavedData = NULL;
    }
}

//---------------------------------------------------------------------
// RefDev::UnlinkTessellatorOuput
//---------------------------------------------------------------------
void RefDev::UnlinkCachedTessellatorOutput(BYTE **pTempData)
{
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned i = 0; i < Decl.m_dwNumActiveStreams; ++i) 
    {
        RDVStreamDecl &StreamDecl = Decl.m_StreamArray[i];
        RDVStream &Stream = m_VStream[StreamDecl.m_dwStreamIndex];
        Stream.m_pData = pTempData[StreamDecl.m_dwStreamIndex];
        Stream.m_pSavedData = NULL;
    }
}

//---------------------------------------------------------------------
// RefDev::DrawTessQuad
//---------------------------------------------------------------------
HRESULT RefDev::DrawTessQuad( const RDBSpline &Surf, DWORD dwOffW, DWORD dwOffH, DWORD dwStride, 
                              const unsigned *m, const unsigned *n, 
                              double u0, double v0, double u1, double v1,
                              double tu0, double tv0, double tu1, double tv1,
                              bool bDegenerate )
{
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned e = 0; e < Decl.m_dwNumElements; ++e)
    {
        RDVElement &velem = Decl.m_VertexElements[e];
        if(velem.m_bIsTessGen)
        {
            if((velem.m_dwToken & 0x10000000) == 0) // Check if token is D3DVSD_TESSNORMAL
            {
                RDVStream &vstrmin = m_VStream[velem.m_dwStreamIndexIn];
                RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
                LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
                LPBYTE B = vstrmin.m_pSavedData + ((dwOffH + n[0]) * dwStride + (dwOffW + m[0])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                Surf.SampleNormal(velem.m_dwDataType, u0, v0, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                Q += vstream.m_dwStride;
                B = vstrmin.m_pSavedData + ((dwOffH + n[1]) * dwStride + (dwOffW + m[1])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                Surf.SampleNormal(velem.m_dwDataType, u1, v0, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                Q += vstream.m_dwStride;
                B = vstrmin.m_pSavedData + ((dwOffH + n[2]) * dwStride + (dwOffW + m[2])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                Surf.SampleNormal(velem.m_dwDataType, u1, v1, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                Q += vstream.m_dwStride;
                B = vstrmin.m_pSavedData + ((dwOffH + n[3]) * dwStride + (dwOffW + m[3])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                Surf.SampleNormal(velem.m_dwDataType, u0, v1, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
            }
            else // it is D3DVSD_TESSUV
            {
                RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
                LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
                if(bDegenerate)
                {
                    ((FLOAT*)Q)[0] = (FLOAT)(tu0 * tv0);
                    ((FLOAT*)Q)[1] = (FLOAT)tv0;
                }
                else
                {
                    ((FLOAT*)Q)[0] = (FLOAT)tu0;
                    ((FLOAT*)Q)[1] = (FLOAT)tv0;
                }
                Q += vstream.m_dwStride;
                if(bDegenerate)
                {
                    ((FLOAT*)Q)[0] = (FLOAT)(tu1 * tv0);
                    ((FLOAT*)Q)[1] = (FLOAT)tv0;
                }
                else
                {
                    ((FLOAT*)Q)[0] = (FLOAT)tu1;
                    ((FLOAT*)Q)[1] = (FLOAT)tv0;
                }
                Q += vstream.m_dwStride;
                if(bDegenerate)
                {
                    ((FLOAT*)Q)[0] = (FLOAT)(tu1 * tv1);
                    ((FLOAT*)Q)[1] = (FLOAT)tv1;
                }
                else
                {
                    ((FLOAT*)Q)[0] = (FLOAT)tu1;
                    ((FLOAT*)Q)[1] = (FLOAT)tv1;
                }
                Q += vstream.m_dwStride;
                if(bDegenerate)
                {
                    ((FLOAT*)Q)[0] = (FLOAT)(tu0 * tv1);
                    ((FLOAT*)Q)[1] = (FLOAT)tv1;
                }
                else
                {
                    ((FLOAT*)Q)[0] = (FLOAT)tu0;
                    ((FLOAT*)Q)[1] = (FLOAT)tv1;
                }
            }
        }
        else
        {
            RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
            LPBYTE B = vstream.m_pSavedData + ((dwOffH + n[0]) * dwStride + (dwOffW + m[0])) * vstream.m_dwStride + velem.m_dwOffset;
            LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
            Surf.Sample(velem.m_dwDataType, u0, v0, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
            Q += vstream.m_dwStride;
            B = vstream.m_pSavedData + ((dwOffH + n[1]) * dwStride + (dwOffW + m[1])) * vstream.m_dwStride + velem.m_dwOffset;
            Surf.Sample(velem.m_dwDataType, u1, v0, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
            Q += vstream.m_dwStride;
            B = vstream.m_pSavedData + ((dwOffH + n[2]) * dwStride + (dwOffW + m[2])) * vstream.m_dwStride + velem.m_dwOffset;
            Surf.Sample(velem.m_dwDataType, u1, v1, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
            Q += vstream.m_dwStride;
            B = vstream.m_pSavedData + ((dwOffH + n[3]) * dwStride + (dwOffW + m[3])) * vstream.m_dwStride + velem.m_dwOffset;
            Surf.Sample(velem.m_dwDataType, u0, v1, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
        }
    }

    HRESULT hr;
    if( m_pCurrentVShader->IsFixedFunction() )
    {
        //
        // With declaration for Fixed Function pipeline, DX8 style
        //
        hr = ProcessPrimitive( D3DPT_TRIANGLEFAN, 0, 4, 0, 0 );
    }
    else
    {
        //
        // Pure Vertex Shader
        //
        hr = ProcessPrimitiveVVM( D3DPT_TRIANGLEFAN, 0, 4, 0, 0 );
    }
    return hr;
}

//---------------------------------------------------------------------
// RefDev::DrawTessTri
//---------------------------------------------------------------------
HRESULT RefDev::DrawTessTri( const RDBSpline &Surf, DWORD dwOffW, DWORD dwOffH, DWORD dwStride, 
                             const unsigned *m, const unsigned *n, 
                             double u0, double v0, double u1, double v1, double u2, double v2,
                             double tu0, double tv0, double tu1, double tv1, double tu2, double tv2,
                             bool bDegenerate0, bool bDegenerate1, bool bDegenerate2 )
{
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned e = 0; e < Decl.m_dwNumElements; ++e)
    {
        RDVElement &velem = Decl.m_VertexElements[e];
        if(velem.m_bIsTessGen)
        {
            if((velem.m_dwToken & 0x10000000) == 0) // Check if token is D3DVSD_TESSNORMAL
            {
                RDVStream &vstrmin = m_VStream[velem.m_dwStreamIndexIn];
                RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
                LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
                LPBYTE B = vstrmin.m_pSavedData + ((dwOffH + n[0]) * dwStride + (dwOffW + m[0])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                if(bDegenerate0)
                {
                    Surf.SampleDegenerateNormal(velem.m_dwDataType, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                }
                else
                {
                    Surf.SampleNormal(velem.m_dwDataType, u0, v0, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                }
                Q += vstream.m_dwStride;
                B = vstrmin.m_pSavedData + ((dwOffH + n[1]) * dwStride + (dwOffW + m[1])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                if(bDegenerate1)
                {
                    Surf.SampleDegenerateNormal(velem.m_dwDataType, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                }
                else
                {
                    Surf.SampleNormal(velem.m_dwDataType, u1, v1, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                }
                Q += vstream.m_dwStride;
                B = vstrmin.m_pSavedData + ((dwOffH + n[2]) * dwStride + (dwOffW + m[2])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                if(bDegenerate2)
                {
                    Surf.SampleDegenerateNormal(velem.m_dwDataType, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                }
                else
                {
                    Surf.SampleNormal(velem.m_dwDataType, u2, v2, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                }
            }
            else // it is D3DVSD_TESSUV
            {
                RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
                LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
                ((FLOAT*)Q)[0] = (FLOAT)tu0;
                ((FLOAT*)Q)[1] = (FLOAT)tv0;
                Q += vstream.m_dwStride;
                ((FLOAT*)Q)[0] = (FLOAT)tu1;
                ((FLOAT*)Q)[1] = (FLOAT)tv1;
                Q += vstream.m_dwStride;
                ((FLOAT*)Q)[0] = (FLOAT)tu2;
                ((FLOAT*)Q)[1] = (FLOAT)tv2;
            }
        }
        else
        {
            RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
            LPBYTE B = vstream.m_pSavedData + ((dwOffH + n[0]) * dwStride + (dwOffW + m[0])) * vstream.m_dwStride + velem.m_dwOffset;
            LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
            Surf.Sample(velem.m_dwDataType, u0, v0, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
            Q += vstream.m_dwStride;
            B = vstream.m_pSavedData + ((dwOffH + n[1]) * dwStride + (dwOffW + m[1])) * vstream.m_dwStride + velem.m_dwOffset;
            Surf.Sample(velem.m_dwDataType, u1, v1, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
            Q += vstream.m_dwStride;
            B = vstream.m_pSavedData + ((dwOffH + n[2]) * dwStride + (dwOffW + m[2])) * vstream.m_dwStride + velem.m_dwOffset;
            Surf.Sample(velem.m_dwDataType, u2, v2, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
        }
    }

    HRESULT hr;
    if( m_pCurrentVShader->IsFixedFunction() )
    {
        //
        // With declaration for Fixed Function pipeline, DX8 style
        //
        hr = ProcessPrimitive( D3DPT_TRIANGLELIST, 0, 3, 0, 0 );
    }
    else
    {
        //
        // Pure Vertex Shader
        //
        hr = ProcessPrimitiveVVM( D3DPT_TRIANGLELIST, 0, 3, 0, 0 );
    }
    return hr;
}

//---------------------------------------------------------------------
// RefDev::DrawNPatch
//---------------------------------------------------------------------
HRESULT RefDev::DrawNPatch(const RDNPatch &Patch, DWORD dwStride, 
                                        const unsigned *m, const unsigned *n, unsigned segs)
{
    for(unsigned i = 0; i < segs; ++i)
    {
        double v0 = double(i) / double(segs);
        double v1 = v0;
        double v2 = double(i + 1) / double(segs);
        double v3 = v2;
        for(unsigned j = 0; j < segs - i; ++j)
        {
            double u0 = double(j + 1) / double(segs);
            double u1 = double(j) / double(segs);
            double u2 = u1;
            double u3 = u0;
            RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
            for(unsigned e = 0; e < Decl.m_dwNumElements; ++e)
            {
                RDVElement &velem = Decl.m_VertexElements[e];
                RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
                LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
                if(velem.m_dwRegister == D3DVSDE_POSITION)
                {
                    Patch.SamplePosition(u0, v0, (FLOAT*)Q);
                    Q += vstream.m_dwStride;
                    Patch.SamplePosition(u1, v1, (FLOAT*)Q);
                    Q += vstream.m_dwStride;
                    Patch.SamplePosition(u2, v2, (FLOAT*)Q);
                    if(j != segs - i - 1)
                    {
                        Q += vstream.m_dwStride;
                        Patch.SamplePosition(u3, v3, (FLOAT*)Q);
                    }
                }
                else
                if(velem.m_dwRegister == D3DVSDE_NORMAL)
                {
                    BYTE* B[3];
                    B[0] = vstream.m_pSavedData + (n[0] * dwStride + m[0]) * vstream.m_dwStride + velem.m_dwOffset;
                    B[1] = vstream.m_pSavedData + (n[1] * dwStride + m[1]) * vstream.m_dwStride + velem.m_dwOffset;
                    B[2] = vstream.m_pSavedData + (n[2] * dwStride + m[2]) * vstream.m_dwStride + velem.m_dwOffset;

                    Patch.SampleNormal(u0, v0, B, (FLOAT*)Q);
                    Q += vstream.m_dwStride;
                    Patch.SampleNormal(u1, v1, B, (FLOAT*)Q);
                    Q += vstream.m_dwStride;
                    Patch.SampleNormal(u2, v2, B, (FLOAT*)Q);
                    if(j != segs - i - 1)
                    {
                        Q += vstream.m_dwStride;
                        Patch.SampleNormal(u3, v3, B, (FLOAT*)Q);
                    }
                }
                else
                {
                    BYTE *B[3];
                    B[0] = vstream.m_pSavedData + (n[0] * dwStride + m[0]) * vstream.m_dwStride + velem.m_dwOffset;
                    B[1] = vstream.m_pSavedData + (n[1] * dwStride + m[1]) * vstream.m_dwStride + velem.m_dwOffset;
                    B[2] = vstream.m_pSavedData + (n[2] * dwStride + m[2]) * vstream.m_dwStride + velem.m_dwOffset;
                    Patch.Sample(velem.m_dwDataType, u0, v0, B, Q);
                    Q += vstream.m_dwStride;
                    Patch.Sample(velem.m_dwDataType, u1, v1, B, Q);
                    Q += vstream.m_dwStride;
                    Patch.Sample(velem.m_dwDataType, u2, v2, B, Q);
                    if(j != segs - i - 1)
                    {
                        Q += vstream.m_dwStride;
                        Patch.Sample(velem.m_dwDataType, u3, v3, B, Q);
                    }
                }
            }
            DWORD cVerts = (j != segs - i - 1) ? 4 : 3;
            HRESULT hr;
            if( m_pCurrentVShader->IsFixedFunction() )
            {
                //
                // With declaration for Fixed Function pipeline, DX8 style
                //
                hr = ProcessPrimitive( D3DPT_TRIANGLEFAN, 0, cVerts, 0, 0 );
            }
            else
            {
                //
                // Pure Vertex Shader
                //
                hr = ProcessPrimitiveVVM( D3DPT_TRIANGLEFAN, 0, cVerts, 0, 0 );
            }
            if(FAILED(hr))
            {
                return hr;
            }
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\hop\npatch.hpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       npatch.hpp
 *  Content:    Declarations for n-Patch scheme
 *
 ****************************************************************************/

#ifndef _NPATCH_HPP
#define _NPATCH_HPP

class RDCubicBezierTriangle
{
public:
    void SamplePosition(double u, double v, FLOAT *Q) const;
    void Sample(DWORD dwDataType, double u, double v, const BYTE* const B[], BYTE *Q) const;

protected:
    double m_B[4][4][3];

private:
    unsigned factorial(unsigned k) const
    {
        _ASSERT(k < 13, "Factorial out of range");
        for(unsigned i = 1, t = 1; i <= k; t *= i++);
        return t;
    }

    double Basis(unsigned i, unsigned j, double u, double v) const
    {
        unsigned k = 3 - i - j;
        double w = 1.0 - u - v;
        _ASSERT(i + j + k == 3, "Barycentric coordinates need to add to 3");
        return (6.0 * pow(u, double(i)) * pow(v, double(j)) * pow(w, double(k))) / double(factorial(i) * factorial(j) * factorial(k));
    }

};

class RDNPatch : public RDCubicBezierTriangle
{
public:
    RDNPatch(const FLOAT* const pV[], const FLOAT* const pN[], 
             const DWORD PositionOrder, const DWORD NormalOrder);
    void SamplePosition(double u, double v, FLOAT *Q) const;
    void SampleNormal(double u, double v, const BYTE* const B[], FLOAT *Q) const;

private:
    void ComputeEdgeControlPoint(unsigned a, unsigned b, const FLOAT* const pV[], const FLOAT* const pN[], unsigned u, unsigned v);
    void ComputeNormalControlPoint(RDVECTOR3* cp, unsigned i, unsigned j,
                                   const FLOAT* const pV[], 
                                   const FLOAT* const pN[]);
    DWORD m_PositionOrder;
    DWORD m_NormalOrder;
    // Normal coefficients
    RDVECTOR3 m_N200;         
    RDVECTOR3 m_N020;         
    RDVECTOR3 m_N002;         
    RDVECTOR3 m_N110;         
    RDVECTOR3 m_N011;         
    RDVECTOR3 m_N101;         
};

class RRIndexAccessor
{
public:
    RRIndexAccessor(BYTE *pBuf, DWORD dwStride, DWORD dwStart)
    {
        _ASSERT(dwStride == 2 || dwStride == 4, "Unsupported indexbuffer stride");        
        m_pBuf = pBuf + dwStart * dwStride;
        m_32 = (dwStride == 4);
    }

    unsigned operator[](unsigned i) const
    {
        return m_32 ? ((DWORD*)m_pBuf)[i] : ((WORD*)m_pBuf)[i];
    }

private:
    VOID *m_pBuf;
    bool m_32;
};

#endif // _NPATCH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\hop\npatch.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       npatch.cpp
 *  Content:    Implementation for N-Patches
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// RefDev::ProcessTessPrimitive
//-----------------------------------------------------------------------------
HRESULT 
RefDev::ProcessTessPrimitive( LPD3DHAL_DP2DRAWPRIMITIVE pDP )
{
    HRESULT hr = S_OK;

    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) )
    {
        //
        // The legacy FVF style: The Zero'th Stream is implied
        //
        DWORD dwFVF    = m_CurrentVShaderHandle;
        RDVStream& Stream = m_VStream[0];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwFVFSize = GetFVFVertexSize( dwFVF );

        if( Stream.m_pData == NULL || dwStride == 0 )
        {
            DPFERR( "Zero'th stream doesnt have valid VB set" );
            return DDERR_INVALIDPARAMS;
        }
        if( dwStride < dwFVFSize )
        {
            DPFERR( "The stride set for the vertex stream is less than"
                    " the FVF vertex size" );
            return E_FAIL;
        }
    }

    BYTE *pVerts = 0, *pNorms = 0;
    unsigned vstride, nstride;

    // Figure out where the positions and normals are
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned e = 0; e < Decl.m_dwNumElements; ++e)
    {
        RDVElement &velem = Decl.m_VertexElements[e];
        if(velem.m_dwRegister == D3DVSDE_POSITION) // Position
        {
            RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
            pVerts = vstream.m_pSavedData + pDP->VStart * vstream.m_dwStride + velem.m_dwOffset;
            vstride = vstream.m_dwStride;
        }
        else if(velem.m_dwRegister == D3DVSDE_NORMAL) // Normal
        {
            RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
            pNorms = vstream.m_pSavedData + pDP->VStart * vstream.m_dwStride + velem.m_dwOffset;
            nstride = vstream.m_dwStride;
        }
    }

    if(pVerts == 0 || pNorms == 0)
    {
        DPFERR("This tessellation scheme needs positions and normals explicitely specified");
        return DDERR_INVALIDPARAMS;
    }

    switch(pDP->primType)
    {
    case D3DPT_TRIANGLELIST:
        {
            for(unsigned i = 0; i < pDP->PrimitiveCount; ++i)
            {
                FLOAT *pV[3], *pN[3];
                unsigned iM[3], iN[3];
                
                pV[0] = (FLOAT*)(pVerts + i * 3 * vstride);
                pV[1] = (FLOAT*)(pVerts + (i * 3 + 1) * vstride);
                pV[2] = (FLOAT*)(pVerts + (i * 3 + 2) * vstride);
                pN[0] = (FLOAT*)(pNorms + i * 3 * nstride);
                pN[1] = (FLOAT*)(pNorms + (i * 3 + 1) * nstride);
                pN[2] = (FLOAT*)(pNorms + (i * 3 + 2) * nstride);
                iM[0] = pDP->VStart + i * 3;     iN[0] = 0;
                iM[1] = pDP->VStart + i * 3 + 1; iN[1] = 0;
                iM[2] = pDP->VStart + i * 3 + 2; iN[2] = 0;

                RDNPatch patch(pV, pN, GetRS()[D3DRS_POSITIONORDER], GetRS()[D3DRS_NORMALORDER]);
                
                hr = DrawNPatch(patch, 0, iM, iN, unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]));
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            for(unsigned i = 0; i < pDP->PrimitiveCount; ++i)
            {
                FLOAT *pV[3], *pN[3];
                unsigned iM[3], iN[3];
                
                pV[0] = (FLOAT*)(pVerts);
                pV[1] = (FLOAT*)(pVerts + (i + 1) * vstride);
                pV[2] = (FLOAT*)(pVerts + (i + 2) * vstride);
                pN[0] = (FLOAT*)(pNorms);
                pN[1] = (FLOAT*)(pNorms + (i + 1) * nstride);
                pN[2] = (FLOAT*)(pNorms + (i + 2) * nstride);
                iM[0] = pDP->VStart;         iN[0] = 0;
                iM[1] = pDP->VStart + i + 1; iN[1] = 0;
                iM[2] = pDP->VStart + i + 2; iN[2] = 0;
                
                RDNPatch patch(pV, pN, GetRS()[D3DRS_POSITIONORDER], GetRS()[D3DRS_NORMALORDER]);

                hr = DrawNPatch(patch, 0, iM, iN, unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]));
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            for(unsigned i = 0; i < pDP->PrimitiveCount; ++i)
            {
                FLOAT *pV[3], *pN[3];
                unsigned iM[3], iN[3];

                pV[0] = (FLOAT*)(pVerts + i * vstride);
                pN[0] = (FLOAT*)(pNorms + i * nstride);
                iM[0] = pDP->VStart + i; iN[0] = 0;
                iM[0] = pDP->VStart + i; iN[0] = 0;
                if((i & 1) != 0)
                {
                    pV[1] = (FLOAT*)(pVerts + (i + 2) * vstride);
                    pV[2] = (FLOAT*)(pVerts + (i + 1) * vstride);
                    pN[1] = (FLOAT*)(pNorms + (i + 2) * nstride);
                    pN[2] = (FLOAT*)(pNorms + (i + 1) * nstride);
                    iM[1] = pDP->VStart + i + 2; iN[1] = 0;
                    iM[2] = pDP->VStart + i + 1; iN[2] = 0;
                }
                else
                {
                    pV[1] = (FLOAT*)(pVerts + (i + 1) * vstride);
                    pV[2] = (FLOAT*)(pVerts + (i + 2) * vstride);
                    pN[1] = (FLOAT*)(pNorms + (i + 1) * nstride);
                    pN[2] = (FLOAT*)(pNorms + (i + 2) * nstride);
                    iM[1] = pDP->VStart + i + 1; iN[1] = 0;
                    iM[2] = pDP->VStart + i + 2; iN[2] = 0;
                }

                RDNPatch patch(pV, pN, GetRS()[D3DRS_POSITIONORDER], GetRS()[D3DRS_NORMALORDER]);

                hr = DrawNPatch(patch, 0, iM, iN, unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]));
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
        break;
    default:
        _ASSERT(FALSE, "Unsupported primitive type");        
        hr = E_FAIL;
    }
    
    return hr;
}

//-----------------------------------------------------------------------------
// RefDev::ProcessTessIndexedPrimitive
//-----------------------------------------------------------------------------
HRESULT 
RefDev::ProcessTessIndexedPrimitive( LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pDIP )
{
    HRESULT hr = S_OK;

    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) )
    {
        //
        // The legacy FVF style: The Zero'th Stream is implied
        //
        DWORD dwFVF    = m_CurrentVShaderHandle;
        RDVStream& Stream = m_VStream[0];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwFVFSize = GetFVFVertexSize( dwFVF );

        if( Stream.m_pData == NULL || dwStride == 0 )
        {
            DPFERR( "Zero'th stream doesnt have valid VB set" );
            return DDERR_INVALIDPARAMS;
        }
        if( dwStride < dwFVFSize )
        {
            DPFERR( "The stride set for the vertex stream is less than"
                    " the FVF vertex size" );
            return E_FAIL;
        }
        
        if( m_IndexStream.m_pData == NULL )
        {
            DPFERR( "Indices are not available" );
            return E_FAIL;
        }
    }

    BYTE *pVerts = 0, *pNorms = 0;
    unsigned vstride, nstride;

    // Figure out where the positions and normals are
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned e = 0; e < Decl.m_dwNumElements; ++e)
    {
        RDVElement &velem = Decl.m_VertexElements[e];
        if(velem.m_dwRegister == D3DVSDE_POSITION) // Position
        {
            RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
            pVerts = vstream.m_pSavedData + pDIP->BaseVertexIndex * vstream.m_dwStride + velem.m_dwOffset;
            vstride = vstream.m_dwStride;
        }
        else if(velem.m_dwRegister == D3DVSDE_NORMAL) // Normal
        {
            RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
            pNorms = vstream.m_pSavedData + pDIP->BaseVertexIndex * vstream.m_dwStride + velem.m_dwOffset;
            nstride = vstream.m_dwStride;
        }
    }

    if(pVerts == 0 || pNorms == 0)
    {
        DPFERR("This tessellation scheme needs positions and normals explicitely specified");
        return DDERR_INVALIDPARAMS;
    }

    RRIndexAccessor Index(m_IndexStream.m_pData, m_IndexStream.m_dwStride, pDIP->StartIndex);

    switch(pDIP->primType)
    {
    case D3DPT_TRIANGLELIST:
        {
            for(unsigned i = 0; i < pDIP->PrimitiveCount; ++i)
            {
                FLOAT *pV[3], *pN[3];
                unsigned iM[3], iN[3];

                pV[0] = (FLOAT*)(pVerts + Index[i * 3] * vstride);
                pV[1] = (FLOAT*)(pVerts + Index[i * 3 + 1] * vstride);
                pV[2] = (FLOAT*)(pVerts + Index[i * 3 + 2] * vstride);
                pN[0] = (FLOAT*)(pNorms + Index[i * 3] * nstride);
                pN[1] = (FLOAT*)(pNorms + Index[i * 3 + 1] * nstride);
                pN[2] = (FLOAT*)(pNorms + Index[i * 3 + 2] * nstride);
                iM[0] = pDIP->BaseVertexIndex + Index[i * 3];     iN[0] = 0;
                iM[1] = pDIP->BaseVertexIndex + Index[i * 3 + 1]; iN[1] = 0;
                iM[2] = pDIP->BaseVertexIndex + Index[i * 3 + 2]; iN[2] = 0;

                RDNPatch patch(pV, pN, GetRS()[D3DRS_POSITIONORDER], GetRS()[D3DRS_NORMALORDER]);
                
                hr = DrawNPatch(patch, 0, iM, iN, unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]));
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            for(unsigned i = 0; i < pDIP->PrimitiveCount; ++i)
            {
                FLOAT *pV[3], *pN[3];
                unsigned iM[3], iN[3];
                
                pV[0] = (FLOAT*)(pVerts + Index[0] * vstride);
                pV[1] = (FLOAT*)(pVerts + Index[i + 1] * vstride);
                pV[2] = (FLOAT*)(pVerts + Index[i + 2] * vstride);
                pN[0] = (FLOAT*)(pNorms + Index[0] * nstride);
                pN[1] = (FLOAT*)(pNorms + Index[i + 1] * nstride);
                pN[2] = (FLOAT*)(pNorms + Index[i + 2] * nstride);
                iM[0] = pDIP->BaseVertexIndex + Index[0];     iN[0] = 0;
                iM[1] = pDIP->BaseVertexIndex + Index[i + 1]; iN[1] = 0;
                iM[2] = pDIP->BaseVertexIndex + Index[i + 2]; iN[2] = 0;
                
                RDNPatch patch(pV, pN, GetRS()[D3DRS_POSITIONORDER], GetRS()[D3DRS_NORMALORDER]);

                hr = DrawNPatch(patch, 0, iM, iN, unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]));
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            for(unsigned i = 0; i < pDIP->PrimitiveCount; ++i)
            {
                FLOAT *pV[3], *pN[3];
                unsigned iM[3], iN[3];

                pV[0] = (FLOAT*)(pVerts + Index[i] * vstride);
                pN[0] = (FLOAT*)(pNorms + Index[i] * nstride);
                iM[0] = pDIP->BaseVertexIndex + Index[i]; iN[0] = 0;
                iM[0] = pDIP->BaseVertexIndex + Index[i]; iN[0] = 0;
                if((i & 1) != 0)
                {
                    pV[1] = (FLOAT*)(pVerts + Index[i + 2] * vstride);
                    pV[2] = (FLOAT*)(pVerts + Index[i + 1] * vstride);
                    pN[1] = (FLOAT*)(pNorms + Index[i + 2] * nstride);
                    pN[2] = (FLOAT*)(pNorms + Index[i + 1] * nstride);
                    iM[1] = pDIP->BaseVertexIndex + Index[i + 2]; iN[1] = 0;
                    iM[2] = pDIP->BaseVertexIndex + Index[i + 1]; iN[2] = 0;
                }
                else
                {
                    pV[1] = (FLOAT*)(pVerts + Index[i + 1] * vstride);
                    pV[2] = (FLOAT*)(pVerts + Index[i + 2] * vstride);
                    pN[1] = (FLOAT*)(pNorms + Index[i + 1] * nstride);
                    pN[2] = (FLOAT*)(pNorms + Index[i + 2] * nstride);
                    iM[1] = pDIP->BaseVertexIndex + Index[i + 1]; iN[1] = 0;
                    iM[2] = pDIP->BaseVertexIndex + Index[i + 2]; iN[2] = 0;
                }

                RDNPatch patch(pV, pN, GetRS()[D3DRS_POSITIONORDER], GetRS()[D3DRS_NORMALORDER]);

                hr = DrawNPatch(patch, 0, iM, iN, unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]));
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
        break;
    default:
        _ASSERT(FALSE, "Unsupported primitive type");        
        hr = E_FAIL;
    }
    
    return hr;
}

//-----------------------------------------------------------------------------
// RDCubicBezierTriangle::SamplePosition
//-----------------------------------------------------------------------------
void RDCubicBezierTriangle::SamplePosition(double u, double v, FLOAT *Q) const
{
    for(unsigned e = 0; e < 3; ++e)
    {
        Q[e] = FLOAT(m_B[0][0][e] * Basis(0, 0, u, v) +
                     m_B[0][3][e] * Basis(0, 3, u, v) +
                     m_B[3][0][e] * Basis(3, 0, u, v) +
                     m_B[0][1][e] * Basis(0, 1, u, v) +
                     m_B[0][2][e] * Basis(0, 2, u, v) +
                     m_B[1][2][e] * Basis(1, 2, u, v) +
                     m_B[2][1][e] * Basis(2, 1, u, v) +
                     m_B[2][0][e] * Basis(2, 0, u, v) +
                     m_B[1][0][e] * Basis(1, 0, u, v) +
                     m_B[1][1][e] * Basis(1, 1, u, v));
    }
}

//-----------------------------------------------------------------------------
// RDCubicBezierTriangle::Sample
//-----------------------------------------------------------------------------
void RDCubicBezierTriangle::Sample(DWORD dwDataType, double u, double v, const BYTE* const B[], BYTE *Q) const
{
    double w = 1.0 - u - v;
    unsigned dwElements = 0;
    switch(dwDataType)
    {
        case D3DVSDT_FLOAT4:
            ++dwElements;
        case D3DVSDT_FLOAT3:
            ++dwElements;
        case D3DVSDT_FLOAT2:
            ++dwElements;
        case D3DVSDT_FLOAT1:
            ++dwElements;
            {
                for(unsigned e = 0; e < dwElements; ++e)
                {
                    ((FLOAT*)Q)[e] = FLOAT(w * double(((FLOAT*)B[0])[e]) + v * double(((FLOAT*)B[1])[e]) + u * double(((FLOAT*)B[2])[e]));
                }
            }
            break;
        case D3DVSDT_D3DCOLOR:
        case D3DVSDT_UBYTE4:
            dwElements = 4;
            {
                for(unsigned e = 0; e < 4; ++e)
                {
                    int t = int(w * double(B[0][e]) + v * double(B[1][e]) + u * double(B[2][e]));
                    Q[e] = BYTE(t < 0 ? 0 : (t > 255 ? 255 : t));
                }
            }
            break;
        case D3DVSDT_SHORT4:
            dwElements += 2;
        case D3DVSDT_SHORT2:
            dwElements += 2;
            {
                for(unsigned e = 0; e < dwElements; ++e)
                {
                    ((SHORT*)Q)[e] = SHORT(w * double(((SHORT*)B[0])[e]) + v * double(((SHORT*)B[1])[e]) + u * double(((SHORT*)B[2])[e]));
                }
            }
            break;
        default:
            _ASSERT(FALSE, "Ununderstood vertex element data type");
    }
}

//-----------------------------------------------------------------------------
// RDNPatch::RDNPatch
//-----------------------------------------------------------------------------
RDNPatch::RDNPatch(const FLOAT* const pV[], const FLOAT* const pN[], 
                   const DWORD PositionOrder, const DWORD NormalOrder)
{
    _ASSERT((PositionOrder == D3DORDER_LINEAR) || (PositionOrder == D3DORDER_CUBIC), 
            "Unsupported position order in NPatch");        
    _ASSERT((NormalOrder == D3DORDER_LINEAR) || (NormalOrder == D3DORDER_QUADRATIC), 
            "Unsupported normal order in NPatch");        

    m_PositionOrder = PositionOrder;
    m_NormalOrder = NormalOrder;
    // Assign corner points
    m_B[0][0][0] = double(pV[0][0]);
    m_B[0][0][1] = double(pV[0][1]);
    m_B[0][0][2] = double(pV[0][2]);
    m_B[0][3][0] = double(pV[1][0]);
    m_B[0][3][1] = double(pV[1][1]);
    m_B[0][3][2] = double(pV[1][2]);
    m_B[3][0][0] = double(pV[2][0]);
    m_B[3][0][1] = double(pV[2][1]);
    m_B[3][0][2] = double(pV[2][2]);

    if (PositionOrder == D3DORDER_CUBIC)
    {
        // Compute edge control points
        ComputeEdgeControlPoint(0, 1, pV, pN, 0, 1);
        ComputeEdgeControlPoint(1, 0, pV, pN, 0, 2);
        ComputeEdgeControlPoint(1, 2, pV, pN, 1, 2);
        ComputeEdgeControlPoint(2, 1, pV, pN, 2, 1);
        ComputeEdgeControlPoint(2, 0, pV, pN, 2, 0);
        ComputeEdgeControlPoint(0, 2, pV, pN, 1, 0);

        // Compute central control point
        m_B[1][1][0] = (m_B[2][0][0] + m_B[1][0][0] + m_B[0][2][0] + m_B[0][1][0] + m_B[2][1][0] + m_B[1][2][0]) / 4.0 -
                        (m_B[3][0][0] + m_B[0][3][0] + m_B[0][0][0]) / 6.0;
        m_B[1][1][1] = (m_B[2][0][1] + m_B[1][0][1] + m_B[0][2][1] + m_B[0][1][1] + m_B[2][1][1] + m_B[1][2][1]) / 4.0 -
                        (m_B[3][0][1] + m_B[0][3][1] + m_B[0][0][1]) / 6.0;
        m_B[1][1][2] = (m_B[2][0][2] + m_B[1][0][2] + m_B[0][2][2] + m_B[0][1][2] + m_B[2][1][2] + m_B[1][2][2]) / 4.0 -
                        (m_B[3][0][2] + m_B[0][3][2] + m_B[0][0][2]) / 6.0;
    }
    if (NormalOrder == D3DORDER_QUADRATIC)
    {
        // Compute central control point
        Normalize(*(RDVECTOR3*)pN[0]);
        Normalize(*(RDVECTOR3*)pN[1]);
        Normalize(*(RDVECTOR3*)pN[2]);
        m_N002 = *(RDVECTOR3*)pN[0];
        m_N020 = *(RDVECTOR3*)pN[1];
        m_N200 = *(RDVECTOR3*)pN[2];
        ComputeNormalControlPoint(&m_N110, 1, 2, pV, pN);
        ComputeNormalControlPoint(&m_N101, 2, 0, pV, pN);
        ComputeNormalControlPoint(&m_N011, 0, 1, pV, pN);
    }
}

//-----------------------------------------------------------------------------
// RDNPatch::SamplePosition
//-----------------------------------------------------------------------------
void RDNPatch::SamplePosition(double u, double v, FLOAT *Q) const
{
    if (m_PositionOrder == D3DORDER_CUBIC)
        RDCubicBezierTriangle::SamplePosition(u, v, Q);
    else
    {
        double w = 1.0 - u - v;
        Q[0] = m_B[0][0][0] * w + m_B[0][3][0] * v + m_B[3][0][0] * u;
        Q[1] = m_B[0][0][1] * w + m_B[0][3][1] * v + m_B[3][0][1] * u;
        Q[2] = m_B[0][0][2] * w + m_B[0][3][2] * v + m_B[3][0][2] * u;
    }
}

//-----------------------------------------------------------------------------
// RDNPatch::SampleNormal
//-----------------------------------------------------------------------------
void RDNPatch::SampleNormal(double u, double v, const BYTE* const B[], FLOAT *Q) const
{
    if (m_NormalOrder == D3DORDER_LINEAR)
        RDCubicBezierTriangle::Sample(D3DVSDT_FLOAT3, u, v, B, (BYTE*)Q);
    else
    {
        // Computed by article "Curved PN Triangles" (Chas Boyd, ...)
        double w = 1.0 - u - v;
        double ww = w*w;
        double uu = u*u;
        double vv = v*v;
        double uv = u*v;
        double wu = w*u;
        double wv = w*v;
        Q[0] = m_N200.x * uu + m_N020.x * vv + m_N002.x * ww + m_N110.x * uv + m_N011.x * wv + m_N101.x * wu;
        Q[1] = m_N200.y * uu + m_N020.y * vv + m_N002.y * ww + m_N110.y * uv + m_N011.y * wv + m_N101.y * wu;
        Q[2] = m_N200.z * uu + m_N020.z * vv + m_N002.z * ww + m_N110.z * uv + m_N011.z * wv + m_N101.z * wu;
        Normalize(*(RDVECTOR3*)Q);
    }
}

//-----------------------------------------------------------------------------
// RDNPatch::ComputeNormalControlPoint
//-----------------------------------------------------------------------------
void RDNPatch::ComputeNormalControlPoint(RDVECTOR3* cp, unsigned i, unsigned j,
                                         const FLOAT* const pV[], 
                                         const FLOAT* const pN[])
{
    RDVECTOR3 Pji, Nij;
    SubtractVector(*(RDVECTOR3*)pV[j], *(RDVECTOR3*)pV[i], Pji);
    AddVector(*(RDVECTOR3*)pN[j], *(RDVECTOR3*)pN[i], Nij);
    FLOAT v = 2.0f * DotProduct(Pji, Nij) / DotProduct(Pji, Pji);
    SubtractVector(Nij, ScaleVector(Pji, v), *cp);
}

//-----------------------------------------------------------------------------
// RDNPatch::ComputeEdgeControlPoint
//-----------------------------------------------------------------------------
void RDNPatch::ComputeEdgeControlPoint(unsigned a, unsigned b, const FLOAT* const pV[], const FLOAT* const pN[], unsigned u, unsigned v)
{
    static const double Tension = 1.0 / 3.0; 
    double t, Edge[3];

    Edge[0] = double(pV[b][0]) - double(pV[a][0]);
    Edge[1] = double(pV[b][1]) - double(pV[a][1]);
    Edge[2] = double(pV[b][2]) - double(pV[a][2]);

    t = Edge[0] * double(pN[a][0]) + Edge[1] * double(pN[a][1]) + Edge[2] * double(pN[a][2]);

    m_B[u][v][0] = double(pV[a][0]) + (Edge[0] - t * double(pN[a][0])) * Tension;
    m_B[u][v][1] = double(pV[a][1]) + (Edge[1] - t * double(pN[a][1])) * Tension;
    m_B[u][v][2] = double(pV[a][2]) + (Edge[2] - t * double(pN[a][2])) * Tension;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\hop\sources.inc ===
TARGETNAME = refhop
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\drawgrid.cpp  \
        ..\bspline.cpp \
        ..\bezier.cpp \
        ..\npatch.cpp \
        ..\catrom.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\inc\rddmon.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// rddmon.hpp
//
// Reference Device Debug Monitor
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _RDDMON_HPP
#define _RDDMON_HPP

#include "debugmon.hpp"

#define D3DDM_IMAGE_MAX 16
typedef struct _ShMemImage
{
    D3DSharedMem* pSM;
    UINT W;
    UINT H;
    UINT BPP;
    RDSurfaceFormat SF;
    void* pBits;
} ShMemImage;

class RDDebugMonitor : public D3DDebugMonitor
{
protected:
    RefDev* m_pRD;

    // shared memory image - dumps surface buffers for image viewer tool
    UINT    m_NumShMemI;
    ShMemImage  m_ShMemI[D3DDM_IMAGE_MAX];
    void    GrowShMemArray( UINT ShMemI );
    void    ShMemIRenderTarget( DWORD Flags, UINT iSM );
    void    ShMemISurface2D( RDSurface2D* pRS, INT32 iLOD, DWORD Flags, UINT iSM );

public:
    RDDebugMonitor( RefDev* pRD, BOOL bDbgMonConnectionEnabled );
    ~RDDebugMonitor( void );

    // x,y render grid mask
    DWORD   m_ScreenMask[2];
    inline BOOL ScreenMask( UINT iX, UINT iY )
    {
        return
            !((1L<<(iX%32)) & m_ScreenMask[0]) ||
            !((1L<<(iY%32)) & m_ScreenMask[1]) ;
    }

    void NextEvent( UINT32 EventType );
    HRESULT ProcessMonitorCommand( void );
};

///////////////////////////////////////////////////////////////////////////////
#endif // _DEBUGMON_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\inc\rdcomm.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rdcomm.hpp
//
// Direct3D Reference Device - Common Header
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _RDCOMM_HPP
#define  _RDCOMM_HPP

#include <math.h>

#ifndef FASTCALL
#ifdef _X86_
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif
#endif

#ifndef CDECL
#ifdef _X86_
#define CDECL __cdecl
#else
#define CDECL
#endif
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Globals                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// memory allocation callbacks
extern LPVOID (__cdecl *g_pfnMemAlloc)( size_t size );
extern void   (__cdecl *g_pfnMemFree)( LPVOID lptr );
extern LPVOID (__cdecl *g_pfnMemReAlloc)( LPVOID ptr, size_t size );

// debug print controls
extern int g_iDPFLevel;
extern unsigned long g_uDPFMask;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Typedefs                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef DllExport
#define DllExport   __declspec( dllexport )
#endif

// width-specific typedefs for basic types
//@@BEGIN_MSINTERNAL
#ifndef _BASETSD_H_
//@@END_MSINTERNAL
typedef signed char             INT8, *PINT8;
typedef short int               INT16, *PINT16;
typedef int                     INT32, *PINT32;
typedef __int64                 INT64, *PINT64;
typedef unsigned char           UINT8, *PUINT8;
typedef unsigned short int      UINT16, *PUINT16;
typedef unsigned int            UINT32, *PUINT32;
typedef unsigned __int64        UINT64, *PUINT64;
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL

typedef float                   FLOAT;
typedef double                  DOUBLE;
typedef int                     BOOL;
typedef FLOAT                  *PFLOAT;
typedef DOUBLE                 *PDOUBLE;

struct RDVECTOR4
{
    RDVECTOR4()
    {
        memset( this, 0, sizeof( *this ) );
    }
    union
    {
        struct
        {
            union
            {
                D3DVALUE x;
                D3DVALUE r;
            };
            union
            {
                D3DVALUE y;
                D3DVALUE g;
            };
            union
            {
                D3DVALUE z;
                D3DVALUE b;
            };
            union
            {
                D3DVALUE w;
                D3DVALUE a;
            };
        };
        D3DVALUE v[4];
    };
};

struct RDVECTOR3
{
    RDVECTOR3()
    {
        memset( this, 0, sizeof( *this ) );
    }

    union
    {
        struct
        {
            D3DVALUE x;
            D3DVALUE y;
            D3DVALUE z;
        };
        D3DVALUE v[3];
    };
};

struct RDCOLOR3
{
    // 0 - 255
    D3DVALUE r,g,b;
};

struct RDCOLOR4
{
    // Normalized 0 - 1
    D3DVALUE r,g,b,a;
};

struct RDLIGHTINGELEMENT
{
    RDVECTOR3 dvPosition;
    RDVECTOR3 dvNormal;
};


//-----------------------------------------------------------------------------
//
// Surface formats for rendering surfaces and textures.  Different subsets are
// supported for render targets and for textures.
//
//-----------------------------------------------------------------------------
typedef enum _RDSurfaceFormat
{
    RD_SF_NULL     = 0,
    RD_SF_B8G8R8   = 1,
    RD_SF_B8G8R8A8 = 2,
    RD_SF_B8G8R8X8 = 3,
    RD_SF_B5G6R5   = 4,
    RD_SF_B5G5R5A1 = 5,
    RD_SF_B5G5R5X1 = 6,
    RD_SF_PALETTE4 = 7,
    RD_SF_PALETTE8 = 8,
    RD_SF_B4G4R4A4 = 9,
    RD_SF_B4G4R4X4 =10,
    RD_SF_L8       =11,          // 8 bit luminance-only
    RD_SF_L8A8     =12,          // 16 bit alpha-luminance
    RD_SF_U8V8     =13,          // 16 bit bump map format
    RD_SF_U5V5L6   =14,          // 16 bit bump map format with luminance
    RD_SF_U8V8L8X8 =15,          // 32 bit bump map format with luminance
    RD_SF_UYVY     =16,          // UYVY format (PC98 compliance)
    RD_SF_YUY2     =17,          // YUY2 format (PC98 compliance)
    RD_SF_DXT1     =18,          // DXT texture compression technique 1
    RD_SF_DXT2     =19,          // DXT texture compression technique 2
    RD_SF_DXT3     =20,          // DXT texture compression technique 3
    RD_SF_DXT4     =21,          // DXT texture compression technique 4
    RD_SF_DXT5     =22,          // DXT texture compression technique 5
    RD_SF_B2G3R3   =23,          // 8 bit RGB texture format
    RD_SF_L4A4     =24,          // 8 bit alpha-luminance
    RD_SF_B2G3R3A8 =25,          // 16 bit alpha-rgb
    RD_SF_U16V16   =26,          // 32 bit bump map format
    RD_SF_U10V11W11=27,          // 32 bit signed format for custom data
    RD_SF_U8V8W8Q8 =28,          // 32 bit signed format for custom data
    RD_SF_A8       =29,          // 8 bit alpha only
    RD_SF_P8A8     =30,          // 8 bit alpha + 8 bit palette

    // The following have been introduced in DX 8.1
    // The byte ordering is opposite to that in the D3DFORMAT_*
    // definition, so RD_SF_R8G8B8A8 here corresponds to D3DFORMAT_A8B8G8R8
    // hence the DWORD contains AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR
    // This is not true for the Depth formats.

    RD_SF_R10G10B10A2      = 31, 
    RD_SF_R8G8B8A8         = 32,
    RD_SF_R8G8B8X8         = 33,
    RD_SF_R16G16           = 34,
    RD_SF_U11V11W10        = 35,
    RD_SF_U10V10W10A2      = 36,
    RD_SF_U8V8X8A8         = 37,
    RD_SF_U8V8X8L8         = 38,

    RD_SF_Z16S0    =70,
    RD_SF_Z24S8    =71,
    RD_SF_Z24X8    =72,
    RD_SF_Z15S1    =73,
    RD_SF_Z32S0    =74,
    RD_SF_S1Z15    =75,
    RD_SF_S8Z24    =76,
    RD_SF_X8Z24    =77,
    RD_SF_Z24X4S4  =78,
    RD_SF_X4S4Z24  =79,

} RDSurfaceFormat;

// compute pixel address from x,y location, sample number, and surface info
char*
PixelAddress( int iX, int iY, int iZ, BYTE* pBits, int iYPitch, int iZPitch, RDSurfaceFormat SType );

class RDSurface2D;

char*
PixelAddress( int iX, int iY, int iZ, int iSample, RDSurface2D* pRT );

// The most general pixel address calculation
char*
PixelAddress( int iX, int iY, int iZ, int iSample, BYTE* pBits, int iYPitch, int iZPitch, int cSamples,
              RDSurfaceFormat SType );

//---------------------------------------------------------------------
// Inline functions to answer various questions about surface formats.
//---------------------------------------------------------------------
inline BOOL
IsDXTn( DWORD dwFourCC )
{
    return ((dwFourCC == MAKEFOURCC('D', 'X', 'T', '1')) ||
            (dwFourCC == MAKEFOURCC('D', 'X', 'T', '2')) ||
            (dwFourCC == MAKEFOURCC('D', 'X', 'T', '3')) ||
            (dwFourCC == MAKEFOURCC('D', 'X', 'T', '4')) ||
            (dwFourCC == MAKEFOURCC('D', 'X', 'T', '5')));
}

inline BOOL
IsYUV( DWORD dwFourCC )
{
    return ((dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y')) ||
            (dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2')));
}

//---------------------------------------------------------------------
// This class manages growing buffer, aligned to 32 byte boundary
// Number if bytes should be power of 2.
// D3DMalloc is used to allocate memory
//---------------------------------------------------------------------

class RefAlignedBuffer32
{
public:
    RefAlignedBuffer32()  {m_size = 0; m_allocatedBuf = 0; m_alignedBuf = 0;}
    ~RefAlignedBuffer32() {if (m_allocatedBuf) free(m_allocatedBuf);}
    // Returns aligned buffer address
    LPVOID GetAddress() {return m_alignedBuf;}
    // Returns aligned buffer size
    DWORD GetSize() {return m_size;}
    HRESULT Grow(DWORD dwSize);
    HRESULT CheckAndGrow(DWORD dwSize)
    {
        if (dwSize > m_size)
            return Grow(dwSize + 1024);
        else
            return S_OK;
    }
protected:
    LPVOID m_allocatedBuf;
    LPVOID m_alignedBuf;
    DWORD  m_size;
};

//-----------------------------------------------------------------------------
//
// Private FVF flags
//
//-----------------------------------------------------------------------------
#define D3DFVFP_FOG           ((UINT64)1<<32) // Fog is present
#define D3DFVFP_CLIP          ((UINT64)1<<33) // Clip coordinates are present
#define D3DFVFP_POSITION2     ((UINT64)1<<34) // Position2 present (tweening)
#define D3DFVFP_NORMAL2       ((UINT64)1<<35) // Normal2 present (tweening)
#define D3DFVFP_BLENDINDICES  ((UINT64)1<<36) // Blend Indices present.

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef NULL
#define NULL 0
#endif

#define MAX(a,b)  (((a) > (b)) ? (a) : (b))
#define MIN(a,b)  (((a) < (b)) ? (a) : (b))
#define ABS(a) (((a) < 0) ? (-(a)) : (a))

// Check the return value and return if something wrong.
// Assume hr has been declared
#define HR_RET(exp)                                                           \
{                                                                             \
    hr = (exp);                                                               \
    if (hr != S_OK)                                                         \
    {                                                                         \
        return hr;                                                            \
    }                                                                         \
}

//-----------------------------------------------------------------------------
// macros for converting n-bit signed integers to floats clamped to [-1.0, 1.0]
//
// e.g. For an 8 bit number, if it is -128, it gets clamped to -127.
//      Then the number is divided by 127.
//
//-----------------------------------------------------------------------------

inline FLOAT CLAMP_SIGNED16(INT16 i)
{
    return (-32768 == i ? -1.f : (FLOAT)i/32767.f);
}

inline FLOAT CLAMP_SIGNED11(INT16 i) //only looks at bottom 11 bits
{
    // sign extend to 16 bits
    i <<= 5; i >>= 5;
    return (-1024 == i ? -1.f : (FLOAT)i/1023.f);
}

inline FLOAT CLAMP_SIGNED10(INT16 i) //only looks at bottom 10 bits
{
    // sign extend to 16 bits
    i <<= 6; i >>= 6;
    return (-512 == i ? -1.f : (FLOAT)i/511.f);
}

inline FLOAT CLAMP_SIGNED8(INT8 i)
{
    return (-128 == i ? -1.f : (FLOAT)i/127.f);
}

inline FLOAT CLAMP_SIGNED6(INT8 i) //only looks at bottom 6 bits
{
    // sign extend to 8 bits
    i <<= 2; i >>= 2;
    return (-32 == i ? -1.f : (FLOAT)i/31.f);
}

inline FLOAT CLAMP_SIGNED5(INT8 i) //only looks at bottom 5 bits
{
    // sign extend to 8 bits
    i <<= 3; i >>= 3;
    return (-16 == i ? -1.f : (FLOAT)i/15.f);
}

inline FLOAT CLAMP_SIGNED4(INT8 i)  //only looks at bottom 4 bits
{
    // sign extend to 8 bits
    i <<= 4; i >>= 4;
    return (-8 == i ? -1.f : (FLOAT)i/7.f);
}

//-----------------------------------------------------------------------------
//
// macros for accessing floating point data as 32 bit integers and vice versa
//
// This is used primarily to do floating point to fixed point conversion with
// the unbiased nearest-even rounding that IEEE floating point does internally
// between operations.  Adding a big number slides the mantissa down to where
// the fixed point equivalent is aligned to the LSB.  IEEE applies a nearest-
// even round to the bits it lops off before storing.  The mantissa can then
// be grabbed by the AS_INT* operations.  Note that the sign and exponent are
// still there, so the easiest thing is to do it with doubles and grab the low
// 32 bits.
//
// The snap values (i.e. the "big number") is the sum of 2**n and 2**(n-1),
// which makes the trick return signed numbers (at least within the mantissa).
//
//-----------------------------------------------------------------------------

#if 0
// NOTE: vc5 optimizing compiler bug breaks this pointer casting technique
#define AS_FLOAT(i) ( *(FLOAT*)&(i) )
#define AS_INT32(f) ( *(INT32*)&(f) )
#define AS_INT16(f) ( *(INT16*)&(f) )
#define AS_UINT32(f) ( *(UINT32*)&(f) )

#else

// workaround using union
typedef union { float f; UINT32 u; INT32 i; } VAL32;
typedef union { double d; UINT64 u; INT64 i; } VAL64;
inline FLOAT AS_FLOAT( long int iVal ) { VAL32 v; v.i = iVal; return v.f; }
inline FLOAT AS_FLOAT( unsigned long int uVal ) { VAL32 v; v.u = uVal; return v.f; }
inline INT32 AS_INT32(  FLOAT fVal ) { VAL32 v; v.f = fVal; return v.i; }
inline INT32 AS_INT32( DOUBLE dVal ) { VAL64 v; v.d = dVal; return (INT32)(v.u & 0xffffffff); }
inline INT16 AS_INT16(  FLOAT fVal ) { VAL32 v; v.f = fVal; return (INT16)(v.u & 0xffff); }
inline INT16 AS_INT16( DOUBLE dVal ) { VAL64 v; v.d = dVal; return (INT16)(v.u & 0xffff); }
inline INT32 AS_UINT32( FLOAT fVal ) { VAL32 v; v.f = fVal; return v.u; }

#endif

//-----------------------------------------------------------------------------
//
// Some common FP values as constants
// point values
//
//-----------------------------------------------------------------------------
#define g_fZero                 (0.0f)
#define g_fOne                  (1.0f)

// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

const D3DVALUE __HUGE_PWR2 = 1024.0f*1024.0f*2.0f;

//-----------------------------------------------------------------------------
//
// these are handy to form 'magic' constants to snap real values to fixed
// point values
//
//-----------------------------------------------------------------------------
#define C2POW0 1
#define C2POW1 2
#define C2POW2 4
#define C2POW3 8
#define C2POW4 16
#define C2POW5 32
#define C2POW6 64
#define C2POW7 128
#define C2POW8 256
#define C2POW9 512
#define C2POW10 1024
#define C2POW11 2048
#define C2POW12 4096
#define C2POW13 8192
#define C2POW14 16384
#define C2POW15 32768
#define C2POW16 65536
#define C2POW17 131072
#define C2POW18 262144
#define C2POW19 524288
#define C2POW20 1048576
#define C2POW21 2097152
#define C2POW22 4194304
#define C2POW23 8388608
#define C2POW24 16777216
#define C2POW25 33554432
#define C2POW26 67108864
#define C2POW27 134217728
#define C2POW28 268435456
#define C2POW29 536870912
#define C2POW30 1073741824
#define C2POW31 2147483648
#define C2POW32 4294967296
#define C2POW33 8589934592
#define C2POW34 17179869184
#define C2POW35 34359738368
#define C2POW36 68719476736
#define C2POW37 137438953472
#define C2POW38 274877906944
#define C2POW39 549755813888
#define C2POW40 1099511627776
#define C2POW41 2199023255552
#define C2POW42 4398046511104
#define C2POW43 8796093022208
#define C2POW44 17592186044416
#define C2POW45 35184372088832
#define C2POW46 70368744177664
#define C2POW47 140737488355328
#define C2POW48 281474976710656
#define C2POW49 562949953421312
#define C2POW50 1125899906842624
#define C2POW51 2251799813685248
#define C2POW52 4503599627370496

#define FLOAT_0_SNAP    (FLOAT)(C2POW23+C2POW22)
#define FLOAT_4_SNAP    (FLOAT)(C2POW19+C2POW18)
#define FLOAT_5_SNAP    (FLOAT)(C2POW18+C2POW17)
#define FLOAT_8_SNAP    (FLOAT)(C2POW15+C2POW14)
#define FLOAT_17_SNAP   (FLOAT)(C2POW6 +C2POW5 )
#define FLOAT_18_SNAP   (FLOAT)(C2POW5 +C2POW4 )

#define DOUBLE_0_SNAP   (DOUBLE)(C2POW52+C2POW51)
#define DOUBLE_4_SNAP   (DOUBLE)(C2POW48+C2POW47)
#define DOUBLE_5_SNAP   (DOUBLE)(C2POW47+C2POW46)
#define DOUBLE_8_SNAP   (DOUBLE)(C2POW44+C2POW43)
#define DOUBLE_17_SNAP  (DOUBLE)(C2POW35+C2POW34)
#define DOUBLE_18_SNAP  (DOUBLE)(C2POW34+C2POW33)

//-----------------------------------------------------------------------------
//
// Floating point related macros
//
//-----------------------------------------------------------------------------
#define COSF(fV)        ((FLOAT)cos((double)(fV)))
#define SINF(fV)        ((FLOAT)sin((double)(fV)))
#define SQRTF(fV)       ((FLOAT)sqrt((double)(fV)))
#define POWF(fV, fE)    ((FLOAT)pow((double)(fV), (double)(fE)))

#ifdef _X86_
#define FLOAT_CMP_POS(fa, op, fb)       (AS_INT32(fa) op AS_INT32(fb))
#define FLOAT_CMP_PONE(flt, op)         (AS_INT32(flt) op INT32_FLOAT_ONE)

__inline int FLOAT_GTZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.i > 0;
}
__inline int FLOAT_LTZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.u > 0x80000000;
}
__inline int FLOAT_GEZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.u <= 0x80000000;
}
__inline int FLOAT_LEZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.i <= 0;
}
__inline int FLOAT_EQZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) == 0;
}
__inline int FLOAT_NEZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) != 0;
}

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    fi.u &= 0x7fffffff;
    return fi.f;
}

// Requires chop rounding.
__inline INT
FTOI(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fistp i
    }

    return i.LowPart;
}

#else

#define FLOAT_GTZ(flt)                  ((flt) > g_fZero)
#define FLOAT_LTZ(flt)                  ((flt) < g_fZero)
#define FLOAT_GEZ(flt)                  ((flt) >= g_fZero)
#define FLOAT_LEZ(flt)                  ((flt) <= g_fZero)
#define FLOAT_EQZ(flt)                  ((flt) == g_fZero)
#define FLOAT_NEZ(flt)                  ((flt) != g_fZero)
#define FLOAT_CMP_POS(fa, op, fb)       ((fa) op (fb))
#define FLOAT_CMP_PONE(flt, op)         ((flt) op g_fOne)

#define ABSF(f)                 ((FLOAT)fabs((double)(f)))
#define FTOI(f)                 ((INT)(f))

#endif // _X86_



//-----------------------------------------------------------------------------
//
// macro wrappers for memory allocation - wrapped around global function ptrs
// set by RefRastSetMemif
//
//-----------------------------------------------------------------------------
#define MEMALLOC(_size)         ((*g_pfnMemAlloc)(_size))
#define MEMFREE(_ptr)           { if (NULL != (_ptr)) { ((*g_pfnMemFree)(_ptr)); } }
#define MEMREALLOC(_ptr,_size)  ((*g_pfnMemReAlloc)((_ptr),(_size)))


//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// Utility Functions                                                            //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Base class for all RefTnL classes to use common allocation functions
//
//-----------------------------------------------------------------------------
class RDAlloc
{
public:
    void* operator new(size_t s);
    void operator delete(void* p, size_t);
};

//-----------------------------------------------------------------------------
//
// debug printf support
//
//-----------------------------------------------------------------------------

void RDDebugPrintfL( int iLevel, const char* pszFormat, ... );
void RDDebugPrintf( const char* pszFormat, ... );
void RDErrorPrintf( const char* pszFormat, ... );

#define _DPF_IF     0x0001
#define _DPF_INPUT  0x0002
#define _DPF_SETUP  0x0004
#define _DPF_RAST   0x0008
#define _DPF_TEX    0x0010
#define _DPF_PIX    0x0020
#define _DPF_FRAG   0x0040
#define _DPF_STATS  0x0080
#define _DPF_DRV    0x0100
#define _DPF_TNL    0x0200
#define _DPF_VS     0x0400
#define _DPF_VVM    0x0800
#define _DPF_ANY    0xffff
#define _DPF_TEMP   0x8000

#ifdef DBG
    #define DPFRR RDDebugPrintfL
    #define DPFM( _level, _mask, _message) \
        if ((g_iDPFLevel >= (_level)) && (g_uDPFMask & (_DPF_##_mask))) { \
            RDDebugPrintf ## _message; \
        }
    #define DPFINFO RDDebugPrintf
#else
    #pragma warning(disable:4002)
    #define DPFRR()
    #define DPFM( _level, _mask, _message)
    #define DPFINFO
#endif

#define DPFERR RDErrorPrintf


//-----------------------------------------------------------------------------
//
// assert macros and reporting functions
//
//-----------------------------------------------------------------------------

// ASSERT with simple string
#undef _ASSERT
#define _ASSERT( value, string )                  \
if ( !(value) ) {                                 \
    RDAssertReport( string, __FILE__, __LINE__ ); \
}
// ASSERT with formatted string - note extra parenthesis on report
// usage: _ASSERTf(foo,("foo is %d",foo))
#undef _ASSERTf
#define _ASSERTf(value,report)                      \
if (!(value)) {                                     \
    char __sz__FILE__[] = __FILE__;                 \
    RDAssertReportPrefix(__sz__FILE__,__LINE__);   \
    RDAssertReportMessage ## report;               \
}
// ASSERT with action field
#undef _ASSERTa
#define _ASSERTa(value,string,action)       \
if (!(value)) {                             \
    RDAssertReport(string,__FILE__,__LINE__); \
    action                                  \
}
// ASSERTf with action field
#undef _ASSERTfa
#define _ASSERTfa(value,report,action)     \
if (!(value)) {                            \
    RDAssertReportPrefix(__FILE__,__LINE__); \
    RDAssertReportMessage ## report;         \
    action                                 \
}

extern void RDAssertReport( const char* pszString, const char* pszFile, int iLine );
extern void RDAssertReportPrefix( const char* pszFile, int iLine );
extern void RDAssertReportMessage( const char* pszFormat, ... );


//-----------------------------------------------------------------------------
//
// bit twiddling utilities
//
//-----------------------------------------------------------------------------

extern INT32 CountSetBits( UINT32 uVal, INT32 nBits );
extern INT32 FindFirstSetBit( UINT32 uVal, INT32 nBits );
extern INT32 FindMostSignificantSetBit( UINT32 uVal, INT32 nBits );
extern INT32 FindLastSetBit( UINT32 uVal, INT32 nBits );

// TRUE if integer is a power of 2
inline BOOL IsPowerOf2( INT32 i )
{
    if ( i <= 0 ) return 0;
    return ( 0x0 == ( i & (i-1) ) );
}


//-----------------------------------------------------------------------------
//
// multiply/add routines & macros for unsigned 8 bit values, signed 16 bit values
//
// These are not currently used, but the Mult8x8Scl is an interesting routine
// for hardware designers to look at.  This does a 8x8 multiply combined with
// a 256/255 scale which accurately solves the "0xff * value = value" issue.
// There are refinements on this (involving half-adders) which are not easily
// representable in C.  Credits to Steve Gabriel and Jim Blinn.
//
//-----------------------------------------------------------------------------

// straight 8x8 unsigned multiply returning 8 bits, tossing fractional
// bits (no rounding)
inline UINT8 Mult8x8( const UINT8 uA, const UINT8 uB )
{
    UINT16 uA16 = (UINT16)uA;
    UINT16 uB16 = (UINT16)uB;
    UINT16 uRes16 = uA16*uB16;
    UINT8  uRes8 = (UINT8)(uRes16>>8);
    return uRes8;
}

// 8x8 unsigned multiply with ff*val = val scale adjustment (scale by (256/255))
inline UINT8 Mult8x8Scl( const UINT8 uA, const UINT8 uB )
{
    UINT16 uA16 = (UINT16)uA;
    UINT16 uB16 = (UINT16)uB;
    UINT16 uRes16 = uA16*uB16;
    uRes16 += 0x0080;
    uRes16 += (uRes16>>8);
    UINT8  uRes8 = (UINT8)(uRes16>>8);
    return uRes8;
}

// 8x8 saturated addition - result > 0xff returns 0xff
inline UINT8 SatAdd8x8( const UINT8 uA, const UINT8 uB )
{
    UINT16 uA16 = (UINT16)uA;
    UINT16 uB16 = (UINT16)uB;
    UINT16 uRes16 = uA16+uB16;
    UINT8  uRes8 = (uRes16 > 0xff) ? (0xff) : ((UINT8)uRes16);
    return uRes8;
}

//----------------------------------------------------------------------------
//
// IntLog2
//
// Do a quick, integer log2 for exact powers of 2.
//
//----------------------------------------------------------------------------
inline UINT32 FASTCALL
IntLog2(UINT32 x)
{
    UINT32 y = 0;

    x >>= 1;
    while(x != 0)
    {
        x >>= 1;
        y++;
    }

    return y;
}
//////////////////////////////////////////////////////////////////////////////
// FVF related macros
//////////////////////////////////////////////////////////////////////////////
#define FVF_TRANSFORMED(dwFVF) ((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
#define FVF_TEXCOORD_NUMBER(dwFVF) \
    (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)


//////////////////////////////////////////////////////////////////////////////
// State Override Macros
//////////////////////////////////////////////////////////////////////////////
#define IS_OVERRIDE(type)   ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)  ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define STATESET_MASK(set, state)       \
    (set).bits[((state) - 1) >> RRSTATEOVERRIDE_DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (RRSTATEOVERRIDE_DWORD_BITS - 1)))

#define STATESET_ISSET(set, state) \
    STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state) \
    STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state) \
    STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))

//---------------------------------------------------------------------
// GetVertexCount
//---------------------------------------------------------------------
__inline DWORD
GetVertexCount( D3DPRIMITIVETYPE primType, DWORD cPrims )
{
    switch( primType )
    {
    case D3DPT_POINTLIST:
        return cPrims;
    case D3DPT_LINELIST:
        return cPrims * 2;
    case D3DPT_LINESTRIP:
        return cPrims + 1;
    case D3DPT_TRIANGLELIST:
        return cPrims * 3;
    case D3DPT_TRIANGLESTRIP:
        return cPrims + 2;
    case D3DPT_TRIANGLEFAN:
        return cPrims + 2;
    }
    return 0;
}


//---------------------------------------------------------------------
// GetTexCoordDim:
//     Computes the dimensionality of the given TexCoord in an FVF
//---------------------------------------------------------------------
#ifndef D3DFVF_GETTEXCOORDSIZE
#define D3DFVF_GETTEXCOORDSIZE(FVF, CoordIndex) ((FVF >> (CoordIndex*2 + 16)) & 0x3)
#endif

inline DWORD GetTexCoordDim( UINT64 FVF, DWORD Index)
{
    DWORD dwFVF = (DWORD)FVF;
    DWORD numTex = FVF_TEXCOORD_NUMBER(dwFVF);

    if( (numTex == 0) || (Index >= numTex ) ) return 0;

    switch( D3DFVF_GETTEXCOORDSIZE(FVF, Index) )
    {
    case D3DFVF_TEXTUREFORMAT1: return 1; break;
    case D3DFVF_TEXTUREFORMAT2: return 2; break;
    case D3DFVF_TEXTUREFORMAT3: return 3; break;
    case D3DFVF_TEXTUREFORMAT4: return 4; break;
    }
    return 0;
}

//---------------------------------------------------------------------
// GetFVFVertexSize:
//     Computes total vertex size in bytes for given fvf
//     including the texture coordinates
//---------------------------------------------------------------------
__inline DWORD
GetFVFVertexSize( UINT64 qwFVF )
{
    // Texture formats size  00   01   10   11
    static DWORD dwTextureSize[4] = {2*4, 3*4, 4*4, 4};

    DWORD dwSize = 3 << 2;
    switch( qwFVF & D3DFVF_POSITION_MASK )
    {
    case D3DFVF_XYZRHW: dwSize += 4;      break;
    case D3DFVF_XYZB1:  dwSize += 1*4;    break;
    case D3DFVF_XYZB2:  dwSize += 2*4;    break;
    case D3DFVF_XYZB3:  dwSize += 3*4;    break;
    case D3DFVF_XYZB4:  dwSize += 4*4;    break;
    case D3DFVF_XYZB5:  dwSize += 5*4;    break;
    }
    if (qwFVF & D3DFVF_NORMAL)
        dwSize += 3*4;
    if (qwFVF & D3DFVF_PSIZE)
        dwSize += 4;

    if (qwFVF & D3DFVF_DIFFUSE)
        dwSize += 4;
    if (qwFVF & D3DFVF_SPECULAR)
        dwSize += 4;
    if (qwFVF & D3DFVF_FOG)
        dwSize += 4;

    // Texture coordinates
    DWORD dwNumTexCoord = (DWORD)(FVF_TEXCOORD_NUMBER(qwFVF));
    DWORD dwTextureFormats = (DWORD)qwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        dwSize += dwNumTexCoord * 2 * 4;
    }
    else
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {

            // dwSize += GetTexCoordDim( qwFVF, i ) * sizeof( float);
            dwSize += dwTextureSize[dwTextureFormats & 3];
            dwTextureFormats >>= 2;
        }
    }

    return dwSize;
}

#if 0
//---------------------------------------------------------------------
// ComputeTextureCoordSize:
// Computes the following device data
//  - bTextureCoordSizeTotal
//  - bTextureCoordSize[] array, based on the input FVF id
//---------------------------------------------------------------------
__inline void ComputeTextureCoordInfo( DWORD dwFVF,
                                       LPDWORD pdwNumTexCoord,
                                       LPDWORD pdwTexCoordSizeArray )
{
    // Texture formats size  00   01   10   11
    static BYTE bTextureSize[4] = {2*4, 3*4, 4*4, 4};

    DWORD dwNumTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);
    *pdwNumTexCoord = dwNumTexCoord;

    // Compute texture coordinate size
    DWORD dwTextureFormats = dwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
            pdwTexCoordSizeArray[i] = 4*2;
    }
    else
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            BYTE dwSize = bTextureSize[dwTextureFormats & 3];
            pdwTexCoordSizeArray[i] = dwSize;
            dwTextureFormats >>= 2;
        }
    }
    return;
}
#endif

HRESULT
RDFVFCheckAndStride( DWORD dwFVF, DWORD* pdwStride );

///////////////////////////////////////////////////////////////////////////////
// Matrix and Vector routines
///////////////////////////////////////////////////////////////////////////////

inline void
ReverseVector(const RDVECTOR3 &in, RDVECTOR3 &out)
{
    out.x = -in.x;
    out.y = -in.y;
    out.z = -in.z;
}

inline void
AddVector(const RDVECTOR3 &v1, const RDVECTOR3 &v2, RDVECTOR3 &out)
{
    out.x = v1.x + v2.x;
    out.y = v1.y + v2.y;
    out.z = v1.z + v2.z;
}

inline void
SubtractVector(const RDVECTOR3 &v1, const RDVECTOR3 &v2, RDVECTOR3 &out)
{
    out.x = v1.x - v2.x;
    out.y = v1.y - v2.y;
    out.z = v1.z - v2.z;
}

inline RDVECTOR3&
ScaleVector(RDVECTOR3 &v, FLOAT scale)
{
    v.x = v.x * scale;
    v.y = v.y * scale;
    v.z = v.z * scale;
    return v;
}

inline void
SetIdentity(D3DMATRIX &m)
{
    m._11 = m._22 = m._33 = m._44 = 1.0f;
    m._12 = m._13 = m._14 = 0.0f;
    m._21 = m._23 = m._24 = 0.0f;
    m._31 = m._32 = m._34 = 0.0f;
    m._41 = m._42 = m._43 = 0.0f;
}


inline void
SetNull(D3DMATRIX &m)
{
    m._11 = m._22 = m._33 = m._44 = 0.0f;
    m._12 = m._13 = m._14 = 0.0f;
    m._21 = m._23 = m._24 = 0.0f;
    m._31 = m._32 = m._34 = 0.0f;
    m._41 = m._42 = m._43 = 0.0f;
}


inline void
CopyMatrix(D3DMATRIX &s, D3DMATRIX &d)
{
    d._11 = s._11;
    d._12 = s._12;
    d._13 = s._13;
    d._14 = s._14;
    d._21 = s._21;
    d._22 = s._22;
    d._23 = s._23;
    d._24 = s._24;
    d._31 = s._31;
    d._32 = s._32;
    d._33 = s._33;
    d._34 = s._34;
    d._41 = s._41;
    d._42 = s._42;
    d._43 = s._43;
    d._44 = s._44;
}

inline D3DVALUE
SquareMagnitude (const RDVECTOR3& v)
{
    return v.x*v.x + v.y*v.y + v.z*v.z;
}


inline D3DVALUE
Magnitude (const RDVECTOR3& v)
{
    return (D3DVALUE) sqrt(SquareMagnitude(v));
}

inline RDVECTOR3
Normalize (const RDVECTOR3& v)
{
    RDVECTOR3 nv;
    D3DVALUE mag = Magnitude(v);

    if( FLOAT_NEZ( mag ) )
    {
        nv.x = v.x/mag;
        nv.y = v.y/mag;
        nv.z = v.z/mag;
    }

    return nv;
}

inline void
Normalize (RDVECTOR3& v)
{
    D3DVALUE mag = Magnitude(v);

    if( FLOAT_NEZ( mag ) )
    {
        v.x = v.x/mag;
        v.y = v.y/mag;
        v.z = v.z/mag;
    }
    else
    {
        v.x = v.y = v.z = 0.0f;
    }

    return;
}

inline RDVECTOR3
CrossProduct (const RDVECTOR3& v1, const RDVECTOR3& v2)
{
        RDVECTOR3 result;

        result.x = v1.y*v2.z - v1.z*v2.y;
        result.y = v1.z*v2.x - v1.x*v2.z;
        result.z = v1.x*v2.y - v1.y*v2.x;

        return result;
}

inline D3DVALUE
DotProduct (const RDVECTOR3& v1, const RDVECTOR3& v2)
{
        return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
}

//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by a 4x4 matrix transposed,
// producing a homogeneous vector
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformPlaneBy4x4Transposed(RDVECTOR4 *v, D3DMATRIX *m, RDVECTOR4 *res)
{
    res->x = v->x*m->_11 + v->y*m->_12 + v->z*m->_13 + v->w*m->_14;
    res->y = v->x*m->_21 + v->y*m->_22 + v->z*m->_23 + v->w*m->_24;
    res->z = v->x*m->_31 + v->y*m->_32 + v->z*m->_33 + v->w*m->_34;
    res->w = v->x*m->_41 + v->y*m->_42 + v->z*m->_43 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformPlaneBy4x4(RDVECTOR4 *v, D3DMATRIX *m, RDVECTOR4 *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + v->w*m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + v->w*m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + v->w*m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformBy4x4(RDVECTOR3 *v, D3DMATRIX *m, RDVECTOR4 *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x3 matrix
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformBy4x3(RDVECTOR3 *v, D3DMATRIX *m, RDVECTOR3 *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z) by 3x3 matrix
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
Xform3VecBy3x3(RDVECTOR3 *v, D3DMATRIX *m, RDVECTOR3 *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33;
}

//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//---------------------------------------------------------------------
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse);


//---------------------------------------------------------------------
// Make RDCOLOR3 from a Packed DWORD
//---------------------------------------------------------------------
inline void MakeRDCOLOR3( RDCOLOR3 *out, DWORD inputColor )
{
    out->r = (D3DVALUE)RGBA_GETRED( inputColor );
    out->g = (D3DVALUE)RGBA_GETGREEN( inputColor );
    out->b = (D3DVALUE)RGBA_GETBLUE( inputColor );
}

//---------------------------------------------------------------------
// Make RDCOLOR4 from a Packed DWORD
//---------------------------------------------------------------------
inline void MakeRDCOLOR4( RDCOLOR4 *out, DWORD inputColor )
{
    out->a = (D3DVALUE)RGBA_GETALPHA( inputColor )/255.0f;
    out->r = (D3DVALUE)RGBA_GETRED  ( inputColor )/255.0f;
    out->g = (D3DVALUE)RGBA_GETGREEN( inputColor )/255.0f;
    out->b = (D3DVALUE)RGBA_GETBLUE ( inputColor )/255.0f;
}

////////////////////////////////////////////////////////////////////////
//
// Macros used to access DDRAW surface info.
//
////////////////////////////////////////////////////////////////////////
#define DDSurf_Width(lpLcl) ( (lpLcl)->lpGbl->wWidth )
#define DDSurf_Pitch(lpLcl) ( (lpLcl)->lpGbl->lPitch )
#define DDSurf_Height(lpLcl) ( (lpLcl)->lpGbl->wHeight )
#define DDSurf_BitDepth(lpLcl) \
    ( (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      (lpLcl->lpGbl->ddpfSurface.dwRGBBitCount) : \
      (lpLcl->lpGbl->lpDD->vmiData.ddpfDisplay.dwRGBBitCount) \
    )
#define DDSurf_PixFmt(lpLcl) \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      ((lpLcl)->lpGbl->ddpfSurface) : \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay) \
    )
#define VIDEO_MEMORY(pDDSLcl) \
    (!((pDDSLcl)->lpGbl->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED))
#define SURFACE_LOCKED(pDDSLcl) \
    ((pDDSLcl)->lpGbl->dwUsageCount > 0)
#define SURFACE_MEMORY(surfLcl) \
(LPVOID)((surfLcl)->lpGbl->fpVidMem)

//---------------------------------------------------------------------
// DDraw extern functions
//---------------------------------------------------------------------
extern "C" HRESULT WINAPI
DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern "C" HRESULT WINAPI
DDInternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl );

HRESULT DDGetAttachedSurfaceLcl(
    LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
    LPDDSCAPS2 lpDDSCaps,
    LPDDRAWI_DDRAWSURFACE_LCL *lplpDDAttachedSurfaceLcl);
extern "C" LPDDRAWI_DDRAWSURFACE_LCL WINAPI
GetDDSurfaceLocal( LPDDRAWI_DIRECTDRAW_LCL this_lcl, DWORD handle, BOOL* isnew );

//---------------------------------------------------------------------
// RDListEntry:
//
// To support singly linked lists with no deletion of entries. Useful
// for active lists (Active Lights etc.)
//---------------------------------------------------------------------
struct RDListEntry
{
    RDListEntry(){m_pNext = NULL;}
    virtual ~RDListEntry(){}

    // Seek to the end of the chain and append
    void Append(RDListEntry* p)
    {
        if( m_pNext == NULL )
        {
            m_pNext = p;
            return;
        }
        RDListEntry* c = m_pNext;
        while( c->m_pNext )  c = c->m_pNext;
        c->m_pNext = p;
    }
    RDListEntry *Next() { return m_pNext; }
    RDListEntry *  m_pNext;
};

//---------------------------------------------------------------------
// Registry access
//---------------------------------------------------------------------
#define RESPATH_D3D     "Software\\Microsoft\\Direct3D"
#define RESPATH_D3DREF  RESPATH_D3D "\\ReferenceDevice"

BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize);
BOOL GetD3DRefRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize);

///////////////////////////////////////////////////////////////////////////////
#endif  // _RDCOMM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\inc\pshader.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pshader.h
//
// Direct3D Reference Device - Pixel Shader
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _PSHADER_H
#define _PSHADER_H

class RefRast;

//---------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------

const DWORD RD_MAX_TEXTURE_STAGES       = D3DHAL_TSS_MAXSTAGES;

const DWORD RD_MAX_COISSUED_INSTRUCTIONS = 2;

// version 1.1 register bank sizes
const DWORD RDPS_MAX_NUMTEMPREG_V255    = 6;
const DWORD RDPS_MAX_NUMINPUTREG_V255   = 8;
const DWORD RDPS_MAX_NUMCONSTREG_V255   = 16;
const DWORD RDPS_MAX_NUMTEXTUREREG_V255 = 8;

// version-independent consts for sizing arrays
const DWORD RDPS_MAX_NUMTEMPREG         = RDPS_MAX_NUMTEMPREG_V255;
const DWORD RDPS_MAX_NUMINPUTREG        = RDPS_MAX_NUMINPUTREG_V255;
const DWORD RDPS_MAX_NUMCONSTREG        = RDPS_MAX_NUMCONSTREG_V255;
const DWORD RDPS_MAX_NUMTEXTUREREG      = RDPS_MAX_NUMTEXTUREREG_V255;

// sizes for internal register arrays
const DWORD RDPS_MAX_NUMQUEUEDWRITEREG   = RD_MAX_COISSUED_INSTRUCTIONS - 1;
const DWORD RDPS_MAX_NUMPOSTMODSRCREG    = 3;
const DWORD RDPS_MAX_NUMSCRATCHREG       = 5;

// refdev-specific pixel shader 'instructions' to match legacy pixel processing
#define D3DSIO_TEXBEM_LEGACY    ((D3DSHADER_INSTRUCTION_OPCODE_TYPE)0xC001)
#define D3DSIO_TEXBEML_LEGACY   ((D3DSHADER_INSTRUCTION_OPCODE_TYPE)0xC002)


//---------------------------------------------------------------------
//

// pshader.cpp

// Structure that describes each D3DSIO_ pixelshader instruction
typedef struct _PixelShaderInstruction
{
    char    Text[D3DDM_MAX_PSINSTSTRING];
    DWORD*  pComment;
    DWORD   CommentSize;

    // instruction tokens
    DWORD   Opcode;
    DWORD   DstParam;
    DWORD   SrcParam[3];
    DWORD   SrcParamCount;
    UINT    uiTSSNum;
    BOOL    bTexOp;

    BOOL    bQueueWrite;
    BOOL    bFlushQueue;        // flush write - TRUE for all singly issued instructions, 
                                // and for the last in any sequence of co-issued instructions.

} PixelShaderInstruction;

// Enum listing refrast's pixelshader register files
typedef enum _RDPS_REGISTER_TYPE
{
    RDPSREG_UNINITIALIZED_TYPE = 0,
    RDPSREG_INPUT,
    RDPSREG_TEMP,
    RDPSREG_CONST,
    RDPSREG_TEXTURE,
    RDPSREG_POSTMODSRC,
    RDPSREG_SCRATCH,
    RDPSREG_QUEUEDWRITE,
    RDPSREG_ZERO,
    RDPSREG_ONE,
    RDPSREG_TWO,
} RDPS_REGISTER_TYPE;

// Type that is a pointer to an array of RGBA vectors.
typedef FLOAT (*PRGBAVEC)[4];

// Type used to refer to a register.
class RDPSRegister
{
private:
    RDPS_REGISTER_TYPE  m_RegType;
    UINT                m_RegNum;
    PRGBAVEC            m_pReg;       // pointer to [4][4] array -> 4 pixel RGBA
                                      // this is computed when m_RegType and m_RegNum are set
public:
    RDPSRegister() {m_pReg = NULL; m_RegType = RDPSREG_UNINITIALIZED_TYPE; m_RegNum = (UINT)-1;}
    void Set(RDPS_REGISTER_TYPE RegType, UINT RegNum, RefRast* pRast);
    inline RDPS_REGISTER_TYPE GetRegType() {return m_RegType;}
    inline UINT GetRegNum() {return m_RegNum;}
    inline PRGBAVEC GetRegPtr() {return m_pReg;}
};

// "RISC" opcodes which are used to implement D3DSIO_ API pixelshader instructions
typedef enum _RDPS_INSTRUCTION_OPCODE_TYPE
{
    RDPSINST_EVAL,
    RDPSINST_SAMPLE,
    RDPSINST_KILL,
    RDPSINST_BEM,
    RDPSINST_LUMINANCE,
    RDPSINST_DEPTH,
    RDPSINST_SRCMOD,
    RDPSINST_SWIZZLE,
    RDPSINST_DSTMOD,
    RDPSINST_MOV,
    RDPSINST_RCP,
    RDPSINST_FRC,
    RDPSINST_ADD,
    RDPSINST_SUB,
    RDPSINST_MUL,
    RDPSINST_DP3,
    RDPSINST_DP4,
    RDPSINST_MAD,
    RDPSINST_LRP,
    RDPSINST_CND,
    RDPSINST_CMP,
    RDPSINST_END,

    RDPSINST_TEXCOVERAGE,
    RDPSINST_QUADLOOPBEGIN,
    RDPSINST_QUADLOOPEND,
    RDPSINST_QUEUEWRITE,
    RDPSINST_FLUSHQUEUE,
    RDPSINST_NEXTD3DPSINST,

} RDPS_INSTRUCTION_OPCODE_TYPE;

// Structures defining the parameters for all the "RISC" opcodes listed above.
// RDPSINST_BASE_PARAMS is the root from which the rest are inherited.


typedef struct _RDPSINST_BASE_PARAMS
{
public:
    union{
        RDPS_INSTRUCTION_OPCODE_TYPE   Inst;

        // Force structure alignment to pointer-size multiples.
        // IA64 (at least) needs this for structure packing to work.
        void*                          AlignmentDummy; 
    };

} RDPSINST_BASE_PARAMS;

typedef struct _RDPSINST_EVAL_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    UINT            uiCoordSet;
    BOOL            bIgnoreD3DTTFF_PROJECTED;
    BOOL            bClamp;
} RDPSINST_EVAL_PARAMS;

typedef struct _RDPSINST_SAMPLE_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    CoordReg;
    UINT            uiStage;
} RDPSINST_SAMPLE_PARAMS;

typedef struct _RDPSINST_BEM_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BYTE            WriteMask;
    UINT            uiStage;
} RDPSINST_BEM_PARAMS;

typedef struct _RDPSINST_LUMINANCE_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    UINT            uiStage;
} RDPSINST_LUMINANCE_PARAMS;

typedef struct _RDPSINST_DEPTH_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
} RDPSINST_DEPTH_PARAMS;

typedef struct _RDPSINST_KILL_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
} RDPSINST_KILL_PARAMS;

typedef struct _RDPSINST_SRCMOD_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    BYTE            WriteMask;
    BOOL            bBias;
    BOOL            bTimes2;
    BOOL            bComplement;
    FLOAT           fRangeMin;
    FLOAT           fRangeMax;
} RDPSINST_SRCMOD_PARAMS;

typedef struct _RDPSINST_SWIZZLE_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    BYTE            WriteMask;
    BYTE            Swizzle;
} RDPSINST_SWIZZLE_PARAMS;

typedef struct _RDPSINST_DSTMOD_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    BYTE            WriteMask;
    FLOAT           fScale;
    FLOAT           fRangeMin;
    FLOAT           fRangeMax;
} RDPSINST_DSTMOD_PARAMS;

typedef struct _RDPSINST_MOV_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    BOOL            bSrcReg0_Negate;
    BYTE            WriteMask;
} RDPSINST_MOV_PARAMS;

typedef struct _RDPSINST_FRC_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    BOOL            bSrcReg0_Negate;
    BYTE            WriteMask;
} RDPSINST_FRC_PARAMS;

typedef struct _RDPSINST_RCP_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    BOOL            bSrcReg0_Negate;
    BYTE            WriteMask;
} RDPSINST_RCP_PARAMS;

typedef struct _RDPSINST_ADD_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BYTE            WriteMask;
} RDPSINST_ADD_PARAMS;

typedef struct _RDPSINST_SUB_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BYTE            WriteMask;
} RDPSINST_SUB_PARAMS;

typedef struct _RDPSINST_MUL_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BYTE            WriteMask;
} RDPSINST_MUL_PARAMS;

typedef struct _RDPSINST_DP3_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BYTE            WriteMask;
} RDPSINST_DP3_PARAMS;

typedef struct _RDPSINST_DP4_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BYTE            WriteMask;
} RDPSINST_DP4_PARAMS;

typedef struct _RDPSINST_MAD_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    RDPSRegister    SrcReg2;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BOOL            bSrcReg2_Negate;
    BYTE            WriteMask;
} RDPSINST_MAD_PARAMS;

typedef struct _RDPSINST_LRP_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    RDPSRegister    SrcReg2;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BOOL            bSrcReg2_Negate;
    BYTE            WriteMask;
} RDPSINST_LRP_PARAMS;

typedef struct _RDPSINST_CND_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    RDPSRegister    SrcReg2;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BOOL            bSrcReg2_Negate;
    BYTE            WriteMask;
} RDPSINST_CND_PARAMS;

typedef struct _RDPSINST_CMP_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    RDPSRegister    SrcReg2;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BOOL            bSrcReg2_Negate;
    BYTE            WriteMask;
} RDPSINST_CMP_PARAMS;

typedef struct _RDPSINST_END_PARAMS : public RDPSINST_BASE_PARAMS
{
} RDPSINST_END_PARAMS;

typedef struct _RDPSINST_TEXCOVERAGE_PARAMS : public RDPSINST_BASE_PARAMS
{
    UINT        uiStage;
    FLOAT       (*pGradients)[2];
    FLOAT*      pDUDX_0;
    FLOAT*      pDUDX_1;
    FLOAT*      pDUDY_0;
    FLOAT*      pDUDY_1;
    FLOAT*      pDVDX_0;
    FLOAT*      pDVDX_1;
    FLOAT*      pDVDY_0;
    FLOAT*      pDVDY_1;
    FLOAT*      pDWDX_0;
    FLOAT*      pDWDX_1;
    FLOAT*      pDWDY_0;
    FLOAT*      pDWDY_1;
} RDPSINST_TEXCOVERAGE_PARAMS;

typedef struct _RDPSINST_QUADLOOPBEGIN_PARAMS : public RDPSINST_BASE_PARAMS
{
} RDPSINST_QUADLOOPBEGIN_PARAMS;

typedef struct _RDPSINST_QUADLOOPEND_PARAMS : public RDPSINST_BASE_PARAMS
{
    size_t      JumpBackByOffset;
} RDPSINST_QUADLOOPEND_PARAMS;

typedef struct _RDPSINST_QUEUEWRITE_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    BYTE            WriteMask;
} RDPSINST_QUEUEWRITE_PARAMS;

typedef struct _RDPSINST_FLUSHQUEUE_PARAMS : public RDPSINST_BASE_PARAMS
{
} RDPSINST_FLUSHQUEUE_PARAMS;

typedef struct _RDPSINST_NEXTD3DPSINST_PARAMS : public RDPSINST_BASE_PARAMS
{
    PixelShaderInstruction* pInst;
} RDPSINST_NEXTD3DPSINST_PARAMS;

// End of "RISC" instruction parameter definitions

typedef struct _ConstDef
{
    float   f[4];
    UINT    RegNum;
} ConstDef;

typedef struct _PSQueuedWriteDst
{
    RDPSRegister    DstReg;
    BYTE            WriteMask;
} PSQueuedWriteDst;

#define RDPS_COMPONENTMASK_SHIFT    16
#define RDPS_COMPONENTMASK_0        (D3DSP_WRITEMASK_0 >> RDPS_COMPONENTMASK_SHIFT)
#define RDPS_COMPONENTMASK_1        (D3DSP_WRITEMASK_1 >> RDPS_COMPONENTMASK_SHIFT)
#define RDPS_COMPONENTMASK_2        (D3DSP_WRITEMASK_2 >> RDPS_COMPONENTMASK_SHIFT)
#define RDPS_COMPONENTMASK_3        (D3DSP_WRITEMASK_3 >> RDPS_COMPONENTMASK_SHIFT)
#define RDPS_COMPONENTMASK_ALL      (D3DSP_WRITEMASK_ALL >> RDPS_COMPONENTMASK_SHIFT)

#define RDPS_NOSWIZZLE          (D3DSP_NOSWIZZLE >> D3DSP_SWIZZLE_SHIFT)
#define RDPS_REPLICATERED       (D3DSP_REPLICATERED >> D3DSP_SWIZZLE_SHIFT)
#define RDPS_REPLICATEGREEN     (D3DSP_REPLICATEGREEN >> D3DSP_SWIZZLE_SHIFT)
#define RDPS_REPLICATEBLUE      (D3DSP_REPLICATEBLUE >> D3DSP_SWIZZLE_SHIFT)
#define RDPS_REPLICATEALPHA     (D3DSP_REPLICATEALPHA >> D3DSP_SWIZZLE_SHIFT)
#define RDPS_SELECT_R           0
#define RDPS_SELECT_G           1
#define RDPS_SELECT_B           2
#define RDPS_SELECT_A           3

// creates BYTE swizzle description:  bits xxyyzzww made of RSPS_SELECT_* for each component
#define _Swizzle(x,y,z,w)   ((x)|(y<<2)|(z<<4)|(w<<6))

//-----------------------------------------------------------------------------
//
// RDPShader: Pixel Shader Class
//
//-----------------------------------------------------------------------------
class RDPShader
{
public:
    RDPShader();
    ~RDPShader();
    HRESULT     Initialize(RefDev* pRD, DWORD* pCode, DWORD ByteCodeSize, D3DCAPS8* pCaps);


    RefDev*     m_pRD;

    DWORD*      m_pCode;    // function tokens passed to API
    UINT        m_CodeSize; // number of DWORDs

    // info extracted by parsing shader
    UINT        m_cActiveTextureStages; // number of texture stages used by this shader
    DWORD       m_ReferencedTexCoordMask; // Which texture coordinate sets are referenced
    UINT        m_cInst;                // number of shader instructions
    PixelShaderInstruction* m_pInst;    // processed instructions

    GArrayT<BYTE> m_RDPSInstBuffer;  // buffer containint refrast "RISC" translated version of shader
    UINT        m_cConstDefs;           // number of D3DSIO_DEF instructions
    ConstDef*   m_pConstDefs;           // array of constant definitions

};
typedef RDPShader *PRDPSHADER;


//-----------------------------------------------------------------------------
// Struct holding the shader ptr
//-----------------------------------------------------------------------------
struct RDPShaderHandle
{
    RDPShaderHandle()
    {
        m_pShader = NULL;
#if DBG
        m_tag = 0;
#endif
    }
    RDPShader* m_pShader;
#if DBG
    // Non zero means that it has been allocated
    DWORD      m_tag;
#endif
};

// psutil.cpp
int
PixelShaderInstDisAsm(
    char* pStrRet, int StrSizeRet, DWORD* pShader, DWORD Flags );

void
RDPSDisAsm(BYTE*        pRDPSInstBuffer, 
           ConstDef*    pConstDefs, 
           UINT         cConstDefs, 
           FLOAT        fMaxPixelShaderValue,
           DWORD        dwVersion);


#endif _PSHADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\inc\refdev.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// refdev.hpp
//
// Direct3D Reference Device - Main Header File
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _REFDEV_HPP
#define  _REFDEV_HPP

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>

#pragma warning( disable: 4056) // fp constant
#pragma warning( disable: 4244) // fp DOUBLE->FLOAT

#include <ddraw.h>
#include <ddrawi.h>
#include <d3dhal.h>
#include "d3d8ddi.h"
//@@BEGIN_MSINTERNAL
#include "d3d8p.h"
//@@END_MSINTERNAL

#include <rdcomm.hpp>

// forward declarations
class D3DDebugMonitor;
class RDDebugMonitor;
class RDSurfaceManager;
class RDSurface2D;
class RDSurface;
class RDRenderTarget;
class RDTextureStageState;
class RDBSpline;
class RDNPatch;
class RefDev;

#include <rddmon.hpp>
#include <templarr.hpp>
#include <vshader.h>
#include <vstream.h>
#include <reftnl.hpp>
#include <refrast.hpp>
#include <pshader.h>

//-----------------------------------------------------------------------------
//
// A special legacy (pre-DX6) texture op we can't easily map into the new
// texture ops.
//
//-----------------------------------------------------------------------------

#define D3DTOP_LEGACY_ALPHAOVR  (0x7fffffff)

//-----------------------------------------------------------------------------
//
// Constants
//
//-----------------------------------------------------------------------------
const DWORD RD_MAX_NUM_TEXTURE_FORMATS = 50;

const DWORD RD_MAX_CLOD = 13*6; // base texture up to 4kx4k for 6 Cubemaps

//-----------------------------------------------------------------------------
//
// RefRastSetMemif - Routine to set memory allocation interface for reference
// rasterizer - takes pointers to functions to use for malloc, free, and realloc.
//
// These must be set prior to new'ing any RefDev objects.
//
//-----------------------------------------------------------------------------
void
RefRastSetMemif(
    LPVOID( _cdecl* pfnMemAlloc )( size_t ),
    void( _cdecl* pfnMemFree )( PVOID ),
    LPVOID( _cdecl* pfnMemReAlloc )( PVOID, size_t ) );

//-----------------------------------------------------------------------------
//
// RDRenderTarget - Class which encompasses all information about rendering
// target, including size, type/pointer/stride for color and depth/stencil
// buffers, guard band clip info, W range info.
//
// Usage is to instantiate, fill out public members, and install into a
// RefDev object via RefDev::SetRenderTarget.
//
//-----------------------------------------------------------------------------
class RDRenderTarget : public RDAlloc
{
public:
    ///////////////////////////////////////////////////////////////////////////
    //
    // public interface
    //
    ///////////////////////////////////////////////////////////////////////////

    RDRenderTarget( void );
    ~RDRenderTarget( void );
//
// these need to be filled in by the user before installing in a
// RefDev object
//
    RECT    m_Clip;         // clipping bounds
    FLOAT   m_fWRange[2];   // range of device W (W at near and far clip planes)

    RDSurface2D* m_pColor;
    RDSurface2D* m_pDepth;

    // This boolean indicates that the DDI used to set render target
    // is a pre-DX7. This is used by the destructor to free up the
    // color and depth buffers.
    BOOL    m_bPreDX7DDI;

    ///////////////////////////////////////////////////////////////////////////
    //
    // internal state and methods
    //
    ///////////////////////////////////////////////////////////////////////////
    friend class RefDev;
    HRESULT Initialize( LPDDRAWI_DIRECTDRAW_LCL pDDLcl, DWORD dwColorHandle,
                        DWORD dwDepthHandle );
    HRESULT Initialize( LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
                        LPDDRAWI_DDRAWSURFACE_LCL pLclColor,
                        LPDDRAWI_DDRAWSURFACE_LCL pLclZ );
    HRESULT Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLclColor,
                        LPDDRAWI_DDRAWSURFACE_LCL pLclZ );

    // read/write specific sample
    void ReadPixelColor   ( INT32 iX, INT32 iY, UINT Sample, RDColor& Color );
    void WritePixelColor  ( INT32 iX, INT32 iY, UINT Sample, const RDColor& Color, BOOL bDither );
    void WritePixelDepth  ( INT32 iX, INT32 iY, UINT Sample, const RDDepth& Depth );
    void ReadPixelDepth   ( INT32 iX, INT32 iY, UINT Sample, RDDepth& Depth );
    void WritePixelStencil( INT32 iX, INT32 iY, UINT Sample, UINT8 uStencil );
    void ReadPixelStencil ( INT32 iX, INT32 iY, UINT Sample, UINT8& uStencil );

    // write all samples
    void WritePixelColor  ( INT32 iX, INT32 iY, const RDColor& Color, BOOL bDither );
    void WritePixelDepth  ( INT32 iX, INT32 iY, const RDDepth& Depth );
    void WritePixelStencil( INT32 iX, INT32 iY, UINT8 uStencil );

    void Clear            ( RDColor fillColor, LPD3DHAL_DP2COMMAND pCmd );
    void ClearDepth       ( RDDepth fillDepth, LPD3DHAL_DP2COMMAND pCmd );
    void ClearStencil     ( UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd );
    void ClearDepthStencil( RDDepth fillDepth, UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd );
};

//-----------------------------------------------------------------------------
//
// RDTextureStageState - This holds the per-stage state for texture mapping.
// An array of these are instanced in the RefDev object.
//
// Store texture matrix at the end of the texture stage state.
//
//-----------------------------------------------------------------------------
class RDTextureStageState
{
public:
    union
    {
        DWORD   m_dwVal[D3DTSS_MAX]; // state array (unsigned)
        FLOAT   m_fVal[D3DTSS_MAX];  // state array (float)
    };
};

//-----------------------------------------------------------------------------
//
// RDSurface - Class instanced once per surface which encompasses information
// about a chain of surfaces used either as a mipmap, cubemap, render-target,
// depth-buffer, vertex buffer or an index buffer.  Includes size and type
// (assumed same for each level of detail) and pointer/stride for each LOD.
//
// Created by CreateSurfaceEx DDI call.
//
//-----------------------------------------------------------------------------

// Surface type flags. Some combination of them are legal
const DWORD RR_ST_UNKNOWN                = 0;
const DWORD RR_ST_TEXTURE                = (1<<0);
const DWORD RR_ST_RENDERTARGETCOLOR      = (1<<2);
const DWORD RR_ST_RENDERTARGETDEPTH      = (1<<3);
const DWORD RR_ST_VERTEXBUFFER           = (1<<4);
const DWORD RR_ST_INDEXBUFFER            = (1<<5);

// The following flags track the surface status
const DWORD RRSURFACE_STATUS_INITCALLED =  (1<<0);
const DWORD RRSURFACE_STATUS_REFCREATED =  (1<<1);
const DWORD RRSURFACE_STATUS_ISLOCKED   =  (1<<2);


class RDSurface
{
public:
    RDSurface()
    {
        m_dwStatus          = 0;
        m_MemPool           = D3DPOOL_FORCE_DWORD;
        m_SurfType          = RR_ST_UNKNOWN;
        m_iLockCount        = 0;
    }

    virtual HRESULT Initialize( LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl ) = 0;

    virtual ~RDSurface()
    {
        return;
    }
    BOOL IsInitialized(){ return (m_dwStatus & RRSURFACE_STATUS_INITCALLED); }
    void SetInitialized(){ m_dwStatus |= RRSURFACE_STATUS_INITCALLED; }

    BOOL IsRefCreated() { return (m_dwStatus & RRSURFACE_STATUS_REFCREATED); }
    void SetRefCreated(){ m_dwStatus |= RRSURFACE_STATUS_REFCREATED; }

    BOOL IsLocked()     { return (m_dwStatus & RRSURFACE_STATUS_ISLOCKED); }
    void Lock()         { m_iLockCount++;   }
    void Unlock()       { if( m_iLockCount > 0 ) m_iLockCount--; }

    DWORD GetSurfaceType() { return m_SurfType; }
    D3DPOOL GetMemPool() { return m_MemPool; }

protected:
    D3DPOOL         m_MemPool;                      // Where is this allocated
    DWORD           m_SurfType;                     // the type of surface
    DWORD           m_dwStatus;
    int             m_iLockCount;
};

//-----------------------------------------------------------------------------
//
// RDCREATESURFPRIVATE
// PrivateData stored in SurfaceGbl->dwReserved1 at CreateSurface call
//
//-----------------------------------------------------------------------------
class RDCREATESURFPRIVATE
{
public:
    RDCREATESURFPRIVATE()
    {
        dwPitch = 0;
        dwLockCount = 0;
        pBits = NULL;

        wSamples = 1;
        dwMultiSamplePitch = 0;
        pMultiSampleBits = NULL;
        SurfaceFormat = RD_SF_NULL;
    }

    ~RDCREATESURFPRIVATE()
    {
        _ASSERT( dwLockCount == 0, "Surface being deleted has some"
                 "outstanding locks" );
        delete [] pBits;
        delete [] pMultiSampleBits;
    }

    void Lock()
    {
        dwLockCount++;
    }

    void Unlock()
    {
        if( dwLockCount > 0)
            dwLockCount--;
    }

    DWORD dwLockCount;

    union
    {
        DWORD dwPitch;
        DWORD dwVBSize;
    };
    BYTE* pBits;

    WORD  wSamples;
    DWORD dwMultiSamplePitch;
    BYTE* pMultiSampleBits;
    RDSurfaceFormat SurfaceFormat;
};

//---------------------------------------------------------------------------
// RDDSurfaceArrayNode
//
// This is a node in the linked list of the growable array of RefSurfaces
// maintained per ddraw lcl.
//---------------------------------------------------------------------------
struct RDSurfaceHandle
{
    RDSurfaceHandle()
    {
        m_pSurf = NULL;
#if DBG
        m_tag = 0;
#endif
    }
    RDSurface* m_pSurf;
#if DBG
    // Non zero means that it has been allocated
    DWORD      m_tag;
#endif
};

class RDSurfaceArrayNode : public RDListEntry
{
public:
    RDSurfaceArrayNode(LPDDRAWI_DIRECTDRAW_LCL pDDLcl);
    ~RDSurfaceArrayNode();
    HRESULT AddSurface( LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl,
                        RDSurface**                 ppSurf );
    RDSurface* GetSurface( DWORD dwHandle );
    HRESULT RemoveSurface( DWORD dwHandle );

private:
    LPDDRAWI_DIRECTDRAW_LCL  m_pDDLcl;
    GArrayT<RDSurfaceHandle> m_SurfHandleArray;
    RDSurfaceArrayNode* m_pNext;

    friend class RDSurfaceManager;
};

//---------------------------------------------------------------------------
// RDSurfaceManager
//
// This class maintains a linked list of all the
// surface handle tables for each DD_LCL
//---------------------------------------------------------------------------
class RDSurfaceManager
{
public:
    RDSurfaceManager() {m_pFirstNode = NULL;}
    ~RDSurfaceManager()
    {
        RDSurfaceArrayNode *pNode = m_pFirstNode;
        while( pNode )
        {
            RDSurfaceArrayNode *pTmp = pNode;
            pNode = pNode->m_pNext;
            delete pTmp;
        }
    }

    RDSurfaceArrayNode* AddLclNode( LPDDRAWI_DIRECTDRAW_LCL pDDLcl );
    RDSurfaceArrayNode* GetLclNode( LPDDRAWI_DIRECTDRAW_LCL pDDLcl );

    HRESULT AddSurfToList( LPDDRAWI_DIRECTDRAW_LCL     pDDLcl,
                           LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl,
                           RDSurface**                 ppSurf );
    RDSurface* GetSurfFromList( LPDDRAWI_DIRECTDRAW_LCL   pDDLcl,
                                DWORD                     dwHandle );

    HRESULT RemoveSurfFromList( LPDDRAWI_DIRECTDRAW_LCL     pDDLcl,
                                LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl);
    HRESULT RemoveSurfFromList( LPDDRAWI_DIRECTDRAW_LCL     pDDLcl,
                                DWORD dwHandle );

private:
    RDSurfaceArrayNode *m_pFirstNode;
};

extern RDSurfaceManager g_SurfMgr;


//-----------------------------------------------------------------------------
//
// RDVertexBuffer - The RefDev's representation of the VertexBuffer. It gets
// created on a CreateSurfaceEx call.
//
//-----------------------------------------------------------------------------
class RDVertexBuffer : public RDSurface
{
public:
    RDVertexBuffer()
    {
        m_pBits = NULL;
        m_cbSize = 0;
        m_FVF = 0;
    }

    virtual ~RDVertexBuffer() { return; }
    HRESULT Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLcl );
    LPBYTE GetBits() { return m_pBits; }
    int GetFVF()  { return m_FVF; }
    int GetSize()  { return m_cbSize; }

protected:
    DWORD   m_FVF;
    BYTE*   m_pBits;
    DWORD   m_cbSize;
};

//-----------------------------------------------------------------------------
//
// RDPalette - Class for representing and managing palettes in RefDev
//
//-----------------------------------------------------------------------------
class RDPalette
{
public:
    RDPalette()
    {
        m_dwFlags = 0;
        memset( m_Entries, 0, sizeof( m_Entries ) );
    }

    D3DCOLOR* GetEntries()
    {
        return m_Entries;
    }

    static const DWORD RDPAL_ALPHAINPALETTE;
    static const DWORD m_dwNumEntries;

    HRESULT Update( WORD StartIndex, WORD wNumEntries,
                    PALETTEENTRY* pEntries );
    BOOL HasAlpha()
    {
        return (m_dwFlags & RDPAL_ALPHAINPALETTE);
    }

    DWORD     m_dwFlags;
    D3DCOLOR  m_Entries[256];
};


struct RDPaletteHandle
{
    RDPaletteHandle()
    {
        m_pPal = NULL;
#if DBG
        m_tag = 0;
#endif
    }
    RDPalette* m_pPal;
#if DBG
    // Non zero means that it has been allocated
    DWORD      m_tag;
#endif
};

//-----------------------------------------------------------------------------
//
// RDSurface2D - Class instanced once per 2D surface which could be either
// texture, color render target or  depth buffer information
// about a chain of surfaces.  Includes size and type
// (assumed same for each level of detail) and pointer/stride for each LOD.
//
// Also includes pointer to palette, and colorkey value (legacy support only).
//
//-----------------------------------------------------------------------------
class RDSurface2D : public RDSurface
{
public:
    ///////////////////////////////////////////////////////////////////////////
    //
    // public interface
    //
    ///////////////////////////////////////////////////////////////////////////

    RDSurface2D( void );
    ~RDSurface2D( void );

    friend class RefDev;
    class RefDev *  m_pRefDev;  // refdev which created this - used only when this is bound as a texture
    void SetRefDev( RefDev* pRefDev) { m_pRefDev = pRefDev; }

    DWORD           m_uFlags;       // RR_TEXTURE_* bitdefs
// bit definitions for RDSurface2D::uFlags
#define RR_TEXTURE_HAS_CK           (1L<< 0)    // set if texture has colorkey
#define RR_TEXTURE_ALPHAINPALETTE   (1L<< 1)    // set if alpha channel in palette
#define RR_TEXTURE_CUBEMAP          (1L<< 2)    // set if texture is Cubemap with 6 times the number of surfaces
#define RR_TEXTURE_VOLUME           (1L<< 4)    // set if texture is volume

    // basic info
    UINT            m_iSamples;
    int             m_iWidth;                       // size of top-level map
    int             m_iHeight;
    int             m_iDepth;                       // depth of volume texture
    BYTE*           m_pBits[RD_MAX_CLOD];         // pointer to surface bits
    int             m_iPitch[RD_MAX_CLOD];        // pitch in bytes
    int             m_iSlicePitch[RD_MAX_CLOD];   // slice pitch in bytes
                                                    // for volume texture
    int             m_cLOD;     // 0..(n-1) count of LODs currently available

    RDSurfaceFormat m_SurfFormat;                   // format of pixel

    DWORD           m_dwColorKey;   // D3DCOLOR colorkey value

    DWORD           m_dwEmptyFaceColor;     // D3DCOLOR empty cubemap empty face value

    DWORD*          m_pPalette;     // pointer to D3DCOLOR palette (may be NULL)
    RDPalette*      m_pPalObj;

    // DD surface pointers for locking/unlocking and GetSurf callback
    LPDDRAWI_DDRAWSURFACE_LCL m_pDDSLcl[RD_MAX_CLOD];
    int             m_cLODDDS;  // 0..(n-1) count of LODs actually in the pDDS array

    D3DTEXTUREHANDLE    m_hTex; // texture handle

    ///////////////////////////////////////////////////////////////////////////
    //
    // internal state and methods
    //
    ///////////////////////////////////////////////////////////////////////////
    BOOL            m_bHasAlpha;        // TRUE if texture has an alpha channel

    int             m_cDimension;       // 1,2,3 for 1D,2D,3D textures
    int             m_cTexels[RD_MAX_CLOD][3]; // integer number of texels in each dimension
    float           m_fTexels[RD_MAX_CLOD][3]; // float number of texels in each dimension


    HRESULT Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLcl );
    DWORD ComputePitch( LPDDRAWI_DDRAWSURFACE_LCL pLcl ) const;
    DWORD ComputePitch( LPDDRAWI_DDRAWSURFACE_LCL pLcl,
                        RDSurfaceFormat SurfFormat,
                        DWORD width, DWORD height ) const;

    void SetPalette( RDPalette* pPal )
    {
        m_pPalObj = pPal;
    }

    void UpdatePalette();
    BOOL Validate( void );
    void ReadColor( INT32 iX, INT32 iY, INT32 iZ, INT32 iLOD, RDColor& Texel, BOOL &bColorKeyKill );

    inline int GetPitch( DWORD level = 0 )  { return m_iPitch[level]; }
    inline LPBYTE GetBits( DWORD level = 0) { return m_pBits[level]; }
    inline int GetWidth()  { return m_iWidth; }
    inline int GetHeight() { return m_iHeight; }
    inline int GetSamples() { return m_iSamples; }
    HRESULT SetLod( DWORD dwLOD )
    {
        return S_OK;
    }
    inline RDSurfaceFormat GetSurfaceFormat() { return m_SurfFormat; }

    friend class RDRenderTarget;
};

#define RD_STATESET_GROWDELTA      1

#define RRSTATEOVERRIDE_DWORD_BITS      32
#define RRSTATEOVERRIDE_DWORD_SHIFT     5

typedef TemplArray<UINT8> StateSetData;
typedef StateSetData *LPStateSetData;

typedef HRESULT (*PFN_DP2REFOPERATION)(RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd);
typedef HRESULT (*PFN_DP2REFOPERATIONUPDATE)(RefDev *pRefDev, LPD3DHAL_DP2COMMAND* ppCmd);
typedef HRESULT (*PFN_DP2REFSETRENDERSTATES)(RefDev *pRefDev,
                                        DWORD dwFvf,
                                        LPD3DHAL_DP2COMMAND pCmd,
                                        LPDWORD lpdwRuntimeRStates);
typedef HRESULT (*PFN_DP2REFTEXTURESTAGESTATE)(RefDev *pRefDev,
                                            DWORD dwFvf,
                                            LPD3DHAL_DP2COMMAND pCmd);
typedef HRESULT (*PFN_DP2REFSETLIGHT)(RefDev *pRefDev,
                                      LPD3DHAL_DP2COMMAND pCmd,
                                      LPDWORD pdwStride);
typedef HRESULT (*PFN_DP2REFSETVERTEXSHADEDCONSTS)
    (RefDev *pRefDev, DWORD StartReg, DWORD dwCount,
                                     LPDWORD pData );
typedef HRESULT (*PFN_DP2REFSETPIXELSHADEDCONSTS)
    (RefDev *pRefDev, DWORD StartReg, DWORD dwCount,
                                     LPDWORD pData );

typedef struct _RD_STATESETFUNCTIONTBL
{
    DWORD                       dwSize;                 // size of struct
    PFN_DP2REFSETRENDERSTATES pfnDp2SetRenderStates;
    PFN_DP2REFTEXTURESTAGESTATE pfnDp2TextureStageState;
    PFN_DP2REFOPERATION pfnDp2SetViewport;
    PFN_DP2REFOPERATION pfnDp2SetWRange;
    PFN_DP2REFOPERATION pfnDp2SetMaterial;
    PFN_DP2REFOPERATION pfnDp2SetZRange;
    PFN_DP2REFSETLIGHT  pfnDp2SetLight;
    PFN_DP2REFOPERATION pfnDp2CreateLight;
    PFN_DP2REFOPERATION pfnDp2SetTransform;
    PFN_DP2REFOPERATION pfnDp2SetExtention;
    PFN_DP2REFOPERATION pfnDp2SetClipPlane;
    PFN_DP2REFOPERATION pfnDp2SetVertexShader;
    PFN_DP2REFSETVERTEXSHADEDCONSTS pfnDp2SetVertexShaderConsts;
    PFN_DP2REFOPERATION pfnDp2SetPixelShader;
    PFN_DP2REFSETPIXELSHADEDCONSTS  pfnDp2SetPixelShaderConsts;
    PFN_DP2REFOPERATION pfnDp2SetStreamSource;
    PFN_DP2REFOPERATION pfnDp2SetIndices;
    PFN_DP2REFOPERATION pfnDp2MultiplyTransform;
} RD_STATESETFUNCTIONTBL, *LPRD_STATESETFUNCTIONTBL;

//
// The device type that the RefDev should emulate
//
typedef enum {
    RDDDI_UNKNOWN = 0,
    RDDDI_OLDHAL  = 1,
    RDDDI_DPHAL,
    RDDDI_DP2HAL,          // DX6 HAL
    RDDDI_DX7HAL,          // DX7 HAL w/out T&L, with state sets
    RDDDI_DX7TLHAL,
    RDDDI_DX8HAL,
    RDDDI_DX8TLHAL,
    RDDDI_FORCE_DWORD = 0xffffffff
} RDDDITYPE;

typedef struct _RRSTATEOVERRIDES
{
    DWORD    bits[D3DSTATE_OVERRIDE_BIAS >> RRSTATEOVERRIDE_DWORD_SHIFT];
} RRSTATEOVERRIDES;

struct RDHOCoeffs
{
    RDHOCoeffs()
    {
        m_pNumSegs = 0;
        for(unsigned i = 0; i < RD_MAX_NUMSTREAMS; m_pData[i++] = 0);
    }
    ~RDHOCoeffs()
    {
        delete[] m_pNumSegs;
        for(unsigned i = 0; i < RD_MAX_NUMSTREAMS; delete[] m_pData[i++]);
    }

    RDHOCoeffs& operator=(const RDHOCoeffs &coeffs);

    UINT           m_Width;
    UINT           m_Height;
    UINT           m_Stride;
    D3DBASISTYPE   m_Basis;
    D3DORDERTYPE   m_Order;
    FLOAT         *m_pNumSegs;
    BYTE          *m_pData[RD_MAX_NUMSTREAMS];
    UINT           m_DataSize[RD_MAX_NUMSTREAMS];
};

//-----------------------------------------------------------------------------
//
// RefDev - Primary object for reference rasterizer.  Each instance
// of this corresponds to a D3D device.
//
// Usage is to instantiate, install RDRenderTarget (and optional RDSurface2D's),
// and set state and draw primitives.
//
//-----------------------------------------------------------------------------
class RefDev : public RDAlloc
{
public:
    friend class RDDebugMonitor;
    friend class RefRast;
    friend class RDPShader;
    ///////////////////////////////////////////////////////////////////////////
    //
    // public interface
    //
    ///////////////////////////////////////////////////////////////////////////
    RDDebugMonitor* m_pDbgMon;

    RefDev( LPDDRAWI_DIRECTDRAW_LCL pDDLcl, DWORD dwInterfaceType,
            RDDDITYPE dwDDIType, D3DCAPS8* pCaps8 );
    ~RefDev( void );
    LPDDRAWI_DIRECTDRAW_LCL GetDDLcl() { return m_pDDLcl; }

    // Methods to get embedded objects
    RefVP&      GetVP()      {  return m_RefVP;  }
    RefVM&      GetVM()      {  return m_RefVM;  }
    RefClipper& GetClipper() { return m_Clipper; }

    RefRast&    GetRast()    { return m_Rast; }

    // DDI methods
    HRESULT DrawPrimitives2( PUINT8 pUMVtx, UINT16 dwStride, DWORD dwFvf,
                             DWORD dwNumVertices, LPD3DHAL_DP2COMMAND *ppCmd,
                             LPDWORD lpdwRStates );

    // Dp2 token handling functions
    HRESULT Dp2RecRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates);
    HRESULT Dp2RecTextureStageState(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecViewport(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecWRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecMaterial(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecZRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecSetLight(LPD3DHAL_DP2COMMAND pCmd, LPDWORD pdwStride);
    HRESULT Dp2RecCreateLight(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecTransform(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecExtention(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecClipPlane(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecSetVertexShader(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecSetVertexShaderConsts(DWORD StartReg, DWORD dwCount,
                                        LPDWORD pData);
    HRESULT Dp2RecSetPixelShader(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecSetPixelShaderConsts(DWORD StartReg, DWORD dwCount,
                                       LPDWORD pData);
    HRESULT Dp2RecSetStreamSource(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecSetIndices(LPD3DHAL_DP2COMMAND pCmd);

    HRESULT Dp2SetRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates);
    HRESULT Dp2SetTextureStageState(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetViewport(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetWRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetMaterial(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetZRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetLight(LPD3DHAL_DP2COMMAND pCmd, PDWORD pdwStride);
    HRESULT Dp2CreateLight(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetTransform(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2MultiplyTransform(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetExtention(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetRenderTarget(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetClipPlane(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2DrawPrimitive(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2DrawPrimitive2(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2DrawIndexedPrimitive(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2DrawIndexedPrimitive2(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2DrawClippedTriFan(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2CreateVertexShader(DWORD handle,
                                  DWORD dwDeclSize, LPDWORD pDecl,
                                  DWORD dwCodeSize, LPDWORD pCode);
    HRESULT Dp2DeleteVertexShader(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetVertexShader(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetVertexShaderConsts(DWORD StartReg, DWORD dwCount,
                                     LPDWORD pData);
    HRESULT Dp2SetStreamSource(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetStreamSourceUM(LPD3DHAL_DP2COMMAND pCmd, PUINT8 pUMVtx );
    HRESULT Dp2SetIndices(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2CreatePixelShader(DWORD handle,
                                 DWORD dwCodeSize, LPDWORD pCode);
    HRESULT Dp2DeletePixelShader(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetPixelShader(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetPixelShaderConsts(DWORD StartReg, DWORD dwCount,
                                    LPDWORD pData);
    HRESULT Dp2SetPalette(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2UpdatePalette(LPD3DHAL_DP2UPDATEPALETTE pUP,
                             PALETTEENTRY *pEntries);
    HRESULT Dp2SetTexLod(LPD3DHAL_DP2COMMAND pCmd);

    // StateSet related functions
    void SetRecStateFunctions(void);
    void SetSetStateFunctions(void);
    HRESULT BeginStateSet(DWORD dwHandle);
    HRESULT EndStateSet(void);
    HRESULT ExecuteStateSet(DWORD dwHandle);
    HRESULT DeleteStateSet(DWORD dwHandle);
    HRESULT CaptureStateSet(DWORD dwHandle);
    HRESULT CreateStateSet(DWORD dwHandle, D3DSTATEBLOCKTYPE sbType);
    HRESULT RecordAllState( DWORD dwHandle );
    HRESULT RecordVertexState( DWORD dwHandle );
    HRESULT RecordPixelState( DWORD dwHandle );

    HRESULT RecordStates(PUINT8 pData, DWORD dwSize);
    HRESULT RecordLastState(LPD3DHAL_DP2COMMAND pCmd, DWORD dwUnitSize);

    LPRD_STATESETFUNCTIONTBL pStateSetFuncTbl;

    // Interface style
    BOOL IsInterfaceDX6AndBefore() {return (m_dwInterfaceType <= 2);}
    BOOL IsInterfaceDX7AndBefore() {return (m_dwInterfaceType <= 3);}

    // DriverStyle
    BOOL IsDriverDX6AndBefore()
    {
        return ((m_dwDDIType <= RDDDI_DP2HAL) && (m_dwDDIType > 0));
    }
    BOOL IsDriverDX7AndBefore()
    {
        return ((m_dwDDIType <= RDDDI_DX7TLHAL) && (m_dwDDIType > 0));
    }

    RDDDITYPE GetDDIType()
    {
        return m_dwDDIType;
    }

    // Last Pixel State
    void StoreLastPixelState(BOOL bStore);

    // RenderTarget control
    void SetRenderTarget( RDRenderTarget* pRenderTarget );
    RDRenderTarget* GetRenderTarget( void );

    // state management functions
    void SetRenderState( DWORD dwState, DWORD dwValue );
    void SetTextureStageState( DWORD dwStage, DWORD dwStageState, DWORD dwValue );
    void SceneCapture( DWORD dwFlags );

    // texture management functions
    BOOL TextureCreate  ( LPD3DTEXTUREHANDLE phTex, RDSurface2D** ppTexture );
    BOOL TextureDestroy ( D3DTEXTUREHANDLE hTex );
    DWORD TextureGetSurf( D3DTEXTUREHANDLE hTex );

    // rendering functions
    HRESULT Clear(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT BeginRendering( void );
    HRESULT EndRendering( void  );

    HRESULT UpdateRastState( void );
    DWORD   m_dwRastFlags;  // rasterizer-core specific flags
#define RDRF_MULTISAMPLE_CHANGED        (1L<<0)
#define RDRF_PIXELSHADER_CHANGED        (1L<<1)
#define RDRF_LEGACYPIXELSHADER_CHANGED  (1L<<2)
#define RDRF_TEXTURESTAGESTATE_CHANGED  (1L<<3)


    // Method to convert FVF vertices into the internal RDVertex. Used for
    // TLVertex rendering and legacy driver models.
    void FvfToRDVertex( PUINT8 pVtx, GArrayT<RDVertex>& dstArray, DWORD dwFvf,
                        DWORD dwStride, UINT cVertices );

    // Rasterizer functions
    void DrawPoint( RDVertex* pvV0 );
    void DrawLine( RDVertex* pvV0, RDVertex* pvV1, RDVertex* pvVFlat = NULL );
    void DrawTriangle( RDVertex* pvV0, RDVertex* pvV1, RDVertex* pvV2,
                       WORD wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE );

    HRESULT DrawOnePrimitive( GArrayT<RDVertex>& VtxArray,
                              DWORD dwStartVertex,
                              D3DPRIMITIVETYPE PrimType,
                              UINT cVertices );
    HRESULT DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                     int StartVertexIndex,
                                     LPWORD pIndices,
                                     DWORD StartIndex,
                                     UINT  cIndices,
                                     D3DPRIMITIVETYPE PrimType );
    HRESULT DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                     int StartVertexIndex,
                                     LPDWORD pIndices,
                                     DWORD StartIndex,
                                     UINT cIndices,
                                     D3DPRIMITIVETYPE PrimType );
    HRESULT DrawOneEdgeFlagTriangleFan( GArrayT<RDVertex>& VtxArray,
                                        UINT cVertices,
                                        UINT32 dwEdgeFlags );

//
// these are used to facilitate the way refdev is used in the D3D runtime
//
    // functions to manipulate current set of texture
    int GetCurrentTextureMaps( D3DTEXTUREHANDLE* phTex, RDSurface2D** pTex );
    BOOL SetTextureMap( D3DTEXTUREHANDLE hTex, RDSurface2D* pTex );

//
// T&L Hal specific functions
//

    HRESULT ProcessPrimitive( D3DPRIMITIVETYPE primType,
                              DWORD dwStartVertex,// Index of the start vertex
                              DWORD cVertices,
                              DWORD dwStartIndex,
                              DWORD cIndices );
    HRESULT ProcessPrimitiveVVM( D3DPRIMITIVETYPE primType,
                                 DWORD dwStartVertex,
                                 DWORD cVertices,
                                 DWORD dwStartIndex,
                                 DWORD cIndices );
    HRESULT ProcessBSpline( DWORD dwOffW, DWORD dwOffH,
                            DWORD dwWidth, DWORD dwHeight,
                            DWORD dwStride, DWORD order,
                            FLOAT *pPrimSegments);
    HRESULT ProcessBezier ( DWORD dwOffW, DWORD dwOffH,
                            DWORD dwWidth, DWORD dwHeight,
                            DWORD dwStride, DWORD order,
                            FLOAT *pPrimSegments,
                            bool bDegenerate );
    HRESULT ProcessCatRomSpline ( DWORD dwOffW, DWORD dwOffH,
                                  DWORD dwWidth, DWORD dwHeight,
                                  DWORD dwStride,
                                  FLOAT *pPrimSegments);
    HRESULT ProcessTessPrimitive( LPD3DHAL_DP2DRAWPRIMITIVE pDP );
    HRESULT ProcessTessIndexedPrimitive( LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pDP );
    HRESULT DrawTessQuad( const RDBSpline &Surf, DWORD dwOffW, DWORD dwOffH, DWORD dwStride,
                          const unsigned *m, const unsigned *n,
                          double u0, double v0, double u1, double v1,
                          double tu0, double tv0, double tu1, double tv1,
                          bool bDegenerate );
    HRESULT DrawTessTri( const RDBSpline &Surf, DWORD dwOffW, DWORD dwOffH, DWORD dwStride,
                         const unsigned *m, const unsigned *n,
                         double u0, double v0, double u1, double v1, double u2, double v2,
                         double tu0, double tv0, double tu1, double tv1, double tu2, double tv2,
                         bool bDegenerate0, bool bDegenerate1, bool bDegenerate2 );
    HRESULT DrawNPatch( const RDNPatch &Patch, DWORD dwStride,
                        const unsigned *m, const unsigned *n, unsigned segs );

    HRESULT ConvertLinearTriBezierToRectBezier(DWORD dwDataType, const BYTE *B, DWORD dwStride, BYTE *Q);
    HRESULT ConvertCubicTriBezierToRectBezier(DWORD dwDataType, const BYTE *B, DWORD dwStride, BYTE *Q);
    HRESULT ConvertQuinticTriBezierToRectBezier(DWORD dwDataType, const BYTE *B, DWORD dwStride, BYTE *Q);

    HRESULT SetupStrides();
    HRESULT UpdateTLState();
    HRESULT UpdateClipper();

    HRESULT DrawDX8Prim(  LPD3DHAL_DP2DRAWPRIMITIVE pDP );
    HRESULT DrawDX8Prim2(  LPD3DHAL_DP2DRAWPRIMITIVE2 pDP );
    HRESULT DrawRectPatch(  LPD3DHAL_DP2DRAWRECTPATCH pDP );
    HRESULT DrawTriPatch(  LPD3DHAL_DP2DRAWTRIPATCH pDP );
    HRESULT DrawDX8IndexedPrim( LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pDIP );
    HRESULT DrawDX8IndexedPrim2( LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 pDIP );
    HRESULT DrawDX8ClippedTriFan( LPD3DHAL_CLIPPEDTRIANGLEFAN pDIP );

    inline RDVStream& GetVStream( DWORD index )
    {
        return m_VStream[index];
    }

    inline HRESULT GrowTLVArray( DWORD dwNumVerts )
    {
        return m_TLVArray.Grow( dwNumVerts );
    }

    inline GArrayT<RDVertex>& GetTLVArray()
    {
        return m_TLVArray;
    }

private:
    ///////////////////////////////////////////////////////////////////////////
    //
    // internal state and methods
    //
    ///////////////////////////////////////////////////////////////////////////

    //-------------------------------------------------------------------------
    // Embedded Objects
    //-------------------------------------------------------------------------
    RefVP       m_RefVP;          // The fixed function T&L object
    RefVM       m_RefVM;          // The programmable vertex machine object
    RefClipper  m_Clipper;        // Clipper object

    RefRast     m_Rast;           // Rasterizer object

    //-------------------------------------------------------------------------
    // state
    //-------------------------------------------------------------------------

    // Caps struct, potentially modified from static caps settings.  Ref code
    //  will behave according to settings of some of the caps in this struct.
    D3DCAPS8    m_Caps8;

    // DDraw Local, needed for the new texture handles from DX7 onwards
    LPDDRAWI_DIRECTDRAW_LCL m_pDDLcl;

    // This is obtained from CONTEXTCREATE->ddrval, indicates
    // what kind of emulation (DX3, DX5, DX6 or DX7) the driver should do.
    RDDDITYPE       m_dwDDIType;

    // This is obtained from CONTEXTCREATE->dwhContext, indicates
    // which D3D Device interface called the driver.
    DWORD           m_dwInterfaceType;

    // save area for floating point unit control
    WORD            m_wSaveFP;

    // TRUE if in begin/end primitive sequence
    BOOL            m_bInBegin;

    // TRUE if in rendering point sprite triangles
    BOOL            m_bPointSprite;

    // render target (color & Z buffer)
    RDRenderTarget* m_pRenderTarget;
    FLOAT           m_fWBufferNorm[2]; // { Wnear, 1/(Wfar-Wnear) } to normalize W buffer value

    // D3D renderstate
    union
    {
        DWORD       m_dwRenderState[D3DHAL_MAX_RSTATES];
        FLOAT       m_fRenderState[D3DHAL_MAX_RSTATES];
    };

    // State Override flags
    RRSTATEOVERRIDES m_renderstate_override;

    // Palette handles
    GArrayT<RDPaletteHandle> m_PaletteHandleArray;

    // texture state - per-stage state and pointer to associated texture
    int                 m_cActiveTextureStages; // count of active texture stages (range 0..D3DHAL_TSS_MAXSTAGES)
    DWORD               m_ReferencedTexCoordMask; // which texture coordinate sets are referenced
    RDSurface2D*        m_pTexture[D3DHAL_TSS_MAXSTAGES];  //  texture maps associated with texture stages
    union
    {
        DWORD   m_dwTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DTSS_MAX]; // state array (unsigned)
        FLOAT   m_fTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DTSS_MAX];  // state array (float)
        RDTextureStageState m_TextureStageState[D3DHAL_TSS_MAXSTAGES];
    };
    DWORD*  m_pTextureStageState[D3DHAL_TSS_MAXSTAGES]; // to speed GetTSS

    BOOL                m_bOverrideTCI;
    DWORD               m_dwTexArrayLength;

    // Vertex and Index streams
    // The extra VStream is for the Tesselator generated data.
    RDVStream                m_VStream[RD_MAX_NUMSTREAMS + 1];
    RDIStream                m_IndexStream;

    // Buffer to store transformed vertices
    GArrayT<RDVertex>        m_TLVArray;

    // Vertex shader state
    GArrayT<RDVShaderHandle> m_VShaderHandleArray;
    RDVShader                m_FVFShader; // Declaration for the legacy (FVF)
                                          // shader
    DWORD                    m_CurrentVShaderHandle;
    RDVShader*               m_pCurrentVShader;
    UINT64                   m_qwFVFOut;  // Desired FVF for the output
                                          // vertices

    // Coefficient storage for HOS
    GArrayT<RDHOCoeffs>      m_HOSCoeffs;

    // Primitive information
    D3DPRIMITIVETYPE m_primType;      // Current primitive being drawn
    DWORD            m_dwNumVertices; // Number of vertices to process
    DWORD            m_dwStartVertex;
    DWORD            m_dwNumIndices;
    DWORD            m_dwStartIndex;

    // Last state
    DWORD m_LastState;

    // Array of StateSets, which are in turn implemented with TemplArray as
    // TemplArray<UINT8> StateSetData
    TemplArray<LPStateSetData> m_pStateSets;

    // pixel shader state
    DWORD                    m_CurrentPShaderHandle;
    GArrayT<RDPShaderHandle> m_PShaderHandleArray;

    // Buffer used to process clear rects
    GArrayT<BYTE>            m_ClearRectBuffer;

    //-------------------------------------------------------------------------
    // methods
    //-------------------------------------------------------------------------

// refrasti.cpp
    HRESULT GrowTexArray( DWORD dwHandle );
    HRESULT SetTextureHandle( int iStage, DWORD dwHandle );
    void MapTextureHandleToDevice( int iStage );
    void UpdateActiveTexStageCount( void );
    RDSurface2D* MapHandleToTexture( D3DTEXTUREHANDLE hTex );

// MapLegcy.cpp
    void MapLegacyTextureBlend( void );
    void MapLegacyTextureFilter( void );

// primfns.cpp
    HRESULT GrowLightArray(const DWORD dwIndex);

    // pixel shader handle manipulation
    inline RDPShader* GetPShader( DWORD dwHandle )
    {
        if( m_PShaderHandleArray.IsValidIndex( dwHandle ) )
            return m_PShaderHandleArray[dwHandle].m_pShader;
        return NULL;
    }

// drawgrid.cpp
    HRESULT LinkTessellatorOutput();
    HRESULT LinkCachedTessellatorOutput(DWORD Handle, BYTE **pTempData);
    void UnlinkTessellatorOutput();
    void UnlinkCachedTessellatorOutput(BYTE **pTempData);

public:
    ///////////////////////////////////////////////////////////////////////////
    //
    // methods used by refdev objects to get at device state
    //
    ///////////////////////////////////////////////////////////////////////////
    inline DWORD* GetRS( void ) { return m_dwRenderState; }
    inline FLOAT* GetRSf( void ) { return m_fRenderState; }
    inline DWORD* GetTSS( DWORD Stage ) { return m_pTextureStageState[Stage]; }
    inline FLOAT* GetTSSf( DWORD Stage ) { return (FLOAT*)m_pTextureStageState[Stage]; }
    inline BOOL ColorKeyEnabled( void )
    {
        return
            m_dwRenderState[D3DRENDERSTATE_COLORKEYENABLE] ||
            m_dwRenderState[D3DRENDERSTATE_COLORKEYBLENDENABLE];
    }

    inline D3DCAPS8* GetCaps8( void ) { return &m_Caps8; }
};

//-------------------------------------------------------------------------
// DXTn compressed texture formats
//-------------------------------------------------------------------------
// number of DXT compression formats
#define NUM_DXT_FORMATS    5
// number of pixels in block
#define DXT_BLOCK_PIXELS   16

// DXT block size array
extern int g_DXTBlkSize[];

typedef struct  {
    BYTE    rgba[4];
} DXT_COLOR;

typedef WORD        RGB565;     // packed color
typedef DWORD       PIXBM;      // 2 BPP bitmap


typedef struct  {
    RGB565      rgb0;       // color for index 0
    RGB565      rgb1;       // color for index 1
    PIXBM       pixbm;      // pixel bitmap
} DXTBlockRGB;

typedef struct  {
    WORD        alphabm[4]; // alpha bitmap at 4 BPP
    DXTBlockRGB    rgb;        // color block
} DXTBlockAlpha4;

typedef struct  {
    BYTE        alpha0;     // alpha for index 0
    BYTE        alpha1;     // alpha for index 1
    BYTE        alphabm[6]; // alpha bitmap at 3 BPP
    DXTBlockRGB    rgb;        // color block
} DXTBlockAlpha3;

void DecodeBlockRGB (DXTBlockRGB *pblockSrc,
                     DXT_COLOR colorDst[DXT_BLOCK_PIXELS]);
void DecodeBlockAlpha4(DXTBlockAlpha4 *pblockSrc,
                       DXT_COLOR colorDst[DXT_BLOCK_PIXELS]);
void DecodeBlockAlpha3(DXTBlockAlpha3 *pblockSrc,
                       DXT_COLOR colorDst[DXT_BLOCK_PIXELS]);

///////////////////////////////////////////////////////////////////////////////
#endif // _REFDEV_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\inc\refrast.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// refrast.hpp
//
// Direct3D Reference Device - Rasterizer Core
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _REFRAST_HPP
#define _REFRAST_HPP

#include "pshader.h"

inline INT32 FloatToNdot4( FLOAT f )
{

// alternate form if FPU is set up to do double precision
//    return AS_INT32( (DOUBLE)f + DOUBLE_4_SNAP );

    INT32 i = AS_INT32( f + FLOAT_4_SNAP );
    i <<= 10; i >>= 10; // sign extend
    return i;
}

inline INT32 FloatToNdot5( FLOAT f )
{

// alternate form if FPU is set up to do double precision
//    return AS_INT32( (DOUBLE)f + DOUBLE_5_SNAP );

    INT32 i = AS_INT32( f + FLOAT_5_SNAP );
    i <<= 10; i >>= 10; // sign extend
    return i;
}

//-----------------------------------------------------------------------------
//
// Constants
//
//-----------------------------------------------------------------------------
const DWORD RD_MAX_MULTISAMPLES = 9;

const UINT RDPRIM_MAX_EDGES = 4;    // 4 edges for a point sprite
const UINT RDATTR_MAX_DIMENSIONALITY = 4;   // up to 4 scalars per attribute

// attribute array assignments
#define RDATTR_DEPTH                0
#define RDATTR_FOG                  1
#define RDATTR_COLOR                2
#define RDATTR_SPECULAR             3
#define RDATTR_TEXTURE0             4
#define RDATTR_TEXTURE1             5
#define RDATTR_TEXTURE2             6
#define RDATTR_TEXTURE3             7
#define RDATTR_TEXTURE4             8
#define RDATTR_TEXTURE5             9
#define RDATTR_TEXTURE6             10
#define RDATTR_TEXTURE7             11
const UINT RDPRIM_MAX_ATTRIBUTES = 12;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Pixel Component Classes                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Color Value Class - Holds an array of floats.
//
//-----------------------------------------------------------------------------
class RDColor
{
public:
    FLOAT R,G,B,A;

    inline RDColor( void ) { R = G = B = 0.0f; A = 1.0f; }
    // assignment constructors
    inline RDColor( UINT32 uVal )
    {
        R = (FLOAT)RGBA_GETRED(   uVal )*(1.f/255.f);
        G = (FLOAT)RGBA_GETGREEN( uVal )*(1.f/255.f);
        B = (FLOAT)RGBA_GETBLUE(  uVal )*(1.f/255.f);
        A = (FLOAT)RGBA_GETALPHA( uVal )*(1.f/255.f);
    }
    inline RDColor( FLOAT fR, FLOAT fG, FLOAT fB, FLOAT fA )
    {
        R = fR; G = fG; B = fB; A = fA;
    }
    inline RDColor( FLOAT* pC )
    {
        R = *(pC+0); G = *(pC+1); B= *(pC+2); A = *(pC+3);
    }

    // UINT32 copy operator
    inline void operator=(const UINT32 uVal)
    {
        R = (FLOAT)RGBA_GETRED(   uVal )*(1.f/255.f);
        G = (FLOAT)RGBA_GETGREEN( uVal )*(1.f/255.f);
        B = (FLOAT)RGBA_GETBLUE(  uVal )*(1.f/255.f);
        A = (FLOAT)RGBA_GETALPHA( uVal )*(1.f/255.f);
    }
    // FLOAT array copy operator
    inline void operator=(const FLOAT* pFVal)
    {
        R = *(pFVal+0);
        G = *(pFVal+1);
        B = *(pFVal+2);
        A = *(pFVal+3);
    }
    // casting operator
    inline operator UINT32() const
    {
        return D3DRGBA( R, G, B, A );
    }

    // set all channels
    inline void SetAllChannels( FLOAT fVal )
    {
        R = fVal; G = fVal; B = fVal; A = fVal;
    }

    // clamp to unity
    inline void Saturate( void )
    {
        R = MIN( 1.f, R );
        G = MIN( 1.f, G );
        B = MIN( 1.f, B );
        A = MIN( 1.f, A );
    }

    inline void Clamp( void )
    {
        R = MAX( 0.f, MIN( 1.f, R ) );
        G = MAX( 0.f, MIN( 1.f, G ) );
        B = MAX( 0.f, MIN( 1.f, B ) );
        A = MAX( 0.f, MIN( 1.f, A ) );
    }

    // copy to array of FLOATs
    inline void CopyTo( FLOAT* pF )
    {
        *(pF+0) = R;
        *(pF+1) = G;
        *(pF+2) = B;
        *(pF+3) = A;
    }

    //
    // conversions between surface format and RDColor - these define the
    // correct way to map between resolutions
    //

    // convert from surface type format to RDColor
    void ConvertFrom( RDSurfaceFormat Type, const char* pSurfaceBits );

    // Convert surface type format to RDColor
    void ConvertTo( RDSurfaceFormat Type, float fRoundOffset, char* pSurfaceBits ) const;
};

//-----------------------------------------------------------------------------
//
// RDDepth - Class for storing and manipulating pixel depth values.  Underlying
// storage is a double precision floating point, which has sufficient precision
// and range to support 16 and 32 bit fixed point and 32 bit floating point.
//
// The UINT32 methods receive a 24 or 32 bit value, and the UINT16
// methods receive a 15 or 16 bit value.
//
//-----------------------------------------------------------------------------
class RDDepth
{
    DOUBLE m_dVal;
    RDSurfaceFormat m_DepthSType;
    DOUBLE dGetValClamped(void) const { return min(1.,max(0.,m_dVal)); }
    DOUBLE dGetCnvScale(void) const
    {
        switch(m_DepthSType)
        {
        case RD_SF_Z16S0:
            return DOUBLE((1<<16)-1);
        case RD_SF_Z24S8:
        case RD_SF_Z24X8:
        case RD_SF_S8Z24:
        case RD_SF_X8Z24:
        case RD_SF_Z24X4S4:
        case RD_SF_X4S4Z24:
            return DOUBLE((1<<24)-1);
        case RD_SF_Z15S1:
        case RD_SF_S1Z15:
            return DOUBLE((1<<15)-1);
        case RD_SF_Z32S0:
            return DOUBLE(0xffffffff);  // too big to be generated as above without INT64's
        default:
            DPFRR(0, "RDDepth not initialized correctly");
            return DOUBLE(0.0);
        }
    }
    DOUBLE dGetCnvInvScale(void) const
    {
        switch(m_DepthSType)
        {
        case RD_SF_Z16S0:
            return DOUBLE( 1./(DOUBLE)((1<<16)-1) );
        case RD_SF_Z24S8:
        case RD_SF_Z24X8:
        case RD_SF_S8Z24:
        case RD_SF_X8Z24:
        case RD_SF_Z24X4S4:
        case RD_SF_X4S4Z24:
            return DOUBLE( 1./(DOUBLE)((1<<24)-1) );
        case RD_SF_Z15S1:
        case RD_SF_S1Z15:
            return DOUBLE( 1./(DOUBLE)((1<<15)-1) );
        case RD_SF_Z32S0:
            return DOUBLE( 1./(DOUBLE)(0xffffffff) );  // too big to be generated as above without INT64's
        default:
            DPFRR(0, "RDDepth not initialized correctly");
            return DOUBLE(0.0);
        }
    }
public:
    RDDepth() {;}
    // assignment constructors
    RDDepth(RDSurfaceFormat SType)             : m_dVal(0.F), m_DepthSType(SType)                         {;}
    RDDepth(UINT16 uVal, RDSurfaceFormat SType): m_DepthSType(SType), m_dVal((DOUBLE)uVal*dGetCnvInvScale()) {;}
    RDDepth(UINT32 uVal, RDSurfaceFormat SType): m_DepthSType(SType), m_dVal((DOUBLE)uVal*dGetCnvInvScale()) {;}

    // copy and assignment operators
    RDDepth& operator=(const RDDepth& A) { m_dVal = A.m_dVal; m_DepthSType = A.m_DepthSType; return *this; }
    RDDepth& operator=(UINT16 uVal) { m_dVal = (DOUBLE)uVal*dGetCnvInvScale(); return *this; }
    RDDepth& operator=(UINT32 uVal) { m_dVal = (DOUBLE)uVal*dGetCnvInvScale(); return *this; }
    RDDepth& operator=(FLOAT fVal) { m_dVal = (DOUBLE)fVal; return *this; }

    // round for integer get operations
    operator UINT16() const { return (UINT16)( (dGetValClamped()*dGetCnvScale()) + .5); }
    operator UINT32() const { return (UINT32)( (dGetValClamped()*dGetCnvScale()) + .5); }

    operator DOUBLE() const { return dGetValClamped(); }
    operator FLOAT()  const { return (FLOAT)dGetValClamped(); }
    void SetSType(RDSurfaceFormat SType)  { m_DepthSType = SType; }
    RDSurfaceFormat GetSType(void) const { return m_DepthSType; }
};

//-----------------------------------------------------------------------------
//
// Texture
//
//-----------------------------------------------------------------------------

#define RRTEX_LODFRAC       5
#define RRTEX_LODFRACMASK   0x1F
#define RRTEX_LODFRACF      .03125f

#define RRTEX_MAPFRAC       5
#define RRTEX_MAPFRACMASK   0x1F
#define RRTEX_MAPFRACF      .03125f

typedef struct _TextureSample
{
    INT32   iLOD;
    FLOAT   fWgt;
    INT32   iCrd[3];
} TextureSample;

typedef struct _TextureFilterControl
{
    int                     cSamples;
    TextureSample           pSamples[16*4*2];   // handles 16:1 aniso in two LODs
    D3DTEXTUREFILTERTYPE    MinFilter;
    D3DTEXTUREFILTERTYPE    MagFilter;
    D3DTEXTUREFILTERTYPE    MipFilter;
    D3DTEXTUREFILTERTYPE    CvgFilter;
    FLOAT                   fCrd[3];    // temporary: to run old filter/sample code
} TextureFilterControl;

typedef struct _TextureCoverage
{
    FLOAT               fLOD;
    FLOAT               fAnisoRatio;
    FLOAT               fAnisoLine[3];
    INT16               iLOD;           // n.RRTEX_LODFRAC fixed point LOD
    BOOL                bMagnify;
    int                 cLOD;           // 1 or 2, for accessing one or two LOD maps
    INT32               iLODMap[2];     // map index for maps adjacent to sample point
    FLOAT               fLODFrc[2];     // (fractional) weighting for each adjacent map
    FLOAT               fGradients[3][2];   // need to store gradients for cube maps
} TextureCoverage;

//
// structure containing texture coordinate and gradient information
// for lookup and filtering
//
class RDTextureCoord
{
public:
    union { FLOAT C0; FLOAT fNX; FLOAT fU; };
    union { FLOAT C1; FLOAT fNY; FLOAT fV; };
    union { FLOAT C2; FLOAT fNZ; FLOAT fW; };
    union { FLOAT DC0DX; FLOAT fDNXDX; FLOAT fDUDX; };
    union { FLOAT DC0DY; FLOAT fDNXDY; FLOAT fDUDY; };
    union { FLOAT DC1DX; FLOAT fDNYDX; FLOAT fDVDX; };
    union { FLOAT DC1DY; FLOAT fDNYDY; FLOAT fDVDY; };
    union { FLOAT DC2DX; FLOAT fDNZDX; };
    union { FLOAT DC2DY; FLOAT fDNZDY; };
};

void
ComputeMipCoverage(
    const FLOAT (*fGradients)[2],
    FLOAT& fLOD, int cDim );
void
ComputeAnisoCoverage(
    const FLOAT (*fGradients)[2], FLOAT fMaxAniso,
    FLOAT& fLOD, FLOAT& fRatio, FLOAT fDelta[] );
void
ComputeCubeCoverage(
    const FLOAT (*fGradients)[2],
    FLOAT& fLOD );
void
DoCubeRemap(
    INT32 iCrd[], INT32 iCrdMax[],
    D3DCUBEMAP_FACES& Face, UINT uOut0, UINT uOut1);

//-----------------------------------------------------------------------------
//
// Primitive edge function - Computes, stores, and evaluates linear function
// for edges.  Basic function is stored in fixed point.  Gradient sign terms
// are computed and stored separately to adhere to fill rules.
//
// This can evaluate edges to a 1/16th subpixel resolution grid.
//
//-----------------------------------------------------------------------------
class RDEdge
{
public:
    INT32   m_iA;       // n.4 fixed point
    INT32   m_iB;       // n.4 fixed point
    INT64   m_iC;       // n.8 fixed point
    BOOL    m_bAPos;    // carefully computed signs of A,B
    BOOL    m_bBPos;

    void Set(
        BOOL bDetSign,
        INT32 iX0, INT32 iY0,
        INT32 iX1, INT32 iY1);

    BOOL Test(INT32 iX, INT32 iY );
};

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
class RDAttribute
{
public:
    friend class RefRast;
    // pointer back to containing refrast object
    RefRast* m_pRR;

    BOOL    m_bPerspective;
    BOOL    m_bClamp;           // clamp to 0..1 if TRUE
    UINT    m_cDimensionality;
    UINT    m_cProjection;      // project by c'th element (0 == disable)
    DWORD   m_dwWrapFlags;      // wrap flags for each dimension (from LSB)
    BOOL    m_bFlatShade;

    // per-dimension attribute functions
    FLOAT   m_fA[RDATTR_MAX_DIMENSIONALITY];
    FLOAT   m_fB[RDATTR_MAX_DIMENSIONALITY];
    FLOAT   m_fC[RDATTR_MAX_DIMENSIONALITY];

    // things generally only set once
    void Init(
        RefRast* pPrimitive, // RefRast with which this attrib is used
        UINT cDimensionality,
        BOOL bPerspective,
        BOOL bClamp );

    // things generally set as RS or TSS changes
    void SetFlatShade( BOOL bFlatShade )    { m_bFlatShade = bFlatShade; }
    void SetWrapFlags( DWORD dwWrapFlags )  { m_dwWrapFlags = dwWrapFlags; }
    void SetProjection( UINT cProjection )  { m_cProjection = cProjection; }
    void SetPerspective( BOOL bPerspective) { m_bPerspective = bPerspective; }

    void Setup(
        const FLOAT* pVtx0, const FLOAT* pVtx1, const FLOAT* pVtx2);
    void LineSetup(
        const FLOAT* pVtx0, const FLOAT* pVtx1, const FLOAT* pVtxFlat = NULL );
    void Setup(
        DWORD dwVtx0, DWORD dwVtx1, DWORD dwVtx2);

    // fully general sample function
    void Sample( FLOAT* pSampleData, FLOAT fX, FLOAT fY,
        BOOL bNoProjectionOverride = TRUE, BOOL bClampOverride = FALSE );
    // sample scalar attribute at given location; assumes no perspective or projection
    //  (used for Depth)
    FLOAT Sample( FLOAT fX, FLOAT fY );
};

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
class RefRast
{
public:
    friend class RDAttribute;
    friend class RDEdge;

    RefDev* m_pRD;
    ~RefRast();
    void Init( RefDev* pRD );

// used for all primitives
    BOOL    m_bIsLine;  // TRUE if rendering a line
    UINT    m_iFlatVtx; // 0..2 range; which vertex to use for flat shading color

    RDAttribute m_Attr[RDPRIM_MAX_ATTRIBUTES];

    FLOAT   m_fX0, m_fY0;   // first vertex, snapped (for initial evaluation)
    FLOAT   m_fRHW0, m_fRHW1, m_fRHW2;  // 1/W data for perspective correction
    FLOAT   m_fRHWA, m_fRHWB, m_fRHWC;  // linear function for 1/W for perspective correction
    FLOAT   SampleAndInvertRHW( FLOAT fX, FLOAT fY );   // sample 1/W at current given location, invert, and return

// triangle and point rendering
    RDEdge  m_Edge[RDPRIM_MAX_EDGES];
    INT32   m_iEdgeCount;

    // integer x,y coords snapped to n.4 grid
    INT32   m_iX0, m_iY0, m_iX1, m_iY1, m_iX2, m_iY2;
    INT64   m_iDet; // n.8 determinant

    FLOAT   m_fDelX10, m_fDelX02; // float x,y deltas
    FLOAT   m_fDelY01, m_fDelY20; //
    FLOAT   m_fTriOODet;          // 1/determinant for triangle function normalization

    // integer x,y scan area, intersected with viewport and guardband
    INT32   m_iXMin, m_iXMax, m_iYMin, m_iYMax;

    BOOL PerTriangleSetup(
        FLOAT* pVtx0, FLOAT* pVtx1, FLOAT* pVtx2,
        DWORD CullMode,
        RECT* pClip);

    BOOL EvalPixelPosition( int iPix );

// line rendering
    INT64   m_iLineEdgeFunc[3];     // line function: Pminor = ([0]*Pmajor + [1])/[2]
    BOOL    m_bLineXMajor;          // TRUE if X major for line function
    INT32   m_iLineMin, m_iLineMax; // min and max pixel extent in major direction
    INT32   m_iLineStep;            // +1 or -1 depending on line major direction
    FLOAT   m_fLineMajorLength;     // major length for line function
    INT32   m_cLineSteps;           // number of steps to take in line iteration

    BOOL PerLineSetup(
        FLOAT* pVtx0, FLOAT* pVtx1,
        BOOL bLastPixel,
        RECT* pClip);

    void StepLine( void );
    INT32   m_iMajorCoord;

// per-pixel data
    int         m_iPix; // which of 4 pixels are currently being worked on

    // per-pixel values
    BOOL        m_bPixelIn[4];
    INT32       m_iX[4], m_iY[4]; // current position
    FLOAT       m_fW[4];
    FLOAT       m_FogIntensity[4];
    RDDepth     m_Depth[4]; // TODO - get rid of this...

    // per-(pixel&sample) values
    BOOL        m_bSampleCovered[RD_MAX_MULTISAMPLES][4];
    RDDepth     m_SampleDepth[RD_MAX_MULTISAMPLES][4];

    // pixel shader stuff
    BOOL        m_bLegacyPixelShade;
    RDPShader*  m_pCurrentPixelShader;
    UINT        m_CurrentPSInst;
    BOOL        m_bPixelDiscard[4];

    // register files
    FLOAT       m_InputReg[RDPS_MAX_NUMINPUTREG][4][4];
    FLOAT       m_TempReg[RDPS_MAX_NUMTEMPREG][4][4];
    FLOAT       m_ConstReg[RDPS_MAX_NUMCONSTREG][4][4];
    FLOAT       m_TextReg[RDPS_MAX_NUMTEXTUREREG][4][4];

    // additional ref-specific registers for holding temporary values in pixel shader
    FLOAT       m_PostModSrcReg[RDPS_MAX_NUMPOSTMODSRCREG][4][4]; // temporary values holding src mod results for 3 source parameters
    FLOAT       m_ScratchReg[RDPS_MAX_NUMSCRATCHREG][4][4]; // just a general scratchpad register (example use: storing eye/reflection vector)
    FLOAT       m_ZeroReg[4][4];  // register containing 0.0f.
    FLOAT       m_OneReg[4][4];   // register containing 1.0f.
    FLOAT       m_TwoReg[4][4];   // register containing 2.0f.
    FLOAT       m_QueuedWriteReg[RDPS_MAX_NUMQUEUEDWRITEREG][4][4];  // staging registers for queued writes
    PSQueuedWriteDst  m_QueuedWriteDst[RDPS_MAX_NUMQUEUEDWRITEREG]; // destination register on flush for queued write

    FLOAT       m_Gradients[3][2];        // gradients for texture sampling

    void ExecShader( void );
    void DoRegToRegOp( PixelShaderInstruction* pInst );
#if DBG
    BOOL        m_bDebugPrintTranslatedPixelShaderTokens;
#endif


    RDPShader*  m_pLegacyPixelShader;
    void UpdateLegacyPixelShader( void );

// multi-sample stuff
    UINT    m_SampleCount;      // count and deltas for current MS buffer type
    INT32   m_SampleDelta[RD_MAX_MULTISAMPLES][2];
    DWORD   m_SampleMask;       // copy of renderstate

    UINT    m_CurrentSample;    // current sample number for 'NextSample' stepper

    inline void SetSampleMask( DWORD SampleMask ) { m_SampleMask = SampleMask; }
    inline BOOL GetCurrentSampleMask( void )
    {
        if ( m_SampleCount <= 1 ) return TRUE; // not effective when not MS buffer
        return ( (1<<m_CurrentSample) & m_SampleMask ) ? TRUE : FALSE;
    }

    inline UINT GetCurrentSample( void ) { return m_CurrentSample; }

    // returns TRUE until samples exhausted and then resets itself on FALSE return
    inline BOOL NextSample( void )
    {
        if (++m_CurrentSample == m_SampleCount)
        {
            // done iterating thru samples, so reset and return FALSE
            m_CurrentSample = 0;
            return FALSE;
        }
        return TRUE;
    }

    // returns x,y deltas (n.4 fixed point) of current sample
    inline INT32 GetCurrentSampleX( int iPix )
        { return (m_iX[iPix]<<4) + m_SampleDelta[m_CurrentSample][0]; }
    inline INT32 GetCurrentSampleY( int iPix )
        { return (m_iY[iPix]<<4) + m_SampleDelta[m_CurrentSample][1]; }
    inline FLOAT GetCurrentSamplefX( int iPix )
        { return (FLOAT)GetCurrentSampleX(iPix) * (1./16.); }
    inline FLOAT GetCurrentSamplefY( int iPix )
        { return (FLOAT)GetCurrentSampleY(iPix) * (1./16.); }

    // sets internal sample number and per-sample deltas based on FSAA type
    void SetSampleMode( UINT MultiSampleCount, BOOL bAntialias );
    UINT GetCurrentNumberOfSamples( void )
        { return m_SampleCount; }


// setup.cpp
    void SetAttributeFunctions(
        const RDVertex& Vtx0,
        const RDVertex& Vtx1,
        const RDVertex& Vtx2 );

// scancnv.cpp
    FLOAT ComputeFogIntensity( FLOAT fX, FLOAT fY );
    void SnapDepth( void );
    void DoScanCnvGenPixels( void );
    void DoScanCnvTri( int iEdgeCount );
    void DoScanCnvLine( void );

// texture filtering
    TextureCoverage         m_TexCvg[D3DHAL_TSS_MAXSTAGES];
    TextureFilterControl    m_TexFlt[D3DHAL_TSS_MAXSTAGES];
    void UpdateTextureControls( void );
    void ComputeTextureCoverage( int iStage, FLOAT (*fGradients)[2] );
    void ComputePerLODControls( int iStage );
    void ComputePointSampleCoords(
        int iStage, INT32 iLOD, FLOAT fCrd[],
        INT32 iCrd[] );
    void ComputeLinearSampleCoords(
        int iStage, INT32 iLOD, FLOAT fCrd[],
        INT32 iCrdFlr[], INT32 iCrdClg[], FLOAT fCrdFrcF[], FLOAT fCrdFrcC[] );
    void SetUp1DTextureSample(
        int iStage, int Start,
        INT32 iLODMap, FLOAT fLODScale,
        INT32 iCrdF, INT32 iCrdC,
        FLOAT fCrdFrcF, FLOAT fCrdFrcC );
    void SetUp2DTextureSample(
        int iStage, int Start,
        INT32 iLODMap, FLOAT fLODScale,
        INT32 iCrdF[], INT32 iCrdC[],
        FLOAT fCrdFrcF[], FLOAT fCrdFrcC[] );
    void SetUp3DTextureSample(
        int iStage, int Start,
        INT32 iLODMap, FLOAT fLODScale,
        INT32 iCrdF[], INT32 iCrdC[],
        FLOAT fCrdFrcF[], FLOAT fCrdFrcC[] );
    void SetUpCubeMapLinearSample(
        int iStage, D3DCUBEMAP_FACES Face,
        INT32 iLODMap, FLOAT fLODScale,
        INT32 (*iCrd)[2], FLOAT (*fFrc)[2] );
    void ComputeTextureFilter( int iStage, FLOAT fCrd[] );
    void ComputeCubeTextureFilter( int iStage, FLOAT fCrd[] );
    void SampleTexture( INT32 iStage, FLOAT fCol[] );


// texstage.cpp
    void ComputeTextureBlendArg(
        DWORD dwArgCtl, BOOL bAlphaOnly,
        const RDColor& DiffuseColor,
        const RDColor& SpecularColor,
        const RDColor& CurrentColor,
        const RDColor& TextureColor,
        const RDColor& TempColor,
        RDColor& BlendArg);
    void DoTextureBlendStage(
        int iStage,
        const RDColor& DiffuseColor,
        const RDColor& SpecularColor,
        const RDColor& CurrentColor,
        const RDColor& TextureColor,
        RDColor& TempColor,
        RDColor& OutputColor);

// pixproc.cpp
    void DoPixels( void );
    BOOL DepthCloser( const RDDepth& DepthVal, const RDDepth& DepthBuf );
    BOOL AlphaTest( FLOAT fAlpha );
    BOOL DoStencil( UINT8 uStncBuf, BOOL bDepthTest, RDSurfaceFormat DepthSFormat, UINT8& uStncRet );
    void DoAlphaBlend( const RDColor& SrcColor, const RDColor& DstColor, RDColor& ResColor );

// pixref.cpp
    void WritePixel( INT32 iX, INT32 iY, UINT Sample, const RDColor& Color, const RDDepth& Depth);

};


///////////////////////////////////////////////////////////////////////////////
#endif // _REFRAST_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\inc\reftnl.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// reftnl.hpp
//
// Direct3D Reference Transform and Lighting - Main Header File
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _REFTNL_HPP
#define  _REFTNL_HPP

#define RD_GB_LEFT   -32768.f
#define RD_GB_TOP    -32768.f
#define RD_GB_RIGHT   32767.f
#define RD_GB_BOTTOM  32767.f

//-----------------------------------------------------------------------------
//
// Constants
//
//-----------------------------------------------------------------------------
// Default color values that should be used when ther is no lighting and
// color in vertices provided
const DWORD RD_DEFAULT_DIFFUSE  = 0xFFFFFFFF;
const DWORD RD_DEFAULT_SPECULAR = 0;

const DWORD RD_MAX_FVF_TEXCOORD = 8;

const DWORD RD_MAX_VERTEX_COUNT = 2048;

// Number of clipping planes
const DWORD RD_MAX_USER_CLIPPLANES = 6;

// Number of clipping planes
const DWORD RD_MAX_CLIPPING_PLANES = (6+RD_MAX_USER_CLIPPLANES);

// Number of blend weights
const DWORD RD_MAX_BLEND_WEIGHTS = 4;

// Number of world matrices
const DWORD RD_MAX_WORLD_MATRICES = 256;

const DWORD RD_WORLDMATRIXBASE  = 256;

// Space for vertices generated/copied while clipping one triangle
const DWORD RD_MAX_CLIP_VERTICES = (( 2 * RD_MAX_CLIPPING_PLANES ) + 3 );

// 3 verts. -> 1 tri, 4 v -> 2 t, N vertices -> (N - 2) triangles
const DWORD RD_MAX_CLIP_TRIANGLES = ( RD_MAX_CLIP_VERTICES - 2 );

// make smaller than guard band for easier clipping
const float RD_MAX_POINT_SIZE = 64;

//-----------------------------------------------------------------------------
//
// Forward defines
//
//-----------------------------------------------------------------------------
class RDLight;

//-----------------------------------------------------------------------------
//
// Typedefs
//
//-----------------------------------------------------------------------------
typedef DWORD RDCLIPCODE;
typedef D3DMATRIX RDMATRIX;

//-----------------------------------------------------------------------------
//
// RDVertex - Internal vertex structure of the refrast. This is the
//            structure exchanged between the T&L and Rasterization parts
//            of the refrast.
//
//-----------------------------------------------------------------------------

class RDVertex
{
public:
    RDVertex()
    {
        Init();
    }

    RDVertex( LPDWORD pVtx, DWORD dwFvf )
    {
        SetFvfData( pVtx, (UINT64)dwFvf );
    }

    RDVertex( LPDWORD pVtx, UINT64 qwFvf )
    {
        SetFvfData( pVtx, qwFvf );
    }

    RDCLIPCODE m_clip;
    FLOAT      m_clip_x;
    FLOAT      m_clip_y;
    FLOAT      m_clip_z;
    FLOAT      m_clip_w;
    RDVECTOR3  m_pos;            // This is screen coordinates
    FLOAT      m_rhw;
    RDCOLOR4   m_diffuse;        // ARGB (0..1 each component)
    RDCOLOR4   m_specular;       // ARGB
    FLOAT      m_fog;            // 0..1
    FLOAT      m_pointsize;
    RDVECTOR4  m_tex[8];

    UINT64 m_qwFVF;

    void Init()
    {
        m_clip = 0;
        m_clip_x = m_clip_y = m_clip_z = m_clip_w = 0.0f;
        m_rhw = 0.0f;
        m_diffuse.a = m_diffuse.r = m_diffuse.g = m_diffuse.b = 1.0f;
        m_specular.a = m_specular.r = m_specular.g = m_specular.b = 0.0f;
        m_fog = 0.0f;
        m_pointsize = 1.0f;
        // Initialize texture coordinates to {0.0, 0.0, 0.0, 1.0}
        memset( m_tex, 0, sizeof(m_tex) );
        for( int i=0; i<8; i++ ) m_tex[i].w = 1.0f;
        m_qwFVF = 0;
    }

    void SetFVF( UINT64 qwControl )
    {
        m_qwFVF = qwControl;
    }

    void SetFvfData( LPDWORD pVtx, UINT64 qwFVF )
    {
        DWORD cDWORD = 0;
        Init();
        m_qwFVF = qwFVF;
        switch( qwFVF & D3DFVF_POSITION_MASK )
        {
        case D3DFVF_XYZRHW:
            memcpy( &m_pos, pVtx, 3*sizeof( float ) );
            pVtx += 3;
            m_rhw = *(float *)(pVtx);
            pVtx += 1;
            break;
        default:
            _ASSERT( TRUE, "RDVertex can only hold Transformed Vertices" );
            return;
        }

        if (qwFVF & D3DFVF_PSIZE)
        {
            m_pointsize = *(FLOAT*)pVtx;
            pVtx++;
        }
        if (qwFVF & D3DFVF_DIFFUSE)
        {
            MakeRDCOLOR4( &m_diffuse, *pVtx );
            pVtx++;
        }
        if (qwFVF & D3DFVF_SPECULAR)
        {
            MakeRDCOLOR4( &m_specular, *pVtx );
            m_fog = m_specular.a;
            m_qwFVF |= D3DFVFP_FOG;
            pVtx++;
        }
        if (qwFVF & D3DFVF_FOG)
        {
            m_fog = *(FLOAT*)pVtx;
            m_qwFVF |= D3DFVFP_FOG;
            pVtx++;
        }
        DWORD dwNumTexCoord = (DWORD)(FVF_TEXCOORD_NUMBER(qwFVF));
        DWORD dwTextureFormats = (DWORD)qwFVF >> 16;

        // Texture formats size  00   01   10   11
        static DWORD dwTextureSize[4] = {2, 3, 4, 1};
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            memcpy( &m_tex[i], pVtx,
                    sizeof( float )*dwTextureSize[dwTextureFormats & 3] );
            pVtx += dwTextureSize[dwTextureFormats & 3];
            dwTextureFormats >>= 2;
        }
    }

    FLOAT GetRHW( void ) const
    {
        return ( m_qwFVF & D3DFVF_XYZRHW ) ? m_rhw : 1.f ;
    }

    FLOAT* GetPtrXYZ( void ) { return (FLOAT*)&m_pos; }
    FLOAT GetX( void ) const  { return m_pos.x; }
    FLOAT GetY( void ) const  { return m_pos.y; }
    FLOAT GetZ( void ) const  { return m_pos.z; }
    DWORD GetDiffuse( void ) const
    {
        DWORD diff =
            D3DRGBA(m_diffuse.r, m_diffuse.g, m_diffuse.b, m_diffuse.a);
        // return color if available else white (default)
        return ( m_qwFVF & D3DFVF_DIFFUSE ) ? diff : 0xffffffff;
    }

    DWORD GetSpecular( void ) const
    {
        DWORD spec =
            D3DRGBA(m_specular.r, m_specular.g, m_specular.b, m_specular.a);
        // return color if available else black (default)
        return ( m_qwFVF & D3DFVF_SPECULAR ) ? spec : 0x00000000;
    }

    UINT TexCrdCount( void ) const
    {
        return
            (UINT)(( m_qwFVF & D3DFVF_TEXCOUNT_MASK ) >> D3DFVF_TEXCOUNT_SHIFT);
    }

    FLOAT GetTexCrd( UINT iCrd, UINT iCrdSet ) const
    {
        // This function ensures that right defaults are returned.
        // Note, except for the q coordinate (which defaults to 1.0)
        // the rest are 0.0.
        if( (iCrdSet < TexCrdCount()) &&
            (iCrd < GetTexCoordDim(m_qwFVF, iCrdSet)) )
        {
            return *( (FLOAT*)&m_tex[iCrdSet] + iCrd );
        }
        else if( iCrd == 3 )
        {
            return 1.0f;
        }
        else
        {
            return 0.0f;
        }
    }

    FLOAT GetLastTexCrd( UINT iCrdSet ) const
    {
        // Return the last texture coordinate if present else 1.0
        if( iCrdSet < TexCrdCount() )
        {
            return *( (FLOAT*)&m_tex[iCrdSet] +
                      GetTexCoordDim(m_qwFVF, iCrdSet) - 1);
        }
        else
        {
            return 1.0f;
        }
    }

    FLOAT GetPointSize( void ) const
    {
        return ( m_qwFVF & D3DFVF_PSIZE ) ? m_pointsize : 1.0f;
    }

    FLOAT GetFog( void ) const
    {
        return ( m_qwFVF & D3DFVFP_FOG ) ? m_fog : 0.0f;
    }
};

class RDClipVertex : public RDVertex
{
public:
    RDClipVertex()
    {
        next = NULL;
    }

    RDClipVertex  *next;
};

struct RDCLIPTRIANGLE
{
    RDCLIPTRIANGLE()
    {
        memset( this, 0, sizeof(*this) );
    }

    RDClipVertex  *v[3];
};

struct RDUSERCLIPPLANE
{
    RDUSERCLIPPLANE()
    {
        memset( this, 0, sizeof(*this) );
    }

    RDVECTOR4       plane;
    BOOL            bActive;
};

//-----------------------------------------------------------------------------
//
// RDTRANSFORMDATA - Transformation data used by Refrence T&L implementation
// to transform vertices.
//
//-----------------------------------------------------------------------------
struct RDTRANSFORMDATA
{
    RDTRANSFORMDATA()
    {
        memset( this, 0, sizeof(*this) );
    }

    RDMATRIX      m_PS;         // Mproj * Mshift
    RDMATRIX      m_VPS;        // Mview * PS
    RDMATRIX      m_VPSInv;     // Inverse( Mview * PS )
    RDMATRIX      m_CTMI;       // Inverse current transformation matrix
    RDVECTOR4     m_frustum[6]; // Normalized plane equations for viewing
    // frustum in the model space
    DWORD          m_dwFlags;
};

//---------------------------------------------------------------------
// RDLIGHTINGDATA
// All the lighting related state clubbed together
//---------------------------------------------------------------------

struct RDLIGHTINGDATA
{
    RDLIGHTINGDATA()
    {
        memset( this, 0, sizeof(*this) );
    }

    // Active Light list
    RDLight           *pActiveLights;

    // Temporary data used when computing lighting

    RDVECTOR3       eye_in_eye;         // eye position in eye space
    // It is (0, 0, 0)

    // Ma * La + Me (Ambient and Emissive) ------
    RDCOLOR3           ambEmiss;

    // ColorVertex stuff ------------------------
    RDCOLOR3 *pAmbientSrc;
    RDCOLOR3 *pDiffuseSrc;
    RDCOLOR3 *pSpecularSrc;
    RDCOLOR3 *pEmissiveSrc;

    // Diffuse ----------------------------------
    RDCOLOR3           vertexDiffuse; // Provided with a vertex, used if
    // COLORVERTEX is enabled and a diffuse
    // color is provided in the vertex
    RDCOLOR3           diffuse;       // Diffuse accumulates here
    DWORD             outDiffuse;    // Diffuse color result of lighting


    // Specular --------------------------------
    RDCOLOR3           vertexSpecular;// Provided with a vertex, used if
    // COLORVERTEX is enabled and a specular
    // color is provided in the vertex
    RDCOLOR3           specular;      // Specular accumulates here
    DWORD             outSpecular;   // Specular color result of lighting

    D3DVALUE          specThreshold;  // If the dot product is less than this
    // value, specular factor is zero
    // End of temporary data

    // RENDERSTATEAMBIENT --------------------------------------

    // Ambient color set by D3DRENDERSTATE_AMBIENT
    // They are all scaled to 0 - 1
    D3DVALUE          ambient_red;
    D3DVALUE          ambient_green;
    D3DVALUE          ambient_blue;
    DWORD             ambient_save;       // Original unscaled color

    // Fog -----------------------------------------------------
    int               fog_mode;
    D3DCOLOR          fog_color;
    D3DVALUE          fog_density;
    D3DVALUE          fog_start;
    D3DVALUE          fog_end;
    D3DVALUE          fog_factor;     // 255 / (fog_end - fog_start)

    D3DCOLORMODEL     color_model;

    // Material ------------------------------------------------

    // For color material
    LPDWORD           pDiffuseAlphaSrc;
    LPDWORD           pSpecularAlphaSrc;

    DWORD               materialDiffAlpha;  // Current material diffuse
    // alpha (0-255) shifted left
    // by 24 bits

    DWORD               materialSpecAlpha;  // Current material specular
    // alpha (0-255) shifted left
    // by 24 bits

    DWORD               vertexDiffAlpha;    // Current material diffuse
    // alpha (0-255) shifted left
    // by 24 bits

    DWORD               vertexSpecAlpha;    // Current material specular
    // alpha (0-255) shifted left
    // by 24 bits

    D3DMATERIAL7      material;           // Cached material data
    RDCOLOR3           matAmb;
    RDCOLOR3           matDiff;
    RDCOLOR3           matSpec;
    RDCOLOR3           matEmis;
};

//-----------------------------------------------------------------------------
//
// RDLight - The light object used by the Reference T&L implementation
// An array of these are instanced in the RefDev object.
//
//-----------------------------------------------------------------------------
struct RDLIGHTI
{
    RDLIGHTI()
    {
        memset( this, 0, sizeof(*this) );
    }

    DWORD           flags;

    RDVECTOR3       position_in_eye;  // In the eye space
    RDVECTOR3       direction_in_eye; // In the eye space

    //
    // Saved light colors scaled from 0 - 255, needed for COLORVERTEX
    //
    D3DCOLORVALUE   La;         //  light ambient
    D3DCOLORVALUE   Ld;         //  light diffuse
    D3DCOLORVALUE   Ls;         //  light specular

    //
    // Precomputed colors scaled from 0 - 255,
    //
    D3DCOLORVALUE   Ma_La;         // Material ambient times light ambient
    D3DCOLORVALUE   Md_Ld;         // Material diffuse times light diffuse
    D3DCOLORVALUE   Ms_Ls;         // Material specular times light specular


    RDVECTOR3       halfway;

    // Stuff for SpotLights
    D3DVALUE        range_squared;
    D3DVALUE        cos_theta_by_2;
    D3DVALUE        cos_phi_by_2;
    D3DVALUE        inv_theta_minus_phi;

};


//-----------------------------------------------------------------------------
// Function pointer to the functions that light a vertex
//-----------------------------------------------------------------------------
typedef void (*RDLIGHTVERTEXFN)( RDLIGHTINGDATA& LData, D3DLIGHT7 *pLight,
                                 RDLIGHTI *pLightI, RDLIGHTINGELEMENT *in,
                                 DWORD dwFlags, UINT64 qwFVFIn );

//-----------------------------------------------------------------------------
// Functions to compute lighting
//-----------------------------------------------------------------------------
struct RDLIGHTVERTEX_FUNC_TABLE
{
    RDLIGHTVERTEX_FUNC_TABLE()
    {
        memset( this, 0, sizeof(*this) );
    }

    RDLIGHTVERTEXFN   pfnDirectional;
    RDLIGHTVERTEXFN   pfnParallelPoint;
    RDLIGHTVERTEXFN   pfnSpot;
    RDLIGHTVERTEXFN   pfnPoint;
};

//-----------------------------------------------------------------------------
//
// RDLight - The light object used by the Reference T&L implementation
// An array of these are instanced in the RefDev object.
//
//-----------------------------------------------------------------------------
#define RDLIGHT_ENABLED              0x00000001  // Is the light active
#define RDLIGHT_NEEDSPROCESSING      0x00000002  // Is the light data processed
#define RDLIGHT_REFERED              0x00000004  // Has the light been refered
                                                 // to

class RDLight : public RDAlloc
{
public:
    RDLight();
    BOOL IsEnabled() {return (m_dwFlags & RDLIGHT_ENABLED);}
    BOOL NeedsProcessing() {return (m_dwFlags & RDLIGHT_NEEDSPROCESSING);}
    BOOL IsRefered() { return (m_dwFlags & RDLIGHT_REFERED); }
    HRESULT SetLight(LPD3DLIGHT7 pLight);
    HRESULT GetLight( LPD3DLIGHT7 pLight );
    void ProcessLight( D3DMATERIAL7 *mat, RDLIGHTVERTEX_FUNC_TABLE *pTbl);
    void XformLight( D3DMATRIX* mV );
    void Enable( RDLight **ppRoot );
    void Disable( RDLight **ppRoot );

private:

    // Flags
    DWORD m_dwFlags;

    // Active List next element
    RDLight *m_Next;

    // Specific function to light the vertex
    RDLIGHTVERTEXFN   m_pfnLightVertex;

    // Light data set by the runtime
    D3DLIGHT7 m_Light;

    // Light data computed by the driver
    RDLIGHTI  m_LightI;

    friend class RefDev;
    friend class RefVP;
};

//---------------------------------------------------------------------
//
// The clipper object. Contains digested Viewport information
// calculated from viewport settings.
//
//---------------------------------------------------------------------
class RefClipper
{
public:
    RefClipper();

    // The pointer to the driver object to obtain state
    RefDev* m_pDev;

    // m_dwDirtyFlags
    static const DWORD RCLIP_DIRTY_ZRANGE;
    static const DWORD RCLIP_DIRTY_VIEWRECT;
    static const DWORD RCLIP_DO_FLATSHADING;
    static const DWORD RCLIP_DO_WIREFRAME;
    static const DWORD RCLIP_DO_ADJUSTWRAP;
    static const DWORD RCLIP_Z_ENABLE;
    DWORD m_dwFlags;

    // Viewport data from the DDI.
    D3DVIEWPORT7 m_Viewport;

    // Is it guardband or not ?
    BOOL m_bUseGB;

    D3DVALUE dvX;               // dwX
    D3DVALUE dvY;               // dwY
    D3DVALUE dvWidth;           // dwWidth
    D3DVALUE dvHeight;          // dwHeight

    // Coefficients to compute screen coordinates from normalized window
    // coordinates
    D3DVALUE scaleX;            // dvWidth/2
    D3DVALUE scaleY;            // dvHeight/2
    D3DVALUE scaleZ;            // (Viewport->dvMaxZ - Viewport->dvMinZ)
    D3DVALUE offsetX;           // dvX + scaleX
    D3DVALUE offsetY;           // dvY + scaleY
    D3DVALUE offsetZ;           // Viewport->dvMinZ

    // Coefficients to compute screen coordinates from normalized window
    // coordinates
    D3DVALUE scaleXi;           // Inverse of scaleX
    D3DVALUE scaleYi;           // Inverse of scaleY
    D3DVALUE scaleZi;           // Inverse of scaleZ

    // Min and max values for viewport window in pixels
    D3DVALUE minX;              // offsetX - scaleX
    D3DVALUE minY;              // offsetY - scaleY
    D3DVALUE maxX;              // offsetX + scaleX
    D3DVALUE maxY;              // offsetY + scaleY

    // Min and max window values with guard band in pixels
    D3DVALUE minXgb;
    D3DVALUE minYgb;
    D3DVALUE maxXgb;
    D3DVALUE maxYgb;

    // Coefficients to transform a vertex to perform the guard band clipping
    // x*gb11 + w*gb41
    // y*gb22 + w*gb42
    //
    D3DVALUE gb11;
    D3DVALUE gb22;
    D3DVALUE gb41;
    D3DVALUE gb42;

    // Coefficients to apply clipping rules for the guard band clipping
    // They are used by clipping routins
    // w*Kgbx1 < x < w*Kgbx2
    // w*Kgby1 < y < w*Kgby2
    //
    D3DVALUE Kgbx1;
    D3DVALUE Kgby1;
    D3DVALUE Kgbx2;
    D3DVALUE Kgby2;


    // Clipping related
    RDCLIPCODE m_clipUnion;            // OR of all vertex clip flags
    RDCLIPCODE m_clipIntersection;     // AND of all vertex clip flags

    GArrayT<RDVertex>  ClipBuf;
    RDClipVertex  *clip_vbuf1[RD_MAX_CLIP_VERTICES];
    RDClipVertex  *clip_vbuf2[RD_MAX_CLIP_VERTICES];
    RDClipVertex **current_vbuf;  // clip_vbuf1 or clip_vbuf2
    RDClipVertex   clip_vertices[RD_MAX_CLIP_VERTICES];
    DWORD       m_dwInterpolate;
    int         clip_vertices_used;
    RDCOLOR4    clip_color;
    RDCOLOR4    clip_specular;

    // User defined clipping planes
    RDVECTOR4 m_userClipPlanes[RD_MAX_USER_CLIPPLANES];

    // User clip planes transformed
    RDUSERCLIPPLANE m_xfmUserClipPlanes[RD_MAX_USER_CLIPPLANES];

    //---------------------------------------------------
    // Methods
    //---------------------------------------------------
    HRESULT UpdateViewData();
    void MakeClipVertexFromVertex( RDClipVertex& cv, RDVertex& v,
                                   DWORD dwClipMask);
    inline BOOL UseGuardBand() { return m_bUseGB; }
    RDCLIPCODE ComputeClipCodes(RDCLIPCODE* pclipIntersection,
                                RDCLIPCODE* pclipUnion, FLOAT x_clip,
                                FLOAT y_clip, FLOAT z_clip, FLOAT w_clip);
    void ComputeClipCodesTL( RDVertex* pVtx );
    void Interpolate( RDClipVertex *out, RDClipVertex *p1, RDClipVertex *p2,
                      int code, D3DVALUE num, D3DVALUE denom );
    int ClipByPlane( RDClipVertex **inv, RDClipVertex **outv, RDVECTOR4 *plane,
                     DWORD dwClipFlag, int count );
    int ClipLineByPlane( RDCLIPTRIANGLE *line, RDVECTOR4 *plane,
                         DWORD dwClipBit);
    void ComputeScreenCoordinates( RDClipVertex **inv, int count );
    DWORD ComputeClipCodeGB( RDClipVertex *p );
    DWORD ComputeClipCode( RDClipVertex *p );
#if 0
    DWORD ComputeClipCodeUserPlanes( RDUSERCLIPPLANE *UserPlanes,
                                     RDClipVertex *p);
#endif
    int ClipLeft( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipRight( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipTop( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipBottom( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipFront( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipBack( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipLeftGB( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipRightGB( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipTopGB( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipBottomGB( RDClipVertex **inv, RDClipVertex **outv, int count);

    int ClipLineLeft( RDCLIPTRIANGLE *inv);
    int ClipLineRight( RDCLIPTRIANGLE *inv);
    int ClipLineTop( RDCLIPTRIANGLE *inv);
    int ClipLineBottom( RDCLIPTRIANGLE *inv);
    int ClipLineFront( RDCLIPTRIANGLE *inv);
    int ClipLineBack( RDCLIPTRIANGLE *inv);
    int ClipLineLeftGB( RDCLIPTRIANGLE *inv);
    int ClipLineRightGB( RDCLIPTRIANGLE *inv);
    int ClipLineTopGB( RDCLIPTRIANGLE *inv);
    int ClipLineBottomGB( RDCLIPTRIANGLE *inv);

    int ClipSingleLine( RDCLIPTRIANGLE *line );
    int ClipSingleTriangle( RDCLIPTRIANGLE *tri,
                            RDClipVertex ***clipVertexPointer );

    void DrawPoint( RDVertex* pvV0 );
    void DrawLine( RDVertex* pvV0, RDVertex* pvV1 );
    void DrawTriangle( RDVertex* pvV0, RDVertex* pvV1, RDVertex* pvV2,
                       WORD wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE );

    HRESULT DrawOnePrimitive( GArrayT<RDVertex>& VtxArray,
                              DWORD dwStartVertex,
                              D3DPRIMITIVETYPE PrimType,
                              UINT cVertices );
    HRESULT DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                     int StartVertexIndex,
                                     LPWORD pIndices,
                                     DWORD StartIndex,
                                     UINT  cIndices,
                                     D3DPRIMITIVETYPE PrimType );
    HRESULT DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                     int StartVertexIndex,
                                     LPDWORD pIndices,
                                     DWORD StartIndex,
                                     UINT  cIndices,
                                     D3DPRIMITIVETYPE PrimType );

};


// RefVP::m_dwTLState flags
#define RDPV_DOLIGHTING                0x00000001
#define RDPV_DOCLIPPING                0x00000002
#define RDPV_DOFOG                     0x00000004
#define RDPV_DOSPECULAR                0x00000008
#define RDPV_RANGEFOG                  0x00000010
#define RDPV_NORMALIZENORMALS          0x00000020
#define RDPV_LOCALVIEWER               0x00000040
#define RDPV_DOCOMPUTEPOINTSIZE        0x00000080
#define RDPV_DOPOINTSCALE              0x00000100
#define RDPV_DOTEXXFORM                0x00000200
#define RDPV_DOTEXGEN                  0x00000400
#define RDPV_NEEDEYEXYZ                0x00000800
#define RDPV_NEEDEYENORMAL             0x00001000

// ColorVertexFlags
#define RDPV_VERTEXDIFFUSENEEDED       0x00002000
#define RDPV_VERTEXSPECULARNEEDED      0x00004000
#define RDPV_COLORVERTEXAMB            0x00008000
#define RDPV_COLORVERTEXDIFF           0x00010000
#define RDPV_COLORVERTEXSPEC           0x00020000
#define RDPV_COLORVERTEXEMIS           0x00040000
#define RDPV_COLORVERTEXFLAGS     (RDPV_VERTEXDIFFUSENEEDED       | \
                                   RDPV_VERTEXSPECULARNEEDED      | \
                                   RDPV_COLORVERTEXAMB            | \
                                   RDPV_COLORVERTEXDIFF           | \
                                   RDPV_COLORVERTEXSPEC           | \
                                   RDPV_COLORVERTEXEMIS )
#define RDPV_DOINDEXEDVERTEXBLEND      0x00100000
#define RDPV_DOPOSITIONTWEENING        0x00200000
#define RDPV_DONORMALTWEENING          0x00400000


// RefVP::m_dwDirtyFlags flags
#define RDPV_DIRTY_PROJXFM     0x00000001
#define RDPV_DIRTY_VIEWXFM     0x00000002
#define RDPV_DIRTY_WORLDXFM    0x00000004
#define RDPV_DIRTY_WORLD1XFM   0x00000008
#define RDPV_DIRTY_WORLD2XFM   0x00000010
#define RDPV_DIRTY_WORLD3XFM   0x00000020
#define RDPV_DIRTY_XFORM       (RDPV_DIRTY_PROJXFM   | \
                                RDPV_DIRTY_VIEWXFM   | \
                                RDPV_DIRTY_WORLDXFM  | \
                                RDPV_DIRTY_WORLD1XFM | \
                                RDPV_DIRTY_WORLD2XFM | \
                                RDPV_DIRTY_WORLD3XFM)
#define RDPV_DIRTY_MATERIAL        0x00000100
#define RDPV_DIRTY_SETLIGHT        0x00000200
#define RDPV_DIRTY_NEEDXFMLIGHT    0x00000400
#define RDPV_DIRTY_COLORVTX        0x00000800
#define RDPV_DIRTY_LIGHTING    (RDPV_DIRTY_MATERIAL     | \
                                RDPV_DIRTY_SETLIGHT     | \
                                RDPV_DIRTY_NEEDXFMLIGHT | \
                                RDPV_DIRTY_COLORVTX)
#define RDPV_DIRTY_FOG              0x00010000
#define RDPV_DIRTY_INVERSEWORLDVIEW 0x00020000

//---------------------------------------------------------------------
// RDPTRSTRIDE: A class instanced once per vertex element.
//---------------------------------------------------------------------
    class RDPTRSTRIDE
    {
    public:
        RDPTRSTRIDE()
        {
            Null();
        }
        inline void Init( LPVOID pData, DWORD dwStride )
        {
            m_pData = m_pCurrent = pData;
            m_dwStride = dwStride;
        }
        inline void Null()
        {
            memset( this, 0, sizeof( *this ) );
        }
        inline void SetStride( DWORD dwStride )
        {
            m_dwStride = dwStride;
        }
        inline DWORD GetStride()
        {
            return m_dwStride;
        }
        inline LPVOID GetFirst()
        {
            return m_pData;
        }
        inline LPVOID GetCurrent()
        {
            return m_pCurrent;
        }
        inline LPVOID Reset()
        {
            return (m_pCurrent = m_pData);
        }
        inline LPVOID Next()
        {
            m_pCurrent = (LPVOID)((LPBYTE)m_pCurrent + m_dwStride);
            return m_pCurrent;
        }

        LPVOID operator []( DWORD dwIndex ) const
        {
            return (LPVOID)((LPBYTE)m_pData + dwIndex*m_dwStride);
        }


    protected:
        LPVOID m_pData;
        DWORD  m_dwStride; // in number of bytes
        LPVOID m_pCurrent;
        DWORD m_dwCurrentIndex;
    };

//---------------------------------------------------------------------
// Struct holding the shader ptr
//---------------------------------------------------------------------
struct RDVShaderHandle
{
    RDVShaderHandle()
    {
        m_pShader = NULL;
#if DBG
        m_tag = 0;
#endif
    }
    RDVShader* m_pShader;
#if DBG
    // Non zero means that it has been allocated
    DWORD      m_tag;
#endif
};


//---------------------------------------------------------------------
// Fixed function vertex processing pipeline object
//---------------------------------------------------------------------
class RefVP : public RDAlloc
{
protected:

    // The pointer to the driver object to obtain state
    RefDev* m_pDev;

    //-------------------------------------------------------------------------
    // Unprocessed state set by the DDI
    //-------------------------------------------------------------------------
    // Growable Light array
    GArrayT<RDLight>  m_LightArray;

    // Current material to use for lighting
    D3DMATERIAL7 m_Material;

    // Transformation state stored by the reference implementation
    RDMATRIX      m_xfmProj;
    RDMATRIX      m_xfmView;
    RDMATRIX      m_xfmWorld[RD_MAX_WORLD_MATRICES];
    RDMATRIX      m_xfmTex[D3DHAL_TSS_MAXSTAGES];

    //-------------------------------------------------------------------------
    // Vertex Elements
    //-------------------------------------------------------------------------
    RDPTRSTRIDE m_position;
    RDPTRSTRIDE m_position2;
    RDPTRSTRIDE m_blendweights;
    RDPTRSTRIDE m_blendindices;
    RDPTRSTRIDE m_normal;
    RDPTRSTRIDE m_normal2;
    RDPTRSTRIDE m_specular;
    RDPTRSTRIDE m_diffuse;
    RDPTRSTRIDE m_pointsize;
    RDPTRSTRIDE m_tex[8];

    //-------------------------------------------------------------------------
    // Cached T&L related render-state info
    //-------------------------------------------------------------------------
    DWORD m_dwTLState;           // RenderState related flags
    DWORD m_dwDirtyFlags;        // Dirty flags

    //-------------------------------------------------------------------------
    // Transformation data
    //-------------------------------------------------------------------------

    // Current transformation matrix
    RDMATRIX m_xfmCurrent[RD_MAX_WORLD_MATRICES];  // using WORLDi matrix
    RDMATRIX m_xfmToEye[RD_MAX_WORLD_MATRICES];    // Transforms to camera
    // space (Mworld*Mview)
    RDMATRIX m_xfmToEyeInv[RD_MAX_WORLD_MATRICES]; // and its Inverse
    BYTE m_WorldProcessed[RD_MAX_WORLD_MATRICES];

    UINT64  m_qwFVFIn;              // FVF of the input vertices
    UINT64  m_qwFVFOut;             // FVF of the output vertices

    int     m_numVertexBlends;
    RDTRANSFORMDATA m_TransformData;

    FLOAT m_fPointSize;
    FLOAT m_fPointAttA;
    FLOAT m_fPointAttB;
    FLOAT m_fPointAttC;
    FLOAT m_fPointSizeMin;
    FLOAT m_fPointSizeMax;

    FLOAT m_fTweenFactor;

    //-------------------------------------------------------------------------
    // Lighting data
    //-------------------------------------------------------------------------
    RDLIGHTVERTEX_FUNC_TABLE    m_LightVertexTable;
    RDLIGHTINGDATA              m_lighting;   // Lighting state

    DWORD m_dwNumActiveTextureStages;

    ///////////////////////////////////////////////////////////////////////////
    // Methods
    ///////////////////////////////////////////////////////////////////////////

    HRESULT UpdateXformData();
    void UpdateWorld( DWORD i );
    HRESULT UpdateLightingData();
    HRESULT UpdateFogData();
    RDCLIPCODE ProcessVertices( UINT64 outFVF, GArrayT<RDVertex>& VtxArray,
                                DWORD count );
    void LightVertex( RDLIGHTINGELEMENT *le );
    void FogVertex  ( RDVertex& Vout, RDVECTOR3 &v, RDLIGHTINGELEMENT *le,
                      int numVertexBlends, float *pBlendFactors,
                      BOOL bVertexInEyeSpace );

public:
    RefVP();

    inline void LightEnable( DWORD dwIndex, BOOL bEnable )
    {
        if( bEnable )
        {
            m_LightArray[dwIndex].Enable(&m_lighting.pActiveLights);
            m_dwDirtyFlags |= RDPV_DIRTY_SETLIGHT;
        }
        else
        {
            m_LightArray[dwIndex].Disable(&m_lighting.pActiveLights);
        }
    }

    inline HRESULT SetLightData( DWORD dwIndex, D3DLIGHT7* pData )
    {
        HRESULT hr = S_OK;
        HR_RET(m_LightArray[dwIndex].SetLight(pData));
        m_dwDirtyFlags |= RDPV_DIRTY_SETLIGHT;
        return S_OK;
    }
    HRESULT GrowLightArray( DWORD dwIndex );
    friend class RefDev;
};

// Vertex Lighting functions
void RDLV_Directional( RDLIGHTINGDATA&, D3DLIGHT7 *, RDLIGHTI *,
                       RDLIGHTINGELEMENT *, DWORD, UINT64 );
void RDLV_PointAndSpot( RDLIGHTINGDATA&, D3DLIGHT7 *, RDLIGHTI *,
                        RDLIGHTINGELEMENT *, DWORD, UINT64 );


///////////////////////////////////////////////////////////////////////////////
#endif // _REFTNL_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\inc\vshader.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   vshader.h
 *  Content:    Direct3D Vertex Shader header
 *
 *
 ***************************************************************************/
#ifndef _VSHADER_H
#define _VSHADER_H

//---------------------------------------------------------------------
// Forward defines
//---------------------------------------------------------------------
class RDVShaderCode;

//---------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------
// Register sets
const DWORD RD_MAX_NUMINPUTREG = 16;
const DWORD RD_MAX_NUMTMPREG   = 12;
const DWORD RD_MAX_NUMCONSTREG = 96;
const DWORD RD_MAX_NUMADDRREG  = 1;
const DWORD RD_MAX_NUMCOLREG   = 2;
const DWORD RD_MAX_NUMTEXREG   = 8;

// The version of the Vertex shader supported in Reference Device.
const DWORD RDVS_CODEMAJORVERSION  = 1;
const DWORD RDVS_CODEMINORVERSION  = 0;
const DWORD RDVS_CODEVERSIONTOKEN  = D3DPS_VERSION( RDVS_CODEMAJORVERSION,
                                                    RDVS_CODEMINORVERSION );

//---------------------------------------------------------------------
//
// RDVVMREG: Register set of the Reference Rasterizer Vertex
//           virtual machine.
//
//---------------------------------------------------------------------
struct RDVVMREG
{
    RDVECTOR4 m_i[RD_MAX_NUMINPUTREG];
    RDVECTOR4 m_t[RD_MAX_NUMTMPREG];
    RDVECTOR4 m_c[RD_MAX_NUMCONSTREG];
    RDVECTOR4 m_a[RD_MAX_NUMADDRREG];

    // Output registers
    RDVECTOR4 m_out[3];
    RDVECTOR4 m_col[RD_MAX_NUMCOLREG];
    RDVECTOR4 m_tex[RD_MAX_NUMTEXREG];
};

//-----------------------------------------------------------------------------
//
// RefVM
//      Vertex Virtual Machine object
//
//-----------------------------------------------------------------------------
class RefDev;
class RefVM
{
public:
    RefVM() { memset( this, 0, sizeof( this ) ); }
    ~RefVM(){};
    RDVVMREG* GetRegisters(){ return &m_reg; }

    // Parses binary shader representation, compiles is and returns
    // compiled object
    RDVShaderCode* CompileCode( DWORD dwSize, LPDWORD pBits );
    HRESULT SetActiveShaderCode( RDVShaderCode* pCode )
    { m_pCurrentShaderCode = pCode; return S_OK; }
    RDVShaderCode* GetActiveShaderCode() {return m_pCurrentShaderCode;}
    HRESULT ExecuteShader(RefDev* pRD);
    // HRESULT GetDataPointer(DWORD dwMemType, VVM_WORD ** pData);
    // Set internal registers to user data
    HRESULT SetData(DWORD RegType, DWORD start, DWORD count, LPVOID buffer);
    // Get data from internal registers
    HRESULT GetData(DWORD RegType, DWORD start, DWORD count, LPVOID buffer);
    inline RDVECTOR4* GetDataAddr( DWORD dwRegType, DWORD dwElementIndex );
    inline UINT GetCurrentInstIndex( void ) { return m_CurInstIndex; }

protected:
    inline void InstMov();
    inline void InstAdd();
    inline void InstMad();
    inline void InstMul();
    inline void InstRcp();
    inline void InstRsq();
    inline void InstDP3();
    inline void InstDP4();
    inline void InstMin();
    inline void InstMax();
    inline void InstSlt();
    inline void InstSge();
    inline void InstExp();
    inline void InstLog();
    inline void InstExpP();
    inline void InstLogP();
    inline void InstLit();
    inline void InstDst();
    inline void InstFrc();
    inline void InstM4x4();
    inline void InstM4x3();
    inline void InstM3x4();
    inline void InstM3x3();
    inline void InstM3x2();
    inline void WriteResult();
    inline HRESULT SetDestReg();
    inline HRESULT SetSrcReg( DWORD index );
    inline HRESULT SetSrcReg( DWORD index, DWORD count );

    RDVVMREG        m_reg;                  // Virtual machine reg set
    RDVShaderCode*  m_pCurrentShaderCode;   // Current shader

    DWORD*          m_pCurToken;        // Current token during parsing
    DWORD           m_dwRegOffset;      // Offset in the register file for
                                        // destination operand
    DWORD           m_WriteMask;        // Write mask for destination operand
    UINT            m_CurInstIndex;     // Current instruction index

    RDVECTOR4*      m_pDest;            // Pointer to destination operand
    RDVECTOR4       m_Source[5];        // Source operands
    RDVECTOR4       m_TmpReg;           // Temporary register for the first

    // The pointer to the driver object to obtain state
    RefDev* m_pDev;
    friend class RefDev;
};

#endif //_VSHADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\link\sources.inc ===
MAJORCOMP=d3d
MINORCOMP=d3d8
TARGETNAME=d3dref8
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLDEF=..\$(TARGETNAME).def

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

!if "$(BUILD_MSREF)" != ""

REFLIBPATH = $(SDK_LIB_PATH)
DDRAWLIB = ddrawp

!else

REFLIBPATH = $(DDK_LIB_PATH)
DDRAWLIB = ddraw

!endif

TARGETLIBS = \
        $(REFLIBPATH)\user32.lib   \
        $(REFLIBPATH)\advapi32.lib \
        $(REFLIBPATH)\uuid.lib     \
        $(REFLIBPATH)\winmm.lib     \
        $(REFLIBPATH)\kernel32.lib

LINKLIBS = \
        ..\..\drv\$(PLAT_DIR)\$(_OBJ_DIR)\*\refdrv.lib    \
        ..\..\common\$(PLAT_DIR)\$(_OBJ_DIR)\*\refcomm.lib  \
        ..\..\rast\$(PLAT_DIR)\$(_OBJ_DIR)\*\refrast.lib  \
        ..\..\tnl\$(PLAT_DIR)\$(_OBJ_DIR)\*\reftnl.lib    \
        ..\..\hop\$(PLAT_DIR)\$(_OBJ_DIR)\*\refhop.lib

DLLENTRY = _DllMainCRTStartup

SOURCES = \
    ..\d3dref8.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\inc\templarr.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// temparr.hpp
//
// Template class used by Direct3D RefDev for stateset and so on.
//
// The following error codes should be defined before included this file:
// DDERR_OUTOFMEMORY
// D3D_OK
// DDERR_INVALIDPARAMS
///////////////////////////////////////////////////////////////////////////////
#ifndef  _TEMPLARR_HPP
#define  _TEMPLARR_HPP


//--------------------------------------------------------------------------
//
// Template for growable arrays
//
//--------------------------------------------------------------------------


template <class ARRAY_ELEMENT>
class GArrayT
{
public:
    GArrayT()
    {
        m_pArray = NULL;
        m_dwArraySize = 0;
        m_dwGrowSize = 8;
    }

    ~GArrayT()
    {
        char tmp[256];
        wsprintf( tmp, "m_dwArraySize = %d, m_pArray = %08x\n", m_dwArraySize,
                  m_pArray );
        _ASSERT( !((m_dwArraySize == 0)^(m_pArray == NULL)), tmp );
        if( m_pArray ) delete[] m_pArray;
    }

    virtual void SetGrowSize( DWORD dwGrowSize)
    {
         m_dwGrowSize = dwGrowSize;
    }

    virtual HRESULT Grow( DWORD dwIndex )
    {
        if( dwIndex < m_dwArraySize ) return S_OK;
        DWORD dwNewArraySize = (dwIndex/m_dwGrowSize + 1) * m_dwGrowSize;
        ARRAY_ELEMENT *pNewArray = AllocArray( dwNewArraySize );
        if( pNewArray == NULL ) return DDERR_OUTOFMEMORY;

        for( DWORD i = 0; i<m_dwArraySize; i++ )
            pNewArray[i] = m_pArray[i];

        delete[] m_pArray;
        m_pArray = pNewArray;
        m_dwArraySize = dwNewArraySize;
        return S_OK;
    }

    virtual HRESULT Grow( DWORD dwIndex, BOOL* pRealloc )
    {
        if( dwIndex < m_dwArraySize ) 
        {
            if( pRealloc ) *pRealloc = FALSE;
            return S_OK;
        }
        if( pRealloc ) *pRealloc = TRUE;
        
        DWORD dwNewArraySize = m_dwArraySize;
        while( dwNewArraySize <= dwIndex ) dwNewArraySize += m_dwGrowSize;
        ARRAY_ELEMENT *pNewArray = AllocArray( dwNewArraySize );
        if( pNewArray == NULL ) return DDERR_OUTOFMEMORY;

        for( DWORD i = 0; i<m_dwArraySize; i++ )
            pNewArray[i] = m_pArray[i];

        delete[] m_pArray;
        m_pArray = pNewArray;
        m_dwArraySize = dwNewArraySize;
        return S_OK;
    }

    virtual ARRAY_ELEMENT *AllocArray( DWORD dwSize ) const
    {
        return new ARRAY_ELEMENT[dwSize];
    }

    virtual ARRAY_ELEMENT& operator []( DWORD dwIndex ) const
    {
        char tmp[256];
        wsprintf( tmp, "dwIndex = %d, m_dwArraySize = %d\n", dwIndex, 
                  m_dwArraySize );
        _ASSERT(dwIndex < m_dwArraySize, tmp);
        return m_pArray[dwIndex];
    }

    virtual BOOL IsValidIndex( DWORD dwIndex ) const
    {
        return (dwIndex < m_dwArraySize);
    }

    virtual DWORD GetSize() const
    {
        return m_dwArraySize;
    }

    virtual DWORD GetGrowSize() const
    {
        return m_dwGrowSize;
    }

protected:
    ARRAY_ELEMENT *m_pArray;
    DWORD          m_dwArraySize;
    DWORD          m_dwGrowSize;
};

//--------------------------------------------------------------------------
//
// A more powerful template for a growable array
//
//--------------------------------------------------------------------------

template <class T> class TemplArray
{
public:
    TemplArray( void );
    ~TemplArray( void );

    // It is the user of this operator who makes sure 0<=iIndex<m_dwArraySize.
    T& operator []( int iIndex );

    HRESULT CheckAndGrow( DWORD iIndex, DWORD dwGrowDelta = 16 );
    HRESULT CheckRange ( DWORD iIndex );

    // The user needs to make sure 0<=m_dwCurrent<m_dwArraySize.
    inline T CurrentItem(void) { return m_pArray[m_dwCurrent];};
    inline void SetCurrentItem(T item) { m_pArray[m_dwCurrent] = item;};
    inline DWORD CurrentIndex(void) { return m_dwCurrent;};
    inline void SetCurrentIndex(DWORD dwIdx) {m_dwCurrent = dwIdx;};

    inline DWORD ArraySize(void) { return m_dwArraySize;};

private:
    T *m_pArray;
    DWORD m_dwArraySize;
    // Index to the current item or the size of data stored in the array
    DWORD m_dwCurrent;
};


template <class T>
TemplArray< T >::TemplArray( void )
{
    m_pArray = NULL;
    m_dwArraySize = 0;
    m_dwCurrent = 0;
}

template <class T>
TemplArray< T >::~TemplArray( void )
{
    if (m_pArray != NULL)
        delete m_pArray;
    m_dwArraySize = 0;
}

template <class T> T&
TemplArray< T >::operator[]( int iIndex )
{
    return m_pArray[iIndex];
}

template <class T> HRESULT
TemplArray< T >::CheckAndGrow( DWORD iIndex, DWORD dwGrowDelta )
{
    if (iIndex >= m_dwArraySize)
    {
        DWORD dwNewArraySize = m_dwArraySize + dwGrowDelta;
        while (iIndex >= dwNewArraySize)
            dwNewArraySize += dwGrowDelta;

        T *pTmpArray = new T[dwNewArraySize];
        if (pTmpArray == NULL)
            return DDERR_OUTOFMEMORY;
        memset(pTmpArray, 0, sizeof(T) * dwNewArraySize);

        if (m_pArray != NULL)
        {
            _ASSERT(m_dwArraySize != 0,
                    "CheckAndGrow: Array size cannot be NULL" );

            // Copy existing stuff into new array
            memcpy(pTmpArray, m_pArray, m_dwArraySize * sizeof(T));

            // Free up existing array
            delete [] m_pArray;
        }


        // Assign new array
        m_pArray = pTmpArray;
        m_dwArraySize = dwNewArraySize;
    }
    return D3D_OK;
}

template <class T> HRESULT
TemplArray< T >::CheckRange( DWORD iIndex )
{
    if (iIndex >= m_dwArraySize)
    {
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

#endif _TEMPLARR_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\ctexfilt.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// ctexfilt.cpp
//
// Direct3D Reference Device - Cube Texture Map Filtering
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void
RefRast::ComputeCubeTextureFilter( int iStage, FLOAT fCrd[] )
{
#define POS_NX 1
#define POS_NY 2
#define POS_NZ 3
#define NEG_NORM 4
#define NEG_NX (NEG_NORM | POS_NX)
#define NEG_NY (NEG_NORM | POS_NY)
#define NEG_NZ (NEG_NORM | POS_NZ)

    // determine which map face the texture coordinate normal is facing
    UINT uMap;
    if ( fabs(fCrd[0]) > fabs(fCrd[1]) )
    {
        if ( fabs(fCrd[0]) > fabs(fCrd[2]) )
            uMap = POS_NX | ((fCrd[0] < 0.0) ? (NEG_NORM) : 0);
        else
            uMap = POS_NZ | ((fCrd[2] < 0.0) ? (NEG_NORM) : 0);
    }
    else
    {
        if ( fabs(fCrd[1]) > fabs(fCrd[2]) )
            uMap = POS_NY | ((fCrd[1] < 0.0) ? (NEG_NORM) : 0);
        else
            uMap = POS_NZ | ((fCrd[2] < 0.0) ? (NEG_NORM) : 0);
    }

    // munged texture coordinate and gradient info for cubemaps
    D3DCUBEMAP_FACES Face;  // face index (0..5) to which normal is (mostly) pointing
    FLOAT fMajor;           // coord in major direction
    FLOAT fMapCrd[2];       // coords into 2D map
    FLOAT fMajorGrad[2];    // dMajor/d(X,Y)
    FLOAT fMapGrad[2][2];   // d(U/Major,V/Major)/d(X,Y)

#define _MapFaceParams( _Face, _IM, _bFlipM, _IU, _bFlipU, _IV, _bFlipV ) \
{ \
    Face = D3DCUBEMAP_FACE_##_Face; \
    fMajor     = (_bFlipM) ? (-fCrd[_IM]) : ( fCrd[_IM]); \
    fMapCrd[0] = (_bFlipU) ? (-fCrd[_IU]) : ( fCrd[_IU]); \
    fMapCrd[1] = (_bFlipV) ? (-fCrd[_IV]) : ( fCrd[_IV]); \
    fMajorGrad[0]  = m_TexCvg[iStage].fGradients[_IM][0]; if (_bFlipM) fMajorGrad[0]  = -fMajorGrad[0]; \
    fMajorGrad[1]  = m_TexCvg[iStage].fGradients[_IM][1]; if (_bFlipM) fMajorGrad[1]  = -fMajorGrad[1]; \
    fMapGrad[0][0] = m_TexCvg[iStage].fGradients[_IU][0]; if (_bFlipU) fMapGrad[0][0] = -fMapGrad[0][0]; \
    fMapGrad[0][1] = m_TexCvg[iStage].fGradients[_IU][1]; if (_bFlipU) fMapGrad[0][1] = -fMapGrad[0][1]; \
    fMapGrad[1][0] = m_TexCvg[iStage].fGradients[_IV][0]; if (_bFlipV) fMapGrad[1][0] = -fMapGrad[1][0]; \
    fMapGrad[1][1] = m_TexCvg[iStage].fGradients[_IV][1]; if (_bFlipV) fMapGrad[1][1] = -fMapGrad[1][1]; \
}
    switch (uMap)
    {
    case POS_NX: _MapFaceParams( POSITIVE_X, 0,0, 2,1, 1,1 ); break;
    case POS_NY: _MapFaceParams( POSITIVE_Y, 1,0, 0,0, 2,0 ); break;
    case POS_NZ: _MapFaceParams( POSITIVE_Z, 2,0, 0,0, 1,1 ); break;
    case NEG_NX: _MapFaceParams( NEGATIVE_X, 0,1, 2,0, 1,1 ); break;
    case NEG_NY: _MapFaceParams( NEGATIVE_Y, 1,1, 0,0, 2,1 ); break;
    case NEG_NZ: _MapFaceParams( NEGATIVE_Z, 2,1, 0,1, 1,1 ); break;
    }

    // compute gradients prior to normalizing map coords
    FLOAT fInvMajor = 1.F/fMajor;
    if ( m_TexFlt[iStage].CvgFilter != D3DTEXF_NONE )
    {
        // Compute d(U/Major)/dx, d(U/Major)/dy, d(V/Major)/dx, d(V/Major)/dy.
        // 
        // i.e., for d(U/Major))/dx
        // Given: U' = unprojected U0 coord (fMapCrd[0])
        //        U0 = U'/Major (fMapCrd[0]/fMajor)
        //        U1 = (U' + dU'/dX)/(Major + dMajor/dX)
        //
        //        d(U/Major)/dx = U1 - U0
        //                      = (Major*(dU'/dX) - U'*(dMajor/dX)) / (Major * (Major + dMajor/dX))
        //        (Use FLT_MAX if denominator is zero)

        float fDenom; 
        fDenom = fMajor * (fMajor + fMajorGrad[0]);
        if( 0 == fDenom )
        {
            fMapGrad[0][0] = fMapGrad[1][0] = FLT_MAX;
        }
        else
        {
            fDenom = 1.F/fDenom;
            fMapGrad[0][0] = (fMajor*fMapGrad[0][0] - fMapCrd[0]*fMajorGrad[0])*fDenom;
            fMapGrad[1][0] = (fMajor*fMapGrad[1][0] - fMapCrd[1]*fMajorGrad[0])*fDenom;
        }

        fDenom = fMajor * (fMajor + fMajorGrad[1]);
        if( 0 == fDenom )
        {
            fMapGrad[0][1] = fMapGrad[1][1] = FLT_MAX;
        }
        else
        {
            fDenom = 1.F/fDenom;
            fMapGrad[0][1] = (fMajor*fMapGrad[0][1] - fMapCrd[0]*fMajorGrad[1])*fDenom;
            fMapGrad[1][1] = (fMajor*fMapGrad[1][1] - fMapCrd[1]*fMajorGrad[1])*fDenom;
        }
        // scale gradients to texture LOD 0 size; scale by .5F to match coord scale below
        fMapGrad[0][0] *= m_pRD->m_pTexture[iStage]->m_fTexels[0][0]*.5F;
        fMapGrad[0][1] *= m_pRD->m_pTexture[iStage]->m_fTexels[0][0]*.5F;
        fMapGrad[1][0] *= m_pRD->m_pTexture[iStage]->m_fTexels[0][1]*.5F;
        fMapGrad[1][1] *= m_pRD->m_pTexture[iStage]->m_fTexels[0][1]*.5F;

        ComputeCubeCoverage( fMapGrad, m_TexCvg[iStage].fLOD );
        ComputePerLODControls( iStage );
    }

    // normalize map coords (-1. to 1. range), then map to 0. to 1.
    fMapCrd[0] = (fMapCrd[0]*fInvMajor)*.5F + .5F;
    fMapCrd[1] = (fMapCrd[1]*fInvMajor)*.5F + .5F;

    int iL;
    D3DTEXTUREFILTERTYPE Filter =
        m_TexCvg[iStage].bMagnify ? m_TexFlt[iStage].MagFilter : m_TexFlt[iStage].MinFilter;
    switch ( Filter )
    {
    default:
    case D3DTEXF_POINT:
        for ( iL = 0; iL < m_TexCvg[iStage].cLOD; iL++ )
        {
            m_TexFlt[iStage].pSamples[iL].iLOD = Face + 6*m_TexCvg[iStage].iLODMap[iL];
            m_TexFlt[iStage].pSamples[iL].fWgt = m_TexCvg[iStage].fLODFrc[iL];
            ComputePointSampleCoords( iStage, m_TexFlt[iStage].pSamples[iL].iLOD,
                fMapCrd, m_TexFlt[iStage].pSamples[iL].iCrd );
            m_TexFlt[iStage].cSamples++;
        }
        break;

    case D3DTEXF_LINEAR:
        for ( iL = 0; iL < m_TexCvg[iStage].cLOD; iL++ )
        {

            if ( 0 == m_TexCvg[iStage].iLODMap[iL] )
            {
                // TODO: correct sampling position near edges on map 0
            }

            INT32 iCrdMap[2][2];
            FLOAT fCrdFrc[2][2];
            ComputeLinearSampleCoords(
                iStage, 6*m_TexCvg[iStage].iLODMap[iL]+Face, fMapCrd,
                iCrdMap[0], iCrdMap[1], fCrdFrc[0], fCrdFrc[1] );
            SetUpCubeMapLinearSample( iStage, Face,
                6*m_TexCvg[iStage].iLODMap[iL]+Face, m_TexCvg[iStage].fLODFrc[iL],
                iCrdMap, fCrdFrc );
        }
        break;
    }
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void
RefRast::SetUpCubeMapLinearSample(
    int iStage, D3DCUBEMAP_FACES Face,
    INT32 iLODMap, FLOAT fLODScale,
    INT32 (*iCrd)[2], FLOAT (*fFrc)[2] )
{
    int iC,iS;
    INT32 iCrdMax[2];
    iCrdMax[0] = m_pRD->m_pTexture[iStage]->m_cTexels[iLODMap][0] - 1;
    iCrdMax[1] = m_pRD->m_pTexture[iStage]->m_cTexels[iLODMap][1] - 1;

    // form flags indicating if sample coordinate is out in either direction
    UINT uOut[2][2] = { 0, 0, 0, 0, };
    for ( iC = 0; iC < 2; iC++ )
    {
        if ( iCrd[iC][0] < 0          )  uOut[iC][0] = 1;
        if ( iCrd[iC][0] > iCrdMax[0] )  uOut[iC][0] = 2;
        if ( iCrd[iC][1] < 0          )  uOut[iC][1] = 1;
        if ( iCrd[iC][1] > iCrdMax[1] )  uOut[iC][1] = 2;
    }

    // compute sample weights and per-sample out flags
    FLOAT fWgtS[4]; BOOL bOutS[4];
    for ( iS = 0; iS < 4; iS ++ )
    {
        fWgtS[iS] = fLODScale*fFrc[iS&1][0]*fFrc[iS>>1][1];
        bOutS[iS] = uOut[iS&1][0] || uOut[iS>>1][1];
    }

    // compute per-sample coords; discard samples which are off in corner;
    //  conditionally remap to adjacent face
    INT32 iCrdS[4][2];
    D3DCUBEMAP_FACES FaceS[4];
    for ( iS = 0; iS < 4; iS ++ )
    {
        iCrdS[iS][0] = iCrd[iS&1][0];
        iCrdS[iS][1] = iCrd[iS>>1][1];
        FaceS[iS] = Face;
        if ( uOut[iS&1][0] && uOut[iS>>1][1] )
        {
            // sample is out on both sides, so don't take this sample (set weight to
            // zero) and divide it's weight evenly between the two singly-out samples
            FLOAT fWgtDist = fWgtS[iS]*.5f;
            fWgtS[iS] = 0.f;
            for ( int iSp = 0; iSp < 4; iSp ++ )
            {
                if (iSp == iS) continue;
                if (bOutS[iSp]) fWgtS[iSp] += fWgtDist;   // will hit 2 of 4
            }
            continue;
        }
        if ( bOutS[iS] )
        {
            // sample is out on one side - remap coordinate only adjacent face
            DoCubeRemap( iCrdS[iS], iCrdMax, FaceS[iS], uOut[iS&1][0], uOut[iS>>1][1] );
        }
    }
    // form the samples
    TextureSample* pS = &m_TexFlt[iStage].pSamples[m_TexFlt[iStage].cSamples];
    for ( iS = 0; iS < 4; iS ++ )
    {
        pS->iLOD = iLODMap - Face + FaceS[iS];
        pS->fWgt = fWgtS[iS];
        pS->iCrd[0] = iCrdS[iS][0];
        pS->iCrd[1] = iCrdS[iS][1];
        pS++; m_TexFlt[iStage].cSamples++;
    }
}

//
// uCubeEdgeTable
//
// This table looks up how to map a given [0] and [1] that are out of range
// on their primary face.  The first (leftmost) index to the table is the current
// face.  The second index is 0 if [1] is in range, 1 if [1] is negative
// and 2 if [1] is larger than the texture.  Likewise, the last index is 0
// if [0] is in range, 1 if [0] is negative, and 2 if [0] is larger than
// than the texture.
//
// defines for the actions returned by the uCubeEdgeTable
//
#define CET_FACEMASK    0x0F    // new face
#define CET_0MASK       0x30    // coord [0] mask
#define CET_00          0x00    // new face [0] is old face  [0]
#define CET_0c0         0x10    // new face [0] is old face ~[0]
#define CET_01          0x20    // new face [0] is old face  [1]
#define CET_0c1         0x30    // new face [0] is old face ~[1]
#define CET_1MASK       0xC0    // coord [1] mask
#define CET_10          0x00    // new face [1] is old face  [0]
#define CET_1c0         0x40    // new face [1] is old face ~[0]
#define CET_11          0x80    // new face [1] is old face  [1]
#define CET_1c1         0xC0    // new face [1] is old face ~[1]
#define CET_INVALID     0xFF    // invalid entry (out on two sides)

#define _SetCET( _Face, _Crd0, _Crd1 ) (_Face)|(CET_0##_Crd0)|(CET_1##_Crd1)

static UINT CubeEdgeTable[6][3][3] = {
{
    { _SetCET( 0,  0,  1 ), _SetCET( 4, c0,  1 ), _SetCET( 5, c0,  1 ), },
    { _SetCET( 2, c1, c0 ),     CET_INVALID,          CET_INVALID,      },
    { _SetCET( 3,  1,  0 ),     CET_INVALID,          CET_INVALID,      },
},
{
    { _SetCET( 1,  0,  1 ), _SetCET( 5, c0,  1 ), _SetCET( 4, c0,  1 ), },
    { _SetCET( 2,  1,  0 ),     CET_INVALID,          CET_INVALID,      },
    { _SetCET( 3, c1, c0 ),     CET_INVALID,          CET_INVALID,      },
},
{
    { _SetCET( 2,  0,  1 ), _SetCET( 1,  1,  0 ), _SetCET( 0, c1, c0 ), },
    { _SetCET( 5,  c0, 1 ),     CET_INVALID,          CET_INVALID,      },
    { _SetCET( 4,  0, c1 ),     CET_INVALID,          CET_INVALID,      },
},
{
    { _SetCET( 3,  0,  1 ), _SetCET( 1, c1, c0 ), _SetCET( 0,  1,  0 ), },
    { _SetCET( 4,  0, c1 ),     CET_INVALID,          CET_INVALID,      },
    { _SetCET( 5,  c0, 1 ),     CET_INVALID,          CET_INVALID,      },
},
{
    { _SetCET( 4,  0,  1 ), _SetCET( 1, c0,  1 ), _SetCET( 0, c0,  1 ), },
    { _SetCET( 2,  0, c1 ),     CET_INVALID,          CET_INVALID,      },
    { _SetCET( 3,  0, c1 ),     CET_INVALID,          CET_INVALID,      },
},
{
    { _SetCET( 5,  0,  1 ), _SetCET( 0, c0,  1 ), _SetCET( 1, c0,  1 ), },
    { _SetCET( 2, c0,  1 ),     CET_INVALID,          CET_INVALID,      },
    { _SetCET( 3, c0,  1 ),     CET_INVALID,          CET_INVALID,      },
},
};

//-----------------------------------------------------------------------------
//
// DoCubeRemap - Interprets the edge table and munges coords and face.
//
//-----------------------------------------------------------------------------
void
DoCubeRemap(
    INT32 iCrd[], INT32 iCrdMax[],
    D3DCUBEMAP_FACES& Face, UINT uOut0, UINT uOut1)
{
    UINT Table = CubeEdgeTable[Face][uOut1][uOut0];
    _ASSERT( Table != CET_INVALID, "Illegal cube map lookup" );
    INT32 iCrdIn[2];
    iCrdIn[0] = iCrd[0];
    iCrdIn[1] = iCrd[1];
    switch ( Table & CET_0MASK )
    {
    default:
    case CET_00:  iCrd[0] =            iCrdIn[0]; break;
    case CET_0c0: iCrd[0] = iCrdMax[0]-iCrdIn[0]; break;
    case CET_01:  iCrd[0] =            iCrdIn[1]; break;
    case CET_0c1: iCrd[0] = iCrdMax[1]-iCrdIn[1]; break;
    }
    switch ( Table & CET_1MASK )
    {
    default:
    case CET_10:  iCrd[1] =            iCrdIn[0]; break;
    case CET_1c0: iCrd[1] = iCrdMax[0]-iCrdIn[0]; break;
    case CET_11:  iCrd[1] =            iCrdIn[1]; break;
    case CET_1c1: iCrd[1] = iCrdMax[1]-iCrdIn[1]; break;
    }
    Face = (D3DCUBEMAP_FACES)(Table & CET_FACEMASK);
}

//-----------------------------------------------------------------------------
//
// Computes level of detail for cube mapping, looks better if
// we err on the side of fuzziness.
//
//-----------------------------------------------------------------------------
void
ComputeCubeCoverage( const FLOAT (*fGradients)[2], FLOAT& fLOD )
{
    // compute length of coverage in U and V axis
    FLOAT fLenX = RR_LENGTH( fGradients[0][0], fGradients[1][0] );
    FLOAT fLenY = RR_LENGTH( fGradients[0][1], fGradients[1][1] );

    FLOAT fCoverage;
#if 0
    // take average since one length can be pathologically small
    // for large areas of triangles when cube mapping
    fCoverage = (fLenX+fLenY)/2;
#else
    // use the MAX of the lengths
    fCoverage = MAX(fLenX,fLenY);
#endif

    // take log2 of coverage for LOD
    fLOD = RR_LOG2(fCoverage);
}


///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\inc\vstream.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   vstream.h
 *  Content:    Direct3D Vertex Streams header
 *
 *
 ***************************************************************************/
#ifndef _VSTREAM_H
#define _VSTREAM_H

//---------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------
const DWORD RD_MAX_NUMELEMENTS = 16;
const DWORD RD_MAX_NUMSTREAMS  = RD_MAX_NUMELEMENTS;
const DWORD RDVSD_STREAMTESS = RD_MAX_NUMSTREAMS;
const DWORD RD_MAX_SHADERINSTSTRING = 128;
const DWORD RD_MAX_SHADERTOKENSPERINST = 32;

//---------------------------------------------------------------------
// macros for parsing Declaration Token Array

// TRUE, if shader handle is DX7 FVF code
//---------------------------------------------------------------------
#define RDVSD_ISLEGACY(ShaderHandle) !(ShaderHandle & D3DFVF_RESERVED0)

enum RDVSD_DATALOAD
{
    RDVSD_LOADREGISTER = 0,
    RDVSD_SKIP
};

#define RDVSD_GETTOKENTYPE(token)           \
    ((token & D3DVSD_TOKENTYPEMASK) >> D3DVSD_TOKENTYPESHIFT)
#define RDVSD_ISSTREAMTESS(token)           \
    ((token & D3DVSD_STREAMTESSMASK) >> D3DVSD_STREAMTESSSHIFT)
#define RDVSD_GETDATALOADTYPE(token)        \
    ((token & D3DVSD_DATALOADTYPEMASK) >> D3DVSD_DATALOADTYPESHIFT)
#define RDVSD_GETDATATYPE(token)            \
    ((token & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT)
#define RDVSD_GETSKIPCOUNT(token)           \
    ((token & D3DVSD_SKIPCOUNTMASK) >> D3DVSD_SKIPCOUNTSHIFT)
#define RDVSD_GETSTREAMNUMBER(token)        \
    ((token & D3DVSD_STREAMNUMBERMASK) >> D3DVSD_STREAMNUMBERSHIFT)
#define RDVSD_GETVERTEXREG(token)           \
    ((token & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT)
#define RDVSD_GETVERTEXREGIN(token)         \
    ((token & D3DVSD_VERTEXREGINMASK) >> D3DVSD_VERTEXREGINSHIFT)
#define RDVSD_GETCONSTCOUNT(token)          \
    ((token & D3DVSD_CONSTCOUNTMASK) >> D3DVSD_CONSTCOUNTSHIFT)
#define RDVSD_GETCONSTADDRESS(token)        \
    ((token & D3DVSD_CONSTADDRESSMASK) >> D3DVSD_CONSTADDRESSSHIFT)
#define RDVSD_GETCONSTRS(token)             \
    ((token & D3DVSD_CONSTRSMASK) >> D3DVSD_CONSTRSSHIFT)
#define RDVSD_GETEXTCOUNT(token)            \
    ((token & D3DVSD_EXTCOUNTMASK) >> D3DVSD_EXTCOUNTSHIFT)
#define RDVSD_GETEXTINFO(token)             \
    ((token & D3DVSD_EXTINFOMASK) >> D3DVSD_EXTINFOSHIFT)

//---------------------------------------------------------------------
//
// RDVElement: Describes a vertex element
//
//---------------------------------------------------------------------

// Function pointer that copies a vertex element into the 4-float vector.
typedef void (*PFN_RDCOPYELEMENT)(LPVOID pInputStream,
                                  RDVECTOR4* pVertexRegister);

class RDVElement
{
public:
    RDVElement()
    {
        memset( this, 0, sizeof( RDVElement ) );
    }

    // Pointer to a function to convert input vertex element data type to
    // the RDVECTOR4
    PFN_RDCOPYELEMENT  m_pfnCopy;
    DWORD   m_dwToken;       // The token that described this vertex element.
    DWORD   m_dwRegister;    // Input register index
    DWORD   m_dwDataType;    // Data type and dimension
    DWORD   m_dwStreamIndex; // API stream index
    DWORD   m_dwOffset;      // Offset in the input stream in bytes

    //
    // Tesselator support
    //
    BOOL    m_bIsTessGen;     // Is this vertex element generated by
                              // tesselator
    DWORD   m_dwRegisterIn;   // Tesselator Input register index
    DWORD   m_dwStreamIndexIn;// API stream index for m_dwRegisterIn
    DWORD   m_dwOffsetIn;     // Offset for m_dwRegisterIn in bytes

};

//---------------------------------------------------------------------
//
// RDVConstantData: Constant data that is used by a shader
//
//---------------------------------------------------------------------
class RDVConstantData: public RDListEntry
{
public:
    RDVConstantData()     {m_pData = NULL; m_dwCount = 0;}
    ~RDVConstantData()    {delete m_pData;}

    DWORD   m_dwCount;          // Number of 4*DWORDs to load
    DWORD   m_dwAddress;        // Start constant register
    DWORD*  m_pData;            // Data. Multiple of 4*DWORD
};
//-----------------------------------------------------------------------------
//
//  RDVStream: Class representing the vertex stream.
//
//-----------------------------------------------------------------------------
class RDVStream
{
public:
    RDVStream()
    {
        m_pData = NULL;
        m_pSavedData = NULL;
        m_dwHandle = 0;
        m_dwNumVertices = 0;
        m_dwSize = 0;
    }

    // Stream memory.
    LPBYTE  m_pData;
    // Temporary pointer
    LPBYTE  m_pSavedData;
    // Vertex buffer handle
    DWORD                   m_dwHandle;
    // Vertex (or index) stride in bytes
    DWORD                   m_dwStride;
    // Max number of vertices (or indices in case of index buffer) the buffer
    // can store
    DWORD                   m_dwNumVertices;
    // Buffer size in bytes
    DWORD                   m_dwSize;
    // Output array for a tessellator
    GArrayT<BYTE>           m_TessOut;
};
//-----------------------------------------------------------------------------
//
//  RDIStream: Class representing the current Index stream
//
//-----------------------------------------------------------------------------
class RDIStream: public RDVStream
{
public:
    RDIStream()
    {
        m_dwFlags = 0;
    }
    DWORD   m_dwFlags;      // User passed flags
};
//---------------------------------------------------------------------
//
// RDVStreamDecl:
//
//      Describes a stream, used by a declaration
//
//---------------------------------------------------------------------
class RDVStreamDecl
{
public:
    RDVStreamDecl();

    // Parses declaration.
    // For fixed-function pipeline computes FVF and FVF2 (used to record
    // texture presence)
    HRESULT Parse(DWORD ** ppToken, BOOL bFixedFunction, BOOL bStreamTess,
                  UINT64* pqwFVF, UINT64* pqwFVF2, DWORD* pdwNumBetas);
    HRESULT MakeVElementArray( UINT64 qwFVF );
    RDVElement  m_Elements[RD_MAX_NUMELEMENTS];  // Vertex elements in the
                                                // stream.
    DWORD       m_dwNumElements;                // Number of elements to use
    DWORD       m_dwStride;                     // Vertex size in bytes
    DWORD       m_dwStreamIndex;                // Index to device streams
    BOOL        m_bIsStreamTess;                // Is it a tesselator stream ?
};
//---------------------------------------------------------------------
//
// RDVShaderInst:
//     The object representing each shader instruction.  Used for
//     debugging, since the reference implementation directly interprets
//     the raw token stream during vshader execution.
//-----------------------------------------------------------------------------
class RDVShaderInst
{
public:
    char    m_String[RD_MAX_SHADERINSTSTRING];
    DWORD   m_Tokens[RD_MAX_SHADERTOKENSPERINST];
    DWORD*  m_pComment;
    DWORD   m_CommentSize;
};
//---------------------------------------------------------------------
//
// RDVShaderCode:
//     The object representing the compiled shader code.
//     In the reference implementation, there is really no compiling
//     happening. The compile phase consists of:
//           1) Validating the the code.
//           2) Computing the output FVF.
//           3) Saving the original bits for later interpretation.
//    In the execution phase (in the RefVM) these saved bits are
//    interpreted.
//-----------------------------------------------------------------------------
class RDVShaderCode
{
public:
    RDVShaderCode() { memset( this, 0, sizeof( this ) ); }
    ~RDVShaderCode(){ delete m_pRawBits; if (m_pInst) delete m_pInst; }
    inline UINT GetInstructionCount( void ) { return m_InstCount; }

    LPDWORD      m_pRawBits;      // Raw code bits
    DWORD        m_dwSize;        // Number of DWORDs

    UINT         m_InstCount;     // Instruction count (for debug monitor)
    RDVShaderInst*   m_pInst;     // Instruction array (for debug monitor)

    // Output FVF for this shaders
    UINT64 m_qwFVFOut;
};
//---------------------------------------------------------------------
//
// RDVDeclaration:
//     The object representing the parsed and compiled declaration.
//-----------------------------------------------------------------------------
class RDVDeclaration
{
public:
    RDVDeclaration()
    {
        memset( this, 0, sizeof( RDVDeclaration ) );
    }
    ~RDVDeclaration();
    HRESULT Parse( DWORD * decl, BOOL bFixedFunction );
    HRESULT MakeVElementArray( UINT64 qwFVF );

    // List of streams, which are used by the declaration
    // The additional one is used for the Tesselator stream.
    RDVStreamDecl   m_StreamArray[RD_MAX_NUMSTREAMS + 1];

    // Number of active streams
    DWORD           m_dwNumActiveStreams;

    // Corresponding FVF for fixed-function pipeline
    // This is OR of all streams input FVF
    UINT64          m_qwInputFVF;

    // Constant data that should be loaded when shader becomes active
    RDVConstantData* m_pConstants;

    // The description of all vertex elements to be loaded into input
    // registers. The array is built by going through active streams and
    // elements inside each stream
    RDVElement       m_VertexElements[RD_MAX_NUMELEMENTS];

    // Number of used members of m_VertexElements
    DWORD           m_dwNumElements;

    // Stride computed for the implicit tesselator stream
    DWORD           m_dwStreamTessStride;
};
//-----------------------------------------------------------------------------
//
// RDVShader: Vertex Shader Class
//
//-----------------------------------------------------------------------------
class RDVShader
{
public:
    RDVShader();
    ~RDVShader();
    HRESULT Initialize(DWORD* lpdwDeclaration, DWORD* lpdwFunction);

    RDVDeclaration   m_Declaration;
    RDVShaderCode*   m_pCode;

    inline BOOL IsFixedFunction()
    {
        return (m_pCode == NULL);
    }
};
typedef RDVShader *PRDVSHADER;


#endif _VSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\pixproc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pixproc.cpp
//
// Direct3D Reference Device - Pixel Processor
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// WritePixel - Writes pixel and (maybe) depth to current render target.
//
//-----------------------------------------------------------------------------
void
RefRast::WritePixel(
    INT32 iX, INT32 iY, UINT Sample,
    const RDColor& Color, const RDDepth& Depth)
{
    m_pRD->m_pRenderTarget->WritePixelColor( iX, iY, Sample, Color,
        m_pRD->GetRS()[D3DRS_DITHERENABLE]);

    // don't write if Z buffering disabled or Z write disabled
    if ( !( m_pRD->GetRS()[D3DRS_ZENABLE     ] ) ||
         !( m_pRD->GetRS()[D3DRS_ZWRITEENABLE] ) ) { return; }

    m_pRD->m_pRenderTarget->WritePixelDepth( iX, iY, Sample, Depth );
}

//-----------------------------------------------------------------------------
//
// DoPixels - Invoked for each set of 2x2 pixels by the scan converter, applies
// texture, specular, fog, alpha blend, and writes result to surface.  Also
// implements depth, alpha, and stencil tests.
//
//-----------------------------------------------------------------------------
void
RefRast::DoPixels( void )
{
#if DBG
    for ( m_iPix = 0; m_iPix < 4; m_iPix++ )
    {
        if ( !m_bPixelIn[m_iPix] ) continue;
        if (m_pRD->m_pDbgMon) m_pRD->m_pDbgMon->NextEvent( D3DDM_EVENT_PIXEL );
    }
#endif

    // pixel shader executed for all 4 pixels of 2x2 grid at one time
    if (m_pCurrentPixelShader)
        ExecShader();

    for ( m_iPix = 0; m_iPix < 4; m_iPix++ )
    {
        if ( !m_bPixelIn[m_iPix] ) continue;
        if ( m_bPixelDiscard[m_iPix] ) continue;

        RDColor PixelColor;
        if ( !m_bLegacyPixelShade )
        {
            // pixel shader final color always left in temp register 0
            PixelColor = m_TempReg[0][m_iPix];
            // saturate before blend and FB access
            PixelColor.Clamp();
        }
        else
        {
            // apply legacy pixel shading (texture lookups already done by ExecShader)
            PixelColor = m_InputReg[0][m_iPix];
            RDColor PixelSpecular( m_InputReg[1][m_iPix] );
            RDColor LastStageColor( PixelColor );
            RDColor ResultColor( PixelColor );
            RDColor TempColor( (DWORD)0x0 );
            for ( int iStage=0; iStage<m_pRD->m_cActiveTextureStages; iStage++ )
            {

                if ( m_pRD->GetTSS(iStage)[D3DTSS_COLOROP] == D3DTOP_DISABLE )
                {
                    ResultColor = LastStageColor; // pass result of previous stage
                    break;
                }

                // no blend if texture bound to stage is bumpmap
                if ( ( m_pRD->GetTSS(iStage)[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAP ) ||
                     ( m_pRD->GetTSS(iStage)[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAPLUMINANCE ) )
                {
                    continue;
                }

                RDColor TextureColor( m_TextReg[iStage][m_iPix] );
                DoTextureBlendStage( iStage, PixelColor, PixelSpecular,
                    LastStageColor, TextureColor, TempColor, ResultColor );

                // set color for next stage
                LastStageColor = ResultColor;
            }
            PixelColor = ResultColor;

            // add specular and saturate
            if ( m_pRD->GetRS()[D3DRS_SPECULARENABLE] )
            {
                PixelColor.R += PixelSpecular.R;
                PixelColor.G += PixelSpecular.G;
                PixelColor.B += PixelSpecular.B;
                PixelColor.Saturate();
            }
        }

        // do alpha test - bail out if failed
        if ( m_pRD->GetRS()[D3DRS_ALPHATESTENABLE] &&
             !AlphaTest( PixelColor.A ) )
        {
            continue;
        }

        // apply fog
        if ( m_pRD->GetRS()[D3DRS_FOGENABLE] )
        {
            RDColor FogColor = m_pRD->GetRS()[D3DRS_FOGCOLOR];
            // (TODO: account for pre-multiplied alpha here??)
            FLOAT ObjColorFrac = m_FogIntensity[m_iPix];
            FLOAT FogColorFrac = 1.f - m_FogIntensity[m_iPix];
            PixelColor.R = (ObjColorFrac * PixelColor.R) + (FogColorFrac * FogColor.R);
            PixelColor.G = (ObjColorFrac * PixelColor.G) + (FogColorFrac * FogColor.G);
            PixelColor.B = (ObjColorFrac * PixelColor.B) + (FogColorFrac * FogColor.B);
        }

        //
        // remainder is done per-sample for multisample buffers
        //
        INT32 iX = m_iX[m_iPix];
        INT32 iY = m_iY[m_iPix];
        do
        {
            RDColor FinalPixelColor = PixelColor;
            UINT iSample = GetCurrentSample();

            if ( !m_bIsLine &&
                   ( !GetCurrentSampleMask() ||
                     !m_bSampleCovered[iSample][m_iPix] ) )
            {
                // iSample not covered by this geometry
                continue;
            }
            //
            // read current depth for this pixel and do depth test - cannot
            // bail out if failed because stencil may need to be updated
            //
            BOOL bDepthTestPassed = TRUE;
            if ( m_pRD->GetRS()[D3DRS_ZENABLE] )
            {
                m_Depth[m_iPix] = m_SampleDepth[iSample][m_iPix];

                RDDepth BufferDepth( m_Depth[m_iPix].GetSType() );
                m_pRD->m_pRenderTarget->ReadPixelDepth( iX, iY, iSample, BufferDepth );
                bDepthTestPassed = DepthCloser( m_Depth[m_iPix], BufferDepth );
            }

            //
            // do stencil operation
            //
            BOOL bStencilTestPassed = TRUE;
            if ( m_pRD->GetRS()[D3DRS_STENCILENABLE] )
            {
                // read stencil buffer and do stencil operation
                UINT8 uStncBuf = 0x0;
                m_pRD->m_pRenderTarget->ReadPixelStencil( iX, iY, iSample, uStncBuf );
                UINT8 uStncNew;
                bStencilTestPassed =
                    DoStencil( uStncBuf, bDepthTestPassed, m_pRD->m_pRenderTarget->m_pDepth->GetSurfaceFormat(), uStncNew );

                // update stencil only if changed
                if ( uStncNew != uStncBuf )
                {
                    // compute new buffer value based on write mask
                    UINT8 uStncWMask = m_pRD->GetRS()[D3DRS_STENCILWRITEMASK];
                    UINT8 uStncBufNew = (uStncBuf & ~uStncWMask) | (uStncNew & uStncWMask);
                    m_pRD->m_pRenderTarget->WritePixelStencil( iX, iY, iSample, uStncBufNew );
                }
            }

            if ( !(bDepthTestPassed && bStencilTestPassed) )
            {
                continue;
            }

            //
            // do alpha blend and write mask
            //
            if ( ( ( m_pRD->GetRS()[D3DRS_COLORWRITEENABLE] & 0xF) != 0xF ) ||
                 ( m_pRD->GetRS()[D3DRS_ALPHABLENDENABLE] ) )
            {
                RDColor BufferColor;
                m_pRD->m_pRenderTarget->ReadPixelColor( iX, iY, iSample, BufferColor );

                if ( m_pRD->GetRS()[D3DRS_ALPHABLENDENABLE] )
                {
                    DoAlphaBlend( FinalPixelColor, BufferColor, FinalPixelColor );
                }

                if ( !(m_pRD->GetRS()[D3DRS_COLORWRITEENABLE] & D3DCOLORWRITEENABLE_RED) )
                    FinalPixelColor.R = BufferColor.R;
                if ( !(m_pRD->GetRS()[D3DRS_COLORWRITEENABLE] & D3DCOLORWRITEENABLE_GREEN) )
                    FinalPixelColor.G = BufferColor.G;
                if ( !(m_pRD->GetRS()[D3DRS_COLORWRITEENABLE] & D3DCOLORWRITEENABLE_BLUE) )
                    FinalPixelColor.B = BufferColor.B;
                if ( !(m_pRD->GetRS()[D3DRS_COLORWRITEENABLE] & D3DCOLORWRITEENABLE_ALPHA) )
                    FinalPixelColor.A = BufferColor.A;
            }

#if 0
{
    extern float g_GammaTable[];
    FinalPixelColor.R = g_GammaTable[ (UINT8)(255.f*FinalPixelColor.R) ];
    FinalPixelColor.G = g_GammaTable[ (UINT8)(255.f*FinalPixelColor.G) ];
    FinalPixelColor.B = g_GammaTable[ (UINT8)(255.f*FinalPixelColor.B) ];
}
#endif
            //
            // update color and depth buffers
            //
            WritePixel( iX, iY, iSample, FinalPixelColor, m_Depth[m_iPix] );

        } while (NextSample());
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Pixel Processing Utility Functions                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Depth compare method used for Z buffering and fragment processing.
//
// Returns TRUE if DepthVal is closer than DepthBuf.  DepthA is the generated
// value and DepthB
//
//-----------------------------------------------------------------------------
BOOL
RefRast::DepthCloser(
    const RDDepth& DepthVal,
    const RDDepth& DepthBuf )
{
    if ( !m_pRD->GetRS()[D3DRS_ZENABLE] ) { return TRUE; }


    switch ( m_pRD->GetRS()[D3DRS_ZFUNC] )
    {
    case D3DCMP_NEVER:        return FALSE;
    case D3DCMP_LESS:         return ( DOUBLE(DepthVal) <  DOUBLE(DepthBuf) );
    case D3DCMP_EQUAL:        return ( DOUBLE(DepthVal) == DOUBLE(DepthBuf) );
    case D3DCMP_LESSEQUAL:    return ( DOUBLE(DepthVal) <= DOUBLE(DepthBuf) );
    case D3DCMP_GREATER:      return ( DOUBLE(DepthVal) >  DOUBLE(DepthBuf) );
    case D3DCMP_NOTEQUAL:     return ( DOUBLE(DepthVal) != DOUBLE(DepthBuf) );
    case D3DCMP_GREATEREQUAL: return ( DOUBLE(DepthVal) >= DOUBLE(DepthBuf) );
    case D3DCMP_ALWAYS:       return TRUE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// Alpha test method for pixel processing.
//
// Returns TRUE if alpha test passes.
//
//-----------------------------------------------------------------------------
BOOL
RefRast::AlphaTest( FLOAT fAlpha )
{
    // grab 8 bit unsigned alpha value
    UINT8 uAlpha = (UINT8)(255.f*fAlpha);

    // form 8 bit alpha reference value
    UINT8 uAlphaRef8 = m_pRD->GetRS()[D3DRS_ALPHAREF];

    // do alpha test and either return directly or pass through
    switch ( m_pRD->GetRS()[D3DRS_ALPHAFUNC] )
    {
    case D3DCMP_NEVER:        return FALSE;
    case D3DCMP_LESS:         return (uAlpha <  uAlphaRef8);
    case D3DCMP_EQUAL:        return (uAlpha == uAlphaRef8);
    case D3DCMP_LESSEQUAL:    return (uAlpha <= uAlphaRef8);
    case D3DCMP_GREATER:      return (uAlpha >  uAlphaRef8);
    case D3DCMP_NOTEQUAL:     return (uAlpha != uAlphaRef8);
    case D3DCMP_GREATEREQUAL: return (uAlpha >= uAlphaRef8);
    case D3DCMP_ALWAYS:       return TRUE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// DoStencil - Performs stencil test.  Returns TRUE if stencil test passed.
// Also computes stencil result value (to be written back to stencil planes
// if test passes, subject to stencil write mask).
//
//-----------------------------------------------------------------------------
BOOL
RefRast::DoStencil(
    UINT8 uStncBuf,     // in: stencil buffer value
    BOOL bDepthTest,    // in: boolean result of depth test
    RDSurfaceFormat DepthSType,   // in: surface type of Z buffer
    UINT8& uStncRet)    // out: stencil value result
{
    // support 8 bit stencil only, so do everything as UINT8's

    // max value for masking and saturation ops
    UINT8 uStncMax;
    switch(DepthSType)
    {
    case RD_SF_Z24S8:
    case RD_SF_S8Z24: uStncMax = 0xff; break;
    case RD_SF_Z15S1:
    case RD_SF_S1Z15: uStncMax = 0x1;  break;
    case RD_SF_Z24X4S4:
    case RD_SF_X4S4Z24: uStncMax = 0xf;  break;
    default:          uStncMax = 0;    break;  // don't let stencil become non 0
    }

    // get reference from renderstate
    UINT8 uStncRef = (UINT8)(m_pRD->GetRS()[D3DRS_STENCILREF]);
    // mask to use only bits possibly present in stencil buffer
    uStncRef &= uStncMax;

    // form masked values for test
    UINT8 uStncMask = (UINT8)(m_pRD->GetRS()[D3DRS_STENCILMASK]);
    UINT8 uStncBufM = uStncBuf & uStncMask;
    UINT8 uStncRefM = uStncRef & uStncMask;

    // do stencil compare function
    BOOL bStncTest = FALSE;
    switch ( m_pRD->GetRS()[D3DRS_STENCILFUNC] )
    {
    case D3DCMP_NEVER:        bStncTest = FALSE; break;
    case D3DCMP_LESS:         bStncTest = (uStncRefM <  uStncBufM); break;
    case D3DCMP_EQUAL:        bStncTest = (uStncRefM == uStncBufM); break;
    case D3DCMP_LESSEQUAL:    bStncTest = (uStncRefM <= uStncBufM); break;
    case D3DCMP_GREATER:      bStncTest = (uStncRefM >  uStncBufM); break;
    case D3DCMP_NOTEQUAL:     bStncTest = (uStncRefM != uStncBufM); break;
    case D3DCMP_GREATEREQUAL: bStncTest = (uStncRefM >= uStncBufM); break;
    case D3DCMP_ALWAYS:       bStncTest = TRUE; break;
    }

    // determine which stencil operation to perform
    DWORD dwStencilOp;
    if ( !bStncTest )
    {
        // stencil test failed - depth test does not matter
        dwStencilOp = m_pRD->GetRS()[D3DRS_STENCILFAIL];
    }
    else
    {
        // stencil test passed - select based on depth pass/fail
        dwStencilOp = ( !bDepthTest )
            ? ( m_pRD->GetRS()[D3DRS_STENCILZFAIL] )
            : ( m_pRD->GetRS()[D3DRS_STENCILPASS] );
    }

    uStncRet = 0x0;
    switch ( dwStencilOp )
    {
    case D3DSTENCILOP_KEEP:    uStncRet = uStncBuf; break;
    case D3DSTENCILOP_ZERO:    uStncRet = 0x00; break;
    case D3DSTENCILOP_REPLACE: uStncRet = uStncRef; break;
    case D3DSTENCILOP_INCRSAT:
        uStncRet = (uStncBuf==uStncMax)?(uStncMax):(uStncBuf+1); break;
    case D3DSTENCILOP_DECRSAT:
        uStncRet = (uStncBuf==0x00)?(0x00):(uStncBuf-1); break;
    case D3DSTENCILOP_INVERT:  uStncRet = ~uStncBuf; break;
    case D3DSTENCILOP_INCR:    uStncRet = uStncBuf+1; break;
    case D3DSTENCILOP_DECR:    uStncRet = uStncBuf-1; break;
    }

    return bStncTest;
}

//-----------------------------------------------------------------------------
//
// DoAlphaBlend - Performs color blending of source and destination colors
// producing a result color.
//
//-----------------------------------------------------------------------------
void
RefRast::DoAlphaBlend(
    const RDColor& SrcColor,    // in: source pixel color
    const RDColor& DstColor,    // in: destination (buffer) color
    RDColor& ResColor)          // out: result (blended) color
{
    RDColor SrcColorFactor;
    RDColor DstColorFactor;
    BOOL bDestBlendOverride = FALSE;

    // no SRC/DST blend (or clamp) required for MIN or MAX BLENDOP
    switch ( m_pRD->GetRS()[D3DRS_BLENDOP] )
    {
    case D3DBLENDOP_MIN:
        ResColor.R = MIN(SrcColor.R,DstColor.R);
        ResColor.G = MIN(SrcColor.G,DstColor.G);
        ResColor.B = MIN(SrcColor.B,DstColor.B);
        ResColor.A = MIN(SrcColor.A,DstColor.A);
        return;
    case D3DBLENDOP_MAX:
        ResColor.R = MAX(SrcColor.R,DstColor.R);
        ResColor.G = MAX(SrcColor.G,DstColor.G);
        ResColor.B = MAX(SrcColor.B,DstColor.B);
        ResColor.A = MAX(SrcColor.A,DstColor.A);
        return;
    }

    // compute source blend factors
    switch ( m_pRD->GetRS()[D3DRS_SRCBLEND] )
    {

    default:
    case D3DBLEND_ZERO:
        SrcColorFactor.SetAllChannels( 0.F );
        break;

    case D3DBLEND_ONE:
        SrcColorFactor.SetAllChannels( 1.F );
        break;

    case D3DBLEND_SRCCOLOR:
        SrcColorFactor.R = SrcColor.R;
        SrcColorFactor.G = SrcColor.G;
        SrcColorFactor.B = SrcColor.B;
        SrcColorFactor.A = SrcColor.A;
        break;

    case D3DBLEND_INVSRCCOLOR:
        SrcColorFactor.R = ( 1.f - SrcColor.R );
        SrcColorFactor.G = ( 1.f - SrcColor.G );
        SrcColorFactor.B = ( 1.f - SrcColor.B );
        SrcColorFactor.A = ( 1.f - SrcColor.A );
        break;

    case D3DBLEND_SRCALPHA:
        SrcColorFactor.SetAllChannels( SrcColor.A );
        break;

    case D3DBLEND_INVSRCALPHA:
        SrcColorFactor.SetAllChannels( 1.f - SrcColor.A );
        break;

    case D3DBLEND_DESTALPHA:
        SrcColorFactor.SetAllChannels( DstColor.A );
        break;

    case D3DBLEND_INVDESTALPHA:
        SrcColorFactor.SetAllChannels( 1.f - DstColor.A );
        break;

    case D3DBLEND_DESTCOLOR:
        SrcColorFactor.R = DstColor.R;
        SrcColorFactor.G = DstColor.G;
        SrcColorFactor.B = DstColor.B;
        SrcColorFactor.A = DstColor.A;
        break;

    case D3DBLEND_INVDESTCOLOR:
        SrcColorFactor.R = ( 1.f - DstColor.R );
        SrcColorFactor.G = ( 1.f - DstColor.G );
        SrcColorFactor.B = ( 1.f - DstColor.B );
        SrcColorFactor.A = ( 1.f - DstColor.A );
        break;

    case D3DBLEND_SRCALPHASAT:
        {
            FLOAT F = MIN( SrcColor.A, 1.f - DstColor.A );
            SrcColorFactor.R = F;
            SrcColorFactor.G = F;
            SrcColorFactor.B = F;
        }
        SrcColorFactor.A = 1.F;
        break;

    // these are for SRCBLEND only and override DESTBLEND
    case D3DBLEND_BOTHSRCALPHA:
        bDestBlendOverride = TRUE;
        SrcColorFactor.SetAllChannels( SrcColor.A );
        DstColorFactor.SetAllChannels( 1.f - SrcColor.A );
        break;

    case D3DBLEND_BOTHINVSRCALPHA:
        bDestBlendOverride = TRUE;
        SrcColorFactor.SetAllChannels( 1.f - SrcColor.A );
        DstColorFactor.SetAllChannels( SrcColor.A );
        break;
    }

    // compute destination blend factors
    if ( !bDestBlendOverride )
    {
        switch ( m_pRD->GetRS()[D3DRS_DESTBLEND] )
        {

        default:
        case D3DBLEND_ZERO:
            DstColorFactor.SetAllChannels( 0.F );
            break;

        case D3DBLEND_ONE:
            DstColorFactor.SetAllChannels( 1.F );
            break;

        case D3DBLEND_SRCCOLOR:
            DstColorFactor.R = SrcColor.R;
            DstColorFactor.G = SrcColor.G;
            DstColorFactor.B = SrcColor.B;
            DstColorFactor.A = SrcColor.A;
            break;

        case D3DBLEND_INVSRCCOLOR:
            DstColorFactor.R = ( 1.f - SrcColor.R );
            DstColorFactor.G = ( 1.f - SrcColor.G );
            DstColorFactor.B = ( 1.f - SrcColor.B );
            DstColorFactor.A = ( 1.f - SrcColor.A );
            break;

        case D3DBLEND_SRCALPHA:
            DstColorFactor.SetAllChannels( SrcColor.A );
            break;

        case D3DBLEND_INVSRCALPHA:
            DstColorFactor.SetAllChannels( 1.f - SrcColor.A );
            break;

        case D3DBLEND_DESTALPHA:
            DstColorFactor.SetAllChannels( DstColor.A );
            break;

        case D3DBLEND_INVDESTALPHA:
            DstColorFactor.SetAllChannels( 1.f - DstColor.A );
            break;

        case D3DBLEND_DESTCOLOR:
            DstColorFactor.R = DstColor.R;
            DstColorFactor.G = DstColor.G;
            DstColorFactor.B = DstColor.B;
            DstColorFactor.A = DstColor.A;
            break;

        case D3DBLEND_INVDESTCOLOR:
            DstColorFactor.R = ( 1.f - DstColor.R );
            DstColorFactor.G = ( 1.f - DstColor.G );
            DstColorFactor.B = ( 1.f - DstColor.B );
            DstColorFactor.A = ( 1.f - DstColor.A );
            break;

        case D3DBLEND_SRCALPHASAT:
            {
                FLOAT F = MIN( SrcColor.A, 1.f - DstColor.A );
                DstColorFactor.R = F;
                DstColorFactor.G = F;
                DstColorFactor.B = F;
            }
            DstColorFactor.A = 1.F;
            break;
        }
    }

    // apply blend factors to update pixel color (MIN and MAX handled above)
    RDColor SclSrc, SclDst;
    SclSrc.R = SrcColorFactor.R * SrcColor.R;
    SclSrc.G = SrcColorFactor.G * SrcColor.G;
    SclSrc.B = SrcColorFactor.B * SrcColor.B;
    SclSrc.A = SrcColorFactor.A * SrcColor.A;
    SclDst.R = DstColorFactor.R * DstColor.R;
    SclDst.G = DstColorFactor.G * DstColor.G;
    SclDst.B = DstColorFactor.B * DstColor.B;
    SclDst.A = DstColorFactor.A * DstColor.A;
    switch ( m_pRD->GetRS()[D3DRS_BLENDOP] )
    {
    default:
    case D3DBLENDOP_ADD:
        ResColor.R = SclSrc.R + SclDst.R;
        ResColor.G = SclSrc.G + SclDst.G;
        ResColor.B = SclSrc.B + SclDst.B;
        ResColor.A = SclSrc.A + SclDst.A;
        break;
    case D3DBLENDOP_SUBTRACT:
        ResColor.R = SclSrc.R - SclDst.R;
        ResColor.G = SclSrc.G - SclDst.G;
        ResColor.B = SclSrc.B - SclDst.B;
        ResColor.A = SclSrc.A - SclDst.A;
        break;
    case D3DBLENDOP_REVSUBTRACT:
        ResColor.R = SclDst.R - SclSrc.R;
        ResColor.G = SclDst.G - SclSrc.G;
        ResColor.B = SclDst.B - SclSrc.B;
        ResColor.A = SclDst.A - SclSrc.A;
        break;
    }

    // clamp result
    ResColor.Clamp();
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////
#include "refdev.hpp"

#include "refrasti.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\psexec.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// psexec.cpp
//
// Direct3D Reference Device - Pixel Shader Execution
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// ExecShader - Executes the current pixel shader.
//
//-----------------------------------------------------------------------------
void
RefRast::ExecShader( void )
{
    #define _InstParam(__INST)         (*(__INST##_PARAMS UNALIGNED64*)pRDPSInstBuffer)
    #define _StepOverInst(__INST)       pRDPSInstBuffer += sizeof(__INST##_PARAMS);
    #define _DeclArgs(__INST)           __INST##_PARAMS& Args = _InstParam(__INST);

    #define _PerChannel(__STATEMENT)                                \
                for( iChn=0; iChn<4; iChn++ )                       \
                {                                                   \
                    __STATEMENT                                     \
                }                                                   \

    #define _PerChannelMasked(__STATEMENT)                         \
                for( iChn=0; iChn<4; iChn++ )                       \
                {                                                   \
                    if( !(Args.WriteMask & ComponentMask[iChn] ) )  \
                        continue;                                   \
                    __STATEMENT                                     \
                }                                                   \

    #define _Dst            Args.DstReg.GetRegPtr()[m_iPix][iChn]
    #define _DstC(__chn)    Args.DstReg.GetRegPtr()[m_iPix][__chn]

    #define _Src0           Args.SrcReg0.GetRegPtr()[m_iPix][iChn]
    #define _Src1           Args.SrcReg1.GetRegPtr()[m_iPix][iChn]
    #define _Src2           Args.SrcReg2.GetRegPtr()[m_iPix][iChn]
    #define _Src0C(__chn)   Args.SrcReg0.GetRegPtr()[m_iPix][__chn]
    #define _Src1C(__chn)   Args.SrcReg1.GetRegPtr()[m_iPix][__chn]
    #define _Src2C(__chn)   Args.SrcReg2.GetRegPtr()[m_iPix][__chn]

    #define _Src0N          (Args.bSrcReg0_Negate?(-_Src0):_Src0)
    #define _Src1N          (Args.bSrcReg1_Negate?(-_Src1):_Src1)
    #define _Src2N          (Args.bSrcReg2_Negate?(-_Src2):_Src2)
    #define _Src0NC(__chn)  (Args.bSrcReg0_Negate?(-_Src0C(__chn)):_Src0C(__chn))
    #define _Src1NC(__chn)  (Args.bSrcReg1_Negate?(-_Src1C(__chn)):_Src1C(__chn))
    #define _Src2NC(__chn)  (Args.bSrcReg2_Negate?(-_Src2C(__chn)):_Src2C(__chn))

    BYTE ComponentMask[4] = {RDPS_COMPONENTMASK_0, RDPS_COMPONENTMASK_1, RDPS_COMPONENTMASK_2, RDPS_COMPONENTMASK_3};
    BYTE* pRDPSInstBuffer = &m_pCurrentPixelShader->m_RDPSInstBuffer[0]; // Buffer of "RISC" RDPS_* instructions to execute.
    int   QueueIndex[4] = {-1,-1,-1,-1}; // For simulating co-issue sequentially ("parallel" writes staged in queue)
    int   iChn; // For macros

#if DBG
    PixelShaderInstruction* pCurrD3DPSInst = NULL;              // Current true D3DSIO_ instruction being simulated.
#endif

    m_bPixelDiscard[0] = m_bPixelDiscard[1] = m_bPixelDiscard[2] = m_bPixelDiscard[3] = FALSE;
  
    while(RDPSINST_END != _InstParam(RDPSINST_BASE).Inst)
    {
        switch(_InstParam(RDPSINST_BASE).Inst)
        {
        case RDPSINST_EVAL:
            {
                _DeclArgs(RDPSINST_EVAL)
                m_Attr[RDATTR_TEXTURE0+Args.uiCoordSet].Sample( Args.DstReg.GetRegPtr()[m_iPix],
                                                                (FLOAT)m_iX[m_iPix], (FLOAT)m_iY[m_iPix], 
                                                                Args.bIgnoreD3DTTFF_PROJECTED, Args.bClamp );
            }
            _StepOverInst(RDPSINST_EVAL)
            break;
        case RDPSINST_SAMPLE:
            {
                _DeclArgs(RDPSINST_SAMPLE)
                ComputeTextureFilter( Args.uiStage, Args.CoordReg.GetRegPtr()[m_iPix] );
                SampleTexture( Args.uiStage, Args.DstReg.GetRegPtr()[m_iPix] );
            }
            _StepOverInst(RDPSINST_SAMPLE)
            break;
        case RDPSINST_KILL:
            {
                _DeclArgs(RDPSINST_KILL)
                DWORD TexKillFlags = 0x0;   // TODO: get these from TSS or per-instruction
                _PerChannel(
                    // compare against zero according to kill flags
                    if ( TexKillFlags & (1<<iChn) )
                    {
                        if ( _Dst >= 0. )
                            m_bPixelDiscard[m_iPix] |= 0x1;
                    }
                    else
                    {
                        if ( _Dst < 0. )
                            m_bPixelDiscard[m_iPix] |= 0x1;
                    }
                )

            }
            _StepOverInst(RDPSINST_KILL)
            break;
        case RDPSINST_BEM:
            {
                _DeclArgs(RDPSINST_BEM)

                RDTextureStageState*  pTSS = &m_pRD->m_TextureStageState[Args.uiStage];
                // Just assuming Args.WriteMask is .rg

                _DstC(0) = _Src0NC(0) + 
                    pTSS->m_fVal[D3DTSS_BUMPENVMAT00] * _Src1NC(0) +
                    pTSS->m_fVal[D3DTSS_BUMPENVMAT10] * _Src1NC(1);
                _DstC(1) = _Src0NC(1) + 
                    pTSS->m_fVal[D3DTSS_BUMPENVMAT01] * _Src1NC(0) +
                    pTSS->m_fVal[D3DTSS_BUMPENVMAT11] * _Src1NC(1);
            }
            _StepOverInst(RDPSINST_BEM)
            break;
        case RDPSINST_LUMINANCE:
            {
                _DeclArgs(RDPSINST_LUMINANCE)
                RDTextureStageState*  pTSS = &m_pRD->m_TextureStageState[Args.uiStage];

                FLOAT fLum = _Src1NC(2) * 
                             pTSS->m_fVal[D3DTSS_BUMPENVLSCALE] +
                             pTSS->m_fVal[D3DTSS_BUMPENVLOFFSET];

                fLum = min(max(fLum, 0.0f), 1.0F);

                // apply luminance modulation to RGB only
                _DstC(0) = _Src0C(0)*fLum;
                _DstC(1) = _Src0C(1)*fLum;
                _DstC(2) = _Src0C(2)*fLum;
            }
            _StepOverInst(RDPSINST_LUMINANCE)
            break;
        case RDPSINST_DEPTH:
            {
                _DeclArgs(RDPSINST_DEPTH)

                FLOAT result;

                FLOAT* pDstReg = Args.DstReg.GetRegPtr()[m_iPix];
                if( pDstReg[1] )
                    result = pDstReg[0] / pDstReg[1];
                else
                    result = 1.0f;

                // clamp
                m_Depth[m_iPix] = MAX(0, MIN(1, result));

                // snap off extra bits by converting to/from buffer format - necessary
                // to make depth buffer equality tests function correctly
                SnapDepth();

                do
                {
                    m_SampleDepth[m_CurrentSample][m_iPix] = m_Depth[m_iPix];
                }
                while (NextSample());
            }
            _StepOverInst(RDPSINST_DEPTH)
            break;
        case RDPSINST_SRCMOD:
            {
                _DeclArgs(RDPSINST_SRCMOD)
                _PerChannelMasked(

                    if( Args.bComplement )
                        _Dst = 1 - _Src0;
                    else if( Args.bBias && Args.bTimes2 )
                        _Dst = 2*(_Src0 - 0.5);
                    else if( Args.bBias )
                        _Dst = _Src0 - 0.5f;
                    else if( Args.bTimes2 )
                        _Dst = 2*_Src0;
                    else
                        _Dst = _Src0;

                    _Dst = MAX( _Dst, Args.fRangeMin );
                    _Dst = MIN( _Dst, Args.fRangeMax );
                )
            }
            _StepOverInst(RDPSINST_SRCMOD)
            break;
        case RDPSINST_SWIZZLE:
            {
                _DeclArgs(RDPSINST_SWIZZLE)
                BYTE Swizzle = Args.Swizzle;
                _PerChannelMasked(
                    _Dst = _Src0C(Swizzle&0x3);
                    Swizzle >>= 2;
                )
            }
            _StepOverInst(RDPSINST_SWIZZLE)
            break;
        case RDPSINST_DSTMOD:
            {
                _DeclArgs(RDPSINST_DSTMOD)

                _PerChannelMasked(
                    _Dst *= Args.fScale;
                    // clamp to range
                    _Dst = MAX( _Dst, Args.fRangeMin );
                    _Dst = MIN( _Dst, Args.fRangeMax );
                )
            }
            _StepOverInst(RDPSINST_DSTMOD)
            break;
        case RDPSINST_MOV:
            {
                _DeclArgs(RDPSINST_MOV)
                _PerChannelMasked(_Dst = _Src0N;)
            }
            _StepOverInst(RDPSINST_MOV)
            break;
        case RDPSINST_RCP:
            {
                _DeclArgs(RDPSINST_RCP)
                _PerChannelMasked(_Dst = _Src0N ? 1/_Src0N : 1.0f;)
            }
            _StepOverInst(RDPSINST_RCP)
            break;
        case RDPSINST_FRC:
            {
                _DeclArgs(RDPSINST_FRC)
                _PerChannelMasked(_Dst = _Src0N - (float)floor(_Src0N);)
            }
            _StepOverInst(RDPSINST_FRC)
            break;
        case RDPSINST_ADD:
            {
                _DeclArgs(RDPSINST_ADD)
                _PerChannelMasked(_Dst = _Src0N + _Src1N;)
            }
            _StepOverInst(RDPSINST_ADD)
            break;
        case RDPSINST_SUB:
            {
                _DeclArgs(RDPSINST_SUB)
                _PerChannelMasked(_Dst = _Src0N - _Src1N;)
            }
            _StepOverInst(RDPSINST_SUB)
            break;
        case RDPSINST_MUL:
            {
                _DeclArgs(RDPSINST_MUL)
                _PerChannelMasked(_Dst = _Src0N * _Src1N;);
            }
            _StepOverInst(RDPSINST_MUL)
            break;
        case RDPSINST_DP3:
            {
                _DeclArgs(RDPSINST_DP3)
                FLOAT dp3 = _Src0NC(0) * _Src1NC(0) +
                            _Src0NC(1) * _Src1NC(1) +
                            _Src0NC(2) * _Src1NC(2);
                _PerChannelMasked(_Dst = dp3;)
            }
            _StepOverInst(RDPSINST_DP3)
            break;
        case RDPSINST_DP4:
            {
                _DeclArgs(RDPSINST_DP4)
                FLOAT dp4 = _Src0NC(0) * _Src1NC(0) +
                            _Src0NC(1) * _Src1NC(1) +
                            _Src0NC(2) * _Src1NC(2) +
                            _Src0NC(3) * _Src1NC(3);
                _PerChannelMasked(_Dst = dp4;)
            }
            _StepOverInst(RDPSINST_DP4)
            break;
        case RDPSINST_MAD:
            {
                _DeclArgs(RDPSINST_MAD)
                _PerChannelMasked(_Dst = _Src0N * _Src1N + _Src2N;)
            }
            _StepOverInst(RDPSINST_MAD)
            break;
        case RDPSINST_LRP:
            {
                _DeclArgs(RDPSINST_LRP)
                _PerChannelMasked(_Dst = (_Src0N*(_Src1N - _Src2N)) + _Src2N;)
            }
            _StepOverInst(RDPSINST_LRP)
            break;
        case RDPSINST_CND:
            {
                _DeclArgs(RDPSINST_CND)
                _PerChannelMasked(_Dst = _Src0N > 0.5f ? _Src1N : _Src2N;)
            }
            _StepOverInst(RDPSINST_CND)
            break;
        case RDPSINST_CMP:
            {
                _DeclArgs(RDPSINST_CMP)
                _PerChannelMasked(_Dst = _Src0N >= 0.f ? _Src1N : _Src2N;)
            }
            _StepOverInst(RDPSINST_CMP)
            break;
        case RDPSINST_TEXCOVERAGE:
            {   
                _DeclArgs(RDPSINST_TEXCOVERAGE);
                Args.pGradients[0][0] = *Args.pDUDX_0 - *Args.pDUDX_1; // du/dx
                Args.pGradients[0][1] = *Args.pDUDY_0 - *Args.pDUDY_1; // du/dy
                Args.pGradients[1][0] = *Args.pDVDX_0 - *Args.pDVDX_1; // dv/dx
                Args.pGradients[1][1] = *Args.pDVDY_0 - *Args.pDVDY_1; // dv/dy
                Args.pGradients[2][0] = *Args.pDWDX_0 - *Args.pDWDX_1; // dw/dx
                Args.pGradients[2][1] = *Args.pDWDY_0 - *Args.pDWDY_1; // dw/dy
                ComputeTextureCoverage( Args.uiStage, Args.pGradients );
            }
            _StepOverInst(RDPSINST_TEXCOVERAGE)
            break;
        case RDPSINST_QUADLOOPBEGIN:
            m_iPix = 0;
            _StepOverInst(RDPSINST_QUADLOOPBEGIN)
            break;
        case RDPSINST_QUADLOOPEND:
            {
                _DeclArgs(RDPSINST_QUADLOOPEND);
                if( 4 > ++m_iPix ) 
                    pRDPSInstBuffer -= Args.JumpBackByOffset;
                else
                    _StepOverInst(RDPSINST_QUADLOOPEND)
            }
            break;
        case RDPSINST_QUEUEWRITE:
            {
                _DeclArgs(RDPSINST_QUEUEWRITE);
                QueueIndex[m_iPix]++;
                m_QueuedWriteDst[QueueIndex[m_iPix]].DstReg    = Args.DstReg;
                m_QueuedWriteDst[QueueIndex[m_iPix]].WriteMask = Args.WriteMask;
            }
            _StepOverInst(RDPSINST_QUEUEWRITE)
            break;
        case RDPSINST_FLUSHQUEUE:
            {
                _ASSERT(QueueIndex[m_iPix] >= 0, "Nothing in pixelshader write queue to flush.  Refrast mistranslated this pixelshader." );
                _ASSERT(QueueIndex[m_iPix] < RDPS_MAX_NUMQUEUEDWRITEREG, "Pixelshader write queue overflow.  Refrast mistranslated this pixelshader." );
                for( int i = 0; i <= QueueIndex[m_iPix]; i++ )
                {
                    _PerChannel(
                        if (m_QueuedWriteDst[i].WriteMask & ComponentMask[iChn])
                            m_QueuedWriteDst[i].DstReg.GetRegPtr()[m_iPix][iChn] = m_QueuedWriteReg[i][m_iPix][iChn];
                    )
                }
                QueueIndex[m_iPix] = -1;
            }
            _StepOverInst(RDPSINST_FLUSHQUEUE)
            break;
        case RDPSINST_NEXTD3DPSINST:
#if DBG
            if (m_pRD->m_pDbgMon)
                m_pRD->m_pDbgMon->NextEvent( D3DDM_EVENT_PIXELSHADERINST );
            pCurrD3DPSInst = _InstParam(RDPSINST_NEXTD3DPSINST).pInst; // Handy to look at when debugging.
#endif
            _StepOverInst(RDPSINST_NEXTD3DPSINST)
            break;
        default:
            _ASSERT(FALSE,"Refrast::ExecShader() - Unrecognized micro-instruction!");
            break;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\rastattr.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// rastattr.cpp
//
// Direct3D Reference Device -
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void RDAttribute::Init(
    RefRast* pRefRast, // RefRast with which this attrib is used
    UINT cDimensionality,
    BOOL bPerspective,
    BOOL bClamp )
{
    m_pRR = pRefRast;

    m_cDimensionality = cDimensionality;
    m_bPerspective = bPerspective;
    m_bClamp = bClamp;

    m_cProjection = 0;
    m_dwWrapFlags = 0x0;
    m_bFlatShade = FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Sampling Routines
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Sample - Sample attribute at given location.
//
//-----------------------------------------------------------------------------
void RDAttribute::Sample(
    FLOAT*  pSample,
    FLOAT   fX,
    FLOAT   fY,
    BOOL    bNoProjectionOverride,  // disables projection if TRUE
    BOOL    bClampOverride)         // enables (forces) clamp if TRUE
{
    FLOAT fPScale = 1.0F;

    if (m_cProjection && !m_bFlatShade && !bNoProjectionOverride)
    {
        // note that perspective is already incorporated into projective coord
        fPScale = 1.0F/( fX*m_fA[m_cProjection] + fY*m_fB[m_cProjection] + m_fC[m_cProjection] );
    }
    else if (m_bPerspective && !m_bFlatShade)
    {
        fPScale = m_pRR->m_fW[m_pRR->m_iPix];
    }

    for ( UINT i=0; i<m_cDimensionality; i++)
    {
        if (m_bFlatShade)
        {
            *(pSample+i) = m_fC[i];
        }
        else
        {
            *(pSample+i) =
                fPScale * ( fX*m_fA[i] + fY*m_fB[i] + m_fC[i] );
        }

        if (m_bClamp || bClampOverride)
        {
            *(pSample+i) = MIN( 1.F, MAX( 0.F, *(pSample+i) ) );
        }
    }
}

//-----------------------------------------------------------------------------
//
// Sample - Sample scalar attribute at given location.  Assumes no perspective
// or projection.  (Used for W or Depth.)
//
//-----------------------------------------------------------------------------
FLOAT RDAttribute::Sample(
    FLOAT   fX,
    FLOAT   fY)
{
    return fX*m_fA[0] + fY*m_fB[0] + m_fC[0];
}

///////////////////////////////////////////////////////////////////////////////
//
// Setup Routines
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// WrapDiff - returns the difference (B-A) as defined under the D3D WRAPU/V
// rules which is the shortest path between the two assuming a coincident
// position at 1. and 0.  The fA and fB input range is 0. to 1.
//
//-----------------------------------------------------------------------------
static FLOAT
WrapDiff( FLOAT fB, FLOAT fA )
{
    // compute straight distance
    FLOAT fDist1 = fB - fA;
    // compute distance 'warping' between 0. and 1.
    FLOAT fDist2 = ( fDist1 < 0 ) ? ( fDist1+1 ) : ( fDist1-1 );

    // return minimum of these
    return ( fabs( fDist1) < fabs( fDist2) ) ? ( fDist1) : ( fDist2 );
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------

void RDAttribute::Setup(
    const FLOAT* pVtx0, const FLOAT* pVtx1, const FLOAT* pVtx2)
{
    if (m_pRR->m_bIsLine)
    {
        LineSetup( pVtx0, pVtx1, pVtx2 );
        return;
    }

    for ( UINT i=0; i<m_cDimensionality; i++)
    {
        FLOAT fVal0 = (pVtx0) ? (*(pVtx0+i)) : (0.);
        FLOAT fVal1 = (pVtx1) ? (*(pVtx1+i)) : (0.);
        FLOAT fVal2 = (pVtx2) ? (*(pVtx2+i)) : (0.);

        if (m_bFlatShade)
        {
            m_fA[i] = m_fB[i] = 0.F;
            switch ( m_pRR->m_iFlatVtx )
            {
            default:
            case 0: m_fC[i] = fVal0; break;
            case 1: m_fC[i] = fVal1; break;
            case 2: m_fC[i] = fVal2; break;
            }
            continue;
        }

        // extract wrap flag for this dimension
        BOOL bWrap = m_dwWrapFlags & (1<<i);

        // compute adjusted values for vertices 1,2 based on wrap flag
        FLOAT fVal1P = bWrap ? ( fVal0 + WrapDiff(fVal1,fVal0) ) : (fVal1);
        FLOAT fVal2P = bWrap ? ( fVal0 + WrapDiff(fVal2,fVal0) ) : (fVal2);

        // compute (maybe) perspective corrected linear deltas along two edges
        FLOAT fRHW0 = (m_bPerspective) ? (m_pRR->m_fRHW0) : (1.0F);
        FLOAT fRHW1 = (m_bPerspective) ? (m_pRR->m_fRHW1) : (1.0F);
        FLOAT fRHW2 = (m_bPerspective) ? (m_pRR->m_fRHW2) : (1.0F);

        FLOAT fDelAttrib10 = ( fVal1P * fRHW1 ) - ( fVal0 * fRHW0 );
        FLOAT fDelAttrib20 = ( fVal2P * fRHW2 ) - ( fVal0 * fRHW0 );

        // compute A & B terms (dVdX and dVdY)
        m_fA[i] = m_pRR->m_fTriOODet *
            ( fDelAttrib10 * m_pRR->m_fDelY20 + fDelAttrib20 * m_pRR->m_fDelY01 );
        m_fB[i] = m_pRR->m_fTriOODet *
            ( fDelAttrib20 * m_pRR->m_fDelX10 + fDelAttrib10 * m_pRR->m_fDelX02 );

        // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
        m_fC[i] = ( fVal0 * fRHW0 )
            - ( m_fA[i] * m_pRR->m_fX0 ) - ( m_fB[i] * m_pRR->m_fY0 );
    }
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void RDAttribute::LineSetup(
    const FLOAT* pVtx0, const FLOAT* pVtx1, const FLOAT* pVtxFlat)
{
    for ( UINT i=0; i<m_cDimensionality; i++)
    {
        FLOAT fVal0 = (pVtx0) ? (*(pVtx0+i)) : (0.);
        FLOAT fVal1 = (pVtx1) ? (*(pVtx1+i)) : (0.);

        if (m_bFlatShade)
        {
            m_fA[i] = m_fB[i] = 0.F;
            m_fC[i] = (pVtxFlat) ? (*(pVtxFlat+i)) : fVal0;
            continue;
        }

        // extract wrap flag for this dimension
        BOOL bWrap = m_dwWrapFlags & (1<<i);

        // compute adjusted values for vertices 1,2 based on wrap flag
        FLOAT fVal1P = bWrap ? ( fVal0 + WrapDiff(fVal1,fVal0) ) : (fVal1);

        // compute (maybe) perspective corrected linear deltas along two edges
        FLOAT fRHW0 = (m_bPerspective) ? (m_pRR->m_fRHW0) : (1.0F);
        FLOAT fRHW1 = (m_bPerspective) ? (m_pRR->m_fRHW1) : (1.0F);

        FLOAT fDelta = ( fVal1P*fRHW1 - fVal0*fRHW0) / m_pRR->m_fLineMajorLength;
        m_fA[i] = ( m_pRR->m_bLineXMajor ) ? ( fDelta ) : ( 0. );
        m_fB[i] = ( m_pRR->m_bLineXMajor ) ? ( 0. ) : ( fDelta );
        // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
        m_fC[i] = ( fVal0* fRHW0)
            - ( m_fA[i] * m_pRR->m_fX0 ) - ( m_fB[i] * m_pRR->m_fY0 );
    }
}

//-----------------------------------------------------------------------------
//
// Setup attribute given packed DWORD color.  Color format is that of the
// colors in the FVF vertex, which corresponds to D3DFMT_A8R8G8B8 (and is
// the same as D3DCOLOR).
//
//-----------------------------------------------------------------------------
void RDAttribute::Setup(
    DWORD dwVtx0, DWORD dwVtx1, DWORD dwVtx2)
{
    FLOAT fVtx0[4];
    FLOAT fVtx1[4];
    FLOAT fVtx2[4];

    fVtx0[0] = RGBA_GETRED(   dwVtx0 ) * (1./255.);
    fVtx0[1] = RGBA_GETGREEN( dwVtx0 ) * (1./255.);
    fVtx0[2] = RGBA_GETBLUE(  dwVtx0 ) * (1./255.);
    fVtx0[3] = RGBA_GETALPHA( dwVtx0 ) * (1./255.);
    fVtx1[0] = RGBA_GETRED(   dwVtx1 ) * (1./255.);
    fVtx1[1] = RGBA_GETGREEN( dwVtx1 ) * (1./255.);
    fVtx1[2] = RGBA_GETBLUE(  dwVtx1 ) * (1./255.);
    fVtx1[3] = RGBA_GETALPHA( dwVtx1 ) * (1./255.);
    fVtx2[0] = RGBA_GETRED(   dwVtx2 ) * (1./255.);
    fVtx2[1] = RGBA_GETGREEN( dwVtx2 ) * (1./255.);
    fVtx2[2] = RGBA_GETBLUE(  dwVtx2 ) * (1./255.);
    fVtx2[3] = RGBA_GETALPHA( dwVtx2 ) * (1./255.);

    Setup( fVtx0, fVtx1, fVtx2);
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\pshader.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pixshade.cpp
//
// Direct3D Reference Device - Pixel Shader
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
RDPShader::RDPShader(void)
{
    m_pRD = NULL;
    m_pCode = NULL;
    m_CodeSize = 0;
    m_cActiveTextureStages = 0;
    m_ReferencedTexCoordMask = 0;
    m_cInst = 0;
    m_pInst = NULL;
    m_cConstDefs = 0;
    m_pConstDefs = NULL;
}

//-----------------------------------------------------------------------------
RDPShader::~RDPShader()
{
    if (NULL != m_pCode)        delete[] m_pCode;
    if (NULL != m_pInst)        delete[] m_pInst;
    if (NULL != m_pConstDefs)   delete[] m_pConstDefs;
}

#define _DWordCount() (pToken - pCode)

#define _RegisterNeedsToBeInitializedWithTexcoords(Reg) (*pReferencedTexCoordMask)|=(1<<Reg);

//-----------------------------------------------------------------------------
//
// UpdateReferencedTexCoords
//
// Called for each instruction while parsing a 1.3 pixelshader.
// Updates pReferencedTexCoordMask (bitfield) to represent
// which texture coordinate sets are actually used by the shader.
// This is used to eliminate unnecessary attribute setup/sampling during
// primitive rasterization.
//
//-----------------------------------------------------------------------------
void UpdateReferencedTexCoords(PixelShaderInstruction* pInst,
                               DWORD* pReferencedTexCoordMask )
{
    switch( pInst->Opcode & D3DSI_OPCODE_MASK )
    {
    case D3DSIO_TEX:  
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXDEPTH:
        {
            for( UINT i = 0; i < 3; i++ )
            {
                UINT  RegNum = pInst->SrcParam[i] & 0xFF;
                if( D3DSPR_TEXTURE == (pInst->SrcParam[i] & D3DSP_REGTYPE_MASK) )
                    _RegisterNeedsToBeInitializedWithTexcoords(RegNum);
            }
        }
        break;
    case D3DSIO_TEXKILL:  // treat dest param as source
        {
            UINT  RegNum = pInst->DstParam & 0xFF;
            if( D3DSPR_TEXTURE == (pInst->DstParam & D3DSP_REGTYPE_MASK) )
                _RegisterNeedsToBeInitializedWithTexcoords(RegNum);
        }
        break;
    }
}

void CalculateSourceReadMasks(PixelShaderInstruction* pInst, BYTE* pSourceReadMasks, BOOL bAfterSwizzle, DWORD dwVersion)
{
    UINT i, j;
    DWORD Opcode = pInst->Opcode & D3DSI_OPCODE_MASK;
    BYTE  ComponentMask[4]= {RDPS_COMPONENTMASK_0, RDPS_COMPONENTMASK_1, RDPS_COMPONENTMASK_2, RDPS_COMPONENTMASK_3};

    for( i = 0; i < pInst->SrcParamCount; i++ )
    {
        BYTE  NeededComponents;
        BYTE  ReadComponents = 0;

        switch( Opcode )
        {
        case D3DSIO_TEX:      // only in ps.1.4 does texld have source parameter
            if( D3DPS_VERSION(1,4) == dwVersion )
            {
                // for ps.1.4, texld has a source parameter
                NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;
            }
            else // versions < ps.1.4 don't have a src param on tex, so we shouldn't get here.  But maybe in ps.2.0...
            {
                NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2 | RDPS_COMPONENTMASK_3;
            }
            break;
        case D3DSIO_TEXCOORD:
            if( D3DPS_VERSION(1,4) == dwVersion )
            {
                // for ps.1.4, texcrd has a source parameter
                NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;
            }
            else // versions < ps.1.4 don't have a src param on texcoord, so we shouldn't get here.  But maybe in ps.2.0...
            {
                NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2 | RDPS_COMPONENTMASK_3;
            }
            break;
        case D3DSIO_TEXBEM:
        case D3DSIO_TEXBEML:
            NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1;
            break;
        case D3DSIO_DP3:
            NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;
            break;
        case D3DSIO_DP4:
            NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2 | RDPS_COMPONENTMASK_3;
            break;
        case D3DSIO_BEM: // ps.1.4
            NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1;
            break;
        default: 
            // standard component-wise instruction, 
            // OR an op we know reads .rgba and we also know it will be validated to .rgba writemask
            NeededComponents = (pInst->DstParam & D3DSP_WRITEMASK_ALL) >> RDPS_COMPONENTMASK_SHIFT;
            break;
        }

        if( bAfterSwizzle )
        {
            pSourceReadMasks[i] = NeededComponents;
        }
        else
        {
            // Figure out which components of this source parameter are read (taking into account swizzle)
            for(j = 0; j < 4; j++)
            {
                if( NeededComponents & ComponentMask[j] )
                    ReadComponents |= ComponentMask[((pInst->SrcParam[i] & D3DSP_SWIZZLE_MASK) >> (D3DVS_SWIZZLE_SHIFT + 2*j)) & 0x3];
            }
            pSourceReadMasks[i] = ReadComponents;
        }
    }
}

void RDPSRegister::Set(RDPS_REGISTER_TYPE RegType, UINT RegNum, RefRast* pRast)
{
    m_RegType = RegType;
    m_RegNum = RegNum;

    UINT MaxRegNum = 0;

    switch( RegType )
    {
    case RDPSREG_INPUT:
        MaxRegNum = RDPS_MAX_NUMINPUTREG - 1;
        m_pReg = pRast->m_InputReg[RegNum];
        break;
    case RDPSREG_TEMP:
        MaxRegNum = RDPS_MAX_NUMTEMPREG - 1;
        m_pReg = pRast->m_TempReg[RegNum];
        break;
    case RDPSREG_CONST:
        MaxRegNum = RDPS_MAX_NUMCONSTREG - 1;
        m_pReg = pRast->m_ConstReg[RegNum];
        break;
    case RDPSREG_TEXTURE:
        MaxRegNum = RDPS_MAX_NUMTEXTUREREG - 1;
        m_pReg = pRast->m_TextReg[RegNum];
        break;
    case RDPSREG_POSTMODSRC:
        MaxRegNum = RDPS_MAX_NUMPOSTMODSRCREG - 1;
        m_pReg = pRast->m_PostModSrcReg[RegNum];
        break;
    case RDPSREG_SCRATCH:
        MaxRegNum = RDPS_MAX_NUMSCRATCHREG - 1;
        m_pReg = pRast->m_ScratchReg[RegNum];
        break;
    case RDPSREG_QUEUEDWRITE:
        MaxRegNum = RDPS_MAX_NUMQUEUEDWRITEREG - 1;
        m_pReg = pRast->m_QueuedWriteReg[RegNum];
        break;
    case RDPSREG_ZERO:
        MaxRegNum = 0;
        m_pReg = pRast->m_ZeroReg;
        break;
    case RDPSREG_ONE:
        MaxRegNum = 0;
        m_pReg = pRast->m_OneReg;
        break;
    case RDPSREG_TWO:
        MaxRegNum = 0;
        m_pReg = pRast->m_TwoReg;
        break;
    default:
        m_pReg = NULL;
        _ASSERT(FALSE,"RDPSRegister::SetReg - Unknown register type.");
        break;
    }
    if( RegNum > MaxRegNum )
    {
        _ASSERT(FALSE,"RDPSRegister::SetReg - Register number too high.");
    }
    return;
}

//-----------------------------------------------------------------------------
//
// Initialize 
// 
// - Copies pixel shader token stream from DDI token stream.
// - Counts the number of active texture stages for m_cActiveTextureStages.
// - Translates shader into "RISC" instruction set to be executed 
//   by refrast's shader VM
//
//-----------------------------------------------------------------------------
HRESULT
RDPShader::Initialize(
    RefDev* pRD, DWORD* pCode, DWORD ByteCodeSize, D3DCAPS8* pCaps )
{
    m_pRD = pRD;
    m_CodeSize = ByteCodeSize/4;    // bytecount -> dword count

    FLOAT   fMin = -(pCaps->MaxPixelShaderValue);
    FLOAT   fMax =  (pCaps->MaxPixelShaderValue);

    // ------------------------------------------------------------------------
    //
    // First pass through shader to find the number of instructions,
    // figure out how many constants there are.
    //
    // ------------------------------------------------------------------------
    {
        DWORD* pToken = pCode;
        pToken++;    // version token
        while (*pToken != D3DPS_END())
        {
            DWORD Inst = *pToken;
            if (*pToken++ & (1L<<31))    // instruction token
            {
                DPFERR("PixelShader Token #%d: instruction token error",_DWordCount());
                return E_FAIL;
            }
            if ( (Inst & D3DSI_OPCODE_MASK) == D3DSIO_COMMENT )
            {
                pToken += (Inst & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
                m_cInst++;
            }
            else if( (Inst & D3DSI_OPCODE_MASK) == D3DSIO_DEF )
            {
                m_cConstDefs++;
                pToken += 5;
            }
            else
            {
                if (*pToken & (1L<<31)) pToken++;    // destination param token
                while (*pToken & (1L<<31)) pToken++; // source param tokens
                m_cInst++;
            }
            if (_DWordCount() > (int)m_CodeSize)
            {
                DPFERR("PixelShader(%d tokens, %d expected): count error",_DWordCount(),m_CodeSize);
                return E_FAIL;
            }
        }
        pToken++; // step over END token
        if (_DWordCount() != (int)m_CodeSize)
        {
            DPFERR("PixelShader(%d tokens, %d expected): count error",_DWordCount(),m_CodeSize);
            return E_FAIL;
        }

        // make copy of original shader
        m_pCode = new DWORD[m_CodeSize];
        if (NULL == m_pCode)
            return E_OUTOFMEMORY;
        memcpy( m_pCode, pCode, ByteCodeSize );

        // allocate instruction array
        m_pInst = new PixelShaderInstruction[m_cInst];
        if (NULL == m_pInst)
            return E_OUTOFMEMORY;
        memset( m_pInst, 0x0, sizeof(PixelShaderInstruction)*m_cInst );

        m_pConstDefs = new ConstDef[m_cConstDefs];
        if (NULL == m_pConstDefs)
            return E_OUTOFMEMORY;
    }

    // ------------------------------------------------------------------------
    //
    // Second pass through shader to:
    //      - produce a list of instructions, each one including opcodes, 
    //        comments, and disassembled text for access by shader debuggers.
    //      - figure out the TSS # used (if any) by each instruction
    //      - figure out the max texture stage # used
    //      - figure out when the ref. pixel shader executor should
    //        queue writes up and when to flush the queue, in order to
    //        simulate co-issue.
    //      - figure out which texture coordinate sets get used
    //      - process constant DEF instructions into a list that can be
    //        executed whenever SetPixelShader is done.
    //
    // ------------------------------------------------------------------------
    {
        DWORD* pToken = m_pCode;
        PixelShaderInstruction* pInst = m_pInst;
        PixelShaderInstruction* pPrevious_NonTrivial_Inst = NULL;
        pToken++; // skip over version

        BOOL    bMinimizeReferencedTexCoords;

        if( (D3DPS_VERSION(1,3) >= *pCode) ||
            (D3DPS_VERSION(254,254) == *pCode ) )//legacy
        {
            bMinimizeReferencedTexCoords    = FALSE;
        }
        else
        {
            bMinimizeReferencedTexCoords    = TRUE;
        }


        UINT    CurrConstDef = 0;

        while (*pToken != D3DPS_END())
        {
            switch( (*pToken) & D3DSI_OPCODE_MASK )
            {
            case D3DSIO_COMMENT:
                pInst->Opcode = *pToken;
                pInst->pComment = (pToken+1);
                pInst->CommentSize = ((*pToken) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
                pToken += (pInst->CommentSize+1);
                pInst++;
                continue;
            case D3DSIO_DEF:
                {
                    pToken++;
                    m_pConstDefs[CurrConstDef].RegNum = (*pToken++) & D3DSP_REGNUM_MASK;

                    // clamp constants on input to range of values in pixel shaders
                    for( UINT i = 0; i < 4; i++ )
                    {
                        m_pConstDefs[CurrConstDef].f[i] = MAX( fMin, MIN( fMax, *(FLOAT*)pToken));
                        pToken++;
                    }

                    CurrConstDef++;
                    continue;
                }
            case D3DSIO_NOP:
                // get disasm string
                PixelShaderInstDisAsm( pInst->Text, 128, pToken, 0x0 );
                pInst->Opcode = *pToken++;
                pInst++;
                continue;
            }

            // get disasm string
            PixelShaderInstDisAsm( pInst->Text, 128, pToken, 0x0 );

            // get next instruction and parameters
            pInst->Opcode = *pToken++;

            pInst->SrcParamCount = 0;
            if (*pToken & (1L<<31))
            {
                pInst->DstParam = *pToken++;
            }
            while (*pToken & (1L<<31))
            {
                pInst->SrcParam[pInst->SrcParamCount++] = *pToken++;
            }


            // process TEX ops
            //
            BOOL bLegacyTexOp = FALSE;
            switch (pInst->Opcode & D3DSI_OPCODE_MASK)
            {
            default: break;
            case D3DSIO_TEXBEM_LEGACY:
            case D3DSIO_TEXBEML_LEGACY:
                bLegacyTexOp = TRUE;
               