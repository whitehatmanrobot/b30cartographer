NLINE LONG CompareExchange(
        volatile LONG *Address,
        LONG NewValue,
        LONG Value
    )
    {
#ifdef _X86_
        __asm
            {
            mov     ecx,Address                 // Load the address.
            mov     edx,NewValue                // Load the new value.
            mov     eax,Value                   // Load the value.
            lock    cmpxchg dword ptr[ecx],edx  // Update the value.
            }
#else
        return InterlockedCompareExchange(Address,NewValue,Value);
#endif
    }

    static INLINE LONG Decrement(
        volatile LONG *Address
    )
    {
#ifdef _X86_
    __asm
        {
        mov     ecx,Address                 // Load the address.
        mov     eax,-1                      // Load constant.
        lock    xadd dword ptr[ecx],eax     // Decrement value.
        dec     eax                         // Correct result.
        }
#else
    return InterlockedDecrement(Address);
#endif
    }

    static INLINE LONG Exchange(
        volatile LONG *Address,
        LONG NewValue
    )
    {
#ifdef _X86_
    __asm
        {
        mov     ecx,Address                 // Load the address.
        mov     eax,NewValue                // Load the new value.
        lock    xchg dword ptr[ecx],eax     // Exchange new value.
        }
#else
    return InterlockedExchange(Address,NewValue);
#endif
    }

    static INLINE LONG Increment(
        volatile LONG *Address
    )
    {
#ifdef _X86_
    __asm
        {
        mov     ecx,Address                 // Load the address.
        mov     eax,1                       // Load constant.
        lock    xadd dword ptr[ecx],eax     // Increment value.
        inc     eax                         // Correct result.
        }
#else
    return InterlockedIncrement(Address);
#endif
    }
};

#pragma warning (default: 4035)

/*****************************************************************************
 IMemAlloc
 Generic memory allocator interface
*****************************************************************************/
class IMemAlloc
{
public:    
    virtual void* Alloc(size_t size) = 0;
    virtual void  Free(void* memblock) = 0;
};

/*****************************************************************************
 CMemAlloc
 Global allocator
*****************************************************************************/
class CMemAlloc : public IMemAlloc
{
public:
    
    // Initializes memory allocator. Call this before anything else in the 
    // service
    bool Init();
    
    // Terminates memory allocator. Call this last in the service.
    void Term();

    // Allocates a block of memory
    void* Alloc(size_t size);
    
    // Releases a block of memory
    void Free(void* memblock);
};

/*****************************************************************************
 CDebugMemAlloc
 Same as CMemAlloc, but uses ultra hard-core (and ultra slow) debug heap
*****************************************************************************/
class CDebugMemAlloc : public IMemAlloc
{
public:
    
    virtual void* Alloc(size_t size)
    {
        return _Heap.New(size, NULL, false);
    }
    
    virtual void Free(void *memblock)
    {
        _Heap.Delete(memblock);
    }
    
protected:

    PAGE_HEAP _Heap;
};

/*****************************************************************************
 g_MemAlloc
 Is the global allocator and is going to be used for most stuff
*****************************************************************************/
extern CMemAlloc g_MemAlloc;


/*****************************************************************************
 USE_GLOBAL_ALLOC
 Want a class or structure to use g_MemAlloc.
 Just add USE_GLOBAL_ALLOC to a class declaration.
*****************************************************************************/
#define USE_GLOBAL_ALLOC \
    PVOID operator new( size_t cSize ) \
    { return (PVOID) g_MemAlloc.Alloc(cSize); } \
    \
    PVOID operator new[]( size_t cSize ) \
    { return (PVOID) g_MemAlloc.Alloc(cSize); } \
    \
    void operator delete( PVOID pObj ) \
    { g_MemAlloc.Free(pObj); } \
    \
    void operator delete[]( PVOID pObj ) \
    { g_MemAlloc.Free(pObj); }

/*****************************************************************************
  CFastLock
*****************************************************************************/
class CFastLock

{
public:

    CFastLock()
    {
        _lTid = 0;
    }

#if _DEBUG

    ~CFastLock()
    {
        DBGASSERT(_lTid == 0);
    }

#endif

    INLINE void Lock()
    {
        LONG lTid = (DWORD) ::GetCurrentThreadId();

        while(CInterlocked::CompareExchange(&_lTid, lTid, 0) != 0)
        {
			int i;
            for(i=0; i < MAXSPIN; i++)
            {
                if(_lTid == 0) break;
            }

            if(i == MAXSPIN)
                Sleep(0);
        }
    }

    INLINE void Unlock()
    {
        DBGASSERT(_lTid != 0);
        CInterlocked::Exchange(&_lTid,0);
    }
    
    bool IsLocked() const
    {
        return _lTid != 0;
    }

protected:

    enum {
        MAXSPIN=0xFFFF
    };

    volatile LONG _lTid;
};

/*****************************************************************************
  String Utilities
*****************************************************************************/
class AnsiStrCharTrait
{
public:    
    typedef char chartype;
    
    static int StringCbVPrintfEx(
        chartype*       pszDest,
        size_t          cbDest,
        chartype**      ppszDestEnd,
        size_t*         pcbRemaining,
        DWORD           dwFlags,
        const chartype* pszFormat,
        va_list         argList
    )
    {
        return ::StringCbVPrintfExA(pszDest, cbDest, ppszDestEnd, pcbRemaining, 
            dwFlags, pszFormat, argList);
    }
    
    static int CompareString(
        LCID            Locale,
        DWORD           dwCmpFlags,
        const chartype* lpString1,
        int             cchCount1,
        const chartype* lpString2,
        int             cchCount2
    )
    {
        return ::CompareStringA(Locale,dwCmpFlags,lpString1,cchCount1,lpString2,
            cchCount2);
    }
};

class UnicodeStrCharTrait
{
public:    
    typedef wchar_t chartype;
    
    static int StringCbVPrintfEx(
        chartype*       pszDest,
        size_t          cbDest,
        chartype**      ppszDestEnd,
        size_t*         pcbRemaining,
        DWORD           dwFlags,
        const chartype* pszFormat,
        va_list         argList
    )
    {
        return ::StringCbVPrintfExW(pszDest, cbDest, ppszDestEnd, pcbRemaining, 
            dwFlags, pszFormat, argList);
    }
    
    static int CompareString(
        LCID            Locale,
        DWORD           dwCmpFlags,
        const chartype* lpString1,
        int             cchCount1,
        const chartype* lpString2,
        int             cchCount2
    )
    {
        return ::CompareStringW(Locale,dwCmpFlags,lpString1,cchCount1,lpString2,
            cchCount2);
    }
};


template <class ct>
class TConstStr
{
public:    
    typedef typename ct::chartype chartype;
    
    TConstStr()
    {
        _szString = (chartype*) "\0\0";
        _wLength  = 0;
    }
    
    TConstStr(const TConstStr& str)
    {
        _szString = str._szString;
        _wLength  = str._wLength;
    }
    
    TConstStr(const chartype* psz)
    {
        _szString = (chartype*) psz;
        
        int iSize=0;
        while(_szString[iSize] != 0)
            iSize++;
            
        _wLength   = (WORD)iSize;
    }

    TConstStr(const chartype* psz, int iSize)
    {
        _szString = (chartype*) psz;
        _wLength  = (WORD)iSize;
        DBGASSERT(_szString[_wLength] == 0);
    }

    unsigned short GetLength() const
    {
        return _wLength;
    }

    int CompareTo(const chartype* psz)
    {
        int ret = ct::CompareString(LOCALE_SYSTEM_DEFAULT, 0, _szString, 
            _wLength, psz, -1);
        DBGASSERT(ret != 0);
        return ret - CSTR_EQUAL;
    }

    int CompareTo(const TConstStr& str)
    {
        int ret = ct::CompareString(LOCALE_SYSTEM_DEFAULT, 0, _szString, 
            _wLength, str._szString, str._wLength);
        DBGASSERT(ret != 0);
        return ret - CSTR_EQUAL;
    }
    
    int IgnoreCaseCompareTo(const chartype* psz)
    {
        int ret = ct::CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, _szString, 
            _wLength, psz, -1);
        DBGASSERT(ret != 0);
        return ret - CSTR_EQUAL;
    }

    int IgnoreCaseCompareTo(const TConstStr& str)
    {
        int ret = ct::CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, _szString, 
            _wLength, str._szString, str._wLength);
        DBGASSERT(ret != 0);
        return ret - CSTR_EQUAL;
    }
    
    const chartype* cstr() const
    {
        return (const chartype*) _szString;
    }
      
    // For some reason TStr cannot access these if they are protected. I'm
    // leaving them public for now. Ugly but not critical.
    WORD       _wLength;
    chartype*  _szString;

};

template <class ct>
class TStr : public TConstStr<ct>
{
public:
    ~TStr()
    {
        Term();
    }
    
    void Term()
    {
        if(_szString != NULL && !_fLocal)
        {
            _pMemAlloc->Free(_szString);
            _szString = NULL;
        }
    }
    
    void Reset()
    {
        DBGASSERT(_wCapacity > 0);
        _wLength     = 0;
        _szString[0] = (chartype)0;
    }
    
    void SetAutoGrow(bool fAutoGrow)
    {
        _fAutoGrow = fAutoGrow;
    }
    
    bool Concat(const chartype* psz, int cch)
    {
        bool fRet = true;
        
        unsigned short usBytesToCopy    = (unsigned short) cch;
        unsigned short usRemainingSpace = _wCapacity - _wLength - 1;
        
        if(usRemainingSpace < usBytesToCopy)
        {
            if(_fAutoGrow)
            {
                fRet = SetCapacity(__max(usBytesToCopy + 1, _wCapacity * 2 + 1));
                
                if(fRet)
                {
                    usRemainingSpace = _wCapacity - _wLength - 1;
                }
            }
            else
            {
                // Buffer too small. Copy only what we can fit in the remaining space.
                usBytesToCopy = usRemainingSpace;
                fRet = false;
            }
        }
        
        // Copy string
        for(unsigned short i=0; i < usBytesToCopy; i++)
        {
            _szString[_wLength + i] = psz[i];
        }
        
        // Null terminate and update length
        _wLength           += usBytesToCopy;
        _szString[_wLength] = (chartype)0;
        
        return fRet;
    }
    
    bool Concat(const chartype* psz)
    {
        bool fRet = true;
        
        unsigned short usCopied         = 0;
        unsigned short usRemainingSpace = _wCapacity - _wLength - 1;
        
        while(psz[usCopied] != (chartype)0)
        {
            // Watch _wCapacity. 
            if(usCopied >= usRemainingSpace)
            {
                // Buffer too small
                if(_fAutoGrow)
                {
                    fRet = SetCapacity(_wCapacity * 2 + 1);
                    
                    if(fRet)
                    {
                        usRemainingSpace = _wCapacity - _wLength - 1 + usCopied;
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    fRet = false;
                    break;
                }
            }
                
            _szString[_wLength] = psz[usCopied];
            usCopied++;
            _wLength++;
        }
        
        // Null terminate and update length
        _szString[_wLength] = (chartype)0;
        
        return fRet;
    }
    
    bool Concat(const TConstStr<ct>& str)
    {
        bool fRet = true;
        
        unsigned short usBytesToCopy    = str._wLength;
        unsigned short usRemainingSpace = _wCapacity - _wLength - 1;
        
        if(usRemainingSpace < usBytesToCopy)
        {
            if(_fAutoGrow)
            {
                fRet = SetCapacity(__max(usBytesToCopy + 1, _wCapacity * 2 + 1));
                
                if(fRet)
                {
                    usRemainingSpace = _wCapacity - _wLength - 1;
                }
            }
            else
            {
                // Buffer too small. Copy only what we can fit in the remaining space.
                usBytesToCopy = usRemainingSpace;
                fRet = false;
            }
        }
        
        // Copy string
        for(unsigned short i=0; i < usBytesToCopy; i++)
        {
            _szString[_wLength + i] = str._szString[i];
        }
        
        // Null terminate and update length
        _wLength           += usBytesToCopy;
        _szString[_wLength] = (chartype)0;
        
        return fRet;
    }
    
    bool Format(const chartype* psz, ...)
    {
        bool fRet = true;
        
        va_list args;
        va_start(args, psz);
        fRet = FormatWithVaList(psz,args);
        va_end(args);
        
        return fRet;
    }
    
    bool FormatWithVaList(const chartype* psz, va_list args)
    {
        bool fRet = true;
        
        unsigned short usRemainingSpace = _wCapacity - _wLength;
        
        chartype* pDestEnd;
        
        HRESULT hr = ct::StringCbVPrintfEx(_szString + _wLength, 
            _wCapacity - _wLength, &pDestEnd, NULL, 0, psz, args);
            
        if(SUCCEEDED(hr))
        {
            _wLength += (WORD) (pDestEnd - (_szString + _wLength));
        }
        else
        {
            if(STRSAFE_E_INSUFFICIENT_BUFFER == hr)
            {
                if(_fAutoGrow)
                {
                    if(_wCapacity < MAXIMUM_CAPACITY && SetCapacity(__min(_wCapacity * 2 + 1, 100)))
                    {
                        fRet = FormatWithVaList(psz,args);
                    }
                    else
                    {
                        fRet = false;
                        _szString[_wLength] = (chartype)0;
                    }
                }
                else
                {
                    fRet = false;
                    _wLength += (WORD) (pDestEnd - (_szString + _wLength));
                }
            }
            else
            {
                fRet = false;
                _szString[_wLength] = (chartype) 0;
                _wLength = 0;
            }
        }
    
        return fRet;
    }
    
    bool Assign(const chartype* psz)
    {
        Reset();
        return Concat(psz);
    }
    
    bool Assign(const TConstStr<ct>& str)
    {
        Reset();
        return Concat(str); 
    }
    
    bool SetCapacity(WORD wCapacity)
    {
        bool fRet            = true;
        chartype* pNewBuffer = NULL;
        
        if(_wCapacity < wCapacity)
        {
            // Allocate new buffer
            chartype* pNewBuffer = (chartype*)_pMemAlloc->Alloc(wCapacity * sizeof(chartype));
            if(NULL == pNewBuffer)
            {
                fRet = false;
                goto lDone;
            }
            
            // Copy string to new buffer with null terminator
            CopyMemory(pNewBuffer, _szString, _wLength + 1);
            
            // Release previous buffer
            if(_szString != NULL && !_fLocal)
                _pMemAlloc->Free(_szString);
                
            // Replace previous buffer with new buffer
            _szString  = pNewBuffer;
            _wCapacity = wCapacity;
            _fLocal    = false;
            pNewBuffer = NULL;
        }
        
    lDone:
        if(pNewBuffer != NULL)
            _pMemAlloc->Free(pNewBuffer);
            
        return fRet;
    }
    
protected:

    TStr(chartype* pNewBuffer, int iCapacity, bool fConst)
    {
        _fLocal    = true;
        _fAutoGrow = false;
        _szString  = pNewBuffer;
        _wCapacity = (WORD) iCapacity;
        _pMemAlloc = &g_MemAlloc;
        
        Reset();
    }
    
    enum
    {
        MAXIMUM_CAPACITY = 60000
    };

    bool       _fLocal;
    bool       _fAutoGrow;
    WORD       _wCapacity;
    IMemAlloc* _pMemAlloc;
};

template <class ct, int c>
class TStackStr : public TStr<ct>
{
public:
    
    TStackStr() : TStr<ct>(_rgBuffer, c+1, false)
    {
    }
    
    TStackStr(const chartype* psz) : TStr<ct>(_rgBuffer, c+1, false)
    {
        Assign(psz);
    }
    
    TStackStr(const TConstStr<ct>& str) : TStr<ct>(_rgBuffer, c+1, false)
    {
        Assign(str);
    }

protected:
    
    chartype _rgBuffer[c+1];
};

typedef TStr<AnsiStrCharTrait>            CStr;
typedef TConstStr<AnsiStrCharTrait>       CConstStr;
typedef TStackStr<AnsiStrCharTrait, 60>   CVerySmallStr;
typedef TStackStr<AnsiStrCharTrait, 251>  CSmallStr;
typedef TStackStr<AnsiStrCharTrait, 4001> CLargeStr;

typedef TStr<UnicodeStrCharTrait>            CWStr;
typedef TConstStr<UnicodeStrCharTrait>       CConstWStr;
typedef TStackStr<UnicodeStrCharTrait, 60>   CVerySmallWStr;
typedef TStackStr<UnicodeStrCharTrait, 251>  CSmallWStr;
typedef TStackStr<UnicodeStrCharTrait, 4001> CLargeWStr;

#define REFANDSIZE(x) x,(ARRAY_SIZE(x)-1)
#define CONSTSTR(x) CConstStr(REFANDSIZE(x))
#define CONSTWSTR(x) CConstWStr(REFANDSIZE(x))

/*****************************************************************************
  Error Utilities
  Macros and classes used in LBS to manage errors, error messages and all 
  kinds of error stuff
*****************************************************************************/

#define STRINGIZE_IT1(x) #x
#define STRINGIZE_IT(x) STRINGIZE_IT1(x)
#define GLOBAL_ERROR_HEADER \
    "-------------------------------------" \
    "\n"__FILE__","STRINGIZE_IT(__LINE__)"\n"__FUNCTION__"\n" 
    

class CGlobalError
{
USE_GLOBAL_ALLOC;
public:
    
    // Init
    // Call this method on a thread right after creating it. It will 
    // initialize the error framework for the thread. Don't try to use the 
    // error framework on the thread before calling Init. Don't call Init
    // on the same thread more than once. 
    // Returns true if succeeded and false if failed.
    static bool Init();
    
    // Term
    // Call Term on a thread right before terminating it. Don't use the error 
    // framework after Term has been called.
    static void Term();
    
    // Reset
    // Resets message. Should be called at the beginning of a new request and
    // stuff like that.
    static void Reset();
    
    // SetMessage
    // Sets a new message
    static void SetMessage(LPCSTR pszMsg, ...);
    
    // AddMessage
    // Add to the current existing message
    static void AddMessage(LPCSTR pszMsg, ...);
    
    // GetCurrentMessage
    // Get current message
    static LPCSTR GetCurrentMessage();
    
    static void ProcessComError();
    
protected:

    CGlobalError()
    {
    }
    
    static void ProcessErrorInfo(IErrorInfo* pErrorInfo);

    CLargeStr _strMessage;
    static DWORD _dwTlsSlotLbsError;
};

/*****************************************************************************
 CLFStack
 Lock-free thread-safe stack
*****************************************************************************/
template <int n=0>
struct TSingleLink
{
    TSingleLink()
    {
        pNext = NULL;
    }
    
    TSingleLink<n>* pNext;
};

typedef TSingleLink<0> CSingleLink;

template <int n=0>
struct TDoubleLink
{
    TDoubleLink()
    {
        pPrev = NULL;
        pNext = NULL;
    }
    
    TDoubleLink<n>* pPrev;
    TDoubleLink<n>* pNext;
};

typedef TDoubleLink<0> CDoubleLink;


class CLFStackBase
{
public:
    
    // CLFStack
    CLFStackBase()
    {
        _StackEndNode.pNext = NULL;
        _pSingleLinkHead     = &_StackEndNode;
        _lCount             = 0;
    }

    // ~CLFStack
    ~CLFStackBase()
    {
        // It's the programmer's responsability to empty the stack before
        // releasing it. 
        DBGASSERT(_pSingleLinkHead == &_StackEndNode);
    }
    
    // Reset
    // Removes all items from the stack. It DOES NOT release the individual 
    // items. This method is NOT thread-safe.
    void Reset();

    // Push 
    // Stack an item on the stack. This method is thread-safe.
    bool Push(CSingleLink* pEntry);
    
    // Pop
    // Remove and return the top element from the stack. This method is 
    // thread-safe.
    CSingleLink* Pop();

    bool IsEmpty()
    {
        return (_pSingleLinkHead == &_StackEndNode);
    }
    
    // GetCount
    LONG GetCount() const { return _lCount; }

#if _DEBUG

    void Verify()
    {
        volatile CSingleLink* p = _pSingleLinkHead;
        
        while(p != &_StackEndNode)
            p = p->pNext;  
    }
    
#endif    

protected:

    // Pointer to the stack
    volatile CSingleLink * _pSingleLinkHead;

    // Dummy Node. It will indicate the end of the stack.
    CSingleLink _StackEndNode;
    
    // Number of entries in the stack
    volatile LONG _lCount;

    CFastLock _lock;
};

template <class c, int n=0>
class TLFStack
{
public:
    
    typedef TSingleLink<n> LINK;
    
    // Reset
    // Removes all items from the stack. It DOES NOT release the individual 
    // items. This method is NOT thread-safe.
    void Reset()
    {
        _stack.Reset();
    }

    // Push 
    // Stack an item on the stack. This method is thread-safe.
    bool Push(LINK* pEntry)
    {
        void* pLink = (LINK*) pEntry;
        return _stack.Push((CSingleLink*)pLink);
    }
    
    // Pop
    // Remove and return the top element from the stack. This method is 
    // thread-safe.
    c* Pop()
    {
        LINK* pLink = reinterpret_cast<LINK*>(_stack.Pop());
        return (c*)pLink;
    }
    
    // GetCount
    LONG GetCount() const { return _stack.GetCount(); }
    
#if _DEBUG

    void Verify()
    {
        _stack.Verify();
    }

#endif

protected:

    CLFStackBase _stack;    
};


/*****************************************************************************
 CFixedSizeMemPool
 Memory pool for fixed size objects. 
*****************************************************************************/
class CFixedSizeMemPool : public IMemAlloc
{
public:
    
    CFixedSizeMemPool()
        : _cbObject(0), _fExpand(false), _pAlloc(NULL)
    {
    }
    
#if _DEBUG
    _declspec(noinline) ~CFixedSizeMemPool()
    {
        DBGASSERT(_pool.Pop() == NULL && "Memory pool was not terminated correctly");
    }
#endif    
    
    // Init
    // Populate the pool with an initial amount of objects
    bool Init(LPCSTR pszName, DWORD cbObject, DWORD cObjects, bool fExpand, IMemAlloc* pAlloc);
    
    // Term
    // Terminate the pool and release resources.
    void Term();
    
    // Alloc
    // Allocate an object from the pool. If the pool is empty and fExpand=true
    // a new object will be allocated using the default memory allocator.
    virtual void* Alloc(size_t size);
    
    // Free
    // Returns an object to the pool
    virtual void Free(void* memblock);
    
#if _DEBUG

    void Verify()
    {
        _pool.Verify();
    }

#endif
    
protected:

    void* AllocNewEntry()
    {
        return _pAlloc->Alloc(_cbObject);
    }
    
    void FreeEntry(void* memblock)
    {
        _pAlloc->Free(memblock);
    }

    TLFStack<CSingleLink> _pool;
    char _szName[60];
    DWORD _cbObject;
    bool _fExpand;
    IMemAlloc* _pAlloc;
};

#define MEM_POOL_DECLARE() \
    public: \
    static CFixedSizeMemPool __mempool; \
    \
    PVOID operator new( size_t cSize ) \
    { return (PVOID) __mempool.Alloc(cSize); } \
    \
    PVOID operator new[]( size_t cSize ) \
    { DBGASSERT(!"Not supported"); return (PVOID) NULL; } \
    \
    void operator delete( PVOID pObj ) \
    { __mempool.Free(pObj); } \
    \
    void operator delete[]( PVOID pObj ) \
    { DBGASSERT(!"Not supported"); return; }
    
#define MEM_POOL_DEFINE(owner) \
    CFixedSizeMemPool owner::__mempool;
    
#define MEM_POOL_INIT(owner,count,expand) \
    owner::__mempool.Init(#owner,sizeof(owner),count,expand,&g_MemAlloc);
    
#define MEM_POOL_TERM(owner) \
    owner::__mempool.Term();

template <class c>
class TEasyLFStack 
{
public:

    // Init
    // Initialize the data structure
    bool Init(
        LPCSTR pszName, 
        int cObjects, 
        bool fExpand, 
        IMemAlloc* pAlloc
    )
    {
        return _pool.Init(pszName,sizeof(data_ref_t),cObjects,fExpand,pAlloc);
    }
    
    // Term
    // Releases resources
    void Term()
    {
        _pool.Term();
    }
    
    // Reset
    // Removes all items from the stack. It DOES NOT release the individual 
    // items. This method is NOT thread-safe.
    void Reset()
    {
        data_ref_t* pDataRef
        
        while((pDataRef = (data_ref_t*) _stack.Pop()) != NULL)
            FreeDataRef(pDataRef);
    }

    // Push 
    // Stack an item on the stack. This method is thread-safe.
    bool Push(c* pEntry)
    {
        data_ref_t* pDataRef = AllocDataRef();
        if(NULL == pDataRef)
            return false;
        
        pDataRef->pData = (c*) pEntry;
        
        if(!_stack.Push((CSingleLink*)pDataRef))
        {
            FreeDataRef(pDataRef);
            return false;
        }
        
        return true;
    }
    
    // Pop
    // Remove and return the top element from the stack. This method is 
    // thread-safe.
    c* Pop()
    {
        data_ref_t* pLink = (data_ref_t*) _stack.Pop();
        
        if(pLink != NULL)
        {
            c* pData = pLink->pData;
            FreeDataRef(pLink);
            return pData;
        }
        else
        {
            return NULL;
        }
    }
    
    // GetCount
    LONG GetCount() const { return _stack.GetCount(); }
    
protected:

    struct data_ref_t : public CSingleLink
    {
        c* pData;
    };
    
    data_ref_t* AllocDataRef()
    {
        return new (_pool.Alloc(sizeof(data_ref_t))) data_ref_t;
    }
    
    void FreeDataRef(data_ref_t* pDataRef)
    {
        pDataRef->~data_ref_t();
        _pool.Free(pDataRef);
    }
    
    CFixedSizeMemPool _pool;
    CLFStackBase _stack;
};

class CListBase
{
public:

    CListBase() 
    {
        _Head.pPrev = NULL;
        _Head.pNext = &_Tail;
        _Tail.pPrev = &_Head;
        _Tail.pNext = NULL;
        _lCount = 0;
    }

    ~CListBase()
    {
        DBGASSERT(_lCount == 0);
    }

    void Enqueue(CDoubleLink* pNewNode);

    CDoubleLink* Dequeue();
    
    void Push(CDoubleLink* pNewNode)
    {
        InsertBefore(_Head.pNext, pNewNode);
    }
    
    CDoubleLink* Pop()
    {
        return Dequeue();
    }

    void Reset();

    LONG GetCount() const { return _lCount; }
    
    class Iterator
    {
    public:
   
        Iterator() :
            _pList(NULL),
            _pLink(NULL)
        {}
        
        CDoubleLink* Next()
        {
            if(_pLink != &_pList->_Tail)
            {
                _pLink = _pLink->pNext;
                
                if(_pLink != &_pList->_Tail)
                    return _pLink;
            }
            
            return NULL;
        }

        CDoubleLink* Prev()
        {
            if(_pLink != &_pList->_Head)
            {
                _pLink = _pLink->pPrev;
                
                if(_pLink != &_pList->_Head)
                    return _pLink;
            }
            
            return NULL;
        }
        
        CDoubleLink* Remove()
        {
            CDoubleLink* pRet = NULL;
            
            if(_pLink == &_pList->_Head ||
               _pLink == &_pList->_Tail)
            {
                return NULL;
            }
             
            pRet = _pLink;
            _pLink = _pLink->pPrev;
            _pList->Remove(pRet);
            return pRet;
        }
        
    protected:
    
        friend CListBase;
        
        void Attach(CListBase* pList, CDoubleLink* pLink)
        {
            _pList = pList;
            _pLink = pLink;
        }
        
        CListBase* _pList;
        CDoubleLink* _pLink;
    };

    void Begin(Iterator* pit)
    {
        pit->Attach(this, &_Head);
    }
    
    void End(Iterator* pit)
    {
        pit->Attach(this, &_Tail);
    }
    
protected:

    void InsertBefore(CDoubleLink* pRef, CDoubleLink* pNewNode)
    {
        DBGASSERT(pRef != &_Head);
        DBGASSERT(pNewNode->pPrev == NULL && pNewNode->pNext == NULL);
        
        pNewNode->pPrev    = pRef->pPrev;
        pNewNode->pNext    = pRef;
        pRef->pPrev->pNext = pNewNode;
        pRef->pPrev        = pNewNode;
        
        _lCount++;
    }
    
    void Remove(CDoubleLink* pRef)
    {
        DBGASSERT(pRef != &_Head);
        DBGASSERT(pRef != &_Tail);
        
        pRef->pPrev->pNext = pRef->pNext;
        pRef->pNext->pPrev = pRef->pPrev;
        
        pRef->pPrev = NULL;
        pRef->pNext = NULL;
        
        _lCount--;
    }

    friend Iterator;
    
    CDoubleLink _Head;
    CDoubleLink _Tail;
    volatile LONG _lCount;
};

template <class c, int n=0>
class TList
{
public:
    
    typedef TDoubleLink<n> LINK;
    
    void Enqueue(TDoubleLink<n>* pEntry)
    {
        void* pLink = (LINK*) pEntry;
        _list.Enqueue((CDoubleLink*)pLink);
    }
    
    c* Dequeue()
    {
        LINK* pLink = reinterpret_cast<LINK*>(_list.Dequeue());
        return (c*)pLink;
    }
    
    void Push(c* pEntry)
    {
        void* pLink = (LINK*) pEntry;
        _list.Push((CDoubleLink*)pLink);
    }
    
    c* Pop()
    {
        LINK* pLink = reinterpret_cast<LINK*>(_list.Pop());
        return (c*)pLink;
    }
    
    void Reset()
    {
        _list.Reset();
    }

    LONG GetCount() const { return _list.GetCount(); }
    
    class Iterator
    {
    public:
   
        c* Next()
        {
            LINK* pLink = reinterpret_cast<LINK*>(_it.Next());
            return (c*) pLink;
        }
        
        c* Prev()
        {
            LINK* pLink = reinterpret_cast<LINK*>(_it.Prev());
            return (c*) pLink;
        }

        c* Remove()
        {
            LINK* pLink = reinterpret_cast<LINK*>(_it.Remove());
            return (c*) pLink;
        }
      
    protected:
    
        friend TList;
        
        CListBase::Iterator _it;
    };
    
    void Begin(Iterator* pit)
    {
        _list.Begin(&pit->_it);
    }
    
    void End(Iterator* pit)
    {
        _list.End(&pit->_it);
    }
    
protected: 

    friend Iterator;

    CListBase _list;
};

template <class c>
class TEasyList
{
public:
    
    // Init
    // Initialize the data structure
    bool Init(
        LPCSTR pszName, 
        int cObjects, 
        bool fExpand, 
        IMemAlloc* pAlloc
    )
    {
        return _pool.Init(pszName,sizeof(data_ref_t),cObjects,fExpand,pAlloc);
    }
    
    // Term
    // Releases resources
    void Term()
    {
        _pool.Term();
    }

    void Reset()
    {
        data_ref_t* pDataRef
        
        while((pDataRef = (data_ref_t*) _list.Dequeue()) != NULL)
            ReleaseDataRef(pDataRef);
    }
    
    bool Enqueue(c entry)
    {
        data_ref_t* pDataRef = AllocDataRef();
        
        if(NULL == pDataRef)
            return false;
        
        pDataRef->data = entry;
        
        _list.Enqueue((CDoubleLink*)pDataRef);
        
        return true;
    }
    
    bool Dequeue(c* pEntry)
    {
        data_ref_t* pLink = (data_ref_t*) _list.Dequeue();
        
        if(pLink != NULL)
        {
            *pEntry = pLink->data;
            FreeDataRef(pLink);
            return true;
        }
        else
        {
            return false;
        }
    }
    
    bool Push(c entry)
    {
        data_ref_t* pDataRef = AllocDataRef();
        
        if(NULL == pDataRef)
            return false;
        
        pDataRef->data = entry;
        
        _list.Push((CDoubleLink*)pDataRef);
        
        return true;
    }
    
    bool Pop(c* pEntry)
    {
        data_ref_t* pLink = (data_ref_t*) _list.Dequeue();
        
        if(pLink != NULL)
        {
            *pEntry = pLink->data;
            FreeDataRef(pLink);
            return true;
        }
        else
        {
            return false;
        }
    }

    LONG GetCount() const { return _list.GetCount(); }
    
protected: 

    struct data_ref_t : public CDoubleLink
    {
        c data;
    };
    
    data_ref_t* AllocDataRef()
    {
        return new (_pool.Alloc(sizeof(data_ref_t))) data_ref_t;
    }
    
    void FreeDataRef(data_ref_t* pDataRef)
    {
        pDataRef->~data_ref_t();
        _pool.Free(pDataRef);
    }
    
    CFixedSizeMemPool _pool;
    CListBase _list;
};

/*****************************************************************************
 CArenaMemAlloc
 Memory pool for fixed size objects. 
*****************************************************************************/
class CArenaMemAlloc : public IMemAlloc
{
public:
    
    // Init
    // Must be called at the beginning of the application before it can be
    // used.
    static bool GlobalInit(DWORD cbPage, DWORD cInitPages, bool fExpand);
    
    // Term
    // Call it at the end of the application to release global resources.
    static void GlobalTerm();
    
    CArenaMemAlloc()
    {
        _pCurrentPage = NULL;
        _cbUsed       = 0;
    }
    
    virtual ~CArenaMemAlloc();
    
    void Term();
    
    // Alloc a chunk of memory 
    virtual void* Alloc(size_t size);
    
    virtual void Free(void* memblock);
    
    void Reset()
    {
        // Release all pages - 1
        while(_pCurrentPage != NULL && _pCurrentPage->pNext != NULL)
        {
            memory_page_t* pNext = _pCurrentPage->pNext;        
            _pool.Free(_pCurrentPage);
            _pCurrentPage = pNext;
        }
        _cbUsed       = 0;    
    }

    DWORD GetUsed() const
    {
        return _cbUsed;
    }

#if _TEST
    
    BYTE* GetPointerToCurrentPage() const
    {
        if(_pCurrentPage != NULL)
            return _pCurrentPage->rgBuffer;
        else
            return NULL;
    }
    
    DWORD GetPageSize() const 
    {
        return _cbPage;
    }

#endif

protected:
    
    struct memory_page_t
    {
        memory_page_t* pNext;
        BYTE rgBuffer[1];
    };
    
    memory_page_t*           _pCurrentPage; // Pointer to current page
    DWORD                    _cbUsed; // Bytes used in the current page
    
    static DWORD             _cbPage; // Size in bytes of each page
    static CFixedSizeMemPool _pool; // Memory pool
    
};

inline void *__cdecl operator new(
   size_t count, 
   CArenaMemAlloc& alloc
)
{
    return alloc.Alloc(count);
}

inline void __cdecl operator delete(
   void* memblock,
   CArenaMemAlloc& alloc
)
{
    return; //no-op
}


/*****************************************************************************
 CLFQueue
*****************************************************************************/
class CLFQueue
{
public:
    
    CLFQueue()
    {
        _pHead = NULL;
        _pTail = NULL;
        _lCount   = 0;
    }

    bool isEmpty()
    {
        return (_pHead == NULL);
    }

    bool Init(LPCSTR pszName, int cObjects, bool fExpand, IMemAlloc* pAlloc);
    
    void Term();
    
    bool Enqueue(void* pData);
    
    void* Dequeue();
    
    LONG GetCount() const { return _lCount; }

protected:
  
    struct node_t
    {
        void* pData;
        node_t * pNext;
    };
    
    node_t* NewNode()
    {
        return (node_t*) _freeList.Alloc(sizeof(node_t));
    }
    
    void FreeNode(node_t* node)
    {
        _freeList.Free(node);
    }
    
    
    volatile node_t * _pHead;
    volatile node_t * _pTail;
    CFixedSizeMemPool  _freeList;   
    volatile LONG      _lCount;
    CFastLock _lock;
};


/*****************************************************************************
  CArrayBase
  Don't use this. Use TArray instead.
*****************************************************************************/
class CArrayBase
{
public:

    ~CArrayBase()
    {
        Term();
    }

    void Term()
    {
        if(_pData != NULL && _pData != _pLocalData)
        {
            _pAlloc->Free(_pData);
            _pData = NULL;
        }
    }

    bool SetAllocator(IMemAlloc* pAlloc);

    // GetSize
    // Return the size of the array
    int GetSize() const
    {
        return _iSize;
    }
    
    // Grow
    // Grows the array, if necessary, to a new capacity
    bool Grow(int iNewCapacity);
    
    // SetSize
    // Use it to manually set the size of the array
    bool SetSize(int iSize);

protected:

    CArrayBase(int iDataSize, int iCapacity, void* pLocalData) : 
        _pLocalData(pLocalData),
        _pData(pLocalData),
        _iDataSize(iDataSize),
        _iCapacity(iCapacity),
        _iSize(0),
        _pAlloc(&g_MemAlloc)
    {
    }

    void*      _pLocalData;
    void*      _pData;
    int        _iDataSize;
    int        _iCapacity;
    volatile int _iSize;
    IMemAlloc* _pAlloc;
};

/*****************************************************************************
  TArray
  Generic array. 
*****************************************************************************/
template <
    class DATATYPE, // Type of the data stored in the array
    int CAPACITY    // Initial capacity of the array
>
class TArray : public CArrayBase
{
public:
    
    INLINE TArray() : CArrayBase(sizeof(DATATYPE), CAPACITY, _rgLocalData)
    {
    }
    
    INLINE void Set(int iNdx, DATATYPE data)
    {
        DBGASSERT(iNdx < _iSize);
        ((DATATYPE*)_pData)[iNdx] = data;
    }

    INLINE DATATYPE Get(int iNdx)
    {
        DBGASSERT(iNdx < _iSize);
        return ((DATATYPE*)_pData)[iNdx];
    }

    INLINE bool Add(DATATYPE data)
    {
        if(SetSize(_iSize+1))
        {
            Set(_iSize-1, data);
            return true;
        }
        else
        {
            return false;
        }
    }
    
    // Inherited from CArrayBase:
    //   int GetSize()
    //   bool SetSize(int iSize) 

protected:

    DATATYPE  _rgLocalData[CAPACITY];
};


/*
    So we are making sure this hash table class works on 64 bit. 
    However, we are going to leave the hash table with a maximum entries of 2^32 until i find out that i need more than that.
*/
template <class KEYTYPE>
class TDefaultHashClass
{
public:
    
    INLINE DWORD GetHash(KEYTYPE key)
    {
        static const DWORD largest_prime_dword = 4294967279;
        return (DWORD) ((SIZE_T)key % largest_prime_dword);
    }
    
    INLINE bool IsEqual(KEYTYPE keyA, KEYTYPE keyB)
    {
        return keyA == keyB;
    }
};

int THashtableGetPrime(DWORD dwTarget);

template <
    class KEYTYPE,
    class DATATYPE,
    class HASHCLASS = TDefaultHashClass<KEYTYPE>
>
class THashtable
{
public:
    
//     struct KEY_DATA_PAIR
//     {
//         KEYTYPE         key;
//         DATATYPE        data;
//         KEY_DATA_PAIR*  pNext;
//     };
    
    THashtable() :
        _pSlots(NULL), 
        _fLocal(false), 
        _loadFactor(1.00),
        _dwCapacity(0),
        _dwMaxCount(0),
        _dwCount(0),
        _pAlloc(&g_MemAlloc)
    {
    }
    
    ~THashtable()
    {
        Term();
    }

    void Term()
    {
        if(!_fLocal && _pSlots != NULL)
        {
            _pAlloc->Free(_pSlots);
            _pSlots = NULL;
        }
    }

    
    void SetAllocator(IMemAlloc* pAlloc)
    {
        if((_pData == NULL || _fLocal) && _dwCount == 0)
        {
            _pAlloc = pAlloc;
            return true;
        }
        else
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER " Cannot set allocator after array has been used");
            return false;
        }
    }
    
    void SetLoadFactor(float lf)
    {
        DBGASSERT(lf > 0.1 && lf <= 1.0);
        _loadFactor = lf;
    }
    
    bool Set(KEYTYPE key, DATATYPE data)
    {
        if(_dwCount+1 >= _dwMaxCount)
        {
            if(!Grow(_dwCapacity*2 + 1))
                return false;
        }
        
        DWORD dwIdealSlot = HASHCLASS().GetHash(key) % _dwCapacity;
        DWORD dwSlot      = dwIdealSlot;
        
        while(_pSlots[dwSlot].dwIdealSlot != AVAILABLE && !HASHCLASS().IsEqual(key, _pSlots[dwSlot].key))
        {
            dwSlot = (dwSlot + 1) % _dwCapacity;
        }
        
        if(_pSlots[dwSlot].dwIdealSlot == AVAILABLE)
            _dwCount++;
        
        _pSlots[dwSlot].key         = key;
        _pSlots[dwSlot].data        = data;
        _pSlots[dwSlot].dwIdealSlot = dwIdealSlot;
        
        return true;
    }
    
    DATATYPE* GetReference(KEYTYPE key)
    {
        if(_dwCount == 0)
            return NULL;
        
        DWORD dwSlot = HASHCLASS().GetHash(key) % _dwCapacity;
        
        while(_pSlots[dwSlot].dwIdealSlot != AVAILABLE)
        {
            if(HASHCLASS().IsEqual(key, _pSlots[dwSlot].key))
            {
                return &_pSlots[dwSlot].data;
            }
           
            dwSlot = (dwSlot + 1) % _dwCapacity;
        }
        
        return NULL;
    }
    
    bool Get(KEYTYPE key, DATATYPE* pData)
    {
        if(_dwCount == 0)
            return false;
        
        DATATYPE* pDataRef;
        
        if((pDataRef = GetReference(key)) != NULL)
        {
            if(pData != NULL)
            {
                *pData = *pDataRef;
            }
            
            return true;
        }
        else
        {
            return false;
        }
    }
    
    bool Remove(KEYTYPE key, DATATYPE* pData)
    {
        if(_dwCount == 0) // BUGBUG: Nasty bug on boundaries
            return false;
        
        DWORD dwSlot = HASHCLASS().GetHash(key) % _dwCapacity;
        
        while(_pSlots[dwSlot].dwIdealSlot != AVAILABLE)
        {
            if(HASHCLASS().IsEqual(key, _pSlots[dwSlot].key))
            {
                break;
            }
           
            dwSlot = (dwSlot + 1) % _dwCapacity;
        }
        
        if(AVAILABLE == _pSlots[dwSlot].dwIdealSlot)
            return false;
            
        if(pData != NULL)
            *pData = _pSlots[dwSlot].data;
            
        DWORD dwEmptySlot = dwSlot;
        dwSlot = (dwSlot + 1) % _dwCapacity;

        int nCurrentDistance = 0;
        int nNewDistance     = 0;
        
        while(_pSlots[dwSlot].dwIdealSlot != AVAILABLE)
        {
            if(_pSlots[dwSlot].dwIdealSlot != dwSlot)
            {
                //You can only scan to the right
               nCurrentDistance = (dwSlot      >= _pSlots[dwSlot].dwIdealSlot)? dwSlot      - _pSlots[dwSlot].dwIdealSlot: (_dwCapacity - _pSlots[dwSlot].dwIdealSlot) + dwSlot;
               nNewDistance     = (dwEmptySlot >= _pSlots[dwSlot].dwIdealSlot)? dwEmptySlot - _pSlots[dwSlot].dwIdealSlot: (_dwCapacity - _pSlots[dwSlot].dwIdealSlot) + dwEmptySlot;
                
               if (nNewDistance < nCurrentDistance)
               {
                   _pSlots[dwEmptySlot].key         = _pSlots[dwSlot].key;
                   _pSlots[dwEmptySlot].data        = _pSlots[dwSlot].data;
                   _pSlots[dwEmptySlot].dwIdealSlot = _pSlots[dwSlot].dwIdealSlot;
                    
                   dwEmptySlot = dwSlot;
               }
            }
            
            dwSlot = (dwSlot + 1) % _dwCapacity;
        }   
        
        _pSlots[dwEmptySlot].dwIdealSlot = AVAILABLE;    
        _dwCount--;

        return true;
    }
    
    bool Grow(DWORD dwTargetCapacity)
    {
        bool fRet          = true;
        slot_t* pNewBuffer = NULL;
        
        if(dwTargetCapacity > _dwCapacity)
        {
            // Allocate a new buffer
            DWORD dwNewCapacity = THashtableGetPrime(dwTargetCapacity);
            
            pNewBuffer = (slot_t*) _pAlloc->Alloc(dwNewCapacity * sizeof(slot_t));
            if(NULL == pNewBuffer)
            {
                fRet = false;
                goto lDone;
            }
            
            // Use a temporary hashtable object to rehash the data
            THashtable temphash(pNewBuffer, dwNewCapacity);
            for(DWORD i=0; i < _dwCapacity; i++)
            {
                // Shortcut
                if(_dwCount == temphash.GetCount())
                    break;
                    
                if(_pSlots[i].dwIdealSlot != AVAILABLE)
                    temphash.Set(_pSlots[i].key, _pSlots[i].data);
            }
            
            // Replace the previous buffer with the new one
            if(_pSlots != NULL && !_fLocal)
                _pAlloc->Free(_pSlots);
            
            _pSlots     = pNewBuffer;
            _fLocal     = false;
            _dwCapacity = dwNewCapacity;
            _dwMaxCount = (DWORD)(_dwCapacity * _loadFactor) - 1;
            
            pNewBuffer  = NULL;
        }
        
    lDone:
    
        if(pNewBuffer != NULL)
        {
            _pAlloc->Free(pNewBuffer);
            pNewBuffer = NULL;
        }
            
        if(!fRet)
            CGlobalError::AddMessage(GLOBAL_ERROR_HEADER "(%d)", dwTargetCapacity);
            
        return fRet;
    }
    
    void Reset()
    {
        for(int i=0; i < (int)_dwCapacity; i++)
        {
            _pSlots[i].dwIdealSlot = AVAILABLE;
        }
        
        _dwCount = 0;
    }
    
    DWORD GetCount() const
    {
        return _dwCount;
    }
    
    class Iterator
    {
    friend THashtable;
    public:
    
        Iterator()
        {
            _pHashtable    = NULL;
            _dwCurrentSlot = 0;
        }
        
        Iterator(THashtable* pHashtable)
        {
            _pHashtable    = pHashtable;
            _dwCurrentSlot = 0;
        }
        
        void Reset()
        {
            _dwCurrentSlot = 0;
        }
        
        bool GetNext(KEYTYPE* pKey, DATATYPE* pData)
        {
            while(_dwCurrentSlot < _pHashtable->_dwCapacity && 
                 _pHashtable->_pSlots[_dwCurrentSlot].dwIdealSlot == AVAILABLE)
            {
                _dwCurrentSlot++;
            }

            if(_dwCurrentSlot < _pHashtable->_dwCapacity)
            {
                if(pKey != NULL)
                    *pKey  = _pHashtable->_pSlots[_dwCurrentSlot].key;
                    
                if(pData != NULL)
                    *pData = _pHashtable->_pSlots[_dwCurrentSlot].data;
                    
                _dwCurrentSlot++;
                return true;
            }
            else
            {
                return false;
            }
        }
        
    protected:
    
        void Init(THashtable* pHashtable)
        {
            _pHashtable = pHashtable;
            _dwCurrentSlot = 0;
        }
    
        THashtable* _pHashtable;
        DWORD       _dwCurrentSlot;
    };

    void InitializeIterator(Iterator* pit)
    {
        pit->Init(this);        
    }

#if LBSVR_ALL_PUBLIC
public:
#else
protected:
#endif

    enum
    {
        AVAILABLE     = 0xFFFFFFFF
    };
    
    typedef struct 
    {
        KEYTYPE  key;
        DATATYPE data;
        DWORD    dwIdealSlot;
    } slot_t;
    
    enum
    {
        SLOT_SIZE = sizeof(slot_t)
    };
    
    THashtable(void* pLocalData, DWORD dwCapacity) :
        _pSlots((slot_t*)pLocalData), 
        _fLocal(true), 
        _loadFactor(0.75),
        _dwCapacity(dwCapacity),
        _dwMaxCount((DWORD)(_dwCapacity * _loadFactor) - 1),
        _dwCount(0),
        _pAlloc(&g_MemAlloc)
    {
        FillMemory(_pSlots, sizeof(slot_t) * _dwCapacity, 0xFF);
    }

    friend Iterator;
    
    float      _loadFactor;
    slot_t*    _pSlots;
    bool       _fLocal;
    DWORD      _dwCapacity;
    DWORD      _dwMaxCount;
    DWORD      _dwCount;
    IMemAlloc* _pAlloc;
};

template <class HASHTABLE, int CAPACITY>
class TStackHashtable : public HASHTABLE
{
public:
    TStackHashtable() : HASHTABLE(_rgLocal, CAPACITY)
    {
    }

protected:
    BYTE _rgLocal[CAPACITY * HASHTABLE::SLOT_SIZE];
};

template <class T>
class THeapNoNotify
{
public:
    static void OnHeapNewPosition(T v, DWORD nNewPos)
    {
        // NO-OP
    }
};

template <
    class T,
    int INITIAL_CAPACITY,
    class COMPARE,
    class NOTIFYONNEWPOSITION=THeapNoNotify<T>
>
class THeap
{
public:
    
    void Term()
    {
        _array.Term();
    }
    
    bool SetAllocator(IMemAlloc* pAlloc)
    {
        return _array.SetAllocator(pAlloc);
    }
    
    bool Grow(DWORD dwCapacity)
    {   
        DWORD dwSize = _array.GetSize();
        
        if(dwSize >= dwCapacity)
            return true;
        
        bool fRet = _array.SetSize(dwCapacity);
        
        if(fRet)
        {
            _array.SetSize(dwSize);
        }
        
        return fRet;
    }

#if _TEST
    bool Verify(int nIndex, int nLevel)
    {
        if (nIndex >= (int)GetCount())
        {
            return true;
        }
        
        bool fRet = true;

        int nStartIndex = (1<< nLevel)      - 1;
        int nEndIndex  =  (1<<(nLevel + 1)) - 1;

        int nChildrenIndexStart = (nIndex - nStartIndex) * 2 + nEndIndex ;        

        T node  = _array.Get(nIndex);

        if (nChildrenIndexStart >= (int)GetCount() )
        {
            return fRet;
        }
        
        T node1 = _array.Get(nChildrenIndexStart);
        fRet = COMPARE::HeapCompare(node1, node) >= 0;

        if (nChildrenIndexStart + 1>= (int)GetCount())
        {
            return fRet;
        }
        
        T node2 = _array.Get(nChildrenIndexStart + 1);        
        fRet = fRet && COMPARE::HeapCompare(node2, node) >= 0;

        if (!fRet)
            return false;
        else
            return Verify(nChildrenIndexStart, nLevel + 1) && Verify(nChildrenIndexStart + 1, nLevel + 1);
    }
#endif

    bool Insert(
        T node
    )
    {
        bool fRet = false;
        
        DWORD dwSlot = _array.GetSize();
        
        if(!_array.SetSize(_array.GetSize()+1))
            goto lDone;
            
        _array.Set(dwSlot, node);
        
        NOTIFYONNEWPOSITION::OnHeapNewPosition(node, dwSlot);
        
        UpHeap(dwSlot);
        
        fRet = true;
    
    lDone:
        
        return fRet;
    }

    T Remove(
        DWORD dwIndex
    )
    {
        DBGASSERT(dwIndex < GetCount());
    
        T ret = _array.Get(dwIndex);

        _array.Set(dwIndex, _array.Get(GetCount()-1));
        
        NOTIFYONNEWPOSITION::OnHeapNewPosition(_array.Get(dwIndex), dwIndex);

        _array.SetSize(_array.GetSize()-1);

        if(GetCount() > 0)
        {   
            if (dwIndex < GetCount() - 1)
            {
                DownHeap(dwIndex);
            }

            if (dwIndex != 0 && dwIndex < GetCount())
            {
                //random removal may require an upheap
                UpHeap(dwIndex);
            }
        }


        return ret;
    }

    T Peek(
        DWORD dwIndex
    )
    {
        return _array.Get(dwIndex);
    }

    DWORD GetCount()
    {
        return _array.GetSize();
    }

//     void Dump()
//     {
//         int iCount = GetCount();
//
//         for(int i=0; i < iCount; i++)
//         {
//             printf("%d(%d) ", _array.Get(i)->iValue, _array.Get(i)->dwIndex);
//         }
//         printf("\n");
//     }

protected:

    void UpHeap(
        DWORD dwIndex
    )
    {
        T v = _array.Get(dwIndex);

        while(dwIndex > 0 && COMPARE::HeapCompare(_array.Get((dwIndex-1) / 2), v) > 0)
        {
            _array.Set(dwIndex, _array.Get((dwIndex-1) / 2));
    
            NOTIFYONNEWPOSITION::OnHeapNewPosition(_array.Get(dwIndex), dwIndex);

            dwIndex = (dwIndex-1)/2;
        }

        _array.Set(dwIndex, v);

        NOTIFYONNEWPOSITION::OnHeapNewPosition(_array.Get(dwIndex), dwIndex);
    }

    void DownHeap(
        DWORD dwIndex
    )
    {
        T v = _array.Get(dwIndex);
    
        DWORD dwSize = GetCount();

        while(dwIndex < dwSize / 2)
        {
            DWORD j = (dwIndex * 2) + 1;

            if(j < (dwSize-1) && COMPARE::HeapCompare(_array.Get(j),_array.Get(j+1)) > 0)
            {
                j++;
            }

            if(COMPARE::HeapCompare(v, _array.Get(j)) <= 0)
            {
                break;
            }

            _array.Set(dwIndex, _array.Get(j));

            NOTIFYONNEWPOSITION::OnHeapNewPosition(_array.Get(dwIndex), dwIndex);

            dwIndex = j;
        }

        _array.Set(dwIndex, v);

        NOTIFYONNEWPOSITION::OnHeapNewPosition(_array.Get(dwIndex), dwIndex);
    }
    
    TArray<T,INITIAL_CAPACITY> _array;
};

__forceinline int WrapDWORDCompare(DWORD dwLeft, DWORD dwRight, DWORD* pdwDiff)
{
    DWORD dwDiffLR;
    DWORD dwDiffRL;

    if (dwLeft == dwRight)
    {
        if(pdwDiff != NULL)
            *pdwDiff = 0;
            
        return 0;
    }
    else
    {
        // Shorest distance will tell us which is likely later (within 20+ days)
        dwDiffLR = dwLeft  - dwRight;
        dwDiffRL = dwRight - dwLeft;
        
        if(dwDiffLR < dwDiffRL)
        {
            if(pdwDiff != NULL)
                *pdwDiff = dwDiffLR;
            
            return 1; // dwLeft is likely later
        }
        else
        {
            if(pdwDiff != NULL)
                *pdwDiff = dwDiffRL;
            
            return -1; // dwRight is likely later
        }
    }
}

class __declspec(novtable) IServerTimerCallback : public CAddRefable
{
public:
    virtual ULONG AddRef() = 0;
    virtual ULONG Release() = 0;
    virtual void OnTimer(void* pParam) = 0;
};

class CServerTimer;

class CServerTimerAppt
{
friend CServerTimer;
USE_GLOBAL_ALLOC;
public:

    static void OnHeapNewPosition(CServerTimerAppt* pv, DWORD nNewPos)
    {
        pv->_dwHeapIndex = nNewPos;
    }
    
    static int HeapCompare(CServerTimerAppt* pv1, CServerTimerAppt* pv2)
    {
        return WrapDWORDCompare(pv1->_dwWhen, pv2->_dwWhen, NULL);
    }

    virtual ULONG AddRef();

    virtual ULONG Release();

protected:

    enum
    {
        NOT_QUEUED=~0
    };
    
    CServerTimerAppt();
    
    ~CServerTimerAppt();
    
    void Init(
        IServerTimerCallback* pCallback, 
        void* pParam, 
        DWORD dwInterval, 
        bool fRecurring,
        DWORD dwNow
    );
    
    void Cancel();
    
    void CalcNextAppt(DWORD dwNow);
    
    void MarkAsNotQueued();
    
    IServerTimerCallback* GetCallback() {  return _pCallback; }
    
    void* GetParam() {  return _pParam; }
    
    DWORD GetWhen() { return _dwWhen; }
    
    bool IsRecurring() { return _fRecurring; }
    
    bool IsQueued() { return _dwHeapIndex != NOT_QUEUED; }
    
    bool IsFirstInLine() { return _dwHeapIndex == 0; }
    
    DWORD GetHeapIndex() { return _dwHeapIndex; }
    
    IServerTimerCallback* _pCallback;
    DWORD         _dwInterval;
    DWORD         _dwWhen;
    DWORD         _dwHeapIndex;
    LONG          _lRef;
    volatile bool _fRecurring;
    void*         _pParam;
};

class CServerTimer
{
public:

    CServerTimer();
    
    ~CServerTimer();
    
    bool Init();
    
    void Shutdown();
    
    void Term();
    
    bool CreateAppointment(
        IServerTimerCallback* pCallback,
        void* pParam,
        DWORD dwInterval,
        bool fRecurring,
        CServerTimerAppt** ppAppt
    );
    
    void CancelAppointment(
        CServerTimerAppt* pAppt
    );
    
#if _TEST
    DWORD _dwTimeAdjust;
    
    DWORD GetNow()
    {
        return GetTickCount() + _dwTimeAdjust;
    }
#else
    
    static DWORD GetNow()
    {
        return GetTickCount();
    }

#endif

protected:

    static DWORD StaticThreadProc(void* pRawThis);
    
    void ThreadProc();
    
    HANDLE        _hThread;
    CFastLock     _lock;
    HANDLE        _hWait;
    THeap<CServerTimerAppt*, 100, CServerTimerAppt, CServerTimerAppt> _heap;
    volatile LONG _fShutdown;
};

// Compare 2 *unsigned* integers
inline int UINT32Compare(
    UINT32 ui1,
    UINT32 ui2
)
{
    if(ui1 < ui2)
        return -1;
    if(ui1 > ui2)
        return 1;
    else
        return 0;    
}

// Compare 2 *unsigned* 64 bit integers
inline int UINT64Compare(
    UINT64 ui1,
    UINT64 ui2
)
{
    if(ui1 < ui2)
        return -1;
    if(ui1 > ui2)
        return 1;
    else
        return 0;    
}

// Revert Dword (for big-little-endian conversions)
inline DWORD RevertDword(DWORD dw)
{
    DWORD dw2;
    
    reinterpret_cast<BYTE*>(&dw2)[0] = reinterpret_cast<BYTE*>(&dw)[3];
    reinterpret_cast<BYTE*>(&dw2)[1] = reinterpret_cast<BYTE*>(&dw)[2];
    reinterpret_cast<BYTE*>(&dw2)[2] = reinterpret_cast<BYTE*>(&dw)[1];
    reinterpret_cast<BYTE*>(&dw2)[3] = reinterpret_cast<BYTE*>(&dw)[0];
    
    return dw2;
}

UINT64 GetUTCTimeAsUint64();

// Trace callback interface
class ITraceCallback
{
public:
    virtual bool Write(const char* psz) = 0;
};

// Utility function to write to ITraceCallback::Write in printf style
void TraceCallbackFormattedWrite(
    ITraceCallback* pOut, 
    const char* pszFmt, 
    ... );

// Yet another utility function to write to ITraceCallback. This one to dump
// a binary blob as string of 2-digit hex numbers
inline void TraceCallbackWriteBinary(
    ITraceCallback* pOut,
    BYTE* pBin,
    DWORD dwSize
)
{
    for(DWORD i=0; i < dwSize; i++)
    {
        TraceCallbackFormattedWrite(pOut,"%02x",pBin[i]);
    }
}

// A file that implements ITraceCallback. Can be used as a black box to 
// conviniently dump information to when the application asserts or something
// like that
class CTraceFile : public ITraceCallback
{
public:
    
    CTraceFile()
    {
        _hFile = INVALID_HANDLE_VALUE;
    }

    ~CTraceFile()
    {
        DBGASSERT(_hFile == INVALID_HANDLE_VALUE);
    }

    bool Init(const char* pszFilename)
    {
        bool fRet = false;

        DBGASSERT(_hFile == INVALID_HANDLE_VALUE);
        
        _hFile = ::CreateFileA(pszFilename, GENERIC_WRITE, FILE_SHARE_READ,
                               NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if(INVALID_HANDLE_VALUE == _hFile)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                                     "CreateFileA failed. Error = %d", 
                                     ::GetLastError());
            goto lDone;
        }

    lDone:

        return fRet;
    }

    void Term()
    {
        if(_hFile != INVALID_HANDLE_VALUE)
        {
            ::CloseHandle(_hFile);
            _hFile = INVALID_HANDLE_VALUE;
        }
    }
    
    virtual bool Write(const char* psz)
    {
        DWORD dwWritten = 0;
        
        if(_hFile == INVALID_HANDLE_VALUE)
            return false;

        CConstStr str(psz);
        if(!::WriteFile(_hFile, str.cstr(), str.GetLength(), &dwWritten, NULL))
        {
            CGlobalError::SetMessage(
                GLOBAL_ERROR_HEADER "WriteFile failed. Error = %d",
                GetLastError());
            
            return false;
        }

        return true;
    }
        
protected:
    
    HANDLE _hFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\svc\mgmt.h ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * mgmt.h
 * Header of leaderboard server management interface (home of xmgmt 
 * commands and whatnot
 * Source: mgmt.cpp
 * 
 */

// Notes: 
// *       Most leaderboard server code commands depend on CGlobalError being 
// correctly initialized in the thread they are going to be running on. Because
// we don't have control over the threads xmgmt uses to process management 
// commands, we're going to init and term CGlobalError on every call.
class CLbSvrMgmt : public CXomControlCallback
{
public:

    IMPLEMENT_REFCOUNT_COM;

    CLbSvrMgmt();

    ~CLbSvrMgmt();
    
    bool Init(UMS* pUMS, CLbList* pLbList, CBufferManager* pBM);

    void Term();

    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwReqId,
        CXomControlResponseInterface* pRI);

protected:

    class CTraceCallback : public ITraceCallback
    {
    public:
        CTraceCallback(
            CXomControlResponseInterface* pRI,
            DWORD dwReqId
        )
        {
            _pRI     = pRI;
            _dwReqId = dwReqId;
        }
    
        virtual bool Write(const char *psz)
        {
            _pRI->WriteResponse(_dwReqId, (BYTE*)psz, (DWORD)-1);
            return true;
        }

    protected:
        
        CXomControlResponseInterface* _pRI;
        DWORD _dwReqId;
    };

    bool ProcessDumpBufferManagerStats(
        CXomControlResponseInterface* pRI,
        DWORD dwReqId,
        CXomParamList* pParams);

    bool ProcessDumpLbBinary(
        CXomControlResponseInterface* pRI,
        DWORD dwReqId,
        CXomParamList* pParams);

    bool ProcessDumpLbPath(
        CXomControlResponseInterface* pRI,
        DWORD dwReqId,
        CXomParamList* pParams);

    bool ProcessDumpUserLbPath(
        CXomControlResponseInterface* pRI,
        DWORD dwReqId,
        CXomParamList* pParams);

    bool ProcessDumpLbMemoryStats(
        CXomControlResponseInterface* pRI,
        DWORD dwReqId,
        CXomParamList* pParams);

    bool ProcessListLb(
        CXomControlResponseInterface* pRI,
        DWORD dwReqId,
        CXomParamList* pParams);

    bool ProcessReloadSettingForTitle(
        CXomControlResponseInterface* pRI,
        DWORD dwReqId,
        CXomParamList* pParams);

    bool ProcessReloadSettingForLb(
        CXomControlResponseInterface* pRI,
        DWORD dwReqId,
        CXomParamList* pParams);

    bool ProcessEnableDisablePerfInstances(
        CXomControlResponseInterface* pRI,
        DWORD dwReqId,
        CXomParamList* pParams, 
        bool fEnable,
        bool fLBSpecific);

    UMS*            _pUMS;
    CLbList*        _pLbList;
    CBufferManager* _pBM;
    bool            _fReg;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\svc\mgmt.cpp ===
/*
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * Leaderboard Server
 *
 * mgmt.cpp
 * Implementation of leaderboard server management interface (home of xmgmt 
 * commands and whatnot
 * Header: mgmt.h
 * 
 */

#include "lbs.h"
#include "mgmt.h"

CLbSvrMgmt::CLbSvrMgmt()
{
    _pUMS    = NULL;
    _pLbList = NULL;
    _pBM     = NULL;
    _fReg    = false;
}

CLbSvrMgmt::~CLbSvrMgmt()
{
    DBGASSERT(!_fReg);
}

bool CLbSvrMgmt::Init(UMS* pUMS, CLbList* pLbList, CBufferManager* pBM)
{
    DBGASSERT(!_fReg);
    
    bool fRet = false;

    _pUMS     = pUMS;
    _pLbList  = pLbList;
    _pBM      = pBM;

    HRESULT hr = g_xomcentral.RegisterControlCallback(this);

    if(FAILED(hr))
    {
        CGlobalError::SetMessage(
            GLOBAL_ERROR_HEADER "RegisterControlCallback failed. hr=0x%08x",
            hr);

        goto lDone;
    }
    
    // Remember to unregister later
    _fReg = true;

    fRet = true;

lDone:

    return fRet;
}

void CLbSvrMgmt::Term()
{
    if(_fReg)
    {
        g_xomcentral.UnregisterControlCallback(this);
        _fReg = false;
    }
}

HRESULT CLbSvrMgmt::OnControlRequest(
    LPCSTR pszRequest,
    DWORD dwReqId,
    CXomControlResponseInterface* pRI)
{
    HRESULT hr = E_FAIL;
    CXomParamList oParams;

    if(FAILED(oParams.Parse(pszRequest)))
    {
        XomWriteFormattedResponse(pRI, dwReqId, "Failed to parse commands\n");
        goto lDone;
    }
    
    if(_stricmp(oParams.GetParam(0), "help") == 0 ||
            _stricmp(oParams.GetParam(0), "h") == 0)
    {
        XomWriteFormattedResponse(
            pRI, dwReqId,
            "\nLbSvr commands:"
            "\n  listlb [<titleId>]"
            "\n  dumplbmemorystats <titleId> <lbid>"
            "\n  dumplbbinary <titleId> <lbid>"
            "\n  dumpbuffermanagerstats"
            "\n  dumpSearchPath <titleID> <lbid> <rating> <ui64Untier>"
            "\n  dumpSearchPathUsingUserIndex <titleID> <lbid> <i64Puid>"
            "\n  reloadsettingforlb <titleID> <lbid>"
            "\n  reloadsettingfortitle <titleID>"
            "\n  enabletitleperfctrs [<titleID>]"
            "\n  disabletitleperfctrs [<titleID>]"
            "\n  enableLBperfctrs [<titleID>]"
            "\n  disableLBperfctrs [<titleID>]");
    }
    else if(_stricmp(oParams.GetParam(0), "listlb") == 0)
    {
        if(!ProcessListLb(pRI, dwReqId, &oParams))
            goto lDone;
    }
    else if(_stricmp(oParams.GetParam(0), "dumplbmemorystats") == 0)
    {
        if(!ProcessDumpLbMemoryStats(pRI, dwReqId, &oParams))
            goto lDone;
    }
    else if(_stricmp(oParams.GetParam(0), "dumpbuffermanagerstats") == 0)
    {
        if(!ProcessDumpBufferManagerStats(pRI, dwReqId, &oParams))
            goto lDone;
    }
    else if(_stricmp(oParams.GetParam(0), "dumplbbinary") == 0)
    {
        if(!ProcessDumpLbBinary(pRI, dwReqId, &oParams))
            goto lDone;
    }
    else if(_stricmp(oParams.GetParam(0), "dumpSearchPath") == 0)
    {
        if(!ProcessDumpLbPath(pRI, dwReqId, &oParams))
            goto lDone;
    }
    else if(_stricmp(oParams.GetParam(0), "dumpSearchPathUsingUserIndex") == 0)
    {
        if(!ProcessDumpUserLbPath(pRI, dwReqId, &oParams))
            goto lDone;
    }
    else if(_stricmp(oParams.GetParam(0), "reloadsettingforlb") == 0)
    {
        if(!ProcessReloadSettingForLb(pRI, dwReqId, &oParams))
            goto lDone;
    }
    else if(_stricmp(oParams.GetParam(0), "reloadsettingfortitle") == 0)
    {
        if(!ProcessReloadSettingForTitle(pRI, dwReqId, &oParams))
            goto lDone;
    }
    else if(_stricmp(oParams.GetParam(0), "enableLBperfctrs") == 0)
    {
        if(!ProcessEnableDisablePerfInstances(pRI, dwReqId, &oParams, true /*enable*/, true /*perlb*/))
            goto lDone;
    }
    else if(_stricmp(oParams.GetParam(0), "disableLBperfctrs") == 0)
    {
        if(!ProcessEnableDisablePerfInstances(pRI, dwReqId, &oParams, false /*disable*/, true /*perlb*/))
            goto lDone;
    }
    else if(_stricmp(oParams.GetParam(0), "enabletitleperfctrs") == 0)
    {
        if(!ProcessEnableDisablePerfInstances(pRI, dwReqId, &oParams, true /*enable*/, false /*pertitle*/))
            goto lDone;
    }
    else if(_stricmp(oParams.GetParam(0), "disabletitleperfctrs") == 0)
    {
        if(!ProcessEnableDisablePerfInstances(pRI, dwReqId, &oParams, false /*disable*/, false /*pertitle*/))
            goto lDone;
    }
    
    hr = S_OK;

lDone:

    return hr;
}

bool CLbSvrMgmt::ProcessListLb(
    CXomControlResponseInterface* pRI,
    DWORD dwReqId,
    CXomParamList* pParams)
{
    CGlobalError::Init();
    bool fRet = false;
    CTraceCallback tc(pRI, dwReqId);
    
    UINT32 uiTitleId = 0;
    
    if(pParams->GetCount() == 2)
    {
        uiTitleId = (UINT32) strtoul(pParams->GetParam(1), NULL, 0);
    }
    XomWriteFormattedResponse(pRI, dwReqId, "TitleId = 0x%x\n", uiTitleId);

    if(!_pLbList->DumpLbList(&tc, uiTitleId))
        goto lDone;

    fRet = true;
    
lDone:

    if(!fRet)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "\nError:\n%s\n", 
                                  CGlobalError::GetCurrentMessage());
    }

    CGlobalError::Term();
    
    return fRet;
}

bool CLbSvrMgmt::ProcessDumpLbMemoryStats(
    CXomControlResponseInterface* pRI,
    DWORD dwReqId,
    CXomParamList* pParams)
{
    bool        fRet       = false;
    CLb*        pLb        = NULL;
    IUmsClient* pUmsClient = NULL;
    
    CTraceCallback tc(pRI, dwReqId);
    CGlobalError::Init();

    UINT32 uiTitleId = 0;
    UINT32 uiLbId    = 0;
    
    if(pParams->GetCount() != 3)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "Invalid parameters\n");  
        goto lDone;
    }
    uiTitleId = (UINT32) strtoul(pParams->GetParam(1), NULL, 0);
    uiLbId    = (UINT32) strtoul(pParams->GetParam(2), NULL, 0);
    
    XomWriteFormattedResponse(pRI, dwReqId, 
                              "TitleId = 0x%x\n"
                              "LbId    = %u\n", 
                              uiTitleId,
                              uiLbId);

    if(!_pUMS->CreateUmsClient(&pUmsClient))
        goto lDone;

    if(_pLbList->GetLb(uiTitleId, uiLbId, &pLb) != CLbList::GetLbStatusSucceeded)
        goto lDone;
    
    if(!pLb->DumpMemoryStats(pUmsClient, &tc))
        goto lDone;

    fRet = true;
    
lDone:

    if(!fRet)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "\nError:\n%s\n", 
                                  CGlobalError::GetCurrentMessage());
    }

    if(pLb != NULL)
        pLb->Release();

    if(pUmsClient != NULL)
        _pUMS->ReleaseUmsClient(pUmsClient);

    CGlobalError::Term();
    
    return fRet;
}

bool CLbSvrMgmt::ProcessDumpLbBinary(
    CXomControlResponseInterface* pRI,
    DWORD dwReqId,
    CXomParamList* pParams)
{
    bool        fRet       = false;
    CLb*        pLb        = NULL;
    IUmsClient* pUmsClient = NULL;
    
    CTraceCallback tc(pRI, dwReqId);
    CGlobalError::Init();

    UINT32 uiTitleId = 0;
    UINT32 uiLbId    = 0;
    
    if(pParams->GetCount() != 3)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "Invalid parameters\n");
        goto lDone;	
    }

    uiTitleId = (UINT32) strtoul(pParams->GetParam(1), NULL, 0);
    uiLbId    = (UINT32) strtoul(pParams->GetParam(2), NULL, 0);
    
    XomWriteFormattedResponse(pRI, dwReqId, 
                              "TitleId = 0x%x\n"
                              "LbId    = %u\n", 
                              uiTitleId,
                              uiLbId);

    if(!_pUMS->CreateUmsClient(&pUmsClient))
        goto lDone;

    if(_pLbList->GetLb(uiTitleId, uiLbId, &pLb) != CLbList::GetLbStatusSucceeded)
        goto lDone;
    
    if(!pLb->DumpLbBinary(pUmsClient, &tc))
        goto lDone;

    fRet = true;
    
lDone:

    if(!fRet)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "\nError:\n%s\n", 
                                  CGlobalError::GetCurrentMessage());
    }

    if(pLb != NULL)
        pLb->Release();

    if(pUmsClient != NULL)
        _pUMS->ReleaseUmsClient(pUmsClient);

    CGlobalError::Term();
    
    return fRet;
}

bool CLbSvrMgmt::ProcessDumpLbPath(
    CXomControlResponseInterface* pRI,
    DWORD dwReqId,
    CXomParamList* pParams)
{
    bool        fRet       = false;
    CLb*        pLb        = NULL;
    IUmsClient* pUmsClient = NULL;
    
    CTraceCallback tc(pRI, dwReqId);
    CGlobalError::Init();

    UINT32          uiTitleId = 0;
    UINT32          uiLbId    = 0;
    LbKey           lbKey;

    if(pParams->GetCount() != 5)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "Invalid parameters\n");
        goto lDone;	
    }

    uiTitleId        = (UINT32) strtoul(pParams->GetParam(1), NULL, 0);
    uiLbId           = (UINT32) strtoul(pParams->GetParam(2), NULL, 0);
    
    lbKey.i64Rating  = (UINT64) strtoul(pParams->GetParam(3), NULL, 0);
    lbKey.ui64Untier   = (UINT64) _strtoui64(pParams->GetParam(4), NULL, 0);
   
    
    XomWriteFormattedResponse(pRI, dwReqId, 
                              "TitleId     = 0x%x\n"
                              "LbId    	   = %u\n", 
                              "uiRating    = %u\n", 
                              "ui64Untier    = %u\n",
                              uiTitleId,
                              uiLbId,
                              lbKey.i64Rating,
                              lbKey.ui64Untier);

    if(!_pUMS->CreateUmsClient(&pUmsClient))
        goto lDone;

    if(_pLbList->GetLb(uiTitleId, uiLbId, &pLb) != CLbList::GetLbStatusSucceeded)
        goto lDone;
    
    if(!pLb->DumpLbSearchPath(pUmsClient, &tc, (void *)&lbKey, sizeof(LbKey),  false))
        goto lDone;

    fRet = true;
    
lDone:

    if(!fRet)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "\nError:\n%s\n", 
                                  CGlobalError::GetCurrentMessage());
    }

    if(pLb != NULL)
        pLb->Release();

    if(pUmsClient != NULL)
        _pUMS->ReleaseUmsClient(pUmsClient);

    CGlobalError::Term();
    
    return fRet;

}


bool CLbSvrMgmt::ProcessDumpUserLbPath(
    CXomControlResponseInterface* pRI,
    DWORD dwReqId,
    CXomParamList* pParams)
{
    bool        fRet       = false;
    CLb*        pLb        = NULL;
    IUmsClient* pUmsClient = NULL;
    
    CTraceCallback tc(pRI, dwReqId);
    CGlobalError::Init();

    UINT32          uiTitleId = 0;
    UINT32          uiLbId    = 0;
    LbPuidIndexKey  lbUKey;

    if(pParams->GetCount() != 4)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "Invalid parameters\n");
        goto lDone;	
    }

    uiTitleId        = (UINT32) strtoul(pParams->GetParam(1), NULL, 0);
    uiLbId           = (UINT32) strtoul(pParams->GetParam(2), NULL, 0);
    
    lbUKey.ui64Puid  = (UINT64) _strtoui64(pParams->GetParam(3), NULL, 0);
   
    
    XomWriteFormattedResponse(pRI, dwReqId, 
                              "TitleId     = 0x%x\n"
                              "LbId    	   = %u\n", 
                              "ui64Puid    = %u\n", 
                              uiTitleId,
                              uiLbId,
                              lbUKey.ui64Puid);

    if(!_pUMS->CreateUmsClient(&pUmsClient))
        goto lDone;

    if(_pLbList->GetLb(uiTitleId, uiLbId, &pLb) != CLbList::GetLbStatusSucceeded)
        goto lDone;
    
    if(!pLb->DumpLbSearchPath(pUmsClient, &tc, (void *)&lbUKey, sizeof(LbPuidIndexKey), true))
        goto lDone;

    fRet = true;
    
lDone:

    if(!fRet)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "\nError:\n%s\n", 
                                  CGlobalError::GetCurrentMessage());
    }

    if(pLb != NULL)
        pLb->Release();

    if(pUmsClient != NULL)
        _pUMS->ReleaseUmsClient(pUmsClient);

    CGlobalError::Term();
    
    return fRet;

}


bool CLbSvrMgmt::ProcessDumpBufferManagerStats(
    CXomControlResponseInterface* pRI,
    DWORD dwReqId,
    CXomParamList* pParams)
{
    CTraceCallback tc(pRI, dwReqId);
    CGlobalError::Init();

    _pBM->DumpStats(&tc);

    CGlobalError::Term();
    return true;
}

bool CLbSvrMgmt::ProcessReloadSettingForLb(
    CXomControlResponseInterface* pRI,
    DWORD dwReqId,
    CXomParamList* pParams)
{
    bool        fRet       = false;
    CLb*        pLb        = NULL;
    IUmsClient* pUmsClient = NULL;
    
    CTraceCallback tc(pRI, dwReqId);
    CGlobalError::Init();

    UINT32          uiTitleId = 0;
    UINT32          uiLbId    = 0;

    if(pParams->GetCount() != 3)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "Invalid parameters\n");
        goto lDone;	
    }

    uiTitleId        = (UINT32) strtoul(pParams->GetParam(1), NULL, 0);
    uiLbId           = (UINT32) strtoul(pParams->GetParam(2), NULL, 0);
   
    
    XomWriteFormattedResponse(pRI, dwReqId, 
                              "TitleId\t= 0x%x\n"
                              "LbId\t= %u\n", 
                              uiTitleId,
                              uiLbId);

    if(!_pUMS->CreateUmsClient(&pUmsClient))
        goto lDone;

    if(!_pLbList->ReloadSettingForLb(uiTitleId, uiLbId, pUmsClient, NULL))
        goto lDone;

    fRet = true;
    
lDone:

    if(!fRet)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "\nError:\n%s\n", 
                                  CGlobalError::GetCurrentMessage());
    }
    else
    {
        XomWriteFormattedResponse(pRI, dwReqId, "Done ");
    }

    if(pLb != NULL)
        pLb->Release();

    if(pUmsClient != NULL)
        _pUMS->ReleaseUmsClient(pUmsClient);

    CGlobalError::Term();
    
    return fRet;
}

bool CLbSvrMgmt::ProcessReloadSettingForTitle(
    CXomControlResponseInterface* pRI,
    DWORD dwReqId,
    CXomParamList* pParams)
{
    bool        fRet       = false;
    CLb*        pLb        = NULL;
    IUmsClient* pUmsClient = NULL;
    
    CTraceCallback tc(pRI, dwReqId);
    CGlobalError::Init();

    UINT32          uiTitleId = 0;
    UINT32          uiLbId    = 0;
    UINT32          uiLbProcessed = 0;
    

    if(pParams->GetCount() != 2)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "Invalid parameters\n");
        goto lDone;	
    }

    uiTitleId        = (UINT32) strtoul(pParams->GetParam(1), NULL, 0);
   
    
    XomWriteFormattedResponse(pRI, dwReqId, 
                              "TitleId     = 0x%x\n",
                              uiTitleId);

    if(!_pUMS->CreateUmsClient(&pUmsClient))
        goto lDone;

    if(!_pLbList->ReloadSettingForTitle(uiTitleId, pUmsClient, &uiLbProcessed))
        goto lDone;

    fRet = true;
    
lDone:

    if(!fRet)
    {
        XomWriteFormattedResponse(pRI, dwReqId, "\nError:\n%s\n", 
                                  CGlobalError::GetCurrentMessage());
    }
    else
    {
        XomWriteFormattedResponse(pRI, dwReqId, "Done - Processed %u Leaderboards\n", uiLbProcessed);
    }

    if(pLb != NULL)
        pLb->Release();

    if(pUmsClient != NULL)
        _pUMS->ReleaseUmsClient(pUmsClient);

    CGlobalError::Term();
    
    return fRet;
}

bool CLbSvrMgmt::ProcessEnableDisablePerfInstances(
    CXomControlResponseInterface* pRI,
    DWORD dwReqId,
    CXomParamList* pParams, 
    bool fEnable,
    bool fLBSpecific)
{
    CGlobalError::Init();
    bool fRet = false;
    CTraceCallback tc(pRI, dwReqId);
    
    UINT32 uiTitleId = 0;
    
    if(pParams->GetCount() == 2)
    {
        uiTitleId = (UINT32) strtoul(pParams->GetParam(1), NULL, 0);
    }
    XomWriteFormattedResponse(pRI, dwReqId, "TitleId = 0x%x\n", uiTitleId);

    if(fLBSpecific)
    {
        if(!_pLbList->ToggleInstancePerfCountersForLBs(uiTitleId, fEnable))
            goto lDone;
    }
    else
    {
        if(!_pLbList->ToggleInstancePerfCountersForTitles(uiTitleId, fEnable)) // if uiTitleId is zero, toggles for all titles.
            goto lDone;
    }

    fRet = true;
    XomWriteFormattedResponse(pRI, dwReqId, "%s completed successfully.\n", pParams->GetParam(0));
    
lDone:

    if(!fRet)
    {
        if(fEnable)
        {
            XomWriteFormattedResponse(pRI, dwReqId, "\nError enabling perf counter instances.  You may have exceeded the max number of instances(%d).  Error details:\n%s\n", 
                                      MAX_INSTANCES_PER_OBJECT, CGlobalError::GetCurrentMessage());
        }
        else
        {
            XomWriteFormattedResponse(pRI, dwReqId, "\nError disabling perf counter instances.  Error details:\n%s\n", 
                                      CGlobalError::GetCurrentMessage());
        }
    }


    CGlobalError::Term();
    
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\perf\lbsvrperf.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using System.Threading;

using xonline.common.protocol;
using xonline.common.config;
using xonline.common.service;
using xonline.server.stats.common;

namespace xonline.server.stats.test.dvt 
{
    public class GlobalData
    {
        static public string     _environment = "dcaiafa";
        static public string     _lbsvrname = "dcaiafa3";
        static public IPEndPoint _lbsvraddr = new IPEndPoint(0, 0);
        static public string     _configserver = "127.0.0.1";
        static public string     _configdb = "npdb";
        
        static public UInt32     _titleId     = 0xfeedfeed;
        static public UInt32     _lbId        = 1;
        static public int        _threadCount = 2;
        static public int        _statCount   = 10;
        static public int        _writeCount  = 5;
        static public int        _puidCount   = 100000;
    }
    
    public struct StatData
    {
        public UInt32 _uiTitleId;
        public UInt32 _uiLbId;
        public UInt64 _puid;
        public Stat[] _stats;
    };
    
    public struct Stat
    {
        public UInt16 _usStatId;
        public object _val;
    };
    
    public class LbsvrProcs
    {
        static public void DeleteTitle(
            UInt32 titleId
        )
        {
            LbsvrClientConnection lbsvrcli = null;

            try
            {
                lbsvrcli = LbsvrClientConnection.OpenConnection(
                    GlobalData._lbsvraddr);
                
                lbsvrcli.BeginRequest(1);
                lbsvrcli.CallProc(LbsvrClientConnection.LbProcIdDeleteTitle, new object[] {
                    (Int32)titleId
                });
                lbsvrcli.SendRequest();
                
                if(lbsvrcli.GetNextResult() != LbsvrClientResult.None)
                    throw new Exception("Assert failed");
            }
            finally
            {
                if(lbsvrcli != null)
                {
                    lbsvrcli.Close();
                    lbsvrcli = null;
                }
            }
        }
        
        static public void CreateLb(
            UInt32 titleId,
            UInt32 lbId
        )
        {
            // Create in the config db
            SqlConnection sql = null;
            LbsvrClientConnection connection = null;
            
            try
            {
                sql = new SqlConnection("Server="+GlobalData._configserver+";Database="+GlobalData._configdb+
                    ";Integrated Security=true");
                 
                sql.Open();
                
                SqlCommand cmd = new SqlCommand("p_stats_lb_add", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_server",      GlobalData._lbsvrname);
                cmd.Parameters.Add("@i_title_id",     (Int32)titleId);
                cmd.Parameters.Add("@i_lb_id",        (Int32)lbId);
                cmd.Parameters.Add("@i_reset_type",   (Int32)0);
                 
                cmd.ExecuteNonQuery();
                
                connection = LbsvrClientConnection.OpenConnection(
                    GlobalData._lbsvraddr);
                    
                connection.BeginRequest(1);
                connection.CallProc(LbsvrClientConnection.LbProcIdLoadLb, new object[] {
                    (Int32)titleId,
                    (Int32)lbId
                });
                connection.SendRequest();
                
                if(connection.GetNextResult() != LbsvrClientResult.None)
                    throw new Exception("Assert failed");
            }
            finally
            {
                if(sql != null)
                    sql.Close();
                
                if(connection != null)
                    connection.Close();
            }
        }
        
        static public void StatWrite(
            LbsvrClientConnection lbsvrcli,
            StatData[] statData
        )
        {
            lbsvrcli.BeginRequest(statData.Length);
            
            for(int i=0; i < statData.Length; i++)
            {
                Stat[] stats = statData[i]._stats;
                
                int prmcount  = 5 + (stats.Length*2);
                object[] prms = new object[prmcount];
                
                prms[0] = (Int32) statData[i]._uiTitleId;
                prms[1] = (Int32) statData[i]._uiLbId;
                prms[2] = (Int64) statData[i]._puid;
                prms[3] = (Int64) 0;
                prms[4] = (Int16) stats.Length;
                
                // Variable parameters (the stats):
                for(int j=0; j < stats.Length; j++)
                {
                    prms[5+(j*2)]   = (Int16) stats[j]._usStatId;
                    prms[5+(j*2)+1] = stats[j]._val;
                }
                
                lbsvrcli.CallProc(LbsvrClientConnection.LbProcIdStatWrite, prms);
            }
            
            lbsvrcli.SendRequest();
            
            if(lbsvrcli.GetNextResult() != LbsvrClientResult.None)
                throw new Exception("assert failed");
        }
        
        static public void StatRead(
            LbsvrClientConnection lbsvrcli,
            StatData[] statData
        )
        {
            lbsvrcli.BeginRequest(statData.Length);
            
            for(int k=0; k < statData.Length; k++)
            {
                lbsvrcli.CallProc(LbsvrClientConnection.LbProcIdStatRead, new object[] {
                    (Int32) statData[k]._uiTitleId,
                    (Int32) statData[k]._uiLbId,
                    (Int64) statData[k]._puid});
            }
            
            lbsvrcli.SendRequest();    
                    
            int i = 0;
            Hashtable stats = new Hashtable();
            for(;;)
            {
                LbsvrClientResult result = lbsvrcli.GetNextResult();
                
                if(result == LbsvrClientResult.None)
                    break;
                else if(result != LbsvrClientResult.Rowset)
                    throw new Exception("Assert failed");
                    
                if(!lbsvrcli.Read())
                    throw new Exception("Assert failed");
                
                UInt32 lbId = (UInt32)(Int32) lbsvrcli.GetColumn(0);
                UInt64 puid = (UInt64)(Int64) lbsvrcli.GetColumn(1);
                object rank = lbsvrcli.GetColumn(2);
                
                while (lbId != statData[i]._uiLbId || puid != statData[i]._puid)
                {
                    i++;
                }
                
                stats.Clear();
                
                if(rank != null)
                    stats[SpecialAttrib.Rank] = (Int32) rank;
                
                int statcount = (lbsvrcli.GetColumnCount() - 3) / 2;
                
                for(int j=0; j < statcount; j++)
                {
                    UInt16 statId = (UInt16)(Int16) lbsvrcli.GetColumn(3 + (j*2));
                    object val    = lbsvrcli.GetColumn(3 + (j*2) + 1);
                    stats[statId] = val;
                }
                
                Stat[] statsToFill = statData[i]._stats;
                for(int j=0; j < statsToFill.Length; j++)
                {
                    statsToFill[j]._val = stats[statsToFill[j]._usStatId];
                }
            }
            
            if(lbsvrcli.GetNextResult() != LbsvrClientResult.None)
                throw new Exception("Assert failed");
        }
    }
    
    public class PerfThread 
    {
        public PerfThread(
            int instance
        )
        {
            _instance = instance;
            _rand     = new Random(unchecked((int)DateTime.Now.Ticks)*_instance);
            _thread   = new XboxLiveThread(new ThreadStart(Execute));
            
            _thread.Start();
        }
        
        public void Execute()
        {
            LbsvrClientConnection lbsvrcli = null;
            Interlocked.Increment(ref _activeInstances);
            
            int counter = 0;
            
            try
            {
                lbsvrcli = LbsvrClientConnection.OpenConnection(GlobalData._lbsvraddr);
                
                StatData[] statData = new StatData[GlobalData._writeCount];
                
                for(;;)
                {
                    // Initialize StatData structures
                    for(int i=0; i < statData.Length; i++)
                    {
                        statData[i]._uiTitleId = GlobalData._titleId;
                        statData[i]._uiLbId    = GlobalData._lbId;
                        
                        statData[i]._puid      = (UInt64)(
                            (counter % (GlobalData._puidCount / GlobalData._threadCount) + 1) *
                            GlobalData._threadCount + _instance - 1);
                            
                        
                        Stat[] stats = new Stat[GlobalData._statCount + 1];
                        
                        int j;
                        for(j=0; j < stats.Length-1; j++)
                        {  
                            stats[j]._usStatId = (UInt16)(j + 1);
                        }
                        stats[j]._usStatId = SpecialAttrib.Rating;
                        
                        statData[i]._stats = stats;
                        
                        counter++;
                    }
                
                    // Read
                    LbsvrProcs.StatRead(lbsvrcli, statData);
                    
                    // Change stats
                    for(int i=0; i < statData.Length; i++)
                    {
                        bool fNoData = false;
                        
                        Stat[] stats = statData[i]._stats;
                        
                        // Update stats
                        int j;
                        for(j=0; j < stats.Length-1; j++)
                        {  
                            if(stats[j]._val == null)
                            {
                                stats[j]._val = _rand.Next(0, GlobalData._puidCount);
                                fNoData = true;
                            }
                                
                            stats[j]._val = ((Int32)stats[j]._val) + (_rand.Next(0, 100) - 50);
                        }
                        
                        // Update rating
                        if(stats[j]._val == null)
                        {
                            stats[j]._val = (Int64) _rand.Next(0, GlobalData._puidCount);
                            fNoData = true;
                        }
                        
                        stats[j]._val = ((Int64)stats[j]._val) + (_rand.Next(0, 100) - 50);
                        
                        if(!fNoData)
                            _reads++;
                            
                        _writes++;
                    }
                    
                    // Write
                    LbsvrProcs.StatWrite(lbsvrcli, statData);
                    
                    _iterations++;
                }
            }
            catch(Exception e)
            {
                Console.WriteLine("Exception detected: " + e.ToString());
            }
            finally
            {
                Interlocked.Decrement(ref _activeInstances);
                
                if(lbsvrcli != null)
                    lbsvrcli.Close();
            }
        }
        
        static public int ActiveInstances
        {
            get { return _activeInstances; }
        }

        public int Iterations
        {
            get { return _iterations; }
        }
        
        public int Reads
        {
            get { return _reads; }
        }
        
        public int Writes
        {
            get { return _writes; }
        }
         
        protected static int _activeInstances = 0;
        protected XboxLiveThread _thread = null;
        protected int _instance = 0;
        protected Random _rand;
        protected int _iterations = 0;
        protected int _reads = 0;
        protected int _writes = 0;
    };
    
    class LbsvrPerf
	{
        static void LoadConfig()
        {
            // Lbsvr
            {
                string[] serverNames = xonline.common.config.Config.GetServerListByInterface(Interface.lbsvr);
                IInterfaceInfo face = xonline.common.config.Config.GetInterface(serverNames[0], Interface.lbsvr);
                GlobalData._lbsvraddr = new IPEndPoint(face.IPAddress, face.Port);
            }

            // Config db
            {
                IInterfaceInfo face  = xonline.common.config.Config.GetSingleInterface(Interface.npdb);
                GlobalData._configserver = face.IPAddressString;
                GlobalData._configdb     = face.DBName;
            }
        }
        
        [STAThread]
		static void Main(string[] args)
		{
            LoadConfig();
            Console.WriteLine("Lbsvr address is "+GlobalData._lbsvraddr.ToString());
            
            // Create leaderboard
            LbsvrProcs.DeleteTitle(GlobalData._titleId);
            LbsvrProcs.CreateLb(GlobalData._titleId, GlobalData._lbId);
            
            PerfThread[] threads = new PerfThread[GlobalData._threadCount];
            
            for(int i=0; i < threads.Length; i++)
            {
                threads[i] = new PerfThread(i + 1);
            }
            
            int sleep      = 1000;
            int prevcount  = 0;
            int prevreads  = 0;
            int prevwrites = 0;
            int countdown  = 0;
            
            for(;;)
            {
                Thread.Sleep(sleep);
                
                int newcount  = 0;
                int newreads  = 0;
                int newwrites = 0;
                
                for(int i=0; i < threads.Length; i++)
                {
                    newcount  += threads[i].Iterations;
                    newreads  += threads[i].Reads;
                    newwrites += threads[i].Writes;
                }
                    
                double rate       = ((double)(newcount  - prevcount))  / ((double)sleep) * 1000;
                double rateReads  = ((double)(newreads  - prevreads))  / ((double)sleep) * 1000;
                double rateWrites = ((double)(newwrites - prevwrites)) / ((double)sleep) * 1000;
                
                Console.WriteLine(string.Format("{0}, {1}, {2}", rate, rateReads, rateWrites));
                
                prevcount  = newcount;
                prevreads  = newreads;
                prevwrites = newwrites;
                
                if(countdown == 0)
                {
                    System.GC.GetTotalMemory(true);
                    countdown = 5;
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\main.cpp ===
#include <lbs.h>
#include "tests.h"
#include "unitutil.h"

CTraceCallback g_unitTraceCallback;

class CDbCallback : public IDbCallback
{
public:
    virtual bool OnRow(
        IUmsClient* pUmsClient,
        UINT32 uiTitleId,
        UINT32 uiLbId,
        UINT64 ui64Puid,
        LbStat rgStats[],
        DWORD  cStats,
        UINT64 lastModified
    )
    {
        return true;
    }
};

void TestWebstore()
{
    CTestConfig config;
    UMS ums;
    CDb db;

    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(db.Init(&config, &ums, NULL /* no perf counters */));

    LbStat stat;
    FillOutLbStatInt32(stat, 10, 100);
    UINT64 lastUpdt = ::GetUTCTimeAsUint64();
    TEST_ASSERT(db.UpdateLbRow(0xfeedfeed, 1, 123, &stat, 1, lastUpdt));

    DbTitleAndLb rgTitleAndLb[] = {
        { 0xfeedfeed, 1}
    };

    CDbCallback callback;

    TEST_ASSERT(db.Load(rgTitleAndLb, ARRAY_SIZE(rgTitleAndLb), &callback));

    TEST_ASSERT(db.RemoveLbRow(0xfeedfeed, 1, 123));

    TEST_ASSERT(db.ResetLb(0xfeedfeed, 1));

    db.Term();

    ums.Shutdown();
    ums.Term();
}

void __cdecl main()
{
    // Init
    g_xomcentral.Init("LBSUnit", NULL);
    g_MemAlloc.Init();
    CGlobalError::Init();
    CArenaMemAlloc::GlobalInit(65536, 1, true);
    
    // TestWebstore();

//#ifdef OLEDB_TEST
    OpenOleDBConnection();
    TestOleDBSimple();
    TestMultiThreadedOleDB();
    CloseOleDBConnection();
//#endif

    // Testing Memory Allocation
    // We need to run this for PAGE_HEAP, DEBUG_HEAP, BLENDED_HEAP, the 3 heaps we are interested in
    TestSimpleAlloc();
    TestIncrementingSizeAlloc();
    TestMultiThreadedRandomAlloc();

    // tutil.cpp
    TestCStr();
    TestCLFStack();
    TestCLFQueue();
    TestCFixedSizeMemPool();
    TestTList();
    TestCArenaMemAlloc();
    TestTArray();
    TestCHashtable();
    TestTHeap();
    TestStressHeapRemoveAt();
    TestCServerTimerSimple();
    TestCServerTimerWrap();

    // tums.cpp
    TestUMSSimple();
    TestUMSLocks();
    TestUMSLockCompability();

    // tbuffer.cpp
    TestBufferManagerSimple();
    TestBufferManagerPaging();

    // tbtree.cpp
    TestBPTPage();
    TestBtreeInsertAscending();
    TestBtreeInsertDescending();
    TestBtreeInsertRandom();
    TestBtreeDeleteAscending();
    TestBtreeDeleteDescending();
    TestBtreeDeleteRandom();
    TestBtreeEnum();
    TestBtreeRank();
    TestBtreeSearchEmpty();
    TestBtreeConcurrency();

    // tnet.cpp
    TestNetParameterPermutation();
    TestNetMessageReply();
    TestNetHelloTimeout();
    TestNetLargeRowset();
    TestNetConcurrency();
    TestNetRequest();
    TestNetProcs();
    TestNetPing();

    // tlb.cpp
    TestCLbStatBlob();
    TestLbUpdateAndRead();
    TestLbUpdate();
    TestLbEnum();
    TestLbRankedEntryCount();
    TestLbGetRankForPuid();
    TestLbReset();
    TestLbLoad();
    TestLbDecay();
    TestLbAutoReset();
    TestLbMaxEntryCount();
    TestLbTrim();

    // db.cpp
    TestDb();
    TestDbSwapChangeList();
    TestDbReset();
    TestDbFailure();
    TestDbBlobifyAndDeblobify();

    //leaves large allocation test at the end
    TestSimpleLargeAlloc();
    
    printf("Done!\n");
    
    // Terminate
    CArenaMemAlloc::GlobalTerm();
    CGlobalError::Term();
    g_MemAlloc.Term();
    g_xomcentral.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\talloc.cpp ===
#include "lbs.h"
#include "tests.h"

#define DATA_BYTE_PATTERN 0xAA
#define TEST_SIMPLE_ALLOC_ITERATION 3
#define TEST_MAX_NUM_LARGE_ALLOC 9000

#ifdef _AMD64_
#define MAX_ALLOCATION_BYTES 6589934592 //lets see if we can support 6 gig of allocation
#else
#define MAX_ALLOCATION_BYTES 2147483648
#endif

#define MAX_THREAD 60

void TestSimpleAlloc()
{
    byte * arrPointer[TEST_SIMPLE_ALLOC_ITERATION];
    int arrAllocSize[TEST_SIMPLE_ALLOC_ITERATION];

    printf("TestSimpleAlloc\n");

    for (int i=0;i<TEST_SIMPLE_ALLOC_ITERATION;i++)
    {
        int nSize = (int)(rand() % 65535);
        byte * pData = (byte *)XAlloc(nSize);
        TEST_ASSERT(pData != NULL);
        SecureZeroMemory(pData, nSize);
        //printf("Allocated %d Location %i64u\r\n", nSize, (ULONGLONG)pData);

        
        for (int j=0;j<nSize;j++)
        {
            pData[j] = DATA_BYTE_PATTERN;
        }

        arrPointer[i] = pData;
        arrAllocSize[i] = nSize;
        pData = NULL;
    }

    XDumpLeaks();

    for (int i=0;i<TEST_SIMPLE_ALLOC_ITERATION;i++)
    {
        byte * pData = arrPointer[i];
        int nAllocSize = arrAllocSize[i];

        for (int j=0;j<nAllocSize;j++)
        {
            TEST_ASSERT(pData[j] == DATA_BYTE_PATTERN);
        }
        
        //printf("FREE %d Location %i64u\r\n", nAllocSize, (ULONGLONG)pData);

        XFree(pData);
        pData = NULL;
    }

    XDumpLeaks();
    
}


void TestIncrementingSizeAlloc()
{
    printf("TestIncrementingSizeAlloc\n");

    int nMaxSizeAlloc = 65535;

    for (int nSize=1;nSize<nMaxSizeAlloc;nSize++)
    {
        byte * pData = (byte *)XAlloc(nSize);
        TEST_ASSERT(pData != NULL);
        ZeroMemory(pData, nSize);
        
        for (int j=0;j<nSize;j++)
        {
            //access the data
            pData[j] = DATA_BYTE_PATTERN;
        }

        XFree(pData);
        pData = NULL;
    }

    XDumpLeaks();
    
}



void TestSimpleLargeAlloc()
{
    int nSizeAlloc = 1024 * 1024;
    int nAllocation = MAX_ALLOCATION_BYTES / (1024*1024);
    byte ** ppAllocPointer = (byte **)XAlloc(nAllocation * sizeof(byte *));

    printf("TestSimpleLargeAlloc\n");

    for (int i=0;i<nAllocation;i++)
    {
        byte * pData = (byte *)XAlloc(nSizeAlloc);
        TEST_ASSERT(pData != NULL);
        ZeroMemory(pData, nSizeAlloc);
        
        for (int j=0;j<nSizeAlloc;j++)
        {
            pData[j] = DATA_BYTE_PATTERN;
        }

        ppAllocPointer[i] = pData;
        pData = NULL;
    }

    for (int i=0;i<nAllocation;i++)
    {
        byte * pData = ppAllocPointer[i];
        TEST_ASSERT(pData != NULL);

        for (int j=0;j<nSizeAlloc;j++)
        {
            TEST_ASSERT(pData[j] == DATA_BYTE_PATTERN);
        }
        
        XFree(pData);
        pData = NULL;
    }

    XFree(ppAllocPointer);

    XDumpLeaks();
}

volatile LONG gThreadIndex = 0;
void TestMultiThreadedRandomAlloc()
{
    HANDLE arrThreadArray[MAX_THREAD];

    printf("TestMultiThreadedRandomAlloc\n");

    ZeroMemory(arrThreadArray, sizeof(HANDLE) * MAX_THREAD);

    for (int nThreadIndex=0;nThreadIndex<MAX_THREAD;nThreadIndex++)
    {
        DWORD dwThreadId = 0;
        arrThreadArray[nThreadIndex] = ::CreateThread(NULL, 0, &ThreadProcRandomAlloc, NULL , 0,
                                                        &dwThreadId);

        TEST_ASSERT(arrThreadArray[nThreadIndex] != NULL);
    }

    //wait until all thread terminates
    ::WaitForMultipleObjectsEx(   MAX_THREAD,
                                  arrThreadArray,
                                  TRUE,
                                  INFINITE,
                                  FALSE
                                );

    for (int nThreadIndex=0;nThreadIndex<MAX_THREAD;nThreadIndex++)
    {
        TEST_ASSERT(arrThreadArray[nThreadIndex] != NULL);

        if (NULL != arrThreadArray[nThreadIndex])
        {
            ::CloseHandle(arrThreadArray[nThreadIndex]);
            arrThreadArray[nThreadIndex] = NULL;
        }
    }

    XDumpLeaks();    
}

//Each thread just allocate some and deallocate some
static DWORD ThreadProcRandomAlloc(void * pVoid)
{
    LONG nThreadIndex = InterlockedIncrement(&gThreadIndex);
    int nIteration = 200;

    for (int i=0;i<nIteration;i++)
    {
        int nAllocation = rand() % 100;
        byte ** ppAllocPointer = (byte **)XAlloc(nAllocation * sizeof(byte *));
        int * pSizeAlloc = (int *) XAlloc(nAllocation * sizeof(int));
        
        for (int i=0;i<nAllocation;i++)
        {
            int nSizeAlloc = rand() % 65535;
            byte * pData = (byte *)XAlloc(nSizeAlloc);
            TEST_ASSERT(pData != NULL);
            ZeroMemory(pData, nSizeAlloc);
            
            for (int j=0;j<nSizeAlloc;j++)
            {
                pData[j] = DATA_BYTE_PATTERN;
            }

            //printf("\tThread %d Alloc Size %d", nThreadIndex, nSizeAlloc);

            ppAllocPointer[i] = pData;
            pSizeAlloc[i] = nSizeAlloc;
            pData = NULL;
        }

        Sleep(rand() % 100);

        for (int i=0;i<nAllocation;i++)
        {
            byte * pData = ppAllocPointer[i];
            int nSizeAlloc = pSizeAlloc[i];
            TEST_ASSERT(pData != NULL);

            for (int j=0;j<nSizeAlloc;j++)
            {
                TEST_ASSERT(pData[j] == DATA_BYTE_PATTERN);
                pData[j] = 0;
            }

            //printf("\tThread %d XFree", nThreadIndex);
            
            XFree(pData);
            pData = NULL;
        }

        XFree(ppAllocPointer);
        XFree(pSizeAlloc);

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\tdb.cpp ===
#include "lbs.h"
#include "tests.h"
#include "unitutil.h"

class CFakeDb : public CDb
{
public:
    
    CFakeDb()
    {
    }
    
    ~CFakeDb()
    {
        _table.Term();
    }
    
    virtual bool UpdateLbRow(
        UINT32 uiTitleId, 
        UINT32 uiLbId, 
        UINT64 ui64Puid, 
        LbStat rgStats[], 
        DWORD cStats,
        UINT64 ui64LastUpdt
    )
    {
        TEST_ASSERT(cStats > 0);
        TEST_ASSERT(rgStats[0].statId == 10);
        TEST_ASSERT(rgStats[0].bType == LbspTypeIdInt32);
        
        Key key = { uiTitleId, uiLbId, ui64Puid };
        _table.Set(key, rgStats[0].i32);
        
        return true;
    }
    
    virtual bool RemoveLbRow(
        UINT32 uiTitleId, 
        UINT32 uiLbId, 
        UINT64 ui64Puid
    )
    {
        Key key = { uiTitleId, uiLbId, ui64Puid };
        _table.Remove(key, NULL);
        
        return true;
    }
    
    virtual bool ResetLb(
        UINT32 uiTitleId, 
        UINT32 uiLbId
    )
    {
        TArray<Key, 1000> data;
        THashtable<Key,INT32,Key>::Iterator it;
        _table.InitializeIterator(&it);
        
        Key key;
        while(it.GetNext(&key, NULL))
        {
            if(key.uiTitleId == uiTitleId && key.uiLbId == uiLbId)
            {
                data.Add(key);
            }
        }
        
        for(int i=0; i < data.GetSize(); i++)
        {
            _table.Remove(data.Get(i), NULL);
        }
    
        return true;
    }
    
    void Reset()
    {
        _table.Reset();
    }
    
    bool IsItThere(
        UINT32 uiTitleId, 
        UINT32 uiLbId, 
        UINT64 ui64Puid,
        INT32  stat
    )
    {
        Key key = {uiTitleId, uiLbId, ui64Puid };
        
        return _table.Get(key, &stat)    && 
               uiTitleId == key.uiTitleId &&
               uiLbId    == key.uiLbId    &&
               ui64Puid  == key.ui64Puid;
    }
    
protected:

    struct Key
    {
        UINT32 uiTitleId;
        UINT32 uiLbId;
        UINT64 ui64Puid;
        
        INLINE static bool IsEqual(Key& key1, Key& key2)
        {
            return key1.uiTitleId == key2.uiTitleId &&
                   key1.uiLbId    == key2.uiLbId    &&
                   key1.ui64Puid  == key2.ui64Puid; 
        }
        
        INLINE static DWORD GetHash(Key& key)
        {
            return static_cast<DWORD>(key.uiTitleId << 4) + 
                   static_cast<DWORD>(key.uiLbId << 2) +
                   static_cast<DWORD>(key.ui64Puid >> 32) + 
                   static_cast<DWORD>(key.ui64Puid);
        }
    };
    
    TStackHashtable< THashtable<Key,INT32,Key>, 1000 > _table; 
};

void TestDb()
{
    printf("TestDb\n");
 
    CTestConfig config;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CLb* pLb;
    IUmsClient* pUmsClient;
    CPersister persister;
    CFakeDb db;
    
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(persister.Init(&config,&ums,&db,&lbList,&bm, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 1, LbResetTypeNever, 0, 0, 0, &pLb) == CLbList::CreateLbStatusSucceeded);
   
    // Write some data 
    for(int i=1; i <= 300; i++)
    {
        LbStat rgStat[2];
        FillOutLbStatInt32 (rgStat[0], 10, i);
        FillOutLbStatInt64 (rgStat[1], LbStatIdRating, i);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,(UINT64)i,rgStat,ARRAY_SIZE(rgStat)));
    }

    // Overwrite 
    for(int i=1; i <= 300; i++)
    {
        LbStat rgStat[2];
        FillOutLbStatInt32 (rgStat[0], 10, -i);
        FillOutLbStatInt64 (rgStat[1], LbStatIdRating, -i);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,(UINT64)i,rgStat,ARRAY_SIZE(rgStat)));
    }
    
    // Reset even puids
    for(int i=2; i <= 300; i+=2)
    {
        TEST_ASSERT(pLb->ResetPuid(pUmsClient,(INT64)i));
    }
    
    // Drain
    pLb->Release();
    persister.Term();
    ums.ReleaseUmsClient(pUmsClient);
    ums.Shutdown();
    
    // Check
    for(int i=1; i <= 300; i+=2)
    {
        TEST_ASSERT(db.IsItThere(0xfeedfeed, 1, (UINT64)i, -i));
    }

    for(int i=2; i <= 300; i+=2)
    {
        TEST_ASSERT(!db.IsItThere(0xfeedfeed, 1, (UINT64)i, -i));
    }

    // Finish cleaning up     
    lbList.Term();
    ums.Term();
    bm.Term();
}

void TestDbSwapChangeList()
{
    printf("TestDbSwapChangeList\n");
 
    CTestConfig config;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CLb* pLb;
    IUmsClient* pUmsClient;
    CPersister persister;
    CFakeDb db;
    
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(persister.Init(&config,&ums,&db,&lbList,&bm, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 1, LbResetTypeNever, 0, 0, 0, &pLb) == CLbList::CreateLbStatusSucceeded);
   
    for(int j=0; j <= 10; j++)
    {
        // Write some data 
        for(int i=1; i <= 100; i++)
        {
            LbStat rgStat[2];
            FillOutLbStatInt32 (rgStat[0], 10, i);
            FillOutLbStatInt64 (rgStat[1], LbStatIdRating, i);
            TEST_ASSERT(pLb->StatWrite(pUmsClient,(UINT64)i,rgStat,ARRAY_SIZE(rgStat)));
        }
    
        // Check
        {
        lStartOver1:
        
            for(int i=1; i <= 100; i++)
            {
                if(!db.IsItThere(0xfeedfeed, 1, (UINT64)i, i))
                {
                    Sleep(1);
                    goto lStartOver1;
                }
            }
        }
        
        // Overwrite 
        for(int i=1; i <= 100; i++)
        {
            LbStat rgStat[2];
            FillOutLbStatInt32 (rgStat[0], 10, -i);
            FillOutLbStatInt64 (rgStat[1], LbStatIdRating, -i);
            TEST_ASSERT(pLb->StatWrite(pUmsClient,(UINT64)i,rgStat,ARRAY_SIZE(rgStat)));
        }
    
        // Check
        {
        lStartOver2:
        
            for(int i=1; i <= 100; i++)
            {
                if(!db.IsItThere(0xfeedfeed, 1, (UINT64)i, -i))
                {
                    Sleep(1);
                    goto lStartOver2;
                }
            }
        }
    }
    
    // Clean up
    pLb->Release();
    persister.Term();
    ums.ReleaseUmsClient(pUmsClient);
    ums.Shutdown();
    lbList.Term();
    ums.Term();
    bm.Term();
}

void TestDbReset()
{
    printf("TestDbReset\n");
 
    CTestConfig config;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CLb* rgpLb[3];
    IUmsClient* pUmsClient;
    CPersister persister;
    CFakeDb db;
    
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(persister.Init(&config,&ums,&db,&lbList,&bm, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    
    for(int i=0; i < 3; i++)
    {
        TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, i+1, LbResetTypeNever, 0, 0, 0, &rgpLb[i]) == CLbList::CreateLbStatusSucceeded);
    }
   
    // Write data to all three leaderboards
    for(int j=1; j <= 100; j++)
    {
        for(int i=0; i < 3; i++)
        {
            LbStat rgStat[2];
            FillOutLbStatInt32 (rgStat[0], 10, j);
            FillOutLbStatInt64 (rgStat[1], LbStatIdRating, j);
            TEST_ASSERT(rgpLb[i]->StatWrite(pUmsClient,(UINT64)j,rgStat,ARRAY_SIZE(rgStat)));
        }
    }
    
    // Reset leaderboard 2
    TEST_ASSERT(rgpLb[1]->ResetLb(pUmsClient));
    
    // Drain
    for(int i=0; i < 3; i++)
    {
        rgpLb[i]->Release();
    }

    persister.Term();
    ums.ReleaseUmsClient(pUmsClient);
    ums.Shutdown();

    // Check
    for(int j=1; j <= 100; j++)
    {
        TEST_ASSERT(db.IsItThere(0xfeedfeed, 1, (UINT64)j, j));
        TEST_ASSERT(!db.IsItThere(0xfeedfeed, 2, (UINT64)j, j));
        TEST_ASSERT(db.IsItThere(0xfeedfeed, 3, (UINT64)j, j));
    }

    // Clean up    
    lbList.Term();
    ums.Term();
    bm.Term();
}

class CTestDbFailure : public CFakeDb
{
public:

    CTestDbFailure() : _fError(FALSE)
    {}

    virtual bool UpdateLbRow(
        UINT32 uiTitleId, 
        UINT32 uiLbId, 
        UINT64 ui64Puid, 
        LbStat rgStats[], 
        DWORD cStats,
        UINT64 ui64LastUpdt
    )
    {
        if(!_fError)
        {
            return CFakeDb::UpdateLbRow(uiTitleId,uiLbId,ui64Puid,rgStats,cStats,ui64LastUpdt);
        }
        else
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "Test induced error");
            return false;
        }
    }
    
    virtual bool RemoveLbRow(UINT32 uiTitleId, UINT32 uiLbId, UINT64 ui64Puid)
    {
        if(!_fError)
        {
            return CFakeDb::RemoveLbRow(uiTitleId,uiLbId,ui64Puid);
        }
        else
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "Test induced error");
            return false;
        }
    }
    
    virtual bool ResetLb(UINT32 uiTitleId, UINT32 uiLbId)
    {
        if(!_fError)
        {
            return CFakeDb::ResetLb(uiTitleId,uiLbId);
        }
        else
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "Test induced error");
            return false;
        }
    }
    
    void SetEnduceError(bool fError)
    {
        ::InterlockedExchange(&_fError, fError ? TRUE : FALSE);
    }

    volatile LONG _fError;
};

void TestDbFailure()
{
    printf("TestDbFailure\n");
 
    CTestConfig config;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CLb* pLb;
    IUmsClient* pUmsClient;
    CPersister persister;
    CTestDbFailure db;
    
    config._dwPersisterRetryInterval = 300;
    
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(persister.Init(&config,&ums,&db,&lbList,&bm, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 1, LbResetTypeNever, 0, 0, 0, &pLb) == CLbList::CreateLbStatusSucceeded);
   
    
    // Write some data 
    db.SetEnduceError(true);
    for(int i=1; i <= 100; i++)
    {
        LbStat rgStat[2];
        FillOutLbStatInt32 (rgStat[0], 10, i);
        FillOutLbStatInt64 (rgStat[1], LbStatIdRating, i);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,(UINT64)i,rgStat,ARRAY_SIZE(rgStat)));
    }
    
    ::Sleep(100);
    
    // Check data hasn't been processed 
    for(int i=1; i <= 100; i++)
    {
        TEST_ASSERT(!db.IsItThere(0xfeedfeed, 1, (UINT64)i, i));
    }
    
    db.SetEnduceError(false);
    
    ::Sleep(100);
    
    // Check data committed
    {
    lStartOver1:
    
        for(int i=1; i <= 100; i++)
        {
            if(!db.IsItThere(0xfeedfeed, 1, (UINT64)i, i))
            {
                Sleep(1);
                goto lStartOver1;
            }
        }
    }

    // Reset leaderboard
    db.SetEnduceError(true);
    TEST_ASSERT(pLb->ResetLb(pUmsClient));
    
    ::Sleep(100);
    
    // Check reset hasn't been processed yet
    for(int i=1; i <= 100; i++)
    {
        TEST_ASSERT(db.IsItThere(0xfeedfeed, 1, (UINT64)i, i));
    }
    
    db.SetEnduceError(false);
    
    ::Sleep(100);
    
    // Check
    {
    lStartOver2:
    
        for(int i=1; i <= 100; i++)
        {
            if(db.IsItThere(0xfeedfeed, 1, (UINT64)i, i))
            {
                Sleep(1);
                goto lStartOver2;
            }
        }
    }
    
    // Clean up
    pLb->Release();
    persister.Term();
    ums.ReleaseUmsClient(pUmsClient);
    ums.Shutdown();
    lbList.Term();
    ums.Term();
    bm.Term();
}

class CTestDbBlobifyAndDeblobiby : public CDb
{
public:
    
    void Test()
    {
        {
            LbStat rgStats[6];
            BYTE blob[DbMaxStatBlobSize];
            DWORD cb = DbMaxStatBlobSize;
            FillOutLbStatString(rgStats[0], 10, "Hello world");
            FillOutLbStatDouble(rgStats[1], 20, 3.1415);
            FillOutLbStatInt64 (rgStats[2], 30, 0xaabbccddeeff9988);
            FillOutLbStatInt32 (rgStats[3], 40, 0x11223344);
            FillOutLbStatInt16 (rgStats[4], 50, 0x1144);
            FillOutLbStatInt8  (rgStats[5], 60, 0x13);
            TEST_ASSERT(BlobifyStats(rgStats, ARRAY_SIZE(rgStats), blob, &cb));
            TEST_ASSERT(cb == 54);
            
            CArenaMemAlloc alloc;
            LbStat rgParsedStats[10];
            DWORD cParsedStats = ARRAY_SIZE(rgParsedStats);
            ZeroMemory(rgParsedStats, sizeof(rgParsedStats));
            TEST_ASSERT(DeblobifyStats(&alloc, blob, cb, rgParsedStats, 
                &cParsedStats));
            TEST_ASSERT(cParsedStats == ARRAY_SIZE(rgStats));
            CUnitUtil::CompareLbStatArrays(rgStats, rgParsedStats, 
                cParsedStats);
        }
    }
};

void TestDbBlobifyAndDeblobify()
{
    printf("TestDbBlobifyAndDeblobify\n");
    
    CTestDbBlobifyAndDeblobiby test;
    test.Test();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\tbtree.cpp ===
#include "lbs.h"
#include "tests.h"
#include "unitutil.h"

class CTestBtree : public BTree
{
public:

    struct PidLevel
    {
        PidLevel()
        {
            pid = 0;
            uiLvl = 0;
        }
        
        PidLevel(BM_PAGEID pid, UINT32 uiLvl)
        {
            this->pid = pid;
            this->uiLvl = uiLvl;
        }
        
        BM_PAGEID pid;
        UINT32 uiLvl;
    };
    
    void VerifyPageLinks(IUmsClient* pUmsClient)
    {
        bool fRet = false;
        TEasyList<PidLevel> queue;
        CBPTPageRef pageRef;
        CBPTPageRef childPageRef;
        PidLevel next;
        
        TEST_ASSERT(queue.Init("queue", 1, true, &g_MemAlloc));
        
        TEST_ASSERT(queue.Enqueue(PidLevel(_pidRoot, 0)));
        
        UINT32 uiCurrentLvl = 0;
        bool fNewLvl = true;
        BM_PAGEID pidLink = 0;
        
        while(queue.Dequeue(&next))
        {
            TEST_ASSERT(next.uiLvl == uiCurrentLvl);
            TEST_ASSERT(next.pid == pidLink || fNewLvl);
            
            fNewLvl = false;
            
            TEST_ASSERT(GetPage(pUmsClient,next.pid,LOCK_MODE_IS,&pageRef));
            
            pidLink = pageRef.GetPage()->_pidRLink;

            if(pidLink == 0)
            {
                uiCurrentLvl++;
                fNewLvl = true;
            }
            
            if(pageRef.GetPage()->_wPageFlags & BPT_PAGE_FLAG_INTERNAL)
            {
                for(DWORD i=0; i < pageRef.GetPage()->_wEntryCount; i++)
                {
                    TEST_ASSERT(GetChildPageFromParent(pUmsClient,&pageRef,(WORD)i,LOCK_MODE_IS,&childPageRef));
                    TEST_ASSERT(queue.Enqueue(PidLevel(childPageRef.GetPage()->pageId, next.uiLvl + 1)));
                        
                    childPageRef.Release(pUmsClient);
                }
            }
            
            pageRef.Release(pUmsClient);
        }
    
        queue.Term();
    
        pageRef.Release(pUmsClient);
        childPageRef.Release(pUmsClient);
        queue.Term();
        
        return;
    }

};


static int KeyCompare(
    void* pParam,
    void* pKey1, 
    DWORD cbKey1, 
    void* pKey2, 
    DWORD cbKey2)
{
    // key is int
    return *((int*)pKey1) - *((int*)pKey2);
}

void TestBPTPage()
{
    printf("TestBPTPage\n");
    
    BTree btree;
    
    btree.TestInit(KeyCompare, sizeof(int));
    
    static const int capacity = 7;
    WORD wSlot;
    
    // Calculate buffer with exact size to accomodate the number of keys specified in 'capacity'
    BYTE rgPageBuffer[
        offsetof(BPTPage, _endOfHeader) + 
        (sizeof(int) + sizeof(UINT64) + sizeof(BPTPage::DATA_SIZE) + sizeof(BPTPage::ENTRY_META)) * capacity
        ];
    
    BPTPage* pPage = (BPTPage*) rgPageBuffer;
    
    pPage->Init(0, sizeof(rgPageBuffer));
    
    // Fill up the page
    int rgData[] = {  10, 20, 30, 5, 15, 25, 35 };
    for(int i=0; i < ARRAY_SIZE(rgData); i++)
    {
        UINT64 data = (UINT64) rgData[i];
        TEST_ASSERT(pPage->AddEntry(&btree, &rgData[i], sizeof(int), &data, sizeof(data), 1) == BPTPage::ADDENTRYSTATUS_SUCCEEDED);
        TEST_ASSERT(pPage->GetEntryIndexGE(&btree, &rgData[i], &wSlot));
    }
    
    TEST_ASSERT(pPage->IntegrityCheck(&btree, sizeof(rgPageBuffer)));

    // Page should be full by now. Inserting more will fail.
    int iData = 1000;
    UINT64 data = (UINT64) iData;
    TEST_ASSERT(pPage->AddEntry(&btree, &iData, sizeof(int), &data, sizeof(data), 1) == BPTPage::ADDENTRYSTATUS_ERROR_NOT_ENOUGH_SPACE);
    
    // See if we can reach all the entries we inserted
    for(int i=0; i < ARRAY_SIZE(rgData); i++)
    {
        WORD wSlot;
        TEST_ASSERT(pPage->GetEntryIndexGE(&btree, &rgData[i], &wSlot));
    }
    
    iData = 1000;
    TEST_ASSERT(!pPage->GetEntryIndexGE(&btree, &iData, &wSlot));

    // Delete and reinsert
    TEST_ASSERT(pPage->GetEntryIndexGE(&btree, &rgData[6], &wSlot));
    pPage->RemoveEntry(&btree, wSlot);
    TEST_ASSERT(!pPage->GetEntryIndexGE(&btree, &rgData[6], &wSlot));
                        
    TEST_ASSERT(pPage->GetEntryIndexGE(&btree, &rgData[5], &wSlot));
    pPage->RemoveEntry(&btree, wSlot);
    TEST_ASSERT(!pPage->GetEntryIndexGE(&btree, &rgData[5], &wSlot));

    data = rgData[6];
    TEST_ASSERT(pPage->AddEntry(&btree, &rgData[6], sizeof(int), &data, sizeof(data), 1) == BPTPage::ADDENTRYSTATUS_SUCCEEDED);
    TEST_ASSERT(pPage->GetEntryIndexGE(&btree, &rgData[6], &wSlot));
    
    data = rgData[5];
    TEST_ASSERT(pPage->AddEntry(&btree, &rgData[5], sizeof(int), &data, sizeof(data), 1) == BPTPage::ADDENTRYSTATUS_SUCCEEDED);
    TEST_ASSERT(pPage->GetEntryIndexGE(&btree, &rgData[5], &wSlot));
    
    TEST_ASSERT(pPage->IntegrityCheck(&btree, sizeof(rgPageBuffer)));
    
    // Delete a bunch of keys. The data section should look like swiss cheese now.
    int rgDeleteData[] = { 5, 25, 35 };
    int rgStillThere[] = { 10, 30, 20, 15 };
    for(int i=0; i < ARRAY_SIZE(rgDeleteData); i++)
    {
        TEST_ASSERT(pPage->GetEntryIndexGE(&btree, &rgDeleteData[i], &wSlot));
        pPage->RemoveEntry(&btree, wSlot);
    }
    for(int i=0; i < ARRAY_SIZE(rgDeleteData); i++)
    {
        TEST_ASSERT(!pPage->GetEntryIndexGE(&btree, &rgDeleteData[i], &wSlot));
    }
    TEST_ASSERT(pPage->_wEntryCount == ARRAY_SIZE(rgStillThere));
    for(int i=0; i < ARRAY_SIZE(rgStillThere); i++)
    {
        TEST_ASSERT(pPage->GetEntryIndexGE(&btree, &rgStillThere[i], &wSlot));
    }
    TEST_ASSERT(pPage->IntegrityCheck(&btree, sizeof(rgPageBuffer)));
    
    // Reinsert keys. It will require compacting the data section.
    for(int i=0; i < ARRAY_SIZE(rgDeleteData); i++)
    {
        data = rgDeleteData[i];
        TEST_ASSERT(pPage->AddEntry(&btree, &rgDeleteData[i], sizeof(int), &data, sizeof(data), 1) == BPTPage::ADDENTRYSTATUS_SUCCEEDED);
    }
    
    TEST_ASSERT(pPage->_wEntryCount == 7);
    for(int i=0; i < ARRAY_SIZE(rgData); i++)
    {
        WORD wSlot;
        TEST_ASSERT(pPage->GetEntryIndexGE(&btree, &rgData[i], &wSlot));
    }
    TEST_ASSERT(pPage->IntegrityCheck(&btree, sizeof(rgPageBuffer)));
}

class CTestBtreeTaskBase : public UMSTask
{
public:

#pragma pack(push, 1)
    struct DATA
    {
        int iData;
        BYTE rgStuffing[30];
        
        int GetSize()
        {
            return (int)(((UINT64)iData * 59) % sizeof(rgStuffing)) + sizeof(iData);
        }
        
    };
#pragma pack(pop)

    void Init(CBufferManager* pBM)
    {
        _pBM = pBM;
    }

    virtual void Free()
    {
    }
    
    CBufferManager* _pBM;
};

class CTestBtreeInsertAscending : public CTestBtreeTaskBase
{
    virtual void Execute(IUmsClient* pUmsClient)
    {
       const UINT64 count = 1000;
       const UINT64 prime = 773;
        
        BTree btree;
        
        TEST_ASSERT(btree.Init(pUmsClient,_pBM,KeyCompare,sizeof(int)));
        
        // Insert in ascending order
        for(UINT c=0; c < count; c++)
        {
            int i = c;

            DATA data;
            data.iData = i;
            TEST_ASSERT(btree.Insert(pUmsClient,&i,sizeof(int),&data, (WORD)data.GetSize()) == BTree::INSERTSTATUS_SUCCEEDED);
        }
        
        // Verify
        for(int i=0; i < count; i++)
        {
            BTree::Iterator it;
            TEST_ASSERT(btree.SearchLE(pUmsClient,&i,sizeof(int),false,&it) == BTree::SEARCHSTATUS_SUCCEEDED);

            DATA* pData = NULL;
            WORD cbData = 0;
            int* pKey   = NULL;
            WORD cbKey  = 0;

            TEST_ASSERT(it.Read());
            it.Get((void**)&pKey,&cbKey,(void**)&pData,&cbData);

            TEST_ASSERT(cbKey == sizeof(int));
            TEST_ASSERT(*pKey == i);
            TEST_ASSERT(cbData == pData->GetSize());
            TEST_ASSERT(pData->iData == i);
            
            TEST_ASSERT(it.GetRank() == i + 1);
        }

        btree.DumpMemoryStats(pUmsClient, &g_unitTraceCallback);
        
        btree.Term(pUmsClient);
    }
};

void TestBtreeInsertAscending()
{
    printf("TestBTreeInsertAscending\n");
    fflush(stdout);
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CTestConfig config;
    config._dwBufferManagerPageSize = 400;
    
    CBufferManager bm;
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    CTestBtreeInsertAscending task;
    
    task.Init(&bm);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    bm.Term();
    ums.Term();
}

class CTestBtreeInsertDescending : public CTestBtreeTaskBase
{
    virtual void Execute(IUmsClient* pUmsClient)
    {
       const UINT64 count = 1000;
       const UINT64 prime = 773;
        
        BTree btree;
        
        TEST_ASSERT(btree.Init(pUmsClient,_pBM,KeyCompare, sizeof(int)));
        
        // Insert in ascending order
        for(UINT c=0; c < count; c++)
        {
            int i = count-c-1;

            DATA data;
            data.iData = i;
            TEST_ASSERT(btree.Insert(pUmsClient,&i,sizeof(int),&data, (WORD)data.GetSize()) == BTree::INSERTSTATUS_SUCCEEDED);
        }
        
        // Verify
        for(int i=0; i < count; i++)
        {
            BTree::Iterator it;
            TEST_ASSERT(btree.SearchLE(pUmsClient,&i,sizeof(int),false,&it) == BTree::SEARCHSTATUS_SUCCEEDED);

            DATA* pData = NULL;
            WORD cbData = 0;
            int* pKey   = NULL;
            WORD cbKey  = 0;

            TEST_ASSERT(it.Read());
            it.Get((void**)&pKey,&cbKey,(void**)&pData,&cbData);

            TEST_ASSERT(cbKey == sizeof(int));
            TEST_ASSERT(*pKey == i);
            TEST_ASSERT(cbData == pData->GetSize());
            TEST_ASSERT(pData->iData == i);
            
            TEST_ASSERT(it.GetRank() == i + 1);
        }

        btree.DumpMemoryStats(pUmsClient, &g_unitTraceCallback);
        
        btree.Term(pUmsClient);
    }
};

void TestBtreeInsertDescending()
{
    printf("TestBtreeInsertDescending\n");
    fflush(stdout);
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CTestConfig config;
    config._dwBufferManagerPageSize = 400;
    
    CBufferManager bm;
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    CTestBtreeInsertDescending task;
    
    task.Init(&bm);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    bm.Term();
    ums.Term();
}

class CTestBtreeInsertRandom : public CTestBtreeTaskBase
{
    virtual void Execute(IUmsClient* pUmsClient)
    {
       const UINT64 count = 1000;
       const UINT64 prime = 773;
        
        BTree btree;
        
        TEST_ASSERT(btree.Init(pUmsClient,_pBM,KeyCompare, sizeof(int)));
        
        // Insert in 'random' order
        for(UINT c=0; c < count; c++)
        {
            int i = (int) (((UINT64)c * prime) % count);

            DATA data;
            data.iData = i;
            TEST_ASSERT(btree.Insert(pUmsClient,&i,sizeof(int),&data, (WORD)data.GetSize()) == BTree::INSERTSTATUS_SUCCEEDED);
        }
        
        // Verify
        for(int i=0; i < count; i++)
        {
            BTree::Iterator it;
            TEST_ASSERT(btree.SearchLE(pUmsClient,&i,sizeof(int),false,&it) == BTree::SEARCHSTATUS_SUCCEEDED);

            DATA* pData = NULL;
            WORD cbData = 0;
            int* pKey   = NULL;
            WORD cbKey  = 0;

            TEST_ASSERT(it.Read());
            it.Get((void**)&pKey,&cbKey,(void**)&pData,&cbData);

            TEST_ASSERT(cbKey == sizeof(int));
            TEST_ASSERT(*pKey == i);
            TEST_ASSERT(cbData == pData->GetSize());
            TEST_ASSERT(pData->iData == i);
            
            TEST_ASSERT(it.GetRank() == i + 1);
        }

        btree.DumpMemoryStats(pUmsClient, &g_unitTraceCallback);
        
        btree.Term(pUmsClient);
    }
};

void TestBtreeInsertRandom()
{
    printf("TestBtreeInsertRandom\n");
    fflush(stdout);
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CTestConfig config;
    config._dwBufferManagerPageSize = 400;
    
    CBufferManager bm;
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    CTestBtreeInsertRandom task;
    
    task.Init(&bm);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    bm.Term();
    ums.Term();
}

class CTestBtreeDeleteAscending : public CTestBtreeTaskBase
{
    virtual void Execute(IUmsClient* pUmsClient)
    {
       const UINT64 count = 1000;
       const UINT64 prime = 773;
        
        BTree btree;
        
        TEST_ASSERT(btree.Init(pUmsClient,_pBM,KeyCompare, sizeof(int)));
        
        // Insert 
        for(UINT c=0; c < count; c++)
        {
            int i = (int)c;

            DATA data;
            data.iData = i;
            TEST_ASSERT(btree.Insert(pUmsClient,&i,sizeof(int),&data, (WORD)data.GetSize()) == BTree::INSERTSTATUS_SUCCEEDED);
        }
        
        // Delete in ascending order
        for(UINT c=0; c < count; c++)
        {
            int i = (int)c;

            TEST_ASSERT(btree.Delete(pUmsClient, &i, sizeof(int)) == BTree::DELETESTATUS_SUCCEEDED);
        }

        btree.DumpMemoryStats(pUmsClient, &g_unitTraceCallback);
        
        btree.Term(pUmsClient);
    }
};

void TestBtreeDeleteAscending()
{
    printf("TestBtreeDeleteAscending\n");
    fflush(stdout);
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CTestConfig config;
    config._dwBufferManagerPageSize = 400;
    
    CBufferManager bm;
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    CTestBtreeDeleteAscending task;
    
    task.Init(&bm);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    bm.Term();
    ums.Term();
}


class CTestBtreeDeleteDescending : public CTestBtreeTaskBase
{
    virtual void Execute(IUmsClient* pUmsClient)
    {
       const UINT64 count = 1000;
       const UINT64 prime = 773;
        
        BTree btree;
        
        TEST_ASSERT(btree.Init(pUmsClient,_pBM,KeyCompare, sizeof(int)));
        
        // Insert 
        for(UINT c=0; c < count; c++)
        {
            int i = (int)c;

            DATA data;
            data.iData = i;
            TEST_ASSERT(btree.Insert(pUmsClient,&i,sizeof(int),&data, (WORD)data.GetSize()) == BTree::INSERTSTATUS_SUCCEEDED);
        }
        
        // Delete in descending order
        for(UINT c=0; c < count; c++)
        {
            int i = (int)(count - c - 1);
            
            TEST_ASSERT(btree.Delete(pUmsClient, &i, sizeof(int)) == BTree::DELETESTATUS_SUCCEEDED);
        }

        btree.DumpMemoryStats(pUmsClient, &g_unitTraceCallback);
        
        btree.Term(pUmsClient);
    }
};

void TestBtreeDeleteDescending()
{
    printf("TestBtreeDeleteDescending\n");
    fflush(stdout);
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CTestConfig config;
    config._dwBufferManagerPageSize = 400;
    
    CBufferManager bm;
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    CTestBtreeDeleteDescending task;
    
    task.Init(&bm);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    bm.Term();
    ums.Term();
}

 
class CTestBtreeDeleteRandom : public CTestBtreeTaskBase
{
    virtual void Execute(IUmsClient* pUmsClient)
    {
       const UINT64 count = 1000;
       const UINT64 prime = 773;
        
        CTestBtree btree;
        
        TEST_ASSERT(btree.Init(pUmsClient,_pBM,KeyCompare, sizeof(int)));
        
        // Insert 
        for(UINT c=0; c < count; c++)
        {
            int i = c;

            DATA data;
            data.iData = i;
            TEST_ASSERT(btree.Insert(pUmsClient,&i,sizeof(int),&data, (WORD)data.GetSize()) == BTree::INSERTSTATUS_SUCCEEDED);
        }
        
        btree.VerifyPageLinks(pUmsClient);
        
        // Delete in random order
        for(UINT c=0; c < count; c++)
        {
            int i = (int) (((UINT64)c * prime) % count);
            
            TEST_ASSERT(btree.Delete(pUmsClient, &i, sizeof(int)) == BTree::DELETESTATUS_SUCCEEDED);
            
            if(c % 10 == 0)
            {
                btree.VerifyPageLinks(pUmsClient);
            }
        }

        btree.DumpMemoryStats(pUmsClient, &g_unitTraceCallback);
        
        btree.Term(pUmsClient);
    }
};

void TestBtreeDeleteRandom()
{
    printf("TestBtreeDeleteRandom\n");
    fflush(stdout);
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CTestConfig config;
    config._dwBufferManagerPageSize = 400;
    
    CBufferManager bm;
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    CTestBtreeDeleteRandom task;
    
    task.Init(&bm);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    bm.Term();
    ums.Term();
}

class CTestBtreeEnum : public CTestBtreeTaskBase
{
    virtual void Execute(IUmsClient* pUmsClient)
    {
       const UINT64 count = 1000;
       const UINT64 prime = 773;
        
        BTree btree;
        
        TEST_ASSERT(btree.Init(pUmsClient,_pBM,KeyCompare, sizeof(int)));
        
        // Insert in 'random' order
        for(UINT c=0; c < count; c++)
        {
            int i = (int) (((UINT64)c * prime) % count);

            DATA data;
            data.iData = i;
            TEST_ASSERT(btree.Insert(pUmsClient,&i,sizeof(int),&data, (WORD)data.GetSize()) == BTree::INSERTSTATUS_SUCCEEDED);
        }
        
        {
            DATA* pData = NULL;
            WORD cbData = 0;
            int* pKey   = NULL;
            WORD cbKey  = 0;

            int i=0;
            BTree::Iterator it;
            TEST_ASSERT(btree.SearchLE(pUmsClient,&i,sizeof(int),false,&it) == BTree::SEARCHSTATUS_SUCCEEDED);

            for(i=0; i < count; i++)
            {
                TEST_ASSERT(it.Read());
                it.Get((void**)&pKey,&cbKey,(void**)&pData,&cbData);
                TEST_ASSERT(*pKey == i);
            }
            TEST_ASSERT(!it.Read());

        }

        btree.DumpMemoryStats(pUmsClient, &g_unitTraceCallback);
        
        btree.Term(pUmsClient);
    }
};

void TestBtreeEnum()
{
    printf("TestBtreeEnum\n");
    fflush(stdout);
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CTestConfig config;
    config._dwBufferManagerPageSize = 400;
    
    CBufferManager bm;
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    CTestBtreeEnum task;
    
    task.Init(&bm);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    bm.Term();
    ums.Term();
}

class CTestBtreeRank : public CTestBtreeTaskBase
{
    virtual void Execute(IUmsClient* pUmsClient)
    {
       const UINT64 count = 1000;
       const UINT64 prime = 773;

        BTree btree;
        
        TEST_ASSERT(btree.Init(pUmsClient,_pBM,KeyCompare, sizeof(int)));
        
        // Insert in 'random' order
        for(UINT c=0; c < count; c++)
        {
            int i = (int) (((UINT64)c * prime) % count);

            DATA data;
            data.iData = i;
            TEST_ASSERT(btree.Insert(pUmsClient,&i,sizeof(int),&data, (WORD)data.GetSize()) == BTree::INSERTSTATUS_SUCCEEDED);
        }
        
        // Delete half
        for(UINT c=0; c < count/2; c++)
        {
            int i = (int) (((UINT64)c * prime) % count);
            TEST_ASSERT(btree.Delete(pUmsClient,&i,sizeof(int)) == BTree::DELETESTATUS_SUCCEEDED);
        }
        
        // Reinsert
        for(UINT c=0; c < count/2; c++)
        {
            int i = (int) (((UINT64)c * prime) % count);

            DATA data;
            data.iData = i;
            TEST_ASSERT(btree.Insert(pUmsClient,&i,sizeof(int),&data, (WORD)data.GetSize()) == BTree::INSERTSTATUS_SUCCEEDED);
        }
        
        // Verify
        DATA* pData = NULL;
        WORD cbData = 0;
        int* pKey   = NULL;
        WORD cbKey  = 0;
        
		int i;
        for(i=0; i < count; i++)
        {
            // Search 
            BTree::Iterator it;
            TEST_ASSERT(btree.SearchLE(pUmsClient,&i,sizeof(int),false,&it) == BTree::SEARCHSTATUS_SUCCEEDED);

            pData  = NULL;
            cbData = 0;
            pKey   = NULL;
            cbKey  = 0;

            TEST_ASSERT(it.Read());
            it.Get((void**)&pKey,&cbKey,(void**)&pData,&cbData);

            TEST_ASSERT(cbKey == sizeof(int));
            TEST_ASSERT(*pKey == i);
            TEST_ASSERT(cbData == pData->GetSize());
            TEST_ASSERT(pData->iData == i);
            
            TEST_ASSERT(it.GetRank() == i + 1);
            
            it.Reset();
            
            // Inverse lookup
            TEST_ASSERT(btree.SearchByRank(pUmsClient,(DWORD)i+1,LOCK_MODE_IS,&it));
            
            pData  = NULL;
            cbData = 0;
            pKey   = NULL;
            cbKey  = 0;
            
            TEST_ASSERT(it.Read());
            it.Get((void**)&pKey,&cbKey,(void**)&pData,&cbData);
            
            TEST_ASSERT(cbKey == sizeof(int));
            TEST_ASSERT(*pKey == i);
            TEST_ASSERT(cbData == pData->GetSize());
            TEST_ASSERT(pData->iData == i);
            
            TEST_ASSERT(it.GetRank() == i + 1);
        }
        
        pData  = NULL;
        cbData = 0;
        pKey   = NULL;
        cbKey  = 0;
        
        BTree::Iterator it;
        TEST_ASSERT(btree.SearchByRank(pUmsClient,(DWORD)i+1,LOCK_MODE_IS,&it));
        
        TEST_ASSERT(it.Read());
        it.Get((void**)&pKey,&cbKey,(void**)&pData,&cbData);
        
        TEST_ASSERT(cbKey == sizeof(int));
        TEST_ASSERT(*pKey == i-1);
        TEST_ASSERT(cbData == pData->GetSize());
        TEST_ASSERT(pData->iData == i-1);
        
        TEST_ASSERT(it.GetRank() == i);
    }
};

void TestBtreeRank()
{
    printf("TestBtreeRank\n");
    fflush(stdout);
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CTestConfig config;
    config._dwBufferManagerPageSize = 400;
    
    CBufferManager bm;
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    CTestBtreeRank task;
    
    task.Init(&bm);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    bm.Term();
    ums.Term();
}

class CTestBtreeSearchEmpty : public CTestBtreeTaskBase
{
    virtual void Execute(IUmsClient* pUmsClient)
    {
        BTree btree;
        BTree::Iterator it;
        
        TEST_ASSERT(btree.Init(pUmsClient,_pBM,KeyCompare,sizeof(int)));
        
        int iKey;
        
        TEST_ASSERT(btree.SearchLE(pUmsClient, &iKey, sizeof(iKey), false, &it));
        TEST_ASSERT(!it.Read());
        
        TEST_ASSERT(btree.SearchByRank(pUmsClient,1,LOCK_MODE_IS,&it));
        TEST_ASSERT(!it.Read());

        btree.Term(pUmsClient);
    }
};

void TestBtreeSearchEmpty()
{
    printf("TestBtreeSearchEmpty\n");
    fflush(stdout);
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CTestConfig config;
    config._dwBufferManagerPageSize = 400;
    
    CBufferManager bm;
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    CTestBtreeSearchEmpty task;
    
    task.Init(&bm);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    bm.Term();
    ums.Term();
}


class CTestBtreeConcurrencyTask : public UMSTask
{
public:

    struct KEY
    {
        INT64 _rating;
        DWORD _dwCounter;
    };
    
    struct DATA
    {
        INT  _iOdd;
        BYTE _rgData[96];
    };

    static int KeyCompare(
        void* pParam,
        void* pRawKey1, 
        DWORD cbRawKey1,
        void *pRawKey2,
        DWORD cbRawKey2
    )
    {
        KEY* pKey1 = (KEY*)pRawKey1;
        KEY* pKey2 = (KEY*)pRawKey2;
        
        int cmp = (int) (pKey2->_rating - pKey1->_rating); 
        
        if(cmp == 0)
            cmp = (int)pKey1->_dwCounter - (int)pKey2->_dwCounter;
            
        return cmp;
    }
    
    class CTask : public UMSTask
    {
    public:
    
        void Init(int iOdd, UINT64 prime, BTree* pbtree)
        {
            _iOdd = iOdd;
            _pbtree = pbtree;
            _lDone = 0;
            _prime = prime;
        }
    
        virtual void Execute(IUmsClient *pUmsClient)
        {
            const UINT   cycles = 600000;
            const UINT64 count  = 150000;
    
            KEY  key;
            DATA data;
            data._iOdd = _iOdd;
            for(UINT c=0; c < count; c++)
            {
                key._rating    = ((UINT64)c * _prime) % count;
                key._dwCounter = (DWORD)_iOdd;

                TEST_ASSERT(_pbtree->Insert(pUmsClient,&key,sizeof(key),&data, sizeof(DATA)) == BTree::INSERTSTATUS_SUCCEEDED);
            }
            
            for(UINT c=0; c < cycles; c++)
            {
                key._rating    = ((UINT64)c * _prime) % count;
                key._dwCounter = (DWORD)_iOdd;
       
                TEST_ASSERT(_pbtree->Delete(pUmsClient,&key,sizeof(key)) == BTree::DELETESTATUS_SUCCEEDED);
                TEST_ASSERT(_pbtree->Insert(pUmsClient,&key,sizeof(key),&data, sizeof(DATA)) == BTree::INSERTSTATUS_SUCCEEDED);
            }
            
            for(UINT c=0; c < count; c++)
            {
                key._rating    = ((UINT64)c * _prime) % count;
                key._dwCounter = (DWORD)_iOdd;

                TEST_ASSERT(_pbtree->Delete(pUmsClient,&key,sizeof(key)) == BTree::DELETESTATUS_SUCCEEDED);
            }
        }
        
        class CCompareKey
        {
        public:
            
            INLINE DWORD GetHash(KEY key)
            {
                static const DWORD largest_prime_dword = 4294967279;
                return (DWORD) (((key._rating % largest_prime_dword) << 2) + key._dwCounter);
            }
            
            INLINE bool IsEqual(KEY keyA, KEY keyB)
            {
                return keyA._rating    == keyB._rating &&
                       keyA._dwCounter == keyB._dwCounter;
            }
        };
        
        virtual void Free()
        {
            InterlockedExchange(&_lDone, 1);
        }
    
        BTree* _pbtree;
        int _iOdd;
        LONG _lDone;
        UINT64 _prime;
    };
    

    void Init(UMS* pUMS, CBufferManager* pBM)
    {
        _pUMS = pUMS;
        _pBM  = pBM;
        _lDone = 0;
    }
    
    virtual void Execute(IUmsClient *pUmsClient)
    {
        BTree btree1;
        //BTree btree2;

        TEST_ASSERT(btree1.Init(pUmsClient,_pBM,KeyCompare, sizeof(KEY)));
        //TEST_ASSERT(btree2.Init(pUmsClient,_pBM,&info));
    
        CTask task1, task2;
        
        task1.Init(0, 70003, &btree1);
        task2.Init(1, 90001/*50021*/, &btree1);
    
        TEST_ASSERT(_pUMS->AddNewTask(&task1));
        TEST_ASSERT(_pUMS->AddNewTask(&task2));
        //task2._lDone = 1;

        DWORD dwNow = GetTickCount();
        while(!task1._lDone || !task2._lDone)
        {
            Sleep(50);
        }
        printf("  Time=%f seconds\n", (GetTickCount() - dwNow) / 1000.0);
        
        btree1.DumpStats();
        //btree2.DumpStats();
        
        btree1.Term(pUmsClient);
        //btree2.Term(pUmsClient);
    }
    
    virtual void Free()
    {
        InterlockedExchange(&_lDone, 1);
    }
    
    UMS* _pUMS;
    CBufferManager* _pBM;
    LONG _lDone;
};

void TestBtreeConcurrency()
{
    printf("TestBtreeConcurrency\n");
    fflush(stdout);
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CTestConfig config;
    config._dwBufferManagerPageSize = 8192;
    
    CBufferManager bm;
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    CTestBtreeConcurrencyTask task;
    
    task.Init(&ums,&bm);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    while(!task._lDone)
    {
        Sleep(50);
    }
    
    ums.Shutdown();
    ums.DumpStats();
    
    bm.Term();
    ums.Term();
}

class CPerfBtreeTask : public UMSTask
{
public:

#pragma pack(push, 1)
    struct DATA
    {
        int iData;
        BYTE rgStuffing[101];
    };
#pragma pack(pop)

    void Init(CBufferManager* pBM)
    {
        _pBM = pBM;
    }

    virtual void Execute(IUmsClient *pUmsClient)
    {
        BTree btree;

        TEST_ASSERT(btree.Init(pUmsClient,_pBM,KeyCompare, sizeof(int)));

        const UINT64 count = 300000;
        const UINT64 prime = 70003;

//         const UINT64 count = 12500;
//         const UINT64 prime = 70003;

//        const UINT64 count = 100;
//        const UINT64 prime = 773;

        printf("Inserting\n");
        DWORD dwNow = GetTickCount();
        for(UINT c=0; c < count; c++)
        {
            int i = (int) (((UINT64)c * prime) % count);

//             printf("Inserting %d(0x%x)\n", i, i);

            DATA data;
            data.iData = i;
            TEST_ASSERT(btree.Insert(pUmsClient,&i,sizeof(int),&data, sizeof(DATA)) == BTree::INSERTSTATUS_SUCCEEDED);

//             btree.DumpTree(pUmsClient);

        }


        printf("Elapsed=%f\n", (GetTickCount()-dwNow)/1000.0);
//         btree.DumpTree(pUmsClient);

        printf("Searching\n");
        dwNow = GetTickCount();
        for(int i=0; i < count; i++)
        {
            BTree::Iterator it;
            TEST_ASSERT(btree.SearchLE(pUmsClient,&i,sizeof(int),false,&it) == BTree::SEARCHSTATUS_SUCCEEDED);

            DATA* pData = NULL;
            WORD cbData = 0;
            int* pKey   = NULL;
            WORD cbKey  = 0;

            TEST_ASSERT(it.Read());
            it.Get((void**)&pKey,&cbKey,(void**)&pData,&cbData);

//             TEST_ASSERT((PtrToUlong(pKey) & 3) == 0);
//             TEST_ASSERT((PtrToUlong(pData) & 3) == 0);

            TEST_ASSERT(cbKey == sizeof(int));
            TEST_ASSERT(*pKey == i);
            TEST_ASSERT(cbData == sizeof(DATA));
            TEST_ASSERT(pData->iData == i);

            TEST_ASSERT(it.GetRank() == i + 1);
        }
        printf("Elapsed=%f\n", (GetTickCount()-dwNow)/1000.0);

        dwNow = GetTickCount();
        printf("Enumerating\n");
        {
            DATA* pData = NULL;
            WORD cbData = 0;
            int* pKey   = NULL;
            WORD cbKey  = 0;

            int i=0;
            BTree::Iterator it;
            TEST_ASSERT(btree.SearchLE(pUmsClient,&i,sizeof(int),false,&it) == BTree::SEARCHSTATUS_SUCCEEDED);

            for(i=0; i < count; i++)
            {
                TEST_ASSERT(it.Read());

                it.Get((void**)&pKey,&cbKey,(void**)&pData,&cbData);
                TEST_ASSERT(*pKey == i);
            }
        }
        printf("Elapsed=%f\n", (GetTickCount()-dwNow)/1000.0);

        printf("Deleting\n");
        dwNow = GetTickCount();
        {
            for(UINT c=0; c < count; c++)
            {
//                 if(c == 39 || c == 40)
//                 {
//                     btree.DumpTree(pUmsClient);
//                 }

                int i = (int) (((UINT64)c * prime) % count);

                //i=c;

                TEST_ASSERT(btree.Delete(pUmsClient, &i, sizeof(int)) == BTree::DELETESTATUS_SUCCEEDED);

//                 for(int j=i + 1; j < count; j++)
//                 {
//                     DATA* pData = NULL;
//                     WORD cbData = 0;
//                     int* pKey   = NULL;
//                     WORD cbKey  = 0;
//
//                     BTree::Iterator it;
//                     TEST_ASSERT(btree.Search(pUmsClient,&j,sizeof(int),&it) == BTree::SEARCHSTATUS_SUCCEEDED);
//
//                     it.Get((void**)&pKey,&cbKey,(void**)&pData,&cbData);
//                     TEST_ASSERT(*pKey == j);
//                 }
            }
        }
        printf("Elapsed=%f\n", (GetTickCount()-dwNow)/1000.0);

        btree.DumpStats();

        printf("Terminating\n");

//        btree.DumpTree(pUmsClient);

        btree.Term(pUmsClient);
    }

    virtual void Free()
    {
    }

    CBufferManager* _pBM;
};

void PerfBtree()
{
    printf("PerfBtree\n");
    fflush(stdout);
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CTestConfig config;
    config._dwBufferManagerPageSize = 16384;
    
    CBufferManager bm;
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    CPerfBtreeTask task;
    
    task.Init(&bm);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    bm.Term();
    ums.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\tests.h ===
#pragma once

#define TEST_ASSERT(x) \
    if(!(x)) \
    { \
        printf("Test error in %s line %d: %s", __FILE__, __LINE__, #x); \
        printf("LastError:\n%s", CGlobalError::GetCurrentMessage()); \
        DebugBreak(); \
    } \

void TestSimpleAlloc();
void TestSimpleLargeAlloc();
void TestMultiThreadedRandomAlloc();
void TestIncrementingSizeAlloc();
static DWORD ThreadProcRandomAlloc(void * pRaw);
    
// Test cases
void TestCStr();
void TestCLFStack();
void TestCLFQueue();
void TestTList();
void TestCFixedSizeMemPool();
void TestCArenaMemAlloc();
void TestTArray();
void TestCHashtable();
void TestTHeap();
void TestStressHeapRemoveAt();
void TestCServerTimerSimple();
void TestCServerTimerWrap();

void TestUMSSimple();
void TestUMSLocks();
void TestUMSLockCompability();

// tbuffer.cpp
void TestBufferManagerSimple();
void TestBufferManagerPaging();

void TestBPTPage();
void TestBtreeInsertAscending();
void TestBtreeInsertDescending();
void TestBtreeInsertRandom();
void TestBtreeDeleteAscending();
void TestBtreeDeleteDescending();
void TestBtreeDeleteRandom();
void TestBtreeEnum();
void TestBtreeRank();
void TestBtreeSearchEmpty();
void TestBtreeConcurrency();

// tnet.cpp
void TestNetParameterPermutation();
void TestNetMessageReply();
void TestNetHelloTimeout();
void TestNetLargeRowset();
void TestNetConcurrency();
void TestNetRequest();
void TestNetProcs();
void TestNetPing();

// tlb.cpp
void TestCLbStatBlob();
void TestLbUpdateAndRead();
void TestLbUpdate();
void TestLbEnum();
void TestLbRankedEntryCount();
void TestLbGetRankForPuid();
void TestLbReset();
void TestLbLoad();
void TestLbDecay();
void TestLbAutoReset();
void TestLbMaxEntryCount();
void TestLbTrim();

// tdb.cpp
void TestDb();
void TestDbSwapChangeList();
void TestDbReset();
void TestDbFailure();
void TestDbBlobifyAndDeblobify();

//oledb test
void TestOleDBSimple();
void OleDbExecuteProcedureNoResult(CODBWSession sql, LPCWSTR pwszProc, ...);
void OleDbVerifyRead(CODBWSession sql, LPCWSTR pwszProc, ...);
void OpenOleDBConnection();
void CloseOleDBConnection();
void TestMultiThreadedOleDB();
static DWORD ThreadProcOleWriteVerify(void * pVoid);

// Perf
void PerfBtree();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\tlb.cpp ===
#include "lbs.h"
#include "tests.h"
#include "unitutil.h"

static void VerifyStatBlob(
    LbStat rgStats[],
    DWORD  cStats,
    BYTE*  pBlob,
    DWORD  cbBlob
)
{
    if(cStats > 0)
    {
        TEST_ASSERT(cbBlob > sizeof(LbBlob));
        WORD wStatCount = ((LbBlob*)pBlob)->wStatCount;
        TEST_ASSERT(wStatCount == cStats);
        pBlob += sizeof(LbBlob);
        cbBlob -= sizeof(LbBlob);
    }
    
    for(DWORD dwStatNdx=0; dwStatNdx < cStats; dwStatNdx++)
    {
        LbBlobStat* pBlobStat = (LbBlobStat*) pBlob;
        
        TEST_ASSERT(cbBlob >= offsetof(LbBlobStat, i8));
        TEST_ASSERT(pBlobStat->statId == rgStats[dwStatNdx].statId);
        TEST_ASSERT(pBlobStat->bType == rgStats[dwStatNdx].bType);
        DWORD dwSize;
        switch(rgStats[dwStatNdx].bType)
        {
        case LbspTypeIdInt8:
            TEST_ASSERT(cbBlob >= offsetof(LbBlobStat, i8) + sizeof(INT8));
            TEST_ASSERT(pBlobStat->i8 == rgStats[dwStatNdx].i8);
            dwSize = offsetof(LbBlobStat, i8) + sizeof(INT8);
            break;
        case LbspTypeIdInt16:
            TEST_ASSERT(cbBlob >= offsetof(LbBlobStat, i16) + sizeof(INT16));
            TEST_ASSERT(pBlobStat->i16 == rgStats[dwStatNdx].i16);
            dwSize = offsetof(LbBlobStat, i16) + sizeof(INT16);
            break;
        case LbspTypeIdInt32:
            TEST_ASSERT(cbBlob >= offsetof(LbBlobStat, i32) + sizeof(INT32));
            TEST_ASSERT(pBlobStat->i32 == rgStats[dwStatNdx].i32);
            dwSize = offsetof(LbBlobStat, i32) + sizeof(INT32);
            break;
        case LbspTypeIdInt64:
            TEST_ASSERT(cbBlob >= offsetof(LbBlobStat, i64) + sizeof(INT64));
            TEST_ASSERT(pBlobStat->i64 == rgStats[dwStatNdx].i64);
            dwSize = offsetof(LbBlobStat, i64) + sizeof(INT64); 
            break;
        case LbspTypeIdDouble:
            TEST_ASSERT(cbBlob >= offsetof(LbBlobStat, d) + sizeof(double));
            TEST_ASSERT(pBlobStat->d == rgStats[dwStatNdx].d);
            dwSize = offsetof(LbBlobStat, d) + sizeof(double);
            break;
        case LbspTypeIdString:
            TEST_ASSERT(cbBlob >= offsetof(LbBlobStat, str) + sizeof(WORD) + 
                rgStats[dwStatNdx].str.wStrLen);
                
            TEST_ASSERT(pBlobStat->str.wStrLen == rgStats[dwStatNdx].str.wStrLen);
                
            TEST_ASSERT(memcmp(pBlobStat->str.str, rgStats[dwStatNdx].str.pstr, 
                rgStats[dwStatNdx].str.wStrLen) == 0);
            
            dwSize = offsetof(LbBlobStat, i8) + sizeof(WORD)
                + rgStats[dwStatNdx].str.wStrLen;
            
            break;
        default:
            
            TEST_ASSERT(false);
        }
        
        pBlob  += dwSize;
        cbBlob -= dwSize;
    }
    
    TEST_ASSERT(cbBlob == 0);
}


void TestCLbStatBlob()
{
    {
        // Blob empty. New stats.
        CArenaMemAlloc alloc;
        BYTE  rgBlobBuffer[LbMaxStatBuffer];
        DWORD cbBuffer = 0;
        DWORD cbBufferSize = sizeof(rgBlobBuffer);
        CConstStr helloWorld(REFANDSIZE("Hello World"));
        CConstStr einstein(REFANDSIZE(
            "Great spirits have always found violent opposition from "
            "mediocrities. The latter cannot understand it when a man does "
            "not thoughtlessly submit to hereditary prejudices but honestly "
            "and courageously uses his intelligence."));
        
        LbStat rgStats[12];
        ZeroMemory(rgStats, sizeof(rgStats));
        rgStats[0].statId = 5;
        rgStats[0].bType  = LbspTypeIdInt8;
        rgStats[0].i8     = 0x12;
        rgStats[1].statId = 10;
        rgStats[1].bType  = LbspTypeIdInt16;
        rgStats[1].i16     = 0x1234;
        rgStats[2].statId = 15;
        rgStats[2].bType  = LbspTypeIdInt32;
        rgStats[2].i32     = 0x12345678;
        rgStats[3].statId = 20;
        rgStats[3].bType  = LbspTypeIdInt64;
        rgStats[3].i64     = 0x1234567890abcdef;
        rgStats[4].statId = 25;
        rgStats[4].bType  = LbspTypeIdDouble;
        rgStats[4].d      = 3.14159265;
        rgStats[5].statId = 30;
        rgStats[5].bType  = LbspTypeIdString;
        rgStats[5].str.wStrLen = helloWorld.GetLength();
        rgStats[5].str.pstr = (CHAR*) helloWorld.cstr();
        rgStats[6].statId = 35;
        rgStats[6].bType  = LbspTypeIdInt8;
        rgStats[6].i8     = 0x12;
        rgStats[7].statId = 40;
        rgStats[7].bType  = LbspTypeIdInt16;
        rgStats[7].i16     = 0x1234;
        rgStats[8].statId = 45;
        rgStats[8].bType  = LbspTypeIdInt32;
        rgStats[8].i32     = 0x12345678;
        rgStats[9].statId = 50;
        rgStats[9].bType  = LbspTypeIdInt64;
        rgStats[9].i64     = 0x1234567890abcdef;
        rgStats[10].statId = 55;
        rgStats[10].bType  = LbspTypeIdDouble;
        rgStats[10].d      = 3.14159265;
        rgStats[11].statId = 60;
        rgStats[11].bType  = LbspTypeIdString;
        rgStats[11].str.wStrLen = einstein.GetLength();
        rgStats[11].str.pstr = (CHAR*)einstein.cstr();
        
        cbBuffer = cbBufferSize;
        
        TEST_ASSERT(LbBlob::UpdateStats(rgStats,ARRAY_SIZE(rgStats),NULL,0,rgBlobBuffer, &cbBuffer));

        VerifyStatBlob(rgStats,ARRAY_SIZE(rgStats),rgBlobBuffer,cbBuffer);
        
        // Parse stats and verify
        LbStat  rgParsedStats[ARRAY_SIZE(rgStats) + 2];
        ZeroMemory(rgParsedStats, sizeof(rgParsedStats));
        DWORD   cStats = ARRAY_SIZE(rgParsedStats);
        TEST_ASSERT(LbBlob::ParseStats(rgBlobBuffer,cbBuffer,&alloc,rgParsedStats,&cStats));
        TEST_ASSERT(cStats == 12);
        CUnitUtil::CompareLbStatArrays(rgStats, rgParsedStats, cStats);
    }

    {
        // Adding new stats to existing blob
        CArenaMemAlloc alloc;
        BYTE  rgBlobBuffer[LbMaxStatBuffer];
        DWORD cbBuffer = 0;
        BYTE  rgBlobBuffer2[LbMaxStatBuffer];
        DWORD cbBuffer2 = 0;
        DWORD cbBufferSize = sizeof(rgBlobBuffer);
        CConstStr helloWorld(REFANDSIZE("Hello World"));
        CConstStr einstein(REFANDSIZE(
            "Great spirits have always found violent opposition from "
            "mediocrities. The latter cannot understand it when a man does "
            "not thoughtlessly submit to hereditary prejudices but honestly "
            "and courageously uses his intelligence."));
        
        LbStat rgStats[6];
        ZeroMemory(rgStats, sizeof(rgStats));
        rgStats[0].statId = 10;
        rgStats[0].bType  = LbspTypeIdInt8;
        rgStats[0].i8     = 0x12;
        rgStats[1].statId = 20;
        rgStats[1].bType  = LbspTypeIdInt16;
        rgStats[1].i16     = 0x1234;
        rgStats[2].statId = 30;
        rgStats[2].bType  = LbspTypeIdInt32;
        rgStats[2].i32     = 0x12345678;
        rgStats[3].statId = 40;
        rgStats[3].bType  = LbspTypeIdInt64;
        rgStats[3].i64     = 0x1234567890abcdef;
        rgStats[4].statId = 50;
        rgStats[4].bType  = LbspTypeIdDouble;
        rgStats[4].d      = 3.14159265;
        rgStats[5].statId = 60;
        rgStats[5].bType  = LbspTypeIdString;
        rgStats[5].str.wStrLen = helloWorld.GetLength();
        rgStats[5].str.pstr = (CHAR*) helloWorld.cstr();
        
        cbBuffer = cbBufferSize;
        
        TEST_ASSERT(LbBlob::UpdateStats(rgStats,ARRAY_SIZE(rgStats),NULL,0,rgBlobBuffer, &cbBuffer));
        VerifyStatBlob(rgStats,ARRAY_SIZE(rgStats),rgBlobBuffer,cbBuffer);
        
        LbStat rgStatChange[7];
        rgStatChange[0].statId = 5;
        rgStatChange[0].bType  = LbspTypeIdInt8;
        rgStatChange[0].i8     = 0x12;
        rgStatChange[1].statId = 10;
        rgStatChange[1].bType  = LbspTypeIdInt16;
        rgStatChange[1].i16     = 0x1234;
        rgStatChange[2].statId = 40;
        rgStatChange[2].bType  = LbspTypeIdInt32 | LbspTypeIdNullFlag;
        rgStatChange[2].i32    = 0;
        rgStatChange[3].statId = 55;
        rgStatChange[3].bType  = LbspTypeIdInt64;
        rgStatChange[3].i64     = 0x1234567890abcdef;
        rgStatChange[4].statId = 60;
        rgStatChange[4].bType  = LbspTypeIdString;
        rgStatChange[4].str.wStrLen = einstein.GetLength();
        rgStatChange[4].str.pstr = (CHAR*)einstein.cstr();
        rgStatChange[5].statId = 65;
        rgStatChange[5].bType  = LbspTypeIdDouble;
        rgStatChange[5].d      = 3.14159265;
        rgStatChange[6].statId = 100;
        rgStatChange[6].bType  = LbspTypeIdDouble | LbspTypeIdNullFlag;
        rgStatChange[6].d      = 0;
        
        cbBuffer2 = cbBufferSize;
        
        TEST_ASSERT(LbBlob::UpdateStats(rgStatChange,
            ARRAY_SIZE(rgStatChange),rgBlobBuffer,cbBuffer,
            rgBlobBuffer2, &cbBuffer2));
            
        LbStat rgStatFinal[8];
        rgStatFinal[0].statId = 5;
        rgStatFinal[0].bType  = LbspTypeIdInt8;
        rgStatFinal[0].i8     = 0x12;
        rgStatFinal[1].statId = 10;
        rgStatFinal[1].bType  = LbspTypeIdInt16;
        rgStatFinal[1].i16     = 0x1234;
        rgStatFinal[2].statId = 20;
        rgStatFinal[2].bType  = LbspTypeIdInt16;
        rgStatFinal[2].i16     = 0x1234;
        rgStatFinal[3].statId = 30;
        rgStatFinal[3].bType  = LbspTypeIdInt32;
        rgStatFinal[3].i32     = 0x12345678;
        rgStatFinal[4].statId = 50;
        rgStatFinal[4].bType  = LbspTypeIdDouble;
        rgStatFinal[4].d      = 3.14159265;
        rgStatFinal[5].statId = 55;
        rgStatFinal[5].bType  = LbspTypeIdInt64;
        rgStatFinal[5].i64     = 0x1234567890abcdef;
        rgStatFinal[6].statId = 60;
        rgStatFinal[6].bType  = LbspTypeIdString;
        rgStatFinal[6].str.wStrLen = einstein.GetLength();
        rgStatFinal[6].str.pstr = (CHAR*)einstein.cstr();
        rgStatFinal[7].statId = 65;
        rgStatFinal[7].bType  = LbspTypeIdDouble;
        rgStatFinal[7].d      = 3.14159265;
    
        VerifyStatBlob(rgStatFinal,ARRAY_SIZE(rgStatFinal),rgBlobBuffer2,cbBuffer2);
        
        // Parse stats and verify
        LbStat  rgParsedStats[ARRAY_SIZE(rgStatFinal) + 2];
        ZeroMemory(rgParsedStats, sizeof(rgParsedStats));
        DWORD   cStats = ARRAY_SIZE(rgParsedStats);
        TEST_ASSERT(LbBlob::ParseStats(rgBlobBuffer2,cbBuffer2,&alloc,rgParsedStats,&cStats));
        TEST_ASSERT(cStats == ARRAY_SIZE(rgStatFinal));
        CUnitUtil::CompareLbStatArrays(rgStatFinal, rgParsedStats, cStats);
    }
    
    {
        // Try to add more than the buffer can handle. An error is expected 
        // and no buffer overrun
        BYTE  rgBlobBuffer[100];
        DWORD dwBufferGuard = 0xdeadf00d;
        
        DWORD cbBuffer = sizeof(rgBlobBuffer);
        
        CConstStr str(REFANDSIZE("0123456789"));
        LbStat rgStats[100];
        
        for(DWORD i=0; i < ARRAY_SIZE(rgStats); i++)
        {
            rgStats[i].statId = (LbStatId)(i + 1);
            rgStats[i].bType  = LbspTypeIdString;
            rgStats[i].str.wStrLen = str.GetLength();
            rgStats[i].str.pstr = (CHAR*)str.cstr();
        }
        
        TEST_ASSERT(!LbBlob::UpdateStats(rgStats,ARRAY_SIZE(rgStats),
            NULL,0,rgBlobBuffer,&cbBuffer));
        
        TEST_ASSERT(0xdeadf00d == dwBufferGuard);
    }
}

class CTestLbUpdateAndRead : public UMSTask
{
public:
    
    CTestLbUpdateAndRead(CLbList* pLbList)
    {
        _pLbList = pLbList;
    }
    
    virtual void Execute(IUmsClient* pUmsClient)
    {
        CArenaMemAlloc alloc;
        CLb* pLb;
        LbStat* pStats = NULL;
        DWORD cStats = 0;
        DWORD dwRank;
        
        // Create leaderboard
        TEST_ASSERT(_pLbList->CreateLb(pUmsClient,1,1,LbResetTypeNever, 0, 0,0,&pLb)
            == CLbList::CreateLbStatusSucceeded);
        
        // Insert user1                         StatId  Value
        LbStat rgStat1[7];
        FillOutLbStatInt8  (rgStat1[0],             10, 0x12);
        FillOutLbStatInt16 (rgStat1[1],             20, 0x1234);
        FillOutLbStatInt32 (rgStat1[2],             30, 0x12345678);
        FillOutLbStatInt64 (rgStat1[3],             40, 0x1234567890abcdef);
        FillOutLbStatDouble(rgStat1[4],             50, 3.14159265);
        FillOutLbStatString(rgStat1[5],             60, "Hello World");
        FillOutLbStatInt64 (rgStat1[6], LbStatIdRating, 100);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,1,rgStat1,ARRAY_SIZE(rgStat1)));
        
        // Insert user2                         StatId  Value
        LbStat rgStat2[7];
        FillOutLbStatInt8  (rgStat2[0],             10, 0x22);
        FillOutLbStatInt16 (rgStat2[1],             20, 0x2234);
        FillOutLbStatInt32 (rgStat2[2],             30, 0x22345678);
        FillOutLbStatInt64 (rgStat2[3],             40, 0x2234567890abcdef);
        FillOutLbStatDouble(rgStat2[4],             50, 3.24159265);
        FillOutLbStatString(rgStat2[5],             60, "Hello World2");
        FillOutLbStatInt64 (rgStat2[6], LbStatIdRating, 200);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,2,rgStat2,ARRAY_SIZE(rgStat2)));
        
        // Insert user3                         StatId  Value
        LbStat rgStat3[7];
        FillOutLbStatInt8  (rgStat3[0],             10, 0x32);
        FillOutLbStatInt16 (rgStat3[1],             20, 0x3234);
        FillOutLbStatInt32 (rgStat3[2],             30, 0x32345678);
        FillOutLbStatInt64 (rgStat3[3],             40, 0x3234567890abcdef);
        FillOutLbStatDouble(rgStat3[4],             50, 3.34159265);
        FillOutLbStatString(rgStat3[5],             60, "Hello World3");
        FillOutLbStatInt64 (rgStat3[6], LbStatIdRating, 150);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,3,rgStat3,ARRAY_SIZE(rgStat3)));
        
        // Read user1
        alloc.Reset();
        LbStat rgStatVerif1[7];
        FillOutLbStatInt8  (rgStatVerif1[0],             10, 0x12);
        FillOutLbStatInt16 (rgStatVerif1[1],             20, 0x1234);
        FillOutLbStatInt32 (rgStatVerif1[2],             30, 0x12345678);
        FillOutLbStatInt64 (rgStatVerif1[3],             40, 0x1234567890abcdef);
        FillOutLbStatDouble(rgStatVerif1[4],             50, 3.14159265);
        FillOutLbStatString(rgStatVerif1[5],             60, "Hello World");
        FillOutLbStatInt64 (rgStatVerif1[6], LbStatIdRating, 100);
        TEST_ASSERT(pLb->StatRead(pUmsClient,1,&alloc,&pStats,&cStats, &dwRank, NULL) 
            == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == ARRAY_SIZE(rgStatVerif1));
        TEST_ASSERT(dwRank == 3);
        CUnitUtil::CompareLbStatArrays(rgStatVerif1, pStats, cStats);
        
        // Read user2
        alloc.Reset();
        LbStat rgStatVerif2[7];
        FillOutLbStatInt8  (rgStatVerif2[0],             10, 0x22);
        FillOutLbStatInt16 (rgStatVerif2[1],             20, 0x2234);
        FillOutLbStatInt32 (rgStatVerif2[2],             30, 0x22345678);
        FillOutLbStatInt64 (rgStatVerif2[3],             40, 0x2234567890abcdef);
        FillOutLbStatDouble(rgStatVerif2[4],             50, 3.24159265);
        FillOutLbStatString(rgStatVerif2[5],             60, "Hello World2");
        FillOutLbStatInt64 (rgStatVerif2[6], LbStatIdRating, 200);
        TEST_ASSERT(pLb->StatRead(pUmsClient,2,&alloc,&pStats,&cStats,&dwRank, NULL) 
            == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == ARRAY_SIZE(rgStatVerif2));
        TEST_ASSERT(dwRank == 1);
        CUnitUtil::CompareLbStatArrays(rgStatVerif2, pStats, cStats);

        // Read user3
        alloc.Reset();
        LbStat rgStatVerif3[7];
        FillOutLbStatInt8  (rgStatVerif3[0],             10, 0x32);
        FillOutLbStatInt16 (rgStatVerif3[1],             20, 0x3234);
        FillOutLbStatInt32 (rgStatVerif3[2],             30, 0x32345678);
        FillOutLbStatInt64 (rgStatVerif3[3],             40, 0x3234567890abcdef);
        FillOutLbStatDouble(rgStatVerif3[4],             50, 3.34159265);
        FillOutLbStatString(rgStatVerif3[5],             60, "Hello World3");
        FillOutLbStatInt64 (rgStatVerif3[6], LbStatIdRating, 150);
        TEST_ASSERT(pLb->StatRead(pUmsClient,3,&alloc,&pStats,&cStats, &dwRank, NULL) 
            == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == ARRAY_SIZE(rgStatVerif3));
        TEST_ASSERT(dwRank == 2);
        CUnitUtil::CompareLbStatArrays(rgStatVerif3, pStats, cStats);
        
        // Delete leaderboard
        pLb->Release();
        TEST_ASSERT(_pLbList->DeleteLb(pUmsClient,1,1,true) 
            == CLbList::DeleteLbStatusSucceeded );
    }
    
    virtual void Free() {}
    
    CLbList* _pLbList;
};

void TestLbUpdateAndRead()
{
    printf("TestLbUpdateAndRead\n");
    
    CTestConfig config;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CTestPersister persister;
    CTestDb db;
    
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    
    CTestLbUpdateAndRead task(&lbList);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    //lbList.Term();
    ums.Term();
    bm.Term();
}

class CTestLbUpdate : public UMSTask
{
public:
    
    CTestLbUpdate(CLbList* pLbList)
    {
        _pLbList = pLbList;
    }
    
    void Populate(IUmsClient* pUmsClient, CLb* pLb)
    {
        static const LPCSTR str = 
            "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        
        // Insert 10000 rows
        for(int i=0; i < 10000; i++)
        {
            LbStat rgStat[2];
            UINT64 puid = i + 1;
            
            rgStat[0].statId      = 10;
            rgStat[0].bType       = LbspTypeIdString;
            rgStat[0].str.pstr    = (CHAR*) str;
            rgStat[0].str.wStrLen = (WORD)(puid % ARRAY_SIZE(str));
            
            rgStat[1].statId      = LbStatIdRating;
            rgStat[1].bType       = LbspTypeIdInt64;
            rgStat[1].i64         = puid * 10;
            
            TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat, ARRAY_SIZE(rgStat)));
        }
    }
    
    enum TestRating
    {
        TestRatingNone = 0,
        TestRatingNull,
        TestRatingLow,
        TestRatingMid,
        TestRatingHigh,
        TestRatingDup,
        TestRatingMax = TestRatingDup
    };
    
    enum TestStat
    {
        TestStatNone = 0,
        TestStatOne,
        TestStatTen,
        TestStatEven,
        TestStatOdd,
        TestStatEvenNull,
        TestStatOddNull,
        TestStatMax = TestStatOddNull
    };
    
    enum
    {
        TestPuid = 11112222 
    };
    
    void SinglePassTest(
        IUmsClient* pUmsClient,
        CLb* pLb,
        TestRating rating,
        TestStat stat
    )
    {
        CArenaMemAlloc alloc;
        
        // Get previous state
        LbStat* pPrevStat = NULL;
        DWORD cPrevStat=0;
        DWORD dwPrevRank;
        CLb::StatReadStatus readStatus = pLb->StatRead(pUmsClient, TestPuid, &alloc, &pPrevStat, &cPrevStat, &dwPrevRank, NULL);
        TEST_ASSERT(readStatus == CLb::StatReadStatusSucceeded || readStatus == CLb::StatReadStatusNotFound);

        LbStat rgStat[20];
        DWORD  cStat=0;
        
        switch(stat)
        {
        case TestStatNone:
            break;
        case TestStatOne:
            FillOutLbStatInt8(rgStat[cStat++], 1, 123);
            break;
        case TestStatTen:
            FillOutLbStatInt8   (rgStat[cStat++], 1,   1);
            FillOutLbStatInt16  (rgStat[cStat++], 2,   2);
            FillOutLbStatInt32  (rgStat[cStat++], 3,   3);
            FillOutLbStatInt64  (rgStat[cStat++], 4,   4);
            FillOutLbStatDouble (rgStat[cStat++], 5,   5);
            FillOutLbStatInt8   (rgStat[cStat++], 6,   6);
            FillOutLbStatInt16  (rgStat[cStat++], 7,   7);
            FillOutLbStatInt32  (rgStat[cStat++], 8,   8);
            FillOutLbStatInt64  (rgStat[cStat++], 9,   9);
            FillOutLbStatDouble (rgStat[cStat++], 10, 10);
            break;
        case TestStatEven:
            FillOutLbStatInt16  (rgStat[cStat++], 2,   2);
            FillOutLbStatInt64  (rgStat[cStat++], 4,   4);
            FillOutLbStatInt8   (rgStat[cStat++], 6,   6);
            FillOutLbStatInt32  (rgStat[cStat++], 8,   8);
            FillOutLbStatDouble (rgStat[cStat++], 10, 10);
            break;
        case TestStatOdd:
            FillOutLbStatInt8   (rgStat[cStat++], 1,   1);
            FillOutLbStatInt32  (rgStat[cStat++], 3,   3);
            FillOutLbStatDouble (rgStat[cStat++], 5,   5);
            FillOutLbStatInt16  (rgStat[cStat++], 7,   7);
            FillOutLbStatInt64  (rgStat[cStat++], 9,   9);
            break;
        case TestStatEvenNull:
            FillOutLbStatNull   (rgStat[cStat++],  2);
            FillOutLbStatNull   (rgStat[cStat++],  4);
            FillOutLbStatNull   (rgStat[cStat++],  6);
            FillOutLbStatNull   (rgStat[cStat++],  8);
            FillOutLbStatNull   (rgStat[cStat++], 10);
            break;
        case TestStatOddNull:
            FillOutLbStatNull   (rgStat[cStat++],  1);
            FillOutLbStatNull   (rgStat[cStat++],  3);
            FillOutLbStatNull   (rgStat[cStat++],  5);
            FillOutLbStatNull   (rgStat[cStat++],  7);
            FillOutLbStatNull   (rgStat[cStat++],  9);
            break;
        default:
            TEST_ASSERT(false);
        };
        
        switch(rating)
        {
        case TestRatingNone:
            break;
        case TestRatingNull:
            FillOutLbStatNull(rgStat[cStat++], LbStatIdRating);
            break;
        case TestRatingLow:
            FillOutLbStatInt64(rgStat[cStat++], LbStatIdRating, 1);
            break;
        case TestRatingMid:
            FillOutLbStatInt64(rgStat[cStat++], LbStatIdRating, 5001);
            break;
        case TestRatingHigh:
            FillOutLbStatInt64(rgStat[cStat++], LbStatIdRating, 10001);
            break;
        case TestRatingDup:
            FillOutLbStatInt64(rgStat[cStat++], LbStatIdRating, 5000);
            break;
        };
        
        TEST_ASSERT(pLb->StatWrite(pUmsClient, TestPuid, rgStat, cStat));

        LbStat* pCurStat = NULL;
        DWORD cCurStat=0;
        DWORD dwCurRank;
        TEST_ASSERT(pLb->StatRead(pUmsClient,TestPuid,&alloc,&pCurStat,&cCurStat, &dwCurRank, NULL) == CLb::StatReadStatusSucceeded);
        
        Verify(pPrevStat, cPrevStat, rgStat, cStat, pCurStat, cCurStat);        
    }
    
    void Verify(
        LbStat rgPrevStat[],
        DWORD  cPrevStat,
        LbStat rgDeltaStat[],
        DWORD  cDeltaStat,
        LbStat rgCurStat[],
        DWORD  cCurStat
    )
    {
        THashtable<LbStatId,LbStat*> table;
        
        table.Grow(20);
        
        for(int i=0; i < (int)cPrevStat; i++)
        {
            TEST_ASSERT(table.Set(rgPrevStat[i].statId, &rgPrevStat[i]));
        }

        for(int i=0; i < (int)cDeltaStat; i++)
        {
            TEST_ASSERT(table.Set(rgDeltaStat[i].statId, &rgDeltaStat[i]));
        }
        
        for(int i=0; i < (int)cCurStat; i++)
        {
            if(rgCurStat[i].statId == LbStatIdRank)
                continue;
                
            LbStat* pStat;
            TEST_ASSERT(table.Remove(rgCurStat[i].statId, &pStat));
            
            CUnitUtil::CompareLbStat(&rgCurStat[i], pStat);
        }
        
        THashtable<LbStatId,LbStat*>::Iterator it;
        
        table.InitializeIterator(&it);
        
        LbStatId statId;
        LbStat* pStat;
        while(it.GetNext(&statId, &pStat))
        {
            if(pStat->statId == LbStatIdRank)
                continue;
                
            TEST_ASSERT(pStat->IsNull());
        }
    }
    
    
    virtual void Execute(IUmsClient* pUmsClient)
    {
        CArenaMemAlloc alloc;
        CLb* pLb;
        LbStat* pStats = NULL;
        DWORD cStats = 0;
        
        // Create leaderboard
        TEST_ASSERT(_pLbList->CreateLb(pUmsClient,1,1,LbResetTypeNever, 0, 0,0,&pLb)
            == CLbList::CreateLbStatusSucceeded);
        
        Populate(pUmsClient,pLb);
        
        for(DWORD rating1=0; rating1 < TestRatingMax; rating1++)
        {
            for(DWORD rating2=0; rating2 < TestRatingMax; rating2++)
            {
                for(DWORD stat1=0; stat1 < TestStatMax; stat1++)
                {
                    for(DWORD stat2=0; stat2 < TestStatMax; stat2++)
                    {
                        SinglePassTest(pUmsClient,pLb,(TestRating)rating1,(TestStat)stat1);
                        SinglePassTest(pUmsClient,pLb,(TestRating)rating2,(TestStat)stat2);
                        TEST_ASSERT(pLb->ResetPuid(pUmsClient, TestPuid));
                    }
                }
            }
        }
        
        // Delete leaderboard
        pLb->Release();
        TEST_ASSERT(_pLbList->DeleteLb(pUmsClient,1,1,true) 
            == CLbList::DeleteLbStatusSucceeded );
    }
    
    virtual void Free() {}
    
    CLbList* _pLbList;
};

void TestLbUpdate()
{
    printf("TestLbUpdate\n");
    
    CTestConfig config;
    config._dwBufferManagerPageSize = 400;
    
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CTestPersister persister;
    CTestDb db;
    
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    
    CTestLbUpdate task(&lbList);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    //lbList.Term();
    ums.Term();
    bm.Term();
}

class CTestLbEnum : public UMSTask, public ILbEnumCallback
{
public:
    
    CTestLbEnum(CLbList* pLbList)
    {
        _pLbList = pLbList;
    }
    
    void Populate(IUmsClient* pUmsClient, CLb* pLb)
    {
        static const LPCSTR str = 
            "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        
        // Insert 10000 rows
        for(int i=0; i < 10000; i++)
        {
            LbStat rgStat[3];
            UINT64 puid = i + 1;
            
            rgStat[0].statId      = 10;
            rgStat[0].bType       = LbspTypeIdString;
            rgStat[0].str.pstr    = (CHAR*) str;
            rgStat[0].str.wStrLen = (WORD)(puid % ARRAY_SIZE(str));
            
            rgStat[1].statId      = 20;
            rgStat[1].bType       = LbspTypeIdInt32;
            rgStat[1].i32         = i;
            
            rgStat[2].statId      = LbStatIdRating;
            rgStat[2].bType       = LbspTypeIdInt64;
            rgStat[2].i64         = puid * 10;
            
            TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat,ARRAY_SIZE(rgStat)));
        }
    }
    
    virtual void Execute(IUmsClient* pUmsClient)
    {
        CArenaMemAlloc alloc;
        CLb* pLb;
        LbStat* pStats = NULL;
        DWORD cStats = 0;
        
        // Create leaderboard
        TEST_ASSERT(_pLbList->CreateLb(pUmsClient,1,1,LbResetTypeNever, 0, 0,0,&pLb)
            == CLbList::CreateLbStatusSucceeded);
        
        Populate(pUmsClient,pLb);
        
        for(int i=0; i < 10000; i++)
        {
            _dwRank = i + 1;
            _dwEnumerated = 0;
            TEST_ASSERT(pLb->EnumByRank(pUmsClient, i+1, 1000, this));
            TEST_ASSERT(_dwEnumerated + i == __min(i + 1000, 10000));
        }
        
        // Delete leaderboard
        pLb->Release();
        TEST_ASSERT(_pLbList->DeleteLb(pUmsClient,1,1,true) 
            == CLbList::DeleteLbStatusSucceeded );
    }
    
    virtual bool OnNewRow(
        DWORD  dwRank,
        UINT64 puid,
        LbStat* rgStats,
        DWORD cStats
    )
    {
        TEST_ASSERT(dwRank == _dwRank);
        TEST_ASSERT(cStats == 3);
        TEST_ASSERT(puid == 10000 - dwRank + 1);
        TEST_ASSERT(rgStats[0].statId == 10 && rgStats[0].bType == LbspTypeIdString);
        TEST_ASSERT(rgStats[1].statId == 20 && rgStats[1].bType == LbspTypeIdInt32 && rgStats[1].i32 == puid-1);
        TEST_ASSERT(rgStats[2].statId == LbStatIdRating && rgStats[2].bType == LbspTypeIdInt64 && rgStats[2].i64 == puid * 10);
        _dwEnumerated++;
        _dwRank++;
        return true;
    }
    
    
    virtual void Free() {}
    
    DWORD _dwRank;
    DWORD _dwEnumerated;
    CLbList* _pLbList;
};



void TestLbEnum()
{
    printf("TestLbEnum\n");
    CTestConfig config;
    config._dwBufferManagerPageSize = 400;
    
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CTestPersister persister;
    CTestDb db;
    
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    
    CTestLbEnum task(&lbList);
    
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    //lbList.Term();
    ums.Term();
    bm.Term();
}

void TestLbRankedEntryCount()
{
    printf("TestLbRankedEntryCount\n");
    CTestConfig config;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CLb* pLb;
    IUmsClient* pUmsClient;
    CTestPersister persister;
    CTestDb db;
    
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
    TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 1, LbResetTypeNever, 0, 0, 0, &pLb) == CLbList::CreateLbStatusSucceeded);
 
    // No entries
    TEST_ASSERT(pLb->GetRankedEntryCount() == 0);
    
    // One unranked entry
    {
        LbStat rgStat[1];
        FillOutLbStatInt32 (rgStat[0], 20, 0x1234);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,1,rgStat,ARRAY_SIZE(rgStat)));
        TEST_ASSERT(pLb->GetRankedEntryCount() == 0);
    }
    
    // New ranked entry
    {
        LbStat rgStat[2];
        FillOutLbStatInt32 (rgStat[0], 20, 0x1234);
        FillOutLbStatInt64 (rgStat[1], LbStatIdRating, 100);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,2,rgStat,ARRAY_SIZE(rgStat)));
        TEST_ASSERT(pLb->GetRankedEntryCount() == 1);
    }
    
    // Change unranked entry to ranked
    {
        LbStat rgStat[1];
        FillOutLbStatInt64 (rgStat[0], LbStatIdRating, 100);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,1,rgStat,ARRAY_SIZE(rgStat)));
        TEST_ASSERT(pLb->GetRankedEntryCount() == 2);
    }
    
    // Change ranked entry to unranked
    {
        LbStat rgStat[1];
        FillOutLbStatNull(rgStat[0], LbStatIdRating);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,2,rgStat,ARRAY_SIZE(rgStat)));
        TEST_ASSERT(pLb->GetRankedEntryCount() == 1);
    }
    
    // Reset entry (remove)
    {
        TEST_ASSERT(pLb->ResetPuid(pUmsClient, 1));
        TEST_ASSERT(pLb->GetRankedEntryCount() == 0);
    }
 
    pLb->Release();
    ums.ReleaseUmsClient(pUmsClient);
    lbList.Term();
    ums.Shutdown();
    ums.Term();
    bm.Term();
}

void TestLbGetRankForPuid()
{
    printf("TestLbGetRankForPuid\n");
 
    CTestConfig config;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CLb* pLb;
    IUmsClient* pUmsClient;
    CTestPersister persister;
    CTestDb db;
    
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
    TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 1, LbResetTypeNever, 0, 0, 0, &pLb) == CLbList::CreateLbStatusSucceeded);
   
     // One unranked entry
    {
        LbStat rgStat[1];
        FillOutLbStatInt32 (rgStat[0], 20, 0x1234);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,1,rgStat,ARRAY_SIZE(rgStat)));
    }
    
    // One ranked entry
    {
        LbStat rgStat[2];
        FillOutLbStatInt32 (rgStat[0], 20, 0x1234);
        FillOutLbStatInt64 (rgStat[1], LbStatIdRating, 100);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,2,rgStat,ARRAY_SIZE(rgStat)));
    }

    // Another ranked entry
    {
        LbStat rgStat[2];
        FillOutLbStatInt32 (rgStat[0], 20, 0x1234);
        FillOutLbStatInt64 (rgStat[1], LbStatIdRating, 200);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,3,rgStat,ARRAY_SIZE(rgStat)));
    }
    
    DWORD dwRank = 0;
    TEST_ASSERT(pLb->GetRankForPuid(pUmsClient, 1, &dwRank) == CLb::GetRankForPuidStatusPuidNotFound);
    TEST_ASSERT(pLb->GetRankForPuid(pUmsClient, 2, &dwRank) == CLb::GetRankForPuidStatusSucceeded && dwRank == 2);
    TEST_ASSERT(pLb->GetRankForPuid(pUmsClient, 3, &dwRank) == CLb::GetRankForPuidStatusSucceeded && dwRank == 1);
    TEST_ASSERT(pLb->GetRankForPuid(pUmsClient, 4, &dwRank) == CLb::GetRankForPuidStatusPuidNotFound);

    pLb->Release();
    ums.ReleaseUmsClient(pUmsClient);
    lbList.Term();
    ums.Shutdown();
    ums.Term();
    bm.Term();
}

void TestLbReset()
{
    printf("TestLbReset\n");

    CTestConfig config;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CLb* pLb;
    IUmsClient* pUmsClient;
    CArenaMemAlloc alloc;
    CTestPersister persister;
    CTestDb db;
 
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
    TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 1, LbResetTypeNever, 0, 0, 0,  NULL) == CLbList::CreateLbStatusSucceeded);
 
    static const LPCSTR str = 
        "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        
    static const int rowcount = 10000;
    
    for(int j=0; j < 2; j++)
    {
        TEST_ASSERT(lbList.GetLb(0xfeedfeed, 1, &pLb) == CLbList::GetLbStatusSucceeded);
        
        // Leaderboard should be empty
        TEST_ASSERT(pLb->GetRankedEntryCount() == 0);

        for(int i=0; i < rowcount; i++)
        {
            UINT64 puid    = i + 1;
            LbStat* pStats = NULL;
            DWORD cStats   = 0;
            DWORD dwRank   = 0;
            
            alloc.Reset();
            
            TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusNotFound);
        }
        
        // Insert 10000 rows
        for(int i=0; i < rowcount; i++)
        {
            LbStat rgStat[2];
            UINT64 puid = i + 1;
            
            rgStat[0].statId      = 10;
            rgStat[0].bType       = LbspTypeIdString;
            rgStat[0].str.pstr    = (CHAR*) str;
            rgStat[0].str.wStrLen = (WORD)(puid % ARRAY_SIZE(str));
            
            rgStat[1].statId      = LbStatIdRating;
            rgStat[1].bType       = LbspTypeIdInt64;
            rgStat[1].i64         = puid * 10;
            
            TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat, ARRAY_SIZE(rgStat)));
        }
        
        // Verify
        TEST_ASSERT(pLb->GetRankedEntryCount() == rowcount);
        
        for(int i=0; i < rowcount; i++)
        {
            UINT64 puid    = i + 1;
            LbStat* pStats = NULL;
            DWORD cStats   = 0;
            DWORD dwRank   = 0;
            
            alloc.Reset();
            
            TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
            TEST_ASSERT(cStats == 2);
        }
        
        pLb->Release();
        
        // Reset leaderboard
        TEST_ASSERT(lbList.ResetLb(pUmsClient, 0xfeedfeed, 1) == CLbList::ResetLbStatusSucceeded);
        
        // Verify
        TEST_ASSERT(pLb->GetRankedEntryCount() == 0);
        
        for(int i=0; i < rowcount; i++)
        {
            UINT64 puid    = i + 1;
            LbStat* pStats = NULL;
            DWORD cStats   = 0;
            DWORD dwRank   = 0;
            
            alloc.Reset();
            
            TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusNotFound);
        }
    }
 
    ums.ReleaseUmsClient(pUmsClient);
    lbList.Term();
    ums.Shutdown();
    ums.Term();
    bm.Term();
}

class CTestLbLoadConfig : public CTestConfig
{
public:
    
    CTestLbLoadConfig(DWORD cLb)
    {   
        _cLb = cLb;    
    }
    
    virtual bool LoadLbInfo(
        CArenaMemAlloc *pAlloc, 
        TList<ConfigLbInfo>*pList
    )
    {
        for(UINT32 lbid=1; lbid <= _cLb; lbid++)
        {
            ConfigLbInfo* plbInfo = new (*pAlloc) ConfigLbInfo;
                
            ZeroMemory(plbInfo, sizeof(ConfigLbInfo));
            plbInfo->dwTitleId = 0xfeedfeed;
            plbInfo->dwLbId    = lbid;
            
            pList->Enqueue(plbInfo);
        }
        
        return true;
    }
    
    DWORD _cLb;
};

class CTestLbLoadDb : public CTestDb
{
public:
    
    CTestLbLoadDb(
        DWORD cLb,
        DWORD cRows,
        IUmsClient* pUmsClient
    )
    {
        _cLb   = cLb;
        _cRows = cRows;
        _pCtrl = pUmsClient;
    }
    
    virtual bool Load(
        DbTitleAndLb rgLb[], 
        DWORD cLb, 
        IDbCallback *pCallback)
    {
        LbStat rgStats[3];
        
        UINT64 lastUpdateTime = ::GetUTCTimeAsUint64();
        
        for(DWORD i=0; i < cLb; i++)
        {
            if(rgLb[i].uiTitleId != 0xfeedfeed ||
               rgLb[i].uiLbId > cLb)
            {
                // skip
                continue;
            }
            
            for(DWORD j=0; j <= _cRows; j++)
            {
                FillOutLbStatInt32(rgStats[0], 10, j);
                FillOutLbStatInt32(rgStats[1], 20, j+1);
                FillOutLbStatInt32(rgStats[2], 30, j+2);
                
                if(!pCallback->OnRow(_pCtrl, rgLb[i].uiTitleId, rgLb[i].uiLbId,
                    (UINT64) j+1, rgStats, ARRAY_SIZE(rgStats), lastUpdateTime))
                {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    DWORD _cLb;
    DWORD _cRows;
    IUmsClient* _pCtrl;
};

void TestLbLoad()
{
    printf("TestLbLoad\n");

    const DWORD lbcount  = 10;
    const DWORD rowcount = 100;
    
    CTestLbLoadConfig config(lbcount);
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CLb* pLb;
    IUmsClient* pUmsClient;
    CArenaMemAlloc alloc;
    CTestPersister persister;
 
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
    CTestLbLoadDb db(lbcount, rowcount, pUmsClient);
    
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    
    // Load
    TEST_ASSERT(lbList.Load(false));
    
    // Verify
    for(DWORD lbid=1; lbid <= lbcount; lbid++)
    {
        TEST_ASSERT(lbList.GetLb(0xfeedfeed, lbid, &pLb) 
            == CLbList::GetLbStatusSucceeded);
            
        for(int i=0; i < rowcount; i++)
        {
            UINT64 puid    = i + 1;
            LbStat* pStats = NULL;
            DWORD cStats   = 0;
            DWORD dwRank   = 0;
            
            alloc.Reset();
            TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
        }
        
        pLb->Release();
    }
 
    ums.ReleaseUmsClient(pUmsClient);
    lbList.Term();
    ums.Shutdown();
    ums.Term();
    bm.Term();
}

void TestLbDecay()
{
    printf("TestLbDecay\n");

    CTestConfig config;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CLb* pLb;
    IUmsClient* pUmsClient;
    CArenaMemAlloc alloc;
    CTestPersister persister;
    CTestDb db;
 
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
    TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 1, LbResetTypeNever, 7, 0, 0,  NULL) == CLbList::CreateLbStatusSucceeded);
 
    static const LPCSTR str = 
        "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        
    static const int rowcount = 10000;
    
    TEST_ASSERT(lbList.GetLb(0xfeedfeed, 1, &pLb) == CLbList::GetLbStatusSucceeded);
    
    // Insert 10000 rows
    for(int i=0; i < rowcount; i++)
    {
        LbStat rgStat[2];
        UINT64 puid = i + 1;
        
        rgStat[0].statId      = 10;
        rgStat[0].bType       = LbspTypeIdString;
        rgStat[0].str.pstr    = (CHAR*) str;
        rgStat[0].str.wStrLen = (WORD)(puid % ARRAY_SIZE(str));
        
        rgStat[1].statId      = LbStatIdRating;
        rgStat[1].bType       = LbspTypeIdInt64;
        rgStat[1].i64         = puid * 10;
        
        TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat, ARRAY_SIZE(rgStat)));
    }
    
    // Verify
    TEST_ASSERT(pLb->GetRankedEntryCount() == rowcount);
    
    for(int i=0; i < rowcount; i++)
    {
        UINT64 puid    = i + 1;
        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        
        alloc.Reset();
        
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == 2);
    }
    
    // rollback last-modified timestamps by 8 days making all rows target for 
    // decay
    TEST_ASSERT(pLb->ChangeLastUpdateTimeOfAll(pUmsClient, 8));
    
    // Update one fifth of the rows. This will update their timestamp
    for(int i=0; i < rowcount; i++)
    {
        if(i % 5 == 0)
        {
            UINT64 puid    = i + 1;
            LbStat rgStat[1];
        
            rgStat[0].statId      = 20;
            rgStat[0].bType       = LbspTypeIdInt32;
            rgStat[0].i32         = (INT32) i;
            
            TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat, ARRAY_SIZE(rgStat)));
        }
    }
    
    // Do the decay thing. 4/5 of the rows will be deleted
    TEST_ASSERT(pLb->DecayLb(pUmsClient, ::GetUTCTimeAsUint64()));
    
    // Verify
    for(int i=0; i < rowcount; i++)
    {
        UINT64 puid    = i + 1;
        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        
        alloc.Reset();
        
        if(i % 5 == 0)
        {
            TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
            TEST_ASSERT(cStats == 3);
        }
        else
        {
            TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusNotFound);
        }
    }
        
    pLb->Release();
 
    ums.ReleaseUmsClient(pUmsClient);
    lbList.Term();
    ums.Shutdown();
    ums.Term();
    bm.Term();
}

void TestLbMaxEntryCount()
{
    printf("TestLbMaxEntryCount\n");

    CTestConfig config;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CLb* pLb;
    IUmsClient* pUmsClient;
    CArenaMemAlloc alloc;
    CTestPersister persister;
    CTestDb db;
 
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
    TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 1, LbResetTypeNever, 0, 100, 0,  &pLb) == CLbList::CreateLbStatusSucceeded);
    
    // Insert 150 rows with descending rating
    for(int i=0; i < 150; i++)
    {
        INT64  rating = 1000 - i;
        UINT64 puid   = rating;
        
        LbStat rgStat[1];
        FillOutLbStatInt64(rgStat[0], LbStatIdRating, rating);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat,ARRAY_SIZE(rgStat)));
    }
    
    // Because the cap is set to 100, only the first 100 entries should have 
    // been written
    pLb->SetMaxEntryCount(0);
    TEST_ASSERT(pLb->GetRankedEntryCount() == 100);
    for(int i=0; i < 100; i++)
    {
        INT64  rating = 1000 - i;
        UINT64 puid   = rating;
        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == 1);
    }
    
    for(int i=0; i < 50; i++)
    {
        INT64  rating = 900 - i;
        UINT64 puid   = rating;
        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusNotFound);
    }
    pLb->SetMaxEntryCount(100);
    
    // Insert another 50 rows on the top of the leaderboard
    for(int i=0; i < 50; i++)
    {
        INT64  rating = 1050 - i;
        UINT64 puid   = rating;
        
        LbStat rgStat[1];
        FillOutLbStatInt64(rgStat[0], LbStatIdRating, rating);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat,ARRAY_SIZE(rgStat)));
    }
    
    // There should still be only 100 rows in there, with the new rows on the top
    TEST_ASSERT(pLb->GetRankedEntryCount() == 100);
    for(int i=0; i < 100; i++)
    {
        INT64  rating = 1050 - i;
        UINT64 puid   = rating;
        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == 1);
    }
    
    // The other rows should not be visible to the world
    for(int i=0; i < 50; i++)
    {
        INT64  rating = 950 - i;
        UINT64 puid   = rating;
        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusNotFound);
    }
    
    // But they are still there, in the reserve
    pLb->SetMaxEntryCount(0);
    TEST_ASSERT(pLb->GetRankedEntryCount() == 150);
    for(int i=0; i < 50; i++)
    {
        INT64  rating = 950 - i;
        UINT64 puid   = rating;
        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == 1);
    }
    
    pLb->SetMaxEntryCount(100);
    
    // Updating an existing row without a rating will not update anything
    {
        UINT64 puid   = 1000;
        LbStat rgStat[1];
        FillOutLbStatInt32(rgStat[0], 10, 10);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat,ARRAY_SIZE(rgStat)));

        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == 1);
        TEST_ASSERT(pStats[0].statId == LbStatIdRating);
    }
    
    // Inserting a new row without a rating will not insert anything
    {
        UINT64 puid   = 2000;
        LbStat rgStat[1];
        FillOutLbStatInt32(rgStat[0], 10, 10);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat,ARRAY_SIZE(rgStat)));

        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusNotFound);
    }
    
    // You can update an existing row by specifying the same rating
    {
        INT64  rating = 1000;
        UINT64 puid   = 1000;
        LbStat rgStat[2];
        FillOutLbStatInt32(rgStat[0], 10, 10);
        FillOutLbStatInt64(rgStat[1], LbStatIdRating, rating);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat,ARRAY_SIZE(rgStat)));

        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == 2);
        TEST_ASSERT(pStats[0].statId == 10 && pStats[0].i32 == 10);
        TEST_ASSERT(pStats[1].statId == LbStatIdRating && pStats[1].i64 == 1000);
    }
    
    // You can also update an existing row by specifying a lower rating that still qualifies
    {
        INT64  rating = 999;
        UINT64 puid   = 1000;
        LbStat rgStat[2];
        FillOutLbStatInt32(rgStat[0], 10, 20);
        FillOutLbStatInt64(rgStat[1], LbStatIdRating, rating);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat,ARRAY_SIZE(rgStat)));

        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == 2);
        TEST_ASSERT(pStats[0].statId == 10 && pStats[0].i32 == 20);
        TEST_ASSERT(pStats[1].statId == LbStatIdRating && pStats[1].i64 == 999);
    }

    // You can definitelly update an existing row by specifying a bigger rating that qualifies
    {
        INT64  rating = 1001;
        UINT64 puid   = 1000;
        LbStat rgStat[2];
        FillOutLbStatInt32(rgStat[0], 10, 30);
        FillOutLbStatInt64(rgStat[1], LbStatIdRating, rating);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat,ARRAY_SIZE(rgStat)));

        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == 2);
        TEST_ASSERT(pStats[0].statId == 10 && pStats[0].i32 == 30);
        TEST_ASSERT(pStats[1].statId == LbStatIdRating && pStats[1].i64 == 1001);
    }
    
    // But a non-qualifying rating will not cause anything to be updated
    {
        INT64  rating = 900;
        UINT64 puid   = 1000;
        LbStat rgStat[2];
        FillOutLbStatInt32(rgStat[0], 10, 40);
        FillOutLbStatInt64(rgStat[1], LbStatIdRating, rating);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat,ARRAY_SIZE(rgStat)));

        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == 2);
        TEST_ASSERT(pStats[0].statId == 10 && pStats[0].i32 == 30);
        TEST_ASSERT(pStats[1].statId == LbStatIdRating && pStats[1].i64 == 1001);
    }

    pLb->Release();
 
    ums.ReleaseUmsClient(pUmsClient);
    lbList.Term();
    ums.Shutdown();
    ums.Term();
    bm.Term();
}

void TestLbTrim()
{
    printf("TestLbTrim\n");

    CTestConfig config;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CLb* pLb;
    IUmsClient* pUmsClient;
    CArenaMemAlloc alloc;
    CTestPersister persister;
    CTestDb db;
 
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
    TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
    TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 1, LbResetTypeNever, 0, 100, 0,  &pLb) == CLbList::CreateLbStatusSucceeded);
    
    // Insert 1000 rows with descending rating
    for(int i=0; i < 1000; i++)
    {
        INT64  rating = 1000 + i;
        UINT64 puid   = rating;
        
        LbStat rgStat[1];
        FillOutLbStatInt64(rgStat[0], LbStatIdRating, rating);
        TEST_ASSERT(pLb->StatWrite(pUmsClient,puid,rgStat,ARRAY_SIZE(rgStat)));
    }
    
    TEST_ASSERT(pLb->GetRankedEntryCount() == 100);
    pLb->SetMaxEntryCount(0);
    TEST_ASSERT(pLb->GetRankedEntryCount() == 1000);
    pLb->SetMaxEntryCount(100);
    
    // Trim
    TEST_ASSERT(pLb->TrimLb(pUmsClient));
    
    // Verify size
    TEST_ASSERT(pLb->GetRankedEntryCount() == 100);
    pLb->SetMaxEntryCount(0);
    TEST_ASSERT(pLb->GetRankedEntryCount() == 100 + LbReserveSize);
    pLb->SetMaxEntryCount(100);
    
    // Verify rows
    for(int i=0; i < 100; i++)        
    {
        INT64  rating = 1900 + i;
        UINT64 puid   = rating;
        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
        TEST_ASSERT(cStats == 1);
    }
    
    for(int i=0; i < 900; i++)
    {
        INT64  rating = 1000 + i;
        UINT64 puid   = rating;
        LbStat* pStats = NULL;
        DWORD cStats   = 0;
        DWORD dwRank   = 0;
        alloc.Reset();
        TEST_ASSERT(pLb->StatRead(pUmsClient, puid, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusNotFound);
    }
    
    pLb->Release();
 
    ums.ReleaseUmsClient(pUmsClient);
    lbList.Term();
    ums.Shutdown();
    ums.Term();
    bm.Term();
}

class CTestLbAutoReset
{
public:

    void Init()
    {
        TEST_ASSERT(ums.Init(NULL));
        TEST_ASSERT(bm.Init(&config, &ums, NULL));
        TEST_ASSERT(lbList.Init(&config,&bm, &ums, &persister, &db, NULL));
        TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
        
        TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 1, LbResetTypeNever, 0, 0, 0,        &rgpLb[0]) == CLbList::CreateLbStatusSucceeded);
        TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 2, LbResetTypeWeekly, 0, 0, 0,       &rgpLb[1]) == CLbList::CreateLbStatusSucceeded);
        TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 3, LbResetTypeMonthly, 0, 0, 0,      &rgpLb[2]) == CLbList::CreateLbStatusSucceeded);
        TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 4, LbResetTypeBimonthly, 0, 0, 0,    &rgpLb[3]) == CLbList::CreateLbStatusSucceeded);
        TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 5, LbResetTypeQuarterly, 0, 0, 0,    &rgpLb[4]) == CLbList::CreateLbStatusSucceeded);
        TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 6, LbResetTypeSemiannually, 0, 0, 0, &rgpLb[5]) == CLbList::CreateLbStatusSucceeded);
        TEST_ASSERT(lbList.CreateLb(pUmsClient, 0xfeedfeed, 7, LbResetTypeAnnually, 0, 0, 0,     &rgpLb[6]) == CLbList::CreateLbStatusSucceeded);
    }
    
    void Run()
    {
        {
            // Random day
            SYSTEMTIME st = {2004, 1, 0, 6};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 1, 2, 3, 4, 5, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }
        
        {
            // Sunday
            SYSTEMTIME st = {2004, 1, 0, 4};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 2, 3, 4, 5, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }
        
        {
            // First of January
            SYSTEMTIME st = {2004, 1, 0, 1};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 1};
            Check(lbs, ARRAY_SIZE(lbs));
        }
    
        {
            // First of February (Sunday)
            SYSTEMTIME st = {2004, 2, 0, 1};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 3, 4, 5, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }

        {
            // First of March
            SYSTEMTIME st = {2004, 3, 0, 1};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 1, 4, 5, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }

        {
            // First of April
            SYSTEMTIME st = {2004, 4, 0, 1};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 1, 3, 5, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }

        {
            // First of May
            SYSTEMTIME st = {2004, 5, 0, 1};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 1, 4, 5, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }

        {
            // First of June
            SYSTEMTIME st = {2004, 6, 0, 1};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 1, 3, 4, 5, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }

        {
            // First of July
            SYSTEMTIME st = {2004, 7, 0, 1};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 1, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }

        {
            // First of August
            SYSTEMTIME st = {2004, 8, 0, 1};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 3, 4, 5, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }

        {
            // First of September
            SYSTEMTIME st = {2004, 9, 0, 1};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 1, 4, 5, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }

        {
            // First of October
            SYSTEMTIME st = {2004, 10, 0, 1};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 1, 3, 5, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }

        {
            // First of November
            SYSTEMTIME st = {2004, 11, 0, 1};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 1, 4, 5, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }
        
        {
            // First of December
            SYSTEMTIME st = {2004, 12, 0, 1};
            UINT64 ft;
            ::SystemTimeToFileTime(&st, (FILETIME*)&ft);
            Prepare();
            TEST_ASSERT(lbList.AutoReset(pUmsClient, ft));
            UINT32 lbs[] = {0, 1, 3, 4, 5, 6};
            Check(lbs, ARRAY_SIZE(lbs));
        }


    
    }
    
    void Term()
    {
        for(int i=0; i < ARRAY_SIZE(rgpLb); i++)
            rgpLb[i]->Release();
        
        ums.ReleaseUmsClient(pUmsClient);
        lbList.Term();
        ums.Shutdown();
        ums.Term();
        bm.Term();
    }
    
    void Prepare()
    {
        for(int i=0; i < ARRAY_SIZE(rgpLb); i++)
        {
            // Reset 
            TEST_ASSERT(rgpLb[i]->ResetLb(pUmsClient));
            
            // Write one row
            LbStat rgStat[1];
            rgStat[0].statId      = 20;
            rgStat[0].bType       = LbspTypeIdInt32;
            rgStat[0].i32         = (INT32) i;
            
            TEST_ASSERT(rgpLb[i]->StatWrite(pUmsClient,1,rgStat, ARRAY_SIZE(rgStat)));
        }
    }
    
    void Check(UINT32 rgLbNdx[], DWORD cLbNdx)
    {
        bool table[ARRAY_SIZE(rgpLb)];
        ZeroMemory(&table, sizeof(table));
        
        for(DWORD i=0; i < cLbNdx; i++)
        {
            DBGASSERT(rgLbNdx[i] < ARRAY_SIZE(table));
            table[rgLbNdx[i]] = true;
        }
        
        for(DWORD i=0; i < ARRAY_SIZE(rgpLb); i++)
        {
            LbStat* pStats = NULL;
            DWORD cStats   = 0;
            DWORD dwRank   = 0;
            
            if(table[i])
            {
                TEST_ASSERT(rgpLb[i]->StatRead(pUmsClient, 1, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusSucceeded);
            }
            else
            {
                TEST_ASSERT(rgpLb[i]->StatRead(pUmsClient, 1, &alloc, &pStats, &cStats, &dwRank, NULL) == CLb::StatReadStatusNotFound);
            }
        }
    }

    CTestConfig config;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CLb* pLb;
    IUmsClient* pUmsClient;
    CArenaMemAlloc alloc;
    CTestPersister persister;
    CTestDb db;
    CLb* rgpLb[7];
};

void TestLbAutoReset()
{
    printf("TestLbAutoReset\n");
    CTestLbAutoReset test;
    test.Init();
    test.Run();
    test.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\tbuffer.cpp ===
#include "lbs.h"
#include "tests.h"
#include "unitutil.h"

class CTestBufferManagerSimpleTask : public UMSTask
{
public:
    
    CTestBufferManagerSimpleTask(CBufferManager* pBM) :
        _pBM(pBM),
        _fDone(false)
    {}
    
    virtual void Execute(IUmsClient *pUmsClient)
    {
        BM_PAGE* pPage;
        BM_PAGEID pageId;
        UMSLockCookie lockCookie;
        
        TEST_ASSERT(_pBM->CreateNewPage(pUmsClient, &lockCookie, &pPage));
        pageId = pPage->pageId;
        TEST_ASSERT(pUmsClient->ReleaseLock(&lockCookie));
        
        TEST_ASSERT(_pBM->GetPage(pUmsClient,pageId,LOCK_MODE_SIX,&pPage,&lockCookie));
        TEST_ASSERT(pPage->pageId == pageId);
        
        UMSLockCookie lockCookie2;
        TEST_ASSERT(_pBM->AcquirePageLock(pUmsClient,pageId,LOCK_MODE_X,&lockCookie2));
        
        TEST_ASSERT(pUmsClient->ReleaseLock(&lockCookie2));
        
        TEST_ASSERT(_pBM->DeletePage(pUmsClient,pageId));
        
        TEST_ASSERT(pUmsClient->ReleaseLock(&lockCookie));
        
        _fDone = true;
    }
    
    virtual void Free()
    {
        // NO-OP
    }
    
    CBufferManager* _pBM;
    bool            _fDone;
};

void TestBufferManagerSimple()
{
    printf("TestBufferManagerSimple\n");
    
    CTestConfig config;
    config._ullMaximumPhysicalMemory = 10485760; // 10MB
    
    UMS ums;
    CBufferManager bm;
    
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    CTestBufferManagerSimpleTask task(&bm);
    TEST_ASSERT(ums.AddNewTask(&task));
    
    ums.Shutdown();
    
    TEST_ASSERT(task._fDone);
    
    ums.Term();
    bm.Term();
}

static void FillBuffer(
    BYTE* pBuffer,
    DWORD cbBuffer,
    DWORD dw
)
{
    DWORD c = cbBuffer / sizeof(DWORD);
    
    for(DWORD i=0; i < c; i++)
    {
        ((DWORD*)pBuffer)[i] = dw;
    }
}

static void CheckBuffer(
    BYTE* pBuffer,
    DWORD cbBuffer,
    DWORD dw
)
{
    DWORD c = cbBuffer / sizeof(DWORD);
    
    for(DWORD i=0; i < c; i++)
    {
        TEST_ASSERT(((DWORD*)pBuffer)[i] == dw);
    }
}

void TestBufferManagerPaging()
{
    printf("TestBufferManagerPaging\n");
    
    const int pagecount = 5000;
    
    CTestConfig config;
    config._ullMaximumPhysicalMemory = 8388608; 
    
    UMS ums;
    IUmsClient* pUmsClient;
    CBufferManager bm;
    
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(ums.CreateUmsClient(&pUmsClient));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    
    // Write a bunch of buffers. Around buffer 1000, we should start paging
    TArray<BM_PAGEID, pagecount> pages;
    pages.SetSize(pagecount);
    UMSSafeLockCookie lock(pUmsClient);
    for(int i=0; i < pagecount; i++)
    {
        BM_PAGE* pPage;
        TEST_ASSERT(bm.CreateNewPage(pUmsClient, &lock, &pPage));
        pages.Set(i, pPage->pageId);
        FillBuffer(((BYTE*)pPage) + sizeof(BM_PAGE), bm.GetPageSize() - sizeof(BM_PAGE), pPage->pageId);
        lock.Release();
    }
    
    // Read all those buffers again. Lots of paging again
    for(int i=0; i < pagecount; i++)
    {
        BM_PAGE* pPage;
        TEST_ASSERT(bm.GetPage(pUmsClient, pages.Get(i), LOCK_MODE_IS, &pPage, &lock));
        CheckBuffer(((BYTE*)pPage) + sizeof(BM_PAGE), bm.GetPageSize() - sizeof(BM_PAGE), pPage->pageId);
        lock.Release();
    }
    
    // Delete all pages. Again, lots of paging.
    for(int i=0; i < pagecount; i++)
    {
        TEST_ASSERT(bm.DeletePage(pUmsClient, pages.Get(i)));
    }
    
    ums.ReleaseUmsClient(pUmsClient);
    ums.Shutdown();
    bm.Term();
    ums.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\toledb.cpp ===
#include "lbs.h"
#include "tests.h"

#define SERVER L"hpleung5"
#define DATABASE L"oledbunit"
#define FIXCHAR "ah-how-"
#define VARCHARSHORT "VS Varchartest VS"
#define VARCHARLONG "LV This is a long varchar from the test program - 0,1,2,3,4,5,6 Its purpose is to have a long string. Let see if any memory corruption happens LV"
#define WVARCHARLONG L"LV This is a long varchar from the test program - 0,1,2,3,4,5,6 Its purpose is to have a long string. Let see if any memory corruption happens LV"
#define NTEXTLONG "NT This is a long NTEXT from the test program - 0,1,2,3,4,5,6 Its purpose is to have a long string. Let see if any memory corruption happens - blah blah !@$%%^&*()~ abcd NT"

INT32   g_nIntegerValue = 1;
INT64   g_nBigInteger = 0x0a0a0a0a0a0a0a0a;
CHAR    g_cTiny = 3;
DATE    g_atldate;
float   g_float = (float)100.001;

WCHAR wszWideCharData[] = L"Some Random Unicode Data : ! @ # $ %";

CODBWSession g_sqlConnection;

void OpenOleDBConnection()
{
    HRESULT hr;
    
    CSmallWStr connectstr;

    // Open connection to config database server
    connectstr.Format(
        L"Provider=SQLOLEDB;Integrated Security=SSPI;"
        L"Data Source=%s;Initial Catalog=%s",
        SERVER, DATABASE);

    TEST_ASSERT(SUCCEEDED(hr = g_sqlConnection.InitializeEx(connectstr.cstr())))

    SYSTEMTIME systime;
    ::GetSystemTime(&systime);
    ::SystemTimeToVariantTime(&systime, &g_atldate);
}

void CloseOleDBConnection()
{
    g_sqlConnection.ReleaseConnection();
}

//Write a bunch of different types into a table - read them back and verify
void TestOleDBSimple()
{
    /*
        Ole Db formatter

        C - DBTYPE_I1
        N - DBTYPE_I2
        I - DBTYPE_I4
        Q - DBTYPE_I8
        T - DBTYPE_I4
        D - DBTYPE_DATE
        G - GUID
        S - STRING ASCII
        W - STRING UNICODE
        B - Binary
        F - Float
    */

    OleDbExecuteProcedureNoResult(g_sqlConnection, L"p_reset");

    int nMaxIteration = rand() % 100;

    for (int i=0;i<nMaxIteration;i++)
    {
        OleDbExecuteProcedureNoResult(g_sqlConnection, L"p_insert %I, %Q, %C, %S, %F, %S, %W, %S, %D, %S", 
                                                        g_nIntegerValue, g_nBigInteger, g_cTiny, 
                                                        FIXCHAR, g_float, VARCHARLONG, 
                                                        WVARCHARLONG, VARCHARSHORT, g_atldate, 
                                                        NTEXTLONG);
    }

    OleDbVerifyRead(g_sqlConnection, L"p_select");

    return;
}


volatile LONG gThreadIndexOleDB = 0;
#define MAX_THREAD 10
void TestMultiThreadedOleDB()
{
    HANDLE arrThreadArray[MAX_THREAD];

    printf("TestMultiThreadedOleDB\n");

    ZeroMemory(arrThreadArray, sizeof(HANDLE) * MAX_THREAD);

    for (int nThreadIndex=0;nThreadIndex<MAX_THREAD;nThreadIndex++)
    {
        DWORD dwThreadId = 0;
        arrThreadArray[nThreadIndex] = ::CreateThread(NULL, 0, &ThreadProcOleWriteVerify, NULL , 0,
                                                        &dwThreadId);

        TEST_ASSERT(arrThreadArray[nThreadIndex] != NULL);
    }

    //wait until all thread terminates
    ::WaitForMultipleObjectsEx(   MAX_THREAD,
                                  arrThreadArray,
                                  TRUE,
                                  INFINITE,
                                  FALSE
                                );

    for (int nThreadIndex=0;nThreadIndex<MAX_THREAD;nThreadIndex++)
    {
        TEST_ASSERT(arrThreadArray[nThreadIndex] != NULL);

        if (NULL != arrThreadArray[nThreadIndex])
        {
            ::CloseHandle(arrThreadArray[nThreadIndex]);
            arrThreadArray[nThreadIndex] = NULL;
        }
    }
}


//Each thread just allocate some and deallocate some
static DWORD ThreadProcOleWriteVerify(void * pVoid)
{
    LONG nThreadIndex = InterlockedIncrement(&gThreadIndexOleDB);
    int nIteration = 20;

    for (int i=0;i<nIteration;i++)
    {
        printf("Test Thread Ole DB %d\r\n", nThreadIndex);
        Sleep(rand() % 5);
        TestOleDBSimple();
    }

    return 0;
}

void OleDbExecuteProcedureNoResult(CODBWSession sql, LPCWSTR pwszProc, ...)
{
    HRESULT hr;

    va_list arg_list;
    va_start(arg_list, pwszProc);

    CWSProcCache pc;

    hr = sql.VCallProc(&pc, pwszProc, arg_list);
    TEST_ASSERT(SUCCEEDED(hr));

    va_end(arg_list);

    return;    
}

/*
    Just Query All Rows and Ensure they contain the right data
*/
void OleDbVerifyRead(CODBWSession sql, LPCWSTR pwszProc, ...)
{
    HRESULT hr;

    va_list arg_list;
    va_start(arg_list, pwszProc);

    CWSProcCache pc;
    
    TEST_ASSERT(SUCCEEDED(sql.VCallProc(&pc, pwszProc, arg_list)));

    struct RowData
    {
        INT32 nInteger;
        INT64 nBigInteger;
        char cTiny;
        char arrFixChar[sizeof(FIXCHAR)];
        float floatdata;
        char arrVarchar17[sizeof(VARCHARSHORT)];
        char arrVarchar1024[sizeof(VARCHARLONG)];
        WCHAR arrWChar[(sizeof(WVARCHARLONG)/2) + 1];
        char arrNTEXT[sizeof(NTEXTLONG)];
        DATE date;
    };

    // Bind rowset columns to the ConfigLbInfo struct
    static DBBINDING bind[] = {
        WSBIND(1, offsetof(RowData, nInteger)  , DBTYPE_I4,  0),
        WSBIND(2, offsetof(RowData, nBigInteger)  , DBTYPE_I8,  0),
        WSBIND(3, offsetof(RowData, cTiny)  , DBTYPE_I1,  0),
        WSBIND(4, offsetof(RowData, arrFixChar)  , DBTYPE_STR,  8),
        WSBIND(5, offsetof(RowData, floatdata)  , DBTYPE_R4,  0),
        WSBIND(6, offsetof(RowData, arrVarchar1024)  , DBTYPE_STR,  1025),
        WSBIND(7, offsetof(RowData, arrWChar)  , DBTYPE_WSTR,  0),
        WSBIND(8, offsetof(RowData, arrVarchar17)  , DBTYPE_STR,  18),
        WSBIND(9, offsetof(RowData, date)  , DBTYPE_DATE,  0),
        WSBIND(10, offsetof(RowData, arrNTEXT)  , DBTYPE_STR,  2049),                        
    };

    if(FAILED(hr = sql.SetBindings(bind, ARRAY_SIZE(bind))))
    {
        goto lDone;
    }

    RowData rowData;
    for(;;)
    {
        ZeroMemory(&rowData, sizeof(RowData));

        DBCOUNTITEM cRows=1;

        if(FAILED(hr = sql.GetRows(&cRows, &rowData, sizeof(RowData))))
        {
            goto lDone;
        }

        if(cRows == 0)
            break;

        TEST_ASSERT(rowData.nInteger    == g_nIntegerValue);
        TEST_ASSERT(rowData.nBigInteger == g_nBigInteger);
        TEST_ASSERT(rowData.cTiny       == g_cTiny);
        TEST_ASSERT(rowData.date        == g_atldate);
        TEST_ASSERT(rowData.floatdata   == g_float); //float is an estimate
        TEST_ASSERT(strcmp ( rowData.arrFixChar    ,  FIXCHAR) == 0 );
        TEST_ASSERT(strcmp ( rowData.arrVarchar17  ,  VARCHARSHORT) == 0 );
        TEST_ASSERT(strcmp ( rowData.arrVarchar1024,  VARCHARLONG) == 0 );
        TEST_ASSERT(strcmp ( rowData.arrNTEXT      ,  NTEXTLONG) == 0 );
        TEST_ASSERT(wcscmp ( rowData.arrWChar      ,  WVARCHARLONG) == 0 );
        
    }

    va_end(arg_list);

lDone:

    return;    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\tnet.cpp ===
#include "lbs.h"
#include "tests.h"
#include "unitutil.h"

class CTestNetClient : public CTestNetConnection
{
public:

    CTestNetClient()
    {
        _hThread = NULL;
        _pConfig = NULL;
    }

    bool Init(CConfig* pConfig, LPCSTR pszClientName)
    {
        bool  fRet = false;
        _pConfig = pConfig;
        _ClientName.Assign(pszClientName);
        
        DWORD dwThreadId;
        _hThread = CreateThread(NULL, 0, StaticThreadProc, this, 0, &dwThreadId);
        
        if(NULL == _hThread)
            goto lDone;
        
        fRet = true;
    
    lDone:
        
        return fRet;
    }

    void Term()
    {
        CloseConnection();
        
        if(_hThread != NULL)
        {
            CloseHandle(_hThread);
            _hThread = NULL;
        }
    }

    HANDLE GetWaitHandle() const
    {
        DBGASSERT(_hThread != NULL);
        return _hThread;
    }

protected:

    static DWORD StaticThreadProc(void* pRawThis)
    {
        ((CTestNetClient*)pRawThis)->ThreadProc();
        return 0;
    }
    
    void ThreadProc()
    {
        if(!CTestNetConnection::Init(_pConfig, _ClientName.cstr()))
        {
            goto lDone;
        }
        
        _status |= StatusExecute;
        if(!Execute())
        {
            _status |= StatusFailed;
            goto lDone;
        }
        
        _status |= StatusCloseConnection;
        if(!CloseConnection())
        {
            _status |= StatusFailed;
            goto lDone;
        }
        
    lDone:
    
        return;
    }

    virtual bool Execute()
    {
        const DWORD RequestCount = 1000;
        const DWORD RowsetCount  = 2;
        const DWORD RowCount     = 100;
        bool fEOR;
        
        for(int i=0; i < RequestCount; i++)
        {
            BeginRequest(1, 1);
            
            BeginProcedure(1, 8);
            AddParamInt32(RowCount);
            AddParamInt32(RowsetCount);
            AddParamInt8(-123);
            AddParamInt16(-123);
            AddParamInt32(-123);
            AddParamInt64(-123);
            AddParamDouble(3.1415);
            AddParamStr("Hello World");
            EndProcedure();
            
            TEST_ASSERT(SendRequest());
            
            for(int iRowsetNdx=0; iRowsetNdx < RowsetCount; iRowsetNdx++)
            {
                TEST_ASSERT(NextResult() == NetReplyResultRowset);
                
                for(int iRowNdx=0; iRowNdx < RowCount; iRowNdx++)
                {
                    TEST_ASSERT(NextRow(&fEOR) && !fEOR);
                    INT32 iRank = GetColumn(0)->i32;
                    TEST_ASSERT(iRank == iRowNdx+1);
                }
                
                TEST_ASSERT(NextRow(&fEOR) && fEOR);
            }
            
            TEST_ASSERT(NextResult() == NetReplyResultNoMore);
        }
        
        return true;
    }
                    
    CConfig*      _pConfig;
    HANDLE        _hThread;
    CVerySmallStr _ClientName;
};

class CTestNetCallback : public INetCallback
{
public:
    
    virtual bool OnNewRequest(CLBSPRequest *pRequest, INetReply *pReply)
    {
        for(int iProcNdx=0; iProcNdx < pRequest->GetProcCount(); iProcNdx++)
        {
            CLBSPProcedure* pProc = pRequest->GetProcedure(iProcNdx);
            
            switch(pProc->GetProcId())
            {
            case 1:
                Proc1(pProc,pReply);
                break;
            
            case 2:
                Proc2(pProc,pReply);
                break;
            
            default:
                TEST_ASSERT(false);
            }
            
        }
        
        TEST_ASSERT(pReply->ReplyDone());
        
        return true;
    }
    
    void Proc1(CLBSPProcedure* pProc, INetReply* pReply)
    {
        INT32 iRowCount;
        TEST_ASSERT(pProc->GetInt32(0, &iRowCount));
        
        INT32 iRowsetCount;
        TEST_ASSERT(pProc->GetInt32(1, &iRowsetCount));
        
        DWORD dwColCount = pProc->GetParamCount()-1;
        LbStat* rgColumn = (LbStat*) _alloca(sizeof(LbStat) * dwColCount);
        ZeroMemory(rgColumn, sizeof(LbStat) * dwColCount);
        
        for(int iParamNdx=1; iParamNdx < (int)dwColCount; iParamNdx++)
        {
            CLBSPParam* pParam;
            TEST_ASSERT(pProc->GetParam(iParamNdx + 1, &pParam));
            
            rgColumn[iParamNdx].bType = pParam->GetType();
            
            if(pParam->IsNull())
            {
                rgColumn[iParamNdx].bType |= LbspTypeIdNullFlag;
                continue;
            }
            
            switch(pParam->GetType())
            {
            case LbspTypeIdInt8:
            {
                INT8  i8Param;
                TEST_ASSERT(pParam->GetInt8(&i8Param));
                rgColumn[iParamNdx].i8 = (INT8) i8Param;
                break;
            }
            
            case LbspTypeIdInt16:
            {
                INT16  i16Param;
                TEST_ASSERT(pParam->GetInt16(&i16Param));
                rgColumn[iParamNdx].i16 = (INT16) i16Param;
                break;
            }
            
            case LbspTypeIdInt32:
            {
                INT32  i32Param;
                TEST_ASSERT(pParam->GetInt32(&i32Param));
                rgColumn[iParamNdx].i32 = (INT32) i32Param;
                break;
            }

            case LbspTypeIdInt64:
            {
                INT64  i64Param;
                TEST_ASSERT(pParam->GetInt64(&i64Param));
                rgColumn[iParamNdx].i64 = (INT64) i64Param;
                break;
            }

            case LbspTypeIdDouble:
            {
                double dParam;
                TEST_ASSERT(pParam->GetDouble(&dParam));
                rgColumn[iParamNdx].d = dParam;
                break;
            }

            case LbspTypeIdString:
            {
                CConstStr str;
                TEST_ASSERT(pParam->GetString(&str));
                rgColumn[iParamNdx].str.wStrLen = str.GetLength();
                rgColumn[iParamNdx].str.pstr    = (CHAR*) str.cstr();
                break;
            }
            
            default:
                TEST_ASSERT(false);
            }
        }
        
        for(int iRowsetNdx=0; iRowsetNdx < iRowsetCount; iRowsetNdx++)
        {
            TEST_ASSERT(pReply->RowsetBegin());
            
            for(int iRowNdx=0; iRowNdx < iRowCount; iRowNdx++)
            {
                rgColumn[0].bType = LbspTypeIdInt32;
                rgColumn[0].i32   = (INT32) iRowNdx + 1;
                TEST_ASSERT(pReply->RowsetRow(rgColumn, dwColCount));
            }
            
            TEST_ASSERT(pReply->RowsetEnd());
        }
    }
    
    void Proc2(CLBSPProcedure* pProc, INetReply* pReply)
    {
        DWORD dwErrorId;
        TEST_ASSERT(pProc->GetInt32(0, (INT32*)&dwErrorId));
        
        CConstStr message;
        TEST_ASSERT(pProc->GetString(1, &message));
        
        TEST_ASSERT(pReply->ReplyMessage(dwErrorId, message.cstr()));
    }
};


class CTestNetClientHelloTimeout : public CTestNetClient
{
protected:
    
    virtual bool SendHello()
    {
        DWORD dwHelloTimeout = _pConfig->GetNetHelloTimeout();
        Sleep(dwHelloTimeout + 2000);
        return true;
    }
};

void TestNetParameterPermutation()
{
    printf("TestNetParameterPermutation\n");

    CNet net;
    CServerTimer timer;
    CTestConfig config;
    CTestNetCallback callback;

    LbStat rgParameters[7];
    rgParameters[0].bType = LbspTypeIdInt8;
    rgParameters[0].i8    = -121;
    rgParameters[1].bType = LbspTypeIdInt16;
    rgParameters[1].i16   = 26473;
    rgParameters[2].bType = LbspTypeIdInt32;
    rgParameters[2].i32   = 102039482;
    rgParameters[3].bType = LbspTypeIdInt64;
    rgParameters[3].i64   = (INT64) 0x123456789ABCDEF1;
    rgParameters[4].bType = LbspTypeIdDouble;
    rgParameters[4].d     = 3.1415;
    rgParameters[5].bType = LbspTypeIdString;
    rgParameters[5].str.pstr = "Nada demais";
    rgParameters[6].bType = LbspTypeIdString;
    rgParameters[6].str.pstr = 
        "Olha que frase grande. Nesta frase, represento o infinito "
        "misticismo do universo";
    
    // Calculate number of permutations
    int iPermutations = 1;
    for(int i=2; i <= ARRAY_SIZE(rgParameters); i++)
        iPermutations *= i;
        
    TEST_ASSERT(timer.Init());
    TEST_ASSERT(net.Init(&config, &timer, &callback, NULL));

    CTestNetConnection client;
    TEST_ASSERT(client.Init(&config, "Client1"));

    for(int i=0; i < iPermutations; i++)
    {
        // Send request
        client.BeginRequest(i+1, 1);
        client.BeginProcedure(1, ARRAY_SIZE(rgParameters) + 2);
        
        client.AddParamInt32(1); // Row Count
        client.AddParamInt32(1); // Rowset Count 
        for(int iParamNdx=0; iParamNdx < ARRAY_SIZE(rgParameters); iParamNdx++)
        {
            
            switch(rgParameters[iParamNdx].bType)
            {
            case LbspTypeIdInt8:
                client.AddParamInt8(rgParameters[iParamNdx].i8);
                break;
            case LbspTypeIdInt16:
                client.AddParamInt16(rgParameters[iParamNdx].i16);
                break;
            case LbspTypeIdInt32:
                client.AddParamInt32(rgParameters[iParamNdx].i32);
                break;
            case LbspTypeIdInt64:
                client.AddParamInt64(rgParameters[iParamNdx].i64);
                break;
            case LbspTypeIdDouble:
                client.AddParamDouble(rgParameters[iParamNdx].d);
                break;
            case LbspTypeIdString:
                client.AddParamStr(rgParameters[iParamNdx].str.pstr);
                break;
            default:
                TEST_ASSERT(false);
            }
        }
        client.EndProcedure();
        TEST_ASSERT(client.SendRequest());
        
        // Check response. The procedure will return one rowset with
        // one row with the exact parameters passed in.
        
        TEST_ASSERT(client.NextResult() == NetReplyResultRowset);
        
        bool fEOR;
        TEST_ASSERT(client.NextRow(&fEOR) && !fEOR);
        TEST_ASSERT(client.GetColumnCount() == ARRAY_SIZE(rgParameters) + 1)        
        
        for(int iParamNdx=1; iParamNdx < ARRAY_SIZE(rgParameters); iParamNdx++)
        {
            LbStat* pColumn = client.GetColumn(iParamNdx+1);
            
            TEST_ASSERT(pColumn->bType == rgParameters[iParamNdx].bType);
            
            switch(rgParameters[iParamNdx].bType)
            {
            case LbspTypeIdInt8:
                TEST_ASSERT(pColumn->i8 == rgParameters[iParamNdx].i8);
                break;
            case LbspTypeIdInt16:
                TEST_ASSERT(pColumn->i16 == rgParameters[iParamNdx].i16);
                break;
            case LbspTypeIdInt32:
                TEST_ASSERT(pColumn->i32 == rgParameters[iParamNdx].i32);
                break;
            case LbspTypeIdInt64:
                TEST_ASSERT(pColumn->i64 == rgParameters[iParamNdx].i64);
                break;
            case LbspTypeIdDouble:
                TEST_ASSERT(pColumn->d == rgParameters[iParamNdx].d);
                break;
            case LbspTypeIdString:
                TEST_ASSERT(CConstStr(pColumn->str.pstr).CompareTo(CConstStr(rgParameters[iParamNdx].str.pstr)) == 0);
                break;
            default:
                TEST_ASSERT(false);
            }
        }
        
        TEST_ASSERT(client.NextRow(&fEOR) && fEOR);
        TEST_ASSERT(client.NextResult() == NetReplyResultNoMore);
        
        // Prepare next permutation
        int i1 = i % ARRAY_SIZE(rgParameters);
        int i2 = (i+1) % ARRAY_SIZE(rgParameters);
        LbStat temp = rgParameters[i1];
        rgParameters[i1] = rgParameters[i2];
        rgParameters[i2] = temp;
    }
    
    client.CloseConnection();

    net.Term();    
    timer.Term();
}

void TestNetLargeRowset()
{
    printf("TestNetLargeRowset\n");

    const DWORD RowCount = 100000;

    CNet net;
    CServerTimer timer;
    CTestConfig config;
    CTestNetCallback callback;

    TEST_ASSERT(timer.Init());
    TEST_ASSERT(net.Init(&config, &timer, &callback, NULL));

    CTestNetConnection client;
    TEST_ASSERT(client.Init(&config, "Client1"));

    client.BeginRequest(1, 1);
    client.BeginProcedure(1, 5);
    
    client.AddParamInt32(RowCount); // Row Count
    client.AddParamInt32(1); // Rowset Count 
    client.AddParamStr(
        "As far as the laws of mathematics refer to reality, they are not certain; "
        "and as far as they are certain, they do not refer to reality.");
    client.AddParamStr(
        "I never think of the future - it comes soon enough.");
    client.AddParamStr(
        "Laws alone can not secure freedom of expression; in order that every man "
        "present his views without penalty there must be spirit of tolerance in the "
        "entire population.");
    client.EndProcedure();
    
    TEST_ASSERT(client.SendRequest());
    
    TEST_ASSERT(client.NextResult() == NetReplyResultRowset);
    
    bool pEOR;
    for(int i=0; i < RowCount; i++)
    {
        TEST_ASSERT(client.NextRow(&pEOR) && !pEOR);
    }

    TEST_ASSERT(client.NextRow(&pEOR) && pEOR);
    TEST_ASSERT(client.NextResult() == NetReplyResultNoMore);
    
    client.CloseConnection();
    net.Term();    
    timer.Term();
}

void TestNetMessageReply()
{
    printf("TestNetMessageReply\n");

    CNet net;
    CServerTimer timer;
    CTestConfig config;
    CTestNetCallback callback;

    TEST_ASSERT(timer.Init());
    TEST_ASSERT(net.Init(&config, &timer, &callback, NULL));

    CTestNetConnection client;
    TEST_ASSERT(client.Init(&config, "Client1"));

    client.BeginRequest(1, 2);
    
    client.BeginProcedure(2, 2);
    client.AddParamInt32(0);
    client.AddParamStr("Message1");
    client.EndProcedure();
    
    client.BeginProcedure(2, 2);
    client.AddParamInt32(1);
    client.AddParamStr("Message2");
    client.EndProcedure();
    
    TEST_ASSERT(client.SendRequest());
    
    DWORD dwErrorId;
    CSmallStr message;

    TEST_ASSERT(client.NextResult() == NetReplyResultMessage);
    TEST_ASSERT(client.GetMessage(&dwErrorId,&message));
    TEST_ASSERT(dwErrorId == 0 && message.CompareTo("Message1") == 0);

    TEST_ASSERT(client.NextResult() == NetReplyResultMessage);
    TEST_ASSERT(client.GetMessage(&dwErrorId,&message));
    TEST_ASSERT(dwErrorId == 1 && message.CompareTo("Message2") == 0);
    
    TEST_ASSERT(client.NextResult() == NetReplyResultNoMore);
    
    client.CloseConnection();
    net.Term();    
    timer.Term();
}


void TestNetHelloTimeout()
{
    printf("TestNetHelloTimeout\n");
    
    CNet net;
    CServerTimer timer;
    CTestConfig config;
    CTestNetCallback callback;
    
    config._dwNetHelloTimeout = 1000;
    
    TEST_ASSERT(timer.Init());
    TEST_ASSERT(net.Init(&config, &timer, &callback, NULL));
    
    CTestNetClientHelloTimeout client;
    TEST_ASSERT(client.Init(&config, "Client1"));
    
    WaitForSingleObject(client.GetWaitHandle(), INFINITE);
    TEST_ASSERT(client.GetStatus() & CTestNetClient::StatusFailed);
    TEST_ASSERT(client.GetStatus() & CTestNetClient::StatusReceiveHelloRep);
    TEST_ASSERT(!(client.GetStatus() & CTestNetClient::StatusExecute));
    
    client.Term();

    net.Term();    
    timer.Term();
}

void TestNetPing()
{
    printf("TestNetPing\n");
    
    CNet net;
    CServerTimer timer;
    CTestConfig config;
    CTestNetCallback callback;
    
    TEST_ASSERT(timer.Init());
    TEST_ASSERT(net.Init(&config, &timer, &callback, NULL));
    
    CTestNetConnection cnt;
    cnt.Init(&config, "UNIT_CLIENT");
    
    // Ping begore anything else
    TEST_ASSERT(cnt.Ping());
    
    // Ping after a request
    cnt.BeginRequest(1, 1);
    cnt.BeginProcedure(2, 2);
    cnt.AddParamInt32(0);
    cnt.AddParamStr("String");
    cnt.EndProcedure();
    TEST_ASSERT(cnt.SendRequest());
    TEST_ASSERT(cnt.NextResult() == NetReplyResultMessage);
    TEST_ASSERT(cnt.NextResult() == NetReplyResultNoMore);
    TEST_ASSERT(cnt.Ping());
    
//     // Ping in the middle of a request (must fail)
//     cnt.BeginRequest(2, 1);
//     cnt.BeginProcedure(2, 2);
//     cnt.AddParamInt32(0);
//     cnt.AddParamStr("String");
//     cnt.EndProcedure();
//     TEST_ASSERT(cnt.SendRequest());
//     TEST_ASSERT(!cnt.Ping());
    
    cnt.CloseConnection();
    
    net.Term();    
    timer.Term();
}

void TestNetConcurrency()
{
    printf("TestNetConcurrency\n");
    
    CTestConfig config;
    CServerTimer timer;
    CTestNetCallback callback;
    CNet net;
    
    config._dwIOThreadCount = 21;
    
    TEST_ASSERT(timer.Init());
    TEST_ASSERT(net.Init(&config, &timer, &callback, NULL));
    
    CTestNetClient* rgClient[20]; 
    
    for(int i=0; i < ARRAY_SIZE(rgClient); i++)
    {
        rgClient[i] = new CTestNetClient();
        TEST_ASSERT(rgClient[i] != NULL);
        
        CSmallStr clientName;
        clientName.Format("Client%d", i);
        TEST_ASSERT(rgClient[i]->Init(&config, clientName.cstr()));
    }

    for(int i=0; i < (int)ARRAY_SIZE(rgClient); i++)
    {
        WaitForSingleObject(rgClient[i]->GetWaitHandle(), INFINITE);
    }
    
    for(int i=0; i < (int)ARRAY_SIZE(rgClient); i++)
    {
        rgClient[i]->Term();
        delete rgClient[i];
    }

    net.Term(); 
    timer.Term();
}

class CTestNetProcHandlers
{
public:

    static DWORD Procedure1(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    )
    {
        pReply->ReplyMessage(0, "Procedure1 executed");
        return 0;
    }
    
    static DWORD Procedure2(
        IUmsClient* pUmsClient,
        CRequestGlobalInfo* pInfo, 
        CLBSPProcedure* pProc, 
        INetReply* pReply,
        CArenaMemAlloc* pAlloc,
        CPerfCounters* pPerfCounters
    )
    {
        pReply->ReplyMessage(1, "Procedure2 inducing error");
        return 2;
    }
};


void TestNetRequest()
{
    printf("TestNetRequest\n");
    
    CTestConfig config;
    CServerTimer timer;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CRequestManager rm;
    CNet net;
    CTestPersister persister;
    CTestDb db;
    CLargeStr msg;
    DWORD dwError;
    
    TEST_ASSERT(timer.Init());
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(lbList.Init(&config, &bm, &ums, &persister, &db, NULL));
    
    TEST_ASSERT(rm.Init(&config,&ums,&lbList, NULL));
    TEST_ASSERT(rm.RegisterProc(1, CTestNetProcHandlers::Procedure1));
    TEST_ASSERT(rm.RegisterProc(2, CTestNetProcHandlers::Procedure2));
    
    TEST_ASSERT(net.Init(&config,&timer,&rm, NULL));
    
    CTestNetConnection client;
    TEST_ASSERT(client.Init(&config, "Client1"));
    
    // Call procedure 1
    client.BeginRequest(1, 1);
    client.BeginProcedure(1, 0);
    client.EndProcedure();
    TEST_ASSERT(client.SendRequest());
    
    TEST_ASSERT(client.NextResult() == NetReplyResultMessage);
    TEST_ASSERT(client.GetMessage(&dwError, &msg));
    TEST_ASSERT(0 == dwError);
    TEST_ASSERT(msg.CompareTo("Procedure1 executed") == 0);
    
    TEST_ASSERT(client.NextResult() == NetReplyResultNoMore);
    
    // Call procedure 2 
    client.BeginRequest(2, 1);
    client.BeginProcedure(2, 0);
    client.EndProcedure();
    TEST_ASSERT(client.SendRequest());
    
    TEST_ASSERT(client.NextResult() == NetReplyResultMessage);
    TEST_ASSERT(client.GetMessage(&dwError, &msg));
    TEST_ASSERT(1 == dwError);
    TEST_ASSERT(msg.CompareTo("Procedure2 inducing error") == 0);

    TEST_ASSERT(client.NextResult() == NetReplyResultMessage);
    TEST_ASSERT(client.GetMessage(&dwError, &msg));
    TEST_ASSERT(2 == dwError);
    
    TEST_ASSERT(client.NextResult() == NetReplyResultNoMore);
    
    // Call procedure 1, 2
    client.BeginRequest(3, 2);
    client.BeginProcedure(1, 0);
    client.EndProcedure();
    client.BeginProcedure(2, 0);
    client.EndProcedure();
    TEST_ASSERT(client.SendRequest());
    
    TEST_ASSERT(client.NextResult() == NetReplyResultMessage);
    TEST_ASSERT(client.GetMessage(&dwError, &msg));
    TEST_ASSERT(0 == dwError);
    TEST_ASSERT(msg.CompareTo("Procedure1 executed") == 0);
    
    TEST_ASSERT(client.NextResult() == NetReplyResultMessage);
    TEST_ASSERT(client.GetMessage(&dwError, &msg));
    TEST_ASSERT(1 == dwError);
    TEST_ASSERT(msg.CompareTo("Procedure2 inducing error") == 0);

    TEST_ASSERT(client.NextResult() == NetReplyResultMessage);
    TEST_ASSERT(client.GetMessage(&dwError, &msg));
    TEST_ASSERT(2 == dwError);

    TEST_ASSERT(client.NextResult() == NetReplyResultNoMore);

    // Call procedure 3
    client.BeginRequest(4, 1);
    client.BeginProcedure(3, 0);
    client.EndProcedure();
    TEST_ASSERT(client.SendRequest());
    
    TEST_ASSERT(client.NextResult() == NetReplyResultMessage);
    TEST_ASSERT(client.GetMessage(&dwError, &msg));
    TEST_ASSERT(LbspErrorInvalidProcId == dwError);

    TEST_ASSERT(client.NextResult() == NetReplyResultNoMore);

    client.CloseConnection();    
    
    ums.Shutdown();
    
    net  .Term();
    bm   .Term();
    ums  .Term();
    timer.Term();
}

void TestNetProcs()
{
    printf("TestNetProcs\n");
    
    CTestConfig config;
    CServerTimer timer;
    UMS ums;
    CBufferManager bm;
    CLbList lbList;
    CRequestManager rm;
    CNet net;
    CLargeStr msg;
    CTestPersister persister;
    CTestDb db;
    DWORD dwError;

    TEST_ASSERT(timer.Init());
    TEST_ASSERT(ums.Init(NULL));
    TEST_ASSERT(bm.Init(&config, &ums, NULL));
    TEST_ASSERT(lbList.Init(&config, &bm, &ums, &persister, &db, NULL));
    
    TEST_ASSERT(rm.Init(&config,&ums,&lbList, NULL));
    TEST_ASSERT(CLbRemoteProc::Register(&rm));
    TEST_ASSERT(net.Init(&config,&timer,&rm, NULL));

     CTestNetConnection client;
    TEST_ASSERT(client.Init(&config, "Client1"));

    // CreateLb
    client.BeginRequest(1, 7);
    client.BeginProcedure(LbProcIdLoadLb, 2);
    client.AddParamInt32(0xfeedf00d); // TitleId
    client.AddParamInt32(1); // LbId
    client.EndProcedure();
    
    // StatWrite
    client.BeginProcedure(LbProcIdStatWrite, 13);
    client.AddParamInt32(0xfeedf00d); // TitleId
    client.AddParamInt32(1); // LbId
    client.AddParamInt64(123); // Puid
    client.AddParamInt64(0); //logontime
    client.AddParamInt16(4); // statcount;
    // ** begin stats
    client.AddParamInt16(1);
    client.AddParamInt32(1234);
    client.AddParamInt16(2);
    client.AddParamInt64(5678);
    client.AddParamInt16(3);
    client.AddParamStr("This is a string");
    client.AddParamInt16(LbStatIdRating);
    client.AddParamInt64(1000);
    // ** end stats
    client.EndProcedure();
    
    // StatRead
    client.BeginProcedure(LbProcIdStatRead, 3);
    client.AddParamInt32(0xfeedf00d); // TitleId
    client.AddParamInt32(1); // LbId
    client.AddParamInt64(123); // Puid
    client.EndProcedure();
    
    // StatEnum
    client.BeginProcedure(LbProcIdStatEnum, 4);
    client.AddParamInt32(0xfeedf00d); // TitleId
    client.AddParamInt32(1); // LbId
    client.AddParamInt32(1); // StartingRank
    client.AddParamInt32(5); // EntryCount
    client.EndProcedure();
    
    // GetLbRankedEntryCount
    client.BeginProcedure(LbProcIdGetLbRankedEntryCount, 2);
    client.AddParamInt32(0xfeedf00d); // TitleId
    client.AddParamInt32(1); // LbId
    client.EndProcedure();
    
    // ResetPuid
    client.BeginProcedure(LbProcIdResetPuid, 3);
    client.AddParamInt32(0xfeedf00d); // TitleId
    client.AddParamInt32(1); // LbId
    client.AddParamInt64(123); // Puid
    client.EndProcedure();
        
    // DeleteLb
    client.BeginProcedure(LbProcIdDeleteLb, 2);
    client.AddParamInt32(0xfeedf00d); // TitleId
    client.AddParamInt32(1); // LbId
    client.EndProcedure();
    
    client.SendRequest();
        
    bool fEOR=false;
    TEST_ASSERT(client.NextResult() == NetReplyResultRowset);
    TEST_ASSERT(client.NextRow(&fEOR) && !fEOR);
    TEST_ASSERT(client.GetColumnCount() == 11);
    TEST_ASSERT(client.GetColumn(0)->bType == LbspTypeIdInt32  && client.GetColumn(0)->i32 == 1);   // lbId
    TEST_ASSERT(client.GetColumn(1)->bType == LbspTypeIdInt64  && client.GetColumn(1)->i64 == 123); // Puid
    TEST_ASSERT(client.GetColumn(2)->bType == LbspTypeIdInt32  && client.GetColumn(2)->i32 == 1); // Rank
    TEST_ASSERT(client.GetColumn(3)->bType == LbspTypeIdInt16  && client.GetColumn(3)->i16 == 1);     
    TEST_ASSERT(client.GetColumn(4)->bType == LbspTypeIdInt32  && client.GetColumn(4)->i32 == 1234);     
    TEST_ASSERT(client.GetColumn(5)->bType == LbspTypeIdInt16  && client.GetColumn(5)->i16 == 2);     
    TEST_ASSERT(client.GetColumn(6)->bType == LbspTypeIdInt64  && client.GetColumn(6)->i64 == 5678); 
    TEST_ASSERT(client.GetColumn(7)->bType == LbspTypeIdInt16  && client.GetColumn(7)->i16 == 3);     
    TEST_ASSERT(client.GetColumn(8)->bType == LbspTypeIdString && CONSTSTR("This is a string").CompareTo(client.GetColumn(8)->str.pstr) == 0); 
    TEST_ASSERT(client.GetColumn(9)->bType == LbspTypeIdInt16  && client.GetColumn(9)->i16 == (INT16)LbStatIdRating);     
    TEST_ASSERT(client.GetColumn(10)->bType == LbspTypeIdInt64  && client.GetColumn(10)->i64 == 1000); // Rating
    TEST_ASSERT(client.NextRow(&fEOR) && fEOR);

    TEST_ASSERT(client.NextResult() == NetReplyResultRowset);
    TEST_ASSERT(client.NextRow(&fEOR) && !fEOR);
    TEST_ASSERT(client.GetColumnCount() == 10);
    TEST_ASSERT(client.GetColumn(0)->bType == LbspTypeIdInt32  && client.GetColumn(0)->i32 == 1);     // Rank
    TEST_ASSERT(client.GetColumn(1)->bType == LbspTypeIdInt64  && client.GetColumn(1)->i64 == 123);   // Puid
    TEST_ASSERT(client.GetColumn(2)->bType == LbspTypeIdInt16  && client.GetColumn(2)->i16 == 1);     
    TEST_ASSERT(client.GetColumn(3)->bType == LbspTypeIdInt32  && client.GetColumn(3)->i32 == 1234);     
    TEST_ASSERT(client.GetColumn(4)->bType == LbspTypeIdInt16  && client.GetColumn(4)->i16 == 2);     
    TEST_ASSERT(client.GetColumn(5)->bType == LbspTypeIdInt64  && client.GetColumn(5)->i64 == 5678); 
    TEST_ASSERT(client.GetColumn(6)->bType == LbspTypeIdInt16  && client.GetColumn(6)->i16 == 3);     
    TEST_ASSERT(client.GetColumn(7)->bType == LbspTypeIdString && CONSTSTR("This is a string").CompareTo(client.GetColumn(7)->str.pstr) == 0); 
    TEST_ASSERT(client.GetColumn(8)->bType == LbspTypeIdInt16  && client.GetColumn(8)->i16 == (INT16)LbStatIdRating);     
    TEST_ASSERT(client.GetColumn(9)->bType == LbspTypeIdInt64  && client.GetColumn(9)->i64 == 1000); // Rating
    TEST_ASSERT(client.NextRow(&fEOR) && fEOR);

    TEST_ASSERT(client.NextResult() == NetReplyResultRowset);
    TEST_ASSERT(client.NextRow(&fEOR) && !fEOR);
    TEST_ASSERT(client.GetColumnCount() == 2);
    TEST_ASSERT(client.GetColumn(0)->bType == LbspTypeIdInt32  && client.GetColumn(0)->i32 == 1);     // lbSize
    TEST_ASSERT(client.NextRow(&fEOR) && fEOR);
    
    TEST_ASSERT(client.NextResult() == NetReplyResultRowset);
    TEST_ASSERT(client.NextRow(&fEOR) && !fEOR);
    TEST_ASSERT(client.GetColumnCount() == 1);
    TEST_ASSERT(client.GetColumn(0)->bType == LbspTypeIdInt32 && client.GetColumn(0)->i32 == 1);
    TEST_ASSERT(client.NextRow(&fEOR) && fEOR);
    
    TEST_ASSERT(client.NextResult() == NetReplyResultNoMore);
    
    client.CloseConnection();
    
    ums.Shutdown();
    
    net  .Term();
    bm   .Term();
    ums  .Term();
    timer.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\tprocs.cpp ===
#include "lbs.h"
#include "tests.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\tums.cpp ===
#include "lbs.h"
#include "tests.h"


class CUMSSimpleTask : public UMSTask
{
MEM_POOL_DECLARE();

public:
    
    CUMSSimpleTask(UMS* pUMS, DWORD dwA, DWORD dwB, DWORD* pdwTotal) :
        _pUMS(pUMS),
        _dwA(dwA),
        _dwB(dwB),
        _pdwTotal(pdwTotal)
    {
    }
    
    virtual void Execute(IUmsClient *pUmsClient)
    {
        DWORD dwTotal = 0;
        for(DWORD i=0; i < _dwB; i++)
        {
            dwTotal += _dwA;
        }
        *_pdwTotal = dwTotal;
    }
    
    virtual void Free()
    {
        delete this;
    }
    
protected:
    
    UMS*   _pUMS;
    DWORD  _dwA;
    DWORD  _dwB;
    DWORD* _pdwTotal;
};

MEM_POOL_DEFINE(CUMSSimpleTask);

void TestUMSSimple()          
{
    printf("TestUMSSimple\n");
    MEM_POOL_INIT(CUMSSimpleTask, 1000, true);
    
    const int c_tasks = 1;
    DWORD* rgdwResults = new DWORD[c_tasks];
    ZeroMemory(rgdwResults, sizeof(DWORD) * c_tasks);
    
    UMS ums;
    
    TEST_ASSERT(ums.Init(NULL));
    
    for(int i=0; i < c_tasks; i++)
    {
        CUMSSimpleTask* pTask = new CUMSSimpleTask(&ums, i, 10000, &rgdwResults[i]);
        TEST_ASSERT(ums.AddNewTask(pTask));
    }
    
    ums.Shutdown();
    ums.Term();
    
    for(int i=0; i < c_tasks; i++)
    {
        TEST_ASSERT(rgdwResults[i] == i * 10000);
    }
    
    
    MEM_POOL_TERM(CUMSSimpleTask);
}

class CUMSLockTask : public UMSTask
{
public:

    enum STATE
    {
        IDLE,
        ACQUIRED,
        WAITING,
        TERMINATED
    };
    
    enum ACTION
    {
        NO_ACTION,
        ACQUIRE,
        CHANGE,
        RELEASE,
        DONT_RELEASE,
        USE_THIS_LOCK,
        PREPARE_FOR_CHANGE,
        TERMINATE
    };
    
    CUMSLockTask() : 
        _eAction(NO_ACTION),
        _eState(IDLE),
        _lm(0),
        _pControl(NULL)
    {
        _lid.type = 0;
        _lid.id   = 0;
    }
    
    virtual void Execute(IUmsClient *pUmsClient)
    {   
        _pControl = pUmsClient;
        
        for(;;)
        {
            while(_eAction == NO_ACTION)
                ::Sleep(0);
                
            if(_eAction == TERMINATE)
                break;
            
            switch(_eState)
            {
            case IDLE:
                if(_eAction == ACQUIRE)
                {
                    _eState = WAITING;
                    TEST_ASSERT(pUmsClient->AcquireLock(*((LOCK_ID*)&_lid), _lm, &_lockCookie));
                    _eState = ACQUIRED;
                }
                else if(_eAction == CHANGE)
                {
                    _eState = WAITING;
                    TEST_ASSERT(pUmsClient->ReleaseAndAcquireLock(&_lockCookie, _lm));
                    _eState = ACQUIRED;
                }
                else if(_eAction == USE_THIS_LOCK)
                {
                    _eState = ACQUIRED;
                }
                else
                {
                    TEST_ASSERT(false);
                }
                break;
                
            case ACQUIRED:
                if(_eAction == DONT_RELEASE)
                {
                    ZeroMemory(&_lockCookie, sizeof(_lockCookie));
                    _eState = IDLE;
                }
                else if(_eAction == PREPARE_FOR_CHANGE)
                {
                    _eState = IDLE;
                }
                else if(_eAction == RELEASE)
                {
                    TEST_ASSERT(pUmsClient->ReleaseLock(&_lockCookie));
                    _eState = IDLE;
                }
                else
                {
                    TEST_ASSERT(false);
                }
                break;
                
            default:
                TEST_ASSERT(false);
            }
            
            _eAction = NO_ACTION;
        }
        
        _eState = TERMINATED;
    }
    
    virtual void Free()
    {
        delete this;
    }
    
    void SetAction(ACTION eAction)
    {
        while(_eAction != NO_ACTION)
            Sleep(0);
            
        _eAction = eAction;
    }
    
    __declspec(noinline) bool WaitForState(STATE eState, bool fIsSleeping)
    {
        DWORD dwNow = GetTickCount();
        
        while(true || GetTickCount() - dwNow < 3000)
        {
            if(eState == _eState && _pControl->IsSleeping() == fIsSleeping)
                return true;
            else
                ::Sleep(0);
        }
        
        return false;
    }
    
    volatile ACTION    _eAction;
    volatile STATE     _eState;
    volatile LOCK_ID   _lid;
    volatile LOCK_MODE _lm;
    UMSLockCookie      _lockCookie;
    IUmsClient*   _pControl;
};

void TestUMSLocks()
{
    printf("TestUMSLocks\n");
    
    static const LOCK_ID lid = { 123, 0x1234567890 };
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CUMSLockTask* rgpTask[8];
    
    for(int i=0; i < ARRAY_SIZE(rgpTask); i++)
    {
        rgpTask[i] = new CUMSLockTask();
        TEST_ASSERT(ums.AddNewTask(rgpTask[i]));
    }
    
    // 0 acquires X.
    *const_cast<LOCK_ID*>(&rgpTask[0]->_lid) = lid;
    rgpTask[0]->_lm  = LOCK_MODE_X;
    rgpTask[0]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::ACQUIRED, false));
    
    // 1 tries to acquire SIX. It enters waiting state.
    *const_cast<LOCK_ID*>(&rgpTask[1]->_lid) = lid;
    rgpTask[1]->_lm  = LOCK_MODE_SIX;
    rgpTask[1]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::WAITING, true));
    
    // 2 tries to acquire SIX. It enters waiting state.
    *const_cast<LOCK_ID*>(&rgpTask[2]->_lid) = lid;
    rgpTask[2]->_lm  = LOCK_MODE_SIX;
    rgpTask[2]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::WAITING, true));
    
    // 3 tries to acquire IX. It enters waiting state.
    *const_cast<LOCK_ID*>(&rgpTask[3]->_lid) = lid;
    rgpTask[3]->_lm  = LOCK_MODE_IX;
    rgpTask[3]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[3]->WaitForState(CUMSLockTask::WAITING, true));
    
    // 4 tries to acquire IX. It enters waiting state.
    *const_cast<LOCK_ID*>(&rgpTask[4]->_lid) = lid;
    rgpTask[4]->_lm  = LOCK_MODE_IX;
    rgpTask[4]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[4]->WaitForState(CUMSLockTask::WAITING, true));

    // 5 tries to acquire IS. It enters waiting state.
    *const_cast<LOCK_ID*>(&rgpTask[5]->_lid) = lid;
    rgpTask[5]->_lm  = LOCK_MODE_IS;
    rgpTask[5]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[5]->WaitForState(CUMSLockTask::WAITING, true));

    // 6 tries to acquire IS. It enters waiting state.
    *const_cast<LOCK_ID*>(&rgpTask[6]->_lid) = lid;
    rgpTask[6]->_lm  = LOCK_MODE_IS;
    rgpTask[6]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[6]->WaitForState(CUMSLockTask::WAITING, true));

    // 7 tries to acquire X. It enters waiting state.
    *const_cast<LOCK_ID*>(&rgpTask[7]->_lid) = lid;
    rgpTask[7]->_lm  = LOCK_MODE_X;
    rgpTask[7]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[7]->WaitForState(CUMSLockTask::WAITING, true));

    // 0 releases X. 7 grabs it. Nobody else moves.
    rgpTask[0]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[3]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[4]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[5]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[6]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[7]->WaitForState(CUMSLockTask::ACQUIRED, false));
    
    // 7 releases X. 1 grabs SIX. 5 and 6 grabs IS.
    rgpTask[7]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[3]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[4]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[5]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[6]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[7]->WaitForState(CUMSLockTask::IDLE, false));
    
    // 5 releases IS. 
    rgpTask[5]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[3]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[4]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[5]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[6]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[7]->WaitForState(CUMSLockTask::IDLE, false));
    
    // 1 releases SIX. 2 grabs SIX. 
    rgpTask[1]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[3]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[4]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[5]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[6]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[7]->WaitForState(CUMSLockTask::IDLE, false));
    
    // 2 releases SIX. 3 and 4 grabs IX. 
    rgpTask[2]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[3]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[4]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[5]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[6]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[7]->WaitForState(CUMSLockTask::IDLE, false));
    
    // 3, 4 and 6 releases their locks
    rgpTask[3]->SetAction(CUMSLockTask::RELEASE);
    rgpTask[4]->SetAction(CUMSLockTask::RELEASE);
    rgpTask[6]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[3]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[4]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[5]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[6]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[7]->WaitForState(CUMSLockTask::IDLE, false));

    // 0 and 1 grab an IX
    rgpTask[0]->_lm = LOCK_MODE_IX;
    rgpTask[0]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::ACQUIRED, false));
    rgpTask[1]->_lm = LOCK_MODE_IX;
    rgpTask[1]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::ACQUIRED, false));
    
    // 0 queues up another lock, this time a SIX
    UMSLockCookie lockCookie0IX = rgpTask[0]->_lockCookie;
    rgpTask[0]->SetAction(CUMSLockTask::DONT_RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    rgpTask[0]->_lm = LOCK_MODE_SIX;
    rgpTask[0]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::ACQUIRED, false));

    // 1 releases the lock. 0 is unblocked and gets its SIX.
    rgpTask[1]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::IDLE, false));
    
    // 0 releases the IX
    UMSLockCookie lockCookie0SIX = rgpTask[0]->_lockCookie; 
    rgpTask[0]->_lockCookie = lockCookie0IX;
    rgpTask[0]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    
    // 0 upgrades the lock to an X    
    rgpTask[0]->_lm = LOCK_MODE_X;
    rgpTask[0]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::IDLE, false));
    
    // 0 releases all locks
    rgpTask[0]->SetAction(CUMSLockTask::RELEASE); // X
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    rgpTask[0]->SetAction(CUMSLockTask::USE_THIS_LOCK); // X
    rgpTask[0]->_lockCookie = lockCookie0SIX;
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::ACQUIRED, false));
    rgpTask[0]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    
    // 0 grabs a IS
    rgpTask[0]->_lm = LOCK_MODE_IS;
    rgpTask[0]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::ACQUIRED, false));

    // 1 queues an X
    rgpTask[1]->_lm = LOCK_MODE_X;
    rgpTask[1]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::WAITING, true));
    
    // 2 queues an IS
    rgpTask[2]->_lm = LOCK_MODE_IS;
    rgpTask[2]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::WAITING, true));
    
    // 0 releases IS. 1 gets the X it was waiting for. 2 keeps on waiting
    rgpTask[0]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::WAITING, true));
    
    // 1 releases X. 2 gets the IS.
    rgpTask[1]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::ACQUIRED, false));

    // 2 releases IS
    rgpTask[2]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::IDLE, false));
    
    // 0 and 1 grab an IX
    rgpTask[0]->_lm = LOCK_MODE_IX;
    rgpTask[0]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::ACQUIRED, false));
    rgpTask[1]->_lm = LOCK_MODE_IX;
    rgpTask[1]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::ACQUIRED, false));

    // 0 queues up an upgrade, this time a SIX
    rgpTask[0]->SetAction(CUMSLockTask::PREPARE_FOR_CHANGE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    rgpTask[0]->_lm = LOCK_MODE_SIX;
    rgpTask[0]->SetAction(CUMSLockTask::CHANGE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::ACQUIRED, false));

    // 1 does the same thing but it gets the lock
    rgpTask[1]->SetAction(CUMSLockTask::PREPARE_FOR_CHANGE);
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::IDLE, false));
    rgpTask[1]->_lm = LOCK_MODE_SIX;
    rgpTask[1]->SetAction(CUMSLockTask::CHANGE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::WAITING, true));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::ACQUIRED, false));

    // 1 releases the SIX. 0 gets it.
    rgpTask[1]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::IDLE, false));
    
    // 0 releases SIX
    rgpTask[0]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));

    
    // Test using different lock ids just to make sure that the hashtable is working correctly
    
    *const_cast<LOCK_ID*>(&rgpTask[0]->_lid) = lid;
    rgpTask[0]->_lm  = LOCK_MODE_X; 
    rgpTask[0]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::ACQUIRED, false));
    
    *const_cast<LOCK_ID*>(&rgpTask[1]->_lid) = lid;
    rgpTask[1]->_lid.id += UMS_SIZE_LOCK_RESOURCE_TABLE; // use same slot in hash table
    rgpTask[1]->_lm  = LOCK_MODE_X;
    rgpTask[1]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::ACQUIRED, false));
    
    *const_cast<LOCK_ID*>(&rgpTask[2]->_lid) = lid; 
    rgpTask[2]->_lm  = LOCK_MODE_IS;
    rgpTask[2]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::WAITING, true));

    *const_cast<LOCK_ID*>(&rgpTask[3]->_lid) = lid;
    rgpTask[3]->_lid.id += UMS_SIZE_LOCK_RESOURCE_TABLE; // use same slot in hash table
    rgpTask[3]->_lm  = LOCK_MODE_IS;
    rgpTask[3]->SetAction(CUMSLockTask::ACQUIRE);
    TEST_ASSERT(rgpTask[3]->WaitForState(CUMSLockTask::WAITING, true));
    
    rgpTask[0]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[3]->WaitForState(CUMSLockTask::WAITING, true));

    rgpTask[1]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::IDLE, false));
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::ACQUIRED, false));
    TEST_ASSERT(rgpTask[3]->WaitForState(CUMSLockTask::ACQUIRED, false));

    rgpTask[2]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[2]->WaitForState(CUMSLockTask::IDLE, false));
    rgpTask[3]->SetAction(CUMSLockTask::RELEASE);
    TEST_ASSERT(rgpTask[3]->WaitForState(CUMSLockTask::IDLE, false));
    
    // Terminate
    for(int i=0; i < ARRAY_SIZE(rgpTask); i++)
    {
        rgpTask[i]->SetAction(CUMSLockTask::TERMINATE);
    }    
    
    ums.Shutdown();
    ums.Term();
}

void TestUMSLockCompability()
{
    printf("TestUMSLockCompability\n");
    
    static const LOCK_ID lid = { 123, 0x1234567890 };
    
    UMS ums;
    TEST_ASSERT(ums.Init(NULL));
    
    CUMSLockTask* rgpTask[LOCK_MODE_LAST+1];
    
    for(int i=0; i < ARRAY_SIZE(rgpTask); i++)
    {
        rgpTask[i] = new CUMSLockTask();
        TEST_ASSERT(ums.AddNewTask(rgpTask[i]));
    }
    
    const LOCK_MODE rgMaxCompatibleLock[LOCK_MODE_LAST+1] = {
        /* no lock       */ LOCK_MODE_LAST,
        /* LOCK_MODE_IS  */ LOCK_MODE_SIX,
        /* LOCK_MODE_IX  */ LOCK_MODE_IX,
        /* LOCK_MODE_SIX */ LOCK_MODE_IS,
        /* LOCK_MODE_IX  */ 0
    };
    
    for(LOCK_MODE lm=LOCK_MODE_IS; lm < LOCK_MODE_LAST; lm++) // Main    
    {
        for(LOCK_MODE clm=LOCK_MODE_IS; clm < LOCK_MODE_LAST; clm++) // Compability
        {
            *const_cast<LOCK_ID*>(&rgpTask[0]->_lid) = lid;
            rgpTask[0]->_lm  = lm;
            rgpTask[0]->SetAction(CUMSLockTask::ACQUIRE);
            TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::ACQUIRED, false));
            
            *const_cast<LOCK_ID*>(&rgpTask[1]->_lid) = lid;
            rgpTask[1]->_lm = clm;
            rgpTask[1]->SetAction(CUMSLockTask::ACQUIRE);
            
            if(clm <= rgMaxCompatibleLock[lm])
            {
                TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::ACQUIRED, false));
            }
            else
            {
                TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::WAITING, true));
            }
            
            *const_cast<LOCK_ID*>(&rgpTask[0]->_lid) = lid;
            rgpTask[0]->_lm  = lm;
            rgpTask[0]->SetAction(CUMSLockTask::RELEASE);
            TEST_ASSERT(rgpTask[0]->WaitForState(CUMSLockTask::IDLE, false));
            
            TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::ACQUIRED, false));
            rgpTask[1]->SetAction(CUMSLockTask::RELEASE);
            TEST_ASSERT(rgpTask[1]->WaitForState(CUMSLockTask::IDLE, false));
        }
    }
    
    // Terminate
    for(int i=0; i < ARRAY_SIZE(rgpTask); i++)
    {
        rgpTask[i]->SetAction(CUMSLockTask::TERMINATE);
    }    
    
    ums.Shutdown();
    ums.Term();    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\tutil.cpp ===
#include "lbs.h"
#include "tests.h"

void TestCStr()
{
    printf("TestCStr\n");
    
    // Write nothing
    {
        TStackStr<AnsiStrCharTrait, 10> str;
        TEST_ASSERT(str.Concat(""));
        TEST_ASSERT(str.CompareTo("") == 0);
        TEST_ASSERT(str.GetLength() == 0);
        str.Reset();
        TEST_ASSERT(str.Concat(CVerySmallStr("")));
        TEST_ASSERT(str.CompareTo(CVerySmallStr("")) == 0);
        TEST_ASSERT(str.GetLength() == 0);
        str.Reset();
        TEST_ASSERT(str.Format(""));
        TEST_ASSERT(str.CompareTo("") == 0);
        TEST_ASSERT(str.GetLength() == 0);
    }
    // Write something
    {
        TStackStr<AnsiStrCharTrait, 10> str;
        TEST_ASSERT(str.Concat("12345"));
        TEST_ASSERT(str.CompareTo("12345") == 0);
        TEST_ASSERT(str.GetLength() == 5);
        str.Reset();
        TEST_ASSERT(str.Concat(CVerySmallStr("12345")));
        TEST_ASSERT(str.CompareTo(CVerySmallStr("12345")) == 0);
        TEST_ASSERT(str.GetLength() == 5);
        str.Reset();
        TEST_ASSERT(str.Format("%s", "12345"));
        TEST_ASSERT(str.CompareTo("12345") == 0);
        TEST_ASSERT(str.GetLength() == 5);
    }
    // Write everything
    {
        TStackStr<AnsiStrCharTrait, 10> str;
        TEST_ASSERT(str.Concat("1234567890"));
        TEST_ASSERT(str.CompareTo("1234567890") == 0);
        TEST_ASSERT(str.GetLength() == 10);
        str.Reset();
        TEST_ASSERT(str.Concat(CVerySmallStr("1234567890")));
        TEST_ASSERT(str.CompareTo(CVerySmallStr("1234567890")) == 0);
        TEST_ASSERT(str.GetLength() == 10);
        str.Reset();
        TEST_ASSERT(str.Format("%s", "1234567890"));
        TEST_ASSERT(str.CompareTo("1234567890") == 0);
        TEST_ASSERT(str.GetLength() == 10);
    }
    // Overload
    {
        TStackStr<AnsiStrCharTrait, 10> str;
        TEST_ASSERT(!str.Concat("1234567890ABC"));
        TEST_ASSERT(str.CompareTo("1234567890") == 0);
        TEST_ASSERT(str.GetLength() == 10);
        str.Reset();
        TEST_ASSERT(!str.Concat(CVerySmallStr("1234567890ABC")));
        TEST_ASSERT(str.CompareTo(CVerySmallStr("1234567890")) == 0);
        TEST_ASSERT(str.GetLength() == 10);
        str.Reset();
        TEST_ASSERT(!str.Format("%s", "1234567890ABC"));
        TEST_ASSERT(str.CompareTo("1234567890") == 0);
        TEST_ASSERT(str.GetLength() == 10);
    }
    // Autogrow
    {
        TStackStr<AnsiStrCharTrait, 10> str;
        str.SetAutoGrow(true);
        TEST_ASSERT(str.Concat("12345678901234567890"));
        TEST_ASSERT(str.CompareTo("12345678901234567890") == 0);
        TEST_ASSERT(str.GetLength() == 20);
    }
    {
        TStackStr<AnsiStrCharTrait, 10> str;
        str.SetAutoGrow(true);
        TEST_ASSERT(str.Concat(CVerySmallStr("12345678901234567890")));
        TEST_ASSERT(str.CompareTo(CVerySmallStr("12345678901234567890")) == 0);
        TEST_ASSERT(str.GetLength() == 20);
    }
    {
        TStackStr<AnsiStrCharTrait, 10> str;
        str.SetAutoGrow(true);
        TEST_ASSERT(str.Format("%s", "12345678901234567890"));
        TEST_ASSERT(str.CompareTo("12345678901234567890") == 0);
        TEST_ASSERT(str.GetLength() == 20);
    }
    {
        TEST_ASSERT(CSmallStr("AAA").CompareTo(CSmallStr("AAA")) == 0);
        TEST_ASSERT(CSmallStr("AAA").CompareTo(CSmallStr("AAAA")) == -1);
        TEST_ASSERT(CSmallStr("AAA").CompareTo("AAA") == 0);
        TEST_ASSERT(CSmallStr("AAA").CompareTo("BBB") == -1);
        TEST_ASSERT(CSmallStr("AAa").CompareTo(CSmallStr("AAA")) == -1);
        TEST_ASSERT(CSmallStr("AAa").IgnoreCaseCompareTo(CSmallStr("AAA")) == 0);
    }
    
    // Static strings
    {
        TEST_ASSERT(CSmallStr("AAA").CompareTo(CONSTSTR("AAA")) == 0);
        
        CSmallStr str;
        str.Concat(CONSTSTR("ABC"));
        str.Concat(CONSTSTR("DEF"));
        TEST_ASSERT(str.CompareTo(CONSTSTR("ABCDEF")) == 0);
    }
}

class CLFStackableTestData : 
    public TSingleLink<0>, 
    public TSingleLink<1>, 
    public TSingleLink<2>
{
public:
    
    void Init(int iKey)
    {
        _iKey      = iKey;
        _iVerifier = CalcVerifier(iKey);
    }
    
    void Verify(int iKey) const
    {
        TEST_ASSERT(iKey == _iKey);
        TEST_ASSERT(CalcVerifier(iKey) == _iVerifier);
    }
    
protected:
    
    int CalcVerifier(int iKey) const 
    {
        return (iKey+1) * 1001;
    }
    
    int _iKey;
    int _iVerifier;    
};

void TestCLFStack()
{
    printf("TestCLFStack\n");
    
    CLFStackableTestData rgData[5];
    
    for(int i=0; i < ARRAY_SIZE(rgData); i++)
    {
        rgData[i].Init(i);
    }
    
    // 1 - Push, pop
    {
        TLFStack<CLFStackableTestData> stk;
        
        stk.Push(&rgData[3]);
        stk.Pop();
        rgData[3].Verify(3);
        
        stk.Reset();
    }
    
    // 2 - Push, push, pop, pop
    {
        TLFStack<CLFStackableTestData> stk;
        CLFStackableTestData* p;
        
        stk.Push(&rgData[1]);
        stk.Push(&rgData[2]);
        
        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == &rgData[2]);
        p->Verify(2);
        
        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
    
        stk.Reset();
    }
    
    // 3 - Push, pop, pop, push, pop
    {
        TLFStack<CLFStackableTestData> stk;
        CLFStackableTestData* p;
        
        stk.Push(&rgData[4]);

        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == &rgData[4]);
        p->Verify(4);
    
        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == NULL);
        
        stk.Push(&rgData[1]);
        
        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
        
        stk.Reset();
    }
    
    // 4 - Pop, push, pop
    {
        TLFStack<CLFStackableTestData> stk;
        CLFStackableTestData* p;
        
        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == NULL);
        
        stk.Push(&rgData[1]);
        
        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
        
        stk.Reset();
    }
    
    // Multiple stacks
    {
        TLFStack<CLFStackableTestData, 0> stack1;
        TLFStack<CLFStackableTestData, 1> stack2;
        TLFStack<CLFStackableTestData, 2> stack3;
        
        TEST_ASSERT(stack1.Push(&rgData[0]));
        TEST_ASSERT(stack1.Push(&rgData[1]));
        TEST_ASSERT(stack1.Push(&rgData[2]));
        TEST_ASSERT(stack1.Push(&rgData[3]));
        TEST_ASSERT(stack1.Push(&rgData[4]));

        TEST_ASSERT(stack2.Push(&rgData[4]));
        TEST_ASSERT(stack2.Push(&rgData[3]));
        TEST_ASSERT(stack2.Push(&rgData[2]));
        TEST_ASSERT(stack2.Push(&rgData[1]));
        TEST_ASSERT(stack2.Push(&rgData[0]));
        
        TEST_ASSERT(stack3.Push(&rgData[0]));
        TEST_ASSERT(stack3.Push(&rgData[2]));
        TEST_ASSERT(stack3.Push(&rgData[4]));
        TEST_ASSERT(stack3.Push(&rgData[3]));
        TEST_ASSERT(stack3.Push(&rgData[1]));
        
        TEST_ASSERT(stack1.Pop() == &rgData[4]);
        TEST_ASSERT(stack1.Pop() == &rgData[3]);
        TEST_ASSERT(stack1.Pop() == &rgData[2]);
        TEST_ASSERT(stack1.Pop() == &rgData[1]);
        TEST_ASSERT(stack1.Pop() == &rgData[0]);
        TEST_ASSERT(stack1.Pop() == NULL);

        TEST_ASSERT(stack2.Pop() == &rgData[0]);
        TEST_ASSERT(stack2.Pop() == &rgData[1]);
        TEST_ASSERT(stack2.Pop() == &rgData[2]);
        TEST_ASSERT(stack2.Pop() == &rgData[3]);
        TEST_ASSERT(stack2.Pop() == &rgData[4]);
        TEST_ASSERT(stack2.Pop() == NULL);
        
        TEST_ASSERT(stack3.Pop() == &rgData[1]);
        TEST_ASSERT(stack3.Pop() == &rgData[3]);
        TEST_ASSERT(stack3.Pop() == &rgData[4]);
        TEST_ASSERT(stack3.Pop() == &rgData[2]);
        TEST_ASSERT(stack3.Pop() == &rgData[0]);
        TEST_ASSERT(stack3.Pop() == NULL);
    }
}

class CLFQueueTestData : public CSingleLink
{
public:
    
    void Init(int iKey)
    {
        _iKey      = iKey;
        _iVerifier = CalcVerifier(iKey);
    }
    
    void Verify(int iKey) const
    {
        TEST_ASSERT(iKey == _iKey);
        TEST_ASSERT(CalcVerifier(iKey) == _iVerifier);
    }
    
    int CalcVerifier(int iKey) const 
    {
        return (iKey+1) * 1001;
    }
    
    int _iKey;
    int _iVerifier;    
};

void TestCLFQueue()
{
    printf("TestCLFQueue\n");
    
    CLFQueueTestData rgData[5];
    
    for(int i=0; i < ARRAY_SIZE(rgData); i++)
    {
        rgData[i].Init(i);
    }
    
    // 1 - Enqueue, dequeue
    {
        CLFQueue q;
        q.Init("queue", 10, false, &g_MemAlloc);
        
        q.Enqueue(&rgData[3]);
        TEST_ASSERT(q.Dequeue() == &rgData[3]);
        rgData[3].Verify(3);
        
        q.Term();
    }
    
    // 2 - Enqueue, Enqueue, dequeue, dequeue
    {
        CLFQueue q;
        CLFQueueTestData* p;
        q.Init("queue", 10, false, &g_MemAlloc);
        
        q.Enqueue(&rgData[1]);
        q.Enqueue(&rgData[2]);
        
        p = (CLFQueueTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
        
        p = (CLFQueueTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[2]);
        p->Verify(2);
    
        q.Term();
    }
    
    // 3 - Enqueue, dequeue, dequeue, enqueue, dequeue
    {
        CLFQueue q;
        CLFQueueTestData* p;
        q.Init("queue", 10, false, &g_MemAlloc);
        
        q.Enqueue(&rgData[4]);

        p = (CLFQueueTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[4]);
        p->Verify(4);
    
        p = (CLFQueueTestData*) q.Dequeue();
        TEST_ASSERT(p == NULL);
        
        q.Enqueue(&rgData[1]);
        
        p = (CLFQueueTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
        
        q.Term();
    }
    
    // 4 - Dequeue, Enqueue, Dequeue
    {
        CLFQueue q;
        CLFQueueTestData* p;
        q.Init("queue", 10, false, &g_MemAlloc);
        
        p = (CLFQueueTestData*) q.Dequeue();
        TEST_ASSERT(p == NULL);
        
        q.Enqueue(&rgData[1]);
        
        p = (CLFQueueTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
        
        q.Term();
    }
    
    // 5 - Enqueue x 5, Dequeue x 5
    {
        CLFQueue q;
        CLFQueueTestData* p;
        q.Init("queue", 10, false, &g_MemAlloc);
        
        for(int i=0; i < ARRAY_SIZE(rgData); i++)
        {
            q.Enqueue(&rgData[i]);
        }
        
        for(int i=0; i < ARRAY_SIZE(rgData); i++)
        {
            p = (CLFQueueTestData*) q.Dequeue();
            TEST_ASSERT(p == &rgData[i]);
            p->Verify(i);
        }
        
        q.Term();
    }
}

class CListTestData : public CDoubleLink
{
public:
    
    void Init(int iKey)
    {
        _iKey      = iKey;
        _iVerifier = CalcVerifier(iKey);
    }
    
    void Verify(int iKey) const
    {
        TEST_ASSERT(iKey == _iKey);
        TEST_ASSERT(CalcVerifier(iKey) == _iVerifier);
    }
    
    int CalcVerifier(int iKey) const 
    {
        return (iKey+1) * 1001;
    }
    
    int _iKey;
    int _iVerifier;    
};

void TestTList()
{
    printf("TestTList\n");
    
    CListTestData rgData[5];
    
    for(int i=0; i < ARRAY_SIZE(rgData); i++)
    {
        rgData[i].Init(i);
    }
    
    // 1 - Enqueue, dequeue
    {
        TList<CListTestData> q;
        
        q.Enqueue(&rgData[3]);
        TEST_ASSERT(q.Dequeue() == &rgData[3]);
        rgData[3].Verify(3);
        
        q.Reset();
    }
    
    // 2 - Enqueue, Enqueue, dequeue, dequeue
    {
        TList<CListTestData> q;
        CListTestData* p;
        
        q.Enqueue(&rgData[1]);
        q.Enqueue(&rgData[2]);
        
        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
        
        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[2]);
        p->Verify(2);
    
        q.Reset();
    }
    
    // 3 - Enqueue, dequeue, dequeue, enqueue, dequeue
    {
        TList<CListTestData> q;
        CListTestData* p;
        
        q.Enqueue(&rgData[4]);

        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[4]);
        p->Verify(4);
    
        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == NULL);
        
        q.Enqueue(&rgData[1]);
        
        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
        
        q.Reset();
    }
    
    // 4 - Dequeue, Enqueue, Dequeue
    {
        TList<CListTestData> q;
        CListTestData* p;
        
        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == NULL);
        
        q.Enqueue(&rgData[1]);
        
        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
        
        q.Reset();
    }
    
    // 5 - Enqueue x 5, Dequeue x 5
    {
        TList<CListTestData> q;
        CListTestData* p;
        
        for(int i=0; i < ARRAY_SIZE(rgData); i++)
        {
            q.Enqueue(&rgData[i]);
        }
        
        for(int i=0; i < ARRAY_SIZE(rgData); i++)
        {
            p = (CListTestData*) q.Dequeue();
            TEST_ASSERT(p == &rgData[i]);
            p->Verify(i);
        }
        
        q.Reset();
    }
    
    // Test iterator
    {
        TList<CListTestData> q;
        CListTestData* p;
        
        for(int i=0; i < ARRAY_SIZE(rgData); i++)
        {
            q.Enqueue(&rgData[i]);
        }
        
        TList<CListTestData>::Iterator it;
        q.Begin(&it);
        
        for(int i=0; i < 2; i++)
        {
            int iIndex = 0;
            
            while( (p = it.Next()) != NULL )
            {
                p->Verify(iIndex);
                iIndex++;
            }
            
            q.Begin(&it);
        }
        
        q.Reset();
    }

    // Test iterator with remove from beginning
    {
        TList<CListTestData> q;

        q.Enqueue(&rgData[1]);
        q.Enqueue(&rgData[2]);
        q.Enqueue(&rgData[3]);
        q.Enqueue(&rgData[4]);
        
        TList<CListTestData>::Iterator it;
        q.Begin(&it);
        
        it.Next()->Verify(1);
        it.Remove()->Verify(1);
        
        it.Next()->Verify(2);
        it.Remove()->Verify(2);
        
        it.Next()->Verify(3);
        it.Next()->Verify(4);
        TEST_ASSERT(it.Next() == NULL);
        
        q.Begin(&it);
        it.Next()->Verify(3);
        it.Next()->Verify(4);
        TEST_ASSERT(it.Next() == NULL);
        
        q.Reset();
    }

    // Test iterator with remove from center
    {
        TList<CListTestData> q;

        q.Enqueue(&rgData[1]);
        q.Enqueue(&rgData[2]);
        q.Enqueue(&rgData[3]);
        q.Enqueue(&rgData[4]);
        
        TList<CListTestData>::Iterator it;
        q.Begin(&it);
        
        it.Next()->Verify(1);
        
        it.Next()->Verify(2);
        it.Remove()->Verify(2);
        
        it.Next()->Verify(3);
        it.Remove()->Verify(3);
        
        it.Next()->Verify(4);
        TEST_ASSERT(it.Next() == NULL);
        
        q.Begin(&it);
        it.Next()->Verify(1);
        it.Next()->Verify(4);
        TEST_ASSERT(it.Next() == NULL);
        
        q.Reset();
    }

    // Test iterator with remove from end
    {
        TList<CListTestData> q;

        q.Enqueue(&rgData[1]);
        q.Enqueue(&rgData[2]);
        q.Enqueue(&rgData[3]);
        q.Enqueue(&rgData[4]);
        
        TList<CListTestData>::Iterator it;
        q.Begin(&it);
        
        it.Next()->Verify(1);
        it.Next()->Verify(2);
        
        it.Next()->Verify(3);
        it.Remove()->Verify(3);
        
        it.Next()->Verify(4);
        it.Remove()->Verify(4);
        
        TEST_ASSERT(it.Next() == NULL);
        
        q.Begin(&it);
        it.Next()->Verify(1);
        it.Next()->Verify(2);
        TEST_ASSERT(it.Next() == NULL);
        
        q.Reset();
    }
}


class CFixedSizeMemPoolTestObjectBase
{
public:
    
    CFixedSizeMemPoolTestObjectBase()
    {
        for(int i=0; i < ARRAY_SIZE(_rgBuffer); i++)
        {
            _rgBuffer[i] = GenElem(i); 
        }
    }

    ~CFixedSizeMemPoolTestObjectBase()
    {
        ZeroMemory(this, sizeof(*this));
    }
    
    void Verify()
    {
        for(int i=0; i < ARRAY_SIZE(_rgBuffer); i++)
        {
            TEST_ASSERT(_rgBuffer[i] == GenElem(i));
        }
    }
    
protected:
    
    BYTE GenElem(int i)
    {
        return 'A' + (i % ('Z'-'A'+1));
    }

    BYTE _rgBuffer[1001];
};

class CFixedSizeMemPoolTestObject1 : public CFixedSizeMemPoolTestObjectBase
{
MEM_POOL_DECLARE();    
};

class CFixedSizeMemPoolTestObject2 : public CFixedSizeMemPoolTestObjectBase
{
MEM_POOL_DECLARE();    
};

MEM_POOL_DEFINE(CFixedSizeMemPoolTestObject1);
MEM_POOL_DEFINE(CFixedSizeMemPoolTestObject2);

void TestCFixedSizeMemPool()
{
    printf("TestCFixedSizeMemPool\n");
    
    MEM_POOL_INIT(CFixedSizeMemPoolTestObject1, 10, false);
    MEM_POOL_INIT(CFixedSizeMemPoolTestObject2, 10, true);
    
    
    // no expansion
    {
        for(int j=0; j < 2; j++)
        {
            CFixedSizeMemPoolTestObject1* rg1[10];
            
            for(int i=0; i < ARRAY_SIZE(rg1); i++)
            {
                rg1[i] = new CFixedSizeMemPoolTestObject1();
                
                TEST_ASSERT(rg1[i] != NULL);
                
                rg1[i]->Verify();
            }
            
            TEST_ASSERT((new CFixedSizeMemPoolTestObject1()) == NULL);
            
            for(int i=0; i < ARRAY_SIZE(rg1); i++)
            {
                delete rg1[i];
            }
        }
    }
    
    // with expansion
    {
        for(int j=0; j < 2; j++)
        {
            CFixedSizeMemPoolTestObject2* rg2[11];
            
            for(int i=0; i < ARRAY_SIZE(rg2); i++)
            {
                rg2[i] = new CFixedSizeMemPoolTestObject2();
                
                TEST_ASSERT(rg2[i] != NULL);
                rg2[i]->Verify();
            }
            
            for(int i=0; i < ARRAY_SIZE(rg2); i++)
            {
                delete rg2[i];
            }
        }
    }
    
    MEM_POOL_TERM(CFixedSizeMemPoolTestObject1);
    MEM_POOL_TERM(CFixedSizeMemPoolTestObject2);
}

void TestCArenaMemAlloc()
{
    printf("TestCArenaMemAlloc\n");
    
    CArenaMemAlloc alloc;
    
    // Populate at least two full pages
    
    BYTE* rgPtrs[10240];
    DWORD cPtrs        = 0;
    DWORD dwBufferSize = 0;
    BYTE* pCurrentPage = NULL;
    DWORD cPages       = 0;
    
    while(cPages < 3)
    {
        dwBufferSize = ((dwBufferSize + 1) % 256) + 1;
        
        BYTE* pBuffer = (BYTE*) alloc.Alloc(dwBufferSize);
        TEST_ASSERT(pBuffer != NULL);
        TEST_ASSERT((PtrToUlong(pBuffer) & (sizeof(PVOID)-1)) == 0);
        
        for(DWORD i=0; i < dwBufferSize; i++)
        {
            BYTE b = (BYTE) ('A' + (dwBufferSize % ('Z'-'A'+1)));
            pBuffer[i] = b;           
        }
        
        TEST_ASSERT(cPtrs < ARRAY_SIZE(rgPtrs));
        rgPtrs[cPtrs] = pBuffer;
        cPtrs++;
    
        if(alloc.GetPointerToCurrentPage() != pCurrentPage)
        {
            cPages++;
            pCurrentPage = alloc.GetPointerToCurrentPage();
        }
    }
    
    // Verify the data
    
    dwBufferSize = 0;
    
    for(DWORD j=0; j < cPtrs; j++)
    {
        dwBufferSize = ((dwBufferSize + 1) % 256) + 1;
        
        BYTE* pBuffer = rgPtrs[j];
        
        for(DWORD i=0; i < dwBufferSize; i++)
        {
            BYTE b = (BYTE) ('A' + (dwBufferSize % ('Z'-'A'+1)));
            TEST_ASSERT(pBuffer[i] == b);  
        }
    }
}

void TestTArray()
{
    printf("TestTArray\n");
    
    // Read/write access
    {
        TArray<int, 1024> array;
        array.SetSize(1024);
        
        for(int i=0; i < array.GetSize(); i++)
        {
            array.Set(i, i+1);
        }
        
        for(int i=0; i < array.GetSize(); i++)
        {
            TEST_ASSERT(array.Get(i) == i+1);
        }
    }
    
    // Add operator
    {
        TArray<int, 1024> array;
        
        for(int i=0; i < 1024; i++)
        {
            TEST_ASSERT(array.Add(i+1));
            TEST_ASSERT(array.GetSize() == i+1);
        }
        
        for(int i=0; i < array.GetSize(); i++)
        {
            TEST_ASSERT(array.Get(i) == i+1);
        }
    }
    
    // Dynamic Grow
    {
        TArray<int, 10> array;
        
        for(int i=0; i < 1024; i++)
        {
            TEST_ASSERT(array.Add(i+1));
            TEST_ASSERT(array.GetSize() == i+1);
        }
        
        for(int i=0; i < array.GetSize(); i++)
        {
            TEST_ASSERT(array.Get(i) == i+1);
        }
    }
    
    // Manual Grow
    {
        TArray<int, 1024> array;
        
        for(int i=0; i < 1024; i++)
        {
            TEST_ASSERT(array.Add(i+1));
            TEST_ASSERT(array.GetSize() == i+1);
        }
        
        array.SetSize(10240);
        
        for(int i=0; i < 1024; i++)
        {
            TEST_ASSERT(array.Get(i) == i+1);
        }
    }
}

class CHashClassStr
{
public:
    
    DWORD GetHash(CStr* key)
    {
        DWORD hash, i;
        
        for (hash=0, i=0; i<key->GetLength(); ++i)
        {
            hash += key->cstr()[i];
            hash += (hash << 10);
            hash ^= (hash >> 6);
        }
        hash += (hash << 3);
        hash ^= (hash >> 11);
        hash += (hash << 15);
        
        return hash;
    }
    
    bool IsEqual(CStr* keyA, CStr* keyB)
    {
        return keyA->CompareTo(*keyB) == 0;
    }
};

void TestCHashtable()
{
    printf("TestCHashtable\n");
    
    // No stack
    {
        THashtable<int, int> hash;
        
        // Add a bunch
        for(int i=0; i < 1024; i++)
        {
            hash.Set(i * 101, i);
        }
        
        // Check if they are all there
        for(int i=0; i < 1024; i++)
        {
            int iData;
            TEST_ASSERT(hash.Get(i * 101, &iData));
            TEST_ASSERT(iData == i);
        }
        
        // key exists
        TEST_ASSERT(hash.Get(10 * 101, NULL));
        
        // key does not exist
        TEST_ASSERT(!hash.Get(1025 * 101, NULL));
    }

    // With stack
    {
        TStackHashtable<THashtable<int, int>, 829> hash;
        
        // Add a bunch
        for(int i=0; i < 1024; i++)
        {
            hash.Set(i * 101, i);
        }
        
        // Check if they are all there
        for(int i=0; i < 1024; i++)
        {
            int iData;
            TEST_ASSERT(hash.Get(i * 101, &iData));
            TEST_ASSERT(iData == i);
        }
        
        // key exists
        TEST_ASSERT(hash.Get(10 * 101, NULL));
        
        // key does not exist
        TEST_ASSERT(!hash.Get(1025 * 101, NULL));
    }
    
    // using strings
    {
        CArenaMemAlloc arenaAlloc;
        TStackHashtable<THashtable<CStr*, UINT64, CHashClassStr>, 1024> hash;

        for(int i=0; i < 1024; i++)
        {
            CStr* pStr = new(arenaAlloc) CVerySmallStr;
            pStr->Format("And the number is %d", i);
            hash.Set(pStr, i);
        }
        
        for(int i=0; i < 1024; i++)
        {
            CVerySmallStr key;
            UINT64 iData;
            
            key.Format("And the number is %d", i);
            TEST_ASSERT(hash.Get(&key, &iData));
            TEST_ASSERT(iData == i);
        }
    }
    
    // Test remove
    {
        TStackHashtable<THashtable<int, int>, 101> hash;
        
        int rgData[]   = {0, 1, 101, 102, 4, 9, 100, 201, 50};
        int rgDelete[] = {100, 0, 101, 1, 102, 9, 4, 50, 201};
        
        for(int i=0; i < ARRAY_SIZE(rgData); i++)
            hash.Set(rgData[i], rgData[i]);
        
        for(int i=0; i < ARRAY_SIZE(rgData); i++)
        {
            if(rgData[i] != -1)
                TEST_ASSERT(hash.Get(rgData[i], NULL));
        }
        
        TEST_ASSERT(!hash.Get(10, NULL));
        
        for(int i=0; i < ARRAY_SIZE(rgDelete); i++)
        {
            int iData;
            TEST_ASSERT(hash.Remove(rgDelete[i], &iData));
            TEST_ASSERT(iData == rgDelete[i]);
            
            for(int j=0; j < ARRAY_SIZE(rgData); j++)
            {
				int h;
                for(h=0; h <= i; h++)
                {
                    if(rgData[j] == rgDelete[h])
                        break;
                }
                
                if(h <= i)
                {
                    TEST_ASSERT(!hash.Get(rgData[j], NULL));
                }
                else
                {
                    TEST_ASSERT(hash.Get(rgData[j], &iData));
                    TEST_ASSERT(iData == rgData[j]);
                }
            }
        }
    }
    
    // Test iterator
    {
        TStackHashtable<THashtable<int, int>, 829> hash;
        TStackHashtable<THashtable<int, int>, 829>::Iterator it(&hash);
        
        int n = 1024;
        
        // Add a bunch
        for(int i=1; i <= n; i++)
        {
            hash.Set(i * 101, i);
        }
        
        // Check if they are all there
        it.Reset();
        int iKey;
        int iData;
        int iTotal = 0;
        
        while(it.GetNext(&iKey,&iData))
        {
            TEST_ASSERT(iKey / 101 == iData);
            iTotal += iData;
        }   
        TEST_ASSERT(iTotal == ((n*n) + n)/2);
    }
}

struct TestTHeapData
{
    int   iValue;
    DWORD dwIndex;
};

class CTestTHeapHelper
{
public:
    
    static void OnHeapNewPosition(TestTHeapData* pv, DWORD nNewPos)
    {
        pv->dwIndex = nNewPos;
    }
    
    static int HeapCompare(TestTHeapData* pv1, TestTHeapData* pv2)
    {
        return pv1->iValue - pv2->iValue;
    }
};


void TestStressHeapRemoveAt()
{
    THeap<TestTHeapData*, 1, CTestTHeapHelper, CTestTHeapHelper> heap;
    int nTrack = 0;
    while (true)
    {
        nTrack = nTrack + 1;
        if (nTrack == 100000)
        {
            break;
        }
        if (rand() % 10 > 5)
        {
            TestTHeapData *pData = new TestTHeapData();
            pData->iValue = rand();

            heap.Insert(pData);
        }

        if (rand() % 10 > 5)
        {
            if (heap.GetCount() !=0)
            {
                int nIndex = rand() % heap.GetCount();
                
                TestTHeapData *pRemove =  heap.Remove(nIndex);
                if (pRemove != NULL)
                {
                    delete (pRemove);
                }

                if (heap.Verify(0, 0) == false)
                {
                     TEST_ASSERT(false);
                }
            }
        }
    }

    int nCount = heap.GetCount();
    for (int i=0;i<nCount;i++)
    {
        TestTHeapData *pRemove =  heap.Remove(0);
        if (pRemove != NULL)
        {
            delete (pRemove);
        }
    }

}



void TestTHeap()
{
    printf("TestTHeap\n");
  
    TestTHeapData rgData[1000];
    
    const int prime = 703;
    const int prime2= 1307;


    for(int i=0; i<ARRAY_SIZE(rgData); i++)
    {
        rgData[i].iValue = (i * prime) % ARRAY_SIZE(rgData);
    }
    
    
    {
        THeap<TestTHeapData*, 1, CTestTHeapHelper, CTestTHeapHelper> heap;
        heap.SetAllocator(&g_MemAlloc);
        
        // Insert data and verify order
        for(int i=0; i<ARRAY_SIZE(rgData); i++)
        {
            heap.Insert(&rgData[i]);
        }
    
        
        for(int i=0; i<ARRAY_SIZE(rgData); i++)
        {
            TEST_ASSERT(heap.Remove(0)->iValue == i);
            TEST_ASSERT(heap.GetCount() == ARRAY_SIZE(rgData)-i-1);
        }
    }
    
    {
        THeap<TestTHeapData*, 1, CTestTHeapHelper, CTestTHeapHelper> heap;
        heap.SetAllocator(&g_MemAlloc);
    
        // Insert and remove in 'random' order
        for(int i=0; i<ARRAY_SIZE(rgData); i++)
        {
            heap.Insert(&rgData[i]);
        }
        
        for(int i=0; i<ARRAY_SIZE(rgData);i++)
        {
            int iIndex = (i * prime2) % ARRAY_SIZE(rgData);
            TEST_ASSERT(heap.Remove(rgData[iIndex].dwIndex) == &rgData[iIndex]);
        }
    }
}

class CTestServerTimer : public IServerTimerCallback
{
IMPLEMENT_REFCOUNT;
public:
    
    CTestServerTimer()
    {
        _dwWhen    = 0;
        _fExecuted = false;
        _dwTimeAdjust = 0;
    }
    
    virtual void OnTimer(void *pParam)
    {
        TEST_ASSERT(pParam == this);
        TEST_ASSERT(!_fExecuted);
        
        _fExecuted = true;
        
        DWORD dwNow = GetTickCount() + _dwTimeAdjust;
        DWORD dwDiff;
        
        WrapDWORDCompare(dwNow, _dwWhen, &dwDiff);
        
        TEST_ASSERT(dwDiff <= 500);
    }
    
    volatile DWORD _dwWhen;
    volatile bool _fExecuted;
    DWORD _dwTimeAdjust;
};

void TestCServerTimerSimple()
{
    printf("TestCServerTimerSimple\n");
    
    CServerTimer timer;
    
    TEST_ASSERT(timer.Init());
    
    {
        // Simple test
        // Create a bunch of appointments with non-sequential intervals.
        // Cancel one of the appointments before it happens.
        // Cancel another after it has happened.
        
        const int appts=10;
        const int interval=200;
        const int prime=67;
        
        CTestServerTimer rgTest[appts];
        CServerTimerAppt* rgAppts[appts];
        
        CTestServerTimer testCancelBefore;
        CServerTimerAppt* pApptBefore = NULL;
        
        CTestServerTimer testCancelAfter;
        CServerTimerAppt* pApptAfter = NULL;
        
        // Create appointments
        DWORD dwNow = GetTickCount();
        for(int i=0; i < ARRAY_SIZE(rgTest); i++)
        {
             DWORD dwInterval  = (DWORD)(((prime*i) % ARRAY_SIZE(rgTest))*interval);
             rgTest[i]._dwWhen = dwNow + dwInterval;
             TEST_ASSERT(timer.CreateAppointment(&rgTest[i], &rgTest[i], dwInterval, false, &rgAppts[i]));
             rgAppts[i]->Release();
        }
        
        // Create Cancel-Before appointment
         testCancelBefore._dwWhen = dwNow + interval * appts;
         TEST_ASSERT(timer.CreateAppointment(&testCancelBefore, &testCancelBefore, interval * appts,
             false, &pApptBefore));
        
        // Create Cancel-After appointment
        testCancelAfter._dwWhen = dwNow + interval;
        TEST_ASSERT(timer.CreateAppointment(&testCancelAfter, &testCancelAfter, interval,
            false, &pApptAfter));
        
        // Sleep a bit 
        Sleep(interval + 100);
        //Sleep(600000);
        
        // Cancel the 'Cancel-Before' appointment
        timer.CancelAppointment(pApptBefore);
        
        // Wait 
        Sleep(interval * appts);
        
        // Check
        for(int i=0; i < ARRAY_SIZE(rgTest); i++)
        {
            TEST_ASSERT(rgTest[i]._fExecuted);
        }
        TEST_ASSERT(!testCancelBefore._fExecuted);
        TEST_ASSERT(testCancelAfter._fExecuted);
        
        // Cancel the 'Cancel-after' appointment. It has already been executed,
        // so it should not have any effect.
        timer.CancelAppointment(pApptAfter);
        
        // Release appointments
        pApptBefore->Release();
        pApptAfter->Release();
    }
    
    timer.Term();
}

void TestCServerTimerWrap()
{
    printf("TestCServerTimerWrap\n");
    
    CServerTimer timer;
    
    TEST_ASSERT(timer.Init());

    // Adjust timer to simulate the GetTickCount wrap around 
    timer._dwTimeAdjust = ~0 - GetTickCount() - 500;
    
    CTestServerTimer testBeforeWrap;
    CServerTimerAppt* pApptBefore = NULL;
    
    CTestServerTimer testAfterWrap;
    CServerTimerAppt* pApptAfter = NULL;
        
    DWORD dwNow = timer.GetNow();        
        
    // Before-wrap appointment
     testBeforeWrap._dwWhen       = dwNow + 250;
     testBeforeWrap._dwTimeAdjust = timer._dwTimeAdjust;
     TEST_ASSERT(timer.CreateAppointment(&testBeforeWrap, &testBeforeWrap, 250,
         false, &pApptBefore));

    // After-wrap appointment
    testAfterWrap._dwWhen = dwNow + 750;
    testAfterWrap._dwTimeAdjust = timer._dwTimeAdjust;
    TEST_ASSERT(timer.CreateAppointment(&testAfterWrap, &testAfterWrap, 750,
        false, &pApptAfter));
    
    TEST_ASSERT(testBeforeWrap._dwWhen > testAfterWrap._dwWhen);
    
    // Wait
    Sleep(1000);
    
    // Check
    TEST_ASSERT(testBeforeWrap._fExecuted);
    TEST_ASSERT(testAfterWrap._fExecuted);
    
    pApptBefore->Release();
    pApptAfter->Release();
    
    timer.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbs\unit\unitutil.h ===
#pragma once

class CInputStream
{
public:

    CInputStream()
    {
        _rgBuffer = 0;
        _dwSize   = 0;
        _dwUsed   = 0;
        _dwPos    = 0;
    }
    
    ~CInputStream()
    {
        Term();
    }
    
    bool Init(DWORD dwSizeBuffer)
    {
        DBGASSERT(_rgBuffer == NULL);
        
        bool fRet = false;
        
        _dwSize = dwSizeBuffer;
        _dwUsed = 0;
        _dwPos  = 0;
        
        _rgBuffer = (BYTE*) g_MemAlloc.Alloc(_dwSize);
        
        if(NULL == _rgBuffer)
            goto lDone;
        
        fRet = true;
        
    lDone:
        
        if(!fRet)
            CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
            
        return fRet;
    }

    void Term()
    {
        if(_rgBuffer != NULL)
        {
            g_MemAlloc.Free(_rgBuffer);
            _rgBuffer = NULL;
        }
        
        _dwSize   = 0;
        _dwUsed   = 0;
        _dwPos    = 0;
    }
    
    enum GetPointerToBytesStatus
    {
        GetPointerToBytesSucceeded  = 0,
        GetPointerToBytesEndReached = 1,
        GetPointerToBytesOtherError = 2
    };
    
    GetPointerToBytesStatus GetPointerToBytes(
        BYTE** ppBuffer, 
        DWORD dwSize
    )
    {
        DBGASSERT(dwSize > 0);
        DBGASSERT(_rgBuffer != NULL && _dwSize != 0);
        
        GetPointerToBytesStatus ret = GetPointerToBytesOtherError;
        
        // Ammount of data requested must be less or equal to the size of
        // the internal buffer
        if(dwSize > _dwSize)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                "dwSize (%d) is greater than internal buffer size (%d)", 
                dwSize, _dwSize);
            goto lDone;
        }
        
        if(_dwUsed - _dwPos < dwSize)
        {
            DWORD dwRequired  = dwSize - (_dwUsed - _dwPos);
            DWORD dwRemaining = _dwSize - _dwUsed;
            
            if(dwRequired > dwRemaining)
            {
                // Not enough space at the end of the buffer to read all 
                // the required data. Time to compact the buffer.
                
                if(_dwUsed != _dwPos)
                {
                    MoveMemory(_rgBuffer, _rgBuffer + _dwPos, _dwUsed - _dwPos);
                    _dwUsed = _dwUsed - _dwPos;
                    _dwPos  = 0;
                }
                else
                {
                    _dwUsed = 0;
                    _dwPos  = 0;   
                }
            }
            
            while(_dwUsed - _dwPos < dwSize)
            {
                DWORD dwRead = 0;
                
                // There is not enough data available in the buffer. Read more.
                if(!FeedStream(_rgBuffer + _dwUsed, _dwSize - _dwUsed, &dwRead))
                {
                    CGlobalError::AddMessage(GLOBAL_ERROR_HEADER 
                        "FeedStream failed.");
                    goto lDone;
                }
                
                if(dwRead == 0)
                {
                    ret = GetPointerToBytesEndReached;
                    goto lDone;
                }
                
                _dwUsed += dwRead;
            }
        }
        
        DBGASSERT(_dwUsed - _dwPos >= dwSize);
        
        // Return pointer to buffer
        *ppBuffer = _rgBuffer + _dwPos;
        _dwPos += dwSize;
        ret = GetPointerToBytesSucceeded;
        
    lDone:
    
        if(GetPointerToBytesOtherError == ret)
            CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
            
        return ret;
    }
    
    void Rewind(DWORD dwBytesToRewind)
    {
        DBGASSERT(_dwPos >= dwBytesToRewind);
        _dwPos -= dwBytesToRewind;
    }

protected:

    virtual bool FeedStream(BYTE* pBuffer, DWORD dwSize, DWORD* pdwRead) = 0;

    BYTE* _rgBuffer;
    DWORD _dwSize;
    DWORD _dwUsed;
    DWORD _dwPos;
};


class CNetRequestBuilder
{
public:
    
    CNetRequestBuilder()
    {
        _cbUsed = 0;
    }
    
    void BeginRequest(DWORD dwReqId, WORD wProcCount)
    {
        _cbUsed        = 0;
        _dwReqId       = dwReqId;
        _wProcCount    = wProcCount;
        _wProcSpecd    = 0;
        _wParamCount   = 0;
        _wParamSpecd   = 0;
        _pProcCall     = NULL;
        _wProcCallSize = 0;
        
        
        LbspReqBeginRequest* pBeginReq;
        
        pBeginReq = (LbspReqBeginRequest*) GetPointer(sizeof(LbspReqBeginRequest));
        pBeginReq->hdr.wMsgSize = sizeof(LbspReqBeginRequest);
        pBeginReq->hdr.wMsgType = LbspIdReqBeginRequest;
        pBeginReq->dwReqId      = dwReqId;
        pBeginReq->wProcCount   = wProcCount;
    }
    
    void BeginProcedure(DWORD dwProcId, WORD wParamCount)
    {
        TEST_ASSERT(NULL == _pProcCall);
        TEST_ASSERT(_wProcSpecd <  _wProcCount);
        
        _wParamCount   = wParamCount;
        _wParamSpecd   = 0;
        _wProcCallSize = sizeof(LbspReqProcCall);
        
        
        _pProcCall = (LbspReqProcCall*)GetPointer(sizeof(LbspReqProcCall));
        
        _pProcCall->hdr.wMsgSize = 0; // We'll have to come back later to fill this one out
        _pProcCall->hdr.wMsgType = LbspIdReqProcCall;
        _pProcCall->dwProcId     = dwProcId;
        _pProcCall->wParamCount  = _wParamCount;
    }
    
    void EndProcedure()
    {
        TEST_ASSERT(_pProcCall != NULL);
        TEST_ASSERT(_wParamCount == _wParamSpecd);
        
        _pProcCall->hdr.wMsgSize = _wProcCallSize;
        
        _wProcSpecd++;
        _pProcCall = NULL;
    }
    
    void AddParamInt8(INT8 param)
    {
        TEST_ASSERT(_wParamSpecd++ < _wParamCount);
        
        _wProcCallSize += sizeof(BYTE)+sizeof(INT8);
        
        LbspProcParam* pParam = (LbspProcParam*)GetPointer(sizeof(BYTE)+sizeof(INT8));
        
        pParam->bParamType = LbspTypeIdInt8;
        pParam->i8Param    = param;
    }
    
    void AddParamInt16(INT16 param)
    {
        TEST_ASSERT(_wParamSpecd++ < _wParamCount);
        
        _wProcCallSize += sizeof(BYTE)+sizeof(INT16);
        
        LbspProcParam* pParam = (LbspProcParam*)GetPointer(sizeof(BYTE)+sizeof(INT16));
        
        pParam->bParamType = LbspTypeIdInt16;
        pParam->i16Param   = param;
    }

    void AddParamInt32(INT32 param)
    {
        TEST_ASSERT(_wParamSpecd++ < _wParamCount);
        
        _wProcCallSize += sizeof(BYTE)+sizeof(INT32);
        
        LbspProcParam* pParam = (LbspProcParam*)GetPointer(sizeof(BYTE)+sizeof(INT32));
        
        pParam->bParamType = LbspTypeIdInt32;
        pParam->i32Param   = param;
    }

    void AddParamInt64(INT64 param)
    {
        TEST_ASSERT(_wParamSpecd++ < _wParamCount);
        
        _wProcCallSize += sizeof(BYTE)+sizeof(INT64);
        
        LbspProcParam* pParam = (LbspProcParam*)GetPointer(sizeof(BYTE)+sizeof(INT64));
        
        pParam->bParamType = LbspTypeIdInt64;
        pParam->i64Param   = param;
    }

    void AddParamDouble(double param)
    {
        TEST_ASSERT(_wParamSpecd++ < _wParamCount);
        
        _wProcCallSize += sizeof(BYTE)+sizeof(double);
        
        LbspProcParam* pParam = (LbspProcParam*)GetPointer(sizeof(BYTE)+sizeof(double));
        
        pParam->bParamType = LbspTypeIdDouble;
        pParam->dParam     = param;
    }

    void AddParamStr(LPCSTR param)
    {
        TEST_ASSERT(_wParamSpecd++ < _wParamCount);
        
        size_t size;
        TEST_ASSERT(SUCCEEDED(StringCchLengthA(param, LbspMaxSizeStringParam, &size)));
        
        _wProcCallSize += (WORD) (sizeof(BYTE) + sizeof(WORD) + size);
        
        LbspProcParam* pParam = (LbspProcParam*)GetPointer(sizeof(BYTE) + sizeof(WORD) + size);
        
        pParam->bParamType       = LbspTypeIdString;
        pParam->strParam.wStrLen = (WORD)size;
        CopyMemory(pParam->strParam.str, param, size);
    }                                                
    
    DWORD GetRemaining()
    {
        return sizeof(_rgBuffer) - _cbUsed;
    }                                      

    BYTE* GetPointer(DWORD dwSize)
    {
        TEST_ASSERT(GetRemaining() >= dwSize);
        
        BYTE* pBuffer = _rgBuffer + _cbUsed;
        
        _cbUsed += dwSize;
        
        return pBuffer;
    }
    
    void GetRequestBuffer(BYTE** ppBuffer, DWORD* pdwSize)
    {
        TEST_ASSERT(_wProcCount  == _wProcSpecd);
        
        *ppBuffer = _rgBuffer;
        *pdwSize  = _cbUsed;
    }
    
    DWORD GetRequestId()
    {
        return _dwReqId;
    }
    
protected:

    BYTE  _rgBuffer[10240];
    DWORD _cbUsed;
    DWORD _dwReqId;
    WORD  _wProcCount;
    WORD  _wProcSpecd;
    WORD  _wParamCount;
    WORD  _wParamSpecd;
    LbspReqProcCall* _pProcCall;
    WORD  _wProcCallSize;
};

enum NetReplyResult
{
    NetReplyResultError   = -1,
    NetReplyResultNoMore  = 1,
    NetReplyResultMessage = 2,
    NetReplyResultRowset  = 3
};

class CNetReplyParser
{
public:
    
    CNetReplyParser()
    {
        _state    = StateNotInitialized;
        _dwReqId  = 0;
    }

    void Init(DWORD dwReqId, CInputStream* pStream)
    {
        _pStream  = pStream;
        _state    = StateReady;
        _dwReqId  = dwReqId;
        _result   = NetReplyResultNoMore;
    }
    
    NetReplyResult NextResult()
    {
        NetReplyResult ret = NetReplyResultError;
        
        if(_state == StateReady)
        {
            if(!ProcessNextMessages())
                goto lDone;
                
            if(_state == StateReady)
                ret=_result;
            else if(_state == StateParsingRowset)
                ret=NetReplyResultRowset;
            else if(_state == StateEndRequest)
                ret = NetReplyResultNoMore;
            else
                goto lDone;
        }
        
    lDone:
        
        return ret;
    }
    
    bool GetMessage(DWORD* pdwErrorId, CStr* pMessage)
    {
        if(_state == StateReady 
           && _result == NetReplyResultMessage)
        {
            if(pdwErrorId != NULL)
                *pdwErrorId = _dwMessageErrorId;
                
            if(pMessage != NULL)
                pMessage->Assign(_strMessage);
                
            return true;
        }
        else
        {
            DBGASSERT(false);
            return false;
        }
    }
    
    bool NextRow(bool* pEOR)
    {
        bool fRet = false;
        *pEOR = true;
        
        if(StateParsingRowset == _state)
        {
            if(!ProcessNextMessages())
                goto lDone;
        
            if(StateParsingRowset == _state)
            {
                *pEOR = false;
            }
        }
        else if(StateReady != _state)
        {
            TEST_ASSERT(false);
            goto lDone;
        }
        
        fRet = true;
        
    lDone:
    
        return fRet;
    }
    
    DWORD GetColumnCount() const
    {
        DBGASSERT(_state == StateParsingRowset);
        return _dwColumns;
    }
    
    LbStat* GetColumn(DWORD dwColumnNdx)
    {
        DBGASSERT(dwColumnNdx < _dwColumns);
        return &_pColumns[dwColumnNdx];
    }
    
    bool ProcessNextMessages()
    {
        bool fRet  = false;
       
        LbsMsgHeader* pHdr = NULL;
        
        if(_pStream->GetPointerToBytes((BYTE**)&pHdr, sizeof(LbsMsgHeader)) 
            != CInputStream::GetPointerToBytesSucceeded)
        {
            goto lDone;
        }
        
        _pStream->Rewind(sizeof(LbsMsgHeader));
        
        switch(pHdr->wMsgType)
        {
        case LbspIdRepEndRequest:
            {
                LbspRepEndRequest* pMsg;
                
                if(_state != StateReady)
                    goto lDone;
                
                if(_pStream->GetPointerToBytes((BYTE**)&pMsg, pHdr->wMsgSize)
                    != CInputStream::GetPointerToBytesSucceeded)
                {
                    goto lDone;
                }
                
                if(pMsg->dwReqId != _dwReqId)
                    goto lDone;
                
                _state = StateEndRequest;
                _result = NetReplyResultNoMore; 
                
                break;
            }
            
        case LbspIdRepMessage:
            {
                LbspRepMessage* pMsg;
                
                if(_state != StateReady)
                    goto lDone;
                    
                if(_pStream->GetPointerToBytes((BYTE**)&pMsg, pHdr->wMsgSize)
                    != CInputStream::GetPointerToBytesSucceeded)
                {
                    goto lDone;
                }
                
                if(pMsg->wMsgLen > LbspMaxSizeMessage)
                    goto lDone;
                    
                _dwMessageErrorId = pMsg->dwErrorId;
                _strMessage.Reset();
                _strMessage.Concat(pMsg->message, pMsg->wMsgLen);
                _result = NetReplyResultMessage;
                break;
            }
            
        case LbspIdRepRowsetStart:
            {
                LbspRepRowsetStart* pMsg;
                
                if(_state != StateReady)
                    goto lDone;
                
                if(_pStream->GetPointerToBytes((BYTE**)&pMsg, pHdr->wMsgSize)
                    != CInputStream::GetPointerToBytesSucceeded)
                {
                    goto lDone;
                }
                
                _state  = StateParsingRowset;
                _result = NetReplyResultRowset;
                _dwColumns = 0;
                        
                break;
            }
            
        case LbspIdRepRowsetEnd:
            {
                LbspRepRowsetEnd* pMsg;
                
                if(_state != StateParsingRowset)
                    goto lDone;
                    
                if(_pStream->GetPointerToBytes((BYTE**)&pMsg, pHdr->wMsgSize)
                    != CInputStream::GetPointerToBytesSucceeded)
                {
                    goto lDone;
                }
                
                _state = StateReady;
                
                break;
            }
            
        case LbspIdRepRowsetRow:
            {
                LbspRepRowsetRow* pRow;
                
                if(_state != StateParsingRowset)
                    goto lDone;
            
                if(_pStream->GetPointerToBytes((BYTE**)&pRow, pHdr->wMsgSize)
                    != CInputStream::GetPointerToBytesSucceeded)
                {
                    goto lDone;
                }
                
                if(!ParseRow(pRow))
                    goto lDone;
                
                break;
            }
            
        default:
            goto lDone;
        }
        
        fRet = true;
    
    lDone:
    
        if(!fRet)
        {
            _state = StateError;
        }
        
        return fRet;
    }
    
    bool ParseRow(LbspRepRowsetRow* pRow)
    {
        bool fRet = false;
        
        DWORD dwRemaining = pRow->hdr.wMsgSize - sizeof(LbspRepRowsetRow);
        BYTE* pBuffer     = (BYTE*) (pRow+1);
        
        _rowsetAlloc.Reset();
        _dwColumns = pRow->wColCount;
        _pColumns  = new (_rowsetAlloc) LbStat[pRow->wColCount];
        ZeroMemory(_pColumns, sizeof(LbStat) * pRow->wColCount);
        
        for(int i=0; i < pRow->wColCount; i++)
        {
            LbspColumnData* pColumn = (LbspColumnData*) pBuffer;
            
            switch(pColumn->bType & LbspTypeIdTypeMask)
            {
            case LbspTypeIdInt8:
            case LbspTypeIdInt16:
            case LbspTypeIdInt32:
            case LbspTypeIdInt64:
            case LbspTypeIdDouble:
            case LbspTypeIdString:
                break;
            default:
                TEST_ASSERT(false);
                goto lDone;
            };
            
            _pColumns[i].bType = pColumn->bType;
                
            pBuffer += sizeof(BYTE);
            dwRemaining -= sizeof(BYTE);
            
            if(pColumn->bType & LbspTypeIdNullFlag)
            {
                continue;
            }
            
            switch(pColumn->bType & LbspTypeIdTypeMask)
            {
            case LbspTypeIdInt8:
                _pColumns[i].i8 = pColumn->i8;
                pBuffer        += sizeof(INT8);
                dwRemaining    -= sizeof(INT8);
                break;
                
            case LbspTypeIdInt16:
                _pColumns[i].i16 = pColumn->i16;
                pBuffer         += sizeof(INT16);
                dwRemaining     -= sizeof(INT16);
                break;
                
            case LbspTypeIdInt32:
                _pColumns[i].i32 = pColumn->i32;
                pBuffer         += sizeof(INT32);
                dwRemaining     -= sizeof(INT32);
                break;
                
            case LbspTypeIdInt64:
                _pColumns[i].i64 = pColumn->i64;
                pBuffer         += sizeof(INT64);
                dwRemaining     -= sizeof(INT64);
                break;
                
            case LbspTypeIdDouble:
                _pColumns[i].d  = pColumn->d;
                pBuffer        += sizeof(double);
                dwRemaining    -= sizeof(double);
                break;
                
            case LbspTypeIdString:
                TEST_ASSERT(pColumn->str.wStrLen <= LbspMaxSizeStringParam);
                _pColumns[i].str.wStrLen = pColumn->str.wStrLen;
                _pColumns[i].str.pstr = (CHAR*)_rowsetAlloc.Alloc(pColumn->str.wStrLen + 1);
                CopyMemory(_pColumns[i].str.pstr, pColumn->str.str, _pColumns[i].str.wStrLen);
                _pColumns[i].str.pstr[_pColumns[i].str.wStrLen] = '\0';
                
                pBuffer        += sizeof(WORD) + pColumn->str.wStrLen;
                dwRemaining    -= sizeof(WORD) + pColumn->str.wStrLen;
                break;
                
            default:
                TEST_ASSERT(false);
                goto lDone;
            };
        }
        
        TEST_ASSERT(dwRemaining == 0);
        
        fRet = true;
        
    lDone:
    
        return fRet;
    }
   
    enum State
    {
        StateNotInitialized,
        StateReady,
        StateParsingRowset,
        StateEndRequest,
        StateError
    };
    
    State GetState() const { return _state; }
    
protected:

    enum
    {
        BufferSize = 10240
    };

    State          _state;
    CInputStream*  _pStream;
    DWORD          _dwReqId;
    NetReplyResult _result;
    DWORD          _dwMessageErrorId;
    TStackStr<AnsiStrCharTrait, LbspMaxSizeMessage> _strMessage;
    CArenaMemAlloc _rowsetAlloc;
    LbStat*        _pColumns;
    DWORD          _dwColumns;
};

class CTestNetConnection : protected CInputStream
{
public:
   
    enum
    {
        SendTimeout=10000,
        ReceiveHelloTimeout=10000,
        PingTimeout=10000
    };
    
    CTestNetConnection()
    {
        _socket     = INVALID_SOCKET;
        _status     = StatusNotInitialized;
        _pConfig    = NULL;
        _dwCntId    = 0;
        _dwPingSeed = 0;
    }
    
    ~CTestNetConnection()
    {
        DBGASSERT(_socket  == INVALID_SOCKET);
    }

    bool Init(CConfig* pConfig, LPCSTR pszClientName)
    {
        bool  fRet = false;
        _pConfig = pConfig;
        _ClientName.Assign(pszClientName);
        
        _status = StatusConnect;
        
        if(!CInputStream::Init(16384))
            goto lDone;
        
        if(!Connect())
        {
            _status |= StatusFailed;
            goto lDone;
        }
        
        _status |= StatusSendHello;
        
        if(!SendHello())
        {
            _status |= StatusFailed;
            goto lDone;
        }
        
        _status |= StatusReceiveHelloRep;
        
        if(!ReceiveHelloResponse())
        {
            _status |= StatusFailed;
            goto lDone;
        }
        
        fRet = true;
    
    lDone:

        if(_status & StatusFailed)
            fRet = false;
        
        return fRet;
    }
    
    virtual bool CloseConnection()
    {
        bool fRet = false;
        
        if(shutdown(_socket, SD_BOTH) != 0)
            goto lDone;
            
        BYTE rgBuffer[10];
        DWORD cbBuffer;
        
        if(recv(_socket, (char*)&rgBuffer, sizeof(rgBuffer), 0) != 0)
        {
            if(WSAGetLastError() != WSAESHUTDOWN)
                goto lDone;
        }
            
        if(closesocket(_socket) != 0)
            goto lDone;
        
        _socket = INVALID_SOCKET;
            
        fRet = true;
            
    lDone:
    
        return fRet;
    }
    
    bool Ping()
    {
        bool fRet = false;
        
        DBGASSERT(_ClientName.GetLength() >= 1 && _ClientName.GetLength() <= LbspMaxClientName);
        
        // Send LbspReqPing
        
        DWORD dwPrevTimeout;
        DWORD dwSizePrevTimeout = sizeof(dwPrevTimeout);
        if(getsockopt(_socket, SOL_SOCKET, SO_SNDTIMEO, (char*)&dwPrevTimeout, (int*)&dwSizePrevTimeout) != 0)
            goto lDone;
        
        LbspReqPing req;
        req.hdr.wMsgSize = sizeof(LbspReqPing);
        req.hdr.wMsgType = LbspIdReqPing;
        req.dwPing       = ++_dwPingSeed;
        
        DWORD dwTimeout = PingTimeout;
        if(setsockopt(_socket, SOL_SOCKET, SO_SNDTIMEO, (const char*)&dwTimeout, sizeof(dwTimeout)) != 0)
            goto lDone;
        
        if(send(_socket, (char*)&req, req.hdr.wMsgSize, 0) != req.hdr.wMsgSize)
            goto lDone;

        dwTimeout = dwPrevTimeout;
        if(setsockopt(_socket, SOL_SOCKET, SO_SNDTIMEO, (const char*)&dwTimeout, sizeof(dwTimeout)) != 0)
            goto lDone;
            
        // Receive LbspRepPing
        
        dwSizePrevTimeout = sizeof(dwPrevTimeout);
        if(getsockopt(_socket, SOL_SOCKET, SO_RCVTIMEO, (char*)&dwPrevTimeout, (int*)&dwSizePrevTimeout) != 0)
            goto lDone;
        
        LbspRepPing rep;
        
        dwTimeout = PingTimeout;
        if(setsockopt(_socket, SOL_SOCKET, SO_RCVTIMEO, (const char*)&dwTimeout, sizeof(dwTimeout)) != 0)
            goto lDone;
        
        if(recv(_socket, (char*)&rep, sizeof(LbspRepPing), 0) != sizeof(LbspRepPing))
            goto lDone;
        
        dwTimeout = dwPrevTimeout;
        if(setsockopt(_socket, SOL_SOCKET, SO_RCVTIMEO, (const char*)&dwTimeout, sizeof(dwTimeout)) != 0)
            goto lDone;
            
        TEST_ASSERT(rep.hdr.wMsgSize == sizeof(LbspRepPing));
        TEST_ASSERT(rep.hdr.wMsgType == LbspIdRepPing);
        TEST_ASSERT(rep.dwPing == req.dwPing);
        
        fRet = true;
    
    lDone:
    
        return fRet;
    }
    
    void BeginRequest(DWORD dwReqId, WORD wProcCount)
    {
        _req.BeginRequest(dwReqId,wProcCount);
    }
    
    void BeginProcedure(DWORD dwProcId, WORD wParamCount)
    {
        _req.BeginProcedure(dwProcId,wParamCount);
    }
    
    void EndProcedure()
    {
        _req.EndProcedure();
    }
    
    void AddParamInt8(INT8 param)
    {
        _req.AddParamInt8(param);
    }
    
    void AddParamInt16(INT16 param)
    {
        _req.AddParamInt16(param);
    }

    void AddParamInt32(INT32 param)
    {
        _req.AddParamInt32(param);
    }

    void AddParamInt64(INT64 param)
    {
        _req.AddParamInt64(param);
    }

    void AddParamDouble(double param)
    {
        _req.AddParamDouble(param);
    }

    void AddParamStr(LPCSTR param)
    {
        _req.AddParamStr(param);
    }

    bool SendRequest()
    {
        bool fRet = false;
        
        BYTE* pBuffer;
        DWORD dwSize;
        _req.GetRequestBuffer(&pBuffer,&dwSize);
        
        if(send(_socket, (const char*)pBuffer, (int)dwSize, 0) != (int) dwSize)
            goto lDone;
            
        _rep.Init(_req.GetRequestId(), this);
        
        fRet = true;
        
    lDone:
    
        return fRet;
    }
    
    NetReplyResult NextResult()
    {
        return _rep.NextResult();
    }
    
    bool GetMessage(DWORD* pdwErrorId, CStr* pMessage)
    {
        return _rep.GetMessage(pdwErrorId,pMessage);
    }
     
    bool NextRow(bool* pEOR)
    {
        return _rep.NextRow(pEOR);
    }
    
    DWORD GetColumnCount() 
    {
        return _rep.GetColumnCount();
    }
    
    LbStat* GetColumn(DWORD dwColumnNdx)
    {
        return _rep.GetColumn(dwColumnNdx);
    }
     
    enum 
    {
        StatusNotInitialized  = 0,
        StatusConnect         = 1,
        StatusSendHello       = StatusConnect         << 1,
        StatusReceiveHelloRep = StatusSendHello       << 1,
        StatusExecute         = StatusReceiveHelloRep << 1,
        StatusCloseConnection = StatusExecute         << 1,
        
        StatusFailed          = 1                     << 31
    };
    
    DWORD GetStatus() const { return _status; }
    

protected:
    
    virtual bool FeedStream(BYTE* pBuffer, DWORD dwSize, DWORD* pdwRead)
    {
        int iRcvd;
        
        iRcvd = recv(_socket, (char*)pBuffer, dwSize, 0);
        
        if(iRcvd == 0 || iRcvd == SOCKET_ERROR)
            return false;
        
        DBGASSERT((DWORD)iRcvd <= dwSize);
        
        *pdwRead = (DWORD) iRcvd;
        
        return true;
    }
    
    virtual bool Connect()
    {
        bool fRet = false;
        
        DBGASSERT(INVALID_SOCKET == _socket);
        
        _socket = socket(AF_INET, SOCK_STREAM, 0);
        
        if(INVALID_SOCKET == _socket)
            goto lDone;
            
        sockaddr_in sin;
        ZeroMemory(&sin, sizeof(sin));
        sin.sin_family      = AF_INET;
        sin.sin_port        = htons((WORD)_pConfig->GetNetListenPort());
        sin.sin_addr        = _pConfig->GetNetListenAddress();
        
        if(SOCKET_ERROR == connect(_socket, (const sockaddr*) &sin, sizeof(sin)))
            goto lDone;
        
        fRet = true;
            
    lDone:
    
        return fRet;
    }
    
    virtual bool SendHello()
    {
        bool fRet = false;
        DBGASSERT(_ClientName.GetLength() >= 1 && _ClientName.GetLength() <= LbspMaxClientName);
        
        DWORD dwPrevTimeout;
        DWORD dwSizePrevTimeout = sizeof(dwPrevTimeout);
        if(getsockopt(_socket, SOL_SOCKET, SO_SNDTIMEO, (char*)&dwPrevTimeout, (int*)&dwSizePrevTimeout) != 0)
            goto lDone;
        
        BYTE rgBuffer[sizeof(LbspReqHello) + LbspMaxClientName - 1];
        LbspReqHello* pHello = (LbspReqHello*) rgBuffer;
        pHello->hdr.wMsgSize   = sizeof(LbspReqHello) + _ClientName.GetLength() - 1;
        pHello->hdr.wMsgType   = LbspIdReqHello;
        pHello->wClientNameLen = (WORD) _ClientName.GetLength();
        CopyMemory(pHello->clientName, _ClientName.cstr(), _ClientName.GetLength());
        
        DWORD dwTimeout = SendTimeout;
        if(setsockopt(_socket, SOL_SOCKET, SO_SNDTIMEO, (const char*)&dwTimeout, sizeof(dwTimeout)) != 0)
            goto lDone;
        
        if(send(_socket, (char*)rgBuffer, pHello->hdr.wMsgSize, 0) != pHello->hdr.wMsgSize)
            goto lDone;

        dwTimeout = dwPrevTimeout;
        if(setsockopt(_socket, SOL_SOCKET, SO_SNDTIMEO, (const char*)&dwTimeout, sizeof(dwTimeout)) != 0)
            goto lDone;
            
        fRet = true;
    
    lDone:
    
        return fRet;
    }
    
    virtual bool ReceiveHelloResponse()
    {
        bool fRet = false;
        
        DWORD dwPrevTimeout;
        DWORD dwSizePrevTimeout = sizeof(dwPrevTimeout);
        if(getsockopt(_socket, SOL_SOCKET, SO_RCVTIMEO, (char*)&dwPrevTimeout, (int*)&dwSizePrevTimeout) != 0)
            goto lDone;
        
        LbspRepHello repHello;
        
        DWORD dwTimeout = ReceiveHelloTimeout;
        if(setsockopt(_socket, SOL_SOCKET, SO_RCVTIMEO, (const char*)&dwTimeout, sizeof(dwTimeout)) != 0)
            goto lDone;
        
        if(recv(_socket, (char*)&repHello, sizeof(LbspRepHello), 0) != sizeof(LbspRepHello))
            goto lDone;
        
        dwTimeout = dwPrevTimeout;
        if(setsockopt(_socket, SOL_SOCKET, SO_RCVTIMEO, (const char*)&dwTimeout, sizeof(dwTimeout)) != 0)
            goto lDone;
            
        TEST_ASSERT(repHello.hdr.wMsgSize == sizeof(LbspRepHello));
        TEST_ASSERT(repHello.hdr.wMsgType == LbspIdRepHello);
        
        _dwCntId = repHello.dwCid;
        _dwPingSeed = _dwCntId << 16;
        
        fRet = true;
        
    lDone:
    
        return fRet;
    }
    
    SOCKET             _socket;
    volatile DWORD     _status;
    CConfig*           _pConfig;
    CVerySmallStr      _ClientName;
    DWORD              _dwCntId;
    CNetRequestBuilder _req;
    CNetReplyParser    _rep;
    DWORD              _dwPingSeed;
};

class CTestConfig : public CConfig
{
public:

    virtual bool LoadConfig()
    {
        return true;
    }
    
    virtual bool LoadLbInfo(
        CArenaMemAlloc* pAlloc, 
        TList<ConfigLbInfo>* pList
    )
    {
        return true;
    }

    virtual GetLbInfoStatus GetLbInfo(
        UINT32 dwTitleId,
        UINT32 dwLbId,
        ConfigLbInfo* pInfo 
    )
    {
        ZeroMemory(pInfo, sizeof(ConfigLbInfo));
        pInfo->dwTitleId = dwTitleId;
        pInfo->dwLbId    = dwLbId;
        return GetLbInfoStatusSucceeded;
    }
    
    virtual DeleteLbStatus DeleteLb(
        DWORD dwTitleId,
        DWORD dwLbId
    )
    {
        return DeleteLbStatusSucceeded;
    }
    
    virtual bool UpdateLbLastResetTime(
        DWORD  dwTitleId,
        DWORD  dwLbId,
        UINT64 lastReset
    )
    {
        return true;
    }
};

class CTestDb : public CDb
{
public:
    
    virtual bool UpdateLbRow(
        UINT32 uiTitleId, 
        UINT32 uiLbId, 
        UINT64 ui64Puid, 
        LbStat rgStats[], 
        DWORD cStats,
        UINT64 ui64LastUpdt
    )
    {
        return true;
    }
    
    virtual bool RemoveLbRow(
        UINT32 uiTitleId, 
        UINT32 uiLbId, 
        UINT64 ui64Puid
    )
    {
        return true;
    }
    
    virtual bool ResetLb(
        UINT32 uiTitleId, 
        UINT32 uiLbId
    )
    {
        return true;
    }
    
    virtual bool Load(
        DbTitleAndLb rgLb[],
        DWORD cLb,
        IDbCallback* pCallback
    )
    {
        return true;
    }
};

class CTestPersister : public CPersister
{
public:
    
    virtual bool MarkLbRowForUpdate(
        IUmsClient *pUmsClient, 
        UINT32 uiTitleId, 
        UINT32 uiLbId, 
        UINT64 ui64Puid)
    {
        return true;
    }
    
    virtual bool ResetLb(
        IUmsClient* pUmsClient,
        UINT32 uiTitleId,
        UINT32 uiLbId
    )
    {
        return true;
    }
};

#define FillOutLbStatInt8(ENTRY, STATID, V)     \
    {                                           \
        LbStat* pStatEntry_ = &(ENTRY);         \
        pStatEntry_->statId = STATID;           \
        pStatEntry_->bType  = LbspTypeIdInt8;   \
        pStatEntry_->i8     = V;                \
    }                                            
    
#define FillOutLbStatInt16(ENTRY, STATID, V)    \
    {                                           \
        LbStat* pStatEntry_ = &(ENTRY);         \
        pStatEntry_->statId = STATID;           \
        pStatEntry_->bType  = LbspTypeIdInt16;  \
        pStatEntry_->i16    = V;                \
    }

#define FillOutLbStatInt32(ENTRY, STATID, V)    \
    {                                           \
        LbStat* pStatEntry_ = &(ENTRY);         \
        pStatEntry_->statId = STATID;           \
        pStatEntry_->bType  = LbspTypeIdInt32;  \
        pStatEntry_->i32    = V;                \
    }

#define FillOutLbStatInt64(ENTRY, STATID, V)    \
    {                                           \
        LbStat* pStatEntry_ = &(ENTRY);         \
        pStatEntry_->statId = STATID;           \
        pStatEntry_->bType  = LbspTypeIdInt64;  \
        pStatEntry_->i64    = V;                \
    }

#define FillOutLbStatDouble(ENTRY, STATID, V)   \
    {                                           \
        LbStat* pStatEntry_ = &(ENTRY);         \
        pStatEntry_->statId = STATID;           \
        pStatEntry_->bType  = LbspTypeIdDouble; \
        pStatEntry_->d      = V;                \
    }

#define FillOutLbStatString(ENTRY, STATID, V)   \
    {                                           \
        LbStat* pStatEntry_ = &(ENTRY);         \
        pStatEntry_->statId = STATID;           \
        pStatEntry_->bType  = LbspTypeIdString; \
        pStatEntry_->str.pstr = (CHAR*) V;      \
        pStatEntry_->str.wStrLen = ARRAY_SIZE(V)-1;\
    }
    
#define FillOutLbStatNull(ENTRY, STATID)        \
    {                                           \
        LbStat* pStatEntry_ = &(ENTRY);         \
        pStatEntry_->statId = STATID;           \
        pStatEntry_->bType  = LbspTypeIdNullFlag; \
    }

class CUnitUtil
{
public:

    static void CompareLbStat(
        LbStat* pStat1,
        LbStat* pStat2
    )
    {
        TEST_ASSERT(pStat1->statId == pStat2->statId);
        TEST_ASSERT(pStat1->IsNull() == pStat2->IsNull());
        
        if(!pStat1->IsNull())
        {
            TEST_ASSERT(pStat1->bType  == pStat2->bType);
            
            switch(pStat1->bType)
            {
            case LbspTypeIdInt8:
                TEST_ASSERT(pStat1->i8 == pStat2->i8);
                break;
            case LbspTypeIdInt16:
                TEST_ASSERT(pStat1->i16 == pStat2->i16);
                break;
            case LbspTypeIdInt32:
                TEST_ASSERT(pStat1->i32 == pStat2->i32);
                break;
            case LbspTypeIdInt64:
                TEST_ASSERT(pStat1->i64 == pStat2->i64);
                break;
            case LbspTypeIdDouble:
                TEST_ASSERT(pStat1->d == pStat2->d);
                break;
            case LbspTypeIdString:
                TEST_ASSERT(pStat1->str.wStrLen == pStat2->str.wStrLen);
                TEST_ASSERT(pStat1->str.pstr != pStat2->str.pstr)
                TEST_ASSERT(memcmp(pStat1->str.pstr, pStat2->str.pstr,
                    pStat1->str.wStrLen) == 0);
                break;
            default:
                
                TEST_ASSERT(false);
            }
        }
    }
    
    static void CompareLbStatArrays(
        LbStat rgStat1[],
        LbStat rgStat2[],
        DWORD cStat
    )
    {
        for(int i=0; i < (int)cStat; i++)
        {
            CompareLbStat(&rgStat1[i],&rgStat2[i]);
        }
    }
};

class CTraceCallback : public ITraceCallback
{
public:
    
    virtual bool Write(const char *psz)
    {
        fputs(psz, stdout);

        return true;
    }
};

extern CTraceCallback g_unitTraceCallback;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\profile\profilefeapp.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 * 
 * Stats Front-Door (xstatsfd)
 * 
 * statsfeapp.cs
 * 
 * Stats front-end application class
 * 
 * */
using System;
using System.Reflection;
using System.Diagnostics;
using System.Web;
using System.Web.Routing;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.common.service;

using Microsoft.Xbox.Diagnostics;
using Microsoft.Xbox.Profile.Service;

[assembly: XomIisNet4InstallerAttribute(Interface.profilefd)]
[assembly: XomIisNet4InstallerAttribute(Interface.profilefd_int)]
[assembly: ConfigAttribute(Component.profileshimfd)]
[assembly: XomAreaDefinition(XomAreaName.profilelog)]

namespace xonline.server.profile.shim.fd
{
    // StatsFrontEndApp
    // Stats own front-end application class 
    [Discovery("ProfileShim", "1")]
    public class ProfileFrontEndApp : FrontEndApp
    {
        private static ISettingsServiceV1 settingsService = null;

        public static ISettingsServiceV1 SettingsServiceInstance
        {
            get { return settingsService; }
        }

        public static void ResolveAllDependencies()
        {
            settingsService = new SettingsService();
            settingsService.LoadUserSettingsManifest();
        }

        // OnApplicationStart
        // Gets called by FEApp during application start up
        protected override void OnApplicationStart()
        {
            Microsoft.Xbox.Unity.Resolver.LoadConfiguration();

            ResolveAllDependencies();
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\profile\ServiceAdapter.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// ServiceAdapter.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Threading;
using System.Linq;
using System.Web;
using Microsoft.IdentityModel.Claims;
using Microsoft.Xbox.Diagnostics.Errors;
using Microsoft.Xbox.Profile.Contracts;
using Microsoft.Xbox.Profile.Service;
using Microsoft.XboxLive.Auth.Claims;
using xonline.common.protocol;
using xonline.common.service;
using System.Text;
using Microsoft.XboxLive.Auth;

namespace xonline.server.profile.fd
{
    public class ServiceAdapter
    {
        private const string SLSInternalClaimType = "http://services.xboxlive.com/sls/internalServiceClaim";
        private const string SLSInternalClaimValueType = "string";
        private const uint baseErrorCode = 0x83830000;

        public static string GetDeviceTypeString()
        {
            int deviceType;
            if (SGInfo.IsActiveAuth())
            {
                deviceType = XOn.XPLT_WEB;
            }
            else
            {
                deviceType = SGInfo.Current.GetPlatformType();

                if (SGInfo.IsFromLiveCache())
                {
                    string OnBehalfHeader = HttpContext.Current.Request.Headers[XHttpHdr.XPLT_I];

                    if (!String.IsNullOrEmpty(OnBehalfHeader))
                    {
                        deviceType = int.Parse(OnBehalfHeader);
                    }
                }
            }

            string deviceTypeStr;

            switch (deviceType)
            {
                case XOn.XPLT_XBOX360:
                    deviceTypeStr = AuthDeviceTypes.Xbox360;
                    break;

                case XOn.XPLT_PC:
                    deviceTypeStr = AuthDeviceTypes.PC;
                    break;

                case XOn.XPLT_MOBILE:
                    deviceTypeStr = AuthDeviceTypes.WindowsPhone7;
                    break;

                default:
                    deviceTypeStr = AuthDeviceTypes.Web;
                    break;
            }

            return deviceTypeStr;
        }

        public static void CreateClaimsFromSGInfo(SGInfo sginfo, Puid xuid)
        {
            string issuer = new AuthHelper().Issuer; // "xsts.xboxlive.com"; // "sginfo";  // @@@???
            //string callingService = "ProfileShim";
            List<IClaimsIdentity> identities = new List<IClaimsIdentity>();

            // ??? 1 identity per user plus a machine identity? Just a single identity for all?
            // But then how to represent users?

            for (int i = 0; i < sginfo.LogonUsers.Length; i++)
            {
                XUIDAndTrust xuidTrust = sginfo.LogonUsers[sginfo.LogonUsers.Length - i - 1];
                if (
                   (0 != xuidTrust.qwUserID && !xuidTrust.IsGuest()) &&
                   (0 == xuid || xuid == xuidTrust.qwUserID)  // Non zero xuid means we only want that one user
                   )
                {
                    ClaimsIdentity userIdentity = new ClaimsIdentity(
                        "sginfouser",
                        AuthClaimTypes.Xuid,  // name claim type
                        null);
                    identities.Add(userIdentity);

                    userIdentity.Claims.Add(new Claim(AuthClaimTypes.Xuid,
                        xuidTrust.qwUserID.ToString(),
                        AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid],
                        issuer));

                    byte[] privileges = sginfo.GetUserPrivileges(xuidTrust.qwUserID);
                    string privilegeString = privileges.Aggregate(
                        new StringBuilder(),
                        (sb, p) => sb.Append(p + " "),
                        sb => sb.Length == 0 ? String.Empty : sb.ToString(0, sb.Length - 1));
                    userIdentity.Claims.Add(new Claim(AuthClaimTypes.Privileges,
                        privilegeString,
                        AuthClaimTypes.ValueTypes[AuthClaimTypes.Privileges],
                        issuer));

                    /*
                    userIdentity.Claims.Add(new Claim(
                        SLSInternalClaimType,
                        callingService,
                        SLSInternalClaimValueType,
                        callingService));*/
                }
            }

            ClaimsIdentity machineIdentity = new ClaimsIdentity(
                "sginfomachine",
                AuthClaimTypes.DeviceId,  // name claim type
                null);
            identities.Add(machineIdentity);

            machineIdentity.Claims.Add(new Claim(AuthClaimTypes.DeviceId,
                sginfo.MachineId.ToString("X"),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceId],
                issuer));
            machineIdentity.Claims.Add(new Claim(AuthClaimTypes.DeviceType,
                GetDeviceTypeString(),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceType], // @@@ Number? Name?
                issuer));
            machineIdentity.Claims.Add(new Claim(AuthClaimTypes.TitleId,
                sginfo.TitleId.ToString(),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.TitleId],
                issuer));

            Thread.CurrentPrincipal = new ClaimsPrincipal(identities);
        }

        public static UserSettingV1[] ConvertSettingsXOnlineToTFS(UserSetting[] settings, uint titleId)
        {
            if (settings == null)
            {
                return null;
            }

            UserSettingV1[] achs = new UserSettingV1[settings.Length];
            for (int i = 0; i < settings.Length; i++)
            {
                achs[i] = ConvertSettingsXOnlineToTFS(settings[i], titleId);
            }

            return achs;
        }

        public static UserSetting[] ConvertSettingsTFSToXOnline(UserSettingV1[] settings, ulong userId)
        {
            if (settings == null)
            {
                return null;
            }

            UserSetting[] achs = new UserSetting[settings.Length];
            for (int i = 0; i < settings.Length; i++)
            {
                achs[i] = ConvertSettingsTFSToXOnline(settings[i], userId);
            }

            return achs;
        }

        public static UserSetting[] ConvertSettingsTFSToXOnline(ProfileUserV1[] settings)
        {
            if (settings == null)
            {
                return null;
            }

            List<UserSetting> achs = new List<UserSetting>();
            for (int i = 0; i < settings.Length; i++)
            {
                for (int j = 0; j < settings[i].Settings.Length; j++)
                {
                    achs.Add(ConvertSettingsTFSToXOnline(settings[i].Settings[j], settings[i].Id));
                }
            }

            return achs.ToArray();
        }

        public static UserSettingV1 ConvertSettingsXOnlineToTFS(UserSetting setting, uint titleId)
        {
            if (setting == null)
            {
                return null;
            }

            UserSettingV1 settingId = new UserSettingV1();
            settingId.Id = setting.SettingId;
            settingId.TitleId = titleId;
            settingId.Source = setting.Source;
            settingId.Value = setting.Value;

            return settingId;
        }

        public static UserSetting ConvertSettingsTFSToXOnline(UserSettingV1 setting, ulong userId)
        {
            UserSetting settingId = new UserSetting();
            settingId.SettingId = setting.Id;
            settingId.Source = setting.Source;
            settingId.Value = setting.Value;
            settingId.UserId = userId;

            return settingId;
        }

        private static byte[] CopyBytes(byte[] array)
        {
            if (array == null)
                return null;

            byte[] bytes = new byte[array.Length];
            for (int i = 0; i < bytes.Length; i++)
            {
                bytes[i] = array[i];
            }

            return bytes;
        }

        public static HResult ConvertUserSettingsErrorCodeTFSToXOnline(ServiceError error)
        {
            HResult hr = HResult.E_FAIL;
            if (error != null)
            {
                hr = (HResult)(error.Id | baseErrorCode);
            }

            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\lbwsinterop\lbwsinterop.cs ===
using System;
using System.Runtime.InteropServices;
using Microsoft.Webstore.WstClient;

using xonline.common.mgmt;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.service;

namespace xonline.server.stats.lbwsinterop
{
    [ComVisible(true)]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface ILbWsInterface
    {
        uint UpdateStatsForUser(int nTitleId, int nLbId, ulong ulPuid, byte [] arrData);

        uint RemoveStatsForUser(int nTitleId, int nLbId, ulong ulPuid);

        uint LoadStats(byte [] pTitleAndLbFormatted, int nPartitionId, out ILbWsReadLbRow iReadLbRow);

        uint RemoveLb(int nTitleId, int nLbId, int nPartitionId);

        uint GetUODBPhysicalPartitionCount(out int nPhysicalPartitionCount);

        uint GetUODBLogicalPartitionCount(out int nLogicalCount);
    }

    [ComVisible(true)]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface ILbWsReadLbRow
    {
        uint Read(out bool bRead);

        uint GetNextRow (  out int nTitleId,
                                out int nLbId,
                                out ulong ul64Puid,
                                [In, Out, MarshalAs(UnmanagedType.SafeArray)]byte [] arrRawStats, //we will parse it on the C++ side
                                out int nByteCount,
                                out double lastModified);      

        uint Close();
    }

    //Internal static native info exception extractor
    //We need a class instead of a method to have 2 different classes access it AND
    //to make sure that the HResult AND the exception string are retrieved together.
    internal class WebStoreExceptionExtractor
    {
        public WebStoreExceptionExtractor(Exception e)
        {
            _hr = HResult.E_FAIL;
            _message = "";
            //The InnerException is the one that we are interested in
            //Deep in the bowels of the Webstore abstracted XBox Live Platform
            //The WstException is wrapped with an XRLException
            if (e.InnerException != null)
            {
                //Now try a cast
                WstException ex = e.InnerException as WstException;
                if (ex != null)
                {
                    //Make absolutely sure that this is a webstore error
                    //Now LSG bug id 5801(for which this is a fix) explicitly
                    //talks about specific webstore errors available in the 
                    //internal webstore error number
                    WstError err = ex.Error;
                    if (err != null)
                    {
                        _hr = (uint)err.Number;
                        //Anytime we figure out how the webstore string methods work
                        //we'll include that here, for now _message uses the Exception string instead.
                        //Use:
                        //_message = WstException.GetErrorMessage(err.Number, "lbwsinterop", "", null);
                        //OR
                        //_message = String.Format("\r\n Internal Webstore Name: {0}, Message: {1} \r\n", 
                        //    err.ErrorName(err.Number), err.ErrorMessage(err.Number) );
                        //
                        _message = String.Format("\r\n Internal Webstore Error, Application: {0}, Message: {1} \r\n", 
                            ex.Application, ex.Message );
                    }
                }
            }
        }
        public readonly uint _hr;
        public readonly string _message;
    }
    
    [ComVisible(true)]
    public class CLbWsReadRow : ILbWsReadLbRow
    {
        const int DbMaxStatBlobSize       = 4000; //maximum stat blob size
        
        WSClient      _ws;
        WstDataReader _wstDataReader;
        
        public CLbWsReadRow()
        {
            _ws = null;
            _wstDataReader = null;
        }

        ~CLbWsReadRow()
        {
            try
            {
                Close();
            }
            catch
            {
                 // This is usually called during garbage collection. If a exception is thrown 
                 // here, there will be nothing to catch it. This is not a big deal for 
                 // ASP.NET applications but it's catastrophic for native applications.
            }
        }

        public uint Execute(byte [] pTitleAndLbFormatted, int nPartitionId)
        {   
            uint hr = HResult.S_OK;
            try
            {
                _ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                
                _ws.StoredProc    = "p_stats_lb_load";
                _ws.PartitionType = WstPartitionType.Physical;
                _ws.Partition     = nPartitionId;      
                
                _ws.AddParameter("@titleAndLbList", pTitleAndLbFormatted);

                _wstDataReader = _ws.Execute();     

                if (null == _wstDataReader)
                {
                    throw new Exception("Unable to call CLbWsReadRow::p_stats_lb_load; _wstDataReader is NULL");
                }
            }
            catch (Exception e)
            {
                WebStoreExceptionExtractor er = new WebStoreExceptionExtractor(e);
                hr = er._hr;

                Xom.NtEvent(XEvent.Id.LB_WS_INTEROP_UNABLE_TO_RETRIEVE_STAT, e,
                    "Exception during CLbWsReadRow::Execute nPartitionId {0}.\r\n{1}",
                    nPartitionId, (hr == HResult.E_FAIL ? string.Empty : er._message)
                );
            }
            return hr;
        }
        
        public uint Read(out bool bRet)
        {
            uint hr = HResult.S_OK;
            bool bStillHaveData = false;

            try
            {
                bStillHaveData = _wstDataReader.Read();
            }
            catch(Exception e)
            {
                WebStoreExceptionExtractor er = new WebStoreExceptionExtractor(e);
                hr = er._hr;

                Xom.NtEvent(XEvent.Id.LB_WS_INTEROP_UNABLE_TO_CALL_READ, e,
                    "Exception during CLbWsReadRow::Read.\r\n{0}", 
                    (hr == HResult.E_FAIL ? string.Empty : er._message)
                );
            }
            
            bRet = bStillHaveData;
            return hr;
        }

        public uint Close()
        {
            //attempt to close data reader
            try
            {
                if (null != _wstDataReader)
                {
                    _wstDataReader.Close();
                    _wstDataReader = null;
                }
            }
            catch
            {
            }

            //attempt to close connection
            try
            {
                if (null != _ws)
                {
                    _ws.Close();
                    _ws = null;
                }
            }
            catch
            {
                
            }

            return HResult.S_OK;
        }

        public uint GetNextRow (out int nTitleId,
                                     out int nLbId,
                                     out ulong ul64Puid,
                                     byte [] arrRawStats,
                                     out int nByteCount,
                                     out double lastModified)
        {   
            uint hr = HResult.S_OK;

            int nTitleIdIn  = 0;
            int nLbIdIn     = 0;
            ulong ul64PuidIn = 0;
            int nByteCountIn = 0;
            double lastModifiedIn = 0;

            try
            {
                nTitleIdIn       = _wstDataReader.GetInt32(0);
                nLbIdIn          = _wstDataReader.GetInt32(1);
                ul64PuidIn       = (ulong)_wstDataReader.GetInt64(2);
                nByteCountIn     = (int)_wstDataReader.GetBytes(3, 0, arrRawStats, 0, DbMaxStatBlobSize);
                DateTime dt      = _wstDataReader.GetDateTime(4);
                lastModifiedIn   = dt.ToOADate();
            }
            catch(Exception e)
            {
                WebStoreExceptionExtractor er = new WebStoreExceptionExtractor(e);
                hr = er._hr;

                Xom.NtEvent(XEvent.Id.LB_WS_INTEROP_UNABLE_TO_CALL_GETNEXTROW, e,
                    "Exception during CLbWsReadRow::GetNextRow.\r\n{0}", 
                    (hr == HResult.E_FAIL ? string.Empty : er._message)
                );
            }

            nTitleId = nTitleIdIn;
            nLbId    = nLbIdIn;
            ul64Puid = ul64PuidIn;
            nByteCount = nByteCountIn;
            lastModified = lastModifiedIn;
            
            return hr;
        }
    }
    
    
    // This class exists for COM interop - it implements the ILbWsInterface interface
    // which is exported by tlbexp and consumed by COM clients. These methods simply
    // call the static Config methods.

    // 
    // Since this object is used by c++ components, any exceptions thrown by common
    //  config are lost in the translation. To avoid this, the Interop methods all catch their
    //  own exceptions and log NT events
    [GuidAttribute("D4F69F7F-43F7-41e9-A58F-762B126511E6")] // fix the guid, so it doesn't change with each build
    [ClassInterfaceAttribute(ClassInterfaceType.None)]  // force clients to use the ILbWsInterface interface
    [ComVisible(true)]
    public class CLbWsInterop : ILbWsInterface
    {
        public CLbWsInterop()
        {
            //uncomment this during debugging both native and managed code
            //System.Diagnostics.Debug.Assert(false);
            XomLoggingControl.Init();
        }

        ~CLbWsInterop()
        {
            try
            {
                XomLoggingControl.Close();
            }
            catch(Exception)
            {
                // This is usually called during garbage collection. If a exception is thrown 
                // here, there will be nothing to catch it. This is not a big deal for 
                // ASP.NET applications but it's catastrophic for native applications.
            }
        }
        
        public uint UpdateStatsForUser(int nTitleId, int nLbId, ulong ulPuid, byte [] arrData)
        {
            uint hr = HResult.S_OK;
            try
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.StoredProc = "p_stats_update";
                    ws.Partition = WSClient.GetHashPartition(ulPuid, ConfigUtil.UodbWebstoreApp);
                    
                    ws.AddParameter("@i_title_id", nTitleId);
                    ws.AddParameter("@i_lb_id", nLbId);
                    ws.AddParameter("@bi_puid", ulPuid);
                    ws.AddParameter("@vb_data", arrData);
                    ws.AddParameter("@dt_last_update", DateTime.Now);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                    ws.ExecuteNonQuery();

                    hr = (uint)ws.GetIntParameter("@RETVAL");
                }
            }
            catch(Exception e)
            {
                WebStoreExceptionExtractor er = new WebStoreExceptionExtractor(e);
                hr = er._hr;

                Xom.NtEvent(XEvent.Id.LB_WS_INTEROP_UNABLE_TO_CALL_STATS_UPDATE, e,
                    "Exception during CLbWsInterop::UpdateStatsForUser, nTitleId {0}, nLbId 0x{1:x}, ulPuid {2}, arrData.Length {3}\r\n{4}",
                    (TitleId) (uint) nTitleId, nLbId, (Puid) ulPuid, arrData.Length, (hr == HResult.E_FAIL ? string.Empty : er._message)
                );
            }

            return hr;
        }

        public uint RemoveStatsForUser(int nTitleId, int nLbId, ulong ulPuid)
        {
            uint hr = HResult.S_OK;
            try
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.StoredProc = "p_stats_remove";
                    ws.Partition = WSClient.GetHashPartition(ulPuid, ConfigUtil.UodbWebstoreApp);
                    
                    ws.AddParameter("@i_title_id", nTitleId);
                    ws.AddParameter("@i_lb_id", nLbId);
                    ws.AddParameter("@bi_puid", ulPuid);
                    
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                    ws.ExecuteNonQuery();

                    hr = (uint)ws.GetIntParameter("@RETVAL");
                }
            }
            catch(Exception e)
            {
                WebStoreExceptionExtractor er = new WebStoreExceptionExtractor(e);
                hr = er._hr;

                Xom.NtEvent(XEvent.Id.LB_WS_INTEROP_UNABLE_TO_CALL_STATS_REMOVE, e, 
                    "Exception during CLbWsInterop::RemoveStatsForUser, nTitleId {0}, nLbId 0x{1:x}, ulPuid {2}\r\n{3}",
                    (TitleId) (uint) nTitleId, nLbId, ulPuid, (hr == HResult.E_FAIL ? string.Empty : er._message)
                );
            }

            return hr;
        }

        public uint LoadStats(byte [] pTitleAndLbFormatted, int nPartitionId, out ILbWsReadLbRow iLbWsReadLbRow)
        {
            uint hr = HResult.S_OK;
            CLbWsReadRow objReadRow = new CLbWsReadRow();

            try
            {
                objReadRow.Execute(pTitleAndLbFormatted, nPartitionId);
            }
            catch (Exception e)
            {
                WebStoreExceptionExtractor er = new WebStoreExceptionExtractor(e);
                hr = er._hr;
                
                Xom.NtEvent(XEvent.Id.LB_WS_INTEROP_UNABLE_TO_CALL_LOAD_STATS, e,
                    "Exception during CLbWsInterop::LoadStats, nPartitionId {0}\r\n{1}",
                    nPartitionId, (hr == HResult.E_FAIL ? string.Empty : er._message)
                );

                //need to log event
                throw;
            }

            iLbWsReadLbRow = (ILbWsReadLbRow)objReadRow;

            return hr;
        }

        //delete entire leaderboard data from a partition
        public uint RemoveLb(int nTitleId, int nLbId, int nPartitionId)
        {
            uint hr = HResult.S_OK;
            
            try
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.StoredProc = "p_stats_lb_remove";
                    ws.PartitionType = WstPartitionType.Physical;
                    ws.Partition = nPartitionId;
                    
                    ws.AddParameter("@i_title_id", nTitleId);
                    ws.AddParameter("@i_lb_id", nLbId);
                    
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                    ws.ExecuteNonQuery();

                    hr = (uint)ws.GetIntParameter("@RETVAL");
                    if (HResult.Failed(hr))
                    {
                        //BUG BUG - Need to do some error logging here
                    }
                }
            }
            catch(Exception e)
            {
                WebStoreExceptionExtractor er = new WebStoreExceptionExtractor(e);
                hr = er._hr;

                Xom.NtEvent(XEvent.Id.LB_WS_INTEROP_UNABLE_TO_CALL_REMOVE_LB, e,
                    "Exception during CLbWsInterop::RemoveLb, nTitleId {0}, nLbId 0x{1:x}\r\n {2}",
                    (TitleId) (uint) nTitleId, nLbId, (hr == HResult.E_FAIL ? string.Empty : er._message)
               );
            }

            return hr;
        }

        public uint GetUODBPhysicalPartitionCount(out int nPhysicalPartitionCount)
        {
            uint hr = HResult.S_OK;
            nPhysicalPartitionCount = 0;

            try
            {
                nPhysicalPartitionCount = WSClient.GetPhysicalPartitionCount(ConfigUtil.UodbWebstoreApp);
            }
            catch (Exception e)
            {
                WebStoreExceptionExtractor er = new WebStoreExceptionExtractor(e);
                hr = er._hr;

                Xom.NtEvent(XEvent.Id.LB_WS_INTEROP_UNABLE_TO_GET_PHYSICAL_PARTITION_COUNT, e,
                    "Exception during CLbWsInterop::GetUODBPhysicalPartitionCount\r\n{0}",
                    (hr == HResult.E_FAIL ? string.Empty : er._message)
                );
            }

            return hr;
        }

        public uint GetUODBLogicalPartitionCount(out int nLogicalPartitionCount)
        {
            uint hr = HResult.S_OK;
            nLogicalPartitionCount = 0;

            try
            {
                nLogicalPartitionCount = WSClient.GetPartitionCount(ConfigUtil.UodbWebstoreApp);
            }
            catch (Exception e)
            {
                WebStoreExceptionExtractor er = new WebStoreExceptionExtractor(e);
                hr = er._hr;

                Xom.NtEvent(XEvent.Id.LB_WS_INTEROP_UNABLE_TO_GET_LOGICAL_PARTITION_COUNT, e,
                    "Exception during CLbWsInterop::GetUODBPhysicalPartitionCount\r\n{0}",
                    (hr == HResult.E_FAIL ? string.Empty : er._message)
                );
            }

            return hr;
        }
        
    }
} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\profile\xrlReadSettings.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlReadSettings.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Web;
using Microsoft.Xbox.Diagnostics.Errors;
using Microsoft.Xbox.Profile.Contracts;
using Microsoft.Xbox.Profile.Service;
using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;
using xonline.server.profile.fd;
using xonline.server.profile.shim.fd;

namespace xonline.server.profile.fd
{
    public class XRLReadSettings : IHttpHandler
    {
        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        // ProcessRequest
        // Process http request
        public void ProcessRequest(HttpContext ctx)
        {
            ReadSettingsRequest req = new ReadSettingsRequest();
            ReadSettingsResponse resp = new ReadSettingsResponse();
            uint hr = HResult.E_FAIL;

            try
            {
                CallSource.Check(VirtualInterface.profilefd, VirtualInterface.profilefd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyFamilyTitleId(req.TitleId);
                SGInfo.VerifyUserId(req.UserId);

                ServiceAdapter.CreateClaimsFromSGInfo(SGInfo.Current, req.UserId);
                ISettingsServiceV1 svc = ProfileFrontEndApp.SettingsServiceInstance;
                ReadMultiSettingsResponseV1 svcResp = svc.ReadUserSettings(req.ForUserIds, req.SettingIds, req.TitleId);
                if (svcResp != null)
                {
                    if (svcResp != null && svcResp.Error != null)
                    {
                        hr = ServiceAdapter.ConvertUserSettingsErrorCodeTFSToXOnline(svcResp.Error);
                        throw new XRLExceptionWithoutEvent(hr,
                                "ISettingsServiceV1 API ReadUserSettings returned error :" + svcResp.Error.Id);
                    }
                    else
                    {
                        resp.Settings = ServiceAdapter.ConvertSettingsTFSToXOnline(svcResp.ProfileUsers);
                        resp.SettingsLen = (ushort)resp.Settings.Length;
                    }
                }

                hr = HResult.S_OK;
            }
            catch (ServiceExceptionWithEvent e)
            {
                hr = ServiceAdapter.ConvertUserSettingsErrorCodeTFSToXOnline(e.Error);
                throw new XRLException(hr, (XEvent.Id)e.Event.Id,
                        "SettingsServiceV1 threw exception: " + e);
            }
            catch (ServiceException e)
            {
                hr = ServiceAdapter.ConvertUserSettingsErrorCodeTFSToXOnline(e.Error);
                throw new XRLExceptionWithoutEvent(hr,
                        "SettingsServiceV1 threw exception: " + e);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch (XRLExceptionWithoutEvent e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"RUS|{0:x}|{1:x}|{2:x}|",
                                    hr,
                                    req.TitleId,
                                    req.UserId);

                if (req.ForUserIds != null)
                {
                    for (int i = 0; i < req.ForUserIds.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", req.ForUserIds[i]);

                        if (i != req.ForUserIds.Length - 1)
                            sb.Append(",");
                    }
                }

                sb.Append("|");

                if (req.SettingIds != null)
                {
                    for (int i = 0; i < req.SettingIds.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", req.SettingIds[i]);

                        if (i != req.SettingIds.Length - 1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.profilelog, sb.ToString());
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Profile, hr, resp);
        }


    }// class XRLReadSettings
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\profile\xrlUploadConsoleAuditList.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlUploadConsoleAuditList.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
using System.Configuration;

using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;


namespace xonline.server.profile.fd
{
    public class XRLUploadConsoleAuditList : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            UploadConsoleListRequest req = new UploadConsoleListRequest();
            uint hr = HResult.E_FAIL;
            string vi = VirtualInterface.xstatsfd;

            try
            {
                vi = CallSource.Check(VirtualInterface.profilefd, VirtualInterface.profilefd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyUserId(req.UserId);

                UploadConsoleAuditList(
                            req.UserId,
                            req.UploadingConsoleId,
                            req.SigningConsoleId,
                            req.ConsoleIdList);

                hr = HResult.S_OK;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"CAL|{0:x}|{1:x}|{2:x}|{3:x}|",
                    hr,
                    req.UserId,
                    ConsoleIdData.GetDecimalValue(req.UploadingConsoleId.ConsoleId),
                    ConsoleIdData.GetDecimalValue(req.SigningConsoleId.ConsoleId));

                if (req.ConsoleIdList != null)
                {
                    for (int i = 0; i < req.ConsoleIdList.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", ConsoleIdData.GetDecimalValue(req.ConsoleIdList[i].ConsoleId));

                        if (i != req.ConsoleIdList.Length - 1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.statslog, sb.ToString());
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Stats, hr);
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

        public static void UploadConsoleAuditList(
                ulong userId,
                ConsoleIdData uploadingConsoleId,
                ConsoleIdData signingConsoleId,
                ConsoleIdData[] consoleIdList)
        {
            WSClient ws;

            if (consoleIdList.Length == 0)
            {
                // The console that signed the console list should always be in the list.
                throw new XRLException(HResult.XONLINE_E_STAT_CONSOLE_LIST_EMPTY, XEvent.Id.CONSOLE_AUDIT_LIST_EMPTY,
                    String.Format("Console history list uploaded by console {0:x}, signed by console 0x{1:x}, for user 0x{2:x} is empty", SGInfo.Current.MachineId, signingConsoleId, userId));
            }
            else
            {
                int platformType = SGInfo.Current.GetPlatformType();

                switch (platformType)
                {
                    case XOn.XPLT_XBOX1:
                        // Console ids shouldn't be uploaded from XBox 1
                        throw new XRLException(HResult.XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED, XEvent.Id.CONSOLE_AUDIT_LIST_NOT_SUPPORTED,
                            String.Format("Console history list cannot be written from Xbox 1 for user 0x{0:x}", userId));
                    case XOn.XPLT_XBOX360:
                        break;
                    case XOn.XPLT_PC:
                        // Console ids shouldn't be uploaded from PC
                        throw new XRLException(HResult.XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED, XEvent.Id.CONSOLE_AUDIT_LIST_NOT_SUPPORTED,
                            String.Format("Console history list cannot be written from PC for user 0x{0:x}", userId));
                    case XOn.XPLT_INTERNAL:
                    default:
                        // Internal Request
                        throw new XRLException(HResult.XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED, XEvent.Id.CONSOLE_AUDIT_LIST_NOT_SUPPORTED,
                            String.Format("Console history list cannot be written from unknown platform {0} for user 0x{1:x}", platformType, userId));
                }
            }

            string webstoreInstance = ConfigurationManager.AppSettings["WebstoreName"];
        
            using (ws = new WSClient(webstoreInstance, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_stats_upload_console_audit_list";
                ws.Partition = ws.CalcPartition(userId);

                ws.AddParameter("@bi_user_puid", userId);
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.AddParameter("@bi_uploading_machine_console_id", ConsoleIdData.GetDecimalValue(uploadingConsoleId.ConsoleId));
                ws.AddParameter("@bi_uploading_machine_puid", SGInfo.Current.MachineId);
                ws.AddParameter("@bi_signing_machine_console_id", ConsoleIdData.GetDecimalValue(signingConsoleId.ConsoleId));

                // Add the console list using a table-valued parameter
                DataTable dtConsoleIdList = new DataTable();
                dtConsoleIdList.Columns.Add("bi_console_id", typeof(long));
                dtConsoleIdList.Columns.Add("i_ordinal", typeof(byte));
                foreach (ConsoleIdData consoleId in consoleIdList)
                {
                    dtConsoleIdList.Rows.Add(ConsoleIdData.GetDecimalValue(consoleId.ConsoleId), dtConsoleIdList.Rows.Count);
                }
                ws.Parameters.AddWithValue("@console_audit_list", dtConsoleIdList);

                ws.ExecuteNonQuery();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\profile\xrlSyncSettings.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncSettings.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Text;
using System.Web;
using Microsoft.Xbox.Profile.Contracts;
using Microsoft.Xbox.Profile.Service;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.profile.fd;
using xonline.server.profile.shim.fd;
using Microsoft.Xbox.Diagnostics.Errors;

namespace xonline.server.profile.fd
{
    public class XRLSyncSettings : IHttpHandler
    {
        public void ProcessRequest(HttpContext ctx)
        {
            SyncSettingsRequest req = new SyncSettingsRequest();
            SyncSettingsResponse resp = new SyncSettingsResponse();
            uint hr = HResult.E_FAIL;

            try
            {
                CallSource.Check(VirtualInterface.profilefd, VirtualInterface.profilefd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyUserId(req.UserId);

                uint titleId = req.TitleId;
                if (titleId == XOn.WEB_TITLE_ID)
                {
                    // web should really be treated like the dash when writing..
                    titleId = XOn.XENON_DASH_TITLE_ID;
                }

                ServiceAdapter.CreateClaimsFromSGInfo(SGInfo.Current, req.UserId);

                if (SGInfo.IsFromLiveCache())
                {
                    // HACK: Livecache version is set to XOn.MinDateTime, which will cause writes to fail because the version is prior to any
                    // service version we would already have.  Really, Livecache is only trying to write, so convert the request into a "write" only
                    // by changing the previous sync date to the current time.  This means that the api will likely return an empty response.
                    req.Version = DateTime.UtcNow;
                }

                if (req.StartinIndex > 0)
                {
                    req.StartinIndex--;
                }

                ISettingsServiceV1 svc = ProfileFrontEndApp.SettingsServiceInstance;
                SyncSettingsResponseV1 svcResponse = svc.SyncUserSettings(
                    req.UserId,
                    ServiceAdapter.ConvertSettingsXOnlineToTFS(req.Settings, titleId),
                    titleId,
                    req.Version,
                    req.StartinIndex,
                    XOn.XONLINE_MAX_SETTING_RESPONSE_COUNT
                    );

                if (svcResponse != null)
                {
                    if (svcResponse.Error != null)
                    {
                        hr = ServiceAdapter.ConvertUserSettingsErrorCodeTFSToXOnline(svcResponse.Error);
                        throw new XRLExceptionWithoutEvent(hr,
                                "ISettingsServiceV1 API SyncUserSettings returned error :" + svcResponse.Error.Id);
                    }
                    else
                    {
                        resp.Version = svcResponse.Version;
                        resp.TotalSettings = (ushort)(svcResponse.PagingInfo.TotalRecords > XOn.XONLINE_MAX_SETTING_RESPONSE_COUNT ? XOn.XONLINE_MAX_SETTING_RESPONSE_COUNT : svcResponse.PagingInfo.TotalRecords);
                        resp.Settings = ServiceAdapter.ConvertSettingsTFSToXOnline(svcResponse.UserSettings, req.UserId);
                        resp.SettingsLen = (ushort)svcResponse.UserSettings.Length;
                    }
                }

                hr = HResult.S_OK;
            }
            catch (ServiceExceptionWithEvent e)
            {
                hr = ServiceAdapter.ConvertUserSettingsErrorCodeTFSToXOnline(e.Error);
                throw new XRLException(hr, (XEvent.Id)e.Event.Id,
                        "SettingsServiceV1 threw exception: " + e);
            }
            catch (ServiceException e)
            {
                hr = ServiceAdapter.ConvertUserSettingsErrorCodeTFSToXOnline(e.Error);
                throw new XRLExceptionWithoutEvent(hr,
                        "SettingsServiceV1 threw exception: " + e);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch (XRLExceptionWithoutEvent e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"SUS|{0:x}|{1:x}|{2:x}|{3}|{4}|",
                    hr,
                    req.TitleId,
                    req.UserId,
                    req.Version,
                    resp.Version);

                if (req.Settings != null)
                {
                    for (int i = 0; i < req.Settings.Length; i++)
                    {
                        if (req.Settings[i] == null)
                            sb.Append("null");
                        else
                            sb.AppendFormat("{0:x}", req.Settings[i].SettingId);

                        if (i != req.Settings.Length - 1)
                            sb.Append(",");
                    }
                }

                sb.Append("|");

                if (resp.Settings != null)
                {
                    for (int i = 0; i < resp.Settings.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", resp.Settings[i].SettingId);

                        if (i != resp.Settings.Length - 1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.profilelog, sb.ToString());
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Profile, hr, resp);
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\progress\progressfeapp.cs ===
/*
 * Copyright (c) 2011 Microsoft Corporation
 * 
 * Progress Front-Door (progressshimfd)
 * 
 * progressfeapp.cs
 * 
 * Progress shim front-end application class
 * 
 * */
using System;
using System.Reflection;
using System.Diagnostics;
using System.Web;
using System.Web.Routing;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.common.service;

using Microsoft.Xbox.Diagnostics;
using Microsoft.Xbox.Progress.Service.Achievements;
using Microsoft.Xbox.Progress.Service.AvatarAwards;
using Microsoft.Xbox.Progress.Service.Interfaces.Achievements;
using Microsoft.Xbox.Progress.Service.Interfaces.AvatarAwards;
using Microsoft.Xbox.Progress.Service.Interfaces.UserTitles;
using Microsoft.Xbox.Progress.Service.UserTitles;

[assembly: XomIisNet4InstallerAttribute(Interface.progressfd)]
[assembly: XomIisNet4InstallerAttribute(Interface.progressfd_int)]
[assembly: ConfigAttribute(Component.progressshimfd)]
[assembly: XomAreaDefinition(XomAreaName.progresslog)]

namespace xonline.server.progress.shim.fd
{
    [Discovery("ProgressShim", "1")]
    public class ProgressFrontEndApp : FrontEndApp
    {
        private static IUserTitleServiceV1 userTitleService = null;
        private static IAchievementsServiceV1 achievementService = null;
        private static IAvatarAwardsServiceV1 avatarAwardService = null;

        public static IAchievementsServiceV1 AchievementServiceInstance
        {
            get { return achievementService; }
        }

        public static IUserTitleServiceV1 UserTitleServiceInstance
        {
            get { return userTitleService; }
        }

        public static IAvatarAwardsServiceV1 AvatarAwardServiceInstance
        {
            get { return avatarAwardService; }
        }

        public static void ResolveAllDependencies()
        {
            userTitleService = new UserTitleServiceV1();
            achievementService = new AchievementsServiceV1();
            avatarAwardService = new AvatarAwardsServiceV1();
        }

        // OnApplicationStart
        // Gets called by FEApp during application start up
        protected override void OnApplicationStart()
        {            
            Microsoft.Xbox.Unity.Resolver.LoadConfiguration();
            Microsoft.Xbox.Progress.Service.StaticGlobals.ResolveAllDependencies();
            ResolveAllDependencies();
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\profile\xrlValidateAvatarManifest.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlValidateAvatarManifest.cs
//
////////////////////////////////////////////////////////////////////

using System.Text;
using System.Web;
using Microsoft.Xbox.Diagnostics.Errors;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.profile.shim.fd;
using Microsoft.Xbox.Profile.Service;
using Microsoft.Xbox.Profile.Contracts;


namespace xonline.server.profile.fd
{
    public class XRLValidateAvatarManifest : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest();
            ValidateAvatarManifestResponse resp = new ValidateAvatarManifestResponse();
            uint hr = HResult.E_FAIL;

            try
            {
                CallSource.Check(VirtualInterface.profilefd, VirtualInterface.profilefd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyUserId(req.UserId);

                ServiceAdapter.CreateClaimsFromSGInfo(SGInfo.Current, req.UserId);
                UserSettingV1 setting = new UserSettingV1();
                setting.Value = req.AvatarManifest;
                ISettingsServiceV1 svc = ProfileFrontEndApp.SettingsServiceInstance;
                ProfileServiceResponse svcResp = svc.ValidateAvatarManifest(req.UserId, setting);

                if (svcResp != null)
                {
                    if (svcResp.Error != null)
                    {
                        hr = ServiceAdapter.ConvertUserSettingsErrorCodeTFSToXOnline(svcResp.Error);
                        throw new XRLExceptionWithoutEvent(hr,
                                "ISettingsServiceV1 API ValidateAvatarManifest returned error :" + svcResp.Error.Id);
                    }
                    else
                    {
                        if (svcResp.StatusCode == System.Net.HttpStatusCode.OK)
                        {
                            resp.ValidationResult = 1;
                        }
                        else
                        {
                            resp.ValidationResult = 0;
                        }
                    }
                }

                hr = HResult.S_OK;
            }
            catch (ServiceExceptionWithEvent e)
            {
                hr = ServiceAdapter.ConvertUserSettingsErrorCodeTFSToXOnline(e.Error);
                throw new XRLException(hr, (XEvent.Id)e.Event.Id,
                        "SettingsServiceV1 threw exception: " + e);
            }
            catch (ServiceException e)
            {
                hr = ServiceAdapter.ConvertUserSettingsErrorCodeTFSToXOnline(e.Error);
                throw new XRLExceptionWithoutEvent(hr,
                        "SettingsServiceV1 threw exception: " + e);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch (XRLExceptionWithoutEvent e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"VAM|{0:x}|{1:x}|{2:x}|{3}",
                    hr,
                    req.UserId,
                    req.ValidationFlags,
                    resp.ValidationResult);

                Xom.Log(XomAreaName.profilelog, sb.ToString());
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Progress, hr, resp);

        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\progress\ServiceAdapter.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlAchievementClear.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Text;
using System.Threading;
using xonline.common.service;
using xonline.common.protocol;

using Microsoft.IdentityModel.Claims;

using Microsoft.Xbox.Progress.Contracts;
using Microsoft.Xbox.Progress.Service;
using Microsoft.Xbox.Diagnostics.Errors;
using Microsoft.Xbox.Progress.Errors;

using Microsoft.XboxLive.Auth.Claims;
using Microsoft.XboxLive.Auth;

namespace xonline.server.progress.fd
{
    public class ServiceAdapter
    {
        private const string SLSInternalClaimType = "http://services.xboxlive.com/sls/internalServiceClaim";
        private const string SLSInternalClaimValueType = "string";
        private const uint baseErrorCode = 0x83840000;

        public static int GetXPLTDeviceType()
        {
            int deviceType;
            if (SGInfo.IsActiveAuth())
            {
                deviceType = XOn.XPLT_WEB;
            }
            else
            {
                deviceType = SGInfo.Current.GetPlatformType();

                if (SGInfo.IsFromLiveCache())
                {
                    string OnBehalfHeader = HttpContext.Current.Request.Headers[XHttpHdr.XPLT_I];

                    if (!String.IsNullOrEmpty(OnBehalfHeader))
                    {
                        deviceType = int.Parse(OnBehalfHeader);
                    }
                }
            }

            return deviceType;
        }

        public static string GetDeviceTypeString()
        {
            int deviceType = GetXPLTDeviceType();
            string deviceTypeStr;

            switch (deviceType)
            {
                case XOn.XPLT_XBOX360:
                    deviceTypeStr = AuthDeviceTypes.Xbox360;
                    break;

                case XOn.XPLT_PC:
                    deviceTypeStr = AuthDeviceTypes.PC;
                    break;

                case XOn.XPLT_MOBILE:
                    deviceTypeStr = AuthDeviceTypes.WindowsPhone7;
                    break;

                default:
                    deviceTypeStr = AuthDeviceTypes.Web;
                    break;
            }

            return deviceTypeStr;
        }

        public static void CreateClaimsFromSGInfo(SGInfo sginfo, Puid xuid)
        {
            string issuer = new AuthHelper().Issuer; // "xsts.xboxlive.com"; // "sginfo";  // @@@???
            //string callingService = "ProgressShim";
            List<IClaimsIdentity> identities = new List<IClaimsIdentity>();

            // ??? 1 identity per user plus a machine identity? Just a single identity for all?
            // But then how to represent users?

            for (int i = 0; i < sginfo.LogonUsers.Length; i++)
            {
                XUIDAndTrust xuidTrust = sginfo.LogonUsers[sginfo.LogonUsers.Length - i - 1];
                if (
                   (0 != xuidTrust.qwUserID && !xuidTrust.IsGuest()) &&
                   (0 == xuid || xuid == xuidTrust.qwUserID)  // Non zero xuid means we only want that one user
                   )
                {
                    ClaimsIdentity userIdentity = new ClaimsIdentity(
                        "sginfouser",
                        AuthClaimTypes.Xuid,  // name claim type
                        null);
                    identities.Add(userIdentity);

                    userIdentity.Claims.Add(new Claim(AuthClaimTypes.Xuid,
                        xuidTrust.qwUserID.ToString(),
                        AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid],
                        issuer));

                    byte[] privileges = sginfo.GetUserPrivileges(xuidTrust.qwUserID);
                    string privilegeString = privileges.Aggregate(
                        new StringBuilder(),
                        (sb, p) => sb.Append(p + " "),
                        sb => sb.Length == 0 ? String.Empty : sb.ToString(0, sb.Length - 1));
                    userIdentity.Claims.Add(new Claim(AuthClaimTypes.Privileges,
                        privilegeString,
                        AuthClaimTypes.ValueTypes[AuthClaimTypes.Privileges],
                        issuer));

                    /*
                    userIdentity.Claims.Add(new Claim(
                        SLSInternalClaimType,
                        callingService,
                        SLSInternalClaimValueType,
                        callingService));
                     */
                }
            }

            ClaimsIdentity machineIdentity = new ClaimsIdentity(
                "sginfomachine",
                AuthClaimTypes.DeviceId,  // name claim type
                null);
            identities.Add(machineIdentity);

            machineIdentity.Claims.Add(new Claim(AuthClaimTypes.DeviceId,
                sginfo.MachineId.ToString("X"),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceId],
                issuer));
            machineIdentity.Claims.Add(new Claim(AuthClaimTypes.DeviceType,
                GetDeviceTypeString(),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceType], // @@@ Number? Name?
                issuer));
            machineIdentity.Claims.Add(new Claim(AuthClaimTypes.TitleId,
                sginfo.TitleId.ToString(),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.TitleId],
                issuer));

            Thread.CurrentPrincipal = new ClaimsPrincipal(identities);
        }

        public static AchievementV1[] ConvertAchievementXOnlineToTFS(Achievement[] achievements, uint titleId)
        {
            if (achievements == null)
            {
                return null;
            }

            AchievementV1[] achs = new AchievementV1[achievements.Length];
            for (int i = 0; i < achievements.Length; i++)
            {
                achs[i] = ConvertAchievementXOnlineToTFS(achievements[i], titleId);
            }

            return achs;
        }

        public static Achievement[] ConvertAchievementTFSToXOnline(AchievementV1[] achievements)
        {
            if (achievements == null)
            {
                return null;
            }

            Achievement[] achs = new Achievement[achievements.Length];
            for (int i = 0; i < achievements.Length; i++)
            {
                achs[i] = ConvertAchievementTFSToXOnline(achievements[i]);
            }

            return achs;
        }

        public static AchievementV1 ConvertAchievementXOnlineToTFS(Achievement achievement, uint titleId)
        {
            if (achievement == null)
            {
                return null;
            }

            AchievementV1 ach = new AchievementV1();
            ach.Id = achievement.AchievementId;
            ach.TitleId = titleId;
            ach.Name = achievement.Title;
            ach.TimeUnlocked = achievement.Achieved;
            ach.Sequence = achievement.Sequence;
            ach.Flags = achievement.Flags;

            if ((achievement.Flags & XOn.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE) != 0)
            {
                ach.UnlockedOnline = true;
            }

            ach.Platform = (byte)GetTFSXPlatform(achievement.Flags);

            ach.Gamerscore = achievement.Cred;
            ach.ImageId = achievement.ImageId;
            ach.Description = achievement.Description;
            ach.LockedDescription = achievement.HowTo;
            ach.AchievementType = achievement.Type;

            return ach;
        }

        public static Achievement ConvertAchievementTFSToXOnline(AchievementV1 achievement)
        {
            Achievement ach = new Achievement();
            ach.AchievementId = achievement.Id;
            ach.Type = achievement.AchievementType;
            ach.ImageId = achievement.ImageId;
            ach.Achieved = achievement.TimeUnlocked;
            ach.Sequence = achievement.Sequence;
            ach.Flags = (achievement.Flags >> 3) << 3;
            ach.Cred = achievement.Gamerscore;
            ach.Description = achievement.Description;
            ach.DescriptionLen = (byte)(achievement.Description != null ? achievement.Description.Length : 0);

            ach.HowTo = achievement.LockedDescription;
            ach.HowToLen = (byte)(achievement.LockedDescription != null ? achievement.LockedDescription.Length : 0);

            ach.Title = achievement.Name;
            ach.TitleLen = (byte)(achievement.Name != null ? achievement.Name.Length : 0);

            return ach;
        }

        public static UserTitle[] ConvertUserTitlesTFSToXOnline(UserTitleV1[] titles)
        {
            if (titles == null)
            {
                return null;
            }

            UserTitle[] userTitles = new UserTitle[titles.Length];
            for (int i = 0; i < titles.Length; i++)
            {
                userTitles[i] = ConvertUserTitleTFSToXOnline(titles[i]);
            }

            return userTitles;
        }

        public static UserTitle ConvertUserTitleTFSToXOnline(UserTitleV1 title)
        {
            UserTitle userTitle = new UserTitle();
            userTitle.NumAchievements = title.CurrentAchievements;
            userTitle.NumCreds = title.CurrentGamerscore;
            userTitle.LastPlayed = title.LastPlayed;
            userTitle.TitleName = title.Name;
            userTitle.TitleNameLen = (byte)(userTitle.TitleName != null ? userTitle.TitleName.Length : 0);
            userTitle.Sequence = title.Sequence;
            userTitle.TitleId = title.TitleId;
            userTitle.TotalAchievements = title.TotalAchievements;
            userTitle.TotalCred = title.TotalGamerscore;
            userTitle.HasExtendedData = 1;
            userTitle.TitleType = (byte)title.TitleType;

            for (int iPlatform = 0; iPlatform < title.Platforms.Length; iPlatform++)
            {
                userTitle.SetPlatformFlag(title.Platforms[iPlatform], true);
            }

            return userTitle;
        }

        public static UserTitleV1[] ConvertUserTitleXOnlineToTFS(UserTitle[] titles)
        {
            if (titles == null)
            {
                return null;
            }

            UserTitleV1[] userTitles = new UserTitleV1[titles.Length];
            for (int i = 0; i < titles.Length; i++)
            {
                userTitles[i] = ConvertUserTitleXOnlineToTFS(titles[i]);
            }

            return userTitles;
        }

        public static UserTitleV1 ConvertUserTitleXOnlineToTFS(UserTitle title)
        {
            UserTitleV1 userTitle = new UserTitleV1();
            userTitle.CurrentAchievements = title.NumAchievements;
            userTitle.CurrentGamerscore = title.NumCreds;
            userTitle.LastPlayed = title.LastPlayed;
            userTitle.Name = title.TitleName;
            userTitle.Sequence = title.Sequence;
            userTitle.TitleId = title.TitleId;
            userTitle.TotalAchievements = title.TotalAchievements;
            userTitle.TotalGamerscore = title.TotalCred;
            return userTitle;
        }

        public static AvatarAwardV1[] ConvertAvatarAwardXOnlineToTFS(AvatarAsset[] assets, uint titleId)
        {
            if (assets == null)
            {
                return null;
            }

            AvatarAwardV1[] awards = new AvatarAwardV1[assets.Length];
            for (int i = 0; i < assets.Length; i++)
            {
                awards[i] = ConvertAvatarAwardXOnlineToTFS(assets[i], titleId);
            }

            return awards;
        }

        public static AvatarAsset[] ConvertAvatarAwardTFSToXOnline(AvatarAwardV1[] assets)
        {
            if (assets == null)
            {
                return null;
            }

            AvatarAsset[] awards = new AvatarAsset[assets.Length];
            for (int i = 0; i < assets.Length; i++)
            {
                awards[i] = ConvertAvatarAwardTFSToXOnline(assets[i]);
            }

            return awards;
        }

        public static AvatarAwardV1 ConvertAvatarAwardXOnlineToTFS(AvatarAsset asset, uint titleId)
        {
            if (asset == null)
            {
                return null;
            }

            AvatarAwardV1 award = new AvatarAwardV1();
            award.AvatarAssetOrdinal = asset.AvatarAssetOrdinal;
            award.TimeUnlocked = asset.Awarded;
            award.BodyTypeMask = asset.BodyTypeMask;
            award.Sequence = asset.Sequence;
            award.Flags = asset.Flags;
            award.TitleId = titleId;

            if ((asset.Flags & XOn.XAVATAR_DETAILS_ACHIEVED_ONLINE) != 0)
            {
                award.UnlockedOnline = true;
            }

            award.Platform = (byte)GetTFSXPlatform(asset.Flags);
            award.AssetId = new Guid(asset.AvatarAssetId);
            award.ImageId = asset.ImageId;
            award.Name = asset.Title;
            award.Description = asset.Description;
            award.LockedDescription = asset.HowTo;
            award.BodyComponent = asset.BodyComponent;
            award.SubCategory = asset.SubCategory;

            return award;
        }

        public static AvatarAsset ConvertAvatarAwardTFSToXOnline(AvatarAwardV1 award)
        {
            AvatarAsset asset = new AvatarAsset();
            asset.AvatarAssetOrdinal = award.AvatarAssetOrdinal;
            asset.Awarded = award.TimeUnlocked;
            //asset.TitleId = award.TitleId;
            asset.BodyTypeMask = award.BodyTypeMask;
            asset.Sequence = award.Sequence;
            asset.Flags = award.Flags;
            //asset.UnlockedOnline = award.UnlockedOnline;
            //asset.IsSecret = award.IsSecret;
            asset.AvatarAssetId = award.AssetId.ToByteArray();
            asset.ImageId = award.ImageId;
            asset.Title = award.Name;
            asset.TitleLen = (byte)(asset.Title != null ? asset.Title.Length : 0);

            asset.Description = award.Description;
            asset.DescriptionLen = (byte)(asset.Description != null ? asset.Description.Length : 0);

            asset.HowTo = award.LockedDescription;
            asset.HowToLen = (byte)(asset.HowTo != null ? asset.HowTo.Length : 0);

            //asset.Platform = award.Platform;
            asset.BodyComponent = award.BodyComponent;
            asset.SubCategory = award.SubCategory;
            return asset;
        }

        private static XPlatform GetTFSXPlatform(int flags)
        {
            int deviceType = GetXPLTDeviceType();
            XPlatform platform = 0;
            switch (deviceType)
            {
                case XOn.XPLT_XBOX360:
                    platform = XPlatform.Xbox360;
                    break;
                case XOn.XPLT_PC:
                    platform = XPlatform.PC;
                    break;
                case XOn.XPLT_MOBILE:
                    platform = XPlatform.Mobile;
                    break;
                default:
                    platform = XPlatform.WebGames;
                    break;
            }

            return platform;
        }

        public static HResult ConvertTitleErrorCodeTFSToXOnline(ServiceError error)
        {
            HResult hr = HResult.E_FAIL;
            if (error != null)
            {
                if (error.Id == ProgressErrors.InvalidTitleError.Id)
                {
                    hr = HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD;
                }
                else if (error.Id == ProgressErrors.UserNotFound.Id)
                {
                    hr = HResult.XONLINE_E_STAT_USER_NOT_FOUND;
                }
                else if (error.Id == ProgressErrors.PrivilegesDeniedError.Id)
                {
                    hr = HResult.XONLINE_E_STAT_PERMISSION_DENIED;
                }
                else if (error.Id == ProgressErrors.PrivacyCheckRejected.Id)
                {
                    hr = HResult.XONLINE_E_STAT_PERMISSION_DENIED;
                }
                else
                {
                    hr = (HResult)(error.Id | baseErrorCode);
                }
            }

            return hr;
        }

        public static HResult ConvertAvatarErrorCodeTFSToXOnline(ServiceError error)
        {
            HResult hr = HResult.E_FAIL;
            if (error != null)
            {
                if (error.Id == ProgressErrors.InvalidPlatformType.Id)
                {
                    hr = HResult.XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED;
                }
                else if (error.Id == ProgressErrors.InvalidTitleError.Id)
                {
                    hr = HResult.E_FAIL;
                }
                else if (error.Id == ProgressErrors.PrivilegesDeniedError.Id)
                {
                    hr = HResult.XONLINE_E_STAT_PERMISSION_DENIED;
                }
                else if (error.Id == ProgressErrors.PrivacyCheckRejected.Id)
                {
                    hr = HResult.XONLINE_E_STAT_PERMISSION_DENIED;
                }
                else
                {
                    hr = (HResult)(error.Id | baseErrorCode);
                }
            }

            return hr;
        }

        public static HResult ConvertAchievementErrorCodeTFSToXOnline(ServiceError error)
        {
            HResult hr = HResult.E_FAIL;
            if (error != null)
            {
                if (error.Id == ProgressErrors.InvalidPlatformType.Id)
                {
                    hr = HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED;
                }
                else if (error.Id == ProgressErrors.InvalidTitleError.Id)
                {
                    hr = HResult.E_FAIL;
                }
                else if (error.Id == ProgressErrors.PrivilegesDeniedError.Id)
                {
                    hr = HResult.XONLINE_E_STAT_PERMISSION_DENIED;
                }
                else if (error.Id == ProgressErrors.PrivacyCheckRejected.Id)
                {
                    hr = HResult.XONLINE_E_STAT_PERMISSION_DENIED;
                }
                else 
                {
                    hr = (HResult)(error.Id | baseErrorCode);
                }
            }

            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\progress\xrlAchievementEnum.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlAchievementEnum.cs
//
////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.Text;
using System.Web;
using Microsoft.Xbox.Diagnostics.Errors;
using Microsoft.Xbox.Progress.Contracts;
using Microsoft.Xbox.Progress.Service.Achievements;
using Microsoft.Xbox.Progress.Service.Interfaces.Achievements;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.progress.shim.fd;

namespace xonline.server.progress.fd
{
    public class XRLAchievementEnum : IHttpHandler
    {
        /// <summary>
        /// IsReusable
        /// </summary>
        /// <returns>True/False</retruns>
        /// <remarks>
        /// Returns if this object can be reused. Since the object doesn't hold
        /// any state, this method always returns true.
        /// </remarks>
        public bool IsReusable
        {
            get { return true; }
        }

        /// <summary>
        /// ProcessRequest
        /// </summary>
        /// <param name="ctx">HTTP input context</param>
        /// <remarks>
        /// Process incoming Achievement enum request.
        /// </remarks>
        public void ProcessRequest(HttpContext ctx)
        {
            uint hr = HResult.E_FAIL;

            AchievementEnumRequest req = new AchievementEnumRequest();
            AchievementEnumResponse resp = new AchievementEnumResponse();

            string[] locales;

            try
            {
                CallSource.Check(VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyUserId(req.Puid);

                ServiceAdapter.CreateClaimsFromSGInfo(SGInfo.Current, req.Puid);

                if (req.LocaleId == 0)
                {
                    locales = SGInfo.GetUserLocaleList(req.Puid, false);
                }
                else
                {
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                IAchievementsServiceV1 svc = ProgressFrontEndApp.AchievementServiceInstance;

                ReadAchievementsResponseV1 possible = svc.ReadPossibleAchievements(req.ForPuid,
                    locales,
                    req.TitleId,
                    0,
                    System.Int32.MaxValue
                    );

                if (possible != null && possible.Error != null)
                {
                    hr = ServiceAdapter.ConvertAchievementErrorCodeTFSToXOnline(possible.Error);
                    throw new XRLExceptionWithoutEvent(hr,
                            "AchievementsServiceV1 API ReadPossibleAchievements returned error :" + possible.Error.Id);
                }

                ReadAchievementsResponseV1 rep = svc.ReadUnlockedAchievements(req.ForPuid,
                    locales,
                    req.TitleId,
                    0,
                    System.Int32.MaxValue
                    );

                if (rep != null && rep.Error != null)
                {
                    hr = ServiceAdapter.ConvertAchievementErrorCodeTFSToXOnline(rep.Error);
                    throw new XRLExceptionWithoutEvent(hr,
                            "AchievementsServiceV1 API ReadUnlockedAchievements returned error :" + rep.Error.Id);
                }

                if (rep != null && possible != null)
                {
                    Dictionary<uint, AchievementV1> achievedIds = new Dictionary<uint, AchievementV1>();
                    List<Achievement> achievements = new List<Achievement>();

                    for (int i = 0; i < rep.Achievements.Length; i++)
                    {
                        if (achievements.Count >= req.MaxAchievements)
                            break;

                        achievedIds[rep.Achievements[i].Id] = rep.Achievements[i];

                        if ((rep.Achievements[i].Flags & XOn.XACHIEVEMENT_DETAILS_NOT_ACHIEVABLE) != 0)
                            continue;

                        if (i < req.StartingIndex)
                            continue;

                        Achievement ach = ServiceAdapter.ConvertAchievementTFSToXOnline(rep.Achievements[i]);
                        ach.Flags |= !rep.Achievements[i].IsSecret ? (int)XOn.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED : 0;
                        achievements.Add(ach);
                    }

                    int count = -1;
                    for (int i = 0; i < possible.Achievements.Length; i++)
                    {
                        if (!achievedIds.ContainsKey(possible.Achievements[i].Id) ||
                                (achievedIds.ContainsKey(possible.Achievements[i].Id) &&
                                    (achievedIds[possible.Achievements[i].Id].Flags & XOn.XACHIEVEMENT_DETAILS_NOT_ACHIEVABLE) != 0))
                        {
                            if (achievements.Count >= req.MaxAchievements)
                                break;

                            count++;
                            if (count < (req.StartingIndex - rep.Achievements.Length))
                                continue;

                            Achievement ach = ServiceAdapter.ConvertAchievementTFSToXOnline(possible.Achievements[i]);
                            if (achievedIds.ContainsKey(possible.Achievements[i].Id))
                            {
                                ach.Flags = (int)XOn.XACHIEVEMENT_DETAILS_NOT_ACHIEVABLE;
                            }

                            ach.Flags |= !possible.Achievements[i].IsSecret ? (int)XOn.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED : 0;

                            achievements.Add(ach);
                        }
                    }

                    resp.Achievements = achievements.ToArray();
                    resp.AchievementsCount = (ushort)resp.Achievements.Length;
                }

                hr = HResult.S_OK;
            }
            catch (ServiceExceptionWithEvent e)
            {
                hr = ServiceAdapter.ConvertAchievementErrorCodeTFSToXOnline(e.Error);
                throw new XRLException(hr, (XEvent.Id)e.Event.Id,
                        "AchievementsServiceV1 threw exception: " + e);
            }
            catch (ServiceException e)
            {
                hr = ServiceAdapter.ConvertAchievementErrorCodeTFSToXOnline(e.Error);
                throw new XRLExceptionWithoutEvent(hr,
                        "AchievementsServiceV1 threw exception: " + e);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch (XRLExceptionWithoutEvent e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"EUA|{0:x}|{1:x}|{2:x}|{3:x}",
                    hr,
                    req.Puid,
                    req.TitleId,
                    req.ForPuid);

                Xom.Log(XomAreaName.progresslog, sb.ToString());
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Progress, hr, resp);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\progress\xrlAvatarAssetEnum.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlAvatarAssetEnum.cs
//
////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.Text;
using System.Web;
using Microsoft.Xbox.Diagnostics.Errors;
using Microsoft.Xbox.Progress.Contracts;
using Microsoft.Xbox.Progress.Service.AvatarAwards;
using Microsoft.Xbox.Progress.Service.Interfaces.AvatarAwards;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.progress.shim.fd;

namespace xonline.server.progress.fd
{
    public class XRLAvatarAssetEnum : IHttpHandler
    {
        /// <summary>
        /// IsReusable
        /// </summary>
        /// <returns>True/False</retruns>
        /// <remarks>
        /// Returns if this object can be reused. Since the object doesn't hold
        /// any state, this method always returns true.
        /// </remarks>
        public bool IsReusable
        {
            get { return true; }
        }

        /// <summary>
        /// ProcessRequest
        /// </summary>
        /// <param name="ctx">HTTP input context</param>
        /// <remarks>
        /// Process incoming AvatarAsset enum request.
        /// </remarks>
        public void ProcessRequest(HttpContext ctx)
        {
            uint hr = HResult.E_FAIL;

            AvatarAssetEnumRequest req = new AvatarAssetEnumRequest();
            AvatarAssetEnumResponse resp = new AvatarAssetEnumResponse();

            string[] locales;

            try
            {
                CallSource.Check(VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyUserId(req.Puid);

                ServiceAdapter.CreateClaimsFromSGInfo(SGInfo.Current, req.Puid);

                if (req.LocaleId == 0)
                {
                    locales = SGInfo.GetUserLocaleList(req.Puid, false);
                }
                else
                {
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                uint? titleId = req.TitleId != 0 ? (uint?)req.TitleId : null;

                IAvatarAwardsServiceV1 svc = ProgressFrontEndApp.AvatarAwardServiceInstance;

                ReadAvatarAwardsResponseV1 possible = null;
                if (titleId != null)
                {
                    possible = svc.ReadPossibleAvatarAwards(req.ForPuid,
                        locales,
                        titleId,
                        0,
                        System.Int32.MaxValue
                        );

                    if (possible != null && possible.Error != null)
                    {
                        hr = ServiceAdapter.ConvertAvatarErrorCodeTFSToXOnline(possible.Error);
                        throw new XRLExceptionWithoutEvent(hr,
                                "AvatarAwardsServiceV1 API ReadPossibleAvatarAwards returned error :" + possible.Error.Id);
                    }
                }

                ReadAvatarAwardsResponseV1 rep = svc.ReadUnlockedAvatarAwards(req.Puid,
                    locales,
                    titleId,
                    0,
                    System.Int32.MaxValue
                    );

                if (rep != null && rep.Error != null)
                {
                    hr = ServiceAdapter.ConvertAvatarErrorCodeTFSToXOnline(rep.Error);
                    throw new XRLExceptionWithoutEvent(hr,
                            "AvatarAwardsServiceV1 API ReadUnlockedAvatarAwards returned error :" + rep.Error.Id);
                }

                if (rep != null && (possible != null || titleId == null))
                {
                    Dictionary<uint, AvatarAwardV1> earnedIds = new Dictionary<uint, AvatarAwardV1>();
                    List<AvatarAsset> awards = new List<AvatarAsset>();

                    for (int i = 0; i < rep.AvatarAwards.Length; i++)
                    {
                        if (awards.Count == req.MaxAssets)
                            break;

                        earnedIds[rep.AvatarAwards[i].AvatarAssetOrdinal] = rep.AvatarAwards[i];

                        if ((rep.AvatarAwards[i].Flags & XOn.XAVATAR_DETAILS_NOT_ACHIEVABLE) != 0)
                            continue;

                        if(i < req.StartingIndex)
                            continue;

                        AvatarAsset asset = ServiceAdapter.ConvertAvatarAwardTFSToXOnline(rep.AvatarAwards[i]);
                        asset.Flags |= !rep.AvatarAwards[i].IsSecret ? (int)XOn.XAVATAR_DETAILS_SHOWUNACHIEVED : 0;
                        awards.Add(asset);
                    }

                    if (titleId != null)
                    {
                        int count = -1;
                        for (int i = 0; i < possible.AvatarAwards.Length; i++)
                        {
                            if (!earnedIds.ContainsKey(possible.AvatarAwards[i].AvatarAssetOrdinal) ||
                                    (earnedIds.ContainsKey(possible.AvatarAwards[i].AvatarAssetOrdinal) &&
                                        (earnedIds[possible.AvatarAwards[i].AvatarAssetOrdinal].Flags & XOn.XAVATAR_DETAILS_NOT_ACHIEVABLE) != 0))
                            {
                                if (awards.Count == req.MaxAssets)
                                    break;

                                count++;
                                if (count < req.StartingIndex - rep.AvatarAwards.Length)
                                    continue;
    
                                AvatarAsset asset = ServiceAdapter.ConvertAvatarAwardTFSToXOnline(possible.AvatarAwards[i]);
                                if (earnedIds.ContainsKey(possible.AvatarAwards[i].AvatarAssetOrdinal))
                                {
                                    asset.Flags = (int)XOn.XAVATAR_DETAILS_NOT_ACHIEVABLE;
                                }

                                asset.Flags |= !possible.AvatarAwards[i].IsSecret ? (int)XOn.XAVATAR_DETAILS_SHOWUNACHIEVED : 0;

                                awards.Add(asset);
                            }
                        }
                    }

                    resp.AvatarAssets = awards.ToArray();
                    resp.AvatarAssetsCount = (ushort)resp.AvatarAssets.Length;
                }

                hr = HResult.S_OK;
            }
            catch (ServiceExceptionWithEvent e)
            {
                hr = ServiceAdapter.ConvertAvatarErrorCodeTFSToXOnline(e.Error);
                throw new XRLException(hr, (XEvent.Id)e.Event.Id,
                        "AvatarAwardsServiceV1 threw exception: " + e);
            }
            catch (ServiceException e)
            {
                hr = ServiceAdapter.ConvertAvatarErrorCodeTFSToXOnline(e.Error);
                throw new XRLExceptionWithoutEvent(hr,
                        "AvatarAwardsServiceV1 threw exception: " + e);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch (XRLExceptionWithoutEvent e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"EUV|{0:x}|{1:x}|{2:x}|{3:x}",
                    hr,
                    req.Puid,
                    req.TitleId,
                    req.ForPuid);

                Xom.Log(XomAreaName.progresslog, sb.ToString());
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Progress, hr, resp);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\progress\xrlSyncTitles.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncTitles.cs
//
////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
using Microsoft.Xbox.Diagnostics.Errors;
using Microsoft.Xbox.Progress.Contracts;
using Microsoft.Xbox.Progress.Service.Interfaces.UserTitles;
using Microsoft.Xbox.Progress.Service.UserTitles;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.server.progress.fd;
using xonline.server.progress.shim.fd;

namespace xonline.server.progress.fd
{
    public class XRLSyncTitles : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            SyncTitlesRequest req = new SyncTitlesRequest();
            SyncTitlesResponse resp = new SyncTitlesResponse();
            uint hr = HResult.E_FAIL;
            string[] locales;

            try
            {
                CallSource.Check(VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyUserId(req.UserId);

                ServiceAdapter.CreateClaimsFromSGInfo(SGInfo.Current, req.UserId);

                if (req.LocaleId == 0)
                {
                    locales = SGInfo.GetUserLocaleList(req.UserId, false);
                }
                else
                {
                    // convert localeid to the string representation
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                if (req.StartingIndex > 0)
                {
                    req.StartingIndex--;
                }

                IUserTitleServiceV1 svc = ProgressFrontEndApp.UserTitleServiceInstance;
                SyncUserTitlesResponseV1 svcResp = svc.SyncTitles(
                            req.UserId,
                            ServiceAdapter.ConvertUserTitleXOnlineToTFS(req.Titles),
                            locales,
                            req.StartingIndex,
                            XOn.XPROFILE_MAX_ENUM_TITLE,
                            req.Version
                            );

                if (svcResp != null && svcResp.Error != null)
                {
                    hr = ServiceAdapter.ConvertTitleErrorCodeTFSToXOnline(svcResp.Error);
                    throw new XRLExceptionWithoutEvent(hr,
                            "UserTitleServiceV1 API SyncTitles returned error :" + svcResp.Error.Id);
                }

                if (svcResp != null && svcResp.PagingInfo != null)
                {
                    resp.Version = svcResp.Version;
                    resp.Titles = ServiceAdapter.ConvertUserTitlesTFSToXOnline(svcResp.Titles);
                    resp.TotalTitles = (ushort)(svcResp.PagingInfo.TotalRecords > XOn.XPROFILE_MAX_ENUM_TITLE ? XOn.XPROFILE_MAX_ENUM_TITLE : svcResp.PagingInfo.TotalRecords);
                }

                hr = HResult.S_OK;
            }
            catch (ServiceExceptionWithEvent e)
            {
                hr = ServiceAdapter.ConvertTitleErrorCodeTFSToXOnline(e.Error);
                throw new XRLException(hr, (XEvent.Id)e.Event.Id,
                        "UserTitleServiceV1 API SyncTitles threw exception: " + e);
            }
            catch (ServiceException e)
            {
                hr = ServiceAdapter.ConvertTitleErrorCodeTFSToXOnline(e.Error);
                throw new XRLExceptionWithoutEvent(hr,
                        "UserTitleServiceV1 API SyncTitles threw exception: " + e);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch (XRLExceptionWithoutEvent e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"SUT|{0:x}|{1:x}|{2}|{3}|",
                    hr,
                    req.UserId,
                    req.Version,
                    resp.Version);

                if (req.Titles != null)
                {
                    for (int i = 0; i < req.Titles.Length; i++)
                    {
                        if (req.Titles[i] == null)
                            sb.Append("null");
                        else
                            sb.AppendFormat("{0:x}", req.Titles[i].TitleId);

                        if (i != req.Titles.Length - 1)
                            sb.Append(",");
                    }
                }

                sb.Append("|");

                if (resp.Titles != null)
                {
                    for (int i = 0; i < resp.Titles.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", resp.Titles[i].TitleId);

                        if (i != resp.Titles.Length - 1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.progresslog, sb.ToString());
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Progress, hr, resp);

        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\progress\xrlTitleClear.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlTitleClear.cs
//
////////////////////////////////////////////////////////////////////

using System.Diagnostics;
using System.Text;
using System.Web;
using Microsoft.Xbox.Diagnostics.Errors;
using Microsoft.Xbox.Progress.Contracts;
using Microsoft.Xbox.Progress.Service.Interfaces.UserTitles;
using Microsoft.Xbox.Progress.Service.UserTitles;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.progress.shim.fd;

namespace xonline.server.progress.fd
{
    public class XRLTitleClear : IHttpHandler
    {
        public void ProcessRequest(HttpContext ctx)
        {
            uint hr = HResult.XONLINE_E_STAT_ERROR;

            TitleClearRequest req = new TitleClearRequest();

            try
            {
                CallSource.Check(VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                // SGInfo.VerifyTitleId is intentionally omitted so any system app
                // can clear any title.

                SGInfo.VerifyUserId(req.UserId);
                ServiceAdapter.CreateClaimsFromSGInfo(SGInfo.Current, req.UserId);
                IUserTitleServiceV1 svc = ProgressFrontEndApp.UserTitleServiceInstance;

                ProgressUpdateResponse progressResp = svc.DeleteTitle(req.UserId, req.TitleId);
                if (progressResp != null && progressResp.Error != null)
                {
                    hr = ServiceAdapter.ConvertTitleErrorCodeTFSToXOnline(progressResp.Error);
                    throw new XRLExceptionWithoutEvent(hr,
                            "UserTitleServiceV1 API DeleteTitle returned error :" + progressResp.Error.Id);
                }

                hr = HResult.S_OK;
            }
            catch (ServiceExceptionWithEvent e)
            {
                hr = ServiceAdapter.ConvertTitleErrorCodeTFSToXOnline(e.Error);
                throw new XRLException(hr, (XEvent.Id)e.Event.Id,
                        "UserTitleServiceV1 API DeleteTitle threw exception: " + e);
            }
            catch (ServiceException e)
            {
                hr = ServiceAdapter.ConvertTitleErrorCodeTFSToXOnline(e.Error);
                throw new XRLExceptionWithoutEvent(hr,
                        "UserTitleServiceV1 API DeleteTitle threw exception: " + e);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch (XRLExceptionWithoutEvent e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat("CLT|{0:x}|{1:x}|{2:x}",
                    hr,
                    req.TitleId,
                    req.UserId);

                Xom.Log(XomAreaName.progresslog, sb.ToString());
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Progress, hr);
        }

        public bool IsReusable
        {
            get { return true; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\Game.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Game.cs		Management functions for a single game.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;

namespace MSRC.Ranking
{
	/// <summary>
	/// A class to represent a single game between some teams each of which comprised of several players. Each game also has
	/// to have the date at which it ended. This time is assumed to be the time when the game finsihed as each team will
	/// know about its scores (which is only possible AFTER the game).
	/// </summary>
	public class Game
	{
		/// <summary>
		/// The date at which the game ended.
		/// </summary>
		DateTime m_aDate;		
		/// <summary>
		/// A variable sized list of teams.
		/// </summary>
		ArrayList m_aTeams;

		/// <summary>
		/// Constructs a game that ended at a specified date between at a maximal number of teams. 
		/// </summary>
		/// <param name="aDate">Date at which the game ended.</param>
		/// <param name="iMaxNumberOfTeams">Maximum number of teams.</param>
		/// <remarks>An exception will be thrown if more than the specified number of teams are added.</remarks>
		public Game (DateTime aDate, int iMaxNumberOfTeams)
		{
			// copy parameters
			m_aDate = aDate;
			m_aTeams = new ArrayList (iMaxNumberOfTeams);
		}

		/// <summary>
		/// Constructs a game that ended at a specified date between an arbitrary number of teams.
		/// </summary>
		/// <param name="aDate">Date at which the game ended.</param>
		public Game (DateTime aDate)
		{
			// copy parameters
			m_aDate = aDate;
			m_aTeams = new ArrayList ();
		}
	
		/// <summary>
		/// The date at which the game ended.
		/// </summary>
		public DateTime Date 
		{
			get 
			{
				return m_aDate;
			}
		}

		/// <summary>
		/// The number of participating teams.
		/// </summary>
		public int NumberOfTeams 
		{
			get 
			{
				return m_aTeams.Count;
			}
		}

		/// <summary>
		/// The total number of players participating in the game.
		/// </summary>
		public int NumberOfPlayers
		{
			get 
			{
				// count the players team by team
				int iNumberOfPlayers = 0;
				for (int i = 0; i < this.NumberOfTeams; i++) 
					iNumberOfPlayers += GetTeam (i).NumberOfPlayers;

				return iNumberOfPlayers;
			}
		}

		/// <summary>
		/// Adds a team to the game.
		/// </summary>
		/// <param name="aTeam">The team to be added.</param>
		/// <returns>The team index of the team added.</returns>
		/// <remarks>The team index is a zero-based internal index used by this class.</remarks>
		public int AddTeam (Team aTeam)
		{
			return (m_aTeams.Add (aTeam));
		}

		/// <summary>
		/// Gets the team at a specified index.
		/// </summary>
		/// <param name="iTeamIndex">The index of the team.</param>
		/// <returns>The team at the given index or null, if the index is wrong.</returns>
		/// <remarks>The team index is a zero-based internal index used by this class.</remarks>
		public Team GetTeam (int iTeamIndex)
		{
			if (iTeamIndex < 0 || iTeamIndex > this.NumberOfTeams)
				return null;

			return ((Team) m_aTeams [iTeamIndex]);
		}

		/// <summary>
		/// Gets the winner between two teams.
		/// </summary>
		/// <param name="iTeamIndex1">Team index of team 1.</param>
		/// <param name="iTeamIndex2">Team index of team 2.</param>
		/// <returns>Returns +1 if team 1 won against team 2, -1 if team 2 won against team 1, and 0 it both teams
		/// draw.</returns>
		/// <remarks>The team index is a zero-based internal index used by this class.</remarks>
		public int GetWinner (int iTeamIndex1, int iTeamIndex2)
		{
			int iScoreTeam1 = GetTeam (iTeamIndex1).TeamScore;
			int iScoreTeam2 = GetTeam (iTeamIndex2).TeamScore;

			// return the result based on the rankings
			if (iScoreTeam1 > iScoreTeam2)
				return +1;
			else if (iScoreTeam2 > iScoreTeam1) 
				return -1;
			else
				return 0;
		}

		/// <summary>
		/// All player IDs of all players in the game.
		/// </summary>
		public int [] PlayerIDs
		{
			get 
			{
				ArrayList aResult = new ArrayList ();

				// add the player IDs of all teams
				for (int i = 0; i < m_aTeams.Count; i++) 
					aResult.AddRange (GetTeam (i).PlayerIDs);

				return ((int []) aResult.ToArray (typeof (int)));
			}
		}

		/// <summary>
		/// All team indicies of all players in the game.
		/// </summary>
		/// <remarks>The team index is a zero-based internal index used by this class.</remarks>
		public int [] TeamIDs
		{
			get 
			{
				ArrayList aResult = new ArrayList ();

				// add the team IDs for all players
				for (int i = 0; i < m_aTeams.Count; i++) 
					for (int j = 0; j < GetTeam (i).NumberOfPlayers; j++)
					aResult.Add (i);

				return ((int []) aResult.ToArray (typeof (int)));
			}
		}

		/// <summary>
		/// The full ranking of all teams based on the team scores.
		/// </summary>
		public Ranking Ranking
		{
			get 
			{
				// construct a true ranking of the teams
				int [] iScores = new int [m_aTeams.Count];
				
				for (int i = 0; i < m_aTeams.Count; i++) 
					iScores [i] = GetTeam (i).TeamScore;

				return new Ranking (iScores);
			}
		}

		/// <summary>
		/// Removes all empty teams.
		/// </summary>
		public void RemoveEmptyTeams ()
		{
			// cycle through all teams and remove those with zero number of players
			for (int i = 0; i < m_aTeams.Count; i++) 
				if (((Team) m_aTeams [i]).NumberOfPlayers == 0) 
				{
					m_aTeams.RemoveAt (i);
					i = i - 1;
				}

			// done!
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\GaussianApproximations.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// GaussianApproximations.cs			Static functions for Gaussian integrals
//
// 2004/2005 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Diagnostics;
using MSRC.Ranking.LinearAlgebra;

namespace MSRC.Ranking.Numerics
{
	/// <summary>
	/// A static class that provides some functions for Gaussian integrals. In particular, this class provides
	/// correction functions for the mean and variance of the truncated Gaussian.
	/// </summary>
	public class GaussianApproximations
	{
		#region Erf functions
		/// <summary>
		/// Computes the complementary error function. This function is defined by 2/sqrt(pi) * integral from x to infinity of exp (-t^2) dt.
		/// </summary>
		/// <param name="x">The lower boundary of integration.</param>
		/// <returns>The complementary error function.</returns>
		/// <remarks>This method uses a Chebyshev series approximation which is exact in the whole range up to 1 * 10^{-7}.</remarks>
		public static double erfc (double x)
		{
			// check for boundary cases
			if (double.IsNegativeInfinity (x))
				return 2.0;
			if (double.IsPositiveInfinity (x))
				return 0.0;

			// ... otherwise do the hard work
			double z = Math.Abs (x);
			double t = 1.0 / (1.0 + 0.5 * z);
			double dResult = t * Math.Exp (-z*z 
				-1.26551223 + 
				t * (1.00002368 + 
				t * (0.37409196 + 
				t * (0.09678418 + 
				t * (-0.18628806 + 
				t * (0.27886807 + 
				t * (-1.13520398 +
				t * (1.48851587 + 
				t * (-0.82215223 + 
				t * 0.17087277)))))))));

			return (dResult = (x >= 0.0)? dResult: 2.0 - dResult);
		}

		/// <summary>
		/// Computes the inverse of the complementary error function. 
		/// </summary>
		/// <param name="y">The point of interest.</param>
		/// <returns>The inverse of the complementary error function.</returns>
		/// <remarks>This function uses a polynomial approximation together with one step of Halley's rational method.</remarks>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the input <c>y</c> is outside [0,2].</exception>
		public static double erfcinv (double y)
		{
			// check for boundary cases
			if (y < 0 || y > 2)
				throw new ArgumentOutOfRangeException ("y", y, "Inverse complementary function not defined outside [0,2].");
			if (y == 0)
				return double.PositiveInfinity;
			if (y == 2)
				return double.NegativeInfinity;

			// stores the result
			double x = 0.0;

			// Rational approxiamtion for the central region
			if (y  >= 0.0485 && y <= 1.9515) 
			{
				double q = y - 1.0;
				double r = q * q;
				x = (((((0.01370600482778535*r - 0.3051415712357203)*r + 1.524304069216834)*r - 3.057303267970988)*r + 2.710410832036097)*r - 0.8862269264526915) * q /
					(((((-0.05319931523264068*r + 0.6311946752267222)*r - 2.432796560310728)*r + 4.175081992982483)*r - 3.320170388221430)*r + 1.0);
			}

			// Rational approximation for the lower region
			if (y < 0.0485)
			{
				double q = Math.Sqrt (-2.0 * Math.Log (y / 2.0));
				x = (((((0.005504751339936943*q + 0.2279687217114118)*q + 1.697592457770869)*q + 1.802933168781950)*q + -3.093354679843504)*q - 2.077595676404383) / 
					((((0.007784695709041462*q + 0.3224671290700398)*q + 2.445134137142996)*q + 3.754408661907416)*q + 1.0);
			}
			
			// Rational approximation for the upper region
			if (y > 1.9515) 
			{
				double q = Math.Sqrt (-2.0 * Math.Log (1 - y / 2.0));
				x = -(((((0.005504751339936943*q + 0.2279687217114118)*q + 1.697592457770869)*q + 1.802933168781950)*q + -3.093354679843504)*q - 2.077595676404383) / 
					 ((((0.007784695709041462*q + 0.3224671290700398)*q + 2.445134137142996)*q + 3.754408661907416)*q + 1.0);
			}

			// One iteration of Halley's rational method (third order) gives full machine precision.
			double u = (erfc (x) - y) / (-2.0 / Math.Sqrt (Math.PI) * Math.Exp (-x * x));
			x = x - u / (1.0 + x * u);

			// done!
			return x;
		}
		#endregion

		#region One dimensional Phi and N functions
		/// <summary>
		/// Computes the cummulative Gaussian distribution at a specified point of interest.
		/// </summary>
		/// <param name="t">The point of interest.</param>
		/// <returns>The cummulative Gaussian distribution at the point of interest.</returns>
		public static double Phi (double t)
		{
			const double dSqrt2 = 1.4142135623730951;

			return erfc (-t / dSqrt2) / 2.0;
		}

		/// <summary>
		/// Computes the inverse of the cummulative Gaussian distribution (qunatile function) at a specified point of interest.
		/// </summary>
		/// <param name="p">The cummulative probability or point of interest in [0,1].</param>
		/// <returns>The quantile at the specified point.</returns>
		public static double PhiInverse (double p)
		{
			const double dSqrt2 = 1.4142135623730951;

			return -dSqrt2 * erfcinv (2 * p);
		}

		/// <summary>
		/// Computes the normal density at a specified point of interest.
		/// </summary>
		/// <param name="t">The point of interest.</param>
		/// <returns>The normal density at the point of interest.</returns>
		public static double N (double t)
		{
			const double dSqrt2Pi = 2.5066282746310002;
			return 1 / dSqrt2Pi * Math.Exp (-t*t / 2);
		}
		#endregion

		#region One dimensional corrector functions of a truncated Gaussian
		/// <summary>
		/// Computes the additive correction of a single-sided truncated Gaussian with unit variance.
		/// </summary>
		/// <param name="t">The mean of the non-truncated Gaussian.</param>
		/// <param name="epsilon">The truncation point.</param>
		/// <returns>The additive correction.</returns>
		public static double v (double t, double epsilon)
		{
			double dNumerator = N (t - epsilon);
			double dDenominator = Phi (t - epsilon);
			if (dDenominator < Math.Sqrt (double.Epsilon))
				return -t + epsilon;
			else
				return dNumerator / dDenominator;
		}

		/// <summary>
		/// Computes the multiplicative correction of a single-sided truncated Gaussian with unit variance.
		/// </summary>
		/// <param name="t">The mean of the non-truncated Gaussian.</param>
		/// <param name="epsilon">The truncation point.</param>
		/// <returns>The multiplicative correction.</returns>
		public static double w (double t, double epsilon)
		{
			double dNumerator = (t - epsilon) * N (t - epsilon);
			double dDenominator = Phi (t - epsilon);
			if (dDenominator < Math.Sqrt (double.Epsilon))
				return (t < 0.0)?1.0:0.0;
			else
			{
				double aV0 = v (t, epsilon);
				return aV0 * aV0 + dNumerator / dDenominator;
			}
		}

		/// <summary>
		/// Computes the additive correction of a symmetrical double-sided truncated Gaussian with unit variance.
		/// </summary>
		/// <param name="t">The mean of the non-truncated Gaussian.</param>
		/// <param name="epsilon">The truncation point.</param>
		/// <returns>The additive correction.</returns>
		public static double v0 (double t, double epsilon)
		{
			double v = Math.Abs (t);
			double dNumerator = N (-epsilon - v) - N (epsilon - v);
			double dDenominator = Phi (epsilon - v) - Phi (-epsilon - v);
			if (dDenominator < Math.Sqrt (double.Epsilon))
				return (t < 0.0)?-t - epsilon:-t + epsilon;
			else		
				return (t < 0.0)?-dNumerator / dDenominator:dNumerator / dDenominator;
		}

		/// <summary>
		/// Computes the multiplicative correction of a symmetrical double-sided truncated Gaussian with unit variance.
		/// </summary>
		/// <param name="t">The mean of the non-truncated Gaussian.</param>
		/// <param name="epsilon">The truncation point.</param>
		/// <returns>The multiplicative correction.</returns>
		public static double w0 (double t, double epsilon)
		{
			double v = Math.Abs (t);
			double dNumerator = (epsilon - v) * N (epsilon - v) - (-epsilon - v) * N (-epsilon - v);
			double dDenominator = Phi (epsilon - v) - Phi (-epsilon - v);
			if (dDenominator < Math.Sqrt (double.Epsilon))
				return 1.0;
			else
			{
				double aV0 = v0 (v, epsilon);
				return aV0 * aV0 + dNumerator / dDenominator;
			}
		}

		/// <summary>
		/// Computes the additive correction of a general double-sided truncated Gaussian with unit variance.
		/// </summary>
		/// <param name="t">The mean of the non-truncated Gaussian.</param>
		/// <param name="l">The lower truncation point.</param>
		/// <param name="u">The upper truncation point.</param>
		/// <returns>The additive correction.</returns>
		/// <remarks>This routine has not been tested in all regimes of t for a given l and u.</remarks>
		/// <exception cref="ArithmeticException">Thrown if the computation is not numerically stable.</exception>
		public static double v (double t, double l, double u)
		{
			double dNumerator = N (t - l) - N (t - u);
			double dDenominator = Phi (u - t) - Phi (l - t);
			if (dDenominator < Math.Sqrt (double.Epsilon))
				throw new ArithmeticException ("Unsafe computation of v");
			else
				return dNumerator / dDenominator;
		}

		/// <summary>
		/// Computes the multiplicative correction of a general double-sided truncated Gaussian with unit variance.
		/// </summary>
		/// <param name="t">The mean of the non-truncated Gaussian.</param>
		/// <param name="l">The lower truncation point.</param>
		/// <param name="u">The upper truncation point.</param>
		/// <returns>The multiplicative correction.</returns>
		/// <remarks>This routine has not been tested in all regimes of t for a given l and u.</remarks>
		/// <exception cref="ArithmeticException">Thrown if the computation is not numerically stable.</exception>
		public static double w (double t, double l, double u)
		{
			double dNumerator = (u - t) * N (u - t) - (l - t) * N (l - t);
			double dDenominator = Phi (u - t) - Phi (l - t);
			if (dDenominator < Math.Sqrt (double.Epsilon))
				throw new ArithmeticException ("Unsafe computation of v");
			else
			{
				double aV0 = v (t, l, u);
				return aV0 * aV0 + dNumerator / dDenominator;
			}
		}
		#endregion

		#region Multi dimensional Phi and moment functions (using Genz algorithm)
		/// <summary>
		/// A structure holding moments of truncated multi-variate Gaussian. This structure is only used by
		/// <c>CalculateTGMoments</c>.
		/// </summary>
		public struct TGMoments
		{
			/// <summary>
			/// Normalisation constant of the truncated Gaussian.
			/// </summary>
			public double M0;
			/// <summary>
			/// Vector of first moments.
			/// </summary>
			public Matrix M1;
			/// <summary>
			/// Square matrix of second moments.
			/// </summary>
			public Matrix M2;
		}	

		/// <summary>
		/// Computes a Niederreither series of coefficients.
		/// </summary>
		/// <param name="iNumberOfDimensions">Number of dimensions.</param>
		/// <returns>A Niederreiter series with as many elements as dimensions.</returns>
		private static double [] ComputeNiederreiterSeries (int iNumberOfDimensions)
		{
			double [] dNiederreiter = new double [iNumberOfDimensions];
			for (int i = 0; i < iNumberOfDimensions; i++)
				dNiederreiter [i] = Math.Pow (2.0, (double) (i + 1) / (double) (iNumberOfDimensions + 1));
			return dNiederreiter;
		}

		/// <summary>
		/// Computes the transformed integrand of a multi-variate Gaussian.
		/// </summary>
		/// <param name="mu">Mean of the Gaussian.</param>
		/// <param name="C">Cholesky factor of the covariance of the Gaussian.</param>
		/// <param name="a">Lower integration boundary.</param>
		/// <param name="b">Upper integration boundary.</param>
		/// <param name="dSample">The uniform random sample.</param>
		/// <param name="tmp">A temporary matrix of the size of <c>M1</c>.</param>
		/// <param name="M0">The volume sample (zeroth moment).</param>
		/// <param name="M1">The mean sample (first moment).</param>
		/// <param name="M2">The second moment sample.</param>
		/// <remarks>This function is implemented to minimise the number of allocations of memory and may thus be hard to 
		/// read.</remarks>
		private static void TransformSample (Matrix mu, Matrix C, Matrix a, Matrix b, double [] dSample, ref Matrix tmp, ref double M0, ref Matrix M1, ref Matrix M2)
		{
			// re-adjusts the lower and upper integration limits of the Gaussian
			int iNumberOfDimensions = a.NoRows;
			
			// initialise the lower and upper integration limits of the uniform
			double dLowerLimit = Phi ((a [0] - mu [0]) / C [0, 0]);
			double dUpperLimit = Phi ((b [0] - mu [0]) / C [0, 0]);
			M0 = dUpperLimit - dLowerLimit;

			// loop over all dimensions and compute the volume at y
			for (int i = 1; i < iNumberOfDimensions; i++) 
			{
				M1 [i - 1] = PhiInverse (dLowerLimit + dSample [i - 1] * (dUpperLimit - dLowerLimit));
				double dTmp = 0.0;
				for (int j = 0; j < i; j++) 
					dTmp += C [i, j] * M1 [j];
				dLowerLimit = Phi (((a [i] - mu [i]) - dTmp) / C [i, i]);
				dUpperLimit = Phi (((b [i] - mu [i]) - dTmp) / C [i, i]);
				M0 *= dUpperLimit - dLowerLimit;
			}
			M1 [iNumberOfDimensions - 1] = PhiInverse (dLowerLimit + dSample [iNumberOfDimensions - 1] * (dUpperLimit - dLowerLimit));
			
			// compute the moments at the random sample
			for (int i = 0; i < C.NoRows; i++) 
			{
				tmp [i] = 0.0;
				for (int j = 0; j <= i; j++)
					tmp [i] += C [i, j] * M1 [j];
				tmp [i] += mu [i];
			}
			for (int i = 0; i < M1.NoRows; i++) 
				M1 [i] = M0 * tmp [i];
			for (int i = 0; i < M2.NoRows; i++) 
				for (int j = 0; j< M2.NoRows; j++) 
					M2 [i, j] = M0 * tmp [i] * tmp [j];
		}

		/// <summary>
		/// Computes a multivariate partial Gaussian integral.
		/// </summary>
		/// <param name="mu">Mean of the Gaussian distribution.</param>
		/// <param name="Sigma">Covariance of the Gaussian distribution.</param>
		/// <param name="a">Lower integration limits.</param>
		/// <param name="b">Upper integration limits.</param>
		/// <param name="iMaxNumberOfPoints">Number of quasi-random points.</param>
		/// <returns>The normalisation constant, mean and second moment matrix of a multivariate Gaussian density between <c>a</c> and <b>b</b>.</returns>
		/// <remarks>This function implements a variant of the algorithm as described in <i>A. Genz. Numerical Computation of Multivariate 
		/// Normal Probabilities.</i> 1992 using a quais-random lattice generator based on Niederreiter point sets. However, for one-dimensional
		/// integrals of a certain sort if resorts to use the fast <c>v</c>, <c>w</c>, <c>v0</c> and <c>w0</c> function.</remarks>
		/// <exception cref="MatrixTypeException">Thrown if <c>mu</c>, <c>a</c> or <c>b</c> are not vectors
		/// or if <c>Sigma</c> is not a square matrix.</exception>
		/// <exception cref="MatrixSizeException">Thrown if <c>mu</c>, <c>a</c> or <c>b</c> are not the same number of rows as <c>Sigma</c>.</exception>
		/// <exception cref="ArithmeticException">Thrown if the normalisation constant comes out too small.</exception>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the number of dimensions is too large (which would lead to unrealiable results).</exception>
		public static TGMoments CalculateTGMoments (Matrix mu, Matrix Sigma, Matrix a, Matrix b, int iMaxNumberOfPoints)
		{
			/////////////////////////////////////////////////////////////////////////
			// Parameter checks
			/////////////////////////////////////////////////////////////////////////
			if (!mu.IsColumnVector)
				throw new MatrixTypeException (mu.Type, MatrixType.ColumnVector);
			if (!a.IsColumnVector)
				throw new MatrixTypeException (a.Type, MatrixType.ColumnVector);
			if (!b.IsColumnVector)
				throw new MatrixTypeException (b.Type, MatrixType.ColumnVector);
			if (Sigma.Type != MatrixType.SquareMatrix && Sigma.Type != MatrixType.Scalar)
				throw new MatrixTypeException (Sigma.Type, MatrixType.SquareMatrix);
			if (mu.NoRows != Sigma.NoRows)
				throw new MatrixSizeException (mu.NoRows, mu.NoColumns, Sigma.NoRows, mu.NoColumns);
			if (a.NoRows != Sigma.NoRows)
				throw new MatrixSizeException (a.NoRows, a.NoColumns, Sigma.NoRows, a.NoColumns);
			if (b.NoRows != Sigma.NoRows)
				throw new MatrixSizeException (b.NoRows, b.NoColumns, Sigma.NoRows, b.NoColumns);
			if (mu.NoRows > 20)
				throw new ArgumentOutOfRangeException ("This method will not work reliably for more than 20 dimensions.");

			// introduce a shorthand for the number of dimensions
			int iNumberOfDimensions = mu.NoRows;

			/////////////////////////////////////////////////////////////////////////
			// allocate the return variable and initialise the squared purely random samples 
			/////////////////////////////////////////////////////////////////////////
			TGMoments aResult;
			aResult.M0 = 0.0;
			aResult.M1 = new Matrix (iNumberOfDimensions, 1);
			aResult.M2 = new Matrix (iNumberOfDimensions, iNumberOfDimensions);

			/////////////////////////////////////////////////////////////////////////
			// check if the quick function can be applied.
			/////////////////////////////////////////////////////////////////////////
			if (mu.NoElements == 1) 
			{
				if (b [0] == double.PositiveInfinity) 
				{
					double dSigma = Math.Sqrt (Sigma [0, 0]);
					aResult.M0 = Phi ((mu [0] - a [0]) / dSigma);
					aResult.M1 = mu [0] + dSigma * v (mu [0] / dSigma, a [0] / dSigma);
					aResult.M2 = dSigma * dSigma * (1 - w (mu [0] / dSigma, a [0] / dSigma)) + aResult.M1 * aResult.M1;
					return aResult;
				}
				if (a [0] == -b [0])
				{
					double dSigma = Math.Sqrt (Sigma [0, 0]);
					aResult.M0 = Phi ((b [0] - mu [0]) / dSigma) - Phi ((a [0] - mu [0]) / dSigma);
					aResult.M1 = mu [0] + dSigma * v0 (mu [0] / dSigma, b [0] / dSigma);
					aResult.M2 = dSigma * dSigma * (1 - w0 (mu [0] / dSigma, b [0] / dSigma)) + aResult.M1 * aResult.M1;
					return aResult;
				}
			}

			////////////////////////////////////////////////////////////
			// Compute the lower triangular Cholesky decomposition and
			// intialise the quasi-random deviates and
			// precompute the Niederreiter point series
			/////////////////////////////////////////////////////////////
			Matrix C = Sigma.Cholesky ();
			double [] dQuasiRandom = new double [iNumberOfDimensions];
			double [] dNiederreiter = ComputeNiederreiterSeries (iNumberOfDimensions);

			double QuasiM0 = 0.0;
			Matrix QuasiM1 = new Matrix (iNumberOfDimensions, 1);
			Matrix QuasiM2 = new Matrix (iNumberOfDimensions, iNumberOfDimensions);
			Matrix Tmp = new Matrix (iNumberOfDimensions, 1);

			///////////////////////////////////////
			// Loop over the number of quasi-random points
			///////////////////////////////////////
			for (int iNumberOfPoints = 0; iNumberOfPoints < iMaxNumberOfPoints; iNumberOfPoints++) 
			{
				// compute a new quasi-random sample and update the a quasi moments
				for (int i = 0; i < iNumberOfDimensions; i++) 
				{
					double t = (double) (iNumberOfPoints + 1) * dNiederreiter [i]; 
					dQuasiRandom [i] = Math.Abs (2.0 * (t - Math.Floor (t)) - 1.0);
				}

				TransformSample (mu, C, a, b, dQuasiRandom, ref Tmp, ref QuasiM0, ref QuasiM1, ref QuasiM2);
				aResult.M0 += (QuasiM0 - aResult.M0) / (double) (2 * iNumberOfPoints + 1);
				QuasiM1.Subtract (aResult.M1);
				QuasiM1.Divide ((double) (2 * iNumberOfPoints + 1));
				aResult.M1.Add (QuasiM1);
				QuasiM2.Subtract (aResult.M2);
				QuasiM2.Divide ((double) (2 * iNumberOfPoints + 1));
				aResult.M2.Add (QuasiM2);

				// compute a new quasi-random sample and update the average quasi moments (mirrored)
				for (int i = 0; i < iNumberOfDimensions; i++) 
					dQuasiRandom [i] = 1.0 - dQuasiRandom [i];

				TransformSample (mu, C, a, b, dQuasiRandom, ref Tmp, ref QuasiM0, ref QuasiM1, ref QuasiM2);
				aResult.M0 = aResult.M0 + (QuasiM0 - aResult.M0) / (double) (2 * iNumberOfPoints + 1);
				QuasiM1.Subtract (aResult.M1);
				QuasiM1.Divide ((double) (2 * (iNumberOfPoints + 1)));
				aResult.M1.Add (QuasiM1);
				QuasiM2.Subtract (aResult.M2);
				QuasiM2.Divide ((double) (2 * (iNumberOfPoints + 1)));
				aResult.M2.Add (QuasiM2);
			}

			////////////////////////////////////////////////
			// renormalise the moments
			////////////////////////////////////////////////
			aResult.M1.Divide (aResult.M0);
			aResult.M2.Divide (aResult.M0);
			if (aResult.M1.IsNaN () || aResult.M2.IsNaN () ||
				aResult.M1.IsInfinity () || aResult.M2.IsInfinity ())
				throw new ArithmeticException ("Normalisation constant is too small");

			// return the result
			return aResult;
		}
		
		/// <summary>
		/// Computes a multivariate partial Gaussian integral.
		/// </summary>
		/// <param name="mu">Mean of the Gaussian distribution.</param>
		/// <param name="Sigma">Covariance of the Gaussian distribution.</param>
		/// <param name="a">Lower integration limits.</param>
		/// <param name="b">Upper integration limits.</param>
		/// <param name="iMaxNumberOfPoints">Number of quasi-random points.</param>
		/// <returns>The integal of the multivariate Gaussian density between <c>a</c> and <b>b</b>.</returns>
		/// <remarks>This function implements a variant of the algorithm as described in <i>A. Genz. Numerical Computation of 
		/// Multivariate Normal Probabilities.</i> 1992. However, fast functions based on <c>erfc</c> are used for one-dimensional
		/// integrals.</remarks>
		/// <exception cref="MatrixTypeException">Thrown if <c>mu</c>, <c>a</c> or <c>b</c> are not vectors
		/// or if <c>Sigma</c> is not a square matrix.</exception>
		/// <exception cref="MatrixSizeException">Thrown if <c>mu</c>, <c>a</c> or <c>b</c> are not the same number of rows as <c>Sigma</c>.</exception>
		/// <exception cref="ArithmeticException">Thrown if the normalisation constant comes out too small.</exception>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the number of dimensions is too large (which would lead to unrealiable results).</exception>
		public static double Phi (Matrix mu, Matrix Sigma, Matrix a, Matrix b, int iMaxNumberOfPoints)
		{
			return CalculateTGMoments (mu, Sigma, a, b, iMaxNumberOfPoints).M0;
		}
		#endregion

		#region Multi dimensional Phi and parameter functions (using Gaussian EP)
		/// <summary>
		/// A structure holding the parameters of truncated multi-variate Gaussian approximation. This structure is only used by
		/// <c>CalculateTGAParameters</c>. 
		/// </summary>
		/// <remarks>Note that the parameters of a truncated Gaussian approximation are closely related to the moments of a truncated Gaussian. 
		/// In particular, we have that TGParameters.Z \approx TGMoments.M0, TGParameters.mu \approx TGMoments.M1 and 
		/// TGParameters.Sigma \approx TGMoments.M2 - TGMoments.M1 * TGMoments.M1.Transpose ().</remarks>
		public struct TGAParameters
		{
			/// <summary>
			/// Approximative normalisation constant of the truncated Gaussian.
			/// </summary>
			public double Z;
			/// <summary>
			/// Mean vector of the Gaussian approximation.
			/// </summary>
			public Matrix mu;
			/// <summary>
			/// Covariance matrix of the Gaussian approximation.
			/// </summary>
			public Matrix Sigma;
		}	

		/// <summary>
		/// Computes the parameter of the best Gaussian approximation of a multivariate truncated Gaussian.
		/// </summary>
		/// <param name="mu">Mean of the Gaussian distribution.</param>
		/// <param name="Sigma">Covariance of the Gaussian distribution.</param>
		/// <param name="l">Lower integration limits.</param>
		/// <param name="u">Upper integration limits.</param>
		/// <param name="iNumberOfIterations">Number of iterations over the list of integration limits. Usually, a value of 5 - 10 will work fine.</param>
		/// <returns>The normalisation constant, mean and covariance matrix of the best Gaussian approxiamtion to the truncated multivariate Gaussian density 
		/// between <c>l</c> and <b>u</b>.</returns>
		/// <remarks>This function implements the EP algorithm of Thomas P. Minka described in <i>T. P. Minka. A family of algorithms for approximate Bayesian 
		/// inference.</i> PhD thesis. MIT. 2001. Note that in the case of scalars, the number of iterations is automatically reduced to 1.</remarks>
		/// <exception cref="MatrixTypeException">Thrown if <c>mu</c>, <c>l</c> or <c>u</c> are not vectors
		/// or if <c>Sigma</c> is not a square matrix.</exception>
		/// <exception cref="MatrixSizeException">Thrown if <c>mu</c>, <c>l</c> or <c>u</c> are not the same number of rows as <c>Sigma</c>.</exception>
		public static TGAParameters CalculateTGAParameters (Matrix mu, Matrix Sigma, Matrix l, Matrix u, int iNumberOfIterations)
		{
			/////////////////////////////////////////////////////////////////////////
			// Parameter checks
			/////////////////////////////////////////////////////////////////////////
			if (!mu.IsColumnVector)
				throw new MatrixTypeException (mu.Type, MatrixType.ColumnVector);
			if (!l.IsColumnVector)
				throw new MatrixTypeException (l.Type, MatrixType.ColumnVector);
			if (!u.IsColumnVector)
				throw new MatrixTypeException (u.Type, MatrixType.ColumnVector);
			if (Sigma.Type != MatrixType.SquareMatrix && Sigma.Type != MatrixType.Scalar)
				throw new MatrixTypeException (Sigma.Type, MatrixType.SquareMatrix);
			if (mu.NoRows != Sigma.NoRows)
				throw new MatrixSizeException (mu.NoRows, mu.NoColumns, Sigma.NoRows, mu.NoColumns);
			if (l.NoRows != Sigma.NoRows)
				throw new MatrixSizeException (l.NoRows, l.NoColumns, Sigma.NoRows, l.NoColumns);
			if (u.NoRows != Sigma.NoRows)
				throw new MatrixSizeException (u.NoRows, u.NoColumns, Sigma.NoRows, u.NoColumns);

			// introduce a shorthand for the number of dimensions
			int iNumberOfDimensions = mu.NoRows;

			/////////////////////////////////////////////////////////////////////////
			// allocate the return variable and initialise the squared purely random samples 
			/////////////////////////////////////////////////////////////////////////
			TGAParameters aResult;
			aResult.mu = new Matrix (mu);
			aResult.Sigma = new Matrix (Sigma);

			/////////////////////////////////////////////////////////////////////////
			// check if the quick function can be applied.
			/////////////////////////////////////////////////////////////////////////
			if (mu.NoElements == 1) 
			{
				double dSigma = Math.Sqrt (Sigma [0, 0]);
				if (u [0] == double.PositiveInfinity) 
				{
					aResult.Z = Phi ((mu [0] - l [0]) / dSigma);
					aResult.mu = mu [0] + dSigma * v (mu [0] / dSigma, l [0] / dSigma);
					aResult.Sigma = Sigma [0, 0] * (1 - w (mu [0] / dSigma, l [0] / dSigma));
					return aResult;
				}
				if (l [0] == -u [0])
				{
					aResult.Z = Phi ((u [0] - mu [0]) / dSigma) - Phi ((l [0] - mu [0]) / dSigma);
					aResult.mu = mu [0] + dSigma * v0 (mu [0] / dSigma, u [0] / dSigma);
					aResult.Sigma = Sigma [0, 0] * (1 - w0 (mu [0] / dSigma, u [0] / dSigma));
					return aResult;
				}

				// general case
				aResult.Z = Phi ((u [0] - mu [0]) / dSigma) - Phi ((l [0] - mu [0]) / dSigma);
				aResult.mu = mu [0] + dSigma * v (mu [0] / dSigma, l [0] / dSigma, u [0] / dSigma);
				aResult.Sigma = Sigma [0, 0] * (1 - w (mu [0] / dSigma, l [0] / dSigma, u [0] / dSigma));
				return aResult;
			}

			////////////////////////////////////////////////////////////
			// Initialise
			/////////////////////////////////////////////////////////////
			double [] dSiteMu = new double [iNumberOfDimensions];
			double [] dSitePrecision = new double [iNumberOfDimensions];
			double [] dSiteScaling = new double [iNumberOfDimensions];
			Matrix t = new Matrix (iNumberOfDimensions, 1);
			Matrix T = new Matrix (iNumberOfDimensions, iNumberOfDimensions);
 
			////////////////////////////////////////////////////////////
			// Main loop
			/////////////////////////////////////////////////////////////			
			for (int iIterations = 0; iIterations < iNumberOfIterations; iIterations++) 
				for (int iDimension = 0; iDimension < iNumberOfDimensions; iDimension++) 
				{
					// Pre-computations
					for (int i = 0; i < iNumberOfDimensions; i++)
						t [i] = aResult.Sigma [i, iDimension];
					for (int i = 0; i < iNumberOfDimensions; i++)
						for (int j = 0; j < iNumberOfDimensions; j++)
							T [i, j] = t [i] * t [j];
					double dD = dSitePrecision [iDimension] * aResult.Sigma [iDimension, iDimension];
					double dE = 1.0 - dD;
					double dPhi = aResult.mu [iDimension] + dD * (aResult.mu [iDimension] - dSiteMu [iDimension]) / dE;
					double dPsi = aResult.Sigma [iDimension, iDimension] / dE;
					double dSqrtPsi = Math.Sqrt (dPsi);
					double dAlpha = 0.0, dBeta = 0.0;

					if (u [iDimension] == double.PositiveInfinity) 
					{
						dAlpha = v (dPhi / dSqrtPsi, l [iDimension] / dSqrtPsi) / dSqrtPsi;
						dBeta = w (dPhi / dSqrtPsi, l [iDimension] / dSqrtPsi) / dPsi;
					} 
					else if (l [iDimension] == -u [iDimension])
					{
						dAlpha = v0 (dPhi / dSqrtPsi, u [iDimension] / dSqrtPsi) / dSqrtPsi;
						dBeta = w0 (dPhi / dSqrtPsi, u [iDimension] / dSqrtPsi) / dPsi;
					} 
					else 
					{
						dAlpha = v (dPhi / dSqrtPsi, l [iDimension] / dSqrtPsi, u [iDimension] / dSqrtPsi) / dSqrtPsi;
						dBeta = w (dPhi / dSqrtPsi, l [iDimension] / dSqrtPsi, u [iDimension] / dSqrtPsi) / dPsi;
					}

					// ADF update
					t.Mulitply ((dSitePrecision [iDimension] * (aResult.mu [iDimension] - dSiteMu [iDimension]) + dAlpha)/ dE);
					T.Mulitply ((dSitePrecision [iDimension] * dE - dBeta) / (dE * dE));
					aResult.mu.Add (t);
					aResult.Sigma.Add (T);

					// Factor update
					dSitePrecision [iDimension] = 1.0 / (1.0 / dBeta - dPsi);
					dSiteMu [iDimension] = dAlpha / dBeta + dPhi;
					dSiteScaling [iDimension] = (Phi ((u [iDimension] - dPhi) / dSqrtPsi) - Phi ((l [iDimension] - dPhi) / dSqrtPsi)) * 
						Math.Exp (dAlpha * dAlpha / (2.0 * dBeta)) / Math.Sqrt (1.0 - dPsi * dBeta);
				}

			// Compute the final normalisation constant
			Matrix SigmaInverse = Sigma.Inverse ();
			Matrix NewSigmaInverse = aResult.Sigma.Inverse ();
			double dB = (double) (mu.Transpose () * SigmaInverse * mu - aResult.mu.Transpose () * NewSigmaInverse * aResult.mu);
			double dS = 1.0;
			for (int i = 0; i < iNumberOfDimensions; i++) 
			{
				dB += dSitePrecision [i] * dSiteMu [i] * dSiteMu [i];
				dS *= dSiteScaling [i];
			}
			aResult.Z = dS * Math.Sqrt (aResult.Sigma.Determinant () / Sigma.Determinant ()) * Math.Exp (-1.0 / 2.0 * dB);

			// return the result
			return aResult;
		}

		/// <summary>
		/// Approximates a multivariate partial Gaussian integral.
		/// </summary>
		/// <param name="mu">Mean of the Gaussian distribution.</param>
		/// <param name="Sigma">Covariance of the Gaussian distribution.</param>
		/// <param name="l">Lower integration limits.</param>
		/// <param name="u">Upper integration limits.</param>
		/// <param name="iNumberOfIterations">Number of iterations over the list of integration limits. Usually, a value of 5 - 10 will work fine.</param>
		/// <returns>The integal of the multivariate Gaussian density between <c>l</c> and <b>u</b>.</returns>
		/// <remarks>This function implements the EP algorithm of Thomas P. Minka described in <i>T. P. Minka. A family of algorithms for approximate Bayesian 
		/// inference.</i> PhD thesis. MIT. 2001. Note that in the case of scalars, the number of iterations is automatically reduced to 1.</remarks>
		/// <exception cref="MatrixTypeException">Thrown if <c>mu</c>, <c>l</c> or <c>u</c> are not vectors
		/// or if <c>Sigma</c> is not a square matrix.</exception>
		/// <exception cref="MatrixSizeException">Thrown if <c>mu</c>, <c>l</c> or <c>u</c> are not the same number of rows as <c>Sigma</c>.</exception>
		public static double PhiEP (Matrix mu, Matrix Sigma, Matrix l, Matrix u, int iNumberOfIterations)
		{
			return CalculateTGAParameters (mu, Sigma, l, u, iNumberOfIterations).Z;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\progress\xrlEnumTitles.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlEnumTitles.cs
//
////////////////////////////////////////////////////////////////////

using System.Text;
using System.Web;
using Microsoft.Xbox.Diagnostics.Errors;
using Microsoft.Xbox.Progress.Contracts;
using Microsoft.Xbox.Progress.Service.Interfaces.UserTitles;
using Microsoft.Xbox.Progress.Service.UserTitles;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.progress.shim.fd;

namespace xonline.server.progress.fd
{
    public class XRLEnumTitles : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            EnumTitlesRequest req = new EnumTitlesRequest();
            EnumTitlesResponse resp = new EnumTitlesResponse();
            uint hr = HResult.XONLINE_E_STAT_ERROR;
            string[] locales;

            try
            {
                CallSource.Check(VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyUserId(req.UserId);

                hr = HResult.XONLINE_E_STAT_ERROR;

                if (req.LocaleId == 0)
                {
                    locales = SGInfo.GetUserLocaleList(req.UserId, false);
                }
                else
                {
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                ////Hack to make shim work same as old code.
                if (req.MaxTitles <= 0)
                    req.MaxTitles = 1;

                ServiceAdapter.CreateClaimsFromSGInfo(SGInfo.Current, req.UserId);
                IUserTitleServiceV1 svc = ProgressFrontEndApp.UserTitleServiceInstance;

                ReadUserTitlesResponseV1 titles = svc.ReadTitles(req.ForUserId,
                    locales,
                    req.StartingIndex,
                    req.MaxTitles);

                if (titles != null)
                {
                    if (titles.Error != null)
                    {
                        hr = ServiceAdapter.ConvertTitleErrorCodeTFSToXOnline(titles.Error);
                        throw new XRLExceptionWithoutEvent(hr,
                                "UserTitleServiceV1 API ReadTitles returned error :" + titles.Error.Id);
                    }
                    else
                    {
                        resp.Titles = ServiceAdapter.ConvertUserTitlesTFSToXOnline(titles.Titles);
                        resp.TitlesLen = (ushort)resp.Titles.Length;
                    }
                }

                hr = HResult.S_OK;
            }
            catch (ServiceExceptionWithEvent e)
            {
                hr = ServiceAdapter.ConvertTitleErrorCodeTFSToXOnline(e.Error);
                throw new XRLException(hr, (XEvent.Id)e.Event.Id,
                        "UserTitleServiceV1 API ReadTitles threw exception: " + e);
            }
            catch (ServiceException e)
            {
                hr = ServiceAdapter.ConvertTitleErrorCodeTFSToXOnline(e.Error);
                throw new XRLExceptionWithoutEvent(hr,
                        "UserTitleServiceV1 API ReadTitles threw exception: " + e);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch (XRLExceptionWithoutEvent e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"EUT|{0:x}|{1:x}|{2:x}|{3:x}|",
                    hr,
                    req.UserId,
                    req.ForUserId,
                    (null == resp.Titles ? 0 : resp.Titles.Length));

                if (resp.Titles != null)
                {
                    for (int i = 0; i < resp.Titles.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", resp.Titles[i].TitleId);

                        if (i != resp.Titles.Length - 1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.progresslog, sb.ToString());
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Progress, hr, resp);

        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\progress\xrlSyncAchievements.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncAchievements.cs
//
////////////////////////////////////////////////////////////////////

using System.Text;
using System.Web;
using Microsoft.Xbox.Diagnostics.Errors;
using Microsoft.Xbox.Progress.Contracts;
using Microsoft.Xbox.Progress.Errors;
using Microsoft.Xbox.Progress.Service.Achievements;
using Microsoft.Xbox.Progress.Service.Interfaces.Achievements;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.progress.shim.fd;

namespace xonline.server.progress.fd
{
    public class XRLSyncAchievements : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            SyncAchievementsRequest req = new SyncAchievementsRequest();
            SyncAchievementsResponse resp = new SyncAchievementsResponse();
            uint hr = HResult.E_FAIL;
            string[] locales;

            try
            {
                CallSource.Check(VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyUserId(req.UserId);

                ServiceAdapter.CreateClaimsFromSGInfo(SGInfo.Current, req.UserId);

                if (req.LocaleId == 0)
                {
                    locales = SGInfo.GetUserLocaleList(req.UserId, false);
                }
                else
                {
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                if (req.StartingIndex > 0)
                {
                    req.StartingIndex--;
                }

                IAchievementsServiceV1 svc = ProgressFrontEndApp.AchievementServiceInstance;
                SyncAchievementsResponseV1 svcResp = svc.SyncAchievements(
                            req.UserId,
                            locales,
                            req.TitleId,
                            ServiceAdapter.ConvertAchievementXOnlineToTFS(req.Achievements, req.TitleId),
                            req.Version,
                            req.StartingIndex,
                            XOn.XONLINE_MAX_ACHIEVEMENTS
                            );

                if (svcResp != null)
                {
                    if (svcResp.Error != null)
                    {
                        hr = ServiceAdapter.ConvertAchievementErrorCodeTFSToXOnline(svcResp.Error);
                        throw new XRLExceptionWithoutEvent(hr,
                                "AchievementsServiceV1 API SyncAchievements returned error :" + svcResp.Error.Id);
                    }
                    else if (svcResp.PagingInfo != null)
                    {
                        resp.Version = svcResp.Version;
                        resp.Achievements = ServiceAdapter.ConvertAchievementTFSToXOnline(svcResp.Achievements);
                        resp.TotalAchievements = (ushort)(svcResp.PagingInfo.TotalRecords > XOn.XONLINE_MAX_ACHIEVEMENTS ? XOn.XONLINE_MAX_ACHIEVEMENTS : svcResp.PagingInfo.TotalRecords);
                    }
                }

                hr = HResult.S_OK;
            }
            catch (ServiceExceptionWithEvent e)
            {
                hr = ServiceAdapter.ConvertAchievementErrorCodeTFSToXOnline(e.Error);
                throw new XRLException(hr, (XEvent.Id)e.Event.Id,
                        "AchievementsServiceV1 API SyncAchievements threw exception: " + e);
            }
            catch (ServiceException e)
            {
                ////Hacky logic to make InvalidTitleError as a normal call. 
                if (e.Error.Id != ProgressErrors.InvalidTitleError.Id)
                {
                    hr = ServiceAdapter.ConvertAchievementErrorCodeTFSToXOnline(e.Error);
                    throw new XRLExceptionWithoutEvent(hr,
                            "AchievementsServiceV1 API SyncAchievements threw exception: " + e);
                }
                else
                {
                    hr = HResult.S_OK;
                }
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch (XRLExceptionWithoutEvent e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"SUA|{0:x}|{1:x}|{2:x}|{3}|{4}|",
                    hr,
                    req.TitleId,
                    req.UserId,
                    req.Version,
                    resp.Version);

                if (req.Achievements != null)
                {
                    for (int i = 0; i < req.Achievements.Length; i++)
                    {
                        if (req.Achievements[i] == null)
                            sb.Append("null");
                        else
                            sb.AppendFormat("{0:x}", req.Achievements[i].AchievementId);

                        if (i != req.Achievements.Length - 1)
                            sb.Append(",");
                    }
                }

                sb.Append("|");

                if (resp.Achievements != null)
                {
                    for (int i = 0; i < resp.Achievements.Length; i++)
                    {
                        sb.AppendFormat("{0:x}", resp.Achievements[i].AchievementId);

                        if (i != resp.Achievements.Length - 1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.progresslog, sb.ToString());
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Progress, hr, resp);
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\progress\xrlSyncAvatarAssets.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// xrlSyncAvatarAssets.cs
//
////////////////////////////////////////////////////////////////////

using System.Text;
using System.Web;
using Microsoft.Xbox.Diagnostics.Errors;
using Microsoft.Xbox.Progress.Contracts;
using Microsoft.Xbox.Progress.Errors;
using Microsoft.Xbox.Progress.Service.AvatarAwards;
using Microsoft.Xbox.Progress.Service.Interfaces.AvatarAwards;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.progress.shim.fd;

namespace xonline.server.progress.fd
{
    public class XRLSyncAvatarAssets : IHttpHandler
    {

        public void ProcessRequest(HttpContext ctx)
        {
            SyncAvatarAssetRequest req = new SyncAvatarAssetRequest();
            SyncAvatarAssetResponse resp = new SyncAvatarAssetResponse();
            uint hr = HResult.E_FAIL;
            string[] locales;

            try
            {
                CallSource.Check(VirtualInterface.progressfd, VirtualInterface.progressfd_int);

                req.ReadFromRequest(ctx.Request);

                SGInfo.VerifyUserId(req.UserId);

                ServiceAdapter.CreateClaimsFromSGInfo(SGInfo.Current, req.UserId);

                if (req.LocaleId == 0)
                {
                    locales = SGInfo.GetUserLocaleList(req.UserId, false);
                }
                else
                {
                    locales = LocaleMapper.LocaleIdToString(req.LocaleId);
                }

                if (req.StartingIndex > 0)
                {
                    req.StartingIndex--;
                }

                IAvatarAwardsServiceV1 svc = ProgressFrontEndApp.AvatarAwardServiceInstance;
                SyncAvatarAwardsResponseV1 svcResp = svc.SyncAvatarAwards(
                            req.UserId,
                            locales,
                            req.TitleId,
                            req.Version,
                            ServiceAdapter.ConvertAvatarAwardXOnlineToTFS(req.AvatarAssets, req.TitleId),
                            req.StartingIndex,
                            XOn.XONLINE_MAX_AVATAR_ASSETS
                            );

                if (svcResp != null)
                {
                    if (svcResp.Error != null)
                    {
                        hr = ServiceAdapter.ConvertAvatarErrorCodeTFSToXOnline(svcResp.Error);
                        throw new XRLExceptionWithoutEvent(hr,
                                "AvatarAwardsServiceV1 API SyncAvatarAwards returned error :" + svcResp.Error.Id);
                    }
                    else if (svcResp.PagingInfo != null)
                    {
                        resp.Version = svcResp.Version;
                        resp.AvatarAssets = ServiceAdapter.ConvertAvatarAwardTFSToXOnline(svcResp.AvatarAwards);
                        if ((svcResp.PagingInfo.TotalRecords - req.StartingIndex) > resp.AvatarAssets.Length)
                        {
                            resp.MoreAvatarAssetPending = (uint)1;
                        }
                    }
                }

                hr = HResult.S_OK;
            }
            catch (ServiceExceptionWithEvent e)
            {
                hr = ServiceAdapter.ConvertAvatarErrorCodeTFSToXOnline(e.Error);
                throw new XRLException(hr, (XEvent.Id)e.Event.Id,
                        "AvatarAwardsServiceV1 API SyncAvatarAwards threw exception: " + e);
            }
            catch (ServiceException e)
            {
                ////Hacky logic to make InvalidTitleError as a normal call. 
                if (e.Error.Id != ProgressErrors.InvalidTitleError.Id)
                {
                    hr = ServiceAdapter.ConvertAvatarErrorCodeTFSToXOnline(e.Error);
                    throw new XRLExceptionWithoutEvent(hr,
                            "AvatarAwardsServiceV1 API SyncAvatarAwards threw exception: " + e);
                }
                else
                {
                    hr = HResult.S_OK;
                }
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            catch (XRLExceptionWithoutEvent e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendFormat(@"SUV|{0:x}|{1:x}|{2:x}|{3}|{4}|",
                    hr,
                    req.TitleId,
                    req.UserId,
                    req.Version,
                    resp.Version);

                if (req.AvatarAssets != null)
                {
                    for (int i = 0; i < req.AvatarAssets.Length; i++)
                    {
                        if (req.AvatarAssets[i] == null)
                            sb.Append("null");
                        else
                            sb.AppendFormat("{0:x}({1:x})", req.AvatarAssets[i].AvatarAssetOrdinal, req.AvatarAssets[i].BodyTypeMask);

                        if (i != req.AvatarAssets.Length - 1)
                            sb.Append(",");
                    }
                }

                sb.Append("|");

                if (resp.AvatarAssets != null)
                {
                    for (int i = 0; i < resp.AvatarAssets.Length; i++)
                    {
                        sb.AppendFormat("{0:x}({1:x})", resp.AvatarAssets[i].AvatarAssetOrdinal, resp.AvatarAssets[i].BodyTypeMask);

                        if (i != resp.AvatarAssets.Length - 1)
                            sb.Append(",");
                    }
                }

                Xom.Log(XomAreaName.progresslog, sb.ToString());
            }

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Progress, hr, resp);
        }

        // IsReusable
        // Returns if this object can be reused. Since the object doesn't hold
        // any state, this method always returns true
        public bool IsReusable
        {
            get { return true; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\PlayerSkills.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// PlayerSkills.cs		Management class for individual player skills
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;

namespace MSRC.Ranking
{
	/// <summary>
	/// A class which manages a chronological series of skills for a player. The date of a skill 
	/// will mean that the skill is valid until this date (including it) but nothing will be known 
	/// afterwards. Note that this class will only allow inserting new skills <c>after</c> the last 
	/// inserted skill. 
	/// </summary>
	public class PlayerSkills
	{
		/// <summary>
		/// A variable sized list of skills.
		/// </summary>
		ArrayList m_aPlayerSkillList;	
		/// <summary>
		/// A variable sized list of dates at which the skills are valid.
		/// </summary>
		ArrayList m_aDatesList;	
		/// <summary>
		/// The maximal length of the array lists. 
		/// </summary>
		int m_iMaxLength;
		/// <summary>
		/// The index of the current element.
		/// </summary>
		int m_iCurrentElementIndex;

		/// <summary>
		/// Construcuts a variable sized list of skills of given maximal length.
		/// </summary>
		public PlayerSkills () : this (int.MaxValue) {}

		/// <summary>
		/// Construcuts a variable sized list of skills of given maximal length.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the skill list is shorter than two elements.</exception>
		public PlayerSkills (int iMaxLength)
		{
			m_aPlayerSkillList = new ArrayList ();
			m_aDatesList = new ArrayList ();

			if (iMaxLength < 2)
				throw new ArgumentOutOfRangeException ("iMaxLength", iMaxLength, "A skill list must have at least two elements.");
			m_iMaxLength = iMaxLength;
			m_iCurrentElementIndex = -1;
		}

		/// <summary>
		/// Adds a new skill valid at a specified date.
		/// </summary>
		/// <param name="aSkill">The new skill.</param>
		/// <param name="aDate">Time at which the skill is valid.</param>
		/// <remarks>The date of a skill will mean that the skill is valid until this date (including it) but 
		/// nothing will be known afterwards.</remarks>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if <c>aDate</c>is before or at the latest inserted skill time.</exception>
		public void AddSkill (Skill aSkill, DateTime aDate)
		{
			if (this.LatestDate >= aDate)
				throw new ArgumentOutOfRangeException ("aDate", aDate, "New skills must be after the last inserted skill.");

			if (m_aPlayerSkillList.Count < m_iMaxLength) 
			{
				m_aPlayerSkillList.Add (aSkill);
				m_aDatesList.Add (aDate);
				m_iCurrentElementIndex = m_aPlayerSkillList.Count - 1;
			}
			else 
			{
				m_iCurrentElementIndex = (++m_iCurrentElementIndex) % m_iMaxLength;
				m_aPlayerSkillList [m_iCurrentElementIndex] = aSkill;
				m_aDatesList [m_iCurrentElementIndex] = aDate;
			}

			// done!
			return;
		}

		/// <summary>
		/// Clears (empties) the list of player skill.
		/// </summary>
		public void Clear ()
		{
			m_aPlayerSkillList.Clear ();
			m_aDatesList.Clear ();
			m_iCurrentElementIndex = -1;
		}

		/// <summary>
		/// The latest skill (or null if the list of skills is empty).
		/// </summary>
		public Skill LatestSkill
		{
			get 
			{
				if (m_aPlayerSkillList.Count == 0)
					return null;
				return (Skill) m_aPlayerSkillList [m_iCurrentElementIndex];
			}
		}

		/// <summary>
		/// The latest date (or 0 ticks if the list of skills is empty).
		/// </summary>
		public DateTime LatestDate
		{
			get 
			{
				if (m_aDatesList.Count == 0)
					return new DateTime (0L);
				return (DateTime) m_aDatesList [m_iCurrentElementIndex];
			}
		}

		/// <summary>
		/// Gets the latest skill until (and including) a specific date.
		/// </summary>
		/// <param name="aDate">The target date.</param>
		/// <returns>The skill that is nearest in the past to the target data or null if there is no skill.</returns>
		public Skill GetLatestSkill (DateTime aDate)
		{
			// scan backwards in time (exploit the ordering of the lists).
			int iCount = m_aDatesList.Count;
			for (int i = 0; i < iCount; i++)
				if (((DateTime) m_aDatesList [(m_iCurrentElementIndex - i) % iCount]) <= aDate)
					return ((Skill) m_aPlayerSkillList [(m_iCurrentElementIndex - i) % iCount]);

			// if the date was even before the first date that we knew anything about, then return null.
			return null;
		}

		/// <summary>
		/// Total number of skills.
		/// </summary>
		public int NumberOfSkills
		{
			get 
			{
				return m_aPlayerSkillList.Count;
			}
		}

		/// <summary>
		/// The list of skills sorted by chronologically.
		/// </summary>
		public Skill [] Skills
		{
			get 
			{
				int iCount = m_aPlayerSkillList.Count;
				ArrayList aSkills = new ArrayList (iCount);
				for (int i = 0; i < m_aPlayerSkillList.Count; i++)
					aSkills.Add (m_aPlayerSkillList [(m_iCurrentElementIndex + i + 1) % iCount]);
				return ((Skill []) aSkills.ToArray (typeof (Skill)));
			}
		}

		/// <summary>
		/// The sorted list of dates.
		/// </summary>
		public DateTime [] Dates
		{
			get 
			{
				int iCount = m_aDatesList.Count;
				ArrayList aDates = new ArrayList (iCount);
				for (int i = 0; i < m_aDatesList.Count; i++)
					aDates.Add (m_aDatesList [(m_iCurrentElementIndex + i + 1) % iCount]);
				return ((DateTime []) aDates.ToArray (typeof (DateTime)));
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\Matrix.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Matrix.cs			A light-weight matrix library
//
// 2004/2005 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Diagnostics;

namespace MSRC.Ranking.LinearAlgebra
{
	/// <summary>
	/// This enumeration represents the different type of matrices.
	/// </summary>
	public enum MatrixType
	{
		#region Matrix Type Enumerations
		/// <summary>
		/// A rectangular matrix (different number of rows and columns and at least two rows and two columns).
		/// </summary>
		RectangularMatrix,
		/// <summary>
		/// A square matrix (same number of rows and columns and at least two rows).
		/// </summary>
		SquareMatrix,
		/// <summary>
		/// A row vector (One row and at least two columns).
		/// </summary>
		RowVector,
		/// <summary>
		/// A column vector (One column and at least two rows).
		/// </summary>
		ColumnVector,
		/// <summary>
		/// A scalar (One row and one column).
		/// </summary>
		Scalar
		#endregion
	}

	/// <summary>
	/// This is an exception which is thrown whenever the matrix type does not agree.
	/// </summary>
	public class MatrixTypeException : Exception
	{
		#region Data declaration
		/// <summary>
		/// Actual type of matrix.
		/// </summary>
		MatrixType m_aActualMatrixType;
		/// <summary>
		/// Expected type of matrix.
		/// </summary>
		MatrixType m_aExpectedMatrixType;
		#endregion
		
		#region Constructor
		/// <summary>
		/// Constructs a new exception for matrix type problems.
		/// </summary>
		/// <param name="aActualMatrixType">Actual type of the matrix.</param>
		/// <param name="aExpectedMatrixType">Expected type of the matrix.</param>
		public MatrixTypeException (MatrixType aActualMatrixType, MatrixType aExpectedMatrixType) : 
			base ("Actual Matrix Type: [" + aActualMatrixType.ToString () + "] Expected Matrix Type: [" + aExpectedMatrixType.ToString () + "]")
		{
			m_aActualMatrixType = aActualMatrixType;
			m_aExpectedMatrixType = aExpectedMatrixType;
		}
		#endregion

		#region Properties
		/// <summary>
		/// Actual type of the matrix.
		/// </summary>
		public MatrixType ActualMatrixType 
		{
			get
			{
				return m_aActualMatrixType;
			}
		}
		/// <summary>
		/// Expected type of the matrix.
		/// </summary>
		public MatrixType ExpectedMatrixType
		{
			get 
			{
				return m_aExpectedMatrixType;
			}
		}
		#endregion
	}

	/// <summary>
	/// This is an exception which is thrown whenever the matrix size does not agree.
	/// </summary>
	public class MatrixSizeException : Exception
	{
		#region Data declaration
		/// <summary>
		/// Actual number of rows.
		/// </summary>
		int m_iActualNoRows;
		/// <summary>
		/// Actual number of columns.
		/// </summary>
		int m_iActualNoColumns;
		/// <summary>
		/// Expected number of rows.
		/// </summary>
		int m_iExpectedNoRows;
		/// <summary>
		/// Expected number of columns.
		/// </summary>
		int m_iExpectedNoColumns;
		#endregion
		
		#region Constructor
		/// <summary>
		/// Constructs a new exception for matrix size problems.
		/// </summary>
		/// <param name="iActualNoRows">Actual number of rows.</param>
		/// <param name="iActualNoColumns">Actual number of columns.</param>
		/// <param name="iExpectedNoRows">Expected number of rows.</param>
		/// <param name="iExpectedNoColumns">Expected number of columns.</param>
		public MatrixSizeException (int iActualNoRows, int iActualNoColumns, int iExpectedNoRows, int iExpectedNoColumns) : 
			base ("Actual Matrix Size: [" + iActualNoRows + "," + iActualNoColumns + "] Expected Matrix Size: [" + iExpectedNoRows + "," + iExpectedNoColumns + "]")
		{
			m_iActualNoRows = iActualNoRows;
			m_iActualNoColumns = iActualNoColumns;
			m_iExpectedNoRows = iExpectedNoRows;
			m_iExpectedNoColumns = iExpectedNoColumns;
		}
		#endregion

		#region Properties
		/// <summary>
		/// Actual number of rows.
		/// </summary>
		public int ActualNoRows
		{
			get
			{
				return m_iActualNoRows;
			}
		}

		/// <summary>
		/// Actual number of columns.
		/// </summary>
		public int ActualNoColumns
		{
			get
			{
				return m_iActualNoColumns;
			}
		}
		
		/// <summary>
		/// Expected number of rows.
		/// </summary>
		public int ExpectedNoRows
		{
			get
			{
				return m_iExpectedNoRows;
			}
		}

		/// <summary>
		/// Expected number of columns.
		/// </summary>
		public int ExpectedNoColumns
		{
			get
			{
				return m_iExpectedNoColumns;
			}
		}
		#endregion
	}

	/// <summary>
	/// This is an exception which is thrown whenever the matrix is not positive definite.
	/// </summary>
	public class MatrixNonPositiveDefiniteException : Exception
	{
		#region Constructor
		/// <summary>
		/// Constructs a new exception for a non-positive definite matrix problem.
		/// </summary>
		public MatrixNonPositiveDefiniteException () : base ("Matrix is not positive definite.") {}
		#endregion
	}

	/// <summary>
	/// A light-weight matrix class for  arbitrary sized matrices. Most of these functions are implemented in a 
	/// straighforward way and are not optimised for any particular target CPU architecture.
	/// </summary>
	public class Matrix 
	{
		#region Data declaration
		/// <summary>
		/// The raw values of the matrix.
		/// </summary>
		private double [,] m_dData;
		/// <summary>
		/// The type of the matrix.
		/// </summary>
		private MatrixType m_aType;
		#endregion

		#region Constructors
		/// <summary>
		/// Constructs a matrix with zeros entries.
		/// </summary>
		/// <param name="iNoRows">Number of rows.</param>
		/// <param name="iNoColumns">Number of columns.</param>
		public Matrix (int iNoRows, int iNoColumns)
		{
			m_dData = new double [iNoRows, iNoColumns];
			m_aType = GetMatrixType ();
			for (int i = 0; i < iNoRows; i++)
				for (int j = 0; j < iNoColumns; j++)
					this [i, j] = 0.0;
		}

		/// <summary>
		/// Constructs a square matrix.
		/// </summary>
		/// <param name="iNoRows">Number of rows and columns.</param>
		public Matrix (int iNoRows) : this (iNoRows, iNoRows) {}

		/// <summary>
		/// Constructs a square diagonal matrix.
		/// </summary>
		/// <param name="iNoRows">Number of rows and columns.</param>
		/// <param name="dDiagonal">The diagonal entry.</param>
		public Matrix (int iNoRows, double dDiagonal)
		{
			m_dData = new double [iNoRows, iNoRows];
			m_aType = GetMatrixType ();
			for (int i = 0; i < iNoRows; i++)
				for (int j = 0; j < iNoRows; j++)
					this [i, j] = (i != j)?0.0:dDiagonal;
		}

		/// <summary>
		/// Constructs a square diagonal matrix.
		/// </summary>
		/// <param name="dDiagonal">The diagonal of the matrix.</param>
		/// <remarks>This constructor allows different entries on the diagonal of the matrix.</remarks>
		public Matrix (double [] dDiagonal)
		{
			m_dData = new double [dDiagonal.Length, dDiagonal.Length];
			m_aType = GetMatrixType ();
			for (int i = 0; i < dDiagonal.Length; i++)
				for (int j = 0; j < dDiagonal.Length; j++)
					this [i, j] = (i != j)?0.0:dDiagonal[i];
		}

		/// <summary>
		/// Constructs a deep copy of a matrix.
		/// </summary>
		/// <param name="aMatrix">Matrix to be copied.</param>
		public Matrix (Matrix aMatrix)
		{
			m_dData = new double [aMatrix.NoRows, aMatrix.NoColumns];
			m_aType = aMatrix.Type;

			// copy the matrix one-by-one
			for (int i = 0; i < aMatrix.NoRows; i++)
				for (int j = 0; j < aMatrix.NoColumns; j++)
					this [i, j] = aMatrix.m_dData [i, j];
		}

		/// <summary>
		/// Constructs a shallow copy of a matrix.
		/// </summary>
		/// <param name="dData">Matrix data to be used.</param>
		public Matrix (double [,] dData)
		{
			m_dData = dData;
			m_aType = GetMatrixType ();
		}

		/// <summary>
		/// Determines the type of the matrix by looking at the number of rows and columns.
		/// </summary>
		/// <returns>The type of the matrix.</returns>
		private MatrixType GetMatrixType ()
		{
			if (this.NoRows == 1 && this.NoColumns == 1)
				return MatrixType.Scalar;
			if (this.NoRows == 1)
				return MatrixType.RowVector;
			if (this.NoColumns == 1)
				return MatrixType.ColumnVector;
			if (this.NoRows == this.NoColumns)
				return MatrixType.SquareMatrix;

			return MatrixType.RectangularMatrix;
		}
		#endregion

		#region Properties and Indexers
		/// <summary>
		/// The type of the matrix (based on number of rows and columns).
		/// </summary>
		public MatrixType Type
		{
			get
			{
				return m_aType;
			}
		}

		/// <summary>
		/// Indicator if the matrix is a row vector.
		/// </summary>
		public bool IsRowVector 
		{
			get 
			{
				return (this.Type == MatrixType.RowVector || this.Type == MatrixType.Scalar);
			}
		}

		/// <summary>
		/// Indicator if the matrix is a column vector.
		/// </summary>
		public bool IsColumnVector 
		{
			get 
			{
				return (this.Type == MatrixType.ColumnVector || this.Type == MatrixType.Scalar);
			}
		}
		
		/// <summary>
		/// Indicator whether or not the matrix is a vector.
		/// </summary>
		public bool IsVector 
		{
			get 
			{
				return this.IsRowVector || this.IsColumnVector;
			}
		}

		/// <summary>
		/// Number of rows.
		/// </summary>
		public int NoRows
		{
			get 
			{
				return m_dData.GetLength (0);
			}
		}

		/// <summary>
		/// Number of columns.
		/// </summary>
		public int NoColumns
		{
			get 
			{
				return m_dData.GetLength (1);
			}
		}

		/// <summary>
		/// Number of total elements of the matrix.
		/// </summary>
		public int NoElements
		{
			get 
			{
				return this.NoRows * this.NoColumns;
			}
		}

		/// <summary>
		/// Element in the zero-based row <c>iRowIndex</c> and zero-based column <c>iColumnIndex</c>.
		/// </summary>
		public double this[ int iRowIndex, int iColumnIndex] 
		{
			get 
			{
				return m_dData [iRowIndex, iColumnIndex];
			}
			set 
			{
				m_dData [iRowIndex, iColumnIndex] = value;
			}
		}

		/// <summary>
		/// Element at position <c>iIndex</c> if the matrix is vector. 
		/// </summary>
		/// <exception cref="MatrixTypeException">Thrown if the matrix is not a vector.</exception>
		public double this[ int iIndex] 
		{
			get 
			{
				if (this.IsRowVector)
					return m_dData [0, iIndex];
				if (this.IsColumnVector)
					return m_dData [iIndex, 0];
				throw new MatrixTypeException (this.Type, MatrixType.ColumnVector);
			}
			set 
			{
				if (this.NoRows == 1)
					m_dData [0, iIndex] = value;
				else if (this.NoColumns == 1)
					m_dData [iIndex, 0] = value;
				else throw new MatrixTypeException (this.Type, MatrixType.ColumnVector);
			}
		}
		#endregion

		#region Object related code
		/// <summary>
		/// Compares with another matrix.
		/// </summary>
		/// <param name="aMatrix">Matrix A.</param>
		/// <returns>Returns true if A is equal to the matrix in every element.</returns>
		override public bool Equals (object aMatrix)
		{
			Matrix A = (Matrix) aMatrix;

			// check that the matrix comparison can be carried out
			if ((A.NoRows != this.NoRows) || (A.NoColumns != this.NoColumns))
				return false;

			// compare the matrices elementwise
			for (int i = 0; i < A.NoRows; i++)
				for (int j = 0; j < A.NoColumns; j++)
					if (A [i, j] != this [i, j])
						return false;

			// if we reached here, the two matrices ARE the same
			return true;
		}

		/// <summary>
		/// Computes a new hash code for the matrix.
		/// </summary>
		/// <returns>The hash code as an integer.</returns>
		/// <remarks>This function simply computes the products of the number of rows and colums and adds the 
		/// first element (0,0) of the matrix in order to compute a hash code.</remarks>
		public override int GetHashCode()
		{
			// The hash code is the total number of elements plus the first element.
			if (NoRows > 0 && NoColumns > 0)
				return NoRows * NoColumns + (int) m_dData [0, 0];
			else
				return NoRows * NoColumns;
		}

		/// <summary>
		/// Creates a string representation of the matrix.
		/// </summary>
		/// <returns>A string showing the matrix elements.</returns>
		override public string ToString ()
		{
			string aResult = "";

			// build the string row after row
			for (int i = 0; i < this.NoRows; i++) 
			{
				for (int j = 0; j < this.NoColumns; j++) 
				{
					aResult += String.Format ("{0,-6:f}\t", m_dData [i, j]);
				}
				aResult += "\n";
			}

			return aResult;
		}
		#endregion

		#region Unary Operators
		/// <summary>
		/// The implicit cast of a matrix into a double array.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <returns>The elements of the matrix A as a double array.</returns>
		public static implicit operator double[,] (Matrix A)
		{
			return A.m_dData;
		}

		/// <summary>
		/// An explicit cast of a matrix into a double. 
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <returns>The only element of the matrix A as a double.</returns>
		/// <exception cref="MatrixTypeException">Thrown if the matrix is not a scalar (one row and one column).</exception>
		public static explicit operator double(Matrix A)
		{
			if (A.Type != MatrixType.Scalar)
				throw new MatrixTypeException (A.Type, MatrixType.Scalar);

			return A [0, 0];
		}

		/// <summary>
		/// The implicit case of a double array into a matrix.
		/// </summary>
		/// <param name="dData">The double array to be casted.</param>
		/// <returns>A new matrix object whose <c>Data</c> property points to the double array.</returns>
		public static implicit operator Matrix (double [,] dData)
		{
			return new Matrix (dData);
		}

		/// <summary>
		/// The implicit cast of a double into a matrix.
		/// </summary>
		/// <param name="x">The double to be casted.</param>
		/// <returns>A 1 x 1 matrix with the only element equal to <c>x</c>.</returns>
		public static implicit operator Matrix (double x)
		{
			Matrix A = new Matrix (1, 1);
			A [0] = x;
			return A;
		}

		/// <summary>
		/// Negates the matrix.
		/// </summary>
		public void Negate ()
		{
			// return the result in a new matrix
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < this.NoColumns; j++)
					this [i, j] = -this [i, j];
		}

		/// <summary>
		/// Negates a matrix.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <returns>Matrix A negated, that is -A.</returns>
		public static Matrix operator -(Matrix A)
		{
			// defer the work by making a deep copy
			Matrix B = new Matrix (A);
			B.Negate ();
			return B;
		}
		#endregion

		#region Binary Operators
		/// <summary>
		/// Compares two matrices.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="B">Matrix B.</param>
		/// <returns>Returns true if A is equal to B in every element.</returns>
		public static bool operator ==(Matrix A, Matrix B)
		{
			return A.Equals (B);
		}

		/// <summary>
		/// Compares two matrices.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="B">Matrix B.</param>
		/// <returns>Returns true if A is not equal to B in every element.</returns>
		public static bool operator !=(Matrix A, Matrix B)
		{
			return !(A.Equals (B));
		}

		/// <summary>
		/// Adds a matrix.
		/// </summary>
		/// <param name="A">Matrix to be added.</param>
		/// <exception cref="MatrixSizeException">Thrown if the matrix to be added is of different size.</exception>
		public void Add (Matrix A)
		{
			// check that the matrix addition can be carried out
			if ((A.NoRows != this.NoRows) || (A.NoColumns != this.NoColumns))
				throw new MatrixSizeException (A.NoRows, A.NoColumns, this.NoRows, this.NoColumns);

			// add the other matrices 
			for (int i = 0; i < A.NoRows; i++)
				for (int j = 0; j < A.NoColumns; j++)
					this [i, j] += A [i, j];
		}

		/// <summary>
		/// Adds two matrices.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="B">Matrix B.</param>
		/// <returns>The matrix sum of A and B, that is A + B.</returns>
		/// <exception cref="MatrixSizeException">Thrown if the two matrices are of different size.</exception>
		public static Matrix operator +(Matrix A, Matrix B)
		{
			// defer the work by making a deep copy
			Matrix C = new Matrix (A);
			C.Add (B);
			return C;
		}

		/// <summary>
		/// Subtracts a matrix.
		/// </summary>
		/// <param name="A">Matrix to be subtracted.</param>
		/// <exception cref="MatrixSizeException">Thrown if the matrix to be subtracted is of different size.</exception>
		public void Subtract (Matrix A)
		{
			// check that the matrix subtraction can be carried out
			if ((A.NoRows != this.NoRows) || (A.NoColumns != this.NoColumns))
				throw new MatrixSizeException (A.NoRows, A.NoColumns, this.NoRows, this.NoColumns);

			// subtracts the matrix
			for (int i = 0; i < A.NoRows; i++)
				for (int j = 0; j < A.NoColumns; j++)
					this [i, j] -= A [i, j];
		}

		/// <summary>
		/// Subtracts two matrices.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="B">Matrix B.</param>
		/// <returns>Matrix B subtracted from matrix B, that is A - B.</returns>
		/// <exception cref="MatrixSizeException">Thrown if the two matrices are of different size.</exception>
		public static Matrix operator -(Matrix A, Matrix B)
		{
			// defer the work by making a deep copy
			Matrix C = new Matrix (A);
			C.Subtract (B);
			return C;
		}

		/// <summary>
		/// Multiplies with a matrix from the right. 
		/// </summary>
		/// <param name="A">Matrix to be multiplied from the right.</param>
		/// <remarks>This will most likely change the size of the matrix.</remarks>
		/// <exception cref="MatrixSizeException">Thrown if the number of rows of <c>A</c> does not match the number of columns.</exception>
		public void Multiply (Matrix A)
		{
			// check that the matrix multiplication can be carried out
			if (this.NoColumns != A.NoRows)
				throw new MatrixSizeException (A.NoRows, A.NoColumns, this.NoColumns, A.NoColumns);

			// for multiplication we have to save the results in a new matrix since it does not work component-wise
			double [,] dData = new double [this.NoRows, A.NoColumns];
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < A.NoColumns; j++)
					for (int k = 0; k < this.NoColumns; k++)
						dData [i, j] += (this [i, k] * A [k, j]);

			// copy the new data (shallow)
			m_dData = dData;
			m_aType = GetMatrixType ();
		}

		/// <summary>
		/// Multiplies two matrices.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="B">Matrix B.</param>
		/// <returns>Matrix A times matrix B, that is A * B.</returns>
		/// <exception cref="MatrixSizeException">Thrown if the number of rows of <c>B</c> does not match the number of columns of <c>A</c>.</exception>
		public static Matrix operator *(Matrix A, Matrix B)
		{
			// defer the work by making a deep copy
			Matrix C = new Matrix (A);
			C.Multiply (B);
			return C;
		}

		/// <summary>
		/// Multiplies with a scalar, that is, each element of the matrix is multiplied by the scalar.
		/// </summary>
		/// <param name="x">The scaling factor.</param>
		public void Mulitply (double x)
		{
			// multiplies every element of the matrix
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < this.NoColumns; j++)
					this [i, j] *= x;
			
			// done!
			return;
		}

		/// <summary>
		/// Multiplies a matrix with a scalar.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="x">Scalar x.</param>
		/// <returns>Matrix A times scalar x, that is every element of A is multiplied by x.</returns>
		public static Matrix operator *(Matrix A, double x)
		{
			// defer the work by making a deep copy
			Matrix B = new Matrix (A);
			B.Mulitply (x);
			return B;
		}

		/// <summary>
		/// Multiplies a scalar with a matrix.
		/// </summary>
		/// <param name="x">Scalar x.</param>
		/// <param name="A">Matrix A.</param>
		/// <returns>Matrix A times scalar x, that is every element of A is multiplied by x.</returns>
		public static Matrix operator *(double x, Matrix A)
		{
			return (A * x);
		}

		/// <summary>
		/// Didives by a scalar, that is, every element is divided by the scalar.
		/// </summary>
		/// <param name="x">The scalar to be dividing by.</param>
		public void Divide (double x)
		{
			// divides every element of the matrix
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < this.NoColumns; j++)
					this [i, j] /= x;
		}

		/// <summary>
		/// Divides a matrix by a scalar.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="x">Scalar x.</param>
		/// <returns>Matrix A divided by scalar x, that is every element of A is divided by x.</returns>
		public static Matrix operator /(Matrix A, double x)
		{
			// defer the work by making a deep copy
			Matrix B = new Matrix (A);
			B.Divide (x);
			return B;
		}
		#endregion 

		#region Basic Matrix Functions
		/// <summary>
		/// Transposes the matrix.
		/// </summary>
		/// <returns>The transposed matrix.</returns>
		public Matrix Transpose ()
		{
			Matrix A = new Matrix (this.NoColumns, this.NoRows);

			// copy the matrix one-by-one
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < this.NoColumns; j++)
					A [j, i] = this [i, j];

			// return the pointer to the object
			return A;
		}

		/// <summary>
		/// Computes the Cholesky decomposition. 
		/// </summary>
		/// <returns>A lower triangular matrix containing the Cholesky decomposition.</returns>
		/// <remarks>This method does not check for the symmetry.</remarks>
		/// <exception cref="MatrixTypeException">Thrown if the matrix is not square.</exception>
		/// <exception cref="MatrixNonPositiveDefiniteException">Thrown if the matrix is not-positive definite.</exception>
		public Matrix Cholesky () 
		{
			// check that the matrix is square
			if (this.Type != MatrixType.SquareMatrix && this.Type != MatrixType.Scalar)
				throw new MatrixTypeException (this.Type, MatrixType.SquareMatrix);
				
			// compute the Cholesky factor
			Matrix L = new Matrix (this.NoRows);
			double dSum = 0.0;

			for (int i = 0; i < this.NoRows; i++) 
			{
				for (int j = i; j < this.NoRows; j++)
				{
					dSum = this [i, j];
					for (int k = 0; k < i; k++)
						dSum -= L [i, k] * L [j, k];

					if (i == j)
					{
						// diagonal entry
						if (dSum < 0.0) 
							throw new MatrixNonPositiveDefiniteException ();
						L [i, i] = System.Math.Sqrt (dSum);
					}
					else
						L [j, i] = dSum / L [i, i];

				}
			}

			// returns the Cholesky factor
			return L;
		}

		/// <summary>
		/// Computes the inverse of a square positive definite matrix. 
		/// </summary>
		/// <returns>The inverse of the matrix.</returns>
		/// <remarks>Note that the method does not check for the symmetry.</remarks>
		/// <exception cref="MatrixTypeException">Thrown if the matrix is not square.</exception>
		/// <exception cref="MatrixNonPositiveDefiniteException">Thrown if the matrix is not-positive definite.</exception>
		public Matrix Inverse ()
		{
			// the inverse Cholesky factor
			Matrix I = InverseCholeskyFactor ();

			// returns the inverse which is simple the inverse Cholesky factor multiplied with itself
			return (I.Transpose () * I);
		}

		/// <summary>
		/// Computes the inverse of the Cholesky factor of the matrix.  
		/// </summary>
		/// <returns>The inverse of the Cholesky factor of the matrix.</returns>
		/// <remarks>Note that the method does not check for the symmetry.</remarks>
		/// <exception cref="MatrixTypeException">Thrown if the matrix is not square.</exception>
		/// <exception cref="MatrixNonPositiveDefiniteException">Thrown if the matrix is not-positive definite.</exception>
		public Matrix InverseCholeskyFactor ()
		{
			Matrix I;

			// check that the matrix is square
			if (this.Type != MatrixType.SquareMatrix && this.Type != MatrixType.Scalar)
				throw new MatrixTypeException (this.Type, MatrixType.SquareMatrix);
				
			// have a very fast version if the matrix is actually a scalar
			if (this.NoRows == 1) 
			{
				I = new Matrix (this.NoRows, this.NoColumns);
				I [0] = System.Math.Sqrt (1.0 / this [0]);
			} 
			else 
			{

				// compute the Cholesky factor
				Matrix L = this.Cholesky ();

				// compute the inverse Cholesky factor by back-substitution
				I = new Matrix (this.NoRows);
				double dSum = 0.0;
				for (int i = 0; i < I.NoRows; i++)
				{
					I [i, i] = 1.0 / L [i, i];
					for (int j = i + 1; j < I.NoRows; j++)
					{
						dSum = 0.0;
						for (int k = i; k < j; k++)
							dSum -= L [j, k] * I [k, i];
						I [j, i] = dSum / L [j, j];
					}
				}
			}

			// return the inverse Cholesky factor
			return (I);
		}

		/// <summary>
		/// Computes the determinant of a positive semidefinite matrix.  
		/// </summary>
		/// <returns>The determinant of the matrix.</returns>
		/// <exception cref="MatrixTypeException">Thrown if the matrix is not square.</exception>
		/// <exception cref="MatrixNonPositiveDefiniteException">Thrown if the matrix is not-positive definite.</exception>
		public double Determinant ()
		{
			// check that the matrix is square
			if (this.Type != MatrixType.SquareMatrix && this.Type != MatrixType.Scalar)
				throw new MatrixTypeException (this.Type, MatrixType.SquareMatrix);
				
			// 1. Scalar case: Fast version 
			if (this.NoRows == 1) 
			{
				return this [0, 0];
			}
 
			// 2. 2 x 2 case: Fast version 
			if (this.NoRows == 2) 
			{
				return this [0, 0] * this [1, 1] - this [0, 1] * this [1, 0];
			} 

			// 3. General case: Via the Cholesky factor
			Matrix L = this.Cholesky ();

			// the determinant is the product of the square diagonal elements of the Cholesky factor
			double dDeterminant = 1.0;
			for (int i = 0; i < L.NoRows; i++)
				dDeterminant *= L [i, i] * L [i, i];

			// done!
			return (dDeterminant);
		}
		#endregion

		#region Matrix Value Checking Code
		/// <summary>
		/// Checks if any element of the matrix is not-a-number.
		/// </summary>
		/// <returns>Returns true the matrix contains at least one element that is not-a-number.</returns>
		public bool IsNaN ()
		{
			// compare the matrices elementwise
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < this.NoColumns; j++)
					if (double.IsNaN (this [i, j]))
						return true;

			// if we reached here, then the matrix contains no not-a-numbers
			return false;
		}

		/// <summary>
		/// Checks if any element of the matrix is infinity.
		/// </summary>
		/// <returns>Returns true the matrix contains at least one element that is infinity.</returns>
		public bool IsInfinity ()
		{
			// compare the matrices elementwise
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < this.NoColumns; j++)
					if (double.IsInfinity (this [i, j]))
						return true;

			// if we reached here, then the matrix contains no infinities
			return false;
		}
		#endregion 
        
        #region MATLAB writing code
        /// <summary>
        /// Converts a variable name to a valid variable name by changing all invalid characters with an underscore.
        /// </summary>
        /// <param name="szName">Variable name</param>
        /// <returns>A valid MATLAB variable name.</returns>
        private string ValidVariableName(string szName)
        {
            string szResult = "";

            for (int i = 0; i < szName.Length; i++)
                if (!Char.IsDigit(szName[i]) && !Char.IsLetter(szName[i]))
                    szResult += '_';
                else
                    szResult += szName[i];

            return szResult;
        }

        /// <summary>
        /// Generates a Matlab V5 compatiable data element.
        /// </summary>
        /// <param name="szName">Name of the matrix.</param>
        /// <returns>The byte array that can be used as a Matlab V5 data element (in a stream).</returns>
        public byte[] MatlabDataElement(string szName)
        {
            // convert to a valid variable name
            szName = ValidVariableName(szName);

            // pad the array name to an 8-byte border
            for (int i = 0; i < szName.Length % 8; i++)
                szName += (char)0;

            // compute total size of buffer
            byte[] aBuffer = new byte[8 * NoRows * NoColumns + 56 + szName.Length];

            // write the data type field
            BitConverter.GetBytes((int)14).CopyTo(aBuffer, 0);                      // 14 == miMATRIX
            BitConverter.GetBytes((int)(aBuffer.Length - 8)).CopyTo(aBuffer, 4);    // number of bytes 

            // write the array flags
            BitConverter.GetBytes((int)6).CopyTo(aBuffer, 8);                       // 6 == miUINT32
            BitConverter.GetBytes((int)8).CopyTo(aBuffer, 12);                      // 8 bytes to follow
            BitConverter.GetBytes((int)6).CopyTo(aBuffer, 16);                      // 6 == mxDOUBLE_CLASS

            // write the dimension field
            BitConverter.GetBytes((int)5).CopyTo(aBuffer, 24);                       // 5 == miINT32
            BitConverter.GetBytes((int)8).CopyTo(aBuffer, 28);                       // 8 bytes to follow
            BitConverter.GetBytes(NoRows).CopyTo(aBuffer, 32);                       // number of rows
            BitConverter.GetBytes(NoColumns).CopyTo(aBuffer, 36);                    // number of columns

            // write the matrix name
            BitConverter.GetBytes((int)1).CopyTo(aBuffer, 40);                       // 1 == miINT8
            BitConverter.GetBytes((int)szName.Length).CopyTo(aBuffer, 44);           // length of name in bytes
            for (int i = 0; i < szName.Length; i++)                                  // write tne name of the matrix
                aBuffer[48 + i] = (byte)szName[i];
            int iPointer = 48 + szName.Length;

            // write the matrix data
            BitConverter.GetBytes((int)9).CopyTo(aBuffer, iPointer);                        // 9 == miDOUBLE
            BitConverter.GetBytes((int)(8 * NoRows * NoColumns)).CopyTo(aBuffer, iPointer + 4);   // bytes to follow
            for (int i = 0, k = 0; i < NoColumns; i++)
                for (int j = 0; j < NoRows; j++, k++)
                    BitConverter.GetBytes((double)(m_dData[j, i])).CopyTo(aBuffer, iPointer + (k + 1) * 8);

            return aBuffer;
        }

        /// <summary>
        /// Generates a Matlab V5 comptabible header byte array.
        /// </summary>
        /// <param name="szCreatorComments">The comments that will go into the header of the Matlab file.</param>
        /// <returns>The header as a byte array.</returns>
        public static byte[] MatlabHeader(string szCreatorComments)
        {
            byte[] aHeader = new byte[128];

            if (szCreatorComments.Length > 115)
                szCreatorComments = szCreatorComments.Substring(0, 115);
            for (int i = 0; i < szCreatorComments.Length; i++)
                aHeader[i] = (byte)szCreatorComments[i];
            aHeader[124] = 0x00;
            aHeader[125] = 0x01;
            aHeader[126] = (byte)'I';
            aHeader[127] = (byte)'M';

            return aHeader;
        }
        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\MuSigmaRankingSystem.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// MuSigmaRankingSystem.cs			MuSigma Ranking system 
//
// 2004/2005 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Diagnostics;
using MSRC.Ranking.Skills;
using MSRC.Ranking.LinearAlgebra;
using MSRC.Ranking.Numerics;

namespace MSRC.Ranking.RankingSystems
{
	/// <summary>
	/// Different types of approximation algorithm for the multi-team case.
	/// </summary>
	public enum Algorithm 
	{
		#region Algorithm types
		/// <summary>
		/// Genz' algorithm as described in <i>A. Genz. Numerical Computation of Multivariate 
		/// Normal Probabilities.</i> 1992.
		/// </summary>
		GenzAlgorithm, 
		/// <summary>
		/// Gaussian EP algorithm as described in <i>T. P. Minka. A family of algorithms for approximate Bayesian 
		/// inference.</i> PhD thesis. MIT. 2001.
		/// </summary>
		EPAlgorithm,
		/// <summary>
		/// EP message passing algorithm. This algorithm is two orders of magnitudes faster than <c>EPAlgorithm</c>. 
		/// </summary>
		EPMessagePassing
	#endregion
	};

	/// <summary>
	/// A class that represents the MuSigma ranking system. This class manages a list of player skill lists. 
	/// Game outcomes will be incorporated by the MuSigma update equation. 
	/// </summary>
	public class MuSigmaRankingSystem : ProbabilisticRankingSystem
	{
		#region Class specific variable declarations
		/// <summary>
		/// The standard deviation of the performance distribution.
		/// </summary>
		double m_dBeta;
		/// <summary>
		/// The draw probability between any two teams.
		/// </summary>
		double m_dDrawProbability;
		/// <summary>
		/// The increase in standard deviation responsible for modelling the dynamics of the skill belief.
		/// </summary>
		double	m_dTau;
		/// <summary>
		/// The number of iterations of the numerical approximation code.
		/// </summary>
		int m_iNumberOfIterations;
		/// <summary>
		/// The particular algorithm used.
		/// </summary>
		Algorithm m_aApproximationAlgorithm;
		/// <summary>
		/// The mean of the prior skill belief.
		/// </summary>
		double m_dPriorMu;
		/// <summary>
		/// The standard deviation of the prior skill belief.
		/// </summary>
		double m_dPriorSigma;
		#endregion 

		#region Constructors
		/// <summary>
		/// Constructs a new instance of the MuSigma ranking system.
		/// </summary>
		/// <param name="aPlayerSkillsList">A list of player skill lists.</param>
		/// <param name="dPerformanceFactor">The performance in a single game relative to the prior standard deviation.</param>
		/// <param name="dDrawProbability">The probability that two equally skilled players will draw.</param>
		/// <param name="dLearningFactor">The change of skill in a single game relative to the prior standard deviation.</param>
		/// <param name="dNegativeSkillProbability">The prior belief that a player has a negative skill (important for team games).</param>
		/// <param name="dPriorSigma">The standard deviation of the prior skill belief.</param>
		/// <param name="aApproximationAlgorithm">The approximation algorithm used.</param>
		/// <param name="iNumberOfIterations">The number of iterations whenever numerical integration is used.</param>
		public MuSigmaRankingSystem (PlayerSkillsList aPlayerSkillsList, double dPerformanceFactor, 
			double dDrawProbability, double dLearningFactor, double dNegativeSkillProbability, double dPriorSigma, 
			Algorithm aApproximationAlgorithm, int iNumberOfIterations) : base (aPlayerSkillsList)
		{
			// copy the arguments
			PriorSigma = dPriorSigma;
			NegativeSkillProbability = dNegativeSkillProbability;
			PerformanceFactor = dPerformanceFactor;
			DrawProbability = dDrawProbability;
			LearningFactor = dLearningFactor;
			ApproximationAlgorithm = aApproximationAlgorithm;
			NumberOfIterations = iNumberOfIterations;
		}

		/// <summary>
		/// Constructs a new instance of the MuSigma ranking system with an empty player skill list using the EP message 
		/// passing algorithm.
		/// </summary>
		/// <param name="dPerformanceFactor">The performance in a single game relative to the prior standard deviation.</param>
		/// <param name="dDrawProbability">The probability that two equally skilled players will draw.</param>
		/// <param name="dLearningFactor">The change of skill in a single game relative to the prior standard deviation.</param>
		/// <param name="dNegativeSkillProbability">The prior belief that a player has a negative skill (important for team games).</param>
		/// <param name="dPriorSigma">The standard deviation of the prior skill belief.</param>
		public MuSigmaRankingSystem (double dPerformanceFactor, double dDrawProbability, double dLearningFactor, 
			double dNegativeSkillProbability, double dPriorSigma) : this (null, dPerformanceFactor, dDrawProbability, dLearningFactor,
			dNegativeSkillProbability, dPriorSigma, Algorithm.EPMessagePassing, 20) {}

		/// <summary>
		/// Constructs a new instance of the MuSigma ranking system with an empty player skill list using the 
		/// EP message passing algorithm and a unit variance prior skill belief with ~0.1% chance of negative skills.
		/// </summary>
		/// <param name="dPerformanceFactor">The performance in a single game relative to the prior standard deviation.</param>
		/// <param name="dDrawProbability">The probability that two equally skilled players will draw.</param>
		/// <param name="dLearningFactor">The change of skill in a single game relative to the prior standard deviation.</param>
		public MuSigmaRankingSystem (double dPerformanceFactor, double dDrawProbability, double dLearningFactor) : 
			this (dPerformanceFactor, dDrawProbability, dLearningFactor, 0.0013498980316300954, 1.0) {}

		/// <summary>
		/// Constructs a new instance of the MuSigma ranking system with an empty player skill list using the EP 
		/// message passing algorithm and a unit variance prior skill belief with ~0.1% chance of negative skills. 
		/// The performance factor is set to 50%, the draw probability to 10% and the learning factor is at 1%.
		/// </summary>
		public MuSigmaRankingSystem () : this (0.5, 0.1, 0.01) {}
		#endregion

		#region Properties code
		/// <summary>
		/// The standard deviation of the performance distribution.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the standard deviation is set to a negative value.</exception>
		public double Beta 
		{
			get 
			{
				return m_dBeta;
			}
			set 
			{
				if (value < 0.0)
					throw new ArgumentOutOfRangeException ("value", value, "Standard deviation of performance distribution must be positive.");
				m_dBeta = value;
			}
		}

		/// <summary>
		/// The draw probability between two equally skilled teams. 
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the draw probability is outside of [0,1).</exception>
		public double DrawProbability
		{
			get
			{
				return m_dDrawProbability;
			}
			set
			{
				if (value < 0.0 || value >= 1.0)
					throw new ArgumentOutOfRangeException ("value", value, "The draw probability must be between 0.0 and 1.0.");
				m_dDrawProbability = value;
			}
		}

		/// <summary>
		/// The increase in standard deviation of the skill belief (dynamics prior).
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the standard deviation in the skill belief is set to a negative value.</exception>
		public double Tau
		{
			get 
			{
				return m_dTau;
			}
			set 
			{
				if (value < 0.0)
					throw new ArgumentOutOfRangeException ("value", value, "Increase in standard deviation of the skill belief must be positive.");
				m_dTau = value;
			}
		}

		/// <summary>
		/// Number of iterations of the numerical approximation code.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the number of iterations is smaller than 20.</exception>
		public int NumberOfIterations
		{
			get 
			{
				return m_iNumberOfIterations;
			}
			set 
			{
				if (value < 20)
					throw new ArgumentOutOfRangeException ("value", value, "Number of iterations must be at least 20");
				m_iNumberOfIterations = value;
			}
		}

		/// <summary>
		/// Approximation algorithm for the multi-team and multi-player case.
		/// </summary>
		public Algorithm ApproximationAlgorithm
		{
			get 
			{
				return m_aApproximationAlgorithm;
			}
			set 
			{
				m_aApproximationAlgorithm = value;
			}
		}

		/// <summary>
		/// The mean of the prior skill belief.
		/// </summary>
		public double PriorMu
		{
			get
			{
				return m_dPriorMu;
			}
			set 
			{
				m_dPriorMu = value;
			}
		}
		/// <summary>
		/// The standard deviation of the prior skill belief.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the standard deviation is set to a negative value.</exception>
		public double PriorSigma
		{
			get
			{
				return m_dPriorSigma;
			}
			set
			{
				if (value < 0.0)
					throw new ArgumentOutOfRangeException ("value", value, "Standard deviation of prior skill belief must be positive.");
				m_dPriorSigma = value;
			}
		}

		/// <summary>
		/// The factor of performance variation relative to the prior standard deviation. A value close to zero
		/// inidicates that the performance in a single game is varying little around the actual skill of the players.
		/// This value should usually be between 0 and 1. Setting this property changes <seealso cref="Beta"/> for the current value
		/// of <seealso cref="PriorSigma"/>.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the performance factor is set to a negative value.</exception>
		public double PerformanceFactor 
		{
			get
			{
				return m_dBeta / m_dPriorSigma;
			}
			set
			{
				if (value < 0.0)
					throw new ArgumentOutOfRangeException ("value", value, "The performance factor must be positive.");
				m_dBeta = value * m_dPriorSigma;
			}
		}

		/// <summary>
		/// The factor of skill point variation relative to the prior standard deviation. A value close to zero
		/// inidicates that the true skill in a single game is varying little. This value should be very small; a value
		/// of more than 0.5 means that the true skill can change up/down by an entire prior standard deviation in a single 
		/// game. Setting this property changes <seealso cref="Tau"/> for the current value of <seealso cref="PriorSigma"/>.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the learning factor is set to a negative value.</exception>
		public double LearningFactor
		{
			get
			{
				return m_dTau / m_dPriorSigma;
			}
			set
			{
				if (value < 0.0)
					throw new ArgumentOutOfRangeException ("value", value, "The learning factor must be positive.");
				m_dTau = value * m_dPriorSigma;
			}
		}

		/// <summary>
		/// The probability that a player has negative skill points. This value should be extremely close to zero. Setting 
		/// this property changes <seealso cref="PriorMu"/> for the current value of <seealso cref="PriorSigma"/>.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the negative skill probability is set to a value outside (0,1].</exception>
		public double NegativeSkillProbability
		{
			get 
			{
				return GaussianApproximations.Phi (-PriorMu / PriorSigma);
			}
			set 
			{
				if (value <= 0.0 || value > 1.0)
					throw new ArgumentOutOfRangeException ("value", value, "The negative skill probability must be between 0.0 and 1.0.");
				m_dPriorMu = -PriorSigma * GaussianApproximations.PhiInverse (value);
			}
		}
		#endregion

        #region Internal game representation and skill belief specific code
        /// <summary>
		/// This struct holds the internal representation of a game in terms of matrices.
		/// </summary>
		private struct InternalGameRepresentation
		{
			/// <summary>
			/// A matrix with as many rows as players and as many column are there are teams (minus one).
			/// </summary>
			public Matrix A;
			/// <summary>
			/// The lower integration limits.
			/// </summary>
			public Matrix a;
            /// <summary>
            /// The upper integration limits.
            /// </summary>
            public Matrix b;
            /// <summary>
            /// The update factors.
            /// </summary>
            public Matrix updateFactors;
            /// <summary>
			/// A mapping from the index to the global player ID.
			/// </summary>
			public ArrayList iIndexToPlayerID;
		}

		/// <summary>
		/// Computes the internal game representation for a particular ranking.
		/// </summary>
		/// <param name="aGame">The game to be represented.</param>
		/// <param name="aRanking">The ranking of the game.</param>
		/// <returns>The internal game representation.</returns>
		/// <exception cref="Exception">Thrown if the game ends in a draw but the draw probability was set to zero.</exception>
		private InternalGameRepresentation ComputeInternalGameRepresentation (Game aGame, Ranking aRanking)
		{
			// cache the number of players and the number of teams (for performance reasons only)
			int iNumberOfPlayers = aGame.NumberOfPlayers;
			int iNumberOfTeams = aGame.NumberOfTeams;

			// initialise the internal game representation
			InternalGameRepresentation aResult;
			aResult.A = new Matrix (iNumberOfPlayers, iNumberOfTeams - 1);
			aResult.a = new Matrix (iNumberOfTeams - 1, 1);
            aResult.b = new Matrix (iNumberOfTeams - 1, 1);
            aResult.updateFactors = new Matrix (iNumberOfPlayers, 1);
            aResult.iIndexToPlayerID = new ArrayList (aGame.NumberOfPlayers);

			// get the final game ranking
			int [] iIndex = aRanking.Indicies;

			// main loop over all teams
			for (int i = 0, iTotalPlayerCount = 0; i < iNumberOfTeams; i++) 
			{
				// update the player ID mapping
				Team aTeamAtCurrentRank = aGame.GetTeam (iIndex [i]);
				aResult.iIndexToPlayerID.AddRange (aTeamAtCurrentRank.PlayerIDs);

				if (i < iNumberOfTeams - 1) 
				{
                    // get the update factors
                    for (int j = 0; j < aTeamAtCurrentRank.NumberOfPlayers; j++) aResult.updateFactors [j + iTotalPlayerCount] = aTeamAtCurrentRank.GetUpdateFactor (j);

                    // construct the next column of 'A' and the next entry for the integration boundaries 'a' and 'b'
					Team aTeamAtNextRank = aGame.GetTeam (iIndex [i + 1]);

                    // get the sum of the fractional game times for both teams
					double dTotalPlayingTime = 0.0;
					for (int j = 0; j < aTeamAtCurrentRank.NumberOfPlayers; j++) dTotalPlayingTime += aTeamAtCurrentRank.GetPlayerGameTimeFraction (j);
                    for (int j = 0; j < aTeamAtNextRank.NumberOfPlayers; j++) dTotalPlayingTime += aTeamAtNextRank.GetPlayerGameTimeFraction (j);

					// construct the jth column of 'A' and wokr out the integration limit
					double dEpsilon = 0.0;
					for (int j = 0; j < aTeamAtCurrentRank.NumberOfPlayers; j++) 
					{
						aResult.A [iTotalPlayerCount++, i] = 2.0 * aTeamAtCurrentRank.GetPlayerGameTimeFraction (j) / dTotalPlayingTime;
						dEpsilon += (aResult.A [iTotalPlayerCount - 1, i] * aResult.A [iTotalPlayerCount - 1, i]);
					}
					for (int j = 0; j < aTeamAtNextRank.NumberOfPlayers; j++) 
					{
						aResult.A [iTotalPlayerCount + j, i] = -2.0 * aTeamAtNextRank.GetPlayerGameTimeFraction (j) / dTotalPlayingTime;
						dEpsilon += (aResult.A [iTotalPlayerCount + j, i] * aResult.A [iTotalPlayerCount + j, i]);
					}
					dEpsilon = - Math.Sqrt (dEpsilon) * Beta * GaussianApproximations.PhiInverse ((1.0 - DrawProbability) / 2.0);

                    // get the update factors (for the next team)
                    for (int j = 0; j < aTeamAtNextRank.NumberOfPlayers; j++) aResult.updateFactors [j + iTotalPlayerCount] = aTeamAtNextRank.GetUpdateFactor (j);

					// set the integration boundaries
					switch (aRanking.GetWinner (iIndex [i], iIndex [i + 1])) 
					{
						case +1:
							aResult.a [i] = dEpsilon;
							aResult.b [i] = double.PositiveInfinity;
							break;
						case 0:
							if (DrawProbability == 0)
								throw new Exception ("The game ended in a draw but the draw probability was set to zero.");
							aResult.a [i] = -dEpsilon;
							aResult.b [i] = dEpsilon;
							break;
						default:
							// we should never get here
							Debug.Assert (false, "Internal error. Must be in the Rankings class.");
							break;
					}
				}
			}
			
			// return the results
			return aResult;
		}

		private struct InternalSkillBelief
		{
			/// <summary>
			/// Means of skill beliefs.
			/// </summary>
			public Matrix mu;
			/// <summary>
			/// Covariance matrix  of skill beliefs.
			/// </summary>
			public Matrix Sigma;
		}

		/// <summary>
		/// Gets the skill beliefs of all players participating in a game.
		/// </summary>
		/// <param name="aInternalGame">Internal representation of the game.</param>
		/// <param name="aDate">Date at which we would like to know the skill beliefs. If the time is at zero ticks, the latest 
		/// skill belief will be used.</param>
		/// <returns>An internal representation of the skill belief.</returns>
		/// <remarks>Note that this function already adds the amount of \tau^2 if it is queried for the latest skill beliefs.</remarks>
		private InternalSkillBelief GetSkillBelief (InternalGameRepresentation aInternalGame, DateTime aDate)
		{
			// get the total number of players
			int iNumberOfPlayers = aInternalGame.A.NoRows;

			// initialise the return structure
			InternalSkillBelief aResult;
			aResult.mu = new Matrix (iNumberOfPlayers, 1);
			aResult.Sigma = new Matrix (iNumberOfPlayers, iNumberOfPlayers);

			// get the skill beliefs from the list of player skill beliefs maintained by this ranking system
			for (int i = 0; i < iNumberOfPlayers; i++) 
			{
				MuSigmaSkill aMuSigmaSkill;
				if (aDate.Ticks == 0) 
				{
					aMuSigmaSkill = (MuSigmaSkill) (m_aPlayerSkillsList.GetPlayerSkills ((int) aInternalGame.iIndexToPlayerID [i]).LatestSkill);
					aResult.mu [i] = aMuSigmaSkill.Mu;
					aResult.Sigma [i, i] = aMuSigmaSkill.Sigma * aMuSigmaSkill.Sigma + Tau * Tau;
				}
				else 
				{
					aMuSigmaSkill = (MuSigmaSkill) (m_aPlayerSkillsList.GetPlayerSkills ((int) aInternalGame.iIndexToPlayerID [i]).GetLatestSkill (aDate));
					aResult.mu [i] = aMuSigmaSkill.Mu;
					aResult.Sigma [i, i] = aMuSigmaSkill.Sigma * aMuSigmaSkill.Sigma;
				}
			}

			// return the result
			return aResult;
		}
		#endregion

        #region 1 dimensional Gaussians and operations
        private class Gaussian
        {
            /// <summary>
            /// The precision times the mean of the Gaussian.
            /// </summary>
            private double m_dPrecisionMean;

            /// <summary>
            /// The precision of the Gaussian.
            /// </summary>
            private double m_dPrecision;

            /// <summary>
            /// Constructs a Gaussian.
            /// </summary>
            /// <param name="dPrecisionMean">Precision times the mean of the Gaussian</param>
            /// <param name="dPrecison">Precision of the Gaussian.</param>
            public Gaussian(double dPrecisionMean, double dPrecison)
            {
                m_dPrecisionMean = dPrecisionMean;
                m_dPrecision = dPrecison;
            }

            /// <summary>
            /// The mean of a Gaussian.
            /// </summary>
            public double Mean
            {
                get
                {
                    return m_dPrecisionMean / m_dPrecision;
                }
            }

            /// <summary>
            /// The precision times the mean of the Gaussian.
            /// </summary>
            public double PrecisionMean
            {
                get
                {
                    return m_dPrecisionMean;
                }
                set
                {
                    m_dPrecisionMean = value;
                }
            }

            /// <summary>
            /// The variance of a Gaussian.
            /// </summary>
            public double Variance
            {
                get
                {
                    return 1.0 / m_dPrecision;
                }
            }

            /// <summary>
            /// The standard deviation of a Gaussian.
            /// </summary>
            public double StdDev
            {
                get
                {
                    return Math.Sqrt(Variance);
                }
            }

            /// <summary>
            /// The precision of a Gaussian.
            /// </summary>
            public double Precision
            {
                get
                {
                    return m_dPrecision;
                }
                set
                {
                    m_dPrecision = value;
                }
            }

            /// <summary>
            /// Multiplies two Gaussians.
            /// </summary>
            /// <param name="D1">First Factor.</param>
            /// <param name="D2">Second Factor.</param>
            /// <returns>The product of the two Gaussians.</returns>
            static public Gaussian operator *(Gaussian D1, Gaussian D2)
            {
                return new Gaussian(D1.PrecisionMean + D2.PrecisionMean, D1.Precision + D2.Precision);
            }

            /// <summary>
            /// Divides two Gaussians.
            /// </summary>
            /// <param name="D1">Numerator Gaussian.</param>
            /// <param name="D2">Denominator Gaussian.</param>
            /// <returns>The division of the two Gaussians.</returns>
            static public Gaussian operator /(Gaussian D1, Gaussian D2)
            {
                return new Gaussian(D1.PrecisionMean - D2.PrecisionMean, D1.Precision - D2.Precision);
            }

            /// <summary>
            /// Computes the absolute difference between two Gaussians.
            /// </summary>
            /// <param name="D1">First Gaussian.</param>
            /// <param name="D2">Second Gaussian.</param>
            /// <returns>The absolute deviation of the two Gaussians in terms of their parameters.</returns>
            static public double operator -(Gaussian D1, Gaussian D2)
            {
                return Math.Max(Math.Abs(D1.PrecisionMean - D2.PrecisionMean), Math.Abs(D1.Precision - D2.Precision));
            }
        }
        #endregion 

        #region Partial Update Code
        /// <summary>
        /// Computes the new skill with partial updates.
        /// </summary>
        /// <param name="aBeforeUpdate">Gaussian skill belief before update.</param>
        /// <param name="aAfterUpdate">Gaussian skill belief after update.</param>
        /// <param name="dWeight">Partial weighting factor.</param>
        /// <returns>The interpolated skill.</returns>
        private Gaussian PartialUpdate(Gaussian aBeforeUpdate, Gaussian aAfterUpdate, double dWeight)
        {
            return new Gaussian(aBeforeUpdate.PrecisionMean + dWeight * (aAfterUpdate.PrecisionMean - aBeforeUpdate.PrecisionMean),
                aBeforeUpdate.Precision + dWeight * (aAfterUpdate.Precision - aBeforeUpdate.Precision));
        }
        #endregion

        #region Update code
        /// <summary>
		/// Updates the player skills given a particular game. This the general update equation for an arbitrary number
		/// of teams and players per team. This function also computes the evidence of this particular game.
		/// </summary>
		/// <param name="aGame">The game to be incorporated.</param>
		/// <param name="dEvidence">The evidence of the game (as an output parameter).</param>
		/// <exception cref="ArithmeticException">Thrown if some of the resulting MuSigma values would be NaN or if
		/// any other non-stable condition occurs.</exception>
		/// <returns>True is the update was performed.</returns>
		override public bool Update (Game aGame, out double dEvidence)
		{
			// initially, set the evidence to zero
			dEvidence = 0.0;

			// make sure that we at least add an entry for all those players who did not yet played 
			// because we DID learn that the player is in the system from this moment on regardless 
			// of the fact that we may not be able to update the score distribution
			int [] iPlayerIDs = aGame.PlayerIDs;
			for (int i = 0; i < iPlayerIDs.Length; i++) 
				if (m_aPlayerSkillsList.GetPlayerSkills (iPlayerIDs [i]).LatestSkill == null) 
					m_aPlayerSkillsList.GetPlayerSkills (iPlayerIDs [i]).AddSkill (new MuSigmaSkill (PriorMu, PriorSigma), aGame.Date);

			// indicate the the update could not be performed and exit if we have one team only
			if (aGame.NumberOfTeams <= 1)
				return false;
		
			// check if we want to use the fast EP message passing algorithm
			if (m_aApproximationAlgorithm == Algorithm.EPMessagePassing)
			{
				EPMessagePassingUpdate (aGame);
				dEvidence = 1.0;
				return true;
			}

			// This will indicate that we are interested in the latest skill belief
			DateTime aZeroTime = new DateTime (0);

			// Compute the internal game representation
			InternalGameRepresentation aGR = ComputeInternalGameRepresentation (aGame, aGame.Ranking);

			// Get the current skill beliefs
			InternalSkillBelief aS = GetSkillBelief (aGR, aZeroTime); 

			/////////////////////////////////////////////
			//  1. Compute u 
			//  2. Compute C and CInverse := C^{-1}
			//  3. Compute ACInverse := A * C^{-1}
			//  4. Compute v := ACInverse * (<u> - u)
			//  5. Compute W := ACInverse * (C - (<uu^T> - <u><u^T>)) * ACInverse^T
			/////////////////////////////////////////////
			Matrix u = aGR.A.Transpose () * aS.mu;
			Matrix C = aGR.A.Transpose () * (new Matrix (aS.Sigma.NoRows, Beta * Beta) + aS.Sigma) * aGR.A;
			Matrix CInverse = C.Inverse ();
			Matrix ACInverse = aGR.A * CInverse;
			Matrix v = null, W = null;

			switch (m_aApproximationAlgorithm) 
			{
				case Algorithm.GenzAlgorithm:
					GaussianApproximations.TGMoments aMoments;
					aMoments = GaussianApproximations.CalculateTGMoments (u, C, aGR.a, aGR.b, m_iNumberOfIterations); 
					v = ACInverse * (aMoments.M1 - u);
					W = ACInverse * ((C - (aMoments.M2 - aMoments.M1 * aMoments.M1.Transpose ())) * ACInverse.Transpose ());
					dEvidence = aMoments.M0;
					break;
				case Algorithm.EPAlgorithm:
					GaussianApproximations.TGAParameters aParameters;
					aParameters = GaussianApproximations.CalculateTGAParameters (u, C, aGR.a, aGR.b, m_iNumberOfIterations); 
					v = ACInverse * (aParameters.mu - u);
					W = ACInverse * ((C - aParameters.Sigma) * ACInverse.Transpose ());
					dEvidence = aParameters.Z;
					break;
			}

			// check for NaN's
			for (int i = 0; i < aS.mu.NoRows; i++)
				if (double.IsNaN (W [i, i]) || double.IsNaN (v [i]))
					throw new ArithmeticException ("EP numerically unstable. This may result from cheating and broken matchmaking.");
			
			// Write back the updated skill belief
			for (int i = 0; i < aS.mu.NoRows; i++)
			{
				double dMultiplicativeCorrection = (1.0 - aS.Sigma [i, i] * W [i, i]);
				double dAdditiveCorrection = aS.Sigma [i, i] * v [i];

				if (dMultiplicativeCorrection > 1.0) 
				{
					Console.WriteLine ("Multiplicative correction out of valid range (above): " + dMultiplicativeCorrection.ToString ());
					dMultiplicativeCorrection = 1.0;
				}
				if (dMultiplicativeCorrection < 0.0) 
				{
					Console.WriteLine ("Multiplicative correction out of valid range (below): " + dMultiplicativeCorrection.ToString ());
					dMultiplicativeCorrection = 0.0;
				}

                // construct the new skill by linear interpolation in the \mu/\sigma^2 - 1/\sigma^2 space
                double dSigmaSquaredBeforeUpdate = aS.Sigma[i, i] - Tau * Tau;
                double dMuBeforeUpdate = aS.mu[i];

                double dSigmaSquaredAfterUpdate = aS.Sigma[i, i] * dMultiplicativeCorrection;
                double dMuAfterUpdate = aS.mu [i] + dAdditiveCorrection;

                Gaussian aNewSkill = PartialUpdate (new Gaussian (dMuBeforeUpdate/dSigmaSquaredBeforeUpdate, 1.0/dSigmaSquaredBeforeUpdate), 
                    new Gaussian (dMuAfterUpdate/dSigmaSquaredAfterUpdate, 1.0/dSigmaSquaredAfterUpdate), aGR.updateFactors [i]);

				MuSigmaSkill aMuSigmaSkill = new MuSigmaSkill (aNewSkill.Mean, aNewSkill.StdDev);
				m_aPlayerSkillsList.GetPlayerSkills ((int) aGR.iIndexToPlayerID [i]).AddSkill (aMuSigmaSkill, aGame.Date.AddSeconds (+1));
			}

			// indicate the the update was performed.
			return true;
		}
		#endregion

		#region Fast Update code using Message Passing
		/// <summary>
		/// Updates the player skills given a particular game. This implementation uses message passing and is two
		/// orders of magnitudes faster than the general the general update equation for an arbitrary number
		/// of teams and players per team. 
		/// </summary>
		/// <param name="aGame">The game to be incorporated.</param>
		/// <exception cref="ArithmeticException">Thrown if some of the resulting MuSigma values would be NaN or if
		/// any other non-stable condition occurs.</exception>
		/// <returns>True is the update was performed.</returns>
		private void EPMessagePassingUpdate (Game aGame)
		{
			const double dCovergenceTolerance = 1e-6;

			#region Pre-computation code
			// get the final game ranking
			Ranking aRanking = aGame.Ranking;
			int [] iIndex = aRanking.Indicies;

			// Precompute some constants that get re-used
			double dBeta2 = Beta * Beta;
			double dTau2 = Tau * Tau;
			#endregion

			/////////////////////////////////////////////////////////
			// Create all necessary marginals 
			/////////////////////////////////////////////////////////
			Gaussian [] aInitialPlayerSkills = new Gaussian [aGame.NumberOfPlayers];
			Gaussian [] aPlayerSkills = new Gaussian [aGame.NumberOfPlayers];
			Gaussian [] aPlayerPerformances = new Gaussian [aGame.NumberOfPlayers];
			Gaussian [] aTeamPerformances = new Gaussian [aGame.NumberOfTeams];

			/////////////////////////////////////////////////////////
			// Create all necessary messages
			/////////////////////////////////////////////////////////
			Gaussian [] aPlayerSkillsToPlayerPerformanceMessage = new Gaussian [aGame.NumberOfPlayers];
			Gaussian [] aPlayerPerformanceToTeamPerformanceMessage = new Gaussian [aGame.NumberOfTeams];

			#region Pre-Processing schedule
			/////////////////////////////////////////////////////////
			// PRE-PROCESSING 1: Set the prior directly in the player skill nodes
			/////////////////////////////////////////////////////////
			for (int iTeamIdx = 0, k = 0; iTeamIdx < aGame.NumberOfTeams; iTeamIdx++)
			{
				int [] iPlayerIDs = aGame.GetTeam (iIndex [iTeamIdx]).PlayerIDs;
				for (int i = 0; i < iPlayerIDs.Length; i++, k++)
				{
					MuSigmaSkill aMuSigmaSkill = (MuSigmaSkill) m_aPlayerSkillsList.GetPlayerSkills (iPlayerIDs [i]).LatestSkill;
					double dInitialPlayerSkillPrecision = 1.0 / (aMuSigmaSkill.Sigma * aMuSigmaSkill.Sigma);
					double dInitialPlayerSkillPrecisionMean = dInitialPlayerSkillPrecision * aMuSigmaSkill.Mu;
					aInitialPlayerSkills [k] = new Gaussian (dInitialPlayerSkillPrecisionMean, dInitialPlayerSkillPrecision);

					double dPlayerSkillPrecision = 1.0 / (aMuSigmaSkill.Sigma * aMuSigmaSkill.Sigma + dTau2);
					double dPlayerSkillPrecisionMean = dPlayerSkillPrecision * aMuSigmaSkill.Mu;
					aPlayerSkills [k] = new Gaussian (dPlayerSkillPrecisionMean, dPlayerSkillPrecision);
				}
			}

			/////////////////////////////////////////////////////////
			// PRE-PROCESSING 2: Update the performances of each player
			/////////////////////////////////////////////////////////
			for (int i = 0; i < aPlayerSkills.Length; i++)
			{
				double dTmp = 1.0 / (1.0 + aPlayerSkills [i].Precision * dBeta2);
				aPlayerSkillsToPlayerPerformanceMessage [i] = new Gaussian (dTmp * aPlayerSkills [i].PrecisionMean, dTmp * aPlayerSkills [i].Precision);
				aPlayerPerformances [i] = new Gaussian (aPlayerSkillsToPlayerPerformanceMessage [i].PrecisionMean, aPlayerSkillsToPlayerPerformanceMessage [i].Precision);
			}

			/////////////////////////////////////////////////////////
			// PRE-PROCESSING 3: Update the performances of each team
			/////////////////////////////////////////////////////////
			double [] dTotalSquaredGameTime = new double [aGame.NumberOfTeams];
			for (int iTeamIdx = 0, k = 0; iTeamIdx < aGame.NumberOfTeams; iTeamIdx++)
			{
				// prepare the counting for the total game time of the team
				dTotalSquaredGameTime [iTeamIdx] = 0.0;

				double dTeamVariance = 0.0, dTeamMean = 0.0;
				Team aTeam = aGame.GetTeam (iIndex [iTeamIdx]);
				for (int i = 0; i < aTeam.NumberOfPlayers; i++, k++)
				{
					// update the total squared game time of the team
					double dTimeFraction = aTeam.GetPlayerGameTimeFraction (i);
					dTotalSquaredGameTime [iTeamIdx] += dTimeFraction * dTimeFraction;

					dTeamVariance += dTimeFraction * dTimeFraction / aPlayerPerformances [k].Precision;
					dTeamMean += dTimeFraction * aPlayerPerformances [k].PrecisionMean / aPlayerPerformances [k].Precision; 
				}
				aPlayerPerformanceToTeamPerformanceMessage [iTeamIdx] = new Gaussian (dTeamMean / dTeamVariance, 1.0 / dTeamVariance);
				aTeamPerformances [iTeamIdx] = new Gaussian (aPlayerPerformanceToTeamPerformanceMessage [iTeamIdx].PrecisionMean, aPlayerPerformanceToTeamPerformanceMessage [iTeamIdx].Precision);
			}

			/////////////////////////////////////////////////////////
			// PRE-PROCESSING 4: Precompute the epsilon draw margins
			/////////////////////////////////////////////////////////
			double [] dEpsilon = new double [aGame.NumberOfTeams - 1];
			for (int i = 0; i < dEpsilon.Length; i++)
				dEpsilon [i] = -Math.Sqrt (dTotalSquaredGameTime [i] + dTotalSquaredGameTime [i+1]) * Beta * GaussianApproximations.PhiInverse ((1.0 - DrawProbability) / 2.0);
			#endregion

			#region EP update loop schedule
			/////////////////////////////////////////////////////////
			// EP CHAIN SCHEDULE: Update the performances of each team to reflect the game outcome
			/////////////////////////////////////////////////////////
			UpdateTeamPerformance (aTeamPerformances, aRanking, iIndex, dEpsilon, dCovergenceTolerance);
			#endregion

			#region Post-Processing schedule
			/////////////////////////////////////////////////////////
			// POST-PROCESSING: Update the performances and skills of each player
			/////////////////////////////////////////////////////////
			for (int iTeamIdx = 0, k = 0; iTeamIdx < aGame.NumberOfTeams; iTeamIdx++)
			{
				double dTeamVariance = aPlayerPerformanceToTeamPerformanceMessage [iTeamIdx].Variance;
				double dTeamMean = aPlayerPerformanceToTeamPerformanceMessage [iTeamIdx].Mean;

				dTeamVariance += 1.0 / (aTeamPerformances [iTeamIdx].Precision - aPlayerPerformanceToTeamPerformanceMessage [iTeamIdx].Precision);
				dTeamMean += -1.0 * (aTeamPerformances [iTeamIdx].PrecisionMean - aPlayerPerformanceToTeamPerformanceMessage [iTeamIdx].PrecisionMean) / 
					(aTeamPerformances [iTeamIdx].Precision - aPlayerPerformanceToTeamPerformanceMessage [iTeamIdx].Precision);

				Team aTeam = aGame.GetTeam (iIndex [iTeamIdx]);
				for (int i = 0; i < aTeam.NumberOfPlayers; i++, k++)
				{
					double dTimeFraction = aTeam.GetPlayerGameTimeFraction (i);
                    double dUpdateFactor = aTeam.GetUpdateFactor (i);
					double dNewMessagePrecision = dTimeFraction * dTimeFraction / (dTeamVariance - dTimeFraction * dTimeFraction / aPlayerPerformances [k].Precision);
					double dNewMessagePrecisionMean = (dNewMessagePrecision > 0.0)?dNewMessagePrecision * 
						(aPlayerPerformances [k].PrecisionMean / aPlayerPerformances [k].Precision - dTeamMean / dTimeFraction) : 0.0;
					aPlayerPerformances [k].Precision += dNewMessagePrecision;
					aPlayerPerformances [k].PrecisionMean += dNewMessagePrecisionMean;
						
					double dTmp = 1.0 / (1.0 + (aPlayerPerformances [k].Precision - aPlayerSkillsToPlayerPerformanceMessage [k].Precision) * dBeta2);
					dNewMessagePrecision = dTmp * (aPlayerPerformances [k].Precision - aPlayerSkillsToPlayerPerformanceMessage [k].Precision);
					dNewMessagePrecisionMean = dTmp * (aPlayerPerformances [k].PrecisionMean - aPlayerSkillsToPlayerPerformanceMessage [k].PrecisionMean);
					aPlayerSkills [k].Precision += dNewMessagePrecision;
					aPlayerSkills [k].PrecisionMean += dNewMessagePrecisionMean;
                    Gaussian aNewSkill = PartialUpdate (aInitialPlayerSkills [k], aPlayerSkills [k], dUpdateFactor);

					// check for NaN in either the mean or the variance
					if (double.IsNaN (aNewSkill.Mean) || double.IsNaN (aNewSkill.Variance)) 
						throw new ArithmeticException ("EP numerically unstable. This may result from cheating and broken matchmaking.");
					else
						m_aPlayerSkillsList.GetPlayerSkills (aTeam.GetPlayerID (i)).AddSkill (new MuSigmaSkill (aNewSkill.Mean, aNewSkill.StdDev), aGame.Date.AddSeconds (+1));
				}
			}
			#endregion
		}

		/// <summary>
		/// This type is used to denote which factors/messages to update in a chain schedule
		/// </summary>
		private struct ChainScheduleEntry
		{
			/// <summary>
			/// If true, the difference factor is updated; otherwise the ranking factor.
			/// </summary>
			public bool DifferenceFactor;
			/// <summary>
			/// The factor index.
			/// </summary>
			public int Factor;
			/// <summary>
			/// The message index.
			/// </summary>
			public int Message;
		}

		/// <summary>
		/// Implements the chain schedule EP updates.
		/// </summary>
		/// <param name="aTeamPerformances">The prior team performances.</param>
		/// <param name="aRanking">The ranking outcome of the game.</param>
		/// <param name="iIndex">The pre-computed re-ordering of the teams.</param>
		/// <param name="dEpsilon">The draw margins between any pair of teams.</param>
		/// <param name="dConvergenceTolerance">The precision at which to stop the update.</param>
		private void UpdateTeamPerformance (Gaussian [] aTeamPerformances, Ranking aRanking, int [] iIndex, double [] dEpsilon, double dConvergenceTolerance)
		{
			/////////////////////////////////////////////////////////
			// Create the marginals and messages
			/////////////////////////////////////////////////////////
			Gaussian [] aTeamPerformanceDifference = new Gaussian [aTeamPerformances.Length - 1];
			Gaussian [,] aTeamPerformanceDifferenceFactorMessage = new Gaussian [aTeamPerformances.Length - 1, 3];
			Gaussian [] aRankingFactorMessage = new Gaussian [aTeamPerformances.Length - 1];
			for (int i = 0; i < aTeamPerformances.Length - 1; i++)
			{
				aTeamPerformanceDifference [i] = new Gaussian (0.0, 0.0);
				aRankingFactorMessage [i] = new Gaussian (0.0, 0.0);
				aTeamPerformanceDifferenceFactorMessage [i, 0] = new Gaussian (0.0, 0.0);
				aTeamPerformanceDifferenceFactorMessage [i, 1] = new Gaussian (0.0, 0.0);
				aTeamPerformanceDifferenceFactorMessage [i, 2] = new Gaussian (0.0, 0.0);
			}

			#region Chain creation code
			/////////////////////////////////////////////////////////
			// Create the chain schedule
			/////////////////////////////////////////////////////////
			ChainScheduleEntry [] aChainSchedule = null;
			if (aTeamPerformances.Length > 2) 
			{
				aChainSchedule = new ChainScheduleEntry [(aTeamPerformances.Length - 2) * 6];
				int k = 0;
				for (int i = 0; i < aTeamPerformances.Length - 2; i++, k+=3)
				{
					aChainSchedule [k].DifferenceFactor = true;
					aChainSchedule [k].Factor = i;
					aChainSchedule [k].Message = 0;

					aChainSchedule [k+1].DifferenceFactor = false;
					aChainSchedule [k+1].Factor = i;
					aChainSchedule [k+1].Message = 0;

					aChainSchedule [k+2].DifferenceFactor = true;
					aChainSchedule [k+2].Factor = i;
					aChainSchedule [k+2].Message = 2;
				}
				for (int i = aTeamPerformances.Length - 3; i >= 0; i--, k+=3)
				{
					aChainSchedule [k].DifferenceFactor = true;
					aChainSchedule [k].Factor = i + 1;
					aChainSchedule [k].Message = 0;

					aChainSchedule [k+1].DifferenceFactor = false;
					aChainSchedule [k+1].Factor = i + 1;
					aChainSchedule [k+1].Message = 0;

					aChainSchedule [k+2].DifferenceFactor = true;
					aChainSchedule [k+2].Factor = i + 1;
					aChainSchedule [k+2].Message = 1;
				}
			}
			else
			{
				aChainSchedule = new ChainScheduleEntry [2];
				aChainSchedule [0].DifferenceFactor = true;
				aChainSchedule [0].Factor = 0;
				aChainSchedule [0].Message = 0;

				aChainSchedule [1].DifferenceFactor = false;
				aChainSchedule [1].Factor = 0;
				aChainSchedule [1].Message = 0;
			}
			#endregion

			#region Chain execution code
			// save some pointers for faster access
			Gaussian aVariable = null, aMessage = null;
			Gaussian aVariable1 = null, aMessage1 = null, aVariable2 = null, aMessage2 = null;
			double dNewMessagePrecision = 0.0, dNewMessagePrecisionMean = 0.0;

			/////////////////////////////////////////////////////////
			// Main EP loop
			/////////////////////////////////////////////////////////
			for (int iIterations = 0; iIterations < m_iNumberOfIterations; iIterations++)
			{
				double dDelta = double.MinValue;

				for (int i = 0; i < aChainSchedule.Length; i++)
				{
					if (aChainSchedule [i].DifferenceFactor)
					{
						/////////////////////////////////////////////////////////
						// update the messages and marginals for the difference factor
						/////////////////////////////////////////////////////////
						double dFactor1 = 0.0, dFactor2 = 0.0;
 
						switch (aChainSchedule [i].Message)
						{
							case 0:
								aVariable = aTeamPerformanceDifference [aChainSchedule [i].Factor];
								aMessage = aTeamPerformanceDifferenceFactorMessage [aChainSchedule [i].Factor, 0];
								aVariable1 = aTeamPerformances [aChainSchedule [i].Factor];
								aMessage1 = aTeamPerformanceDifferenceFactorMessage [aChainSchedule [i].Factor, 1];
								dFactor1 = +1.0;
								aVariable2 = aTeamPerformances [aChainSchedule [i].Factor + 1];
								aMessage2 = aTeamPerformanceDifferenceFactorMessage [aChainSchedule [i].Factor, 2];
								dFactor2 = -1.0;
								break;
							case 1:
								aVariable = aTeamPerformances [aChainSchedule [i].Factor];
								aMessage = aTeamPerformanceDifferenceFactorMessage [aChainSchedule [i].Factor, 1];
								aVariable1 = aTeamPerformanceDifference [aChainSchedule [i].Factor];
								aMessage1 = aTeamPerformanceDifferenceFactorMessage [aChainSchedule [i].Factor, 0];
								dFactor1 = +1.0;
								aVariable2 = aTeamPerformances [aChainSchedule [i].Factor + 1];
								aMessage2 = aTeamPerformanceDifferenceFactorMessage [aChainSchedule [i].Factor, 2];
								dFactor2 = +1.0;
								break;
							case 2:
								aVariable = aTeamPerformances [aChainSchedule [i].Factor + 1];
								aMessage = aTeamPerformanceDifferenceFactorMessage [aChainSchedule [i].Factor, 2];
								aVariable1 = aTeamPerformanceDifference [aChainSchedule [i].Factor];
								aMessage1 = aTeamPerformanceDifferenceFactorMessage [aChainSchedule [i].Factor, 0];
								dFactor1 = -1.0;
								aVariable2 = aTeamPerformances [aChainSchedule [i].Factor];
								aMessage2 = aTeamPerformanceDifferenceFactorMessage [aChainSchedule [i].Factor, 1];
								dFactor2 = +1.0;
								break;
						}

						// compute new message parameters and changes in parameter
						dNewMessagePrecision = 1.0 / 
							(1.0 / (aVariable1.Precision - aMessage1.Precision) + 1.0 / (aVariable2.Precision - aMessage2.Precision));
						dNewMessagePrecisionMean = dNewMessagePrecision * 
							(dFactor1 * (aVariable1.PrecisionMean - aMessage1.PrecisionMean) / (aVariable1.Precision - aMessage1.Precision) +
							dFactor2 * (aVariable2.PrecisionMean - aMessage2.PrecisionMean) / (aVariable2.Precision - aMessage2.Precision));
						
						// work out the change in the precision and precison times mean
						double dPrecisionChange = dNewMessagePrecision - aMessage.Precision;
						double dPrecisionMeanChange = dNewMessagePrecisionMean - aMessage.PrecisionMean;						
						dDelta = Math.Max (dDelta, Math.Abs (dPrecisionChange));
						dDelta = Math.Max (dDelta, Math.Abs (dPrecisionMeanChange));

						// update the precision and precision times mean
						aMessage.Precision = dNewMessagePrecision;
						aMessage.PrecisionMean = dNewMessagePrecisionMean;
						aVariable.Precision += dPrecisionChange;
						aVariable.PrecisionMean += dPrecisionMeanChange;

					}
					else
					{
						/////////////////////////////////////////////////////////
						// update the messages and marginals for the ranking factor
						/////////////////////////////////////////////////////////
						aVariable = aTeamPerformanceDifference [aChainSchedule [i].Factor];
						aMessage = aRankingFactorMessage [aChainSchedule [i].Factor];
						double c = aVariable.Precision - aMessage.Precision;
						double sqrtC = Math.Sqrt (c);
						double d = aVariable.PrecisionMean - aMessage.PrecisionMean;
						double w, v;
						if (aRanking.GetWinner (iIndex [aChainSchedule [i].Factor], iIndex [aChainSchedule [i].Factor + 1]) != 0)
						{
							w = GaussianApproximations.w (d / sqrtC, dEpsilon [aChainSchedule [i].Factor] * sqrtC);
							v = GaussianApproximations.v (d / sqrtC, dEpsilon [aChainSchedule [i].Factor] * sqrtC);
						}
						else
						{
							w = GaussianApproximations.w0 (d / sqrtC, dEpsilon [aChainSchedule [i].Factor] * sqrtC);
							v = GaussianApproximations.v0 (d / sqrtC, dEpsilon [aChainSchedule [i].Factor] * sqrtC);
						}
						double dNewMarginalPrecision = c / (1.0 - w);
						double dNewMarginalPrecisionMean = (d + sqrtC * v) / (1.0 - w);

						// work out the change in the precision and precison times mean
						double dPrecisionChange = dNewMarginalPrecision - aVariable.Precision;
						double dPrecisionMeanChange = dNewMarginalPrecisionMean - aVariable.PrecisionMean;						
						dDelta = Math.Max (dDelta, Math.Abs (dPrecisionChange));
						dDelta = Math.Max (dDelta, Math.Abs (dPrecisionMeanChange));

						// update the precision and precision times mean
						aVariable.Precision = dNewMarginalPrecision;
						aVariable.PrecisionMean = dNewMarginalPrecisionMean;
						aMessage.Precision += dPrecisionChange;
						aMessage.PrecisionMean += dPrecisionMeanChange;
					}
				}

				if (dDelta < dConvergenceTolerance || aTeamPerformances.Length == 2)
					break;
			}
			#endregion

			#region Chain post-processing code
			// finally, update the winning's team performance and ...
			aVariable = aTeamPerformances [0];
			aMessage = aTeamPerformanceDifferenceFactorMessage [0, 1];
			aVariable1 = aTeamPerformanceDifference [0];
			aMessage1 = aTeamPerformanceDifferenceFactorMessage [0, 0];
			aVariable2 = aTeamPerformances [1];
			aMessage2 = aTeamPerformanceDifferenceFactorMessage [0, 2];
			dNewMessagePrecision = 1.0 / (1.0 / (aVariable1.Precision - aMessage1.Precision) + 1.0 / (aVariable2.Precision - aMessage2.Precision));
			dNewMessagePrecisionMean = dNewMessagePrecision * 
				((aVariable1.PrecisionMean - aMessage1.PrecisionMean) / (aVariable1.Precision - aMessage1.Precision) +
				(aVariable2.PrecisionMean - aMessage2.PrecisionMean) / (aVariable2.Precision - aMessage2.Precision));
			aVariable.Precision += dNewMessagePrecision - aMessage.Precision;
			aVariable.PrecisionMean += dNewMessagePrecisionMean - aMessage.PrecisionMean;
			aMessage.Precision = dNewMessagePrecision;
			aMessage.PrecisionMean = dNewMessagePrecisionMean;

			// update the losing's team performance 
			aVariable = aTeamPerformances [aTeamPerformances.Length - 1];
			aMessage = aTeamPerformanceDifferenceFactorMessage [aTeamPerformances.Length - 2, 2];
			aVariable1 = aTeamPerformanceDifference [aTeamPerformances.Length - 2];
			aMessage1 = aTeamPerformanceDifferenceFactorMessage [aTeamPerformances.Length - 2, 0];
			aVariable2 = aTeamPerformances [aTeamPerformances.Length - 2];
			aMessage2 = aTeamPerformanceDifferenceFactorMessage [aTeamPerformances.Length - 2, 1];
			dNewMessagePrecision = 1.0 / (1.0 / (aVariable1.Precision - aMessage1.Precision) + 1.0 / (aVariable2.Precision - aMessage2.Precision));
			dNewMessagePrecisionMean = dNewMessagePrecision * 
				(-(aVariable1.PrecisionMean - aMessage1.PrecisionMean) / (aVariable1.Precision - aMessage1.Precision) +
				(aVariable2.PrecisionMean - aMessage2.PrecisionMean) / (aVariable2.Precision - aMessage2.Precision));
			aVariable.Precision += dNewMessagePrecision - aMessage.Precision;
			aVariable.PrecisionMean += dNewMessagePrecisionMean - aMessage.PrecisionMean;
			#endregion
		}
		#endregion

		#region Ranking Probability code
		/// <summary>
		/// Computes the marginalised probability for some rankings for a given game.
		/// </summary>
		/// <param name="aGame">The game for which the ranking probabilities should be computed.</param>
		/// <param name="aRankings">A list of rankings for which the probability should be computed.</param>
		/// <returns>The probabilities of the specified rankings for the given game.</returns>
		/// <exception cref="ArgumentException">Thrown if the probabilities cannot be computed.</exception>
		public override double [] RankingProbability (Game aGame, Ranking [] aRankings)
		{
			// check that we can compute the probability of the outcome
			if (aGame.NumberOfTeams < 2)
				throw new ArgumentOutOfRangeException ("aGame", aGame.NumberOfTeams, "Probability of ranking can only be computed for 2 or more players.");

			// allocate the result 
			double [] dProbabilities = new double [aRankings.Length];

			for (int i = 0; i < aRankings.Length; i++) 
			{
				// Compute the internal game representation
				InternalGameRepresentation aGR = ComputeInternalGameRepresentation (aGame, aRankings [i]);

				// Get the current skill belief
				InternalSkillBelief aS = GetSkillBelief (aGR, aGame.Date); 

				// Compute u and C
				Matrix u = aGR.A.Transpose () * aS.mu;
				Matrix C = aGR.A.Transpose () * (new Matrix (aS.Sigma.NoRows, Beta * Beta) + aS.Sigma) * aGR.A;

				// Compute the probability
				
				switch (m_aApproximationAlgorithm) 
				{
					case Algorithm.GenzAlgorithm:
						dProbabilities [i] = GaussianApproximations.Phi (u, C, aGR.a, aGR.b, m_iNumberOfIterations);
						break;
					case Algorithm.EPAlgorithm:
						dProbabilities [i] = GaussianApproximations.PhiEP (u, C, aGR.a, aGR.b, m_iNumberOfIterations);
						break;
				}
			}

			// return the result
			return dProbabilities;
		}
		#endregion

		#region Matchmaking code
		/// <summary>
		/// Computes the quality of a match.
		/// </summary>
		/// <param name="aGame">The game to check.</param>
		/// <returns>A number between 0 and 1 which indicates the quality of the match (1 is the best possible 
		/// match and 0 is the worst possible match).</returns>
		/// <remarks>This functions computes the (normalised) probability of a joint draw of all teams.</remarks>
		public override double MatchQuality (Game aGame)
		{
			// Compute the internal game representation
			InternalGameRepresentation aGR = ComputeInternalGameRepresentation (aGame, aGame.Ranking);

			// Get the current skill beliefs
			InternalSkillBelief aS = GetSkillBelief (aGR, aGame.Date); 

			// auxcillary quality
			Matrix C1 = Beta * Beta * aGR.A.Transpose () * aGR.A;
			Matrix C2 = C1 + aGR.A.Transpose () * aS.Sigma * aGR.A;
			Matrix u = aGR.A.Transpose () * aS.mu;

			return Math.Exp (-1.0/2.0 * (double) (u.Transpose () * C2.Inverse () * u)) * 
				Math.Sqrt (C1.Determinant () / C2.Determinant ());
		}

		/// <summary>
		/// Computes the match quality between two players in the MuSigma system.
		/// </summary>
		/// <param name="aPlayer1Skill">MuSigma skill of player 1.</param>
		/// <param name="aPlayer2Skill">MuSigma skill of player 2.</param>
		/// <returns>A number between 0 and 1 which indicates the quality of the match (1 is the best possible 
		/// match and 0 is the worst possible match).</returns>
		/// <remarks>This function computes the (normalised) probability of drawing.</remarks>
		public override double MatchQuality (Skill aPlayer1Skill, Skill aPlayer2Skill)
		{
			// first, assume the the skills are actually MuSigma skills
			MuSigmaSkill aMuSigmaSkill1 = (MuSigmaSkill) aPlayer1Skill;
			MuSigmaSkill aMuSigmaSkill2 = (MuSigmaSkill) aPlayer2Skill;
			double dC1 = Math.Sqrt (aMuSigmaSkill1.Sigma * aMuSigmaSkill1.Sigma + aMuSigmaSkill2.Sigma * aMuSigmaSkill2.Sigma + 2.0 * Beta * Beta);
			double dC2 = Math.Sqrt (2.0) * Beta;
				
			// Compute the probability of draw for Epsilon -> 0.
			return Math.Exp (-(aMuSigmaSkill1.Mu - aMuSigmaSkill2.Mu) *  (aMuSigmaSkill1.Mu - aMuSigmaSkill2.Mu) / (2.0 * dC1 * dC1)) * dC2 / dC1;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\Ranking.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Ranking.cs		A class that represents a ranking between n elements.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;

namespace MSRC.Ranking
{
	/// <summary>
	/// A class that represents a ranking between n elements. In this class, rank 1 is assumed to be the highest rank. Moreover, it is possible
	/// that two elements are on the same rank. In this case, no rank gap is introduced; a valid ranking is thus 1,1,2,3 instead of 1,1,3,4.
	/// </summary>
	public class Ranking
	{
		/// <summary>
		/// The ranks of each element. Note that the ranks will always be between 1 and m_iRanks.Length.
		/// </summary>
		int	[] m_iRanks;

		/// <summary>
		/// Constructs an identity ranking between a specified number of elements. The first element will be of highest rank and
		/// the last element will be of lowest rank.
		/// </summary>
		/// <param name="iNumberOfElements">Number of elements.</param>
		public Ranking (int iNumberOfElements)
		{
			m_iRanks = new int [iNumberOfElements];

			for (int i = 0; i < m_iRanks.Length; i++)
				m_iRanks [i] = i + 1;
		}

		/// <summary>
		/// Constructs a ranking based on the values given in an vector of nunbers.
		/// </summary>
		/// <param name="iElements">A list of integers.</param>
		/// <remarks>This method will have to call sorting routines so it may become slow when passed a long list of integers!</remarks>
		public Ranking (int [] iElements) 
		{
			// if there are no elements to sort then 
			if (iElements.Length == 0)
				m_iRanks = new int [0];
			else 
			{
				m_iRanks = new int [iElements.Length];
				int [] iIndex = new int [iElements.Length];

				// construct an identity ranking
				for (int i = 0; i < iElements.Length; i++) 
					iIndex [i] = i;

				// sort the ranking
				Sort ((int []) iElements.Clone (), iIndex);

				// compute the ranks
				m_iRanks [iIndex [iElements.Length - 1]] = 1;
				for (int i = 1; i < m_iRanks.Length; i++) 
				{
					if (iElements [iIndex [iElements.Length - 1 - i]] < iElements [iIndex [iElements.Length - i]])
						m_iRanks [iIndex [iElements.Length - 1 - i]] = m_iRanks [iIndex [iElements.Length - i]] + 1;
					else	
						m_iRanks [iIndex [iElements.Length - 1 - i]] = m_iRanks [iIndex [iElements.Length - i]];
				}
			}
		}

		/// <summary>
		/// Zero-based indicies which reflect the rankings.
		/// </summary>
		public int [] Indicies
		{
			get 
			{
				int [] iIndex = new int [m_iRanks.Length];

				for (int i = 0; i < m_iRanks.Length; i++) 
					iIndex [i] = i;

				Sort ((int []) m_iRanks.Clone (), iIndex);

				return iIndex;
			}
		}

		/// <summary>
		/// Number of elements in the ranking.
		/// </summary>
		public int NumberOfElements 
		{
			get 
			{
				return m_iRanks.Length;
			}
		}

		/// <summary>
		/// Computes the factorial of n.
		/// </summary>
		/// <param name="n">The parameter <c>n</c>.</param>
		/// <returns>The factorial of <c>n</c>.</returns>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if <c>n</c> is too large to represent n! as a long.</exception>
		private long Factorial (int n)
		{
			long [] lFactorial = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200};
			if (n >= lFactorial.Length)
				throw new ArgumentOutOfRangeException ("n", n, "Factorial cannot be represented by a long number.");

			return lFactorial [n];
		}

		/// <summary>
		/// Number of equivalent rankings.
		/// </summary>
		public long NumberOfEquivalenceClasses
		{
			get 
			{
				// get the rankings re-ordered
				int [] iRanks = (int []) m_iRanks.Clone ();
				Sort (iRanks);

				// compute the number of equivalence classes
				long iNumberOfEquivalenceClasses = 1;
				int k = 0;
				for (int i = 0; i < iRanks.Length; i++) 
				{
					if (iRanks [i] != iRanks [k]) 
					{
						iNumberOfEquivalenceClasses *= Factorial (i - k);
						k = i;
					}
				}
				iNumberOfEquivalenceClasses *= Factorial (iRanks.Length - k);

				return iNumberOfEquivalenceClasses;
			}
		}

		/// <summary>
		/// Compares the rank of two elements.
		/// </summary>
		/// <param name="i">Index of the first element.</param>
		/// <param name="j">Index of the second element.</param>
		/// <returns>Returns +1 is the first element is of higher rank than the second element, -1 if the 
		/// second element is of higher rank than the first element, or 0 if both elements are of same rank.</returns>
		public int GetWinner (int i, int j)
		{
			if (m_iRanks [i] < m_iRanks [j]) return +1;
			if (m_iRanks [i] > m_iRanks [j]) return -1;

			return 0;
		}

		/// <summary>
		/// Computes the difference to another ranking.
		/// </summary>
		/// <param name="aRanking">Ranking to be compared with.</param>
		/// <returns>A value between 0 and 1 indicating the difference between the two rankings.</returns>
		/// <remarks>The ranking difference will be computed as the fraction of pairs of elements where the two rankings disagree. This
		/// can be seen as the fractional difference between the number of swapping operations that bubble sort would take to sort each
		/// of the two rankings.</remarks>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the rankings differ in the number of elements.</exception>
		public double Difference (Ranking aRanking) 
		{
			if (aRanking.NumberOfElements != this.NumberOfElements)
				throw new ArgumentOutOfRangeException ("aRanking", aRanking.NumberOfElements, "Rankings are of different length.");

			// if there are not enough elements then the ranking is perfect
			if (aRanking.NumberOfElements < 2)
				return 0.0;

			// count the number of pairs which are differently ranked
			int iNumberOfDifferentPairs = 0;
			for (int i = 0; i < aRanking.NumberOfElements; i++)
				for (int j = i + 1; j < this.NumberOfElements; j++) 
					if (this.GetWinner (i, j) != aRanking.GetWinner (i, j))
						iNumberOfDifferentPairs++;

			// re-normalise
			return 2.0 * (double) iNumberOfDifferentPairs / (double) (this.NumberOfElements * (this.NumberOfElements - 1));
		}

		/// <summary>
		/// Bubble sort of a list of items relative to a list of keys. 
		/// </summary>
		/// <param name="iKeys">List of keys (this will be sorted in ascending order).</param>
		/// <param name="iItems">List of items (this will be sorted in ascending order relative to the list of keys).</param>
		/// <remarks>This sort is slow but stable (as opposed to <seealso cref="Array.Sort(Array, Array)"/>.</remarks>
		private void Sort (int [] iKeys, int [] iItems)
		{
			// consitency check
			if (iKeys.Length != iItems.Length)
				throw new ArgumentException ("Two arrays are not of equal length.");

			// run two nested for - loops
			for (int i = 0; i < iKeys.Length; i++) 
				for (int j = i + 1; j < iKeys.Length; j++)
				{
					if (iKeys [j] < iKeys [i]) 
					{
						int iTmp = iKeys [j];
						iKeys [j] = iKeys [i];
						iKeys [i] = iTmp;

						iTmp = iItems [j];
						iItems [j] = iItems [i];
						iItems [i] = iTmp;
					}
				}

			// done!
			return;
		}

		/// <summary>
		/// Bubble sort of a list of keys. 
		/// </summary>
		/// <param name="iKeys">List of keys (this will be sorted in ascending order).</param>
        /// <remarks>This sort is slow but stable (as opposed to <seealso cref="Array.Sort(Array, Array)"/>.</remarks>
		private void Sort (int [] iKeys)
		{
			// run two nested for - loops
			for (int i = 0; i < iKeys.Length; i++) 
				for (int j = i + 1; j < iKeys.Length; j++)
				{
					if (iKeys [j] < iKeys [i]) 
					{
						int iTmp = iKeys [j];
						iKeys [j] = iKeys [i];
						iKeys [i] = iTmp;
					}
				}

			// done!
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\MuSigmaSkill.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// MuSigmaSkill.cs		Class of a MuSigma skill belief.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;

namespace MSRC.Ranking.Skills
{
	/// <summary>
	/// A class to represent the skill belief in the MuSigma system, that is, the parameters \mu (mean) and \sigma (standard deviation) of 
	/// the Gaussian skill belief.
	/// </summary>
	public class MuSigmaSkill : Skill
	{
		/// <summary>
		/// The mean of the skill belief.
		/// </summary>
		double m_dMu;		
		/// <summary>
		/// The standard deviation of the skill belief.
		/// </summary>
		double m_dSigma;	

		/// <summary>
		/// Constructor which initialises mean and standard deviation of the skill belief.
		/// </summary>
		/// <param name="dMu">Mean of the skill belief.</param>
		/// <param name="dSigma">Standard deviation of the skill belief.</param>
		public MuSigmaSkill (double dMu, double dSigma)
		{
			m_dMu = dMu;
			m_dSigma = dSigma;
		}

		/// <summary>
		/// The mean of the skill belief.
		/// </summary>
		public double Mu 
		{
			get 
			{
				return m_dMu;
			}
		}

		/// <summary>
		/// The standard deviation of the skill belief.
		/// </summary>
		public double Sigma 
		{
			get 
			{
				return m_dSigma;
			}
		}

		/// <summary>
		/// Skill points of the player. 
		/// </summary>
		/// <remarks>The skill points of the player is the lower 99% quantile of the skill belief. This is a very conservative 
		/// estimate of the true skill of a player and should always lower bound the true skill.</remarks>
		override public double Points
		{
			get 
			{
				return m_dMu - 3.0 * m_dSigma;
			}
		}

		/// <summary>
		/// Skill level of the player. The skill level is obtained by mutliplying the skill points by dScaling and making 
		/// sure it never gets negative or above 50.
		/// </summary>
		/// <param name="dScaling">A scaling factor that is applied to the MuSigma skill points.</param>
		/// <returns>The level between 0 and 50.</returns>
		public override int GetLevel (double dScaling)
		{
			return Math.Min (Math.Max ((int) Math.Ceiling (Points * dScaling), 0), 50);
		}

		/// <summary>
		/// Fractional skill level of the player.
		/// </summary>
		/// <param name="dScaling">A scaling factor that is applied to the MuSigma skill points.</param>
		/// <returns>The fractional part of the skill points into the level.</returns>
		public override double GetFractionalLevel (double dScaling)
		{
			double dFractionalLevel = 1.0 - ((((double) (GetLevel (dScaling))) / dScaling - Points) * dScaling);
				
			return (dFractionalLevel > 1.0)?1.0:((dFractionalLevel < 0.0)?0.0:dFractionalLevel);
		}	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\RankingSystem.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// RankingSystem.cs			All abstract ranking system classes. 
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;

namespace MSRC.Ranking
{
	#region Ranking System
	/// <summary>
	/// The abstract base class that manages a list of player skill lists. A ranking system will allow to incorporate a game outcomes 
	/// an update the inidividual player skills accordingly. Moreover, a ranking system will offer a predicition of the outcome of the 
	/// game to support matchmaking mechanisms. 
	/// </summary>
	public abstract class RankingSystem
	{
		#region Variable declarations
		/// <summary>
		/// The list of player skill list.
		/// </summary>
		protected PlayerSkillsList m_aPlayerSkillsList;
		#endregion

		#region Constructors
		/// <summary>
		/// Constructs a ranking system for a given list of player skill lists.
		/// </summary>
		/// <param name="aPlayerSkillsList">A list of player skill lists. If the list is <c>null</c>, a new list of player
		/// skill lists will be created.</param>
		public RankingSystem (PlayerSkillsList aPlayerSkillsList)
		{
			if (aPlayerSkillsList == null)
				m_aPlayerSkillsList = new PlayerSkillsList ();
			else
				m_aPlayerSkillsList = aPlayerSkillsList;
		}

		/// <summary>
		/// Constructs a ranking system with a new list of player skill lists.
		/// </summary>
		public RankingSystem () : this (null) {}
		#endregion

		#region List Management Code
		/// <summary>
		/// Clears all the chronologically sorted skills of all the players maintained by this ranking system.
		/// </summary>
		public void ClearPlayerSkills () 
		{
			m_aPlayerSkillsList.ClearPlayerSkills ();
		}
		#endregion

		#region Update Code
		/// <summary>
		/// Updates the player skills with a particular game.
		/// </summary>
		/// <param name="aGame">The game to be incorporated.</param>
		/// <returns>True, if the update was performed.</returns>
		abstract public bool Update (Game aGame);
		#endregion

		#region Prediction Code
		/// <summary>
		/// Computes the most likely outcome of a game.
		/// </summary>
		/// <param name="aGame">The game for which the outcome should be predicted.</param>
		/// <returns>The most likely ranking.</returns>
		/// <remarks>Note that this function ignores the actual game outcome which is contained in the game passed to the method.
		/// The method is supposed to throw an exception if the outcome cannot be predicted.</remarks>
		abstract public Ranking PredictedOutcome (Game aGame);
		#endregion

		#region Matchmaking Code
		/// <summary>
		/// Computes the quality of a match.
		/// </summary>
		/// <param name="aGame">The game to check.</param>
		/// <returns>A number between 0 and 1 which indicates the quality of the match (1 is the best possible 
		/// match and 0 is the worst possible match).</returns>
		/// <remarks>This function computes the maximum discrepancy between any pair of players using the skills valid 
		/// at the time of the game. It is conceivable that a derived implementation of this method does a more careful 
		/// analysis.</remarks>
		public virtual double MatchQuality (Game aGame)
		{
			int [] iPlayerIDs = aGame.PlayerIDs;
			double dWorstQuality = 1.0;

			// loop over all combination of players
			for (int i = 0; i < iPlayerIDs.Length; i++) 
				for (int j = i + 1; j < iPlayerIDs.Length; j++)
				{
					Skill aSkill1 =  m_aPlayerSkillsList.GetPlayerSkills (iPlayerIDs [i]).GetLatestSkill (aGame.Date);
					Skill aSkill2 =  m_aPlayerSkillsList.GetPlayerSkills (iPlayerIDs [j]).GetLatestSkill (aGame.Date);
					dWorstQuality = Math.Min (MatchQuality (aSkill1, aSkill2), dWorstQuality);
				}

			// return the worst match quality between any pair of players
			return dWorstQuality;
		}

		/// <summary>
		/// Computes the match quality between two players.
		/// </summary>
		/// <param name="aPlayer1Skill">Skill of player 1.</param>
		/// <param name="aPlayer2Skill">Skill of player 2.</param>
		/// <returns>A number between 0 and 1 which indicates the quality of the match (1 is the best possible 
		/// match and 0 is the worst possible match).</returns>
		abstract public double MatchQuality (Skill aPlayer1Skill, Skill aPlayer2Skill);
		#endregion

		#region Properties
		/// <summary>
		/// The list of player skill lists maintained by the ranking system.
		/// </summary>
		public PlayerSkillsList PlayerSkillsList
		{
			get 
			{
				return m_aPlayerSkillsList;
			}
		}
		#endregion
	}
	#endregion

	#region Probabilistic Ranking System
	/// <summary>
	/// The abstract base class that manages a list of player skill lists. A probabilistic ranking system is a ranking system which is
	/// based on a probabilistic model of the game outcome. Hence, in such a ranking system it is possible to compute the probability of a
	/// particualr game outcome.
	/// </summary>
	public abstract class ProbabilisticRankingSystem : RankingSystem
	{
		#region Constructors
		/// <summary>
		/// Constructs a probabilistic ranking system for a given list of player skill lists.
		/// </summary>
		/// <param name="aPlayerSkillsList">A list of player skill lists. If this list is <c>null</c>, a new list of player
		/// skill lists will be created.</param>
		public ProbabilisticRankingSystem (PlayerSkillsList aPlayerSkillsList) : base (aPlayerSkillsList) {}

		/// <summary>
		/// Constructs a probabilistic ranking system with a new list of player skill lists.
		/// </summary>
		public ProbabilisticRankingSystem () : base () {}
		#endregion

		#region Ranking Probability Code
		/// <summary>
		/// Computes the probability for some rankings for a given game.
		/// </summary>
		/// <param name="aGame">The game for which the ranking probabilities should be computed.</param>
		/// <param name="aRankings">A list of rankings for which the probability should be computed.</param>
		/// <returns>The probabilities of the specified rankings for the given game. This method throws an exception if 
		/// the probabilities cannot be computed.</returns>
		abstract public double [] RankingProbability (Game aGame, Ranking [] aRankings);
		#endregion

		#region Update code
		/// <summary>
		/// Updates the player skills with a particular game.
		/// </summary>
		/// <param name="aGame">The game to be incorporated.</param>
		/// <returns>True, if the update was performed.</returns>
		/// <remarks>This method uses the evidence based <c>Update</c> method and should not be overriden!</remarks>
		public override bool Update(Game aGame)
		{
			double dTmp;
			return this.Update (aGame, out dTmp);
		}

		/// <summary>
		/// Updates the player skills with a particular game and computes the evidence of the game.
		/// </summary>
		/// <param name="aGame">The game to be incorporated.</param>
		/// <param name="dEvidence">The evidence of the game (as an output parameter).</param>
		/// <returns>True, if the update was performed.</returns>
		abstract public bool Update (Game aGame, out double dEvidence);
		#endregion

		#region Prediction Code
		/// <summary>
		/// Computes the most likely game outcome based on the probability for each ranking.
		/// </summary>
		/// <param name="aGame">The game for which the outcome should be predicted.</param>
		/// <returns>The most likely outcome.</returns>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the the game has more than two team.</exception>
		public override Ranking PredictedOutcome (Game aGame)
		{
			// check that we can compute the probability of the outcome
			if (aGame.NumberOfTeams != 2)
				throw new ArgumentOutOfRangeException ("aGame", aGame.NumberOfTeams, "Game outcomes can only be predicted for two-player games.");

			// enumerate all three rankings
			Ranking [] aRankings = new Ranking [3] {	
													   new Ranking (new int [2] {1, 0}),	// Team 1 wins
													   new Ranking (new int [2] {0, 1}),	// Team 2 wins
													   new Ranking (new int [2] {0, 0})		// Teams draw
												   }; 

			// compute the probabilities for all three outcomes
			double [] dProbabilities = RankingProbability (aGame, aRankings);

			// pick the maximum probability outcome
			if (dProbabilities [0] >= dProbabilities [1] && dProbabilities [0] >= dProbabilities [2])
				return aRankings [0];
			if (dProbabilities [1] >= dProbabilities [0] && dProbabilities [1] >= dProbabilities [2])
				return aRankings [1];

			return aRankings [2];
		}
		#endregion
	}
	#endregion 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\PlayerSkillsList.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// PlayerSkillsList.cs		Management functions for list of player skills
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;

namespace MSRC.Ranking
{
	/// <summary>
	/// A class that manages list of skills indexed by players. Each player will be identified by a unqiue player ID. This
	/// list is managing a chronologically sorted list of skills for each player. The PlayerSkills class and this class should not be confused: 
	/// Whereas the PlayerSkills class manages all skills of a single player in time, this class manages a list of PlayerSkills for all players.
	/// </summary>
	public class PlayerSkillsList
	{
		/// <summary>
		/// A variable sized mapping between player IDs and player skills.
		/// </summary>
		Hashtable m_aSkillsList;

		/// <summary>
		/// Constructs a variable sized list of skill lists.
		/// </summary>
		public PlayerSkillsList()
		{
			m_aSkillsList = new Hashtable ();
		}

		/// <summary>
		/// Clears (empties) the list of skill lists.
		/// </summary>
		public void Clear ()
		{
			m_aSkillsList.Clear ();
		}

		/// <summary>
		/// Clears (empties) the chronologically sorted list of skills for each player but retains
		/// its own internal list of skill lists.
		/// </summary>
		public void ClearPlayerSkills ()
		{
			IDictionaryEnumerator aEnumerator = m_aSkillsList.GetEnumerator ();
			while (aEnumerator.MoveNext ()) 
				((PlayerSkills) aEnumerator.Value).Clear ();
		}

		/// <summary>
		/// Adds a the chronologically sorted list of skills for a new player with a specified unique player index.
		/// </summary>
		/// <param name="aPlayerSkills">A chronologically sorted list of skills for the player.</param>
		/// <param name="iPlayerID">The unique player ID.</param>
		public void AddPlayerSkills (PlayerSkills aPlayerSkills, int iPlayerID)
		{
			m_aSkillsList.Add (iPlayerID, aPlayerSkills);
		}

		/// <summary>
		/// Gets the list of skills for a given player ID.
		/// </summary>
		/// <param name="iPlayerID">The unique player ID.</param>
		/// <returns>The chronologically sorted list of skills for the player with the specified ID or null if 
		/// the player does not exists.</returns>
		public PlayerSkills GetPlayerSkills (int iPlayerID)
		{
			if (!m_aSkillsList.ContainsKey (iPlayerID))
				return null;

			return (PlayerSkills) m_aSkillsList [iPlayerID];
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__ranking_2_none_12.4.56.0_none_a7cad4d98a3faff6
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_ranking_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680.manifest
XP_MANIFEST_PATH=manifests\x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680.cat
XP_CATALOG_PATH=manifests\x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680.cat
XP_PAYLOAD_PATH=x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_ranking_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\admin\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__ranking_2_none_12.4.56.0_none_a7cad4d98a3faff6
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_ranking_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680.manifest
XP_MANIFEST_PATH=manifests\x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680.cat
XP_CATALOG_PATH=manifests\x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680.cat
XP_PAYLOAD_PATH=x86__ranking_2_no-public-key_12.4.56.0_x-ww_c48c3680
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_ranking_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\Team.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Team.cs		Management functions for a single team.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;

namespace MSRC.Ranking
{
	/// <summary>
	/// A class to represent a team of players together with their scores, the fraction of total game length that the player 
	/// participated and the amount by which the players's skill should be updated. Each player will be represented by a 
    /// unique integer ID. The score will be an integer value. The fraction of game time will be a double value between
    /// 0 and 1. The amount by which the players's skill should be updated will be a double value between 0 and 1.
	/// </summary>
	public class Team
	{
		/// <summary>
		/// The variable size list of player ID's that form the team.
		/// </summary>
		ArrayList m_aPlayerID;	
		/// <summary>
		/// The variable size list of player scores for each player on the team. 
		/// </summary>
		ArrayList m_aScore;
		/// <summary>
		/// The variable size list of player's fraction of the total game time that they participated.
		/// </summary>
		ArrayList m_aGameTimeFraction;
		/// <summary>
		/// The variable size list of player's update factors.
		/// </summary>
		ArrayList m_aUpdateFactors;

		/// <summary>
		/// Construcuts a new team with a given maximal number of players.
		/// </summary>
		/// <param name="iMaxNumberOfPlayers">Maximal number of players.</param>
		/// <remarks>If more than the specified number of players are added an exception will be thrown.</remarks>
		public Team (int iMaxNumberOfPlayers)
		{
			m_aPlayerID = new ArrayList (iMaxNumberOfPlayers);
			m_aScore = new ArrayList (iMaxNumberOfPlayers);
			m_aGameTimeFraction = new ArrayList (iMaxNumberOfPlayers);
			m_aUpdateFactors = new ArrayList (iMaxNumberOfPlayers);
		}

		/// <summary>
		/// Construcuts a new team with a variable number of players.
		/// </summary>
		public Team ()
		{
			m_aPlayerID = new ArrayList ();
			m_aScore = new ArrayList ();
			m_aGameTimeFraction = new ArrayList ();
			m_aUpdateFactors = new ArrayList ();
		}

		/// <summary>
		/// Adds a new player to the team.
		/// </summary>
		/// <param name="iPlayerID">Player ID of the new player.</param>
		/// <param name="iScore">Score of the new player.</param>
		/// <param name="dGameTimeFraction">Fraction of total game length that the player participated.</param>
		/// <param name="dUpdateFactor">Update factor for this player.</param>
		/// <returns>The player index of the added player.</returns>
		/// <remarks>The player index must not be confused with the player ID. The player index is a zero-based
		/// internal index used by this class.</remarks>
        public int AddPlayer (int iPlayerID, int iScore, double dGameTimeFraction, double dUpdateFactor)
		{
			m_aPlayerID.Add (iPlayerID);
			m_aGameTimeFraction.Add (dGameTimeFraction);
            m_aUpdateFactors.Add (dUpdateFactor);
			return (m_aScore.Add (iScore));
		}

		/// <summary>
		/// Adds a new player to the team.
		/// </summary>
		/// <param name="iPlayerID">Player ID of the new player.</param>
		/// <param name="iScore">Score of the new player.</param>
		/// <param name="dGameTimeFraction">Fraction of total game length that the player participated.</param>
		/// <returns>The player index of the added player.</returns>
		/// <remarks>The player index must not be confused with the player ID. The player index is a zero-based
		/// internal index used by this class. The update factor is set to 100%.</remarks>
		public int AddPlayer (int iPlayerID, int iScore, double dGameTimeFraction)
		{
			return (AddPlayer (iPlayerID, iScore, dGameTimeFraction, 1.0));
		}

		/// <summary>
		/// Adds a new player to the team.
		/// </summary>
		/// <param name="iPlayerID">Player ID of the new player.</param>
		/// <param name="iScore">Score of the new player.</param>
		/// <returns>The player index of the added player.</returns>
		/// <remarks>The player index must not be confused with the player ID. The player index is a zero-based
		/// internal index used by this class. The fraction of total game length of participation and the update
		/// factor are set to 100%.
		/// </remarks>
		public int AddPlayer (int iPlayerID, int iScore)
		{
			return (AddPlayer (iPlayerID, iScore, 1.0));
		}

		/// <summary>
		/// Total number of players in the team.
		/// </summary>
		public int NumberOfPlayers
		{
			get 
			{
				return m_aPlayerID.Count;
			}
		}

		/// <summary>
		/// Score of the team.
		/// </summary>
		/// <remarks>The score of a team is always the the sum of the scores of all players in the team.</remarks>
		public int TeamScore 
		{
			get 
			{
				// do the summation by hand
				int iTotalScore = 0;
				for (int i = 0; i < m_aScore.Count; i++) iTotalScore += (int) m_aScore [i];

				return iTotalScore;
			}
		}

		/// <summary>
		/// Get the player ID for a player at specified index.
		/// </summary>
		/// <param name="iPlayer">The player index.</param>
		/// <returns>The global player ID or -1 if the index is out of range.</returns>
		/// <remarks>The player index must not be confused with the player ID. The player index is a zero-based
		/// internal index used by this class and increases everytime a player is added.</remarks>
		public int GetPlayerID (int iPlayer)
		{
			if (iPlayer < 0 || iPlayer > this.NumberOfPlayers)
				return -1;

			return (int) m_aPlayerID [iPlayer];
		}

		/// <summary>
		/// All player IDs for the entire team.
		/// </summary>
		public int [] PlayerIDs
		{
			get 
			{
				// copy them into an array
				int [] iPlayerIDs = new int [m_aPlayerID.Count];
				for (int i = 0; i < m_aPlayerID.Count; i++) iPlayerIDs [i] = (int) m_aPlayerID [i];

				return iPlayerIDs;
			}
		}

		/// <summary>
		/// Gets the score for the player at a specified index.
		/// </summary>
		/// <param name="iPlayer">The player index.</param>
		/// <returns>The score of the player.</returns>
		/// <remarks>The player index must not be confused with the player ID. The player index is a zero-based
		/// internal index used by this class and increases everytime a player is added.</remarks>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the player index is out of range.</exception>
		public int GetPlayerScore (int iPlayer)
		{
			if (iPlayer < 0 || iPlayer > this.NumberOfPlayers)
				throw new ArgumentOutOfRangeException ("iPlayer", iPlayer, "This value should be between 0 and " + (this.NumberOfPlayers - 1));

			return (int) m_aScore [iPlayer];
		}

		/// <summary>
		/// Scores for every player on the team.
		/// </summary>
		public int [] PlayerScores 
		{
			get 
			{
				// copy them into an array
				int [] iScores = new int [m_aScore.Count];
				for (int i = 0; i < m_aScore.Count; i++) iScores [i] = (int) m_aScore [i];

				return iScores;
			}
		}

		/// <summary>
		/// Gets the fraction of game length that the player at a specified index participated.
		/// </summary>
		/// <param name="iPlayer">The player index.</param>
		/// <returns>The fraction of total game time of participation.</returns>
		/// <remarks>The player index must not be confused with the player ID. The player index is a zero-based
		/// internal index used by this class and increases everytime a player is added.</remarks>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the player index is out of range.</exception>
		public double GetPlayerGameTimeFraction (int iPlayer)
		{
			if (iPlayer < 0 || iPlayer > this.NumberOfPlayers)
				throw new ArgumentOutOfRangeException ("iPlayer", iPlayer, "This value should be between 0 and " + (this.NumberOfPlayers - 1));

			return (double) m_aGameTimeFraction [iPlayer];
		}

		/// <summary>
		/// Fraction of game length that each player has participated.
		/// </summary>
		public double [] GameTimeFractions 
		{
			get 
			{
				// copy them into an array
				double [] dGameTimeFraction = new double [m_aGameTimeFraction.Count];
				for (int i = 0; i < m_aGameTimeFraction.Count; i++) dGameTimeFraction [i] = (double) m_aGameTimeFraction [i];

				return dGameTimeFraction;
			}
		}

		/// <summary>
		/// Gets the update factor of a player.
		/// </summary>
		/// <param name="iPlayer">The player index.</param>
		/// <returns>The update factor.</returns>
		/// <remarks>The player index must not be confused with the player ID. The player index is a zero-based
		/// internal index used by this class and increases everytime a player is added.</remarks>
		/// <exception cref="ArgumentOutOfRangeException">Thrown if the player index is out of range.</exception>
		public double GetUpdateFactor (int iPlayer)
		{
			if (iPlayer < 0 || iPlayer > this.NumberOfPlayers)
				throw new ArgumentOutOfRangeException ("iPlayer", iPlayer, "This value should be between 0 and " + (this.NumberOfPlayers - 1));

			return (double) m_aUpdateFactors [iPlayer];
		}

		/// <summary>
		/// Update factors for each player.
		/// </summary>
		public double [] UpdateFactors
		{
			get 
			{
				// copy them into an array
				double [] dUpdateFactors = new double [m_aUpdateFactors.Count];
				for (int i = 0; i < m_aUpdateFactors.Count; i++) dUpdateFactors [i] = (double) m_aUpdateFactors [i];

				return dUpdateFactors;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\ranking\Skill.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Skill.cs		Abstract base class of a player skill
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;

namespace MSRC.Ranking
{
	/// <summary>
	/// Abstract base class of all skills. Since we are interested in rankings, each skill must be convertible into a (skill) level 
	/// and a more fine-grained skill point measure. For example, the number of kills, the total ammount of experience points, etc. are valid 
	/// skill measures. Since we have both levels and skill points, a fractional level will tell us the fractional amount of difference 
	/// between the level and the skill points.
	/// </summary>
	abstract public class Skill
	{
		/// <summary>
		/// Default constructor.
		/// </summary>
		public Skill() {}

		/// <summary>
		/// The skill points of the player. 
		/// </summary>
		/// <remarks>Skill points are the exact, fine-grained summary of skill.</remarks>
		abstract public double Points
		{
			get;
		}

		/// <summary>
		/// A skill level of the player between 0 and 50.
		/// </summary>
		/// <param name="dScaling">Scaling factor of the points to map it to levels.</param>
		/// <returns>A level between 0 and 50.</returns>
		/// <remarks>Levels are the broad version of the skill points.</remarks>
		abstract public int GetLevel (double dScaling);

		/// <summary>
		/// The fractional difference between the level and the points. This value should always be between 0 and 1.
		/// </summary>
		/// <returns>The fractional part of the skill points into the current level.</returns>
		abstract public double GetFractionalLevel (double dScaling);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\admin\StatsXlastUtilTest.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

// From Test
using ServerTestFramework;
using ServerTestFramework.Utilities;

using xonline.common.diagnostics;
using xonline.common.leaderboard;
using xonline.common.livetitleconfig;
using xonline.common.xlastutil;

using xonline.stats.admin;

namespace xonline.server.stats.test.admin
{

    public class StatsXlastUtilTestSuite:TestSuite
    {
        public StatsXlastUtilTestSuite()
        {
            AddChild( new StatsXlastUtilTest());
            AddChild( new StatsAdminTest());
        }
    }


    public class StatsXlastUtilTest : TestNode
    {

        public const uint GoodTitleID = 0x80000312;
        public const uint BadTitleID  = 0x80000313;
        public string GoodXlast;
        public string BadXlast;
        public const string GoodXlastPath = "StatsXlastGoodXml.xlast";
        public const string BadXlastPath = "StatsXlastBadXml.xlast";

        public StatsXlastUtilTest() 
        { 
            Console.WriteLine( "In the Constructor" );   
 
            //read in xml, assign it to string
            Console.WriteLine("about to read file");
            StreamReader xlastReader = new StreamReader( GoodXlastPath );
            this.GoodXlast = xlastReader.ReadToEnd();
            xlastReader.Close();
            
            xlastReader = new StreamReader( BadXlastPath );
            this.BadXlast = xlastReader.ReadToEnd();
            Console.WriteLine("Bad string length is " + this.GoodXlast.Length );
            xlastReader.Close();

        }

        // executes once per test run
        [TestGroupSetup]
        public void StatsXlastUtilTestFixtureSetup()
        {
            Console.WriteLine( "In TestFixtureSetUp." );
        }


        // executes once at the end of all the tests
        [TestGroupTearDown]
        public void StatsXlastUtilTestFixtureTearDown()
        {
            Console.WriteLine( "In TestFixtureTearDown." );
        }

        //can we tell whether skill leaderboards have been created?
        [Test]
        public void SkillLbIdentificationTest()
        {
            Console.WriteLine("Starting SkillLbIdentificationTest.");

        }

        //can we create skill leaderboards correctly on the Xlast object?
        [Test]
        public void SkillLbCreationTest()
        {
            Console.WriteLine("Starting SkillLbCreationTest.");

        }


        //task: add tests to confirm skill lb's get extracted... 

        //test retrieving leaderboards from XLAST
        //confirm that getting leaderboards from xlast + ltc 
        // results in leaderboards with values from xlast, and server name from ltc
        [Test]
        public void GetXLASTLeaderboardConfiguration_test()
        {


            //get xlast
            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml( GoodXlast );

            //get ltc
            LiveTitleConfig ltc = LiveTitleConfig.GetLiveTitleConfigFromXlast( GoodXlast, "TESTSERVER", "TESTSERVER" );

            //test the per-leaderboard configuration ability
            //the text xlast has 26 lb's, so this should be fine... 
            ltc.LeaderboardConfigs[ 0 ].HostingLbs = "Server0";
            ltc.LeaderboardConfigs[ 1 ].HostingLbs = "Server1";
            ltc.LeaderboardConfigs[ 2 ].HostingLbs = "Server2";
            ltc.LeaderboardConfigs[ 3 ].HostingLbs = "Server3";
            ltc.LeaderboardConfigs[ 4 ].HostingLbs = "Server4";
            ltc.LeaderboardConfigs[ 5 ].HostingLbs = "Server5";

            //get leaderboard objects for this title from XLAST/LTC
            ArrayList xlastLb = StatsXlastUtil.ExtractLeaderboards( xlsp, ltc );

            //Test1: correct number of leaderboards?
            StatsView[] sv = xlsp.GameConfigProject.StatsViews.StatsView;
            Console.WriteLine(" SVXlast: " + sv.Length + "   lb: " + xlastLb.Count + "  ltc: " + ltc.LeaderboardConfigs.Length );
            Assert.IsTrue( xlastLb.Count == sv.Length );
            Assert.IsTrue( xlastLb.Count == ltc.LeaderboardConfigs.Length );


            //Test2: correct configuration retrieved from the combination?
            //compare leaderboards retrieved to the input values

            //make it easier to retrieve them, they're not required to be sequentially numbered
            Console.WriteLine( "Adding LeaderboardConfigs to Hashtable: " );
            Hashtable lcHash = new Hashtable( ltc.LeaderboardConfigs.Length );
            foreach( LeaderboardConfig lc in ltc.LeaderboardConfigs )
            {
                lcHash.Add( lc.LeaderboardID, lc.HostingLbs );
            }
            
            Console.WriteLine( "Adding Statsviews: " );
            Hashtable svHash = new Hashtable( sv.Length );
            foreach( StatsView isv in sv )
            {
                svHash.Add( (int) isv.id, isv );
            }

            Console.WriteLine( "   Leaderboard   XLAST " );
            //compare expected configuration
            foreach ( LeaderboardSettings lb in xlastLb )
            {
                //lb = (Leaderboard) xlastLb[ iLoop ];
                //Test2a: confirm we're talking about the same leaderboard id, and it exists everywhere
                Console.WriteLine( " lb " + lb.LeaderboardID );
                Assert.IsTrue( lcHash.Contains( lb.LeaderboardID ) );
                Assert.IsTrue( svHash.Contains( lb.LeaderboardID ) );
                StatsView tsv = (StatsView) svHash[ lb.LeaderboardID ];

                //Test2b: Assigned to the correct server?  (lb == ltc)
                //this is where the other values we assigned get tested... 
                Console.WriteLine( "     lb svr: " + lb.LBServer + "       ltc " + lcHash[ lb.LeaderboardID ] );
                Assert.IsTrue( lb.LBServer == (string) lcHash[ lb.LeaderboardID ] );

                //Test2c: TitleID got transferred over correctly? (lb == ltc)
                Assert.IsTrue( lb.TitleID == ltc.TitleID );

                //Test2d: Xlast values got transferred over correctly? (lb == xlast)
                Assert.IsTrue( lb.ResetType == (byte) tsv.resetType );
                Assert.IsTrue( lb.MaxAttachments == tsv.maxAttachments );
                //removed in April XDK
                //Assert.IsTrue( lb.MaxAttachmentSize == (int) tsv.maxAttachmentSize );
                Assert.IsTrue( lb.DecayDays == tsv.entryExpiration );
                Assert.IsTrue( lb.TopEntries == (int) tsv.topEntries );

                //removed for June XDK... but will be back someday.  ugh.
                //ssert.IsTrue( lb.TeamView == tsv.teamView );

                Assert.IsTrue( lb.Arbitrated == tsv.arbitrated );
            }


            Console.WriteLine( "WHEW... All the Tests Passed!" );
        }

        [Test]
        public void CheckForSkillLeaderboards_POS()
        {
            //xlast doc has correctly configured skill leaderboards
        }

        //[Test]
        public void CheckLb_MissingLB_NEG()
        {
            //xlast doc one missing skill leaderboard
        }
        
        //[Test]
        public void CheckLb_MissingGAMEMODE_NEG()
        {
            //xlast doc doesn't have the GAME_MODE context
        }


    }  // class statsxlastutil

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\admin\StatsAdminTest.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

// From Test
using ServerTestFramework;
using ServerTestFramework.Utilities;

using xonline.common.diagnostics;
using xonline.common.leaderboard;
using xonline.common.livetitleconfig;
using xonline.common.xlastutil;
using ServerTestFramework.LiveService.UserSettings;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;

namespace xonline.server.stats.test.admin
{

    public class StatsAdminTest : TestNode
    {

        #region Fixture setup/teardown, Constants

        public StatsAdminTest()
        {
            //task: anything to do here?
        }

        // executes once per test run
        [TestGroupSetup]
        public void XlastUtilTestFixtureSetup()
        {
            Console.WriteLine( "In TestFixtureSetUp." );
        }

        // executes once at the end of all the tests
        [TestGroupTearDown]
        public void XlastUtilTestFixtureTearDown()
        {
            Console.WriteLine( "In TestFixtureTearDown." );
        }

        #endregion


        [Test]
        public void WriteUserNukeReadImmediately()
        {
            
            for (uint nTitleId=1;nTitleId<100;nTitleId++)
            {
                try
                {
                    xonline.stats.admin.DbLeaderboard.DeleteLeaderboard(nTitleId, 1);
                }
                catch
                {
                    //maybe there was nothing to delete
                }

                try
                {
                    xonline.stats.admin.DbLeaderboard.DeleteLeaderboard(nTitleId, 2);
                }
                catch
                {
                    //maybe there was nothing to delete
                }

                xonline.stats.admin.DbLeaderboard.CreateLeaderboard(nTitleId, 1, 0, "hpleung5");
                xonline.stats.admin.DbLeaderboard.CreateLeaderboard(nTitleId, 2, 0, "hpleung5");
            }

            xonline.stats.admin.DbLeaderboard.ResetStatsFDOnly(30000);
            
            //now is a time to create a bunch of users which have played a bunch of titles
            for (ulong i=1;i<100;i++)
            {
                for (int nTitleId=1;nTitleId<10;nTitleId++)
                {
                    using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                    {
                        ws.ClearParameters();
                        ws.StoredProc = "p_stats_update_user_title";
                        ws.Partition = ws.CalcPartition(i);
                        ws.AddParameter("@bi_user_puid", i);
                        ws.AddParameter("@si_hash_bucket", 0);
                        ws.AddParameter("@i_title_id", nTitleId);
                        ws.AddParameter("@dt_last_logon", DateTime.Now);
                        ws.AddParameter("@i_sequence", 0);
                        ws.AddParameter("@i_creds", 0);
                        ws.AddParameter("@i_achievements", 0);
                        ws.AddParameter("@dt_max_time", DateTime.Now);
                        ws.AddParameter("@dt_last_sync_time", DateTime.Now);

                        ws.ExecuteNonQuery();
                    }

                    StatStruct [] arrStat = new StatStruct[1];
                    arrStat[0] = new StatStruct(SpecialAttrib.Rating, StatParamType.Int64, (Int64)i);

                    StatPost.StatPostReplaceOneUserStats(i, (uint)nTitleId, 1, arrStat);
                    StatPost.StatPostReplaceOneUserStats(i, (uint)nTitleId, 2, arrStat);

                    xonline.stats.admin.DbLeaderboard.RemoveUserFromAllLeaderboards(i);

                    if (xonline.stats.admin.StatFrontDoorUtilities.IsUserMemberOfLeaderboard(i, (uint)nTitleId, 1) ||
                        xonline.stats.admin.StatFrontDoorUtilities.IsUserMemberOfLeaderboard(i, (uint)nTitleId, 2))
                    {
                        throw new Exception("User Still Exist when he should have been nuked");
                    }
                }
            }            
        }


        [Test]
        public void DeleteAUserWithNoLbEntries()
        {
             xonline.stats.admin.DbLeaderboard.RemoveUserFromAllLeaderboards(99999);
        }

         [Test]
        public void DeleteAUserWithPlayedTitleButNoLbEntries()
        {
            ulong ulUserId = 88888;
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.StoredProc = "p_stats_update_user_title";
                ws.Partition = ws.CalcPartition(ulUserId);
                ws.AddParameter("@bi_user_puid", ulUserId);
                ws.AddParameter("@si_hash_bucket", 0);
                ws.AddParameter("@i_title_id", 1);
                ws.AddParameter("@dt_last_logon", DateTime.Now);
                ws.AddParameter("@i_sequence", 0);
                ws.AddParameter("@i_creds", 0);
                ws.AddParameter("@i_achievements", 0);
                ws.AddParameter("@dt_max_time", DateTime.Now);
                ws.AddParameter("@dt_last_sync_time", DateTime.Now);

                ws.ExecuteNonQuery();
            }
             
             xonline.stats.admin.DbLeaderboard.RemoveUserFromAllLeaderboards(88888);
        }


        [Test]
        public void WriteUserNukeLater()
        {
            
            for (uint nTitleId=1;nTitleId<100;nTitleId++)
            {
                try
                {
                    xonline.stats.admin.DbLeaderboard.DeleteLeaderboard(nTitleId, 1);
                }
                catch
                {
                    //maybe there was nothing to delete
                }

                try
                {
                    xonline.stats.admin.DbLeaderboard.DeleteLeaderboard(nTitleId, 2);
                }
                catch
                {
                    //maybe there was nothing to delete
                }

                xonline.stats.admin.DbLeaderboard.CreateLeaderboard(nTitleId, 1, 0, "hpleung5");
                xonline.stats.admin.DbLeaderboard.CreateLeaderboard(nTitleId, 2, 0, "hpleung5");
            }

            xonline.stats.admin.DbLeaderboard.ResetStatsFDOnly(30000);
            
            //now is a time to create a bunch of users which have played a bunch of titles
            for (ulong i=1;i<100;i++)
            {
                for (int nTitleId=1;nTitleId<10;nTitleId++)
                {
                    using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                    {
                        ws.ClearParameters();
                        ws.StoredProc = "p_stats_update_user_title";
                        ws.Partition = ws.CalcPartition(i);
                        ws.AddParameter("@bi_user_puid", i);
                        ws.AddParameter("@si_hash_bucket", 0);
                        ws.AddParameter("@i_title_id", nTitleId);
                        ws.AddParameter("@dt_last_logon", DateTime.Now);
                        ws.AddParameter("@i_sequence", 0);
                        ws.AddParameter("@i_creds", 0);
                        ws.AddParameter("@i_achievements", 0);
                        ws.AddParameter("@dt_max_time", DateTime.Now);
                        ws.AddParameter("@dt_last_sync_time", DateTime.Now);

                        ws.ExecuteNonQuery();
                    }

                    StatStruct [] arrStat = new StatStruct[1];
                    arrStat[0] = new StatStruct(SpecialAttrib.Rating, StatParamType.Int64, (Int64)i);

                    StatPost.StatPostReplaceOneUserStats(i, (uint)nTitleId, 1, arrStat);
                    StatPost.StatPostReplaceOneUserStats(i, (uint)nTitleId, 2, arrStat);

                }
            }         


            for (ulong i=1;i<100;i++)
            {
                for (int nTitleId=1;nTitleId<10;nTitleId++)
                {
                    xonline.stats.admin.DbLeaderboard.RemoveUserFromAllLeaderboards(i);

                    if (xonline.stats.admin.StatFrontDoorUtilities.IsUserMemberOfLeaderboard(i, (uint)nTitleId, 1) ||
                        xonline.stats.admin.StatFrontDoorUtilities.IsUserMemberOfLeaderboard(i, (uint)nTitleId, 2))
                    {
                        throw new Exception("User Still Exist when he should have been nuked");
                    }
                }
             }
        }

        

        //configure all lb for a title

        //delete title's lb - confirm they're gone

        //add single lb, confirm it's there: lbserver and npdb.t_stats_leaderboards (via retrievelbconfig) 

        //add single lb, remove it, confirm it's gone

        //any tests to confirm frontdoor resets work?

        //report user's stats

        //remove user's stats

       

    }

    public class StatStruct 
    {
       public ushort         m_nAttributeID;
       public StatParamType m_nAttributeType;
       public object        m_objData;

       public StatStruct(ushort nAttributeID, StatParamType nAttributeType, object value)
       {
            m_nAttributeID   = nAttributeID;
            m_nAttributeType = nAttributeType;
            m_objData        = value;
       }

       public StatStruct()
       {
        
       }
    }
    
    public enum StatParamType
    {
        Int32        = 3,
        Int64        = 4,
        Double       = 5
    }


    class StatPost
    {
         //This will call into the stats Front Door
        public static void StatPostReplaceOneUserStats(ulong ulPuid, uint uiTitleID, uint uiLbID, StatStruct [] arrStatsAttributes)
        {   
            ReqStatPost objStatPostReq = new ReqStatPost();
            objStatPostReq._uiTitleId = uiTitleID;
            objStatPostReq._usProcCount = 1;

            objStatPostReq._procs = new MsgStatPostProcedureCall[1];
            objStatPostReq._procs[0] = new MsgStatPostProcedureCall();

            objStatPostReq._procs[0]._usProcId = StatPostProcedure.Replace;

            StatPostTypeValuePair objStatReplace = new StatPostTypeValuePair();

            objStatReplace.WriteStat(StatParam.Puid,   ulPuid);
            objStatReplace.WriteStat(StatParam.Int32, (Int32)uiLbID);
            objStatReplace.WriteStat(StatParam.Int16, (Int16)0);

            MsgStatPostParameter objPuidParam = new MsgStatPostParameter();

            for (int i=0;i<arrStatsAttributes.Length;i++)
            {
                objStatReplace.WriteStat(StatParam.Int16, (Int16)arrStatsAttributes[i].m_nAttributeID);
                objStatReplace.WriteStat((byte)arrStatsAttributes[i].m_nAttributeType, arrStatsAttributes[i].m_objData);
            }

            objStatPostReq._procs[0]._params = objStatReplace.Generate();
            objStatPostReq._procs[0]._usParamCount = (ushort)objStatPostReq._procs[0]._params.Length;
            
            MemoryStream objMemStream = new MemoryStream();
            BinaryWriter objBinWriter = new BinaryWriter(objMemStream);
            objStatPostReq.WriteTo(objBinWriter);
            
            XrlRequest objXrlReq = new XrlRequest();
            objXrlReq.TargetVirtualInterface = VirtualInterface.xstatsfd_int;
            objXrlReq.PostData = objMemStream.ToArray();

            XUIDAndTrust[] arrXuidAndTrust = new XUIDAndTrust[1];
            arrXuidAndTrust[0] = new XUIDAndTrust(ulPuid, 0, 0.0f); //the user puid is what is important
                
            BundledAuthData objBundleAuth = new BundledAuthData(0 , arrXuidAndTrust); //Stats Post only supports bundle Auth

            objXrlReq.IsBundleAuth = true;
            objXrlReq.AuthData = objBundleAuth.GetBase64EncodedString();//new HTTPAuthData(0, 0, 0, ulPuid, uiTitleID, 0, 0).GetBase64EncodedString();
            objXrlReq.Path     = objStatPostReq.GetXRL();
            
            uint hr = objXrlReq.Send();
            if (HResult.Failed(hr))
            {
                throw new Exception(String.Format("Error While calling Stats FD HResult {0:x}",hr)); //BUG BUG - Log the event
            }
            
        }

    }

    
    class StatPostTypeValuePair:IGenerateStatPostValuePair
    {   
        List<StatPostPair>  m_arrStatObjects = new List<StatPostPair>();

        public StatPostTypeValuePair()
        {
            
        }

        //byStatType needs to be compatible with StatParam
        public void WriteStat(byte byStatType, object value)
        {
            m_arrStatObjects.Add(new StatPostPair(byStatType, value));
        }

        public MsgStatPostParameter [] Generate()
        {
            MsgStatPostParameter [] arrReturn = new MsgStatPostParameter[GetParamCount()];
            for (int i=0;i<m_arrStatObjects.Count;i++)
            {
                StatPostPair objPair     = m_arrStatObjects[i];
                arrReturn[i] = objPair.ToStatPostParam();
            }

            return arrReturn;
        }
        
        public int GetParamCount()
        {
            return m_arrStatObjects.Count;
        }

        
    }

    class StatPostPair
    {
        public byte   m_byType;
        public object m_objvalue;

        public StatPostPair(byte byType, object objValue)
        {
            if (null == objValue )
            {
                m_byType    = (byte)StatParam.Null;
            }
            else
            {
                m_byType    = byType;
            }

            m_objvalue  = objValue;
        }

        public MsgStatPostParameter ToStatPostParam()
        {
           MsgStatPostParameter objRet = new MsgStatPostParameter();
           objRet._bParamType = m_byType;
           objRet._data      = m_objvalue;

           return objRet;
        }
    }

    interface IGenerateStatPostValuePair
    {
        void WriteStat(byte byStatType, object value);
        MsgStatPostParameter [] Generate();
        int GetParamCount();
    }
    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\applogparser\Program.cs ===
using System;
using System.Collections;
using System.Text;
using System.IO;

namespace AppLogParser
{
    class SettingsRequestComparer : IEqualityComparer
    {
        private string[] SortStringArray(string[] before)
        {
            string[] after = new string[before.Length];
            //make a copy.
            for(int i=0; i<before.Length; i++)
            {
                after[i] = before[i];
            }
            //bubble sort! yipppeeee
            for(int i=0; i<before.Length; i++)
                for (int j = i+1; j < before.Length; j++)
                {
                    if (after[i].CompareTo(after[j]) > 1)
                    {
                        string temp = after[j];
                        after[j] = after[i];
                        after[i] = temp;
                    }
                }
            return after;
        }
        bool IEqualityComparer.Equals(object x, object y)
        {
            SettingRequest a = (SettingRequest)x;
            SettingRequest b = (SettingRequest)y;
            return a.SREquals(b);

        }

        int IEqualityComparer.GetHashCode(object obj)
        {
            SettingRequest a = (SettingRequest) obj;
            string[] settings = SortStringArray(a.settings1);
            string hashcode = "";
            foreach (string s in settings)
            {
                hashcode += s;
            }
            return hashcode.GetHashCode();
        }

     
    }

    class SettingRequest
    {
        //public int numUsers;
        //public int numSettings;
        //public int timesRequested;
        public string[] settings1;
        //public string titleID;
        //public string[] settings2;
        //public string[] settings3;
        //public string[] settings4;
        //public string[] settings5;

        private bool equals(string[] LHS, string[] RHS)
        {
            if (RHS.Length != LHS.Length) return false;
            for(int i=0; i< RHS.Length; i++)
            {
                if (LHS[i] != RHS[i]) return false;
            }
            return true;
        }
        public bool SREquals(SettingRequest RHS)
        {
            if (settings1.Length != RHS.settings1.Length) return false;
            for (int i = 0; i < settings1.Length; i++)
            {
                if (settings1[i] != RHS.settings1[i]) return false;
            }
            return true;
        }

        //public SettingRequest(int u, int s, string[] set)
        //{
        //    numUsers = u;
        //    numSettings = s;
        //    settings1 = set;
        //    timesRequested = 0;
        //}
        public SettingRequest(string[] set)
        {
            settings1 = set;
            //titleID = title;
        }

        //public void addSettingString(string[] set)
        //{
        //    if (settings1 == null) 
        //    {
        //        settings1 = set;
        //        return;
        //    }
        //    if (settings1 != null && equals(set, settings1)) return;
        //    if (settings2 == null)
        //    {
        //        settings2 = set;
        //        return;
        //    }
        //    if (settings2 != null && equals(set, settings2)) return;
        //    if (settings3 == null)
        //    {
        //        settings3 = set;
        //        return;
        //    }
        //    if (settings3 != null && equals(set, settings3)) return;
        //    if (settings4 == null)
        //    {
        //        settings4 = set;
        //        return;
        //    }
        //    if (settings4 != null && equals(set, settings4)) return;
        //    if (settings5 == null)
        //    {
        //        settings5 = set;
        //        return;
        //    }
            
            
        //}
    }
    class SyncSettingManager
    {
        class MapObject
        {
            public int count;
            public Hashtable titleCount;

            public MapObject()
            {
                count = 0;
                titleCount = new Hashtable();
            }
            public void AddTitle(string titleID)
            {
                count++;

                if (titleCount[titleID] == null)
                {
                    titleCount[titleID] = 1;
                }
                else
                {
                    int numtimes = (int)titleCount[titleID];
                    numtimes++;
                    titleCount[titleID] = numtimes;
                }
            }

        }
        public Hashtable requestedSettingsAndTitles;
        public Hashtable requestedTitles;
        public Hashtable responseSettingsAndTitles;
        public Hashtable responseTitles;
        public Hashtable bothSettingsAndTitles;
        public Hashtable bothTitles;
        public long totalSyncSettingsRequests;
        public long totalOnlyRequestedSettings;
        public long totalOnlyResponseSettings;
        public long totalBothSettings;
        public long totalEmptyCalls;

        public SyncSettingManager()
        {
            requestedSettingsAndTitles = new Hashtable();
            responseSettingsAndTitles = new Hashtable();
            bothSettingsAndTitles = new Hashtable();
            requestedTitles = new Hashtable();
            responseTitles = new Hashtable();
            bothTitles = new Hashtable();
            totalSyncSettingsRequests = 0;
            totalOnlyRequestedSettings = 0;
            totalOnlyResponseSettings = 0;
            totalBothSettings = 0;
            totalEmptyCalls = 0;
        }
        private string buildKey(string[] settings)
        {
            string key = "";
            for (int i = 0; i < settings.Length; i++)
            {
                key += settings[i];
                if (i < settings.Length - 1) key += '+';
            }
            return key;
        }
        private string buildKey(string[] settings, string[] settings2)
        {
            string key = "";
            for (int i = 0; i < settings.Length; i++)
            {
                key += settings[i];
                if (i < settings.Length - 1) key += '+';
            }

            key += ";";

            for (int i = 0; i < settings2.Length; i++)
            {
                key += settings2[i];
                if (i < settings2.Length - 1) key += '+';
            }

            return key;
        }

        public void AddRequestedSettings(string[] requestedSettings, string title)
        {
            //create key for hashing
            string key = buildKey(requestedSettings);
           
            //hash the key
            if (requestedSettingsAndTitles[key] == null)
            {
                MapObject temp = new MapObject();
                temp.AddTitle(title);
                requestedSettingsAndTitles[key] = temp;
            }
            else
            {
                MapObject temp = (MapObject)requestedSettingsAndTitles[key];
                temp.AddTitle(title);
            }
            //add to title count hashtable
            if (requestedTitles[key] == null)
            {
                requestedTitles[key] = 1;
            }
            else
            {
                int count = (int)requestedTitles[key];
                requestedTitles[key] = count + 1;
            }
        }
        public void AddBothSettings(string[] requestedSettings, string[] responseSettings, string title)
        {
            //create key for hashing
            string key = "";
            foreach (string s in requestedSettings)
            {
                key += s + "+";
            }
            key += ";";
            foreach (string s in responseSettings)
            {
                key += s + "+";
            }
            
            //hash the key
            if (bothSettingsAndTitles[key] == null)
            {
                MapObject temp = new MapObject();
                temp.AddTitle(title);
                bothSettingsAndTitles[key] = temp;
            }
            else
            {
                MapObject temp = (MapObject)bothSettingsAndTitles[key];
                temp.AddTitle(title);
            }
            //add to title count hashtable
            if (bothTitles[key] == null)
            {
                bothTitles[key] = 1;
            }
            else
            {
                int count = (int)bothTitles[key];
                bothTitles[key] = count + 1;
            }
        }
        public void AddResponseSettings(string[] responseSettings, string title)
        {
            //create key for hashing
            string key = buildKey(responseSettings);
            
            //hash the key
            if (responseSettingsAndTitles[key] == null)
            {
                MapObject temp = new MapObject();
                temp.AddTitle(title);
                responseSettingsAndTitles[key] = temp;
            }
            else
            {
                MapObject temp = (MapObject)responseSettingsAndTitles[key];
                temp.AddTitle(title);
            }

            //add to title count hashtable
            if (responseTitles[key] == null)
            {
                responseTitles[key] = 1;
            }
            else
            {
                int count = (int)responseTitles[key];
                responseTitles[key] = count + 1;
            }
        }
        
        public string[][] GetRequestedScenarios()
        {
            //convert our arraylist to string[][]
            string[][] retVal = new string[requestedSettingsAndTitles.Keys.Count][];

            int i = 0;
            foreach (string s in requestedSettingsAndTitles.Keys)
            {
                retVal[i] = s.Split('+');
                i++;
            }

            return retVal;
        }
        public string[][] GetResponseScenarios()
        {
            //convert our arraylist to string[][]
            string[][] retVal = new string[responseSettingsAndTitles.Keys.Count][];

            int i = 0;
            foreach (string s in responseSettingsAndTitles.Keys)
            {
                retVal[i] = s.Split('+');
                i++;
            }

            return retVal;
        }
        public void GetBothScenarios(out string[][] req, out string[][] resp)
        {
            //convert our arraylist to string[][]
            req = new string[bothSettingsAndTitles.Keys.Count][];
            resp = new string[bothSettingsAndTitles.Keys.Count][];
            int i = 0;
            foreach (string s in bothSettingsAndTitles.Keys)
            {
                string[] temp = s.Split(';');
                req[i] = temp[0].Split('+');
                resp[i] = temp[1].Split('+');
                i++;
            }
        }

        public double GetRequestedTotalRatio()
        {
            return (double) totalOnlyRequestedSettings/(double)totalSyncSettingsRequests;
        }
        public double GetResponseTotalRatio()
        {
            return (double)totalOnlyResponseSettings / (double)totalSyncSettingsRequests;
        }
        public double GetBothTotalRatio()
        {
            return (double)totalBothSettings / (double)totalSyncSettingsRequests;
        }
        public double GetEmptyTotalRatio()
        {
            return (double)totalEmptyCalls / (double)totalSyncSettingsRequests;
        }
        public double GetRequestedScenarioRatio(string[] requestedSettings)
        {
            string key = buildKey(requestedSettings);
            //hash the key
            if (requestedSettingsAndTitles[key] == null)
            {
                return 0;
            }
            else
            {
                MapObject temp = (MapObject)requestedSettingsAndTitles[key];
                return (double)temp.count / (double)totalOnlyRequestedSettings;
            } 
        }
        public string[] GetRequestedScenarioTitles(string[] requestedSettings)
        {
            string[] retVal = null;
            string key = buildKey(requestedSettings);
            //hash the key
            if (requestedSettingsAndTitles[key] == null)
            {
                retVal = new string[0];
            }
            else
            {
                MapObject temp = (MapObject)requestedSettingsAndTitles[key];
                retVal = new string[temp.titleCount.Keys.Count];
                int i=0;
                foreach (string s in temp.titleCount.Keys)
                {
                    retVal[i] = s;
                    i++;
                }
            }
            return retVal;
        }
        public string[] GetRequestedTitles()
        {
            string[] retVal = new string[requestedTitles.Keys.Count];
            int i = 0;
            foreach (string s in requestedTitles.Keys)
            {
                retVal[i] = s;
                i++;
            }
            return retVal;
        }
        public double GetRequestedTitleRatio(string title)
        {
            if (requestedTitles[title] == null) return 0;
            return ((int)requestedTitles[title]) / (double)totalOnlyRequestedSettings;
        }
        public double GetRequestedScenarioTitleRatio(string[] requestedSettings, string title)
        {
            string key = buildKey(requestedSettings);
            //hash the key
            if (requestedSettingsAndTitles[key] == null)
            {
                return 0;
            }
            else
            {
                MapObject temp = (MapObject)requestedSettingsAndTitles[key];
                if (temp.titleCount[title] == null) return 0;
                return ((int)temp.titleCount[title]) / (double)temp.count;     
            }
            
        }

        public double GetResponseScenarioRatio(string[] requestedSettings)
        {
            string key = buildKey(requestedSettings);
            //hash the key
            if (responseSettingsAndTitles[key] == null)
            {
                return 0;
            }
            else
            {
                MapObject temp = (MapObject)responseSettingsAndTitles[key];
                return (double)temp.count / (double)totalOnlyResponseSettings;
            }
        }
        public string[] GetResponseScenarioTitles(string[] requestedSettings)
        {
            string[] retVal = null;
            string key = buildKey(requestedSettings);
            //hash the key
            if (responseSettingsAndTitles[key] == null)
            {
                retVal = new string[0];
            }
            else
            {
                MapObject temp = (MapObject)responseSettingsAndTitles[key];
                retVal = new string[temp.titleCount.Keys.Count];
                int i = 0;
                foreach (string s in temp.titleCount.Keys)
                {
                    retVal[i] = s;
                    i++;
                }
            }
            return retVal;
        }
        public double GetResponseScenarioTitleRatio(string[] requestedSettings, string title)
        {
            string key = buildKey(requestedSettings);
            //hash the key
            if (responseSettingsAndTitles[key] == null)
            {
                return 0;
            }
            else
            {
                MapObject temp = (MapObject)responseSettingsAndTitles[key];
                if (temp.titleCount[title] == null) return 0;
                return ((int)temp.titleCount[title]) / (double)temp.count;
            }

        }

        public double GetBothScenarioRatio(string[] requestedSettings, string[] responseSettings)
        {
            //create key for hashing
            string key = buildKey(requestedSettings, responseSettings);

            //hash the key
            if (bothSettingsAndTitles[key] == null)
            {
                return 0;
            }
            else
            {
                MapObject temp = (MapObject)bothSettingsAndTitles[key];
                return (double)temp.count / (double)totalBothSettings;
            }
        }
        public string[] GetBothScenarioTitles(string[] requestedSettings, string[] responseSettings)
        {
            string[] retVal = null;
            string key = buildKey(requestedSettings, responseSettings);
            //hash the key
            if (bothSettingsAndTitles[key] == null)
            {
                retVal = new string[0];
            }
            else
            {
                MapObject temp = (MapObject)bothSettingsAndTitles[key];
                retVal = new string[temp.titleCount.Keys.Count];
                int i = 0;
                foreach (string s in temp.titleCount.Keys)
                {
                    retVal[i] = s;
                    i++;
                }
            }
            return retVal;
        }
        public double GetBothScenarioTitleRatio(string[] requestedSettings, string[] responseSettings, string title)
        {
            string key = buildKey(requestedSettings, responseSettings);
            //hash the key
            if (bothSettingsAndTitles[key] == null)
            {
                return 0;
            }
            else
            {
                MapObject temp = (MapObject)bothSettingsAndTitles[key];
                if (temp.titleCount[title] == null) return 0;
                return ((int)temp.titleCount[title]) / (double)temp.count;
            }

        }
    }
    class SettingRequestMapping
    {
        public Hashtable usersToTimesRequested;
        public int totalTimesRequested;

        public SettingRequestMapping(int numUsers, string titleID)
        {
            usersToTimesRequested = new Hashtable();
            string hashkey = titleID + "+" + numUsers.ToString();
            usersToTimesRequested[hashkey] = 1;
            totalTimesRequested = 1;
        }

        public void AddUserCount(int numUsers, string titleID)
        {
            string hashkey = titleID + "+" + numUsers.ToString();
            if (usersToTimesRequested[hashkey] == null)
            {
                usersToTimesRequested[hashkey] = 1;
            }
            else
            {
                int numtimes = (int)usersToTimesRequested[hashkey];
                numtimes++;
                usersToTimesRequested[hashkey] = numtimes;
            }
            totalTimesRequested++;
        }
        public string[] GetUserArray()
        {
            ArrayList list = new ArrayList();
            foreach (string s in usersToTimesRequested.Keys)
            {
                string[] split = s.Split('+');
                if (! list.Contains(split[1]))
                {
                    list.Add(split[1]);
                }
            }
            string[] retVal = new string[list.Count];
            //convert arraylist to int[]
            for (int i = 0; i < retVal.Length; i++)
            {
                retVal[i] = (string)list[i];
            }
            return retVal;

        }
       
        public int GetUserOccuranceAcrossAllTitles(string numUsers)
        {
            int count = 0;
            foreach (string s in usersToTimesRequested.Keys)
            {
                string[] split = s.Split('+');
                if (split[1] == numUsers)
                {
                    count += (int) usersToTimesRequested[s];
                }
            }
            return count;
        }
        public double GetUserOccuranceAcrossAllTitlesRatio(string numUsers)
        {

            return (double)GetUserOccuranceAcrossAllTitles (numUsers) / (double)totalTimesRequested;
        }

        //titles
        public string[] GetTitleArray() //this one will be large
        {
            ArrayList list = new ArrayList();
            foreach (string s in usersToTimesRequested.Keys)
            {
                string[] split = s.Split('+');
                if (!list.Contains(split[0]))
                {
                    list.Add(split[0]);
                }
            }
            string[] retVal = new string[list.Count];
            //convert arraylist to int[]
            for (int i = 0; i < retVal.Length; i++)
            {
                retVal[i] = (string)list[i];
            }
            return retVal;

        }

        public int GetTitleOccuranceAcrossAllUsers(string title)
        {
            int count = 0;
            foreach (string s in usersToTimesRequested.Keys)
            {
                string[] split = s.Split('+');
                if (split[0] == title)
                {
                    count += (int)usersToTimesRequested[s];
                }
            }
            return count;
        }

        public double GetTitleOccuranceAcrossAllUsersRatio(string title)
        {

            return (double)GetTitleOccuranceAcrossAllUsers(title) / (double)totalTimesRequested;
        }
    }
    class EnumTitlesManager
    {
        public Hashtable numReturnedTitles;
        public Hashtable returnedTitles;
        public int numRequests;

        public EnumTitlesManager()
        {
            numReturnedTitles = new Hashtable();
            returnedTitles = new Hashtable();
            numRequests = 0;
        }
        private string buildKey(string[] settings)
        {
            string key = "";
            for (int i = 0; i < settings.Length; i++)
            {
                key += settings[i];
                if (i < settings.Length - 1) key += '+';
            }
            return key;
        }
        public void AddTitles(string[] titles)
        {
            //hash in numReturnedTitles
            if (numReturnedTitles[titles.Length] == null)
            {
                numReturnedTitles[titles.Length] = 1;
            }
            else
            {
                int count = (int) numReturnedTitles[titles.Length];
                numReturnedTitles[titles.Length] = count + 1;
            }
            foreach (string s in titles)
            {
                string key = s;
                //hash in returnedTitels
                if (returnedTitles[key] == null)
                {
                    returnedTitles[key] = 1;
                }
                else
                {
                    int count = (int)returnedTitles[key];
                    returnedTitles[key] = count + 1;
                }
            }
            numRequests++;
        }
        public int[] getNumTitleArray()
        {
            int[] retVal = new int[numReturnedTitles.Keys.Count];
            int i = 0;
            foreach(int num in numReturnedTitles.Keys)
            {
                retVal[i] = num;
                i++;
            }
            return retVal;
        }
        public double GetNumTitleRatio(int numTitle)
        {
            if (numReturnedTitles[numTitle] == null) return 0;
            int count = (int) numReturnedTitles[numTitle];
            return (double)count / (double)numRequests;
        }

        public void AddZeroTitles()
        {
            if (numReturnedTitles[0] == null)
            {
                numReturnedTitles[0] = 1;
            }
            else
            {
                int count = (int)numReturnedTitles[0];
                numReturnedTitles[0] = count + 1;
            }
            numRequests++;
        }
    }
    class EnumAchievementsManager
    {
        public Hashtable titles;
        public int numRequests;

        public EnumAchievementsManager()
        {
            titles = new Hashtable();
            numRequests = 0;
        }
        public void AddTitle(string title)
        {

            if (titles[title] == null)
            {
                titles[title] = 1;
            }
            else
            {
                int count = (int)titles[title];
                titles[title] = count + 1;
            }
        
            numRequests++;
        }
        public string[] GetTitleArray()
        {
            string[] retVal = new string[titles.Keys.Count];
            int i = 0;
            foreach (string t in titles.Keys)
            {
                retVal[i] = t;
                i++;
            }
            return retVal;
        }
        public double GetTitleRatio(string title)
        {
            if (titles[title] == null) return 0;
            int count = (int)titles[title];
            return (double)count / (double)numRequests;
        }
    }
    class SyncTitlesManager
    {
        public Hashtable numReqTitles;
        public Hashtable numRespTitles;
        public Hashtable reqTitles;
        public Hashtable respTitles;
        public int numTotalRequests;
        public int numReqRequests;
        public int numRespRequests;
        public int numBothRequests;
        public int numEmptyRequests;

        public SyncTitlesManager()
        {
            numReqTitles = new Hashtable();
            numRespTitles = new Hashtable();
            reqTitles = new Hashtable();
            respTitles = new Hashtable();

            numTotalRequests = 0;
            numReqRequests = 0;
            numRespRequests = 0;
            numBothRequests = 0;
        }
        private string buildKey(string[] settings)
        {
            string key = "";
            for (int i = 0; i < settings.Length; i++)
            {
                key += settings[i];
                if (i < settings.Length - 1) key += '+';
            }
            return key;
        }

        public void AddReqTitles(string[] titles)
        {
            //hash in numReturnedTitles
            if (numReqTitles[titles.Length] == null)
            {
                numReqTitles[titles.Length] = 1;
            }
            else
            {
                int count = (int)numReqTitles[titles.Length];
                numReqTitles[titles.Length] = count + 1;
            }

            foreach(string t in titles)
            {
                string key = titles.Length + "+" + t;
                //hash in returnedTitels
                if (reqTitles[key] == null)
                {
                    reqTitles[key] = 1;
                }
                else
                {
                    int count = (int)reqTitles[key];
                    reqTitles[key] = count + 1;
                }
            }
        }
        public void AddRespTitles(string[] titles)
        {
            if (numRespTitles[titles.Length] == null)
            {
                numRespTitles[titles.Length] = 1;
            }
            else
            {
                int count = (int)numRespTitles[titles.Length];
                numRespTitles[titles.Length] = count + 1;
            }

            foreach (string t in titles)
            {
                string key = titles.Length + "+" + t;
                //hash in returnedTitels
                if (respTitles[key] == null)
                {
                    respTitles[key] = 1;
                }
                else
                {
                    int count = (int)respTitles[key];
                    respTitles[key] = count + 1;
                }
            }
        }

        public double GetRespTitleRatio()
        {
            return (double)numRespRequests / (double)numTotalRequests;
        }
        public double GetReqTitleRatio()
        {
            return (double)numReqRequests / (double)numTotalRequests;
        }
        public double GetBothTitleRatio()
        {
            return (double)numBothRequests / (double)numTotalRequests;
        }
        public double GetEmptyTitleRatio()
        {
            return (double)numEmptyRequests / (double)numTotalRequests;
        }
        public double GetNumReqTitleRatio(int numTitles)
        {
            if (numReqTitles[numTitles] == null) return 0;
            int count = (int) numReqTitles[numTitles];
            return (double)count / (double)numReqRequests;
        }
        public double GetNumRespTitleRatio(int numTitles)
        {
            if (numRespTitles[numTitles] == null) return 0;
            int count = (int) numRespTitles[numTitles];
            return (double)count / (double)numRespRequests;
        }
        public double GetRespTitleRatioByNum(int numTitles, string titleID)
        {
            string key = numTitles + "+" + titleID;
            if (respTitles[key] == null) return 0;
            int count = (int) respTitles[key];
            double denominatorCount = 0;
            foreach (string s in respTitles.Keys)
            {
                string[] split = s.Split('+');
                if (split[0] == numTitles.ToString())
                {
                    denominatorCount += (double)((int)respTitles[s]);
                }
            }
            return (double) count / denominatorCount;

        }
        public double GetReqTitleRatioByNum(int numTitles, string titleID)
        {
            string key = numTitles + "+" + titleID;
            if (reqTitles[key] == null) return 0;
            double count = (double)((int)reqTitles[key]);
            double denominatorCount = 0;
            foreach (string s in reqTitles.Keys)
            {
                string[] split = s.Split('+');
                if (split[0] == numTitles.ToString())
                {
                    denominatorCount += (double)((int)reqTitles[s]);
                }
            }
            return count / denominatorCount;

        }

        public int[] GetNumReqTitleList()
        {
            int[] retVal = new int[numReqTitles.Keys.Count];
            int i = 0;
            foreach (int t in numReqTitles.Keys)
            {
                retVal[i] = t;
                i++;
            }
            return retVal;
        }
        public string[] GetReqTitleListByNum(int num)
        {
            ArrayList temp = new ArrayList();
            foreach (string s in reqTitles.Keys)
            {
                string[] split = s.Split('+');
                if (split[0] == num.ToString())
                {
                    if (! temp.Contains(split[1])) temp.Add(split[1]);
                }
            }

            string[] retVal = new string[temp.Count];
            for(int i=0; i<retVal.Length; i++)
            {
                retVal[i] = (string) temp[i];
            }
            return retVal;
        }
        public string[] GetRespTitleListByNum(int num)
        {
            ArrayList temp = new ArrayList();
            foreach (string s in respTitles.Keys)
            {
                string[] split = s.Split('+');
                if (split[0] == num.ToString())
                {
                    if (!temp.Contains(split[1])) temp.Add(split[1]);
                }
            }

            string[] retVal = new string[temp.Count];
            for (int i = 0; i < retVal.Length; i++)
            {
                retVal[i] = (string)temp[i];
            }
            return retVal;
        }
        public int[] GetNumRespTitleList()
        {
            int[] retVal = new int[numRespTitles.Keys.Count];
            int i = 0;
            foreach (int t in numRespTitles.Keys)
            {
                retVal[i] = t;
                i++;
            }
            return retVal;
        }

    }
    class SyncAchievementsManager
    {
        public Hashtable numReqAchieve;
        public Hashtable numRespAchieve;
        public Hashtable numBothAchieve;
        public Hashtable reqTitles;
        public Hashtable respTitles;
        public Hashtable bothTitles;
        public int numTotalRequests;
        public int numReqRequests;
        public int numRespRequests;
        public int numBothRequests;
        public int numEmptyRequests;

        public SyncAchievementsManager()
        {
            numReqAchieve = new Hashtable();
            numRespAchieve = new Hashtable();
            numBothAchieve = new Hashtable();
            reqTitles = new Hashtable();
            respTitles = new Hashtable();
            bothTitles = new Hashtable();

            numTotalRequests = 0;
            numReqRequests = 0;
            numRespRequests = 0;
            numBothRequests = 0;
            numEmptyRequests = 0;
        }

        public string buildKey(int length1, int length2)
        {
            return length1.ToString() + "+" + length2.ToString();
        }
        private int[] upackKey(string t)
        {
            int[] retval = new int[2];
            string[] nums = t.Split('+');
            //serious error if this happens...
            if (nums.Length < 2) return retval;
            int i = 0;
            foreach(string s in nums)
            {
                retval[i] = Int32.Parse(s);
                i++;
            }
            return retval;

        }
        public void AddReqAchieve(string[] achID)
        {
            //hash in numReturnedTitles
            if (numReqAchieve[achID.Length] == null)
            {
                numReqAchieve[achID.Length] = 1;
            }
            else
            {
                int count = (int)numReqAchieve[achID.Length];
                numReqAchieve[achID.Length] = count + 1;
            }
        }
        public void AddRespAchieve(string[] achID)
        {
            if (numRespAchieve[achID.Length] == null)
            {
                numRespAchieve[achID.Length] = 1;
            }
            else
            {
                int count = (int)numRespAchieve[achID.Length];
                numRespAchieve[achID.Length] = count + 1;
            }
        }
        public void AddBothAchieve(string[] achID, string[] achID2)
        {
            string key = buildKey(achID.Length, achID2.Length);
            if (numBothAchieve[key] == null)
            {
                numBothAchieve[key] = 1;
            }
            else
            {
                int count = (int)numBothAchieve[key];
                numBothAchieve[key] = count + 1;
            }
        }
        public void AddReqTitle(string title)
        {
            if (reqTitles[title] == null)
            {
                reqTitles[title] = 1;
            }
            else
            {
                int count = (int)reqTitles[title];
                reqTitles[title] = count + 1;
            }
        }
        public void AddRespTitle(string title)
        {
            if (respTitles[title] == null)
            {
                respTitles[title] = 1;
            }
            else
            {
                int count = (int)respTitles[title];
                respTitles[title] = count + 1;
            }
        }
        public void AddBothTitle(string title)
        {
            if (bothTitles[title] == null)
            {
                bothTitles[title] = 1;
            }
            else
            {
                int count = (int)bothTitles[title];
                bothTitles[title] = count + 1;
            }
        }

        public double GetRespAchieveRatio()
        {
            return (double)numRespRequests / (double)numTotalRequests;
        }
        public double GetReqAchieveRatio()
        {
            return (double)numReqRequests / (double)numTotalRequests;
        }
        public double GetBothAchieveRatio()
        {
            return (double)numBothRequests / (double)numTotalRequests;
        }
        public double GetEmptyAchieveRatio()
        {
            return (double)numEmptyRequests / (double)numTotalRequests;
        }
        public double GetNumReqAchieveRatio(int numAch)
        {
            if (numReqAchieve[numAch] == null) return 0;
            int count = (int)numReqAchieve[numAch];
            return (double)count / (double)numReqRequests;
        }
        public double GetNumRespAchieveRatio(int numAchieve)
        {
            if (numRespAchieve[numAchieve] == null) return 0;
            int count = (int)numRespAchieve[numAchieve];
            return (double)count / (double)numRespRequests;
        }
        public int[] GetNumReqAchieveList()
        {
            int[] retVal = new int[numReqAchieve.Keys.Count];
            int i = 0;
            foreach (int t in numReqAchieve.Keys)
            {
                retVal[i] = t;
                i++;
            }
            return retVal;
        }
        public int[] GetNumRespAchieveList()
        {
            int[] retVal = new int[numRespAchieve.Keys.Count];
            int i = 0;
            foreach (int t in numRespAchieve.Keys)
            {
                retVal[i] = t;
                i++;
            }
            return retVal;
        }
        public int[][] GetNumBothAchieveList()
        {
            int[][] retVal = new int[numBothAchieve.Keys.Count][];
            int i = 0;
            foreach (string t in numRespAchieve.Keys)
            {
                int[] temp = upackKey(t);
                retVal[i] = temp;
                i++;
            }
            return retVal;
        }


        public string[] GetReqAchieveTitleList()
        {
            string[] retVal = new string[reqTitles.Keys.Count];
            int i = 0;
            foreach (string t in reqTitles.Keys)
            {
                retVal[i] = t;
                i++;
            }
            return retVal;
        }

        public double GetReqAchieveTitleRatio(string t)
        {
            if (reqTitles[t] == null) return 0;
            int count = (int)reqTitles[t];
            return (double)count / (double)numReqRequests;
        }

        public string[] GetRespAchieveTitleList()
        {
            string[] retVal = new string[respTitles.Keys.Count];
            int i = 0;
            foreach (string t in respTitles.Keys)
            {
                retVal[i] = t;
                i++;
            }
            return retVal;
        }

        public double GetRespAchieveTitleRatio(string t)
        {
            if (respTitles[t] == null) return 0;
            int count = (int)respTitles[t];
            return (double)count / (double)numRespRequests;
        }

        public string[] GetBothAchieveTitleList()
        {
            string[] retVal = new string[respTitles.Keys.Count];
            int i = 0;
            foreach (string t in respTitles.Keys)
            {
                retVal[i] = t;
                i++;
            }
            return retVal;
        }

        public double GetBothAchieveTitleRatio(string t)
        {
            if (bothTitles[t] == null) return 0;
            int count = (int)bothTitles[t];
            return (double)count / (double)numBothRequests;
        }
    }
    class Program
    {
        public static Hashtable titleIDs = new Hashtable();
        public static Hashtable synctitleIDs = new Hashtable();
        public static Hashtable settingRequests = new Hashtable(new SettingsRequestComparer());
        public static Hashtable requests = new Hashtable();
        public static Hashtable syncrequests = new Hashtable();
        public static Hashtable settingIDs = new Hashtable();
        public static Hashtable syncsettingIDs = new Hashtable();
        public static Hashtable syncTitleSetting = new Hashtable();
        public static long totalRSRequests = 0;
        public static SyncSettingManager SSMan = new SyncSettingManager();
        public static EnumTitlesManager ETMan = new EnumTitlesManager();
        public static SyncTitlesManager STMan = new SyncTitlesManager();
        public static SyncAchievementsManager SAMan = new SyncAchievementsManager();
        public static EnumAchievementsManager EAMan = new EnumAchievementsManager();
        public static string outputXML = "";


        static void Main(string[] args)
        {
            StreamReader SR = null;
            string line = null;

            //if (args.Length != 1) Console.WriteLine("Invalid arguments. Please specify the file to parse.");
            string input = "notdone";
            while (input != "done")
            {
                Console.WriteLine("Enter the file you wish to be parsed, or type done to write out the results.\n>>");
                input = Console.ReadLine();
                if (input == "done") break;
                try
                {
                    //open the file for parsing
                    SR = File.OpenText(input);
                    line = SR.ReadLine();
                    //read the file in line by line
                    while (line != null)
                    {
                        ParseRUSLine(line);
                        ParseSUSLine(line);
                        ParseEUTLine(line);
                        ParseSUTLine(line);
                        ParseEUALine(line);
                        ParseSUALine(line);
                        line = SR.ReadLine();
                    }
                    //done reading through the file

                }
                catch (Exception e)
                {
                    Console.WriteLine("Error opening or parsing file. \n" + e.ToString());
                }
                finally
                {
                    if (SR != null) SR.Close();
                }
            }

            //I should probably use string builder here, but EH.
            outputXML += "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n";
            outputXML += "<StressSettings>\n";
            outputXML += "<Profile>\n";

            WriteRUSFindings();
            string line1 = outputXML;
            outputXML = "";
            WriteSUSFindings();
            string line2 = outputXML;
            outputXML = "";
            WriteEUTFindings();
            WriteSUTFindings();
            WriteEUAFindings();
            WriteSUAFindings();

            outputXML += "</Profile>\n";
            outputXML += "</StressSettings>\n";


            //write out the xml file
            TextWriter file = null;
            try
            {
                file = new StreamWriter("ProfileStressSettings.xml");
                file.WriteLine(line1 + line2 + outputXML);
            }
            catch (Exception e)
            {
                Console.WriteLine("There was an error writing to XML file. All was probably lost. :(");
                Console.WriteLine(e.ToString());
            }
            finally
            {
                if (file != null)
                {
                    file.Close();
                }
            }
            

        }

        private static void ParseEUTLine(string line)
        {
            string[] split = line.Split('|');
            // DateTime | EUT | hr | from user| for user | numTitles | TitleId, TitleId...

            if (split == null || split.Length != 7) return;
            if (split[1] != "EUT") return;

            if (split[5].Trim() == "0") ETMan.AddZeroTitles();
            else
            {
                string[] titles = split[6].Split(',');
                ETMan.AddTitles(titles);
            }
        }
        private static void ParseEUALine(string line)
        {
            string[] split = line.Split('|');
            // DateTime | EUa | hr | from user| titleid | foruser

            if (split == null || split.Length != 6) return;
            if (split[1] != "EUA") return;

            EAMan.AddTitle(split[4]);
        }
        private static void ParseSUALine(string line)
        {
            string[] split = line.Split('|');
            // DateTime | SUA | hr | titleid | user| req version | resp version | req ach | resp ach

            if (split == null || split.Length != 9) return;
            if (split[1] != "SUA") return;
            if (split[7].Length > 0 && split[8].Length == 0)
            {
                SAMan.AddReqAchieve(split[6].Split(','));
                SAMan.AddReqTitle(split[3]);
                SAMan.numReqRequests++;
            }
            else if (split[8].Length > 0 && split[7].Length == 0)
            {
                SAMan.AddRespAchieve(split[7].Split(','));
                SAMan.AddRespTitle(split[3]);
                SAMan.numRespRequests++;
            }
            else if (split[7].Length > 0 && split[8].Length > 0)
            {
                SAMan.AddBothAchieve(split[7].Split(','), split[8].Split(','));
                SAMan.AddBothTitle(split[3]);
                SAMan.numBothRequests++;
            }
            else
            {
              SAMan.numEmptyRequests++;
            }
            SAMan.numTotalRequests++;
        }
        private static void ParseSUTLine(string line)
        {
            string[] split = line.Split('|');
            // DateTime | SUT | hr | user| req version | resp version | req titles | resp titles

            if (split == null || split.Length != 8) return;
            if (split[1] != "SUT") return;
            if (split[6].Length > 0 && split[7].Length == 0)
            {
                STMan.AddReqTitles(split[6].Split(','));
                STMan.numReqRequests++;
            }
            else if (split[7].Length > 0 && split[6].Length == 0)
            {
                STMan.AddRespTitles(split[7].Split(','));
                STMan.numRespRequests++;
            }
            else if (split[7].Length > 0 && split[6].Length > 0) STMan.numBothRequests++;
            else
            {
                STMan.numEmptyRequests++;
            }

            STMan.numTotalRequests++;
        }
        private static void WriteEUAFindings()
        {
            Hashtable temp = new Hashtable();
            temp["4"] = .16;
            temp["32"] = .08;
            temp["110"] = .76;
            outputXML += "\t<EnumAchievements>\n";
            try
            {
                foreach (string maxAch in temp.Keys)
                {
                    outputXML += "\t\t<Scenario min=\"0\" max=\""+maxAch+"\" ratio=\""+((double)temp[maxAch]).ToString() +"\">\n";
                    try
                    {
                        string[] titles = EAMan.GetTitleArray();
                        foreach (string t in titles)
                        {
                            double titleRatio = EAMan.GetTitleRatio(t);
                            if (titleRatio > .001)
                                outputXML += "\t\t\t<title num=\"" + t + "\" ratio=\"" + titleRatio + "\" />\n";
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("There was an error writing EUA findings to file. \n" + e.ToString());
                    }
                    finally
                    {
                        outputXML += "\t\t</Scenario>\n";
                    }
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("There was an error writing EUA findings to file. \n" + e.ToString());
            }
            finally
            {
                outputXML += "\t</EnumAchievements>\n";
            }
        }
        private static void WriteEUTFindings()
        {
            outputXML += "\t<EnumTitles>\n";
            try
            {
                int[] numTitles = ETMan.getNumTitleArray();
                foreach (int num in numTitles)
                {
                    outputXML += "\t\t<Scenario num=\""+num.ToString()+"\" ratio=\""+ETMan.GetNumTitleRatio(num)+"\" />\n";
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("There was an error writing EUT findings to file. \n" + e.ToString());
            }
            finally
            {
                outputXML += "\t</EnumTitles>\n";
            }
        }
        private static void WriteSUTFindings()
        {
            outputXML += "\t<SyncTitles>\n";
            try
            {
                outputXML += "\t\t<Type name=\"RequestTitles\" ratio=\""+STMan.GetReqTitleRatio()+"\" >\n";
                try
                {
                    int[] numReqTitles = STMan.GetNumReqTitleList();
                    foreach (int num in numReqTitles)
                    {
                        outputXML += "\t\t\t<Scenario num=\"" + num.ToString() + "\" ratio=\"" + STMan.GetNumReqTitleRatio(num) + "\" >\n";
                        try
                        {
                            string[] titles = STMan.GetReqTitleListByNum(num);
                            foreach (string t in titles)
                            {
                                double titleRatio = STMan.GetReqTitleRatioByNum(num, t);
                                if (titleRatio > .001)
                                    outputXML += "\t\t\t\t<title num=\"" + t + "\" ratio=\"" + titleRatio + "\" />\n";
                            }
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("There was an error writing SUT findings to file for req settings. \n" + e.ToString());
                        }
                        finally
                        {
                            outputXML += "\t\t\t</Scenario>\n";
                        }
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("There was an error writing SUT findings to file for req settings. \n" + e.ToString());
                }
                finally
                {
                    outputXML += "\t\t</Type>\n";
                }

                outputXML += "\t\t<Type name=\"ResponseTitles\" ratio=\"" + STMan.GetRespTitleRatio() + "\" >\n";
                try
                {
                    int[] numRespTitles = STMan.GetNumRespTitleList();
                    foreach (int num in numRespTitles)
                    {
                        outputXML += "\t\t\t<Scenario num=\"" + num.ToString() + "\" ratio=\"" + STMan.GetNumRespTitleRatio(num) + "\" >\n";
                        try
                        {
                            string[] titles = STMan.GetRespTitleListByNum(num);
                            foreach (string t in titles)
                            {
                                double titleRatio = STMan.GetRespTitleRatioByNum(num, t);
                                if (titleRatio > .001)
                                    outputXML += "\t\t\t\t<title num=\"" + t + "\" ratio=\"" + titleRatio + "\" />\n";
                            }
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("There was an error writing SUT findings to file for req settings. \n" + e.ToString());
                        }
                        finally
                        {
                            outputXML += "\t\t\t</Scenario>\n";
                        }
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("There was an error writing SUT findings to file for resp settings. \n" + e.ToString());
                }
                finally
                {
                    outputXML += "\t\t</Type>\n";
                }
                outputXML += "\t\t<Type name=\"BothTitles\" ratio=\"" + STMan.GetBothTitleRatio() + "\" />\n";
                outputXML += "\t\t<Type name=\"EmptyTitles\" ratio=\"" + STMan.GetEmptyTitleRatio() + "\" />\n";
            }
            catch (Exception e)
            {
                Console.WriteLine("There was an error writing SUT findings to file. \n" + e.ToString());
            }
            finally
            {
                outputXML += "\t</SyncTitles>\n";
            }
        }
        private static void WriteSUAFindings()
        {
            outputXML += "\t<SyncAchievements>\n";
            try
            {
                outputXML += "\t\t<Type name=\"RequestAchievements\" ratio=\"" + SAMan.GetReqAchieveRatio() + "\" >\n";
                try
                {
                    int[] numReqAchieve = SAMan.GetNumReqAchieveList();
                    foreach (int num in numReqAchieve)
                    {
                        outputXML += "\t\t\t<Scenario num=\"" + num.ToString() + "\" ratio=\"" + SAMan.GetNumReqAchieveRatio(num) + "\" />\n";
                        
                    }
                    string[] titles = SAMan.GetReqAchieveTitleList();
                    foreach (string t in titles)
                    {
                        double tRatio = SAMan.GetReqAchieveTitleRatio(t);
                        if (tRatio > .001)
                            outputXML += "\t\t\t<title num=\"" + t + "\" ratio=\"" + tRatio + "\" />\n";
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("There was an error writing SUA findings to file for req Achievements. \n" + e.ToString());
                }
                finally
                {
                    outputXML += "\t\t</Type>\n";
                }

                outputXML += "\t\t<Type name=\"ResponseAchievements\" ratio=\"" + SAMan.GetRespAchieveRatio() + "\" >\n";
                try
                {
                    int[] numRespAchieve = SAMan.GetNumRespAchieveList();
                    foreach (int num in numRespAchieve)
                    {
                        outputXML += "\t\t\t<Scenario num=\"" + num.ToString() + "\" ratio=\"" + SAMan.GetNumRespAchieveRatio(num) + "\" />\n";
                    }
                    string[] titles = SAMan.GetRespAchieveTitleList();
                    foreach (string t in titles)
                    {
                        double tRatio = SAMan.GetRespAchieveTitleRatio(t);
                        if (tRatio > .001)
                            outputXML += "\t\t\t<title num=\"" + t + "\" ratio=\"" + tRatio + "\" />\n";
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("There was an error writing SUA findings to file for resp Achievements. \n" + e.ToString());
                }
                finally
                {
                    outputXML += "\t\t</Type>\n";
                }
                outputXML += "\t\t<Type name=\"BothAchievements\" ratio=\"" + SAMan.GetBothAchieveRatio() + "\" >\n";
                outputXML += "\t\t\t<Scenario num=\"1\" ratio=\"1\" />\n";
                string[] bothtitles = SAMan.GetBothAchieveTitleList();
                foreach (string t in bothtitles)
                {
                    double tRatio = SAMan.GetBothAchieveTitleRatio(t);
                    if (tRatio > .001)
                        outputXML += "\t\t\t<title num=\"" + t + "\" ratio=\"" + tRatio + "\" />\n";
                }
                outputXML += "\t\t</Type>\n";
                outputXML += "\t\t<Type name=\"EmptyAchievements\" ratio=\"" + SAMan.GetEmptyAchieveRatio() + "\" />\n";
            }
            catch (Exception e)
            {
                Console.WriteLine("There was an error writing SUA findings to file. \n" + e.ToString());
            }
            finally
            {
                outputXML += "\t</SyncAchievements>\n";
            }
        }

       

        private static void ParseRUSLine(string line)
        {
            string[] split = line.Split('|');
            //read settings log lines have 7 data fragments segmented by '|'
            
            if (split == null || split.Length != 7) return;

            if (split[1] != "RUS") return;
            //save the title id
            if (titleIDs[split[3]] == null)
            {
                titleIDs[split[3]] = 1;
            }
            else
            { 
                int numtitle = (int) titleIDs[split[3]];
                numtitle++;
                titleIDs[split[3]] = numtitle;
            }
            //save the settingids
            string[] settings = split[6].Split(',');
            foreach (string s in settings)
            {
                if (settingIDs[s] == null)
                {
                    settingIDs[s] = 1;
                }
                else
                {
                    int numsetting = (int)settingIDs[s];
                    numsetting++;
                    settingIDs[s] = numsetting;
                }
            }
            //parse users
            string[] users = split[5].Split(',');

            //add request statistics
            int numReads = users.Length * settings.Length;
            if (requests[numReads] == null)
            {
                requests[numReads] = 1;
            }
            else
            {
                int numtimes = (int)requests[numReads];
                numtimes++;

                requests[numReads] = numtimes++; 
            }

            //add settings objects galore.
            SettingRequest temp = new SettingRequest(settings);
            if (settingRequests[temp] == null)
            {
                SettingRequestMapping map = new SettingRequestMapping(users.Length, split[3]);
                settingRequests[temp] = map;
            }
            else
            {
                SettingRequestMapping map = (SettingRequestMapping)settingRequests[temp];
                map.AddUserCount(users.Length, split[3]);

                settingRequests[temp] = map;
            }
            //increase the total counter
            totalRSRequests++;


        }

        private static void ParseSUSLine(string line)
        {
            string[] split = line.Split('|');

            //read settings log lines have 9 data fragments segmented by '|'
            //DateTime | SUS | hr | titleid | userid| request version datetime | response version datetime | request settings | response settings 
            if (split == null || split.Length != 9) return;

            if (split[1] != "SUS") return;
            //save the title id
            if (synctitleIDs[split[3]] == null)
            {
                synctitleIDs[split[3]] = 1;
            }
            else
            {
                int numtitle = (int)synctitleIDs[split[3]];
                numtitle++;
                synctitleIDs[split[3]] = numtitle;
            }
            //save the requested settingids
            if (split[7].Length > 0 && split[8].Length == 0)
            {
                SSMan.AddRequestedSettings(split[7].Split(','), split[3]);
                SSMan.totalOnlyRequestedSettings++;
            }
            else if (split[7].Length == 0 && split[8].Length > 0)
            {
                SSMan.AddResponseSettings(split[8].Split(','), split[3]);
                SSMan.totalOnlyResponseSettings++;
                
            }
            else if (split[7].Length > 0 && split[8].Length > 0)
            {
                SSMan.AddBothSettings(split[7].Split(','), split[8].Split(','), split[3]);
                SSMan.totalBothSettings++;
            }
            else
            {
                SSMan.totalEmptyCalls++;
            }
            
            //general stuff
            string[] settings = split[7].Split(',');
            foreach (string s in settings)
            {
                if (syncsettingIDs[s] == null)
                {
                    syncsettingIDs[s] = 1;
                }
                else
                {
                    int numsetting = (int)syncsettingIDs[s];
                    numsetting++;
                    syncsettingIDs[s] = numsetting;
                }
            }

            //add request statistics
            int numsettings = settings.Length;
            if (requests[numsettings] == null)
            {
                requests[numsettings] = 1;
            }
            else
            {
                int numtimes = (int)requests[numsettings];
                numtimes++;
                requests[numsettings] = numtimes++;
            }
            SSMan.totalSyncSettingsRequests++;
        }

        private static void WriteSUSFindings()
        {
            outputXML += "\t<SyncSettings>\n";
            try
            {
                //write out response statistics

                outputXML += "\t\t<Type name=\"RequestedSettings\" ratio=\""+SSMan.GetRequestedTotalRatio()+"\">\n";
                try
                {
                    //write out the scenarios
                    string[][] scenarios = SSMan.GetRequestedScenarios();
                    int scenarioCount = 1;
                    foreach (string[] sa in scenarios)
                    {
                        double scenRatio = SSMan.GetRequestedScenarioRatio(sa);
                        if (scenRatio < .001) continue;
                        outputXML += "\t\t\t<Scenario ID=\"" + scenarioCount++ + "\" ratio=\"" + scenRatio + "\">\n";
                        try
                        {
                            outputXML += "\t\t\t\t<Settings>\n";
                            foreach (string s in sa)
                            {
                                outputXML += "\t\t\t\t\t<setting ID = \"" + s + "\" />\n";
                            }
                            outputXML += "\t\t\t\t</Settings>\n";

                            string[] titles = SSMan.GetRequestedScenarioTitles(sa);
                            foreach (string title in titles)
                            {
                                double r = SSMan.GetRequestedScenarioTitleRatio(sa, title);
                                if (r >= .01)
                                    outputXML += "\t\t\t\t<title num=\"" + title + "\" ratio=\"" + r + "\" />\n";
                            }
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("There was an error writing SUS findings to file for requested settings. \n" + e.ToString());
                        }
                        finally
                        {
                            outputXML += "\t\t\t</Scenario>\n";
                        }
                    }
                    /* kkline:
                     * Not sure why this is here, it is not parsed in GPSTress, and 
                     * uses the settings instead of the Titles
                    //write out the titles
                    string[] titlesOverall = SSMan.GetRequestedTitles();
                    foreach (string title in titlesOverall)
                    {
                        double r = SSMan.GetRequestedTitleRatio(title);
                        if (r >= .01)
                            outputXML += "\t\t\t<title num=\"" + title + "\" ratio=\"" + r + "\" />\n";
                    }
                    end kkline*/
                }
                catch (Exception e)
                {
                    Console.WriteLine("There was an error writing SUS findings to file for requested settings. \n" + e.ToString());
                }
                finally
                {
                    outputXML += "\t</Type>\n";
                }

                outputXML += "\t\t<Type name=\"ResponseSettings\" ratio = \""+SSMan.GetResponseTotalRatio()+"\">\n";
                try
                {
                    //write out the scenarios
                    string[][] scenarios = SSMan.GetResponseScenarios();
                    int scenarioCount = 1;
                    foreach (string[] sa in scenarios)
                    {
                        double scenRatio = SSMan.GetResponseScenarioRatio(sa);
                        if (scenRatio < .01) continue;
                        outputXML += "\t\t\t<Scenario ID=\"" + scenarioCount++ + "\" ratio = \"" + scenRatio + "\">\n";
                        try
                        {
                            outputXML += "\t\t\t\t<Settings>\n";
                            foreach (string s in sa)
                            {
                                outputXML += "\t\t\t\t\t<Setting ID = \""+s+"\" />\n";
                            }
                            outputXML += "\t\t\t\t</Settings>\n";

                            string[] titles = SSMan.GetResponseScenarioTitles(sa);
                            foreach (string title in titles)
                            {
                                double r = SSMan.GetResponseScenarioTitleRatio(sa, title);
                                if (r >= .01)
                                     outputXML += "\t\t\t\t<title num=\""+title+"\" ratio=\""+r+"\" />\n";
                            }
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("There was an error writing SUS findings to file for response settings. \n" + e.ToString());
                        }
                        finally
                        {
                            outputXML += "\t\t\t</Scenario>\n";
                        }
                    }
                    //write out the titles
                    //string[] titles = SSMan.GetResponseTitles();
                    //foreach (string title in titles)
                    //{
                    //    double r = SSMan.GetResponseTitleRatio(title);
                    //    if (r >= .01)
                    //        outputXML += "\t\t\t<title ID=\"" + title + "\" ratio=\"" + r + "\" />\n";
                    //}


                }
                catch (Exception e)
                {
                    Console.WriteLine("There was an error writing SUS findings to file for response settings. \n" + e.ToString());
                }
                finally
                {
                    outputXML += "\t</Type>\n";
                }


                outputXML += "\t\t<Type name=\"BothSettings\" ratio = \""+SSMan.GetBothTotalRatio()+"\">\n";
                try
                {
                    //write out the scenarios
                    string[][] req;
                    string[][] resp;
                    SSMan.GetBothScenarios(out req, out resp);
                    int scenarioCount = 1;
                    for(int i=0; i<req.Length; i++)
                    {
                        double scenRatio = SSMan.GetBothScenarioRatio(req[i], resp[i]);
                        if (scenRatio < .01) continue;
                        outputXML += "\t\t\t<Scenario ID=\"" + scenarioCount++ + "\" ratio = \"" + scenRatio + "\">\n";
                        try
                        {
                            outputXML += "\t\t\t\t<ReqSettings>\n";
                            foreach (string s in req[i])
                            {
                                outputXML += "\t\t\t\t\t<Setting ID = \""+s+"\" />\n";
                            }
                            outputXML += "\t\t\t\t</ReqSettings>\n";

                            outputXML += "\t\t\t\t<RespSettings>\n";
                            foreach (string s in resp[i])
                            {
                                outputXML += "\t\t\t\t\t<Setting ID = \"" + s + "\" />\n";
                            }
                            outputXML += "\t\t\t\t</RespSettings>\n";

                            string[] titles = SSMan.GetBothScenarioTitles(req[i], resp[i]);
                            foreach (string title in titles)
                            {
                                double r = SSMan.GetBothScenarioTitleRatio(req[i], resp[i], title);
                                if (r >= .01)
                                     outputXML += "\t\t\t\t<title ID=\""+title+"\" ratio=\""+r+"\" />\n";
                            }
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("There was an error writing SUS findings to file for both settings. \n" + e.ToString());
                        }
                        finally
                        {
                            outputXML += "\t\t\t</Scenario>\n";
                        }
                    }
                    //write out the titles
                    //string[] titles = SSMan.GetBothTitles();
                    //foreach (string title in titles)
                    //{
                    //    double r = SSMan.GetBothTitleRatio(title);
                    //    if (r >= .01)
                    //        outputXML += "\t\t\t<title ID=\"" + title + "\" ratio=\"" + r + "\" />\n";
                    //}


                }
                catch (Exception e)
                {
                    Console.WriteLine("There was an error writing SUS findings to file for requested settings. \n" + e.ToString());
                }
                finally
                {
                    outputXML += "\t</Type>\n";
                }

                outputXML += "\t\t<Type name=\"EmptySettings\" ratio = \"" + SSMan.GetEmptyTotalRatio() + "\" />\n";
            }
            catch (Exception e)
            {
                Console.WriteLine("There was an error writing SUS findings to file. \n" + e.ToString());
            }
            finally
            {
                outputXML += "\t</SyncSettings>\n";
            }
        }

        private static void WriteRUSFindings()
        {
            //write out results to csv file for easy graphing!
            //write out settings data.
            outputXML += "\t<ReadSettings>\n";
            try
            {
                //rusfindings contains boringish toplevel analysis
                TextWriter file = new StreamWriter("RUSFindings.csv");
                //calculate how many times setting x was seen in all requests
                file.WriteLine("Setting ID,Occurrance");
                foreach (string s in settingIDs.Keys)
                {
                    file.WriteLine(s + "," + ((int)settingIDs[s]).ToString());
                }
                //calculate how many times title x was seen in all requests
                file.WriteLine("Title ID,Occurrance");
                foreach (string s in titleIDs.Keys)
                {
                    file.WriteLine(s + "," + ((int)titleIDs[s]).ToString());
                }
                //calculate how many times each distinct (users*settings) number was requested
                file.WriteLine("Users*Settings,Occurrance");
                foreach (int s in requests.Keys)
                {
                    file.WriteLine(s.ToString() + "," + ((int)requests[s]).ToString());
                }
                file.Close();

                file = new StreamWriter("RUSFindings2.csv");
                file.WriteLine("Setting array,titleID,number of users,occurrance");
                string nextline = "Setting array,total number of times requested\n";
                string newfile = "Setting array,titleID,numer of users, occurrance,ratio for user, total occurrances for user, total overall\n";
                string newfile2 = "Setting array, numer of users, occurrance, ratio for user\n";
                uint totalOccurrences = 0;

                //pull out each setting request "scenario" and do some calculations on it
                int scenarioCount = 0;
                foreach (SettingRequest SR in settingRequests.Keys)
                {
                    scenarioCount++;
                    string settingarray = "";
                    //convert settingsarray array into a single hashable string 
                    for (int i = 0; i < SR.settings1.Length; i++)
                    {
                        settingarray += SR.settings1[i];
                        if (i < SR.settings1.Length - 1) settingarray += '+';
                    }

                    SettingRequestMapping map = (SettingRequestMapping)settingRequests[SR];
                    nextline += settingarray + "," + map.totalTimesRequested + "\n";
                   
                    //update xml file with new scenario and ratio of requests that the scenario is
                    double ratio = (double)map.totalTimesRequested/ (double)totalRSRequests;

                    outputXML += "\t\t<Scenario ID=\"" + scenarioCount + "\" ratio=\"" + ratio.ToString() + "\">\n";
                    try
                    {
                        //output the settings for this scenario
                        outputXML += "\t\t\t<Settings>\n";
                        try
                        {
                            foreach (string s in SR.settings1)
                            {
                                outputXML += "\t\t\t\t<setting ID=\"" + s + "\" /> \n";
                            }
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("There was an error writing RUS findings to file for the settings of a scenario. \n" + e.ToString());
                        }
                        finally
                        {
                            outputXML += "\t\t\t</Settings>\n";
                        }
                        //do some old accounting crap
                        Hashtable usersToOccurrence = new Hashtable();
                        foreach (string s in map.usersToTimesRequested.Keys)
                        {
                            string[] titleiduser = s.Split('+');
                            int occurrance = (int)map.usersToTimesRequested[s];
                            totalOccurrences += (uint)occurrance;

                            if (usersToOccurrence[titleiduser[1]] == null)
                            {
                                usersToOccurrence[titleiduser[1]] = occurrance;
                            }
                            else
                            {
                                usersToOccurrence[titleiduser[1]] = occurrance + (int)usersToOccurrence[titleiduser[1]];
                            }

                            file.WriteLine(settingarray + "," + titleiduser[0] + "," + titleiduser[1] + "," + occurrance.ToString());
                        }
                        //more some old accounting crap
                        foreach (string s in map.usersToTimesRequested.Keys)
                        {
                            string[] titleiduser = s.Split('+');
                            int occurrance = (int)map.usersToTimesRequested[s];

                            double r = (double)occurrance / (double)((int)usersToOccurrence[titleiduser[1]]);
                            if (ratio * 100 < 1) continue;

                            newfile += settingarray + "," + titleiduser[0] + "," + titleiduser[1] + "," + occurrance.ToString() + "," + r.ToString() + "," + (int)usersToOccurrence[titleiduser[1]] + "," + totalOccurrences + "\n";


                        }
                        foreach (string numUsers in usersToOccurrence.Keys)
                        {
                            double ratio1 = (double)((int)usersToOccurrence[numUsers]) / (double)totalOccurrences;
                            newfile2 += settingarray + "," + numUsers + "," + ((int)usersToOccurrence[numUsers]).ToString() + "," + ratio1.ToString() + "\n";
                        }


                        //calculate the user ratios for the xml string
                        string[] userArray = map.GetUserArray();
                        foreach (string u in userArray)
                        {
                            try
                            {
                                //calculate the ratio
                                double userRatio = map.GetUserOccuranceAcrossAllTitlesRatio(u);
                                outputXML += "\t\t\t<user num=\"" + u + "\" ratio=\"" + userRatio.ToString() + "\" /> \n";

                            }
                            catch (Exception e)
                            {
                                Console.WriteLine("There was an error writing RUS findings to file for a user. \n" + e.ToString());
                            }
                        }
                        //calculate the title ratios for the xml string
                        string[] titleArray = map.GetTitleArray();
                        foreach (string t in titleArray)
                        {
                            try
                            {
                                //calculate the ratio
                                double titleRatio = map.GetTitleOccuranceAcrossAllUsersRatio(t);
                                if (titleRatio > .01)
                                    outputXML += "\t\t\t<title num=\"" + t + "\" ratio=\"" + titleRatio.ToString() + "\" /> \n";

                            }
                            catch (Exception e)
                            {
                                Console.WriteLine("There was an error writing RUS findings to file for a title. \n" + e.ToString());
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("There was an error writing RUS findings to file. \n"+e.ToString());
                    }
                    finally
                    {
                        outputXML+="\t\t</Scenario>\n";
                    }
                }
                if (totalOccurrences != totalRSRequests)
                {
                    //we've got a bookkeeping problem somewhere
                    Console.WriteLine("We have a bookkeeping problem somewhere in the RUS objects.");
                    Console.WriteLine("Calculated occurrance from objects = " + totalOccurrences + ", occurance from parsing section = " + totalRSRequests);
                }
                file.Write(nextline);

                file.Close();

                file = new StreamWriter("RUSFindings3.csv");

                file.Write(newfile2);
                file.Write(newfile);

                file.Close();

            }
            catch (Exception e)
            {
                Console.WriteLine("error opening file or writing out results.\n" + e.ToString());
            }
            finally
            {
                outputXML += "\t</ReadSettings>\n";
            }

            Console.WriteLine("Results written to RUSFindings.csv and RUSFindings2.csv");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\BatchRecoveryTest.cs ===
using System;
using System.IO;
using System.Xml;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.config;

[assembly: RootNode(typeof(BatchRecoveryTest.BatchRecoverySuite))]

namespace BatchRecoveryTest
{
    /// <summary>
    ///   <TestSuite>BatchRecovery</TestSuite>
    ///   <Tester>KKline</Tester>
    ///   <Developer>MattChil</Developer>
    ///   <PM>CarlosCo</PM>
    ///   <Status></Status>
    /// </summary>
    /// <remarks>
    ///   <Goal></Goal>
    ///   <NonGoal></NonGoal>
    ///   <Description>
    ///   </Description>
    /// </remarks>
    [Owner("kkline"), Description("BatchRecovery Test Suite")]
    public class BatchRecoverySuite : TestNode
    {
        // These are for the bulk titles
        public const int TitleIDStart = 11000;
        public const int TitleCount = 500;

        // Initialize
        public override void PreRun(RUN_TYPE runType)
        {
            // Make sure you brush up on the best practices of STF: http://xblwiki/default.aspx/XboxLive/STFBestPractices.html
            //
            // See a list of test case attributes you can use here: http://xblwiki/default.aspx/XboxLive/STFAttributeList.html
            //
            // This page explains how to set the test case priorities: http://xblwiki/default.aspx/XboxLive/TestCasePriorityDefinitions.html 

            // Set the endpoint for FakeSG to your service, if needed
            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence_int).ToString());

            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                // Functional initialization
                FriendsCommon.UserAllocBlockSize = (uint)50;

                // Make sure we have the test titles for the large cases
                PropBulkTitles();

                // We also need the specific titles from Achievement tests 
                // for Mobile, Avatar Award gender tests, so let's do them as well
                PropTitles();

            }
            else if (runType == RUN_TYPE.STRESS)
            {
                // Stress initialization
                // TBD - using GPStress most likely
            }
        }
        public void PropBulkTitles()
        {
            Global.RO.Info("Checking to see if stress titles are propped correctly. This might take a little while.");

            string pathToConfigFiles = "InputFiles\\GamerProfile\\";
            //let's make sure the title information is present...
            for (uint title = (uint)TitleIDStart; title < TitleCount + TitleIDStart; title++)
            {
                try
                {
                    TitleConfig.GetTitle(title);
                }
                catch (ApplicationException)
                {
                    //prop the title accordingly
                    Global.RO.Info("Title number " + title + " not found in NPDB--attempting to remedy via sql file...");
                    try
                    {
                        string totalPath = pathToConfigFiles + "200titles.sql";
                        StreamReader file = File.OpenText(totalPath);
                        String sql;
                        sql = file.ReadToEnd();

                        int indexOfStart = sql.IndexOf("*");
                        sql = sql.Remove(indexOfStart, 1);
                        sql = sql.Insert(indexOfStart, title.ToString());

                        int indexOfEnd = sql.IndexOf("*");
                        sql = sql.Remove(indexOfEnd, 1);
                        sql = sql.Insert(indexOfEnd, (TitleCount + TitleIDStart).ToString());

                        Npdb npdb = new Npdb();
                        npdb.ConnectToServer();
                        npdb.IssueCommand(sql);
                        npdb.Close();

                    }
                    catch (Exception e)
                    {
                        Global.RO.Warn("Could not prop title " + title + "!  Test results may be inaccurate.");
                        Global.RO.Warn("Text is as follows:" + e.ToString());
                    }
                    Global.RO.Info("Title configuration info added successfully!");
                }
            }
        }

        public void PropTitles()
        {
            Global.RO.Info("Checking to see if custom titles are propped correctly. This might take a little while.");

            string pathToConfigFiles = "InputFiles\\GamerProfile\\";

            // Titles 50-97 for Achievements (original ones from Achievement tests)
            // Title 98 added for WinMo (ach plus 5 unisex avatar awards)
            // Title 99 added for WebGames (ach plus 5 unisex avatar awards)
            // Titles 200-204 added for AvatarAssets 
            // 200=5 Unisex, 201=34 Unisex, 202=5 Male/Female, 203=CrossPlat 360/PC, 204=Hidden Avatar Asset
            uint[] titles = { 50, 51, 52, 53, 54, 96, 97, 98, 99, 200, 201, 202, 203, 204 };

            foreach (uint title in titles)
            {
                try
                {
                    TitleConfig.GetTitle(title);
                }
                catch (ApplicationException)
                {
                    //prop the title accordingly
                    Global.RO.Info("Title number " + title + " not found in NPDB--attempting to remedy via sql file...");
                    try
                    {
                        StreamReader file = File.OpenText(pathToConfigFiles + "achievement" + title + ".sql");
                        String sql;
                        sql = file.ReadToEnd();
                        Npdb npdb = new Npdb();
                        npdb.ConnectToServer();
                        npdb.IssueCommand(sql);
                        npdb.Close();

                    }
                    catch (Exception e)
                    {
                        Global.RO.Warn("Could not prop title " + title + "!  Test results may be inaccurate.");
                        Global.RO.Warn("Text is as follows:" + e.ToString());
                    }
                    Global.RO.Info("Title configuration info added successfully!");
                }
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\AvatarManifestParser\AvatarManifestReader.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using xonline.common.config;
using xonline.common.service;
using ServerTestFramework.LiveService.UserSettings;

namespace AvatarManifestParser
{
    class AvatarManifestReader
    {
        // This app takes in a single CSV formatted file with two pieces of data.
        // The format of the file should be created from the query against UODB
        //
        //      select bi_user_puid,vb_value from t_user_settings
        //      where i_setting_id=0x63E80044
        //
        // Run this query against a single UODB partition, which on 4/15/2010 was around 550,000 rows
        // After you run it, output the results to a CSV file
        //
        // Technically we aren't using the puid at this point, but we could in the future
        //
        static void Main(string[] args)
        {
            StreamReader SR = null;
            StreamWriter SW =new StreamWriter("AvatarManifestResults.txt");
            //StreamWriter ASW = new StreamWriter("AvatarManifestCounts.txt");
            
            Dictionary<Guid, uint> assetCounterMale = new Dictionary<Guid, uint>();
            Dictionary<Guid, uint> assetCounterFemale = new Dictionary<Guid, uint>();
            Dictionary<double, uint> heightCounterMale = new Dictionary<double, uint>();
            Dictionary<double, uint> heightCounterFemale = new Dictionary<double, uint>();
            Dictionary<double, uint> weightCounterMale = new Dictionary<double, uint>();
            Dictionary<double, uint> weightCounterFemale = new Dictionary<double, uint>();
            Dictionary<uint, uint>[] colorCountersMale = new Dictionary<uint, uint>[9];
            Dictionary<uint, uint>[] colorCountersFemale = new Dictionary<uint, uint>[9];
            
            //I cut the manifest counter code out because most avatars were unique as expected
            //Dictionary<string, uint> manifestMaleCounter = new Dictionary<string, uint>();
            //Dictionary<string, uint> manifestFemaleCounter = new Dictionary<string, uint>();

            string inputFile = null;
            string line = null;
            uint goodcount = 0;
            uint badcount = 0;

            if ((args.Length != 2)&&((args[0]=="-f")||(args[0]=="/f")))
            {
                Console.WriteLine("Invalid args: -f filename");
                return;
            }
            else
            {
                // Arg 1 should be the file path
                inputFile = args[1];
            }

            try
            {
                // try to open the file for parsing
                SR = File.OpenText(inputFile);

                // Setup the Asset Ids from the existing TOC lookup
                foreach (KeyValuePair<Guid,string> assets in AvatarAssets.assetsById)
                {
                    assetCounterMale.Add(assets.Key, 0);
                    assetCounterFemale.Add(assets.Key, 0);
                }

                // Build the height and weight Dictionaries
                // there are only 5 choices for each
                heightCounterMale.Add(-1.0, 0);
                heightCounterMale.Add(-0.5, 0);
                heightCounterMale.Add(0.0, 0);
                heightCounterMale.Add(0.5, 0);
                heightCounterMale.Add(1.0, 0);
                weightCounterMale.Add(-1.0, 0);
                weightCounterMale.Add(-0.5, 0);
                weightCounterMale.Add(0.0, 0);
                weightCounterMale.Add(0.5, 0);
                weightCounterMale.Add(1.0, 0);

                // Female
                heightCounterFemale.Add(-1.0, 0);
                heightCounterFemale.Add(-0.5, 0);
                heightCounterFemale.Add(0.0, 0);
                heightCounterFemale.Add(0.5, 0);
                heightCounterFemale.Add(1.0, 0);
                weightCounterFemale.Add(-1.0, 0);
                weightCounterFemale.Add(-0.5, 0);
                weightCounterFemale.Add(0.0, 0);
                weightCounterFemale.Add(0.5, 0);
                weightCounterFemale.Add(1.0, 0);

                // Build the color counter dictionaries in the array
                for (int i = 0; i < colorCountersMale.Length; i++)
                {
                    colorCountersMale[i] = new Dictionary<uint, uint>();
                }

                // Female - Build the color counter dictionaries in the array
                for (int i = 0; i < colorCountersFemale.Length; i++)
                {
                    colorCountersFemale[i] = new Dictionary<uint, uint>();
                }

                // assume the first line is good.
                line = SR.ReadLine();
                //read the file in line by line
                while (line != null)
                {
                    string[] splitLine = line.Split(',');
                    string strManifest = null;

                    if (splitLine.Length != 2)
                    {
                        Console.WriteLine("Invalid input line");
                        badcount++;
                    }
                    else
                    {
                        //don't care about the bi_user_puid at this point so skip splitLine[0]

                        //if the manifest starts with 0x (which it should), remove that
                        if (splitLine[1].StartsWith("0x"))
                            strManifest = splitLine[1].Remove(0, 2);
                        else
                            strManifest = splitLine[1];

                        if (strManifest == "")
                            badcount++;
                        else
                        {
                            AvatarManifest manifest = AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(strManifest));
                            
                            if (manifest.BodyComponentInfo.ModelAssetId == AvatarAssets.LookupAssetByName("Male body"))
                            {
                                ParseManifest(manifest, ref assetCounterMale, ref heightCounterMale, ref weightCounterMale, ref colorCountersMale);
                                //CountManifests(manifest, ref manifestMaleCounter);
                                goodcount++;
                            }
                            else if (manifest.BodyComponentInfo.ModelAssetId == AvatarAssets.LookupAssetByName("Female body"))
                            {
                                ParseManifest(manifest, ref assetCounterFemale, ref heightCounterFemale, ref weightCounterFemale, ref colorCountersFemale);
                                //CountManifests(manifest, ref manifestFemaleCounter);
                                goodcount++;
                            }
                            else
                                badcount++;
                        }
                    }

                    // Read another line
                    line = SR.ReadLine();
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Error opening or parsing file. \n" + e.ToString());
            }

            //Output results
            Console.WriteLine("Good Manifests: {0}", goodcount.ToString());
            SW.WriteLine("Good Manifests: {0}", goodcount.ToString());
            Console.WriteLine("Bad Manifests: {0}", badcount.ToString());
            SW.WriteLine("Bad Manifests: {0}", badcount.ToString());
            Console.WriteLine("Total Manifests: {0}", (goodcount + badcount).ToString());
            SW.WriteLine("Total Manifests: {0}", (goodcount + badcount).ToString());
            SW.WriteLine("");
            SW.WriteLine("MALE Avatar Manifests Breakdown");
            SW.WriteLine("");
            foreach (Guid g in assetCounterMale.Keys)
            {
                if (AvatarAssets.LookupAssetName(g).StartsWith("Unknown asset"))
                    SW.WriteLine(g + ": " + assetCounterMale[g]);       
                else
                    SW.WriteLine(AvatarAssets.LookupAssetName(g) + ": " + assetCounterMale[g]);       
            }

            foreach (double d in heightCounterMale.Keys)
            {
                SW.WriteLine("Male Height " + d + ": " + heightCounterMale[d]);
            }

            foreach (double d in weightCounterMale.Keys)
            {
                SW.WriteLine("Male Weight " + d + ": " + weightCounterMale[d]);
            }

            for (int i = 0; i < colorCountersMale.Length; i++)
            {
                // Write out the name of the Colorable from the Enum
                Array values = System.Enum.GetValues(typeof(AvatarManifest.Color_e));
                SW.WriteLine(Enum.GetName(typeof(AvatarManifest.Color_e), values.GetValue(i)));

                // Loops through each key for this colorable and output the RGB value and count
                foreach (uint ui in colorCountersMale[i].Keys)
                {
                    byte[] RGB = BitConverter.GetBytes(ui);
                    SW.WriteLine("( {0} , {1} , {2} ) : {3}",RGB[1],RGB[2],RGB[3], colorCountersMale[i][ui]);
                }
            }
            SW.WriteLine("");
            SW.WriteLine("FEMALE Avatar Manifests Breakdown");
            SW.WriteLine("");
            foreach (Guid g in assetCounterFemale.Keys)
            {
                if (AvatarAssets.LookupAssetName(g).StartsWith("Unknown asset"))
                    SW.WriteLine(g + ": " + assetCounterFemale[g]);
                else
                    SW.WriteLine(AvatarAssets.LookupAssetName(g) + ": " + assetCounterFemale[g]);
            }

            foreach (double d in heightCounterFemale.Keys)
            {
                SW.WriteLine("Female Height " + d + ": " + heightCounterFemale[d]);
            }

            foreach (double d in heightCounterFemale.Keys)
            {
                SW.WriteLine("Female Weight " + d + ": " + heightCounterFemale[d]);
            }

            for (int i = 0; i < colorCountersFemale.Length; i++)
            {
                // Write out the name of the Colorable from the Enum
                Array values = System.Enum.GetValues(typeof(AvatarManifest.Color_e));
                SW.WriteLine(Enum.GetName(typeof(AvatarManifest.Color_e), values.GetValue(i)));

                // Loops through each key for this colorable and output the RGB value and count
                foreach (uint ui in colorCountersFemale[i].Keys)
                {
                    byte[] RGB = BitConverter.GetBytes(ui);
                    SW.WriteLine("( {0} , {1} , {2} ) : {3}", RGB[1], RGB[2], RGB[3], colorCountersFemale[i][ui]);
                }
            }
            
            /* Cutting this code out for now, not really any value added when it was
             * originally run, about 6 total manifests that had 20 matches, which i guess
             * was more or less expected.
             * 
            // Now display the manifest strings and their counts
            ASW.WriteLine("Male Avatar Manifest Strings Breakdown");
            ASW.WriteLine("");
            foreach (string s in manifestMaleCounter.Keys)
            {
                if ((int)manifestMaleCounter[s] >= 10)
                    ASW.WriteLine(s + " : " + manifestMaleCounter[s]);
            }

            ASW.WriteLine("");
            ASW.WriteLine("Female Avatar Manifest Strings Breakdown");
            ASW.WriteLine("");
            foreach (string s in manifestFemaleCounter.Keys)
            {
                if ((int)manifestFemaleCounter[s] >= 10)
                    ASW.WriteLine(s + " : " + manifestFemaleCounter[s]);
            }
            */

            // cleanup
            if (SR != null)
                SR.Close();

            if (SW != null)
                SW.Close();

            /*
            if (ASW != null)
                ASW.Close();
            */
        }

        private static void ParseManifest(AvatarManifest manifest, ref Dictionary<Guid, uint> assetCounter, ref  Dictionary<double, uint> heightCounter, 
                                          ref Dictionary<double, uint> weightCounter, ref Dictionary<uint, uint>[] colorCounters)
        {
            // Only one valid Head Guid
            if ((manifest.HeadComponentInfo.ModelAssetId != Guid.Empty)&&(assetCounter.ContainsKey(manifest.HeadComponentInfo.ModelAssetId)))
                assetCounter[manifest.HeadComponentInfo.ModelAssetId]++;

            // Only two valid Body Guids
            if ((manifest.BodyComponentInfo.ModelAssetId != Guid.Empty)&&(assetCounter.ContainsKey(manifest.BodyComponentInfo.ModelAssetId)))
                assetCounter[manifest.BodyComponentInfo.ModelAssetId]++;

            if (heightCounter.ContainsKey(manifest.HeightFactor))
                heightCounter[manifest.HeightFactor]++;

            if (weightCounter.ContainsKey(manifest.WeightFactor))
                weightCounter[manifest.WeightFactor]++;

            if (manifest.BlendShapes[(int)AvatarManifest.Shape_e.Chin].BlendShapeAssetId != Guid.Empty)
                assetCounter[manifest.BlendShapes[(int)AvatarManifest.Shape_e.Chin].BlendShapeAssetId]++;

            if (manifest.BlendShapes[(int)AvatarManifest.Shape_e.Ear].BlendShapeAssetId != Guid.Empty)
                assetCounter[manifest.BlendShapes[(int)AvatarManifest.Shape_e.Ear].BlendShapeAssetId]++;

            if (manifest.BlendShapes[(int)AvatarManifest.Shape_e.Nose].BlendShapeAssetId != Guid.Empty)
                assetCounter[manifest.BlendShapes[(int)AvatarManifest.Shape_e.Nose].BlendShapeAssetId]++;

            if (manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.Eye].TextureAssetId != Guid.Empty)
                assetCounter[manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.Eye].TextureAssetId]++;

            if (manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.EyeBrow].TextureAssetId != Guid.Empty)
                assetCounter[manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.EyeBrow].TextureAssetId]++;

            if (manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.EyeShadow].TextureAssetId != Guid.Empty)
                assetCounter[manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.EyeShadow].TextureAssetId]++;

            if (manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.FacialHair].TextureAssetId != Guid.Empty)
                assetCounter[manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.FacialHair].TextureAssetId]++;

            if (manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.Mouth].TextureAssetId != Guid.Empty)
                assetCounter[manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.Mouth].TextureAssetId]++;

            if (manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.SkinFeatures].TextureAssetId != Guid.Empty)
                assetCounter[manifest.ReplacementTextures[(int)AvatarManifest.Texture_e.SkinFeatures].TextureAssetId]++;

            foreach (AvatarManifest.XAVATAR_COMPONENT_INFO component in manifest.ComponentInfo)
            {
                if ((component != null)&&(component.ModelAssetId != Guid.Empty))
                {
                    if (assetCounter.ContainsKey(component.ModelAssetId))
                        assetCounter[component.ModelAssetId]++;
                    // else the component is an award or purchased item
                    // we'll add the GUID to the list, and have to not look it up later but just print out the GUID
                    else
                    {
                        assetCounter.Add(component.ModelAssetId, 1);
                    }
                }
            }

            // This is for all 9 Colorable items.  Each colorable has a dictionary which stores the colors and the associated
            // counts for them.  

            // Skin
            if (colorCounters[(int)AvatarManifest.Color_e.Skin].ContainsKey(manifest.DynamicColors[(int)AvatarManifest.Color_e.Skin].c))
                colorCounters[(int)AvatarManifest.Color_e.Skin][manifest.DynamicColors[(int)AvatarManifest.Color_e.Skin].c]++;
            else
                colorCounters[(int)AvatarManifest.Color_e.Skin].Add(manifest.DynamicColors[(int)AvatarManifest.Color_e.Skin].c,1);

            // Hair
            if (colorCounters[(int)AvatarManifest.Color_e.Hair].ContainsKey(manifest.DynamicColors[(int)AvatarManifest.Color_e.Hair].c))
                colorCounters[(int)AvatarManifest.Color_e.Hair][manifest.DynamicColors[(int)AvatarManifest.Color_e.Hair].c]++;
            else
                colorCounters[(int)AvatarManifest.Color_e.Hair].Add(manifest.DynamicColors[(int)AvatarManifest.Color_e.Hair].c, 1);

            // Mouth
            if (colorCounters[(int)AvatarManifest.Color_e.Mouth].ContainsKey(manifest.DynamicColors[(int)AvatarManifest.Color_e.Mouth].c))
                colorCounters[(int)AvatarManifest.Color_e.Mouth][manifest.DynamicColors[(int)AvatarManifest.Color_e.Mouth].c]++;
            else
                colorCounters[(int)AvatarManifest.Color_e.Mouth].Add(manifest.DynamicColors[(int)AvatarManifest.Color_e.Mouth].c, 1);

            // Iris
            if (colorCounters[(int)AvatarManifest.Color_e.Iris].ContainsKey(manifest.DynamicColors[(int)AvatarManifest.Color_e.Iris].c))
                colorCounters[(int)AvatarManifest.Color_e.Iris][manifest.DynamicColors[(int)AvatarManifest.Color_e.Iris].c]++;
            else
                colorCounters[(int)AvatarManifest.Color_e.Iris].Add(manifest.DynamicColors[(int)AvatarManifest.Color_e.Iris].c, 1);

            // EyeBrow
            if (colorCounters[(int)AvatarManifest.Color_e.EyeBrow].ContainsKey(manifest.DynamicColors[(int)AvatarManifest.Color_e.EyeBrow].c))
                colorCounters[(int)AvatarManifest.Color_e.EyeBrow][manifest.DynamicColors[(int)AvatarManifest.Color_e.EyeBrow].c]++;
            else
                colorCounters[(int)AvatarManifest.Color_e.EyeBrow].Add(manifest.DynamicColors[(int)AvatarManifest.Color_e.EyeBrow].c, 1);
            
            // Eye Shadow
            if (colorCounters[(int)AvatarManifest.Color_e.EyeShadow].ContainsKey(manifest.DynamicColors[(int)AvatarManifest.Color_e.EyeShadow].c))
                colorCounters[(int)AvatarManifest.Color_e.EyeShadow][manifest.DynamicColors[(int)AvatarManifest.Color_e.EyeShadow].c]++;
            else
                colorCounters[(int)AvatarManifest.Color_e.EyeShadow].Add(manifest.DynamicColors[(int)AvatarManifest.Color_e.EyeShadow].c, 1);

            // Facial Hair
            if (colorCounters[(int)AvatarManifest.Color_e.FacialHair].ContainsKey(manifest.DynamicColors[(int)AvatarManifest.Color_e.FacialHair].c))
                colorCounters[(int)AvatarManifest.Color_e.FacialHair][manifest.DynamicColors[(int)AvatarManifest.Color_e.FacialHair].c]++;
            else
                colorCounters[(int)AvatarManifest.Color_e.FacialHair].Add(manifest.DynamicColors[(int)AvatarManifest.Color_e.FacialHair].c, 1);

            // SkinFeatures1
            if (colorCounters[(int)AvatarManifest.Color_e.SkinFeatures1].ContainsKey(manifest.DynamicColors[(int)AvatarManifest.Color_e.SkinFeatures1].c))
                colorCounters[(int)AvatarManifest.Color_e.SkinFeatures1][manifest.DynamicColors[(int)AvatarManifest.Color_e.SkinFeatures1].c]++;
            else
                colorCounters[(int)AvatarManifest.Color_e.SkinFeatures1].Add(manifest.DynamicColors[(int)AvatarManifest.Color_e.SkinFeatures1].c, 1);

            // SkinFeatures2
            if (colorCounters[(int)AvatarManifest.Color_e.SkinFeatures2].ContainsKey(manifest.DynamicColors[(int)AvatarManifest.Color_e.SkinFeatures2].c))
                colorCounters[(int)AvatarManifest.Color_e.SkinFeatures2][manifest.DynamicColors[(int)AvatarManifest.Color_e.SkinFeatures2].c]++;
            else
                colorCounters[(int)AvatarManifest.Color_e.SkinFeatures2].Add(manifest.DynamicColors[(int)AvatarManifest.Color_e.SkinFeatures2].c, 1);

            return;
        }

        // This function was added to do a quick check to see if there were any common manifests in the system
        // The result were the 12 default avatars from the picker, and then 6 or so ones that had about 20 copies.  
        // The data shows that this step is probably not as valuable, and so for now this is commented out and not used
        // but can be easily run if the data may change.  
        private static void CountManifests(AvatarManifest tempManifest, ref Dictionary<string, uint> manifestCounter)
        {
            // For counting the avatar manifests, lets eliminate what previous components they had
            // so we can get a more accurate picture of actual avatars

            // find the previous component shirt
            AvatarManifest.XAVATAR_COMPONENT_INFO previousCompShirt = Array.Find(tempManifest.PreviousRequiredComponentInfo, prci => (prci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Shirt) != 0);
            // set the Asset to empty and the component mask to None (required)
            previousCompShirt.ModelAssetId = new AvatarAssetId(Guid.Empty);
            previousCompShirt.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.None;

            // find the previous component pants
            AvatarManifest.XAVATAR_COMPONENT_INFO previousPants = Array.Find(tempManifest.PreviousRequiredComponentInfo, prci => (prci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Trousers) != 0);
            // set the Asset to empty and the component mask to None (required)
            previousPants.ModelAssetId = new AvatarAssetId(Guid.Empty);
            previousPants.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.None;

            // find the previous component shoes
            AvatarManifest.XAVATAR_COMPONENT_INFO previousShoes = Array.Find(tempManifest.PreviousRequiredComponentInfo, prci => (prci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Shoes) != 0);
            // set the Asset to empty and the component mask to None (required)
            previousShoes.ModelAssetId = new AvatarAssetId(Guid.Empty);
            previousShoes.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.None;
            
            // find the previous component hair
            AvatarManifest.XAVATAR_COMPONENT_INFO previousHair = Array.Find(tempManifest.PreviousRequiredComponentInfo, prci => (prci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Hair) != 0);
            // set the Asset to empty and the component mask to None (required)
            previousHair.ModelAssetId = new AvatarAssetId(Guid.Empty);
            previousHair.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.None;

            // And we should clear out the owner XUID as well
            tempManifest.OwnerXuid = 0;

            string strManifest = null;
            byte[] byteManifest = new byte[1000];
            byteManifest = tempManifest.ToArray();
            for (int i = 0; i < 1000; i++)
                strManifest += byteManifest[i];

            // Now start counting them
            if (manifestCounter.ContainsKey(strManifest))
                manifestCounter[strManifest]++;
            // else the component is an award or purchased item
            // we'll add the GUID to the list, and have to not look it up later but just print out the GUID
            else
            {
                manifestCounter.Add(strManifest, 1);
            }

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\BatchRecoveryStress.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace BatchRecoveryTest
{
    /// <summary>
    /// Not currently needed, will most likely use GPStress
    /// </summary>
    [StressTest, Description("")]
    public class StressTest1 : TestNode
    {
        public override void Run()
        {
            // Place your StressTest1 test logic here
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\BatchRecoveryBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Globalization;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth.Claims;
using ServerTestFramework;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.AvatarAsset;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.LiveService.XSTS;
using xonline.common.config;
using xonline.common.diagnostics;

namespace BatchRecoveryTest
{
    public partial class BatchRecoveryBase : TestNode
    {
        // Single FriendsCommon object
        public static FriendsCommon Fc = new FriendsCommon();

        // For Data Population
        public const int TitleAchievementCount = 40;
        public const int TitleAvatarAwardCount = 5;

        // Routing stuff
        public static string profileUri = "http://" + (Global.XEnv.MultiSettingRead(MultiSetting.authsg_hostNameMappings)[0].Split(','))[1] + "/users/";
        public static string progressUri = "http://" + (Global.XEnv.MultiSettingRead(MultiSetting.authsg_hostNameMappings)[0].Split(','))[1] + "/users/";
        public static string aasgUri = "http://" + Global.XEnv.GetVirtualInterface(VirtualInterface.authsg).ToString() + "/users/";

        // Constants in the service
        public const int DefaultMaxItems = 32;

        // Random for generating fake title data
        public static Random random = new Random();

        #region ProfileIds
        public static uint[] ProfileIds = new uint[]
        {
            // Standard Profile Ones
            0x10040000, 0x10040002, 0x10040003, 0x63E83FFF, 0x63E83FFE, 0x63E83FFD,
            0x10040005, 0x10040007, 0x10040008, 0x1004000C, 0x1004000D, 0x1004000E, 
            0x4064000F, 0x40640010, 0x402C0011, 0x10040015, 0x10040018, 0x1004001d, 
            0x1004001e, 0x10040022, 0x10040023, 0x10040024, 0x10040026, 0x10040027, 
            0x10040028, 0x10040029, 0x1004003B, 0x1004003C, 0x1004003D, 0x1004003E, 
            0x41040040, 0x40520041, 0x41900042, 0x43E80043, 0x63E80044, 0x63E80045, 
            0x10040047, 0x10040048, 0x406403E8, 0x100403EA, 0x100403EB, 0x100403EC, 
            0x100403ED, 0x100403EE, 0x100403EF, 0x100403F0, 0x100403F1, 0x603403F2 
            
            /* Zune no-worky ones
               0x100403F3, 0x700803F4, 0x406403FD, 0x406403FE, 0x43E803FA,
               0x60A803F5, 0x410003F6, 0x601003F7, 0x601003F8, 0x601003F9
            */

            /*  Can't write to these, server restrictions prevent it
                0x10040001 Gamer_type 
                0x10040006 Gamercard_cred
                0x5004000B Gamercard_rep
                0x10040004 GAMER_ZONE 
                0x10040012 Gamercard_titles_played 
                0x10040013 achievements_earned
                0x10040038 title_cred
                0x10040039 title_achievements_earned
                0x1004003A gamer_tier
                0x1004003F service_flags
                0x63E80051 JUMP_IN_LIST (internal only)
            */   
            /*  Transient settings won't return because no reason to, not stored in DB
                0x61000046 party_info 
                0x6020004A Video_metadata 
            */
        };
        #endregion

        #region Validation

        public void ValidateSettings(UserSetting[] expectedGlobal, UserTitleSetting[] expectedTitle, UserProfileSetting[] actual)
        {
            Assert.IsTrue(actual != null, "Actual user settings array is null.");

            foreach (UserProfileSetting actualSetting in actual)
            {
                if (actualSetting.TitleId == 0xfffe07d1)
                {
                    bool found = false;
                    foreach (UserSetting globalSetting in expectedGlobal)
                    {
                        if (globalSetting.SettingId == actualSetting.Id &&
                            Convert.ToBase64String(globalSetting.Value) == actualSetting.ValueString &&
                            globalSetting.Value.Length == actualSetting.Value.Length)
                        {
                            found = true;
                            break;
                        }
                    }
                    Assert.IsTrue(found == true, "Was unable to find expected global setting " + actualSetting.Id.ToString());
                }
                else
                {
                    bool found = false;
                    foreach (UserTitleSetting expectedSetting in expectedTitle)
                    {
                        if (expectedSetting.titleId == actualSetting.TitleId &&
                            expectedSetting.userSetting.SettingId == actualSetting.Id &&
                            Convert.ToBase64String(expectedSetting.userSetting.Value) == actualSetting.ValueString &&
                            expectedSetting.userSetting.Value.Length == actualSetting.Value.Length)
                        {
                            found = true;
                            break;
                        }
                    }
                    Assert.IsTrue(found == true, "Was unable to find expected global setting " + actualSetting.Id);
                }
            }
        }

        public void ValidateUserTitles(UserTitle[] expectedTitles, UserProgressTitle[] actual)
        {
            Assert.IsTrue(actual != null, "Actual user titles array is null.");

            if (expectedTitles == null)
                return;

            Assert.AreEqual(expectedTitles.Length, actual.Length, "User title array lengths don't match.");

            for (int i = 0; i < expectedTitles.Length; ++i)
            {
                // Compare in reverse order
                //CompareDateTimes(expectedTitles[i].LastPlayed, actual[actual.Length - 1 - i].LastPlayed);
                
                // Note: the local values aren't written to the database until recalc gamerscore is called so we will always get 0 back
                Assert.AreEqual(expectedTitles[i].NumAchievements, actual[actual.Length - 1 - i].UserAchievements);
                Assert.AreEqual(expectedTitles[i].NumCreds, actual[actual.Length - 1 - i].UserGamerscore);

                Assert.AreEqual(expectedTitles[i].Sequence, actual[actual.Length - 1 - i].Sequence);
                Assert.AreEqual(expectedTitles[i].TitleId, actual[actual.Length - 1 - i].TitleId);
                Assert.AreEqual(expectedTitles[i].TitleName, actual[actual.Length - 1 - i].Name);

                // Note: actual values are populated from titleconfig on server when returned
                //Assert.AreEqual(expectedTitles[i].TotalAchievements, actual[i].MaxAchievements);
                //Assert.AreEqual(expectedTitles[i].TotalCred, actual[i].MaxGamerscore);
            }
        }

        public void ValidateAchievements(AchievementWD[] expectedAchievements, UserProgressAchievement[] actual)
        {
            Assert.IsTrue(expectedAchievements != null, "Expected achievements cannot be null.");
            Assert.IsTrue(actual != null, "Actual achievements cannot be null.");

            for (int i = 0; i < actual.Length; ++i)
            {
                // Compare in reverse order
                CompareDateTimes(expectedAchievements[i].Achieved, actual[actual.Length - 1 - i].AchievedDate);
                Assert.AreEqual(expectedAchievements[i].AchievementId, actual[actual.Length - 1 - i].Id);
                Assert.AreEqual(expectedAchievements[i].Flags, actual[actual.Length - 1 - i].Flags);
                Assert.AreEqual(GetPlatformTypeFromFlags(expectedAchievements[i].Flags), actual[actual.Length - 1 - i].Platform);
            }
        }

        public void ValidateTitleAchievements(UserPossibleAchievement[] expectedAchievements, UserPossibleAchievement[] actual)
        {
            Assert.IsTrue(expectedAchievements != null, "Expected achievements cannot be null.");
            Assert.IsTrue(actual != null, "Actual achievements cannot be null.");

            for (int i = 0; i < actual.Length; ++i)
            {
                Assert.AreEqual(expectedAchievements[i].Description, actual[i].Description);
                Assert.AreEqual(expectedAchievements[i].Gamerscore, actual[i].Gamerscore);
                Assert.AreEqual(expectedAchievements[i].HowTo, actual[i].HowTo);
                Assert.AreEqual(expectedAchievements[i].Id, actual[i].Id);
                Assert.AreEqual(expectedAchievements[i].ImageId, actual[i].ImageId);
                Assert.AreEqual(expectedAchievements[i].SecretAchievement, actual[i].SecretAchievement);
                Assert.AreEqual(expectedAchievements[i].Title, actual[i].Title);
                Assert.AreEqual(expectedAchievements[i].TitleId, actual[i].TitleId);
                Assert.AreEqual(expectedAchievements[i].Type, actual[i].Type);
            }
        }

        public void ValidateAvatarAssets(AvatarAssetWD[] expectedAssets, UserProgressAvatarAward[] actual)
        {
            Assert.IsTrue(expectedAssets != null, "Expected avatar assets cannot be null.");
            Assert.IsTrue(actual != null, "Actual avatar assets cannot be null.");

            for (int i = 0; i < actual.Length; ++i)
            {
                CompareDateTimes(expectedAssets[i].Awarded, actual[i].AwardedDate);
                Assert.AreEqual(expectedAssets[i].BodyTypeMask, actual[i].BodyTypeMask);
                Assert.AreEqual(expectedAssets[i].Flags, actual[i].Flags);
                Assert.AreEqual(expectedAssets[i].AvatarAssetOrdinal, actual[i].Id);
                Assert.AreEqual(GetPlatformTypeFromFlags(expectedAssets[i].Flags), actual[i].Platform);
                Assert.AreEqual(expectedAssets[i].Sequence, actual[i].Sequence);
                //Assert.AreEqual(expectedAssets[i]., actual[i].TitleId);
            }
        }

        public void ValidateTitleAvatarAwards(UserPossibleAvatarAward[] expectedAvatarAwards, UserPossibleAvatarAward[] actual)
        {
            Assert.IsTrue(expectedAvatarAwards != null, "Expected avatar awards cannot be null.");
            Assert.IsTrue(actual != null, "Actual avatar awards cannot be null.");

            for (int i = 0; i < actual.Length; ++i)
            {
                Assert.AreEqual(expectedAvatarAwards[i].AssetId, actual[i].AssetId);
                Assert.AreEqual(expectedAvatarAwards[i].BodyComponent, actual[i].BodyComponent);
                Assert.AreEqual(expectedAvatarAwards[i].BodyTypeMask, actual[i].BodyTypeMask);
                Assert.AreEqual(expectedAvatarAwards[i].Description, actual[i].Description);
                Assert.AreEqual(expectedAvatarAwards[i].HowTo, actual[i].HowTo);
                Assert.AreEqual(expectedAvatarAwards[i].Id, actual[i].Id);
                Assert.AreEqual(expectedAvatarAwards[i].ImageId, actual[i].ImageId);
                Assert.AreEqual(expectedAvatarAwards[i].SecretAward, actual[i].SecretAward);
                Assert.AreEqual(expectedAvatarAwards[i].SubCategory, actual[i].SubCategory);
                Assert.AreEqual(expectedAvatarAwards[i].Title, actual[i].Title);
                Assert.AreEqual(expectedAvatarAwards[i].TitleId, actual[i].TitleId);
            }
        }

        private TimeSpan timeEpsilon = new TimeSpan(0, 0, 30);

        public void CompareDateTimes(DateTime expected, DateTime actual)
        {
            CompareDateTimes(expected, actual, timeEpsilon);
        }

        public void CompareDateTimes(DateTime expected, DateTime actual, TimeSpan diffAllowed)
        {
            Assert.IsTrue(Math.Abs(expected.Ticks - actual.Ticks) < diffAllowed.Ticks, "Time difference was too great.");
        }

        // Copied from statsprot.cs
        public static int GetPlatformTypeFromFlags(int flags)
        {
            uint newFlags = (uint)flags & 0x00700000; //XOn.XACHIEVEMENT_DETAILS_PLATFORM_MASK;
            uint achFlag = 0;

            switch (newFlags)
            {
                case 0x00100000: //XOn.XACHIEVEMENT_DETAILS_PLATFORM_360:
                    achFlag = 1; //XOn.XPLT_XBOX360;
                    break;
                case 0x00200000: //XOn.XACHIEVEMENT_DETAILS_PLATFORM_PC:
                    achFlag = 2; //XOn.XPLT_PC;
                    break;
                case 0x00300000: //XOn.XACHIEVEMENT_DETAILS_PLATFORM_MOBILE:
                    achFlag = 15; //XOn.XPLT_MOBILE;
                    break;
                case 0x00400000: //XOn.XACHIEVEMENT_DETAILS_PLATFORM_WEB_GAMES:
                    achFlag = 16; //XOn.XPLT_WEB_GAMES;
                    break;
                default:
                    break;
            }

            return (int)achFlag;
        }

        public static uint GetFlagsFromPlatformType(uint platform)
        {
            switch (platform)
            {
                case 1: //XOn.XPLT_XBOX360
                    return 0x00100000; //XOn.XACHIEVEMENT_DETAILS_PLATFORM_360:
                case 2: //XOn.XPLT_PC;
                    return 0x00200000; //XOn.XACHIEVEMENT_DETAILS_PLATFORM_PC:
                case 15: //XOn.XPLT_MOBILE;
                    return 0x00300000; //XOn.XACHIEVEMENT_DETAILS_PLATFORM_MOBILE:
                case 16://XOn.XPLT_WEB_GAMES;
                    return 0x00400000; //XOn.XACHIEVEMENT_DETAILS_PLATFORM_WEB_GAMES:
                default:
                    break;
            }

            return 0;
        }

        public static T[] GetSubArray<T>(T[] data, int index, int length)
        {
            T[] result = new T[length];
            Array.Copy(data, index, result, 0, length);
            return result;
        }

        #endregion

        #region Authorization

        private const string _Issuer = "xsts.xboxlive.com";

        public static List<IClaimsIdentity> GetTestToken(string gamertag, ulong xuid)
        {
            return GetTestToken(gamertag, xuid, "Xbox360", 0xFFFE0000, 1, 103);
        }

        public static List<IClaimsIdentity> GetTestToken(string gamertag, ulong xuid, string deviceType)
        {
            return GetTestToken(gamertag, xuid, deviceType, 0xFFFE0000, 1, 103);
        }

        public static List<IClaimsIdentity> GetTestToken(string gamertag, ulong xuid, string deviceType, int language, int country)
        {
            return GetTestToken(gamertag, xuid, deviceType, 0xFFFE0000, language, country);
        }

        public static List<IClaimsIdentity> GetTestToken(string gamertag, ulong xuid, string deviceType, uint titleId, int language, int country)
        {
            //Make up a token by adding claims. 
            //Feel free to leave what you don't care about as default values and just change the ones you care about.
            List<Claim> claims = new List<Claim>()
            {
                new Claim(AuthClaimTypes.DeviceId, "FA00FFFFFFFFFFFF", ClaimValueTypes.HexBinary, _Issuer),
                new Claim(AuthClaimTypes.DeviceType, deviceType, ClaimValueTypes.String, _Issuer),
                new Claim(AuthClaimTypes.FlowToken, "EF594473B7D97D8D", ClaimValueTypes.HexBinary, _Issuer),
                new Claim(AuthClaimTypes.TitleId, titleId.ToString("X"), ClaimValueTypes.HexBinary, _Issuer),
                new Claim(AuthClaimTypes.TitleVersion, "1", ClaimValueTypes.HexBinary, _Issuer),
                new Claim(AuthClaimTypes.AgeGroup, "Adult", ClaimValueTypes.String, _Issuer),
                new Claim(AuthClaimTypes.PartnerXuid, "CB7E3DD1C3BBAC569F75031E61D1507CE7FFE7B7", ClaimValueTypes.HexBinary, _Issuer),
                new Claim(AuthClaimTypes.ClientIpPort, "10.124.212.84:65535", AuthClaimValueTypes.IpAddress, _Issuer),
                new Claim(AuthClaimTypes.Country, country.ToString(), ClaimValueTypes.Integer, _Issuer),
                new Claim(AuthClaimTypes.Gamertag, gamertag, _Issuer),
                new Claim(AuthClaimTypes.Language, language.ToString(), ClaimValueTypes.Integer, _Issuer),
                new Claim(AuthClaimTypes.Privileges, "255", AuthClaimValueTypes.IntegerArray, _Issuer),
                new Claim(AuthClaimTypes.Puid, "37FFF893377D2", ClaimValueTypes.HexBinary, _Issuer),
                new Claim(AuthClaimTypes.Tier, "Gold", _Issuer),
                new Claim(AuthClaimTypes.Xuid, xuid.ToString("X"), ClaimValueTypes.HexBinary, _Issuer),
            };
            List<IClaimsIdentity> identities = new List<IClaimsIdentity>()
            {
                new ClaimsIdentity(claims, AuthenticationTypes.Federation),
            };

            return identities;
        }

        public string GetXSTSToken(PNUser user, uint titleId)
        {
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.userPuid0 = user.UserId;
            slot.machinePuid = user.Xbox.XboxId;
            slot.titleId = titleId;

            SimpleXSTSClient clt = new SimpleXSTSClient();
            string s = clt.GetTokenStringFromSTS(ServerTestFramework.LiveService.XSTS.SimpleXSTSClient.CreateDefaultRST(), slot, 0);
            return s;
        }

        #endregion

        public static string GenerateContinuationToken(uint startingIndex)
        {
            return startingIndex.ToString() + "," + DateTime.MinValue.ToString("O", CultureInfo.InvariantCulture);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\BatchRecoveryFunc.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using Microsoft.IdentityModel.Claims;
using ServerTestFramework;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.AvatarAsset;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserSettings;
using xonline.common.diagnostics;

namespace BatchRecoveryTest
{
    #region URI Negative Cases
    [Owner("kkline")]
    [TestGroup, Description("Batch Settings API Negative Tests")]
    public class URI_NegativeCases : TestNode
    {
        /// <summary>
        /// MyValues Indexes
        /// [0] = MaxItems for Request
        /// [1] = SkipItems for Request
        /// [2] = ContinuationToken for Request
        /// [3] = API
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Validates the correct error codes are returned for negative values."), EnvRequirement("")]
        [CompoundCase("Settings_NegativeMaxItems", -5, 0, "0", "settings")]
        [CompoundCase("Settings_NegativeStartIndex", 32, -5, "0", "settings")]
        [CompoundCase("Settings_NegativeContinuationToken", 32, 0, "-5", "settings")]
        [CompoundCase("TitleHistory_NegativeMaxItems", -5, 0, "0", "titlehistory")]
        [CompoundCase("TitleHistory_NegativeStartIndex", 32, -5, "0", "titlehistory")]
        [CompoundCase("TitleHistory_NegativeContinuationToken", 32, 0, "-5", "titlehistory")]
        [CompoundCase("Achievements_NegativeMaxItems", -5, 0, "0", "progress/achievements")]
        [CompoundCase("Achievements_NegativeStartIndex", 32, -5, "0", "progress/achievements")]
        [CompoundCase("Achievements_NegativeContinuationToken", 32, 0, "-5", "progress/achievements")]
        [CompoundCase("TitleAchievements_NegativeMaxItems", -5, 0, "0", "progress/titleachievements")]
        [CompoundCase("TitleAchievements_NegativeStartIndex", 32, -5, "0", "progress/titleachievements")]
        [CompoundCase("TitleAchievements_NegativeContinuationToken", 32, 0, "-5", "progress/titleachievements")]
        [CompoundCase("AvatarAwards_NegativeMaxItems", -5, 0, "0", "progress/avatarawards")]
        [CompoundCase("AvatarAwards_NegativeStartIndex", 32, -5, "0", "progress/avatarawards")]
        [CompoundCase("AvatarAwards_NegativeContinuationToken", 32, 0, "-5", "progress/avatarawards")]
        [CompoundCase("TitleAvatarAwards_NegativeMaxItems", -5, 0, "0", "progress/titleavatarawards")]
        [CompoundCase("TitleAvatarAwards_NegativeStartIndex", 32, -5, "0", "progress/titleavatarawards")]
        [CompoundCase("TitleAvatarAwards_NegativeContinuationToken", 32, 0, "-5", "progress/titleavatarawards")]
        public class NegativeParameterValidation : BatchRecoveryBase
        {
            PNUser user = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
            }

            public override void Run()
            {
                string uri = ((string)MyValues[3]).Contains("settings") ? profileUri : progressUri;
                string url = String.Empty;

                if (((string)MyValues[2]).StartsWith("-"))
                {
                    url = String.Format((string)MyValues[3] + "?maxitems={0}&skipitems={1}&continuationtoken={2}", (int)MyValues[0], (int)MyValues[1], (string)MyValues[2]);
                }
                else
                {
                    url = String.Format((string)MyValues[3] + "?maxitems={0}&skipitems={1}", (int)MyValues[0], (int)MyValues[1]);
                }

                HttpStatusCode code = SendInvalidRequest(uri, url, user);

                Assert.AreEqual(HttpStatusCode.BadRequest, code, " HttpStatusCode (" + code + ") does match what was expected (" + HttpStatusCode.BadRequest + ").");
            }
        }


        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Xuid in XAuth must match requested user's xuid."), EnvRequirement("")]
        [CompoundCase("Settings_InvalidAuth", "settings")]
        [CompoundCase("TitleHistory_InvalidAuth", "titlehistory")]
        [CompoundCase("Achievements_InvalidAuth", "progress/achievements")]
        [CompoundCase("TitleAchievements_InvalidAuth", "progress/titleachievements")]
        [CompoundCase("AvatarAwards_InvalidAuth", "progress/avatarawards")]
        [CompoundCase("TitleAvatarAwards_InvalidAuth", "progress/titleavatarawards")]
        public class InvalidAuthXuid : BatchRecoveryBase
        {
            PNUser user = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
            }

            public override void Run()
            {
                // Make new claims with mismatching xuid
                List<IClaimsIdentity> claims = GetTestToken(user.Name, 1234567890);
                string uri = ((string)MyValues[0]).Contains("settings") ? profileUri : progressUri;

                HttpStatusCode code = SendInvalidRequest(uri, (string)MyValues[0], user, claims);
                Assert.AreEqual(HttpStatusCode.Forbidden, code, " HttpStatusCode (" + code + ") does match what was expected (" + HttpStatusCode.Forbidden + ").");
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Xuid in XAuth must match requested user's xuid."), EnvRequirement("")]
        [CompoundCase("Settings_InvalidAuth", "settings")]
        [CompoundCase("TitleHistory_InvalidAuth", "titlehistory")]
        [CompoundCase("Achievements_InvalidAuth", "progress/achievements")]
        [CompoundCase("TitleAchievements_InvalidAuth", "progress/titleachievements")]
        [CompoundCase("AvatarAwards_InvalidAuth", "progress/avatarawards")]
        [CompoundCase("TitleAvatarAwards_InvalidAuth", "progress/titleavatarawards")]
        public class InvalidAuthRequestor : BatchRecoveryBase
        {
            PNUser requestor = null;
            PNUser requestee = null;

            public override void PreRun()
            {
                requestor = Fc.CreateXenonUser(false);
                requestee = Fc.CreateXenonUser(false);
            }

            public override void Run()
            {
                // Make new claims with other user
                List<IClaimsIdentity> requestorClaims = GetTestToken(requestor.Name, requestor.UserId);
                string uri = ((string)MyValues[0]).Contains("settings") ? profileUri : progressUri;

                HttpStatusCode code = SendInvalidRequest(uri, (string)MyValues[0], requestee, requestorClaims);
                Assert.AreEqual(HttpStatusCode.Forbidden, code, " HttpStatusCode (" + code + ") does match what was expected (" + HttpStatusCode.Forbidden + ").");
            }
        }

        ///// <summary>
        ///// MyValues Indexes
        ///// [0] = Gamertag
        ///// [1] = ExpectedStatusCode
        ///// </summary>
        //[TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Invalid Gamertag cases"), EnvRequirement("")]
        //[CompoundCase("NoGamertag", "", HttpStatusCode.NotFound)]
        //[CompoundCase("StartWithDigitGamertag", "1Gamertag", HttpStatusCode.BadRequest)]
        //[CompoundCase("MaxPlusOneLengthGamertag", "ABCDEFGHIJKLMNOP", HttpStatusCode.BadRequest)]
        //[CompoundCase("NonAlphaNumericGamertags", "@#$%^&*", HttpStatusCode.NotFound)]
        //public class InvalidProfileGamertags : BatchRecoveryBase
        //{
        //    public override void Run()
        //    {
        //        HttpStatusCode code = SendInvalidProfileRequest(MyValues[0].ToString(), "settings");
        //        Assert.AreEqual((HttpStatusCode)MyValues[1], code, " HttpStatusCode does match what was expected.");
        //    }
        //}

        ///// <summary>
        ///// MyValues Indexes
        ///// [0] = Progress path
        ///// [1] = Gamertag
        ///// [2] = ExpectedStatusCode
        ///// </summary>
        //[TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Invalid Gamertag cases"), EnvRequirement("")]
        //[CompoundCase("TitleHistory_NoGamertag", "titlehistory", "", HttpStatusCode.NotFound)]
        //[CompoundCase("TitleHistory_StartWithDigitGamertag", "titlehistory", "1Gamertag", HttpStatusCode.BadRequest)]
        //[CompoundCase("TitleHistory_MaxPlusOneLengthGamertag", "titlehistory", "ABCDEFGHIJKLMNOP", HttpStatusCode.BadRequest)]
        //[CompoundCase("TitleHistory_NonAlphaNumericGamertags", "titlehistory", "@#$%^&*", HttpStatusCode.NotFound)]
        //[CompoundCase("Achievements_NoGamertag", "progress/achievements", "", HttpStatusCode.NotFound)]
        //[CompoundCase("Achievements_StartWithDigitGamertag", "progress/achievements", "1Gamertag", HttpStatusCode.BadRequest)]
        //[CompoundCase("Achievements_MaxPlusOneLengthGamertag", "progress/achievements", "ABCDEFGHIJKLMNOP", HttpStatusCode.BadRequest)]
        //[CompoundCase("Achievements_NonAlphaNumericGamertags", "progress/achievements", "@#$%^&*", HttpStatusCode.NotFound)]
        //[CompoundCase("TitleAchievements_NoGamertag", "progress/titleachievements", "", HttpStatusCode.NotFound)]
        //[CompoundCase("TitleAchievements_StartWithDigitGamertag", "progress/titleachievements", "1Gamertag", HttpStatusCode.BadRequest)]
        //[CompoundCase("TitleAchievements_MaxPlusOneLengthGamertag", "progress/titleachievements", "ABCDEFGHIJKLMNOP", HttpStatusCode.BadRequest)]
        //[CompoundCase("TitleAchievements_NonAlphaNumericGamertags", "progress/titleachievements", "@#$%^&*", HttpStatusCode.NotFound)]
        //[CompoundCase("AvatarAwards_NoGamertag", "progress/avatarawards", "", HttpStatusCode.NotFound)]
        //[CompoundCase("AvatarAwards_StartWithDigitGamertag", "progress/avatarawards", "1Gamertag", HttpStatusCode.BadRequest)]
        //[CompoundCase("AvatarAwards_MaxPlusOneLengthGamertag", "progress/avatarawards", "ABCDEFGHIJKLMNOP", HttpStatusCode.BadRequest)]
        //[CompoundCase("AvatarAwards_NonAlphaNumericGamertags", "progress/avatarawards", "@#$%^&*", HttpStatusCode.NotFound)]
        //[CompoundCase("TitleAvatarAwards_NoGamertag", "progress/titleavatarawards", "", HttpStatusCode.NotFound)]
        //[CompoundCase("TitleAvatarAwards_StartWithDigitGamertag", "progress/titleavatarawards", "1Gamertag", HttpStatusCode.BadRequest)]
        //[CompoundCase("TitleAvatarAwards_MaxPlusOneLengthGamertag", "progress/titleavatarawards", "ABCDEFGHIJKLMNOP", HttpStatusCode.BadRequest)]
        //[CompoundCase("TitleAvatarAwards_NonAlphaNumericGamertags", "progress/titleavatarawards", "@#$%^&*", HttpStatusCode.NotFound)]
        //public class InvalidProgressGamertags : BatchRecoveryBase
        //{
        //    public override void Run()
        //    {
        //        HttpStatusCode code = SendInvalidProgressRequest(MyValues[1].ToString(), MyValues[0].ToString());
        //        Assert.AreEqual((HttpStatusCode)MyValues[2], code, " HttpStatusCode does match what was expected.");
        //    }
        //}
    }
    #endregion

    // TODO:
    //    Perf counters?
    //    Defaults for maxitems/skipitems for all APIs?
    //    Different device types
    //    Other titles / Avatar gender
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\BatchRecoveryBase\DataPopulation.cs ===
﻿using System;
using System.Collections.Generic;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth.Claims;
using ServerTestFramework;
using ServerTestFramework.Core.Utilities;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.AvatarAsset;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserSettings;
using xonline.common.config;
using xonline.common.diagnostics;

namespace BatchRecoveryTest
{
    public partial class BatchRecoveryBase : TestNode
    {
        #region DataPopulation
        public static UserSetting[] SyncGlobalSettings(ulong userId, int settingsCount)
        {
            RandomEx rand = new RandomEx();
            UserSetting[] retSettings = new UserSetting[settingsCount];

            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO >> 16) & 0x3FF);
            //  xonline.common.service.XOn.XONLINE_MAX_SETTING_COUNT
            if (settingsCount > ProfileIds.Length)
            {
                settingsCount = ProfileIds.Length;
            }

            for (int i = 0; i < settingsCount; i++)
            {
                int isettingSize = (int)((ProfileIds[i] >> 16) & 0x3FF);
                UserSetting[] usettings = new UserSetting[1];

                if (ProfileIds[i] == xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1)
                {
                    string manifestToc = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410003C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
                    usettings[0] = new UserSetting(userId, ProfileIds[i], AvatarManifestHelpers.HexToBytes(manifestToc));
                }
                else if (ProfileIds[i] == xonline.common.protocol.ProfileDefs.XPROFILE_PERMISSIONS)
                {                    
                    usettings[0] = new UserSetting(userId,ProfileIds[i], SConvert.Bytes(0x00000004));
                }
                else
                {
                    usettings[0] = new UserSetting(userId, ProfileIds[i], rand.GenerateRandomBlob(isettingSize));
                }

                retSettings[i] = usettings[0];

                SyncSettingsRequest request = new SyncSettingsRequest(xonline.common.service.XOn.XENON_DASH_TITLE_ID, userId, usettings, DateTime.UtcNow);
                SyncSettingsResponse resp = new SyncSettingsResponse();

                resp = request.Execute();
            }

            return retSettings;
        }

        // This allows for me to do error testing for settings
        public static UserSetting[] SyncSingleSetting(ulong userId, uint settingId)
        {
            RandomEx rand = new RandomEx();

            int isettingSize = (int)((settingId >> 16) & 0x3FF);
            UserSetting[] usettings = new UserSetting[1];

            if (settingId == xonline.common.protocol.ProfileDefs.XPROFILE_PERMISSIONS)
                usettings[0] = new UserSetting(userId, settingId, SConvert.Bytes(0x00000004));
            else  
                usettings[0] = new UserSetting(userId, settingId, rand.GenerateRandomBlob(isettingSize));

            SyncSettingsRequest request = new SyncSettingsRequest(xonline.common.service.XOn.XENON_DASH_TITLE_ID, userId, usettings, DateTime.UtcNow);
            SyncSettingsResponse resp = new SyncSettingsResponse();

            resp = request.Execute();

            return usettings;
        }

        public class UserTitleSetting
        {
            public UserSetting userSetting;
            public uint titleId;
        }

        public static UserTitleSetting[] SyncTitleSpecificSettings(ulong userId, int titleCount)
        {
            RandomEx rand = new RandomEx();
            UserTitleSetting[] retSettings = new UserTitleSetting[titleCount * 3];
            for (int i = 0; i < retSettings.Length; i++)
            {
                retSettings[i] = new UserTitleSetting();
            }

            // Max number of titles to use for syncing
            if (titleCount > BatchRecoverySuite.TitleCount)
            {
                titleCount = BatchRecoverySuite.TitleCount;
            }

            for (int i = 0; i < titleCount; i++)
            {
                UserSetting[] usettings = new UserSetting[]
                {
                    new UserSetting(userId, xonline.common.protocol.ProfileDefs.XPROFILE_TITLE_SPECIFIC1, rand.GenerateRandomBlob(1000), SettingSource.XSOURCE_TITLE),
                    new UserSetting(userId, xonline.common.protocol.ProfileDefs.XPROFILE_TITLE_SPECIFIC2, rand.GenerateRandomBlob(1000), SettingSource.XSOURCE_TITLE),
                    new UserSetting(userId, xonline.common.protocol.ProfileDefs.XPROFILE_TITLE_SPECIFIC3, rand.GenerateRandomBlob(1000), SettingSource.XSOURCE_TITLE)
                };

                retSettings[i * 3 + 0].userSetting = usettings[0];
                retSettings[i * 3 + 0].titleId = (uint)(BatchRecoverySuite.TitleIDStart + i);
                retSettings[i * 3 + 1].userSetting = usettings[1];
                retSettings[i * 3 + 1].titleId = (uint)(BatchRecoverySuite.TitleIDStart + i);
                retSettings[i * 3 + 2].userSetting = usettings[2];
                retSettings[i * 3 + 2].titleId = (uint)(BatchRecoverySuite.TitleIDStart + i);

                SyncSettingsRequest request = new SyncSettingsRequest((uint)(BatchRecoverySuite.TitleIDStart + i), userId, usettings, DateTime.UtcNow);
                SyncSettingsResponse resp = new SyncSettingsResponse();

                resp = request.Execute();
            }

            return retSettings;
        }

        public enum TitleAchievementType
        {
            Completion = 1,
            Leveling,
            Unlock,
            Event,
            Tournament,
            Checkpoint,
            Other
        }

        public static AchievementWD[] SyncAchievements(uint titleId, ulong userId, int achCount)
        {
            return SyncAchievements(titleId, userId, achCount, false);
        }

        public static AchievementWD[] SyncAchievements(uint titleId, ulong userId, int achCount, bool titleAchievement)
        {
            if (achCount > xonline.common.service.XOn.XONLINE_MAX_ACHIEVEMENTS)
                achCount = xonline.common.service.XOn.XONLINE_MAX_ACHIEVEMENTS;

            int flags = achievementflags.SetPlatformTypeInFlags((int)achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED | (int)achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE, xonline.common.service.XOn.XPLT_XBOX360);
            if(titleAchievement)
            {
                flags |= (int)TitleAchievementType.Completion;
            }

            AchievementWD[] achToEarn = new AchievementWD[achCount];

            for (int i = 0; i < achCount; i++)
            {
                achToEarn[i] = new AchievementWD((uint)i + 1, (uint)i + 1, flags);
            }

            XRLSyncAchievements request = new XRLSyncAchievements(titleId, userId, achToEarn);
            SyncAchievementsResponse response = new SyncAchievementsResponse();

            response = request.Execute();

            return achToEarn;
        }

        public static AchievementWD[] SyncAchievementsPlatform(uint titleId, ulong userId, int achCount, byte platformFlag)
        {
            return SyncAchievementsPlatform(titleId, userId, achCount, platformFlag, false);
        }

        public static AchievementWD[] SyncAchievementsPlatform(uint titleId, ulong userId, int achCount, byte platformFlag, bool titleAchievement)
        {
            if (achCount > xonline.common.service.XOn.XONLINE_MAX_ACHIEVEMENTS)
                achCount = xonline.common.service.XOn.XONLINE_MAX_ACHIEVEMENTS;

            int flags = achievementflags.SetPlatformTypeInFlags((int)achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED | (int)achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE, platformFlag);
            if (titleAchievement)
            {
                flags |= (int)TitleAchievementType.Completion;
            }

            AchievementWD[] achToEarn = new AchievementWD[achCount];

            for (int i = 0; i < achCount; i++)
            {
                achToEarn[i] = new AchievementWD((uint)i + 1, (uint)i + 1, flags);
            }

            XRLSyncAchievements request = new XRLSyncAchievements(titleId, userId, achToEarn);
            SyncAchievementsResponse response = new SyncAchievementsResponse();

            response = request.ExecuteInt(xonline.common.service.XOn.XPLT_INTERNAL_LIVEN, platformFlag);

            return achToEarn;
        }

        public static AchievementWD[] SyncAchievementsBatch(uint titleId, ulong userId, int achCount)
        {
            return SyncAchievementsBatch(titleId, userId, achCount, false);
        }

        public static AchievementWD[] SyncAchievementsBatch(uint titleId, ulong userId, int achCount, bool titleAchievement)
        {
            AchievementWD[] retAchievements = new AchievementWD[achCount];
            int retAchIndex = 0;

            if (achCount > TitleAchievementCount)
                achCount = TitleAchievementCount;

            int flags = achievementflags.SetPlatformTypeInFlags((int)achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED | (int)achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE, xonline.common.service.XOn.XPLT_XBOX360);
            if(titleAchievement)
            {
                flags |= (int)TitleAchievementType.Completion;
            }

            int index = achCount;
            uint achId = 1;

            while (index != 0)
            {
                if (index > xonline.common.service.XOn.XONLINE_MAX_ACHIEVEMENTS)
                {
                    AchievementWD[] achToEarn = new AchievementWD[xonline.common.service.XOn.XONLINE_MAX_ACHIEVEMENTS];

                    for (int i = 0; i < xonline.common.service.XOn.XONLINE_MAX_ACHIEVEMENTS; i++)
                    {
                        achToEarn[i] = new AchievementWD(achId + (uint)i, achId + (uint)i, flags);
                        retAchievements[retAchIndex++] = achToEarn[i];
                    }

                    XRLSyncAchievements request = new XRLSyncAchievements(titleId, userId, achToEarn);
                    SyncAchievementsResponse response = new SyncAchievementsResponse();

                    response = request.Execute();

                    index = index - xonline.common.service.XOn.XONLINE_MAX_ACHIEVEMENTS;
                    achId = achId + xonline.common.service.XOn.XONLINE_MAX_ACHIEVEMENTS;
                }
                else
                {
                    AchievementWD[] achToEarn = new AchievementWD[index];

                    for (int i = 0; i < index; i++)
                    {
                        achToEarn[i] = new AchievementWD(achId + (uint)i, achId + (uint)i);
                        retAchievements[retAchIndex++] = achToEarn[i];
                    }

                    XRLSyncAchievements request = new XRLSyncAchievements(titleId, userId, achToEarn);
                    SyncAchievementsResponse response = new SyncAchievementsResponse();

                    response = request.Execute();

                    index = 0;
                }
            }

            return retAchievements;
        }

        public UserPossibleAchievement[] GetPossibleAchievementsEnUs(uint titleId)
        {
            return GetPossibleAchievements(titleId, "en-US");
        }

        public UserPossibleAchievement[] GetPossibleAchievementsDeDe(uint titleId)
        {
            return GetPossibleAchievements(titleId, "de-DE");
        }

        public UserPossibleAchievement[] GetPossibleAchievements(uint titleId, string locale)
        {
            UserPossibleAchievement[] achievements = new UserPossibleAchievement[40];

            for (int i = 0; i < 40; ++i)
            {
                achievements[i] = new UserPossibleAchievement();
                achievements[i].Description = locale == "en-US" ? "Achievement1_DESC" : "Achievement1_DESC de-DE";
                //achievements[i]. = 0x00000008;
                achievements[i].Gamerscore = 0;
                achievements[i].HowTo = locale == "en-US" ? "Achievement1_HOWTO" : "Achievement1_HOWTO de-DE";
                achievements[i].Id = (uint)(i + 1);
                achievements[i].ImageId = 0xffffffff;
                achievements[i].SecretAchievement = false;
                achievements[i].Title = locale == "en-US" ? "Achievement1_NAME" : "Achievement1_NAME de-DE";
                achievements[i].TitleId = titleId;
                achievements[i].Type = 0x01;
            }

            return achievements;
        }

        public static AvatarAssetWD[] SyncAvatarAwards(uint titleId, ulong userId, int iAvatarCount)
        {
            // Currently the stress title only has unisex type 3 avatar awards
            byte avatarBodyType = 3;

            if (iAvatarCount > TitleAvatarAwardCount)
                iAvatarCount = TitleAvatarAwardCount;

            AvatarAssetWD[] avatarToEarn = new AvatarAssetWD[iAvatarCount];

            for (int i = 0; i < iAvatarCount; i++)
            {
                avatarToEarn[i] = new AvatarAssetWD((uint)i + 1, avatarBodyType, (uint)i + 1);
                //avatarToEarn[i].Flags |= (int)xonline.common.service.XOn.XACHIEVEMENT_DETAILS_PLATFORM_360;
                avatarToEarn[i].Awarded = DateTime.UtcNow;
            }

            XRLSyncAvatarAssets request = new XRLSyncAvatarAssets(titleId, userId, avatarToEarn);
            SyncAvatarAssetsResponse response = new SyncAvatarAssetsResponse();

            response = request.Execute();

            return avatarToEarn;
        }

        public static AvatarAssetWD[] SyncAvatarAwardsPlatform(uint titleId, ulong userId, int iAvatarCount, int platformFlag)
        {
            int flags = avatarassetflags.SetPlatformTypeInFlags((int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED_ONLINE, platformFlag);

            // Currently the stress title only has unisex type 3 avatar awards
            byte avatarBodyType = 3;

            if (iAvatarCount > TitleAvatarAwardCount)
                iAvatarCount = TitleAvatarAwardCount;

            AvatarAssetWD[] avatarToEarn = new AvatarAssetWD[iAvatarCount];

            for (int i = 0; i < iAvatarCount; i++)
            {
                avatarToEarn[i] = new AvatarAssetWD((uint)i + 1, avatarBodyType, (uint)i + 1, flags);
                avatarToEarn[i].Awarded = DateTime.UtcNow;
            }

            XRLSyncAvatarAssets request = new XRLSyncAvatarAssets(titleId, userId, avatarToEarn);
            SyncAvatarAssetsResponse response = new SyncAvatarAssetsResponse();

            response = request.ExecuteInt(xonline.common.service.XOn.XPLT_INTERNAL_LIVEN, platformFlag);

            return avatarToEarn;
        }

        public static void SyncGenderAvatarAwards(uint titleId, ulong userId, uint ordinal)
        {
            //int flags = ServerTestFramework.LiveService.AvatarAsset.avatarassetflags.SetPlatformTypeInFlags(1, 1);

            AvatarAssetWD[] avatarToEarn = new AvatarAssetWD[]
            {
               new AvatarAssetWD(ordinal, 1, ordinal),
               new AvatarAssetWD(ordinal, 2, ordinal)
            };

            XRLSyncAvatarAssets request = new XRLSyncAvatarAssets(titleId, userId, avatarToEarn);
            SyncAvatarAssetsResponse response = new SyncAvatarAssetsResponse();

            response = request.Execute();
        }

        public UserPossibleAvatarAward[] GetPossibleAvatarAwardsEnUs(uint titleId)
        {
            return GetPossibleAvatarAwards(titleId, "en-US");
        }

        public UserPossibleAvatarAward[] GetPossibleAvatarAwardsFrFr(uint titleId)
        {
            return GetPossibleAvatarAwards(titleId, "fr-FR");
        }

        public UserPossibleAvatarAward[] GetPossibleAvatarAwards(uint titleId, string locale)
        {
            UserPossibleAvatarAward[] avatarAwards = new UserPossibleAvatarAward[5];

            for (int i = 0; i < 5; ++i)
            {
                avatarAwards[i] = new UserPossibleAvatarAward();
                avatarAwards[i].AssetId = new Guid("{00000001-000" + (i + 1) + "-4103-CF4E-E4BA00000037}");
                avatarAwards[i].BodyComponent = 1;
                avatarAwards[i].BodyTypeMask = 3;
                avatarAwards[i].Description = locale == "en-US" ? "Asset Description" : "le asset description 1";
                avatarAwards[i].HowTo = locale == "en-US" ? "Asset Description" : "le asset description 1";
                avatarAwards[i].Id = (uint)(i + 1);
                avatarAwards[i].ImageId = 32768;
                avatarAwards[i].SecretAward = false;
                avatarAwards[i].SubCategory = 0;
                avatarAwards[i].Title = locale == "en-US" ? "Asset Name" : "le asset name 1";
                avatarAwards[i].TitleId = titleId;
            }

            return avatarAwards;
        }

        public static UserTitle[] SyncTitles(ulong userId, int titleCount)
        {
            return SyncTitles(userId, titleCount, "en-US");
        }

        public static UserTitle[] SyncTitles(ulong userId, int titleCount, string locale)
        {
            UserTitle[] retTitles = new UserTitle[titleCount];
            int retTitleIndex = 0;

            if (titleCount > BatchRecoverySuite.TitleCount)
                titleCount = BatchRecoverySuite.TitleCount;

            int index = titleCount;
            uint titleId = (uint)BatchRecoverySuite.TitleIDStart;

            while (index != 0)
            {
                if (index > xonline.common.service.XOn.XONLINE_MAX_SETTING_COUNT)
                {
                    UserTitle[] titlesToAdd = new UserTitle[xonline.common.service.XOn.XONLINE_MAX_SETTING_COUNT];

                    for (int i = 0; i < xonline.common.service.XOn.XONLINE_MAX_SETTING_COUNT; i++)
                    {
                        titlesToAdd[i] = new UserTitle(titleId + (uint)i, DateTime.UtcNow, 0, 0, (uint)i);
                        titlesToAdd[i].TitleName = locale == "fr-FR" ? "le title55" : "title55"; // Hardcoded and sad
                        retTitles[retTitleIndex++] = titlesToAdd[i];
                    }

                    SyncTitlesRequest request = new SyncTitlesRequest(userId, DateTime.UtcNow, titlesToAdd);
                    SyncTitlesResponse response = new SyncTitlesResponse();

                    response = request.Execute();

                    index = index - xonline.common.service.XOn.XONLINE_MAX_SETTING_COUNT;
                    titleId = titleId + xonline.common.service.XOn.XONLINE_MAX_SETTING_COUNT;
                }
                else
                {
                    UserTitle[] titlesToAdd = new UserTitle[index];

                    for (int i = 0; i < index; i++)
                    {
                        titlesToAdd[i] = new UserTitle(titleId + (uint)i, DateTime.UtcNow, 0, 0, (uint)i);
                        titlesToAdd[i].TitleName = locale == "fr-FR" ? "le title55" : "title55"; // Hardcoded and sad
                        retTitles[retTitleIndex++] = titlesToAdd[i];
                    }

                    SyncTitlesRequest request = new SyncTitlesRequest(userId, DateTime.UtcNow, titlesToAdd);
                    SyncTitlesResponse response = new SyncTitlesResponse();

                    response = request.Execute();

                    index = 0;
                }
            }

            return retTitles;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\Functional\Achievements.cs ===
﻿using System;
using System.Globalization;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.diagnostics;

namespace BatchRecoveryTest.Functional
{
    [Owner("kkline")]
    [TestGroup, Description("Batch Achievement API Positive tests")]
    public class Achievement_PostiveCases : TestNode
    {

        /// <summary>
        /// MyValues Indexes
        /// [0] = Achievement Count per title
        /// [1] = Title Count
        /// [2] = MaxItems for Request
        /// [3] = SkipItems for Request
        /// [4] = ContinuationToken for Request
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Achievement Cases"), EnvRequirement("")]
        [CompoundCase("OneTitleOneAchievement", 1, 1, 50, 0, 0)]
        [CompoundCase("AllAchievementsOneTitle", BatchRecoveryBase.TitleAchievementCount, 1, 50, 0, 0)]
        [CompoundCase("TenAchievementsTenTitles", 10, 10, 50, 0, 0)]
        [CompoundCase("AllAchievementsFiftyTitles", BatchRecoveryBase.TitleAchievementCount, 50, 200, 0, 0)]
        [CompoundCase("TenAchievementsTwoHundredTitles", 10, 200, 200, 0, 0)]
        public class Achievements : BatchRecoveryBase
        {
            PNUser user = null;
            AchievementWD[] achievements = null;
            int achievementsIndex = 0;

            public override void PreRun()
            {
                achievementsIndex = 0;
                user = Fc.CreateXenonUser(false);
                achievements = new AchievementWD[(int)MyValues[0] * (int)MyValues[1]];

                for (int i = 0; i < (int)MyValues[1]; i++)
                {
                    if ((int)MyValues[0] > xonline.common.service.XOn.XONLINE_MAX_ACHIEVEMENTS)
                    {
                        AchievementWD[] synchedAchievements = SyncAchievementsBatch((uint)(BatchRecoverySuite.TitleIDStart + i), user.UserId, (int)MyValues[0]);

                        foreach (AchievementWD ach in synchedAchievements)
                            achievements[achievementsIndex++] = ach;
                    }
                    else
                    {
                        AchievementWD[] synchedAchievements = SyncAchievements((uint)(BatchRecoverySuite.TitleIDStart + i), user.UserId, (int)MyValues[0]);

                        foreach (AchievementWD ach in synchedAchievements)
                            achievements[achievementsIndex++] = ach;
                    }
                }
            }

            public override void Run()
            {
                HttpWebResponse resp = AchievementsRequest(user, (int)MyValues[2], (int)MyValues[3]);
                ProgressReadAllAchievementsResponse achResp = ReadAchievementResponse(resp);

                Global.RO.Info("Check Total Count of Achievements returned");
                Assert.AreEqual(((int)MyValues[0] * (int)MyValues[1]), (int)achResp.PagingInfo.TotalItems, String.Format("  Total Count achievements {0} != {1}", (int)achResp.PagingInfo.TotalItems, ((int)MyValues[0] * (int)MyValues[1])));

                ValidateAchievements(achievements, achResp.Achievements);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Achievement Case for Not Achievable Flagged Achievements"), EnvRequirement("")]
        public class AchievementNotAchievable : BatchRecoveryBase
        {
            PNUser user = null;
            AchievementWD[] achievements = null;
            int achCount = 10;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                achievements = SyncAchievements((uint)(BatchRecoverySuite.TitleIDStart), user.UserId, achCount);
                achievements[0].Flags = 0x170000; // Will be this after we mark it as not achieveable

                ServerTestFramework.Database.ProgressWS.MarkAchievementNotAchievable(user.UserId, BatchRecoverySuite.TitleIDStart, 1);
            }

            public override void Run()
            {
                HttpWebResponse resp = AchievementsRequest(user, 50, 0);
                ProgressReadAllAchievementsResponse achResp = ReadAchievementResponse(resp);

                Global.RO.Info("Check Total Count of Achievements returned");
                Assert.AreEqual(achCount, (int)achResp.PagingInfo.TotalItems, String.Format("  Total Count achievements {0} != {1}", (int)achResp.PagingInfo.TotalItems, achCount));
                Global.RO.Info("Now check the flags to make sure we have this one");
                Assert.AreEqual(0x170000, (int)achResp.Achievements[achResp.Achievements.Length - 1].Flags, String.Format("Not Achievable Flags {0} != {1}", (int)achResp.Achievements[achResp.Achievements.Length - 1].Flags, 0x170000)); // Also has platform flag set, and Completion Achievement type set

                ValidateAchievements(achievements, achResp.Achievements);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the continuation token value takes precedence over the skipitems"), EnvRequirement("")]
        public class ContinuationTokenTakesPrecedence : BatchRecoveryBase
        {
            PNUser user = null;
            AchievementWD[] achievements = null;
            int achCount = 30;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                // Sync 30 achievements
                achievements = SyncAchievements((uint)(BatchRecoverySuite.TitleIDStart), user.UserId, achCount);
            }

            public override void Run()
            {
                HttpWebResponse resp = AchievementsRequest(user, achCount, 20, GenerateContinuationToken(0)); // We should expect to start at index 0 because of the continuation token, not 20
                ProgressReadAllAchievementsResponse sResp = ReadAchievementResponse(resp);

                Global.RO.Info("Check Total Count of Achievements returned");
                Assert.AreEqual((int)sResp.PagingInfo.TotalItems, achCount, String.Format("Total Items achievements {0} != {1}", (int)sResp.PagingInfo.TotalItems, achCount));
                Assert.AreEqual((int)sResp.Achievements.Length, achCount, "Expected count and response count are not the same.");

                //ValidateAchievements(achievements, sResp.Achievements);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the continuation token is working by using it multiple times"), EnvRequirement("")]
        public class ContinuationToken : BatchRecoveryBase
        {
            PNUser user = null;
            AchievementWD[] achievements = null;
            int achCount = 30;
            int batchSize = 10;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                // Sync 30 achievements
                achievements = SyncAchievements((uint)(BatchRecoverySuite.TitleIDStart), user.UserId, achCount);
            }

            public override void Run()
            {
                UserProgressAchievement[] totalAchievements = new UserProgressAchievement[achCount];
                int totalAchIndex = 0;
                string continuationToken = GenerateContinuationToken(0);

                while (totalAchIndex < achCount)
                {
                    HttpWebResponse resp = AchievementsRequest(user, batchSize, continuationToken);
                    ProgressReadAllAchievementsResponse sResp = ReadAchievementResponse(resp);

                    foreach (UserProgressAchievement achievement in sResp.Achievements)
                    {
                        totalAchievements[totalAchIndex++] = achievement;
                    }

                    if (sResp.PagingInfo.ContinuationToken != null)
                        continuationToken = sResp.PagingInfo.ContinuationToken;
                    else
                        break;
                }

                Assert.AreEqual(totalAchievements.Length, achCount, "Expected total count and response count are not the same.");

                ValidateAchievements(achievements, totalAchievements);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Windows Mobile game achievement"), EnvRequirement("")]
        public class AchievementWindowsMobileGame : BatchRecoveryBase
        {
            PNUser user = null;
            AchievementWD[] achievements = null;
            int achCount = 10;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                achievements = SyncAchievementsPlatform((uint)(98), user.UserId, achCount, xonline.common.service.XOn.XPLT_MOBILE);
            }

            public override void Run()
            {
                HttpWebResponse resp = AchievementsRequest(user, 50, 0);
                ProgressReadAllAchievementsResponse achResp = ReadAchievementResponse(resp);

                Global.RO.Info("Check Total Count of Achievements returned");
                Assert.AreEqual(achCount, (int)achResp.PagingInfo.TotalItems, String.Format("  Total Count achievements {0} != {1}", (int)achResp.PagingInfo.TotalItems, achCount));

                ValidateAchievements(achievements, achResp.Achievements);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Web Games game achievement"), EnvRequirement("")]
        public class AchievementWebGames : BatchRecoveryBase
        {
            PNUser user = null;
            AchievementWD[] achievements = null;
            int achCount = 10;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                achievements = SyncAchievementsPlatform((uint)(99), user.UserId, achCount, xonline.common.service.XOn.XPLT_WEB_GAMES);
            }

            public override void Run()
            {
                HttpWebResponse resp = AchievementsRequest(user, 50, 0);
                ProgressReadAllAchievementsResponse achResp = ReadAchievementResponse(resp);

                Global.RO.Info("Check Total Count of Achievements returned");
                Assert.AreEqual(achCount, (int)achResp.PagingInfo.TotalItems, String.Format("  Total Count achievements {0} != {1}", (int)achResp.PagingInfo.TotalItems, achCount));

                ValidateAchievements(achievements, achResp.Achievements);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("PC game achievement"), EnvRequirement("")]
        public class AchievementPC : BatchRecoveryBase
        {
            PNUser user = null;
            AchievementWD[] achievements = null;
            int achCount = 10;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                // Title 52 is PC/Xbox360 cross plat
                achievements = SyncAchievementsPlatform((uint)(52), user.UserId, achCount, xonline.common.service.XOn.XPLT_PC);
            }

            public override void Run()
            {
                HttpWebResponse resp = AchievementsRequest(user, 50, 0);
                ProgressReadAllAchievementsResponse achResp = ReadAchievementResponse(resp);

                Global.RO.Info("Check Total Count of Achievements returned");
                Assert.AreEqual(achCount, (int)achResp.PagingInfo.TotalItems, String.Format("  Total Count achievements {0} != {1}", (int)achResp.PagingInfo.TotalItems, achCount));

                ValidateAchievements(achievements, achResp.Achievements);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Test going through XSTS and the AASG"), EnvRequirement("")]
        public class AchievementThroughAASG : BatchRecoveryBase
        {
            PNUser user = null;
            AchievementWD[] achievements = null;
            int achCount = 10;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                achievements = SyncAchievements((uint)(BatchRecoverySuite.TitleIDStart), user.UserId, achCount);
            }

            public override void Run()
            {
                string url = String.Format("{0}xuid({1})/progress/achievements?maxitems={2}&skipitems={3}", aasgUri, user.UserId.ToString(), 50, 0);
                HttpWebResponse resp = MakeAASGRequest(url, user);
                ProgressReadAllAchievementsResponse achResp = ReadAchievementResponse(resp);

                Global.RO.Info("Check Total Count of Achievements returned");
                Assert.AreEqual(achCount, (int)achResp.PagingInfo.TotalItems, String.Format("  Total Count achievements {0} != {1}", (int)achResp.PagingInfo.TotalItems, achCount));

                ValidateAchievements(achievements, achResp.Achievements);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\Functional\AvatarAwards.cs ===
﻿using System;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService.AvatarAsset;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.diagnostics;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;

namespace BatchRecoveryTest.Functional
{
    /// <summary>
    ///
    /// </summary>
    [Owner("kkline")]
    [TestGroup, Description("Batch AvatarAwards API Positive tests")]
    public class AvatarAwards_PostiveCases : TestNode
    {
        /// <summary>
        /// MyValues Indexes
        /// [0] = Avatar Award Count per title
        /// [1] = Title Count
        /// [2] = MaxItems for Request
        /// [3] = SkipItems for Request
        /// [4] = ContinuationToken for Request
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Avatar Award Cases"), EnvRequirement("")]
        [CompoundCase("OneAwardOneTitle", 1, 1, 50, 0, 0)]
        [CompoundCase("AllAwardsOneTitle", BatchRecoveryBase.TitleAvatarAwardCount, 1, 50, 0, 0)]
        [CompoundCase("AllAwardsTenTitles", BatchRecoveryBase.TitleAvatarAwardCount, 10, 50, 0, 0)]
        [CompoundCase("AllAwardsFiftyTitles", BatchRecoveryBase.TitleAvatarAwardCount, 50, 200, 0, 0)]
        [CompoundCase("AllAwardsTwoHundredTitles", BatchRecoveryBase.TitleAvatarAwardCount, 200, 200, 0, 0)]
        public class AvatarAwards : BatchRecoveryBase
        {
            PNUser user = null;
            AvatarAssetWD[] avatarAssets = null;
            int avatarAssetIndex = 0;

            public override void PreRun()
            {
                avatarAssetIndex = 0;
                user = Fc.CreateXenonUser(false);
                avatarAssets = new AvatarAssetWD[(int)MyValues[0] * (int)MyValues[1]];

                for (int i = 0; i < (int)MyValues[1]; i++)
                {
                    if ((int)MyValues[0] > xonline.common.service.XOn.XONLINE_MAX_ACHIEVEMENTS)
                    {
                        // This should be SyncAvatarAwardsBatch - need to duplicate SyncAchievementsBatch
                        AvatarAssetWD[] syncedAssets = SyncAvatarAwards((uint)(BatchRecoverySuite.TitleIDStart + i), user.UserId, (int)MyValues[0]); // TODO

                        foreach (AvatarAssetWD asset in syncedAssets)
                            avatarAssets[avatarAssetIndex++] = asset;
                    }
                    else
                    {
                        AvatarAssetWD[] syncedAssets = SyncAvatarAwards((uint)(BatchRecoverySuite.TitleIDStart + i), user.UserId, (int)MyValues[0]);

                        foreach (AvatarAssetWD asset in syncedAssets)
                            avatarAssets[avatarAssetIndex++] = asset;
                    }
                }
            }

            public override void Run()
            {
                HttpWebResponse resp = AvatarAwardsRequest(user, 50, 0);
                ProgressReadAllAvatarAwardsResponse avatarResp = ReadAvatarAwardsResponse(resp);

                Global.RO.Info("Check Total Count of Avatar Awards returned");
                Assert.AreEqual((int)avatarResp.PagingInfo.TotalItems, ((int)MyValues[0] * (int)MyValues[1]), String.Format("  Total Count achievements {0} != {1}", (int)avatarResp.PagingInfo.TotalItems, ((int)MyValues[0] * (int)MyValues[1])));

                ValidateAvatarAssets(avatarAssets, avatarResp.AvatarAwards);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Single Title wwith Not Achievable Avatar Awards"), EnvRequirement("")]
        public class AvatarAwardsMarkedNotAchievable : BatchRecoveryBase
        {
            PNUser user = null;
            AvatarAssetWD[] avatarAssets = null;
            int avatarAwardCount = 5;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                avatarAssets = SyncAvatarAwards((uint)BatchRecoverySuite.TitleIDStart, user.UserId, avatarAwardCount);
                avatarAssets[0].Flags = 0x170000; // Will be this after we mark it as not achieveable

                ServerTestFramework.Database.ProgressWS.MarkAvatarAssetNotAchievable(user.UserId, BatchRecoverySuite.TitleIDStart, 1);
            }

            public override void Run()
            {
                HttpWebResponse resp = AvatarAwardsRequest(user, 50, 0);
                ProgressReadAllAvatarAwardsResponse avatarResp = ReadAvatarAwardsResponse(resp);

                Global.RO.Info("Check Total Count of Avatar Awards returned");
                Assert.AreEqual(avatarAwardCount, (int)avatarResp.PagingInfo.TotalItems, String.Format("Total Count avatar awards {0} != {1}", (int)avatarResp.PagingInfo.TotalItems, avatarAwardCount));
                Global.RO.Info("Check if Not Achievable Award is returned correctly");
                Assert.AreEqual(0x170000, (int)avatarResp.AvatarAwards[0].Flags, String.Format("Not Achievable Flags {0} != {1}", (int)avatarResp.AvatarAwards[0].Flags, 0x170000)); // Also has platform flag set (the 1)

                ValidateAvatarAssets(avatarAssets, avatarResp.AvatarAwards);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the continuation token value takes precedence over the skipitems"), EnvRequirement("")]
        public class ContinuationTokenTakesPrecedence : BatchRecoveryBase
        {
            PNUser user = null;
            AvatarAssetWD[] achievements = null;
            int aaCount = TitleAvatarAwardCount;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                // Sync 30 achievements
                achievements = SyncAvatarAwards((uint)(BatchRecoverySuite.TitleIDStart), user.UserId, aaCount);
            }

            public override void Run()
            {
                HttpWebResponse resp = AvatarAwardsRequest(user, aaCount, 20, GenerateContinuationToken(0)); // We should expect to start at index 0 because of the continuation token, not 20
                ProgressReadAllAvatarAwardsResponse sResp = ReadAvatarAwardsResponse(resp);

                Global.RO.Info("Check Total Count of Achievements returned");
                Assert.AreEqual((int)sResp.PagingInfo.TotalItems, aaCount, String.Format("Total Items avatar awards {0} != {1}", (int)sResp.PagingInfo.TotalItems, aaCount));
                Assert.AreEqual((int)sResp.AvatarAwards.Length, aaCount, "Expected count and response count are not the same.");

                //ValidateAchievements(achievements, sResp.Achievements);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the continuation token is working by using it multiple times"), EnvRequirement("")]
        public class ContinuationToken : BatchRecoveryBase
        {
            PNUser user = null;
            AvatarAssetWD[] avatarAwards = null;
            int aaCount = 5;
            int batchSize = 2;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                // Sync 5 achievements
                avatarAwards = SyncAvatarAwards((uint)(BatchRecoverySuite.TitleIDStart), user.UserId, aaCount);
            }

            public override void Run()
            {
                UserProgressAvatarAward[] totalAvatarAwards = new UserProgressAvatarAward[aaCount];
                int totalAaIndex = 0;
                string continuationToken = GenerateContinuationToken(0);

                while (totalAaIndex < aaCount)
                {
                    HttpWebResponse resp = AvatarAwardsRequest(user, batchSize, continuationToken);
                    ProgressReadAllAvatarAwardsResponse sResp = ReadAvatarAwardsResponse(resp);

                    foreach (UserProgressAvatarAward avatarAward in sResp.AvatarAwards)
                    {
                        totalAvatarAwards[totalAaIndex++] = avatarAward;
                    }

                    if (sResp.PagingInfo.ContinuationToken != null)
                        continuationToken = sResp.PagingInfo.ContinuationToken;
                    else
                        break;
                }

                Assert.AreEqual(totalAvatarAwards.Length, aaCount, "Expected total count and response count are not the same.");

                ValidateAvatarAssets(avatarAwards, totalAvatarAwards);
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Windows Mobile title with Avatar Awards"), EnvRequirement("")]
        public class AvatarAwardsWindowsMobile : BatchRecoveryBase
        {
            PNUser user = null;
            AvatarAssetWD[] avatarAssets = null;
            int avatarAwardCount = 5;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                avatarAssets = SyncAvatarAwardsPlatform((uint)98, user.UserId, avatarAwardCount, xonline.common.service.XOn.XPLT_MOBILE);
            }

            public override void Run()
            {
                HttpWebResponse resp = AvatarAwardsRequest(user, 50, 0);
                ProgressReadAllAvatarAwardsResponse avatarResp = ReadAvatarAwardsResponse(resp);

                Global.RO.Info("Check Total Count of Avatar Awards returned");
                Assert.AreEqual(avatarAwardCount, (int)avatarResp.PagingInfo.TotalItems, String.Format("Total Count avatar awards {0} != {1}", (int)avatarResp.PagingInfo.TotalItems, avatarAwardCount));
                
                ValidateAvatarAssets(avatarAssets, avatarResp.AvatarAwards);
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Web Games title with Avatar Awards"), EnvRequirement("")]
        public class AvatarAwardsWebGames : BatchRecoveryBase
        {
            PNUser user = null;
            AvatarAssetWD[] avatarAssets = null;
            int avatarAwardCount = 5;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                avatarAssets = SyncAvatarAwardsPlatform((uint)99, user.UserId, avatarAwardCount, xonline.common.service.XOn.XPLT_WEB_GAMES);
            }

            public override void Run()
            {
                HttpWebResponse resp = AvatarAwardsRequest(user, 50, 0);
                ProgressReadAllAvatarAwardsResponse avatarResp = ReadAvatarAwardsResponse(resp);

                Global.RO.Info("Check Total Count of Avatar Awards returned");
                Assert.AreEqual(avatarAwardCount, (int)avatarResp.PagingInfo.TotalItems, String.Format("Total Count avatar awards {0} != {1}", (int)avatarResp.PagingInfo.TotalItems, avatarAwardCount));

                ValidateAvatarAssets(avatarAssets, avatarResp.AvatarAwards);
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Test going through XSTS and the AASG"), EnvRequirement("")]
        public class AvatarAwardsThroughAASG : BatchRecoveryBase
        {
            PNUser user = null;
            AvatarAssetWD[] avatarAssets = null;
            int avatarAwardCount = 5;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                avatarAssets = SyncAvatarAwards((uint)BatchRecoverySuite.TitleIDStart, user.UserId, avatarAwardCount);
            }

            public override void Run()
            {
                string url = String.Format("{0}xuid({1})/progress/avatarawards?maxitems={2}&skipitems={3}", aasgUri,user.UserId.ToString(), 50, 0);
                HttpWebResponse response = MakeAASGRequest(url, user);

                ProgressReadAllAvatarAwardsResponse avatarResp = ReadAvatarAwardsResponse(response);

                Global.RO.Info("Check Total Count of Avatar Awards returned");
                Assert.AreEqual(avatarAwardCount, (int)avatarResp.PagingInfo.TotalItems, String.Format("Total Count avatar awards {0} != {1}", (int)avatarResp.PagingInfo.TotalItems, avatarAwardCount));

                ValidateAvatarAssets(avatarAssets, avatarResp.AvatarAwards);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\BatchRecoveryBase\Contracts.cs ===
﻿using System;
using System.Runtime.Serialization;
using ServerTestFramework;

namespace BatchRecoveryTest
{
    public partial class BatchRecoveryBase : TestNode
    {
        #region ProfileDataContracts

        // NOTE: PageInfo is common to all REST response types
        [DataContract(Name = "pagingInfo")]
        public class ResponsePagingInfo
        {
            public ResponsePagingInfo()
            {
                this.ContinuationToken = null;
            }

            [DataMember(Name = "continuationToken")]
            public string ContinuationToken { get; set; }

            [DataMember(Name = "totalRecords")]
            public uint TotalItems { get; set; }
        }

        [DataContract(Name = "response")]
        public class ProfileReadAllSettingsResponse
        {
            internal DateTime LastModified;
            [DataMember(Name = "version")]
            public string LastModifiedString
            {
                get
                {
                    return LastModified.ToUniversalTime().ToString("o");
                }
                set
                {
                    LastModified = DateTime.Parse(value);
                }
            }

            [DataMember(Name = "pagingInfo")]
            public ResponsePagingInfo PagingInfo = new ResponsePagingInfo();

            [DataMember(Name = "settings")]
            public UserProfileSetting[] Settings = null;
        }

        [DataContract(Name = "setting")]
        public class UserProfileSetting
        {
            [DataMember(Name = "id")]
            public uint Id = 0;

            [DataMember(Name = "titleId")]
            public uint TitleId = 0;

            internal byte[] Value;
            [DataMember(Name = "value")]
            public string ValueString
            {
                get
                {
                    return Convert.ToBase64String((Value == null) ? new byte[0] : Value);
                }
                set
                {
                    Value = System.Convert.FromBase64String(value);
                }
            }
        }
        #endregion

        #region Progress DataContracts

        [DataContract(Name = "response")]
        public class ProgressReadAllTitlesResponse
        {
            internal DateTime LastModified;
            [DataMember(Name = "version")]
            public string LastModifiedString
            {
                get
                {
                    return LastModified.ToUniversalTime().ToString("o");
                }
                set
                {
                    LastModified = DateTime.Parse(value).ToUniversalTime();
                }
            }

            [DataMember(Name = "pagingInfo")]
            public ResponsePagingInfo PagingInfo = new ResponsePagingInfo();

            [DataMember(Name = "titles")]
            public UserProgressTitle[] Titles = null;
        }

        [DataContract(Name = "title")]
        public class UserProgressTitle
        {
            [DataMember(Name = "titleId")]
            public uint TitleId = 0;

            [DataMember(Name = "name")]
            public string Name = null;

            internal DateTime LastPlayed = DateTime.MinValue;
            [DataMember(Name = "lastPlayed")]
            public string LastPlayedString
            {
                get
                {
                    return LastPlayed.ToString("o");
                }
                set
                {
                    LastPlayed = DateTime.Parse(value).ToUniversalTime();
                }
            }

            [DataMember(Name = "currentGamerscore")]
            public uint UserGamerscore = 0;

            [DataMember(Name = "currentAchievements")]
            public uint UserAchievements = 0;

            [DataMember(Name = "totalAchievements")]
            public uint MaxAchievements = 0;

            [DataMember(Name = "totalGamerscore")]
            public uint MaxGamerscore = 0;

            [DataMember(Name = "sequence")]
            public uint Sequence = 0;
        }

        // protocol object for response
        [DataContract(Name = "response")]
        public class ProgressReadAllAchievementsResponse
        {
            internal DateTime LastModified;
            [DataMember(Name = "version")]
            public string LastModifiedString
            {
                get
                {
                    return LastModified.ToUniversalTime().ToString("o");
                }
                set
                {
                    LastModified = DateTime.Parse(value).ToUniversalTime();
                }
            }

            [DataMember(Name = "pagingInfo")]
            public ResponsePagingInfo PagingInfo = new ResponsePagingInfo();

            [DataMember(Name = "achievements")]
            public UserProgressAchievement[] Achievements = null;
        }

        [DataContract(Name = "achievement")]
        public class UserProgressAchievement
        {
            [DataMember(Name = "titleId")]
            public uint TitleId = 0;

            [DataMember(Name = "id")]
            public uint Id = 0;

            internal DateTime AchievedDate = DateTime.MinValue;

            [DataMember(Name = "timeUnlocked")]
            public string AchievedDateString
            {
                get
                {
                    return AchievedDate.ToString("o");
                }
                set
                {
                    AchievedDate = DateTime.Parse(value).ToUniversalTime();
                }
            }

            [DataMember(Name = "sequence")]
            public uint Sequence = 0;

            [DataMember(Name = "flags")]
            public uint Flags = 0;

            [DataMember(Name = "platform")]
            public uint Platform = 0;

            [DataMember(Name = "unlockedOnline")]
            public bool AchievedOnline
            {
                get
                {
                    return (0 != (Flags & xonline.common.service.XOn.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE)) ? true : false;
                }
                set { }
            }
        }

        // protocol object for response
        [DataContract(Name = "response")]
        public class ProgressReadAllPossibleAchievementsResponse
        {
            internal DateTime LastModified;
            [DataMember(Name = "version")]
            public string LastModifiedString
            {
                get
                {
                    return LastModified.ToUniversalTime().ToString("o");
                }
                set
                {
                    LastModified = DateTime.Parse(value).ToUniversalTime();
                }
            }

            [DataMember(Name = "pagingInfo")]
            public ResponsePagingInfo PagingInfo = new ResponsePagingInfo();

            [DataMember(Name = "achievements")]
            public UserPossibleAchievement[] Achievements = null;
        }

        [DataContract(Name = "achievement")]
        public class UserPossibleAchievement
        {
            [DataMember(Name = "titleId")]
            public uint TitleId = 0;

            [DataMember(Name = "id")]
            public uint Id = 0;

            [DataMember(Name = "type")]
            public byte Type = 0;

            [DataMember(Name = "gamerscore")]
            public int Gamerscore = 0;

            [DataMember(Name = "imageId")]
            public uint ImageId = 0;

            [DataMember(Name = "name")]
            public string Title = null;

            [DataMember(Name = "description")]
            public string Description = null;

            [DataMember(Name = "lockedDescription")]
            public string HowTo = null;

            [DataMember(Name = "isSecret")]
            public bool SecretAchievement = false;
        }

        // protocol object for response
        [DataContract(Name = "response")]
        public class ProgressReadAllAvatarAwardsResponse
        {
            internal DateTime LastModified;
            [DataMember(Name = "version")]
            public string LastModifiedString
            {
                get
                {
                    return LastModified.ToUniversalTime().ToString("o");
                }
                set
                {
                    LastModified = DateTime.Parse(value).ToUniversalTime();
                }
            }

            [DataMember(Name = "pagingInfo")]
            public ResponsePagingInfo PagingInfo = new ResponsePagingInfo();

            [DataMember(Name = "avatarAwards")]
            public UserProgressAvatarAward[] AvatarAwards = null;
        }

        [DataContract(Name = "avatarAward")]
        public class UserProgressAvatarAward
        {
            [DataMember(Name = "titleId")]
            public uint TitleId = 0;

            [DataMember(Name = "id")]
            public uint Id = 0;

            [DataMember(Name = "bodyType")]
            public uint BodyTypeMask = 0;

            [DataMember(Name = "sequence")]
            public uint Sequence = 0;

            [DataMember(Name = "flags")]
            public uint Flags = 0;

            [DataMember(Name = "platform")]
            public uint Platform = 0;

            internal DateTime AwardedDate = DateTime.MinValue;

            [DataMember(Name = "timeUnlocked")]
            public string AwardedDateString
            {
                get
                {
                    return AwardedDate.ToString("o");
                }
                set
                {
                    AwardedDate = DateTime.Parse(value).ToUniversalTime();
                }
            }

            [DataMember(Name = "unlockedOnline")]
            public bool AchievedOnline
            {
                get
                {
                    return (0 != (Flags & xonline.common.service.XOn.XAVATAR_DETAILS_ACHIEVED_ONLINE)) ? true : false;
                }
                set { }
            }
        }

        // protocol object for response
        [DataContract(Name = "response")]
        public class ProgressReadAllPossibleAvatarAwardsResponse
        {
            internal DateTime LastModified = DateTime.MinValue;
            [DataMember(Name = "version")]
            public string LastModifiedString
            {
                get
                {
                    return LastModified.ToUniversalTime().ToString("o");
                }
                set
                {
                    LastModified = DateTime.Parse(value).ToUniversalTime();
                }
            }

            [DataMember(Name = "pagingInfo")]
            public ResponsePagingInfo PagingInfo = new ResponsePagingInfo();

            [DataMember(Name = "avatarAwards")]
            public UserPossibleAvatarAward[] AvatarAwards = null;
        }

        //TODO: Bodytypemask and imageID are issue in this.
        [DataContract(Name = "avatarAward")]
        public class UserPossibleAvatarAward
        {
            [DataMember(Name = "titleId")]
            public uint TitleId = 0;

            internal Guid AssetId = Guid.Empty;
            [DataMember(Name = "assetId")]
            public string AssetIdString
            {
                get
                {
                    return AssetId.ToString();
                }
                set
                {
                    AssetId = new Guid(value);
                }
            }

            [DataMember(Name = "id")]
            public uint Id = 0;

            [DataMember(Name = "bodyComponent")]
            public uint BodyComponent = 0;

            [DataMember(Name = "subCategory")]
            public uint SubCategory = 0;

            [DataMember(Name = "imageId")]
            public uint ImageId = 0;

            [DataMember(Name = "bodyType")]
            public uint BodyTypeMask = 0;

            [DataMember(Name = "name")]
            public string Title = null;

            [DataMember(Name = "description")]
            public string Description = null;

            [DataMember(Name = "lockedDescription")]
            public string HowTo = null;

            [DataMember(Name = "isSecret")]
            public bool SecretAward = false;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\BatchRecoveryBase\Requests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Net;
using System.Runtime.Serialization.Json;
using System.Text;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace BatchRecoveryTest
{
    public partial class BatchRecoveryBase : TestNode
    {
        #region Requests

        public static HttpWebResponse SettingsRequest(PNUser user)
        {
            string url = String.Format("{0}xuid({1})/settings", profileUri, "0x" + user.UserId.ToString("X"));
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse SettingsRequest(PNUser requestor, PNUser requestee)
        {
            string url = String.Format("{0}xuid({1})/settings", profileUri, "0x" + requestee.UserId.ToString("X"));
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, requestor);

            return resp;
        }

        public static HttpWebResponse SettingsRequest(PNUser user, int maxItems, int skipItems)
        {
            string url = String.Format("{0}xuid({1})/settings?maxitems={2}&skipitems={3}", profileUri, "0x" + user.UserId.ToString("X"), maxItems, skipItems);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse SettingsRequest(PNUser user, int maxItems, string continuationToken)
        {
            string url = String.Format("{0}xuid({1})/settings?maxitems={2}&continuationtoken={3}", profileUri, "0x" + user.UserId.ToString("X"), maxItems, continuationToken);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse SettingsRequest(PNUser user, int maxItems, int skipItems, string continuationToken)
        {
            string url = String.Format("{0}xuid({1})/settings?maxitems={2}&skipitems={3}&continuationtoken={4}", profileUri, "0x" + user.UserId.ToString("X"), maxItems, skipItems, continuationToken);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse SettingsRequest(PNUser user, string url)
        {
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse TitleHistoryRequest(PNUser user)
        {
            string url = String.Format("{0}xuid({1})/titlehistory", progressUri, "0x" + user.UserId.ToString("X"));
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse TitleHistoryRequest(PNUser user, int maxItems, int skipItems)
        {
            string url = String.Format("{0}xuid({1})/titlehistory?maxitems={2}&skipitems={3}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, skipItems);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse TitleHistoryRequest(PNUser user, int maxItems, string continuationToken)
        {
            string url = String.Format("{0}xuid({1})/titlehistory?maxitems={2}&continuationtoken={3}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, continuationToken);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse TitleHistoryRequest(PNUser user, int maxItems, int skipItems, string continuationToken)
        {
            string url = String.Format("{0}xuid({1})/titlehistory?maxitems={2}&skipitems={3}&continuationtoken={4}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, skipItems, continuationToken);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse AchievementsRequest(PNUser user)
        {
            string url = String.Format("{0}xuid({1})/progress/achievements", progressUri, "0x" + user.UserId.ToString("X"));
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse AchievementsRequest(PNUser user, int maxItems, int skipItems)
        {
            string url = String.Format("{0}xuid({1})/progress/achievements?maxitems={2}&skipitems={3}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, skipItems);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse AchievementsRequest(PNUser user, int maxItems, string continuationToken)
        {
            string url = String.Format("{0}xuid({1})/progress/achievements?maxitems={2}&continuationtoken={3}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, continuationToken);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse AchievementsRequest(PNUser user, int maxItems, int skipItems, string continuationToken)
        {
            string url = String.Format("{0}xuid({1})/progress/achievements?maxitems={2}&skipItems={3}&continuationtoken={4}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, skipItems, continuationToken);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse TitleAchievementsRequest(PNUser user)
        {
            string url = String.Format("{0}xuid({1})/progress/titleachievements", progressUri, "0x" + user.UserId.ToString("X"));
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse TitleAchievementsRequest(PNUser user, int maxItems, int skipItems)
        {
            string url = String.Format("{0}xuid({1})/progress/titleachievements?maxitems={2}&skipitems={3}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, skipItems);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }


        public static HttpWebResponse TitleAchievementsRequest(PNUser user, int maxItems, string continuationToken)
        {
            string url = String.Format("{0}xuid({1})/progress/titleachievements?maxitems={2}&continuationtoken={3}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, continuationToken);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse TitleAchievementsRequest(PNUser user, int maxItems, int skipItems, string continuationToken)
        {
            string url = String.Format("{0}xuid({1})/progress/titleachievements?maxitems={2}&skipItems={3}&continuationtoken={4}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, skipItems, continuationToken);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse AvatarAwardsRequest(PNUser user)
        {
            string url = String.Format("{0}xuid({1})/progress/avatarawards", progressUri, "0x" + user.UserId.ToString("X"));
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse AvatarAwardsRequest(PNUser user, int maxItems, int skipItems)
        {
            string url = String.Format("{0}xuid({1})/progress/avatarawards?maxitems={2}&skipitems={3}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, skipItems);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse AvatarAwardsRequest(PNUser user, int maxItems, string continuationToken)
        {
            string url = String.Format("{0}xuid({1})/progress/avatarawards?maxitems={2}&continuationtoken={3}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, continuationToken);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse AvatarAwardsRequest(PNUser user, int maxItems, int skipItems, string continuationToken)
        {
            string url = String.Format("{0}xuid({1})/progress/avatarawards?maxitems={2}&skipitems={3}&continuationtoken={4}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, skipItems, continuationToken);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse TitleAvatarAwardsRequest(PNUser user)
        {
            string url = String.Format("{0}xuid({1})/progress/titleavatarawards", progressUri, "0x" + user.UserId.ToString("X"));
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse TitleAvatarAwardsRequest(PNUser user, int maxItems, int skipItems)
        {
            string url = String.Format("{0}xuid({1})/progress/titleavatarawards?maxitems={2}&skipitems={3}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, skipItems);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse TitleAvatarAwardsRequest(PNUser user, int maxItems, string continuationToken)
        {
            string url = String.Format("{0}xuid({1})/progress/titleavatarawards?maxitems={2}&continuationtoken={3}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, continuationToken);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        public static HttpWebResponse TitleAvatarAwardsRequest(PNUser user, int maxItems, int skipItems, string continuationToken)
        {
            string url = String.Format("{0}xuid({1})/progress/titleavatarawards?maxitems={2}&skipitems={3}&continuationtoken={4}", progressUri, "0x" + user.UserId.ToString("X"), maxItems, skipItems, continuationToken);
            Global.RO.Info(url);

            HttpWebResponse resp = SendRequest(url, user);

            return resp;
        }

        private const string DefaultLocale = "en-us";

        public static HttpWebResponse SendRequest(string url, PNUser user)
        {
            return SendRequest(url, user, GetTestToken(user.Name, user.UserId));
        }

        public static HttpWebResponse SendRequest(string url, PNUser user, List<IClaimsIdentity> identities)
        {
            return SendRequest(url, user, identities, new string[] { DefaultLocale });
        }

        public static HttpWebResponse SendRequest(string url, PNUser user, List<IClaimsIdentity> identities, string[] locales)
        {
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.ContentType = "GET";
            request.Accept = "application/JSON";

            // Auth
            request.Headers.SetXAuthdata(new ClaimsPrincipal(new ClaimsIdentityCollection(identities)));

            // Language
            request.Headers.Add("Accept-Language", GenerateAcceptLanguageHeader(locales, null));

            HttpWebResponse response = (HttpWebResponse)request.GetResponse();
            return response;
        }

        public static HttpStatusCode SendInvalidRequest(string uri, string path, PNUser user)
        {
            return SendInvalidRequest(uri, path, user, GetTestToken(user.Name, user.UserId));
        }

        public static HttpStatusCode SendInvalidRequest(string uri, string path, PNUser user, List<IClaimsIdentity> identities)
        {
            string url = String.Format("{0}xuid({1})/{2}", uri, "0x" + user.UserId.ToString("X"), path);
            Global.RO.Info(url);

            HttpStatusCode code = new HttpStatusCode();
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.ContentType = "GET";
            request.Accept = "application/JSON";
            request.Headers.SetXAuthdata(new ClaimsPrincipal(new ClaimsIdentityCollection(identities)));

            try
            {
                HttpWebResponse response = (HttpWebResponse)request.GetResponse();
            }
            catch (WebException e)
            {
                code = ((HttpWebResponse)e.Response).StatusCode;
                Global.RO.Info(e.Message);
                if (e.Status == WebExceptionStatus.ProtocolError)
                {
                    Global.RO.Info("Status Code : {0}", ((HttpWebResponse)e.Response).StatusCode);
                    Global.RO.Info("Status Description : {0}", ((HttpWebResponse)e.Response).StatusDescription);
                }
            }

            return code;
        }

        public HttpWebResponse MakeAASGRequest(string url, PNUser user)
        {
            Global.RO.Info(url);

            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.ContentType = "GET";
            request.Accept = "application/JSON";

            // Auth
            String samlToken = GetXSTSToken(user, 12345); // TitleId doesn't matter, but one is required
            request.Headers.Add("Authorization", "XBL2.0 x=" + samlToken);

            return (HttpWebResponse)request.GetResponse();
        }

        // Stolen from TFS Microsoft.Xbox.Test.UserServices.RequestUtils
        public static string GenerateAcceptLanguageHeader(string[] locales, float[] qualities)
        {
            if (locales == null || locales.Length == 0)
            {
                locales = new string[] { DefaultLocale };
            }

            if (qualities == null)
            {
                qualities = new float[locales.Length];
                for (int i = 0; i < locales.Length; ++i)
                {
                    qualities[i] = (float)Math.Max(1 - (i * 0.1), 0.1);
                }
            }
            else if (qualities.Length < locales.Length)
            {
                float[] temp = new float[locales.Length];
                for (int i = 0; i < locales.Length; ++i)
                {
                    if (i < qualities.Length)
                    {
                        temp[i] = qualities[i];
                    }
                    else
                    {
                        temp[i] = (float)Math.Max(1 - (i * 0.1), 0.1);
                    }
                }

                qualities = temp;
            }

            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < locales.Length; i++)
            {
                sb.AppendFormat("{0};q={1},", locales[i], qualities[i]);
            }

            return sb.ToString();
        }

        #endregion

        #region Response

        public static ProfileReadAllSettingsResponse ReadSettingsResponse(HttpWebResponse resp)
        {
            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(ProfileReadAllSettingsResponse));

            ProfileReadAllSettingsResponse pSettings = (ProfileReadAllSettingsResponse)ser.ReadObject(resp.GetResponseStream());

            return pSettings;
        }

        public static ProgressReadAllTitlesResponse ReadTitlesResponse(HttpWebResponse resp)
        {
            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(ProgressReadAllTitlesResponse));

            ProgressReadAllTitlesResponse pTitles = (ProgressReadAllTitlesResponse)ser.ReadObject(resp.GetResponseStream());

            return pTitles;
        }

        public static ProgressReadAllAchievementsResponse ReadAchievementResponse(HttpWebResponse resp)
        {
            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(ProgressReadAllAchievementsResponse));

            ProgressReadAllAchievementsResponse pAch = (ProgressReadAllAchievementsResponse)ser.ReadObject(resp.GetResponseStream());

            return pAch;
        }

        public static ProgressReadAllPossibleAchievementsResponse ReadPossibleAchievementResponse(HttpWebResponse resp)
        {
            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(ProgressReadAllPossibleAchievementsResponse));

            ProgressReadAllPossibleAchievementsResponse pAch = (ProgressReadAllPossibleAchievementsResponse)ser.ReadObject(resp.GetResponseStream());

            return pAch;
        }

        public static ProgressReadAllAvatarAwardsResponse ReadAvatarAwardsResponse(HttpWebResponse resp)
        {
            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(ProgressReadAllAvatarAwardsResponse));

            ProgressReadAllAvatarAwardsResponse pAvatar = (ProgressReadAllAvatarAwardsResponse)ser.ReadObject(resp.GetResponseStream());

            return pAvatar;
        }

        public static ProgressReadAllPossibleAvatarAwardsResponse ReadPossibleAvatarAwardsResponse(HttpWebResponse resp)
        {
            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(ProgressReadAllPossibleAvatarAwardsResponse));

            ProgressReadAllPossibleAvatarAwardsResponse pAvatar = (ProgressReadAllPossibleAvatarAwardsResponse)ser.ReadObject(resp.GetResponseStream());

            return pAvatar;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\common\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\Functional\Settings.cs ===
﻿using System;
using System.Collections.Generic;
using System.Net;
using Microsoft.IdentityModel.Claims;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserSettings;
using xonline.common.diagnostics;

namespace BatchRecoveryTest.Functional
{
    /// <summary>
    ///
    /// </summary>
    [Owner("kkline")]
    [TestGroup, Description("Batch Settings API Positive tests")]
    public class Settings_PostiveCases : TestNode
    {
        /// <summary>
        /// MyValues Indexes
        /// [0] = Global Settings Count
        /// [1] = Title Count for TitleSpecific Settings
        /// [2] = MaxItems for Request
        /// [3] = SkipItems for Request
        /// [4] = ContinuationToken for Request
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Title Cases"), EnvRequirement("")]
        [CompoundCase("NoSettings", 0, 0, 50, 0, 0)]
        [CompoundCase("SingleSettings", 1, 0, 50, 0, 0)]
        [CompoundCase("MaxGlobalSettings", -1, 0, 50, 0, 0)]
        [CompoundCase("SingleTitleWithTitleSpecificSettings", 0, 1, 50, 0, 0)]
        [CompoundCase("FiftyTitlesWithTitleSpecificSettings", 0, 50, 50, 0, 0)]
        [CompoundCase("MaxGlobalFiftyTitleswithTitleSpecificSettings", -1, 50, 200, 0, 0)]
        [CompoundCase("MaxSettingsBoth", -1, BatchRecoverySuite.TitleCount, 200, 0, 0)]
        public class Settings : BatchRecoveryBase
        {
            PNUser user = null;
            const int SettingsCountPerTitle = 3;
            UserSetting[] globalSettings = null;
            UserTitleSetting[] titleSettings = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                int globalSettingCount = (int)MyValues[0];

                // Set to MAX settings
                if (globalSettingCount == -1)
                    globalSettingCount = ProfileIds.Length;

                // With new privacy, we will always return the permission setting now because we call CreateXenonUser
                if (globalSettingCount == 0)
                    globalSettingCount = 1;

                // We will always sync because of Privacy now
                globalSettings = SyncGlobalSettings(user.UserId, globalSettingCount);

                // Check to see if we should sync these settings
                if ((int)MyValues[1] != 0)
                    titleSettings = SyncTitleSpecificSettings(user.UserId, (int)MyValues[1]);
            }

            public override void Run()
            {
                int globalSettingCount = (int)MyValues[0];

                if (globalSettingCount == -1)
                    globalSettingCount = ProfileIds.Length;

                // With new privacy, we will always return the permission setting now because we call CreateXenonUser
                if (globalSettingCount == 0)
                    globalSettingCount = 1;

                int settingCount = globalSettingCount + ((int)MyValues[1] * SettingsCountPerTitle);

                HttpWebResponse resp = SettingsRequest(user, (int)MyValues[2], (int)MyValues[3]);
                ProfileReadAllSettingsResponse sResp = ReadSettingsResponse(resp);

                Global.RO.Info("Check Total Count of Settings returned");
                Assert.AreEqual((int)sResp.PagingInfo.TotalItems, settingCount, String.Format("Total Items settings {0} != {1}", (int)sResp.PagingInfo.TotalItems, settingCount));

                ValidateSettings(globalSettings, titleSettings, sResp.Settings);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Avatar Manifest nulled out case"), EnvRequirement("")]
        public class AvatarManifestNulled : BatchRecoveryBase
        {
            PNUser user = null;
            // setting count is 2 because we will always get back a permission, so we are going to sync it anyway.
            const int settingCount = 2;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                // Sync the bogus avatar info manifest
                SyncSingleSetting(user.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1);

                // Sync the permission setting now so we know to get it back
                SyncSingleSetting(user.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_PERMISSIONS);

            }

            public override void Run()
            {
                HttpWebResponse resp = SettingsRequest(user, 10, 0);
                ProfileReadAllSettingsResponse sResp = ReadSettingsResponse(resp);

                Global.RO.Info("Check total count of settings returned");
                Assert.AreEqual((int)sResp.PagingInfo.TotalItems, settingCount, String.Format("Total Count settings {0} != {1}", (int)sResp.PagingInfo.TotalItems, settingCount));

                Global.RO.Info("Check value of avatar manifest setting");
                // Note the first returned item will be the permission setting (it sorts it based on setting id), so grab the second one.
                Assert.AreEqual(sResp.Settings[1].ValueString, "", String.Format("Total Count settings {0} != {1}", sResp.Settings[1].ValueString, ""));
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Avatar Manifest nulled out case"), EnvRequirement("")]
        public class TransientSettingsNotReturned : BatchRecoveryBase
        {
            PNUser user = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                // Transient Settings (no database storage)
                SyncSingleSetting(user.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO); 
                SyncSingleSetting(user.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_VIDEO_METADATA);
                
                // Added to make the profile have a permission because it will get it anyway.
                SyncSingleSetting(user.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_PERMISSIONS);
            }

            public override void Run()
            {
                HttpWebResponse resp = SettingsRequest(user, 10, 0);
                ProfileReadAllSettingsResponse sResp = ReadSettingsResponse(resp);

                Global.RO.Info("Check total items returned, should be 1 - just the permission setting");
                Assert.AreEqual((int)sResp.PagingInfo.TotalItems, 1, String.Format("Total count settings {0} != {1}", (int)sResp.PagingInfo.TotalItems, 1));

                Global.RO.Info("Check setting id to make sure it is the permissions setting");
                Assert.AreEqual((int)sResp.Settings[0].Id, xonline.common.protocol.ProfileDefs.XPROFILE_PERMISSIONS, String.Format(" - SettingId {0:X} != {1:X}", (int)sResp.Settings[0].Id, xonline.common.protocol.ProfileDefs.XPROFILE_PERMISSIONS));

            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the continuation token value takes precedence over the skipitems"), EnvRequirement("")]
        public class ContinuationTokenTakesPrecedence : BatchRecoveryBase
        {
            PNUser user = null;
            UserSetting[] globalSettings = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                // Sync all global settings
                globalSettings = SyncGlobalSettings(user.UserId, ProfileIds.Length);
            }

            public override void Run()
            {
                HttpWebResponse resp = SettingsRequest(user, ProfileIds.Length, 20, "0"); // We should expect to start at index 0 because of the continuation token, not 20
                ProfileReadAllSettingsResponse sResp = ReadSettingsResponse(resp);

                Global.RO.Info("Check Total Count of Settings returned");
                Assert.AreEqual((int)sResp.PagingInfo.TotalItems, ProfileIds.Length, String.Format("Total Items settings {0} != {1}", (int)sResp.PagingInfo.TotalItems, ProfileIds.Length));
                Assert.AreEqual((int)sResp.Settings.Length, ProfileIds.Length, "Expected count and response count are not the same.");

                //ValidateSettings(globalSettings, null, sResp.Settings);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the maxItems parameter is defaulted to 32 when not provided"), EnvRequirement("")]
        public class MaxItemsDefaults : BatchRecoveryBase
        {
            PNUser user = null;
            UserSetting[] globalSettings = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                // Sync all global settings
                globalSettings = SyncGlobalSettings(user.UserId, ProfileIds.Length);
            }

            public override void Run()
            {
                HttpWebResponse resp = SettingsRequest(user, String.Format("{0}xuid({1})/settings?continuationtoken={2}", profileUri, "0x" + user.UserId.ToString("X"), "0"));
                ProfileReadAllSettingsResponse sResp = ReadSettingsResponse(resp);

                Global.RO.Info("Check Total Count of Settings returned");
                Assert.AreEqual((int)sResp.PagingInfo.TotalItems, ProfileIds.Length, String.Format("Total Count settings {0} != {1}", (int)sResp.PagingInfo.TotalItems, ProfileIds.Length));
                //Assert.AreEqual((int)sResp.PagingInfo.Count, DefaultMaxItems, String.Format("Count of returned settings {0} != {1}", (int)sResp.PagingInfo.Count, DefaultMaxItems));

                ValidateSettings(globalSettings, null, sResp.Settings);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the continuation token is working by using it multiple times"), EnvRequirement("")]
        public class ContinuationToken : BatchRecoveryBase
        {
            PNUser user = null;
            UserSetting[] globalSettings = null;
            int batchSize = 20;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                // Sync all global settings (48)
                globalSettings = SyncGlobalSettings(user.UserId, ProfileIds.Length);
            }

            public override void Run()
            {
                UserProfileSetting[] totalSettings = new UserProfileSetting[ProfileIds.Length];
                int totalSettingsIndex = 0;
                string continuationToken = "0";

                while (totalSettingsIndex < ProfileIds.Length)
                {
                    HttpWebResponse resp = SettingsRequest(user, batchSize, continuationToken);
                    ProfileReadAllSettingsResponse sResp = ReadSettingsResponse(resp);

                    foreach (UserProfileSetting setting in sResp.Settings)
                    {
                        totalSettings[totalSettingsIndex++] = setting;
                    }

                    if (sResp.PagingInfo.ContinuationToken != null)
                        continuationToken = sResp.PagingInfo.ContinuationToken;
                    else
                        break;
                }

                Assert.AreEqual(totalSettings.Length, ProfileIds.Length, "Expected total count and response count are not the same.");

                ValidateSettings(globalSettings, null, totalSettings);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Test going through XSTS and the AASG"), EnvRequirement("")]
        public class SettingsThroughAASG : BatchRecoveryBase
        {
            PNUser user = null;
            UserSetting[] globalSettings = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                // Sync all global settings
                globalSettings = SyncGlobalSettings(user.UserId, ProfileIds.Length);
            }

            public override void Run()
            {
                string url = String.Format("{0}xuid({1})/settings?maxitems={2}&skipitems={3}", aasgUri, user.UserId.ToString(), 50, 0);
                HttpWebResponse resp = MakeAASGRequest(url, user);

                ProfileReadAllSettingsResponse sResp = ReadSettingsResponse(resp);

                Global.RO.Info("Check Total Count of Settings returned");
                Assert.AreEqual((int)sResp.PagingInfo.TotalItems, ProfileIds.Length, String.Format("Total Count settings {0} != {1}", (int)sResp.PagingInfo.TotalItems, ProfileIds.Length));

                ValidateSettings(globalSettings, null, sResp.Settings);
            }
        }
    }

    /// <summary>
    ///
    /// </summary>
    [Owner("kkline")]
    [TestGroup, Description("Batch Settings API Negative tests")]
    public class Settings_NegativeCases : TestNode
    {
        ///// <summary>
        ///// MyValues Indexes
        ///// [0] = MaxItems for Request
        ///// [1] = SkipItems for Request
        ///// [2] = ContinuationToken for Request
        ///// </summary>
        //[TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Validates the correct error codes are returned for negative values."), EnvRequirement("")]
        //[CompoundCase("NegativeMaxItems", -5, 0, "0")]
        //[CompoundCase("NegativeStartIndex", 32, -5, "0")]
        //[CompoundCase("NegativeContinuationToken", 32, 0, "-5")]
        //public class NegativeParameterValidation : BatchRecoveryBase
        //{
        //    PNUser user = null;

        //    public override void PreRun()
        //    {
        //        user = Fc.CreateXenonUser(false);
        //    }

        //    public override void Run()
        //    {
        //        try
        //        {
        //            if (String.Equals((string)MyValues[2], "0"))
        //            {
        //                HttpWebResponse resp = SettingsRequest(user, (int)MyValues[0], (int)MyValues[1]);
        //            }
        //            else
        //            {
        //                HttpWebResponse resp = SettingsRequest(user, (int)MyValues[0], (string)MyValues[2]);
        //            }

        //            Assert.IsTrue(false, " SettingsRequest is expected to fail with an invalid parameter.");
        //        }
        //        catch (WebException e)
        //        {
        //            HttpStatusCode code = ((HttpWebResponse)e.Response).StatusCode;
        //            Global.RO.Info(e.Message);
        //            Assert.AreEqual(HttpStatusCode.BadRequest, code, " Returned HttpStatusCode was not expected.");
        //        }
        //    }
        //}

        //[TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Xuid in XAuth must match requested user's xuid."), EnvRequirement("")]
        //public class UserTokenXuidMismatch : BatchRecoveryBase
        //{
        //    PNUser user = null;

        //    public override void PreRun()
        //    {
        //        user = Fc.CreateXenonUser(false);
        //    }

        //    public override void Run()
        //    {
        //        // Make new claims with mismatching xuid
        //        List<IClaimsIdentity> claims = GetTestToken(user.Name, 1234567890);

        //        HttpStatusCode code = SendInvalidRequest(profileUri, "settings", user, claims);
        //        Assert.AreEqual(HttpStatusCode.Unauthorized, code, " HttpStatusCode (" + code + ") does match what was expected (" + HttpStatusCode.Unauthorized + ".");
        //    }
        //}

        //[TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("You can only get your own settings"), EnvRequirement("")]
        //public class OtherUsersSettingsNotReturned : BatchRecoveryBase
        //{
        //    PNUser requestor = null;
        //    PNUser requestee = null;

        //    public override void PreRun()
        //    {
        //        requestor = Fc.CreateXenonUser(false);
        //        requestee = Fc.CreateXenonUser(false);

        //        // Sync all global settings
        //        SyncGlobalSettings(requestee.UserId, ProfileIds.Length);
        //    }

        //    public override void Run()
        //    {
        //        // Make new claims with other user
        //        List<IClaimsIdentity> requestorClaims = GetTestToken(requestor.Name, requestor.UserId);

        //        HttpStatusCode code = SendInvalidRequest(profileUri, "settings", requestee, requestorClaims);
        //        Assert.AreEqual(HttpStatusCode.Unauthorized, code, " HttpStatusCode (" + code + ") does match what was expected (" + HttpStatusCode.Unauthorized + ").");
        //    }
        //}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\Functional\TitleAchievements.cs ===
﻿using System;
using System.Collections.Generic;
using System.Net;
using Microsoft.IdentityModel.Claims;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserSettings;
using xonline.common.diagnostics;

namespace BatchRecoveryTest.Functional
{
    /// <summary>
    ///
    /// </summary>
    [Owner("kkline")]
    [TestGroup, Description("Batch PossibleAchievement API Positive tests")]
    public class TitleAchievement_PostiveCases : TestNode
    {
        /// <summary>
        /// MyValues Indexes
        /// [0] = Title Count
        /// [1] = MaxItems for Request
        /// [2] = SkipItems for Request
        /// [3] = ContinuationToken for Request
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Title Achievement Cases"), EnvRequirement("")]
        [CompoundCase("NoTitle", 0, 50, 0, 0)]
        [CompoundCase("OneTitle", 1, 50, 0, 0)]
        [CompoundCase("FiveTitles", 5, 200, 0, 0)]
        [CompoundCase("FiftyTitles", 50, 200, 0, 0)]
        [CompoundCase("MaxTitles", BatchRecoverySuite.TitleCount, BatchRecoverySuite.TitleCount, 0, 0)]
        public class TitleAchievements : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] titles = null;
            UserPossibleAchievement[] titleAchievements = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                titles = SyncTitles(user.UserId, (int)MyValues[0]);

                titleAchievements = new UserPossibleAchievement[titles.Length * 40];
                int titleAchIndex = 0;

                for(int t = 0; t < titles.Length; ++t)
                {
                    // Lets do these in reverse order to account for the new sorting
                    UserPossibleAchievement[] achievements = GetPossibleAchievementsEnUs(titles[titles.Length - 1 - t].TitleId); // We now return the awards in reverse order

                    for (int i = 0; i < achievements.Length; ++i)
                    {
                        titleAchievements[titleAchIndex++] = achievements[i];
                    }
                }
            }

            public override void Run()
            {
                HttpWebResponse resp = TitleAchievementsRequest(user, (int)MyValues[1], (int)MyValues[2]);
                ProgressReadAllPossibleAchievementsResponse pAchResp = ReadPossibleAchievementResponse(resp);

                Global.RO.Info("Check Total Count of Title Achievements returned");
                Assert.AreEqual(((int)MyValues[0] * TitleAchievementCount), (int)pAchResp.PagingInfo.TotalItems, String.Format("Total Count title achievements {0} != {1}", (int)pAchResp.PagingInfo.TotalItems, ((int)MyValues[0] * TitleAchievementCount)));

                ValidateTitleAchievements(titleAchievements, pAchResp.Achievements);
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Test localization for title achievements"), EnvRequirement("")]
        public class LocalizedTitleAchievement : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] titles = null;
            UserPossibleAchievement[] titleAchievements = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                titles = SyncTitles(user.UserId, 1);

                titleAchievements = new UserPossibleAchievement[titles.Length * 40];
                int titleAchIndex = 0;

                foreach (UserTitle title in titles)
                {
                    // Get the german strings
                    UserPossibleAchievement[] achievements = GetPossibleAchievementsDeDe(title.TitleId);

                    for (int i = 0; i < achievements.Length; ++i)
                    {
                        titleAchievements[titleAchIndex++] = achievements[i];
                    }
                }
            }

            public override void Run()
            {
                // Make german XAuth
                List<IClaimsIdentity> claims = GetTestToken(user.Name, user.UserId, "Xbox360" /*Xbox360*/, 3 /*German*/, 24 /*Germany*/);

                string url = String.Format("{0}xuid({1})/progress/titleachievements?maxitems={2}&skipitems={3}", progressUri, "0x" + user.UserId.ToString("X"), 40, 0);
                Global.RO.Info(url);

                HttpWebResponse resp = SendRequest(url, user, claims, new string[] { "de-de" });
                ProgressReadAllPossibleAchievementsResponse pAchResp = ReadPossibleAchievementResponse(resp);

                Global.RO.Info("Check Total Count of Title Achievements returned");
                Assert.AreEqual(40, (int)pAchResp.PagingInfo.TotalItems, String.Format("Total Items title achievements {0} != {1}", (int)pAchResp.PagingInfo.TotalItems, 40));

                ValidateTitleAchievements(titleAchievements, pAchResp.Achievements);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the continuation token value takes precedence over the skipitems"), EnvRequirement("")]
        public class ContinuationTokenTakesPrecedence : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] titles = null;
            int titleCount = 5;
            int achCount = 200; // 5 * 40

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                titles = SyncTitles(user.UserId, titleCount);
            }

            public override void Run()
            {
                HttpWebResponse resp = TitleAchievementsRequest(user, achCount, 20, GenerateContinuationToken(0)); // We should expect to start at index 0 because of the continuation token, not 20
                ProgressReadAllPossibleAchievementsResponse sResp = ReadPossibleAchievementResponse(resp);

                Global.RO.Info("Check Total Count of Achievements returned");
                Assert.AreEqual((int)sResp.PagingInfo.TotalItems, achCount, String.Format("Total Items achievements {0} != {1}", (int)sResp.PagingInfo.TotalItems, achCount));
                Assert.AreEqual((int)sResp.Achievements.Length, achCount, "Expected count and response count are not the same.");

                //ValidateAchievements(achievements, sResp.Achievements);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the continuation token is working by using it multiple times"), EnvRequirement("")]
        public class ContinuationToken : BatchRecoveryBase
        {
            PNUser user = null;
            UserPossibleAchievement[] achievements = null;
            int achCount = 40;
            int batchSize = 10;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                SyncTitles(user.UserId, 1);

                // 40 achievements
                achievements = GetPossibleAchievementsEnUs(BatchRecoverySuite.TitleIDStart);
            }

            public override void Run()
            {
                UserPossibleAchievement[] totalAchievements = new UserPossibleAchievement[achCount];
                int totalAchIndex = 0;
                string continuationToken = GenerateContinuationToken(0);

                while (totalAchIndex < achCount)
                {
                    HttpWebResponse resp = TitleAchievementsRequest(user, batchSize, continuationToken);
                    ProgressReadAllPossibleAchievementsResponse sResp = ReadPossibleAchievementResponse(resp);

                    foreach (UserPossibleAchievement achievement in sResp.Achievements)
                    {
                        totalAchievements[totalAchIndex++] = achievement;
                    }

                    if (sResp.PagingInfo.ContinuationToken != null)
                        continuationToken = sResp.PagingInfo.ContinuationToken;
                    else
                        break;
                }

                Assert.AreEqual(totalAchievements.Length, achCount, "Expected total count and response count are not the same.");

                ValidateTitleAchievements(achievements, totalAchievements);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Test going through XSTS and the AASG"), EnvRequirement("")]
        public class TitleAchievementsThroughAASG : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] titles = null;
            UserPossibleAchievement[] titleAchievements = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                titles = SyncTitles(user.UserId, 1);

                titleAchievements = new UserPossibleAchievement[40];
                int titleAchIndex = 0;

                foreach (UserTitle title in titles)
                {
                    UserPossibleAchievement[] achievements = GetPossibleAchievementsEnUs(title.TitleId);

                    for (int i = 0; i < achievements.Length; ++i)
                    {
                        titleAchievements[titleAchIndex++] = achievements[i];
                    }
                }
            }

            public override void Run()
            {
                string url = String.Format("{0}xuid({1})/progress/titleachievements", aasgUri, user.UserId.ToString());
                HttpWebResponse resp = MakeAASGRequest(url, user);
                ProgressReadAllPossibleAchievementsResponse pAchResp = ReadPossibleAchievementResponse(resp);

                Global.RO.Info("Check Total Count of Title Achievements returned");
                Assert.AreEqual(TitleAchievementCount, (int)pAchResp.PagingInfo.TotalItems, String.Format("Total Count title achievements {0} != {1}", (int)pAchResp.PagingInfo.TotalItems, TitleAchievementCount));

                ValidateTitleAchievements(titleAchievements, pAchResp.Achievements);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\common\dvt.cs ===
using System;
using System.Net;
using System.Data.SqlClient;
using System.Data;
using System.IO;

using xonline.common.protocol;
using xonline.common.config;
using xonline.server.stats.common;
using xonline.common.stfutil;

namespace xonline.server.stats.test.dvt 
{
    class DvtConstants
    {
        public const uint   TitleId         = 0xfeedfeed;
        public const ulong  TestMachineId   = 0xf00df00df00df00d;
    }

    public class DvtConfig
    {
            
        static public string     _environment = "dcaiafa";
        static public int        _iInternetPort   = 10070;
        static public int        _iDatacenterPort = 11070;
        static public string     _frontdoor = "127.0.0.1";
        static public string     _lbsvrname = "dcaiafa3";
        static public IPEndPoint _lbsvraddr = new IPEndPoint(0, 0);
        static public string     _configserver = "127.0.0.1";
        static public string     _configdb = "npdb";
        static public int        _iRandomSeed = (new Random()).Next();
        static public bool       _fThrow = false;


        static DvtConfig()
        {
            LoadConfig();
        }

        static public void LoadConfig()
        {
        
            // environment
            {
                DvtConfig._environment = xonline.common.config.Config.Environment;
            }

            // Lbsvr
            {
                string[] serverNames = xonline.common.config.Config.GetServerListByInterface(Interface.lbsvr);
                DvtConfig._lbsvrname = serverNames[0];//BUGBUG: serverNames[0]
                IInterfaceInfo face = xonline.common.config.Config.GetInterface(DvtConfig._lbsvrname, Interface.lbsvr); 
                DvtConfig._lbsvraddr = new IPEndPoint(face.IPAddress, face.Port);
            }

            // Stats FD
            {
                IVirtualInterfaceInfo face = xonline.common.config.Config.GetVirtualInterface(VirtualInterface.xstatsfd, Site.main);
                DvtConfig._frontdoor = face.IPAddressString;
                DvtConfig._iInternetPort = face.Port;

                face = xonline.common.config.Config.GetVirtualInterface(VirtualInterface.xstatsfd_int, Site.main);
                DvtConfig._iDatacenterPort = face.Port;
            }

            // Config db
            {
                IInterfaceInfo face  = xonline.common.config.Config.GetSingleInterface(Interface.npdb);
                DvtConfig._configserver = face.IPAddressString;
                DvtConfig._configdb     = face.DBName;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\Functional\Titles.cs ===
﻿using System;
using System.Collections.Generic;
using System.Net;
using Microsoft.IdentityModel.Claims;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserSettings;
using xonline.common.diagnostics;

namespace BatchRecoveryTest.Functional
{
    [Owner("kkline")]
    [TestGroup, Description("Batch Titles API Positive tests")]
    public class Titles_PostiveCases : TestNode
    {
        /// <summary>
        /// MyValues Indexes
        /// [0] = Title Count
        /// [1] = MaxItems for Request
        /// [2] = SkipItems for Request
        /// [3] = ContinuationToken for Request
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Title Cases"), EnvRequirement("")]
        [CompoundCase("NoTitle", 0, 50, 0, 0)]
        [CompoundCase("OneTitle", 1, 50, 0, 0)]
        [CompoundCase("TenTitles", 10, 50, 0, 0)]
        [CompoundCase("FiftyTitles", 50, 50, 0, 0)]
        [CompoundCase("MaxTitles", BatchRecoverySuite.TitleCount, BatchRecoverySuite.TitleCount, 0, 0)]
        public class Titles : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] userTitles = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                if ((int)MyValues[0] != 0)
                    userTitles = SyncTitles(user.UserId, (int)MyValues[0]);
            }

            public override void Run()
            {
                HttpWebResponse resp = TitleHistoryRequest(user, (int)MyValues[1], (int)MyValues[2]);
                ProgressReadAllTitlesResponse tResp = ReadTitlesResponse(resp);

                Global.RO.Info("Check Total Count of Titles returned");
                Assert.AreEqual((int)MyValues[0], (int)tResp.PagingInfo.TotalItems, String.Format("Total Count titles {0} != {1}", (int)tResp.PagingInfo.TotalItems, (int)MyValues[0]));

                ValidateUserTitles(userTitles, tResp.Titles);
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Test localization for user titles"), EnvRequirement("")]
        public class LocalizedUserTitle : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] userTitles = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                userTitles = SyncTitles(user.UserId, 1, "fr-FR");
            }

            public override void Run()
            {
                // Make french XAuth
                List<IClaimsIdentity> claims = GetTestToken(user.Name, user.UserId, "Xbox360" /*Xbox360*/, 4 /*French*/, 34 /*France*/);

                string url = String.Format("{0}xuid({1})/titlehistory?maxitems={2}&skipitems={3}", progressUri, "0x" + user.UserId.ToString("X"), 32, 0);
                Global.RO.Info(url);

                HttpWebResponse resp = SendRequest(url, user, claims, new string[] { "fr-fr" });
                ProgressReadAllTitlesResponse tResp = ReadTitlesResponse(resp);

                Global.RO.Info("Check Total Count of Titles returned");
                Assert.AreEqual(1, (int)tResp.PagingInfo.TotalItems, String.Format("Total Items titles {0} != {1}", 1, (int)tResp.PagingInfo.TotalItems));

                ValidateUserTitles(userTitles, tResp.Titles);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the continuation token value takes precedence over the skipitems"), EnvRequirement("")]
        public class ContinuationTokenTakesPrecedence : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] userTitles = null;
            int numTitles = 50;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                // Sync 50 titles
                userTitles = SyncTitles(user.UserId, numTitles);
            }

            public override void Run()
            {
                HttpWebResponse resp = TitleHistoryRequest(user, numTitles, 20, GenerateContinuationToken(0)); // We should expect to start at index 0 because of the continuation token, not 20
                ProgressReadAllTitlesResponse sResp = ReadTitlesResponse(resp);

                Global.RO.Info("Check Total Count of Titles returned");
                Assert.AreEqual((int)sResp.PagingInfo.TotalItems, numTitles, String.Format("Total Items titles {0} != {1}", (int)sResp.PagingInfo.TotalItems, numTitles));
                Assert.AreEqual((int)sResp.Titles.Length, numTitles, "Expected count and response count are not the same.");

                //ValidateUserTitles(userTitles, sResp.Titles);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the continuation token is working by using it multiple times"), EnvRequirement("")]
        public class ContinuationToken : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] userTitles = null;
            int numTitles = 50;
            int batchSize = 20;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);

                // Sync 50 titles
                userTitles = SyncTitles(user.UserId, numTitles);
            }

            public override void Run()
            {
                UserProgressTitle[] totalTitles = new UserProgressTitle[numTitles];
                int totalTitlesIndex = 0;
                string continuationToken = GenerateContinuationToken(0);

                while (totalTitlesIndex < numTitles)
                {
                    HttpWebResponse resp = TitleHistoryRequest(user, batchSize, continuationToken);
                    ProgressReadAllTitlesResponse sResp = ReadTitlesResponse(resp);

                    foreach (UserProgressTitle title in sResp.Titles)
                    {
                        totalTitles[totalTitlesIndex++] = title;
                    }

                    if (sResp.PagingInfo.ContinuationToken != null)
                        continuationToken = sResp.PagingInfo.ContinuationToken;
                    else
                        break;
                }

                Assert.AreEqual(totalTitles.Length, numTitles, "Expected total count and response count are not the same.");

                ValidateUserTitles(userTitles, totalTitles);
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Test going through XSTS and the AASG"), EnvRequirement("")]
        public class TitlesThroughAASG : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] userTitles = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                userTitles = SyncTitles(user.UserId, 1);
            }

            public override void Run()
            {
                string url = String.Format("{0}xuid({1})/titlehistory", aasgUri, user.UserId.ToString());

                HttpWebResponse resp = MakeAASGRequest(url, user);
                ProgressReadAllTitlesResponse tResp = ReadTitlesResponse(resp);

                Global.RO.Info("Check Total Count of Titles returned");
                Assert.AreEqual(1, (int)tResp.PagingInfo.TotalItems, String.Format("Total Items titles {0} != {1}", 1, (int)tResp.PagingInfo.TotalItems));

                ValidateUserTitles(userTitles, tResp.Titles);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\BatchRecovery\Functional\TitleAvatarAwards.cs ===
﻿using System;
using System.Collections.Generic;
using System.Net;
using Microsoft.IdentityModel.Claims;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserSettings;
using xonline.common.diagnostics;

namespace BatchRecoveryTest.Functional
{
    /// <summary>
    ///
    /// </summary>
    [Owner("kkline")]
    [TestGroup, Description("Batch PossibleAvatarAwards API Positive tests")]
    public class TitleAvatarAwards_PostiveCases : TestNode
    {
        /// <summary>
        /// MyValues Indexes
        /// [0] = Title Count
        /// [1] = MaxItems for Request
        /// [2] = SkipItems for Request
        /// [3] = ContinuationToken for Request
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Title Avatar Award Cases"), EnvRequirement("")]
        [CompoundCase("NoTitle", 0, 50, 0, 0)]
        [CompoundCase("OneTitle", 1, 50, 0, 0)]
        [CompoundCase("FiveTitles", 5, 200, 0, 0)]
        [CompoundCase("FiftyTitles", 50, 200, 0, 0)]
        [CompoundCase("MaxTitles", BatchRecoverySuite.TitleCount, BatchRecoverySuite.TitleCount, 0, 0)]
        public class TitleAvatarAwards : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] titles = null;
            UserPossibleAvatarAward[] titleAvatarAwards = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                titles = SyncTitles(user.UserId, (int)MyValues[0]);

                titleAvatarAwards = new UserPossibleAvatarAward[titles.Length * 5];
                int titleAssetIndex = 0;

                for (int t = 0; t < titles.Length; ++t)
                {
                    UserPossibleAvatarAward[] awards = GetPossibleAvatarAwardsEnUs(titles[titles.Length - 1 - t].TitleId); // We now return the awards in reverse order

                    for (int i = 0; i < awards.Length; ++i)
                    {
                        titleAvatarAwards[titleAssetIndex++] = awards[i];
                    }
                }
            }

            public override void Run()
            {
                HttpWebResponse resp = TitleAvatarAwardsRequest(user, (int)MyValues[1], (int)MyValues[2]);
                ProgressReadAllPossibleAvatarAwardsResponse paaResp = ReadPossibleAvatarAwardsResponse(resp);

                Global.RO.Info("Check Total Count of Title Avatar Awards returned");
                Assert.AreEqual(((int)MyValues[0] * TitleAvatarAwardCount), (int)paaResp.PagingInfo.TotalItems, String.Format("Total Count title avatar awards {0} != {1}", (int)paaResp.PagingInfo.TotalItems, ((int)MyValues[0] * TitleAvatarAwardCount)));

                ValidateTitleAvatarAwards(titleAvatarAwards, paaResp.AvatarAwards);
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Test localization for title avatar awards"), EnvRequirement("")]
        public class LocalizedTitleAvatarAward : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] titles = null;
            UserPossibleAvatarAward[] titleAvatarAwards = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                titles = SyncTitles(user.UserId, 1);

                titleAvatarAwards = new UserPossibleAvatarAward[titles.Length * TitleAvatarAwardCount];
                int titleAvatarAwardIndex = 0;

                foreach (UserTitle title in titles)
                {
                    // Get the french strings
                    UserPossibleAvatarAward[] avatarAwards = GetPossibleAvatarAwardsFrFr(title.TitleId);

                    for (int i = 0; i < avatarAwards.Length; ++i)
                    {
                        titleAvatarAwards[titleAvatarAwardIndex++] = avatarAwards[i];
                    }
                }
            }

            public override void Run()
            {
                // Make french XAuth
                List<IClaimsIdentity> claims = GetTestToken(user.Name, user.UserId, "Xbox360" /*Xbox360*/, 4 /*French*/, 34 /*France*/);

                string url = String.Format("{0}xuid({1})/progress/titleavatarawards?maxitems={2}&skipitems={3}", progressUri, "0x" + user.UserId.ToString("X"), TitleAvatarAwardCount, 0);
                Global.RO.Info(url);

                HttpWebResponse resp = SendRequest(url, user, claims, new string[] { "fr-fr" });
                ProgressReadAllPossibleAvatarAwardsResponse pAchResp = ReadPossibleAvatarAwardsResponse(resp);

                Global.RO.Info("Check Total Count of Title Avatar Awards returned");
                Assert.AreEqual(TitleAvatarAwardCount, (int)pAchResp.PagingInfo.TotalItems, String.Format("Total Items title achievements {0} != {1}", (int)pAchResp.PagingInfo.TotalItems, TitleAvatarAwardCount));

                ValidateTitleAvatarAwards(titleAvatarAwards, pAchResp.AvatarAwards);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the continuation token value takes precedence over the skipitems"), EnvRequirement("")]
        public class ContinuationTokenTakesPrecedence : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] titles = null;
            int titleCount = 6;
            int aaCount = 30; // 6 * 5

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                titles = SyncTitles(user.UserId, titleCount);
            }

            public override void Run()
            {
                HttpWebResponse resp = TitleAvatarAwardsRequest(user, aaCount, 20, GenerateContinuationToken(0)); // We should expect to start at index 0 because of the continuation token, not 20
                ProgressReadAllPossibleAvatarAwardsResponse sResp = ReadPossibleAvatarAwardsResponse(resp);

                Global.RO.Info("Check Total Count of Achievements returned");
                Assert.AreEqual((int)sResp.PagingInfo.TotalItems, aaCount, String.Format("Total Items avatar awards {0} != {1}", (int)sResp.PagingInfo.TotalItems, aaCount));
                Assert.AreEqual((int)sResp.AvatarAwards.Length, aaCount, "Expected count and response count are not the same.");

                //ValidateAchievements(achievements, sResp.Achievements);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Verify the continuation token is working by using it multiple times"), EnvRequirement("")]
        public class ContinuationToken : BatchRecoveryBase
        {
            PNUser user = null;
            UserPossibleAvatarAward[] avatarAwards = null;
            int aaCount = 5;
            int batchSize = 2;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                SyncTitles(user.UserId, 1);

                // 5 avatarAwards
                avatarAwards = GetPossibleAvatarAwardsEnUs(BatchRecoverySuite.TitleIDStart);
            }

            public override void Run()
            {
                UserPossibleAvatarAward[] totalAvatarAwards = new UserPossibleAvatarAward[aaCount];
                int totalAaIndex = 0;
                string continuationToken = GenerateContinuationToken(0);

                while (totalAaIndex < aaCount)
                {
                    HttpWebResponse resp = TitleAvatarAwardsRequest(user, batchSize, continuationToken);
                    ProgressReadAllPossibleAvatarAwardsResponse sResp = ReadPossibleAvatarAwardsResponse(resp);

                    foreach (UserPossibleAvatarAward avatarAward in sResp.AvatarAwards)
                    {
                        totalAvatarAwards[totalAaIndex++] = avatarAward;
                    }

                    if (sResp.PagingInfo.ContinuationToken != null)
                        continuationToken = sResp.PagingInfo.ContinuationToken;
                    else
                        break;
                }

                Assert.AreEqual(totalAvatarAwards.Length, aaCount, "Expected total count and response count are not the same.");

                ValidateTitleAvatarAwards(avatarAwards, totalAvatarAwards);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Test going through XSTS and the AASG"), EnvRequirement("")]
        public class TitleAvatarAwardsThroughAASG : BatchRecoveryBase
        {
            PNUser user = null;
            UserTitle[] titles = null;
            UserPossibleAvatarAward[] titleAvatarAwards = null;

            public override void PreRun()
            {
                user = Fc.CreateXenonUser(false);
                titles = SyncTitles(user.UserId, 1);

                titleAvatarAwards = new UserPossibleAvatarAward[TitleAvatarAwardCount];
                int titleAchIndex = 0;

                foreach (UserTitle title in titles)
                {
                    UserPossibleAvatarAward[] awards = GetPossibleAvatarAwardsEnUs(title.TitleId);

                    for (int i = 0; i < awards.Length; ++i)
                    {
                        titleAvatarAwards[titleAchIndex++] = awards[i];
                    }
                }
            }

            public override void Run()
            {
                string url = String.Format("{0}xuid({1})/progress/titleavatarawards", aasgUri, user.UserId.ToString());
                HttpWebResponse resp = MakeAASGRequest(url, user);
                ProgressReadAllPossibleAvatarAwardsResponse paaResp = ReadPossibleAvatarAwardsResponse(resp);

                Global.RO.Info("Check Total Count of Title Avatar Awards returned");
                Assert.AreEqual(TitleAvatarAwardCount, (int)paaResp.PagingInfo.TotalItems, String.Format("Total Count title avatar awards {0} != {1}", (int)paaResp.PagingInfo.TotalItems, TitleAvatarAwardCount));

                ValidateTitleAvatarAwards(titleAvatarAwards, paaResp.AvatarAwards);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\common\req.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.stats.test.dvt 
{
    // MessageWrapper
    // Stuff to help fill out the messages
    class MessageWrapper
    {
        
        // ToMsgSetData
        // Fills MsgSetData
        static public MsgSetData ToMsgSetData(uint uiLbId, ulong ulUserId, MsgAttribData[] attribs)
        {
            MsgSetData msg      = new MsgSetData();
            msg._uiTitleId      = DvtConstants.TitleId;
            msg._ulUserId       = ulUserId;
            msg._uiLbId         = uiLbId;
            msg._uiAttrCount    = (ushort) attribs.Length;
            msg._attribs        = attribs;
            return msg;
        }

        // ToMsgGetData
        // Fills MsgGetData
        static public MsgGetData ToMsgGetData(uint uiLbId, ulong ulUserId, ushort[] attribIds)
        {
            MsgGetData msg      = new MsgGetData();
            msg._uiTitleId      = DvtConstants.TitleId;
            msg._ulUserId       = ulUserId;
            msg._uiLbId         = uiLbId;
            msg._uiAttrCount    = (uint) attribIds.Length;
            msg._attrIds        = attribIds;
            return msg;
        }

        // ToMsgAttribData
        // Fills an array of MsgAttribData. The parameters are always:
        // 2n   - attribute id
        // 2n+1 - attribute value
        static public MsgAttribData[] ToMsgAttribData(params object[] attrData)
        {
            MsgAttribData[] attribs = new MsgAttribData[attrData.Length/2];

            for(int ndx=0; ndx < attribs.Length; ndx++)
            {
                attribs[ndx] = new MsgAttribData();

                if(attrData[ndx*2] is int)
                    attribs[ndx]._usAttrId = (ushort)(int)attrData[ndx*2];
                else if(attrData[ndx*2] is uint)
                    attribs[ndx]._usAttrId = (ushort)(uint)attrData[ndx*2];
                else if(attrData[ndx*2] is short)
                    attribs[ndx]._usAttrId = (ushort)(short)attrData[ndx*2];
                else if(attrData[ndx*2] is ushort)
                    attribs[ndx]._usAttrId = (ushort)attrData[ndx*2];
                else
                    throw new Exception("Invalid object type for _usAttrId.");

                if(attrData[ndx*2+1] == null)
                {
                    attribs[ndx]._bAttrType = (byte) AttrType.None;
                    attribs[ndx]._value = null;
                }
                else if(attrData[ndx*2+1] is int)
                {
                    attribs[ndx]._bAttrType = (byte) AttrType.Long;
                    attribs[ndx]._value = (int)attrData[ndx*2+1];
                }
                else if(attrData[ndx*2+1] is uint)
                {
                    attribs[ndx]._bAttrType = (byte) AttrType.Long;
                    attribs[ndx]._value = (int)(uint)attrData[ndx*2+1];
                }
                else if(attrData[ndx*2+1] is long)
                {
                    attribs[ndx]._bAttrType = (byte) AttrType.LongLong;
                    attribs[ndx]._value = (long)attrData[ndx*2+1];
                }
                else if(attrData[ndx*2+1] is ulong)
                {
                    attribs[ndx]._bAttrType = (byte) AttrType.LongLong;
                    attribs[ndx]._value = (long)(ulong)attrData[ndx*2+1];
                }
                else if(attrData[ndx*2+1] is double)
                {
                    attribs[ndx]._bAttrType = (byte) AttrType.Double;
                    attribs[ndx]._value = attrData[ndx*2+1];
                }
                else if(attrData[ndx*2+1] is float)
                {
                    attribs[ndx]._bAttrType = (byte) AttrType.Double;
                    attribs[ndx]._value = (double)(float)attrData[ndx*2+1];
                }
                else if(attrData[ndx*2+1] is string)
                {
                    attribs[ndx]._bAttrType = (byte) AttrType.String;
                    attribs[ndx]._value = attrData[ndx*2+1];
                }
                else
                    throw new Exception("Invalid object type for _value.");
            }

            return attribs;
        }

        public struct Puid
        {
            public Puid(ulong puid)
            {
                _puid = puid;
            }
            
            public ulong _puid;
        }

        static public ReqStatPost ToReqStatPost(
            uint                        uiTitleId,
            MsgStatPostProcedureCall[]  procs )
        {
            ReqStatPost msg = new ReqStatPost();
            msg._uiTitleId = uiTitleId;
            msg._usProcCount = (ushort) procs.Length;
            msg._procs = procs;

            return msg;
        }
        
        static public MsgStatPostProcedureCall ToMsgStatPostProcedureCall(
            ushort usProcId, 
            params object[] param)
        {
            ArrayList paramMsgs = new ArrayList();
            MsgStatPostProcedureCall msg = new MsgStatPostProcedureCall();
            msg._usProcId = usProcId;
            
            for(int i=0; i < param.Length; i++)
            {
                MsgStatPostParameter paramMsg = new MsgStatPostParameter();
                if(param[i] is byte)
                {
                    paramMsg._bParamType = StatParam.Int8;
                    paramMsg._data = param[i];
                }
                else if(param[i] is short)
                {
                    paramMsg._bParamType = StatParam.Int16;
                    paramMsg._data = param[i];
                }
                else if(param[i] is int)
                {
                    paramMsg._bParamType = StatParam.Int32;
                    paramMsg._data = param[i];
                }
                else if(param[i] is long)
                {
                    paramMsg._bParamType = StatParam.Int64;
                    paramMsg._data = param[i];
                }
                else if(param[i] is double)
                {
                    paramMsg._bParamType = StatParam.Float;
                    paramMsg._data = param[i];
                }
                else if(param[i] is string)
                {
                    paramMsg._bParamType = StatParam.Utf8string;
                    paramMsg._data = param[i];
                }
                else if(param[i] is Puid)
                {
                    paramMsg._bParamType = StatParam.Puid;
                    paramMsg._data = ((Puid)param[i])._puid;
                }
                else
                {
                    throw new Exception("Invalid type of param[i]");
                }
                
                paramMsgs.Add(paramMsg);
            }

            msg._params = (MsgStatPostParameter[]) paramMsgs.ToArray(typeof(MsgStatPostParameter));
            msg._usParamCount = (ushort) msg._params.Length;

            return msg;
        }

        static public ReqStatUnitGet ToReqStatUnitGet(uint uiTitleId, ulong[] puids, MsgUnitStatGetSpec[] specs)
        {
            ReqStatUnitGet req = new ReqStatUnitGet();
            req._uiTitleId = uiTitleId;
            if(puids.Length >= 1) req._ulPuid1 = puids[0];
            if(puids.Length >= 2) req._ulPuid2 = puids[1];
            if(puids.Length >= 3) req._ulPuid3 = puids[2];
            if(puids.Length >= 4) req._ulPuid4 = puids[3];
            req._usSpecCount = (ushort) specs.Length;
            req._specs = specs;

            return req;
        }

        static public MsgUnitStatGetSpec ToMsgUnitStatGetSpec(uint uiLbId, ushort[] statIds)
        {
            MsgUnitStatGetSpec msg = new MsgUnitStatGetSpec();
            msg._uiLbId = uiLbId;
            msg._usNumStats = (ushort) statIds.Length;
            msg._statIds = statIds;
        
            return msg;
        }

        static public ReqUnitEnum ToReqUnitEnum(uint uiTitleId, uint uiLbId, uint uiFlags, ulong ulPuid, 
            ushort usPageSize, ushort[] statIds)
        {
            ReqUnitEnum req = new ReqUnitEnum();
            req._uiTitleId = uiTitleId;
            req._uiLbId = uiLbId;
            req._uiFlags = uiFlags;
            req._ulPuid = ulPuid;
            req._usPageSize = usPageSize;
            req._usStatCount = (ushort) statIds.Length;
            req._statIds = statIds;

            return req;
        }
    }

    // ReqStatWrite
    // StatWrite request.
    class ReqStatWrite
    {
        public ReqStatWrite(MsgSetData[] setDataMessages)
        {
            _setDataMessages = setDataMessages;
        }

        public void Post()
        {
            MemoryStream        memStream   = new MemoryStream();
            BinaryWriter        writer      = new BinaryWriter(memStream);

            // build message
            foreach(MsgSetData msg in _setDataMessages)
            {
                msg.WriteTo(writer);
            }
            
            // Post message
            byte[] req = memStream.ToArray();
            byte[] resp = null;
            
            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/xstatsset.ashx", 
                req, out resp);

            // Process resp
            if(resp.Length > 0)
            {
                BinaryReader            repReader   = new BinaryReader(new MemoryStream(resp));
                _rep                                = new RepSetDataCanUploadAtt();
                _rep.ReadFrom(repReader);
            }
        }

        public  MsgSetData[]            _setDataMessages;
        public  RepSetDataCanUploadAtt  _rep        = null;
        public  uint                    _hr         = HResult.S_FALSE;
    }

    // ReqStatRead
    // StatRead request.
    class ReqStatRead
    {
        public ReqStatRead(MsgGetData[] getDataMsgs)
        {
            _getDataMsgs = getDataMsgs;
        }

        public void Post()
        {
            MemoryStream        memStream   = new MemoryStream();
            BinaryWriter        writer      = new BinaryWriter(memStream);

            // build message
            foreach(MsgGetData msg in _getDataMsgs)
            {
                msg.WriteTo(writer);
            }
            
            // Post message
            byte[] req = memStream.ToArray();
            byte[] resp = null;
            
            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/xstatsget.ashx", 
                req, out resp);

            // Process resp
            if(resp.Length > 0)
            {
                BinaryReader            repReader   = new BinaryReader(new MemoryStream(resp));
                _reps                               = new MsgRepGetData[_getDataMsgs.Length];
                
                for(int ndx=0; ndx < _reps.Length; ndx++)
                {
                    _reps[ndx]          = new MsgRepGetData();
                    _reps[ndx]._attribs = new MsgAttribData[_getDataMsgs[ndx]._attrIds.Length];
                    _reps[ndx].ReadFrom(repReader);
                }
            }
        }

        public  MsgGetData[]            _getDataMsgs;
        public  MsgRepGetData[]         _reps       = null;
        public  uint                    _hr         = HResult.S_FALSE;
    }

    // EnumLB
    // Enumerate Leaderboard request.
    class ReqEnumLB
    {
        public ReqEnumLB(uint uiLb, object pivot, uint uiPageStart, uint uiPageSize, ushort[] attribsReq)
        {
            _uiLb           = uiLb;
            _pivot          = pivot;
            _uiPageStart    = uiPageStart;
            _uiPageSize     = uiPageSize;
            _attribsReq     = attribsReq;
        }

        public void Post()
        {
            MsgEnumLB msg = new MsgEnumLB();
            msg._uiTitleId      = DvtConstants.TitleId;
            msg._uiLb           = _uiLb;
            msg._ulPivotOrPageStart = (_pivot != null ? (ulong) _pivot : _uiPageStart);
            msg._bIsPivotUser   = (_pivot != null ? (byte) 1 : (byte) 0);
            msg._uiPageSize     = _uiPageSize;
            msg._uiAttrCount    = (uint) _attribsReq.Length;
            msg._attrIds        = _attribsReq;

            MemoryStream memStream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(memStream);
            msg.WriteTo(writer);

            byte[] req = memStream.ToArray();
            byte[] resp = null;
            
            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/xstatsenumlb.ashx", 
                req, out resp);

            if(HResult.Succeeded(_hr))
            {
                BinaryReader    repReader   = new BinaryReader(new MemoryStream(resp));
                _rep                        = new RepEnumLB();
                _rep.ReadFrom(repReader);
            }
        }
        
        public uint         _uiLb;
        public object       _pivot;
        public uint         _uiPageStart;
        public uint         _uiPageSize;
        public ushort[]     _attribsReq;
        public RepEnumLB    _rep            = null;
        public uint         _hr             = HResult.S_FALSE;
    }

    // ReqReset
    // Leaderboard reset request
    class ReqReset
    {
        public ReqReset(ulong userId, uint lbId, TeamTicket[] tickets )
        {
            _userId = userId;
            _lbId = lbId;
            _teamtickets = tickets;
        }

        public void Post()
        {
            MsgReset msg = new MsgReset();
            msg.titleId = DvtConstants.TitleId;
            msg.leaderBoardType = _lbId;
            msg.userId = _userId;
            
            if(_teamtickets != null)
            {
                msg._teamTickets = new TeamTickets(_teamtickets);
            }
            else
            {
                msg._teamTickets = null;
            }

            MemoryStream memStream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(memStream);
            msg.WriteTo(writer);

            byte[] req = memStream.ToArray();
            byte[] resp = null;
            
            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/xstatsreset.ashx", 
                req, out resp);
        }

        public  ulong   _userId;
        public  uint    _lbId;
        public  TeamTicket[] _teamtickets = null;
        public  uint    _hr     = HResult.S_FALSE;
    }
    

    // ReqCommitAtt
    // Commit attachment request
    class ReqCommitAtt
    {
        public ReqCommitAtt(
            string                  attachPathName,
            RepSetDataReference[]   refs, 
            uint                    uiSize, 
            uint                    uiSizeUncomp)
        {
            _attachPathName     = attachPathName;
            _refs               = refs;
            _uiSize             = uiSize;
            _uiSizeUncomp       = uiSizeUncomp;
        }

        public void Post()
        {
            MsgCommitAttachment msg = new MsgCommitAttachment();
            msg._uiTitleId          = DvtConstants.TitleId;
            msg._uiAttSize          = _uiSize;
            msg._uiAttSizeUncomp    = _uiSizeUncomp;
            msg._pathName           = _attachPathName;
            msg._refs               = new MsgCommitAttachmentReference[_refs.Length];
            
            for(int ndx=0; ndx < _refs.Length; ndx++)
            {
                msg._refs[ndx] = new MsgCommitAttachmentReference();
                msg._refs[ndx]._uiLb    = _refs[ndx]._uiLb;
                msg._refs[ndx]._ulUser  = _refs[ndx]._ulUser;
            }

            MemoryStream memStream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(memStream);
            msg.WriteTo(writer);

            byte[] req = memStream.ToArray();
            byte[] resp = null;
            
            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/xstatscommitatt.ashx", 
                req, out resp);
        }

        string                      _attachPathName;
        RepSetDataReference[]       _refs;
        public uint                 _uiSize;
        public uint                 _uiSizeUncomp;
        public  uint                _hr             = HResult.S_FALSE;
    }
 
    // WebEnumLB
    // Enumerate Leaderboard request.
    class ReqWebEnumLB
    {
        public ReqWebEnumLB(uint uiLb, object pivot, uint uiPageStart, uint uiPageSize)
        {
            _uiLb           = uiLb;
            _pivot          = pivot;
            _uiPageStart    = uiPageStart;
            _uiPageSize     = uiPageSize;
        }

        public void Post()
        {
            MsgWebEnumLB msg = new MsgWebEnumLB();
            msg._uiTitleId      = DvtConstants.TitleId;
            msg._uiLb           = _uiLb;
            msg._ulPivotOrPageStart = (_pivot != null ? (ulong) _pivot : _uiPageStart);
            msg._bIsPivotUser   = (_pivot != null ? (byte) 1 : (byte) 0);
            msg._uiPageSize     = _uiPageSize;

            MemoryStream memStream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(memStream);
            msg.WriteTo(writer);

            byte[] req = memStream.ToArray();
            byte[] resp = null;
            
            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/xstatswebenumlb.ashx", 
                req, out resp);

            if(HResult.Succeeded(_hr))
            {
                BinaryReader    repReader   = new BinaryReader(new MemoryStream(resp));
                _rep                        = new RepWebEnumLB();
                _rep.ReadFrom(repReader);
            }
        }
        
        public uint         _uiLb;
        public object       _pivot;
        public uint         _uiPageStart;
        public uint         _uiPageSize;
        public RepWebEnumLB _rep            = null;
        public uint         _hr             = HResult.S_FALSE;
    }

    // ReqRemoveAtt
    // Remove attachment request
    class ReqRemoveAtt
    {
        public ReqRemoveAtt(string attachPathName)
        {
            _attachPathName = attachPathName;
        }

        public void Post()
        {
            MsgRemoveAtt msg = new MsgRemoveAtt();
            msg._attachPathName = _attachPathName;

            MemoryStream memStream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(memStream);
            msg.WriteTo(writer);

            byte[] req = memStream.ToArray();
            byte[] resp = null;
            
            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/xstatsremoveatt.ashx", 
                req, out resp);
                
            if(HResult.Succeeded(_hr))
            {
                BinaryReader    repReader   = new BinaryReader(new MemoryStream(resp));
                _rep                        = new RepRemoveAtt();
                _rep.ReadFrom(repReader);
            }                
        }

        
        public string       _attachPathName;
        public uint         _hr             = HResult.S_FALSE;
        public RepRemoveAtt _rep = null;
    }

    // XRLPostStatPost
    public class XRLPostStatPost
    {
        public XRLPostStatPost(ReqStatPost req)
        {
            _req = req;
        }
        
        public void Post()
        {
            MemoryStream ms     = new MemoryStream();
            BinaryWriter bw     = new BinaryWriter(ms);
            _req.WriteTo(bw);
            
            byte[] binReq       = ms.ToArray();
            byte[] binRep       = null;

            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/statpost.ashx",
                binReq, out binRep);
        
            // Process resp
            if(binRep.Length > 0)
            {
                BinaryReader            repReader   = new BinaryReader(new MemoryStream(binRep));
                _rep                                = new RepSetDataCanUploadAtt();
                _rep.ReadFrom(repReader);
            }
        
        }
    
        public ReqStatPost              _req        = null;
        public RepSetDataCanUploadAtt   _rep        = null;
        public uint                     _hr     = HResult.S_FALSE;
    }

    public class XRLPostStatUnitGet
    {
        public XRLPostStatUnitGet(ReqStatUnitGet req)
        {
            _req = req;
        }

        public void Post()
        {
            MemoryStream ms     = new MemoryStream();
            BinaryWriter bw     = new BinaryWriter(ms);
            _req.WriteTo(bw);
            
            byte[] binReq       = ms.ToArray();
            byte[] binRep       = null;

            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/statunitget.ashx",
                binReq, out binRep);

            if(_hr == HResult.S_OK)
            {
                BinaryReader br = new BinaryReader(new MemoryStream(binRep));
                _rep = new RepUnitStatGet();
                _rep.ReadFrom(br);
            }
        }

        public uint                         _hr     = HResult.S_FALSE;
        public ReqStatUnitGet               _req;
        public RepUnitStatGet               _rep;
    }

    public class XRLPostUnitEnum
    {
        public XRLPostUnitEnum(ReqUnitEnum req)
        {
            _req = req;
        }

        public void Post()
        {
            MemoryStream ms     = new MemoryStream();
            BinaryWriter bw     = new BinaryWriter(ms);
            _req.WriteTo(bw);
            
            byte[] binReq       = ms.ToArray();
            byte[] binRep       = null;

            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/statunitenum.ashx",
                binReq, out binRep);

            if(_hr == HResult.S_OK)
            {
                BinaryReader br = new BinaryReader(new MemoryStream(binRep));
                _rep = new RepUnitEnum();
                _rep.ReadFrom(br);
            }
        }

        public uint                         _hr     = HResult.S_FALSE;
        public ReqUnitEnum                  _req;
        public RepUnitEnum                  _rep;
    }
    
    public class XRLPostCompCreateLb
    {
        public XRLPostCompCreateLb(uint uiTitleId, uint uiTemplateId)
        {
            _req = new ReqCompCreateLb();
            _req._uiTitleId = uiTitleId;
            _req._uiTemplateId = uiTemplateId;
        }
        
        public void Post()
        {
            MemoryStream ms     = new MemoryStream();
            BinaryWriter bw     = new BinaryWriter(ms);
            
            _req.WriteTo(bw);
            
            byte[] binReq       = ms.ToArray();
            byte[] binRep       = null;

            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/xstatscompcreatelb.ashx",
                binReq, out binRep);

            if(_hr == HResult.S_OK)
            {
                BinaryReader br = new BinaryReader(new MemoryStream(binRep));
                _rep = new RepCompCreateLb();
                _rep.ReadFrom(br);
            }
        }
        
        public uint                     _hr;
        public ReqCompCreateLb          _req;
        public RepCompCreateLb          _rep;
    }

    public class XRLPostCompDeleteLb
    {
        public XRLPostCompDeleteLb(uint uiTitleId, uint uiLbId)
        {
            _req = new ReqCompDeleteLb();
            _req._uiTitleId = uiTitleId;
            _req._uiLbId = uiLbId;
        }
        
        public void Post()
        {
            MemoryStream ms     = new MemoryStream();
            BinaryWriter bw     = new BinaryWriter(ms);
            
            _req.WriteTo(bw);
            
            byte[] binReq       = ms.ToArray();
            byte[] binRep       = null;

            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/xstatscompdeletelb.ashx",
                binReq, out binRep);
        }
        
        public uint                     _hr;
        public ReqCompDeleteLb          _req;
    }
    
    public class XRLReloadDbMap
    {
        public void Post()
        {
            byte[] binRep = null;
            
            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/xstatsreloaddbmap.ashx",
                new byte[] {}, out binRep);
        }
        
        public uint             _hr;
    }
    
    public class XRLCertReset
    {
        public XRLCertReset(ulong ulPuid)
        {
            _req = new ReqCertReset();
            _req._ulPuid = ulPuid;
        }
        
        public void Post()
        {
            MemoryStream ms     = new MemoryStream();
            BinaryWriter bw     = new BinaryWriter(ms);
            
            _req.WriteTo(bw);
            
            byte[] binReq       = ms.ToArray();
            byte[] binRep       = null;

            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/xstatscertreset.ashx",
                binReq, out binRep);
        }
        
        public ReqCertReset _req;
        public uint         _hr;
    }
    
    public class XRLCertVerify
    {
        public XRLCertVerify(ulong ulPuid)
        {
            _req = new ReqCertVerify();
            _req._ulPuid = ulPuid;
        }
        
        public void Post()
        {
            MemoryStream ms     = new MemoryStream();
            BinaryWriter bw     = new BinaryWriter(ms);
            
            _req.WriteTo(bw);
            
            byte[] binReq       = ms.ToArray();
            byte[] binRep       = null;

            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/xstatscertverify.ashx",
                binReq, out binRep);
                
            if(_hr == HResult.S_OK)
            {
                BinaryReader br = new BinaryReader(new MemoryStream(binRep));
                _rep = new RepCertVerify();
                _rep.ReadFrom(br);
            }
        }
        
        public uint          _hr;
        public ReqCertVerify _req;
        public RepCertVerify _rep = null;
    }

    public class XRLHealth
    {
        public void Post()
        {
            byte[] binRep = null;
            
            _hr = XRL.Post((int)XOService.Stats, "http://"+DvtConfig._frontdoor+"/xstats/health.ashx",
                new byte[] {}, out binRep);
        }
        
        public uint             _hr;
    }

         
    // BatchRequests
    // Usefull methods to batch a bunch of repetitive operations
    class BatchRequests
    {
        class MsgSorter : IComparer
        {
            public int Compare(object x, object y)
            {
                MsgSetData msg1 = (MsgSetData) x;
                MsgSetData msg2 = (MsgSetData) y;

                if(msg1._ulUserId != msg2._ulUserId)
                    return msg1._ulUserId.CompareTo(msg2._ulUserId);
                else if(msg1._uiLbId != msg2._uiLbId)
                    return msg1._uiLbId.CompareTo(msg2._uiLbId);
                else 
                    return 0;
            }
        }

        public static void SetData(MsgSetData[] setDataMessages)
        {
            SetData(setDataMessages, null);
        }
        
        public static void SetData(MsgSetData[] setDataMessages, LbSimulator sim)
        {
            MsgSorter msgSorter = new MsgSorter();
            Array.Sort(setDataMessages, msgSorter);

            ArrayList req = new ArrayList(4);

            for(int msgNdx=0;;)
            {
                // Build a request

                req.Clear();
                ulong   ulUserId    = 0;
                uint    uiUserCount = 0;
                ulong[] userIds     = new ulong[4];

                for(; msgNdx < setDataMessages.Length; msgNdx++)
                {
                    if(req.Count == 20)
                        break;
                    
                    MsgSetData msg = setDataMessages[msgNdx];

                    if( ulUserId != msg._ulUserId)
                    {
                        if(uiUserCount < 4 )
                        {
                            userIds[uiUserCount++]  = msg._ulUserId;
                            ulUserId                = msg._ulUserId;
                        }
                        else
                            break;
                    }

                    req.Add(msg);
                }

                if(req.Count > 0)
                {
                    // Prepare auth
                    XRL.SetSGSession(new SGSession(DvtConstants.TestMachineId, userIds));
                    
                    // Post the request
                    ReqStatWrite reqStatWrite = new ReqStatWrite((MsgSetData[])req.ToArray(typeof(MsgSetData)));
                    reqStatWrite.Post();
                    if(reqStatWrite._hr != HResult.S_OK)
                        throw new DvtTestCaseException("(ReqStatWrite) Expecting hr=S_OK. "+
                            "Received hr=0x"+reqStatWrite._hr.ToString("x"));
                    
                    if(sim != null)
                        sim.Write((MsgSetData[])req.ToArray(typeof(MsgSetData)));
                }
                else
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\common\utdb.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.diagnostics;
using xonline.server.stats.common;

namespace xonline.server.stats.test.dvt 
{
    // DbLeaderboard
    // Handles stuff where we have to go directly to the database.
    class DbLeaderboard
    {
        static public void CreateLeaderboard(
            int     iLbType, 
            byte    bResetType )
        {
            CreateLeaderboard(iLbType, bResetType, 0, 0, 0, 0, "E", 0, 0, "", false, false);
        }
        
        static public void CreateLeaderboard(
            int     iLbType, 
            byte    bResetType, 
            int     iAttCount, 
            int     iMaxAttSize, 
            int     iDecayDays, 
            int     iMaxRatCount)
        {
            CreateLeaderboard(iLbType, bResetType, iAttCount, iMaxAttSize, iDecayDays, iMaxRatCount, "E", 0, 0, "", 
                false, false);
        }

        static public void ResetFrontDoor()
        {
            XrlRequest req = new XrlRequest();
            req.TargetVirtualInterface = VirtualInterface.xstatsfd_int;
            req.Path = "/xstats/xstatsreloaddbmap.ashx";
            req.AuthData = new HTTPAuthData().GetBase64EncodedString();
            uint hr = req.Send();
            
            Assert.AreEqual(hr, HResult.S_OK);
            
        }
        
        // CreateLeaderboard
        // Creates a new unitest leaderboard on the database
        static public void CreateLeaderboard(
            int     iLbType, 
            byte    bResetType, 
            int     iAttCount, 
            int     iMaxAttSize, 
            int     iDecayDays, 
            int     iMaxRatCount,
            string  eloE,
            int     eloK,
            int     eloNew,
            string  eloCtable,
            bool    fIsTeam,
            bool    fReqArbitration )
        {
            // Create in the config db
            SqlConnection sql = null;
            LbsvrClientConnection connection = null;
            
            try
            {
                sql = new SqlConnection("Server="+DvtConfig._configserver+";Database="+DvtConfig._configdb+
                    ";Integrated Security=true");
                 
                sql.Open();
                
                SqlCommand cmd = new SqlCommand("p_stats_lb_add", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@vc_server",      DvtConfig._lbsvrname);
                cmd.Parameters.AddWithValue("@i_title_id",     unchecked((Int32)DvtConstants.TitleId));
                cmd.Parameters.AddWithValue("@i_lb_id",        (Int32)iLbType);
                cmd.Parameters.AddWithValue("@i_reset_type",   (Int32)bResetType);
                cmd.Parameters.AddWithValue("@ti_top_100",     (Int32)(iMaxRatCount!=0 ? 1 : 0));
                cmd.Parameters.AddWithValue("@ti_team",        (Int32)(fIsTeam ? 1 : 0));
                cmd.Parameters.AddWithValue("@ti_req_arb",     (Int32)(fReqArbitration ? 1 : 0));
                cmd.Parameters.AddWithValue("@i_decay_days",   (Int32)iDecayDays);
                cmd.Parameters.AddWithValue("@c_Elo_E",        (string)eloE);
                cmd.Parameters.AddWithValue("@i_Elo_K",        (Int32)eloK);
                cmd.Parameters.AddWithValue("@i_Elo_New",      (Int32)eloNew);
                cmd.Parameters.AddWithValue("@vc_Elo_C_table", (string)eloCtable);
                cmd.Parameters.AddWithValue("@i_attach_count", (Int32)iAttCount);
                cmd.Parameters.AddWithValue("@i_max_attach_size", (Int32)iMaxAttSize);
                 
                cmd.ExecuteNonQuery();
                
                connection = LbsvrClientConnection.OpenConnection(
                    DvtConfig._lbsvraddr);
                    
                connection.BeginRequest(1);
                connection.CallProc(LbsvrClientConnection.LbProcIdLoadLb, new object[] {
                    unchecked((Int32)DvtConstants.TitleId),
                    (Int32)  iLbType
                });
                connection.SendRequest();
                
                DvtTestCase.Assert(!connection.NextRowset());
    
                ResetFrontDoor();
            }
            finally
            {
                if(sql != null)
                    sql.Close();
                
                if(connection != null)
                    connection.Close();
            }
        }
        
        static public void ConfigureTitle(uint uiTitleId, uint uiMaxWrites, uint uiMaxReads)
        {
            SqlConnection sql = null;

            try
            {
                sql = new SqlConnection("Server="+DvtConfig._configserver+";Database="+DvtConfig._configdb+
                    ";Integrated Security=true");
                 
                sql.Open();
                
                SqlCommand cmd = new SqlCommand("p_stats_title_set_limits", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@i_title_id",     unchecked((Int32)DvtConstants.TitleId));
                cmd.Parameters.AddWithValue("@i_max_writes",   (Int32) uiMaxWrites);
                cmd.Parameters.AddWithValue("@i_max_reads",    (Int32) uiMaxReads);
                cmd.ExecuteNonQuery();
            }
            finally
            {
                if(sql != null)
                    sql.Close();
            }
            
            ResetFrontDoor();
        }
        
        // Reset
        // Deletes all unitest leaderboards from the database
        static public void Reset()
        {
            SqlConnection sql = null;
            LbsvrClientConnection connection = null;
            
            try
            {

                // Delete data from leaderboard server
            
                connection = LbsvrClientConnection.OpenConnection(
                    DvtConfig._lbsvraddr);
                    
                connection.BeginRequest(1);
                connection.CallProc(LbsvrClientConnection.LbProcIdDeleteTitle, new object[] {
                    unchecked((Int32)DvtConstants.TitleId)
                });
                connection.SendRequest();
                
                DvtTestCase.Assert(!connection.NextRowset());

                // delete data from config database
            
                sql = new SqlConnection("Server="+DvtConfig._configserver+";Database="+DvtConfig._configdb+
                    ";Integrated Security=true");
                 
                sql.Open();
                
                SqlCommand cmd = new SqlCommand("p_stats_title_delete", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@i_title_id",  unchecked((Int32)DvtConstants.TitleId));
                
                cmd.ExecuteNonQuery();
            
                ResetFrontDoor();
            }
            finally
            {
                if(connection != null)
                    connection.Close();
                    
                if(sql != null)
                    sql.Close();
            }
            
        }
 
        // Reset
        // Deletes all unitest leaderboards from the database
        static public void ChangeLastWriteTime(int iLbType, int iDayDiff)
        {
            LbsvrClientConnection connection = null;
            
            try
            {
                connection = LbsvrClientConnection.OpenConnection(
                    DvtConfig._lbsvraddr);
                    
                connection.BeginRequest(1);
                connection.CallProc(LbsvrClientConnection.LbProcIdTestChangeLastUpdateTime, new object[] {
                    unchecked((Int32)DvtConstants.TitleId),
                    (Int32)iLbType,
                    (Int32)iDayDiff
                });
                connection.SendRequest();
            }
            finally
            {
                if(connection != null)
                    connection.Close();
            }
        }
        
        // Decay
        // Decay the test leaderboard
        static public void Decay(int iLbId)
        {
            LbsvrClientConnection connection = null;
            
            try
            {
                connection = LbsvrClientConnection.OpenConnection(
                    DvtConfig._lbsvraddr);
                    
                connection.BeginRequest(1);
                connection.CallProc(LbsvrClientConnection.LbProcIdTestAutoDecay, new object[] {
                    (Int64)DateTime.UtcNow.ToFileTimeUtc()
                });
                connection.SendRequest();
            }
            finally
            {
                if(connection != null)
                    connection.Close();
            }
        }

        static public void UnitsConfigureTitle(
            double  dDecayFactor,
            int     iMaxAvailUnits,
            int     iSizeUnitCache)
        {
            throw new Exception("Not implemented");
        }
        
        static public void UnitsConfigureLeaderboard(
            uint    uiUnitLbId,
            string  param )
        {
            throw new Exception("Not implemented");
        }        

        static public void CreateCompetitionPartition(
            uint    uiTitleId,
            byte    bPartition )
        {
            SqlConnection sql = null;
            
            try
            {
                sql = new SqlConnection("Server="+DvtConfig._configserver+";Database="+DvtConfig._configdb+
                    ";Integrated Security=true");
                 
                sql.Open();
                
                SqlCommand cmd = new SqlCommand("dbo.p_stats_competition_partition_add", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@vc_server"       , DvtConfig._lbsvrname);
                cmd.Parameters.AddWithValue("@i_title_id"      , unchecked((Int32)DvtConstants.TitleId));
                cmd.Parameters.AddWithValue("@i_comp_part_id"  , (int)bPartition);
                cmd.ExecuteNonQuery();
            
                ResetFrontDoor();
            }
            finally
            {
                if(sql != null)
                    sql.Close();
            }
        }        
        
        static public void CreateCompetitionTemplate(
            uint    uiTitleId,
            uint    uiTemplateId, 
            byte    bResetType, 
            int     iAttCount, 
            int     iMaxAttSize, 
            int     iDecayDays, 
            int     iMaxRatCount,
            string  eloE,
            int     eloK,
            int     eloNew,
            string  eloCtable,
            bool    fIsTeam,
            bool    fReqArbitration)
        {
            // Create in the config db
            SqlConnection sql = null;
            
            try
            {
                sql = new SqlConnection("Server="+DvtConfig._configserver+";Database="+DvtConfig._configdb+
                    ";Integrated Security=true");
                 
                sql.Open();
                
                SqlCommand cmd = new SqlCommand("dbo.p_stats_competition_template_add", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@i_title_id",     unchecked((Int32)DvtConstants.TitleId));
                cmd.Parameters.AddWithValue("@i_comp_templ_id",(Int32)uiTemplateId);
                cmd.Parameters.AddWithValue("@i_reset_type",   (Int32)bResetType);
                cmd.Parameters.AddWithValue("@ti_top_100",     (Int32)0);
                cmd.Parameters.AddWithValue("@ti_team",        (Int32)(fIsTeam ? 1 : 0));
                cmd.Parameters.AddWithValue("@ti_req_arb",     (Int32)(fReqArbitration ? 1 : 0));
                cmd.Parameters.AddWithValue("@i_decay_days",   (Int32)iDecayDays);
                cmd.Parameters.AddWithValue("@c_Elo_E",        (string)eloE);
                cmd.Parameters.AddWithValue("@i_Elo_K",        (Int32)eloK);
                cmd.Parameters.AddWithValue("@i_Elo_New",      (Int32)eloNew);
                cmd.Parameters.AddWithValue("@vc_Elo_C_table", (string)eloCtable);
                cmd.Parameters.AddWithValue("@i_attach_count", (Int32)iAttCount);
                cmd.Parameters.AddWithValue("@i_max_attach_size", (Int32)iMaxAttSize);
                 
                cmd.ExecuteNonQuery();
                
                ResetFrontDoor();
            }
            finally
            {
                if(sql != null)
                    sql.Close();
            }
        }
    }
    
    public class CMgmtCommand
	{
        public static string RunCommand(string target, string command)
        {
            TcpClient client = new TcpClient();
            string result = null;
            
            try
            {
                client.NoDelay = true;
                client.Connect(target, 4100);

                client.ReceiveTimeout = 10 * 1000;
                client.SendTimeout = 10 * 1000;

                NetworkStream stream = client.GetStream();
                StreamReader reader = new StreamReader(stream);

                if(stream.CanWrite && stream.CanRead)
                {
                    byte[] sendBytes = Encoding.ASCII.GetBytes(command);

                    stream.Write(sendBytes, 0, sendBytes.Length);

                    //  Second line is the response text, this is what we return
                    result = reader.ReadLine();
                    result = reader.ReadLine();
                }
                else
                    return null;
            }
            catch (Exception e)
            {
                result = "FAIL: " + e.Message;
            }
            finally
            {
                client.Close();
            }

            return result;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\common\xrl.cs ===
/*
 * StatsUnitest
 * xrl.cs
 * xrl request
*/

using System;
using System.Collections;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using xonline.common.service;

namespace xonline.server.stats.test.dvt 
{
    class XRLBundledAuth
    {
        public XRLBundledAuth(uint uiTitleId, ulong[] puids)
        {
            _uiTitleId  = uiTitleId;
            _puids      = puids;
        }
        
        public uint     _uiTitleId;
        public ulong[]  _puids;
    }
    
    // XRL
    // Handles XRL requests 
    class XRL
    {
        // SetSGSession
        // Sets the SGSession context object to be used on all AddSession requests originating from the same thread.
        static public void SetSGSession(SGSession session)
        {
            Thread.SetData(_currentSessionSlot, session);
        }
        
        static public void SetBundledAuth(XRLBundledAuth bundledAuth)
        {
            Thread.SetData(_bundledAuthSlot, bundledAuth);
        }
        
        static public void SetPort(int iPort)
        {
            Thread.SetData(_portSlot, (object)(ushort)iPort);
        }
        
        // Post
        // XRL post.
        public static uint Post(
            int serviceId, 
            string URL, 
            byte[] request, 
            out byte[] response)
        {
            Socket xrlSocket = null;
            response = null;
            uint hr = 0;
            IPEndPoint localEndPoint = null;

            // Parse URL
            string destHost;
            string destPort;
            string destPath;
            
            Match match = _urlParser.Match(URL);

            if(match.Groups.Count == 0)
            {
                throw new Exception("URL " + URL + " is invalid.");
            }

            destHost = match.Groups["host"].Value;
            destPort = match.Groups["port"].Value;
            destPath = match.Groups["path"].Value;            

            // Dest port
            ushort usPort;
            
            if(destPort.Length > 0)
            {
                usPort = Convert.ToUInt16(destPort, 10);
            }
            else
            {
                object port = Thread.GetData(_portSlot);
                
                if(port != null)
                {
                    usPort = (ushort) port;
                }
                else
                {
                    usPort = (ushort) DvtConfig._iInternetPort;
                }
            }
            
            // Resolve host name
            IPHostEntry hostEntry = Dns.GetHostEntry(destHost);
            IPEndPoint destEndPoint = new IPEndPoint(hostEntry.AddressList[0], usPort);
            
            try
            {
                // Create the xrlSocket and bind it to one of the available dynamic ports
                localEndPoint = new IPEndPoint(0, 0);
                xrlSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                xrlSocket.Bind(localEndPoint);

#if false // not working
                // Don't linger
                LingerOption lingerOption = new LingerOption(true, 10);
                xrlSocket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.Linger, lingerOption);
#endif

                // Build bundled auth header
                string bundledAuthHeader;
                XRLBundledAuth bundledAuth = (XRLBundledAuth) Thread.GetData(_bundledAuthSlot);
                
                if(bundledAuth != null)
                {   
                    XUIDAndTrust[] xuidAndTrust = new XUIDAndTrust[bundledAuth._puids.Length];
                    
                    for(int i=0; i < xuidAndTrust.Length && i < bundledAuth._puids.Length; i++)
                    {
                        xuidAndTrust[i] = new XUIDAndTrust(bundledAuth._puids[i], 0, 0.0f);
                    }
                    
                    BundledAuthData bundledAuthData = new BundledAuthData(bundledAuth._uiTitleId, xuidAndTrust);
                    bundledAuthHeader = XHttpHdr.BUNDLEDAUTHDATA + ":" + 
                        bundledAuthData.GetBase64EncodedString() + "\r\n";
                }
                else
                {
                    bundledAuthHeader = String.Empty;
                }
                
                // build request header
                string serviceHeader = 
                    "POST "+destPath+" HTTP/1.0\r\n" + 
                    "User-Agent: "+serviceId+"/1.0.0\r\n" +
                    "Content-Type: xon/"+serviceId+"\r\n" +
                    bundledAuthHeader +
                    "Content-Length: "+request.Length+"\r\n" +
                    "\r\n";

                // Connect 
                xrlSocket.Connect(destEndPoint);

                // Prepare auth
                SGSession session = (SGSession) Thread.GetData(_currentSessionSlot);
                
                if(session != null)
                {
                    localEndPoint = (IPEndPoint) xrlSocket.LocalEndPoint;
                    SGAuth.AddSession(localEndPoint, session);
                }
                else
                {
                    localEndPoint = null;
                }
                
                // Send request                
                xrlSocket.Send(Encoding.ASCII.GetBytes(serviceHeader));
                xrlSocket.Send(request);

                // Read the response
                int iWrittenResponse = 0;
                int iContentLength = 0;
                string responseHeader = String.Empty;
                byte[] responseBuffer = new Byte[2048];
                
                while(response == null || iWrittenResponse < iContentLength)
                {
                    // Any data available?
                    if(xrlSocket.Poll(100000, SelectMode.SelectRead))
                    {
                        int iReceived = xrlSocket.Receive(responseBuffer);
                        
                        // If response is null, then we're still parsing the http header
                        if(response == null)
                        {
                            // Add recently written buffer to header
                            responseHeader += Encoding.ASCII.GetString(responseBuffer, 0, iReceived);
                            
                            // Did we read the entire header?
                            int endOfHeader = responseHeader.IndexOf("\r\n\r\n");

                            if(endOfHeader == -1)
                                throw new Exception(
                                    "Failed to parse http response header. Can't find CRLF last pairs.");

                            endOfHeader += 4;
                            
                            // Parse the header. First the status.
                            match = _regexHTTPStatus.Match(responseHeader);
                            
                            if(! match.Success)
                                throw new Exception("Failed to parse http response header. "+
                                    "Failed part: status. Http header:\n"+responseHeader);

                            int status = Convert.ToInt32((string)match.Groups["status"].Value, 10);
                            
                            // X-Err
                            match = _regexXErr.Match(responseHeader);

                            if(match.Success)
                                hr = HResult.Parse((string)match.Groups["xerr"].Value);

                            if(status != 200 && HResult.Succeeded(hr))
                                hr = HResult.E_FAIL;

                            // Content-lenth
                            match = _regexContentLength.Match(responseHeader);
                            
                            if(match.Success)
                                iContentLength = Convert.ToInt32(match.Groups["len"].Value);
                            else
                                iContentLength = 0;

                            // Allocate response 
                            response = new byte[iContentLength];
                            Array.Copy(responseBuffer, endOfHeader, response, 0, iReceived - endOfHeader);
                            iWrittenResponse = iReceived - endOfHeader;
                        }
                        else
                        {
                            // Copy more of the response
                            Array.Copy(responseBuffer, 0, response, iWrittenResponse, iReceived);
                            iWrittenResponse += iReceived;
                        }
                    }
                }

                xrlSocket.Shutdown(SocketShutdown.Both);
            }
            finally
            {
                if(xrlSocket != null)
                {
                    xrlSocket.Close();
                    xrlSocket = null;
                }

                if(localEndPoint != null)
                {
                    SGAuth.DropSession(localEndPoint);
                }
            }

            return hr;
        }

        private static LocalDataStoreSlot   _currentSessionSlot = Thread.AllocateDataSlot();
        private static LocalDataStoreSlot   _portSlot           = Thread.AllocateDataSlot();
        private static LocalDataStoreSlot   _bundledAuthSlot    = Thread.AllocateDataSlot();
        private static Regex                _urlParser          = new Regex(@"http:\/\/(?<host>[\w-\.]+)(:(?<port>\d+))?(?<path>\/.*)?", RegexOptions.Compiled);
        private static Regex                _regexHTTPStatus    = new Regex(@"HTTP\/(?<httpver>\d+.\d+)\s(?<status>\d+)\s\w+.*", RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.Multiline);
        private static Regex                _regexXErr          = new Regex(@"^X-Err: (?<xerr>[A-Za-z0-9]+)", RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.Multiline);
        private static Regex                _regexContentLength = new Regex(@"^Content-Length: (?<len>\d+)", RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.Multiline);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\common\tc.cs ===
/*
 * StatsUnitest
 * xrl.cs
 * Test case base classes
*/

using System;
using System.Collections;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;

namespace xonline.server.stats.test.dvt 
{
    // DvtTestCaseAttribute
    // Attribute to decorate DvtTestCase derived classes
    [AttributeUsage(AttributeTargets.Class)]
    class DvtTestCaseAttribute : Attribute
    {
        public DvtTestCaseAttribute(string name, string description)
        {
            _name           = name;
            _description    = description;
        }
        
        public Type Initializer
        {
            get { return _initializer; }
            set { _initializer = value; }
        }

        public string _name;
        public string _description;
        public Type   _initializer  = null;
    }
    
    // DvtTestCaseInitializer
    // base class for classes that do initialization work for other test cases
    abstract class DvtTestCaseInitializer
    {
        public abstract void Run();
    }
    
    // DvtTestCase
    // base class for test cases. 
    abstract class DvtTestCase
    {
        public DvtTestCase()
        {
            // Get attribute of test case
            DvtTestCaseAttribute DvtTestCaseInfo = (DvtTestCaseAttribute) this.GetType().GetCustomAttributes(
                typeof(DvtTestCaseAttribute), false)[0] as DvtTestCaseAttribute;

            _name           = DvtTestCaseInfo._name.ToLower();
            _description    = DvtTestCaseInfo._description;
            _initializer    = DvtTestCaseInfo._initializer;
        }

        public abstract void Run();

        public string Name
        {
            get { return _name; }
        }

        public Type Initializer
        {
            get { return _initializer; }
        }

        static public void Assert(bool fAssert)
        {
            if(!fAssert)
                throw new DvtTestCaseException("Assert failed");
        }

        protected string    _name;
        protected string    _description;
        protected Type      _initializer;
    }

    // DvtTestCaseDatabase
    // Provides a way to catalog, search and execute test cases
    class DvtTestCaseDatabase
    {
        public DvtTestCaseDatabase()
        {
            // Add all test cases in the assembly to the database
            Type[] allTypes = Assembly.GetExecutingAssembly().GetTypes();

            foreach( Type t in allTypes )
            {
                if( t.IsSubclassOf(typeof(DvtTestCase)) 
                    && t != typeof(DvtTestCase) )
                {
                    DvtTestCaseAttribute DvtTestCaseInfo = (DvtTestCaseAttribute) t.GetCustomAttributes(
                        typeof(DvtTestCaseAttribute), false)[0] as DvtTestCaseAttribute;

                    string DvtTestCaseName = DvtTestCaseInfo._name.ToLower();
                    
                    // check name
                    if(!_regexIsValidDvtTestCaseMask.Match(DvtTestCaseName).Success)
                        throw new Exception("test case " + DvtTestCaseName + " is invalid.");

                    // Add it to test case database
                    _DvtTestCaseList.Add(new DictionaryEntry(DvtTestCaseName, t));
                }
            }
        }
        
        // GetDvtTestCases
        // Returns an array of instances of DvtTestCases that match the mask parameters
        public DvtTestCase[] GetDvtTestCases(string mask)
        {
            mask = mask.ToLower();

            if(!_regexIsValidDvtTestCaseMask.Match(mask).Success)
                throw new Exception("Invalid test case mask: " + mask);

            // transform mask into a valid regular expression
            mask = mask.Replace(".", "\\.");
            mask = mask.Replace("-", "\\-");
            mask = mask.Replace("*", ".*");
            mask = "^" + mask + "$";
            Regex regexMask = new Regex(mask, 0);

            // Store all cases that match in this caseList.
            ArrayList caseList = new ArrayList(_DvtTestCaseList.Count);
            foreach(DictionaryEntry entry in _DvtTestCaseList)
            {
                if(regexMask.Match((string)entry.Key).Success)
                    caseList.Add(((Type)entry.Value).GetConstructor(Type.EmptyTypes).Invoke(null));
            }
            
            return (DvtTestCase[])caseList.ToArray(typeof(DvtTestCase));
        }

        // GetDvtTestCaseNames
        // Returns an array with all the test case names
        public string[] GetDvtTestCaseNames()
        {
            string[] caseNames = new string[_DvtTestCaseList.Count];
            
            for(int ndx=0; ndx < caseNames.Length; ndx++)
            {
                caseNames[ndx] = (string)(((DictionaryEntry)_DvtTestCaseList[ndx]).Key);
            }

            return caseNames;
        }

        private         ArrayList   _DvtTestCaseList               = new ArrayList(100);
        static private  Regex       _regexIsValidDvtTestCaseName   = new Regex(@"^(?:[A-Za-z0-9\-_]+\.?)+$", RegexOptions.Compiled);
        static private  Regex       _regexIsValidDvtTestCaseMask   = new Regex(@"^(?:[A-Za-z0-9\-\*_]+\.?)+$", RegexOptions.Compiled);
    }

    // DvtTestCaseException
    // Exception used on test case failures.
    class DvtTestCaseException : Exception
    {
        public DvtTestCaseException(string message) : base(message)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\common\sim.cs ===
/*
 * StatsUnitest
 * tcAttach.cs
 * StatSet test cases
*/

using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.stats.common;

namespace xonline.server.stats.test.dvt 
{
    // LbSimulator
    // Simulates the data arrangement at the same time it makes the requests 
    // to the service. Then it compares the simulated results with the results 
    // from the service.
    class LbSimulator : StatIMDb
    {
        public void Write(MsgSetData[] msgs)
        {
            // In order to achieve exactness in the simulation we've got to also simulate the order in which the 
            // front-door is going to process the messages. We'll use a hashtable for that.
            Hashtable orderedMsgs = new Hashtable(msgs.Length);
            foreach(MsgSetData msg in msgs)
            {
                LbUserKey lbUserKey = new LbUserKey(msg._uiLbId, msg._ulUserId);
                ArrayList msgList = (ArrayList) orderedMsgs[lbUserKey];
                if(msgList == null)
                {
                    msgList = new ArrayList(1);
                    orderedMsgs[lbUserKey] = msgList;
                }
                msgList.Add(msg);
            }
            
            // Now we should be ready to process the messages
            IStatDbStatUpdate update = CreateStatUpdate(msgs[0]._uiTitleId, DateTime.Now, false);
            
            foreach(ArrayList msgList in orderedMsgs.Values)
            {
                foreach(MsgSetData msg in msgList)
                {
                    LbUserKey lbUserKey = new LbUserKey(msg._uiLbId, msg._ulUserId);
                    update.PlayerLbStart(lbUserKey);
                    
                    foreach(MsgAttribData msgAttribData in msg._attribs)
                    {
                        update.PlayerUpdateStat(msgAttribData._usAttrId, msgAttribData._value);
                    }
                }
            }
                
            update.Process(null);
                
        }

        public void StatPost(ReqStatPost req)
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter(ms);
            req.WriteTo(bw);
            
            StatPost statPost = new StatPost(
                (IStatIO) new UtStatIO(ms),
                (IStatDb)this, 
                null);
                
            statPost.ParseRequest();
            statPost.Process();
            statPost.SendResponse();

            XRLPostStatPost xrl = new XRLPostStatPost(req);
            xrl.Post();

            DvtTestCase.Assert(xrl._hr == HResult.S_OK);
        }

        public void Verify()
        {
            VerifyStatGet();
            VerifyUnitGet();
            VerifyUnitEnum();
        }
        
        public void VerifyStatGet()
        {
            foreach(PlayerLb playerLb in _playerLbs.Values)
            {
                ArrayList lbEntries = new ArrayList(playerLb._lbEntries.Values);
                
                // Verify rows in chunks of 101
                for(int iLbEntryNdx = 0; iLbEntryNdx < lbEntries.Count; iLbEntryNdx+= 101)
                {
                    int iChunkSize = Math.Min(101, lbEntries.Count - iLbEntryNdx);
                    
                    VerifyStatGetChunk(playerLb, lbEntries.GetRange(iLbEntryNdx, iChunkSize));                    
                }
            }
        }
        
        protected void VerifyStatGetChunk(PlayerLb playerLb, ArrayList lbEntries)
        {
            // Prepare ReqGetData
            ReqGetData req = new ReqGetData();
            req._messages = new MsgGetData[lbEntries.Count];
            int iMsgNdx = 0;
            foreach(PlayerLbEntry lbEntry in lbEntries)
            {
                MsgGetData msgGetData = new MsgGetData();
                msgGetData._uiTitleId = playerLb._uiTitleId;
                msgGetData._uiLbId = playerLb._uiLbId;
                msgGetData._ulUserId = lbEntry._ulUserId;
                msgGetData._attrIds = new ushort[lbEntry._stats.Count + 1];
                lbEntry._stats.Keys.CopyTo(msgGetData._attrIds, 1);
                msgGetData._attrIds[0] = SpecialAttrib.Rank;
                
                req._messages[iMsgNdx++] = msgGetData;
            }
            
            // Send it to front-door
            ReqStatRead xrl = new ReqStatRead(req._messages);
            xrl.Post();
            DvtTestCase.Assert(xrl._hr == HResult.S_OK);
                        
            // Verify response
            DvtTestCase.Assert(xrl._reps.Length == req._messages.Length);
            
            for(int i=0; i < xrl._reps.Length; i++)
            {
                MsgGetData msg = req._messages[i];
                MsgRepGetData rep = xrl._reps[i];
                
                DvtTestCase.Assert(rep._uiLbId == msg._uiLbId);
                DvtTestCase.Assert(rep._ulUserId == msg._ulUserId);
                DvtTestCase.Assert(rep._attribs.Length == msg._attrIds.Length);
                
                for(int iStatNdx=0; iStatNdx < rep._attribs.Length; iStatNdx++)
                {
                    MsgAttribData stat = rep._attribs[iStatNdx];
                    
                    DvtTestCase.Assert(stat._usAttrId == msg._attrIds[iStatNdx]);
                    
                    if(stat._bAttrType == (byte) AttrType.None)
                    {
                        DvtTestCase.Assert(GetPlayerStat(playerLb._uiTitleId, rep._uiLbId, rep._ulUserId, stat._usAttrId)==null);
                    }
                    else
                    {
                        DvtTestCase.Assert(stat._value.Equals(
                            GetPlayerStat(playerLb._uiTitleId, rep._uiLbId, rep._ulUserId, stat._usAttrId)));
                    }                        
                }
            }
        }

        protected void VerifyUnitGet()
        {
            foreach(UnitTitle unitTitle in this._unitTitles.Values)
            {
                foreach(Unit unit in unitTitle._units.Values)
                {
                    // Build unit get request for all stats in the imdb
                    ArrayList specs = new ArrayList();
                    foreach(UnitLb unitLb in unit._unitLbs.Values)
                    {
                        ArrayList statIds = new ArrayList();

                        foreach(DictionaryEntry statDicEntry in unitLb._stats)
                        {
                            statIds.Add((ushort)statDicEntry.Key);
                        }
                        
                        statIds.Add(SpecialAttrib.Rating);

                        MsgUnitStatGetSpec spec = new MsgUnitStatGetSpec();
                        spec._uiLbId = unitLb._uiUnitLbId;
                        spec._statIds = (ushort[]) statIds.ToArray(typeof(ushort));
                        spec._usNumStats = (ushort) spec._statIds.Length;

                        specs.Add(spec);
                    }
                    
                    // Get data from the front-door
                    ReqStatUnitGet req = MessageWrapper.ToReqStatUnitGet(DvtConstants.TitleId,
                        unit._members, (MsgUnitStatGetSpec[]) specs.ToArray(typeof(MsgUnitStatGetSpec)));
                    XRLPostStatUnitGet xrl = new XRLPostStatUnitGet(req);
                    xrl.Post();
                    
                    // Compare results with imdb
                    DvtTestCase.Assert(xrl._hr == HResult.S_OK);
                    DvtTestCase.Assert(xrl._rep._usSpecCount == xrl._req._usSpecCount);
                    for(int iSpecNdx=0; iSpecNdx < req._specs.Length; iSpecNdx++)
                    {
                        MsgUnitStatGetSpecData repspec = xrl._rep._specs[iSpecNdx];
                        MsgUnitStatGetSpec     reqspec = xrl._req._specs[iSpecNdx];
                        
                        DvtTestCase.Assert(repspec._uiLbId == reqspec._uiLbId);
                        DvtTestCase.Assert(repspec._usNumStats == reqspec._usNumStats);

                        for(int iStatNdx=0; iStatNdx < repspec._usNumStats; iStatNdx++)
                        {
                            DvtTestCase.Assert(repspec._stats[iStatNdx]._usAttrId == reqspec._statIds[iStatNdx]);
                            DvtTestCase.Assert(repspec._stats[iStatNdx]._value.Equals(
                                this.GetUnitStat(DvtConstants.TitleId, unit._members, 
                                repspec._uiLbId, repspec._stats[iStatNdx]._usAttrId)));
                        }
                    }
                }
            }
        }


        protected void VerifyUnitEnum()
        {
            // For each title 
            foreach(UnitTitle title in this._unitTitles.Values)
            {
                // Build hashtable with leaderboard ids
                // Build hashtable with stat ids
                Hashtable lbIdsTable = new Hashtable();
                Hashtable statIdsTable = new Hashtable();
                foreach(Unit unit in title._units.Values)
                {
                    foreach(UnitLb lb in unit._unitLbs.Values)
                    {
                        lbIdsTable[lb._uiUnitLbId] = true;

                        foreach(ushort usStatId in lb._stats.Keys)
                        {
                            statIdsTable[usStatId] = true;
                        }
                    }
                }

                statIdsTable[(ushort)SpecialAttrib.Rating] = true;

                // Transform hashtables into arrays
                uint[] lbIds = new uint[lbIdsTable.Count];
                lbIdsTable.Keys.CopyTo(lbIds, 0);
                ushort[] statIds = new ushort[statIdsTable.Count];
                statIdsTable.Keys.CopyTo(statIds, 0);

                // foreach user
                foreach(ulong ulPuid in title._users.Keys)
                {
                    // for each leaderboard id
                    foreach(uint uiLbId in lbIds)
                    {
                        StatDbUnitEnumOrder[] dbEnumOrder   = new StatDbUnitEnumOrder[] { StatDbUnitEnumOrder.Activity, StatDbUnitEnumOrder.Rating };
                        uint[] enumOrder                    = new uint[] { UnitEnumFlags.SortActivity, UnitEnumFlags.SortRating };
                        
                        for(int iOrderType=0; iOrderType < 2; iOrderType++)
                        {
                            // build unit enum request for all attributes in attribute array
                            ReqUnitEnum req = MessageWrapper.ToReqUnitEnum(
                                title._uiTitleId, uiLbId, enumOrder[iOrderType],
                                ulPuid, (ushort) (title._uiMaxAvailUnits + title._uiSizeUnitCache),
                                statIds);

                            // send enum request to front door and get a response
                            XRLPostUnitEnum xrl = new XRLPostUnitEnum(req);
                            xrl.Post();
                            DvtTestCase.Assert(xrl._hr == HResult.S_OK);

                            // process enum request using statimdb
                            UnitEnumCallback cb = new UnitEnumCallback(req);
                            this.UnitEnum(req._uiTitleId, req._ulPuid, req._uiLbId, req._usPageSize, 
                                dbEnumOrder[iOrderType], req._statIds, cb, false);
                            cb.PrepareReply();

                            // compare the two responses
                            RepUnitEnum rep1 = xrl._rep;
                            RepUnitEnum rep2 = cb._rep;

                            DvtTestCase.Assert(rep1._usNumEntries == rep2._usNumEntries);
                            
                            for(int iEntry=0; iEntry < rep1._usNumEntries; iEntry++)
                            {
                                MsgUnitEnumEntry entry1 = rep1._entries[iEntry];
                                MsgUnitEnumEntry entry2 = rep2._entries[iEntry];
                                
                                DvtTestCase.Assert(entry1._puid1          == entry2._puid1);
                                DvtTestCase.Assert(entry1._puid2          == entry2._puid2);
                                DvtTestCase.Assert(entry1._puid3          == entry2._puid3);
                                DvtTestCase.Assert(entry1._puid4          == entry2._puid4);
                                DvtTestCase.Assert(entry1._usStatCount    == entry2._usStatCount);
                                
                                for(int iStat=0; iStat < entry1._usStatCount; iStat++)
                                {
                                    DvtTestCase.Assert(entry1._stats[iStat]._usAttrId == entry2._stats[iStat]._usAttrId);
                                    DvtTestCase.Assert(entry1._stats[iStat]._bAttrType == entry2._stats[iStat]._bAttrType);
                                    
                                    if(entry1._stats[iStat]._value != null)
                                        DvtTestCase.Assert(entry1._stats[iStat]._value.Equals(entry2._stats[iStat]._value));
                                    else
                                        DvtTestCase.Assert(entry1._stats[iStat]._value == entry2._stats[iStat]._value);
                                }
                            }
                        }
                    }
                }
            }
        }

        public void VerifyPlayerStat(uint uiTitleId, uint uiLbId, ulong ulUserId, ushort usStatId, object val)
        {
            object val2 = GetPlayerStat(uiTitleId, uiLbId, ulUserId, usStatId);
            
            if( (val != null && val2 != null && !val.Equals(val2)) 
                || (val != null && val2 == null) 
                || (val == null && val2 != null) )
            {
                throw new DvtTestCaseException("ASSERT FAILED: stat value not expected. "+
                    "\nuiTitleId="+uiTitleId.ToString("x")+
                    "\nuiLbId="+uiLbId+
                    "\nusStatId="+usStatId+
                    "\nval="+(val != null ? val.ToString() : "(null)")+
                    "\nval2="+(val2 != null ? val2.ToString() : "(null)") );
            }
        }

        public void VerifyUnitStat(uint uiTitleId, uint uiLbId, ulong[] members, ushort usStatId, object val)
        {
            object val2 = GetUnitStat(uiTitleId, members, uiLbId, usStatId);
            
            if( (val != null && val2 != null && !val.Equals(val2)) 
                || (val != null && val2 == null) 
                || (val == null && val2 != null) )
            {
                throw new DvtTestCaseException("ASSERT FAILED: stat value not expected. "+
                    "\nuiTitleId="+uiTitleId.ToString("x")+
                    "\nuiLbId="+uiLbId+
                    "\nusStatId="+usStatId+
                    "\nval="+(val != null ? val.ToString() : "(null)")+
                    "\nval2="+(val2 != null ? val2.ToString() : "(null)") );
            }
        }
          
        protected class UtStatIO : IStatIO
        {
            public UtStatIO(Stream inputStream)
            {
                _hr = HResult.S_OK;
                _inputStream = inputStream;
                _inputStream.Seek(0, SeekOrigin.Begin);
            }
            
            public Stream InputStream
            {
                get { return _inputStream; }
            }
            
            public Stream OutputStream 
            {
                get { return _outputStream; }
            }

            public HttpResponse Response
            {
                get { return null; }
            }
            
            public void SetXErr(uint uiTitleId, uint hr)
            {
                _hr = hr;
            }
            
            public uint _hr;
            public Stream _inputStream;
            public Stream _outputStream = (Stream) new MemoryStream();
        }
        
        protected class UnitEnumCallback : IStatDbUnitEnumCallback
        {
            public UnitEnumCallback(ReqUnitEnum req)
            {
                _req = req;
                _entries = new ArrayList(_req._usPageSize);
            }
            
            public void PrepareReply()
            {
                if(_currentRow != null)
                    ReconcileStats();

                _rep._entries = (MsgUnitEnumEntry[]) _entries.ToArray(typeof(MsgUnitEnumEntry));
                _rep._usNumEntries = (ushort) _rep._entries.Length;
            }

            public void OnNewRow(ulong[] members, string[] names, long lRating)
            {
                if(_currentRow != null)
                    ReconcileStats();
                
                _currentRow = new MsgUnitEnumEntry();
                if(members.Length >= 1)
                {
                    _currentRow._puid1 = members[0];
                    _currentRow._name1 = names[0];
                }
                if(members.Length >= 2)
                {
                    _currentRow._puid2 = members[1];
                    _currentRow._name2 = names[1];
                }
                if(members.Length >= 3)
                {
                    _currentRow._puid3 = members[2];
                    _currentRow._name3 = names[2];
                }
                if(members.Length >= 4)
                {
                    _currentRow._puid4 = members[3];
                    _currentRow._name4 = names[3];
                }
                
                _currentRow._usStatCount = _req._usStatCount;
                _currentRow._stats = new MsgAttribData[_currentRow._usStatCount];

                for(int i=0; i < _currentRow._usStatCount; i++)
                {
                    _currentRow._stats[i] = new MsgAttribData();
                    _currentRow._stats[i]._usAttrId = _req._statIds[i];
                }

                _stats[SpecialAttrib.Rating] = lRating;
            }

            public void OnAttribute(ushort usStatId, object val)
            {
                _stats[usStatId] = val;
            }

            protected void ReconcileStats()
            {
                for(ushort i=0; i < _currentRow._usStatCount; i++)
                {
                    object val = _stats[_currentRow._stats[i]._usAttrId];

                    if(val != null)
                    {
                        if(val is int)
                        {
                            _currentRow._stats[i]._bAttrType = (byte) AttrType.Long;
                            _currentRow._stats[i]._value = val;
                        }
                        else if (val is long)
                        {
                            _currentRow._stats[i]._bAttrType = (byte) AttrType.LongLong;
                            _currentRow._stats[i]._value = val;
                        }
                        else if (val is double)
                        {
                            _currentRow._stats[i]._bAttrType = (byte) AttrType.Double;
                            _currentRow._stats[i]._value = val;
                        }
                        else
                            throw new Exception("ASSERT FAILED: invalid type");
                    }
                }

                _entries.Add(_currentRow);
                _currentRow = null;
            }

            public ReqUnitEnum      _req;
            public RepUnitEnum      _rep             = new RepUnitEnum();
            public MsgUnitEnumEntry _currentRow;
            public Hashtable        _stats           = new Hashtable();
            public ArrayList        _entries;
        }

        private Hashtable   _lbs = new Hashtable();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\common\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__common_3_none_12.4.56.0_none_2758e45a43f77aac
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_common_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.manifest
XP_MANIFEST_PATH=manifests\x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.cat
XP_CATALOG_PATH=manifests\x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.cat
XP_PAYLOAD_PATH=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_common_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\common\sgauth.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Reflection;
using System.Threading;

namespace xonline.server.stats.test.dvt 
{
    // SGSession
    // Pass it to SGAuth so it knows what to simulate
    class SGSession
    {
        public SGSession(ulong ulMachineId, ulong[] users)
        {
            Debug.Assert(users != null && users.Length >= 1 && users.Length <= 4);
            _ulMachineId = ulMachineId;

            for(int ndx=0; ndx < users.Length; ndx++)
                _users[ndx] = users[ndx];
        }
        
        public uint     _uiTitleId      = DvtConstants.TitleId;
        public ulong    _ulMachineId;
        public ulong[]  _users = new ulong[4];
        public ulong    _fileTimeSessionStarted = (ulong) DateTime.Now.AddMinutes(5).ToFileTime();
    }
    
    // SGAuth
    // Handles SG auth stuff 
    class SGAuth
    {
        private const ushort sgMessagePort = 0xFFFF;
            // That's where SG receives UDP messages
        
        // Start
        // Start the auth thread. Call it at the beginning of the app.
        static public void Start()
        {
            _authThread = new Thread(new ThreadStart((new SGAuth()).AuthThread));
            _authThread.Name = "Auth thread";
            _authThread.Start();
        }
        
        // Shutdown
        // Stop the auth thread and do clean up. Call it at the end of the app.
        static public void Shutdown()
        {
            if(_authThread != null)
            {
                // Signal auth thread to stop
                _fShutdown = true;
                
                // Wait until it finishes
                while(_authThread.IsAlive)
                {
                    Thread.Sleep(500);
                }
            }
        }

        // AddSession
        // Add a session to the list of stuff to be simulated
        static public void AddSession(IPEndPoint endPoint, SGSession session)
        {
            _sessionTable.Add(endPoint, session);
        }

        // DropSession
        // Drop a session from the list
        static public void DropSession(IPEndPoint endPoint)
        {
            _sessionTable.Remove(endPoint);
        }

        // AuthThread
        // Does the real work
        private void AuthThread()
        {
            byte[] authStuff = new Byte[4096];
            Socket authSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            authSocket.Bind(new IPEndPoint(0, sgMessagePort));
            EndPoint endPointRequester = new IPEndPoint(0, 0);            
            
            while(!_fShutdown)
            {
                if(!authSocket.Poll(500000, SelectMode.SelectRead))
                {
                    continue;
                }
                
                int iSize = authSocket.ReceiveFrom(authStuff, ref endPointRequester);
                MemoryStream memStream = new MemoryStream(authStuff, 0, iSize);
                BinaryReader reader = new BinaryReader(memStream);

                // Read message header
                SGMsgHdr hdr = new SGMsgHdr();
                hdr.ReadFrom(reader);

                if(hdr._wType != SGMsgHdr.SGMSG_TYPE_SPIDATA_REQ2)
                {
                    throw new Exception("Invalid SG message type " + hdr._wType);
                }
                
                // Read SPI request
                SGMsgSpiReq2 spiReq = new SGMsgSpiReq2();
                spiReq.ReadFrom(reader);

                // Look for the session
                IPEndPoint sessionEndPoint = new IPEndPoint(spiReq._ipaZ, IPAddress.NetworkToHostOrder((short)spiReq._ipportZ));
                SGSession session = (SGSession) _sessionTable[sessionEndPoint];
                
                // Prepare to send reply
                memStream = new MemoryStream(authStuff);
                BinaryWriter writer = new BinaryWriter(memStream);

                // SPI reply
                SGMsgSpiRep2 spiRep = new SGMsgSpiRep2();
                hdr._wType                  = SGMsgHdr.SGMSG_TYPE_SPIDATA_REP2;
                hdr._cbEnt                  = (ushort) (SGMsgHdr.Size + SGMsgSpiRep2.Size);
                hdr.WriteTo(writer);
                spiRep._dwReqNum            = spiReq._dwReqNum;
                spiRep._ipaZ                = spiReq._ipaZ;
                spiRep._ipportZ             = spiReq._ipportZ;
                spiRep._fNotFound           = (byte) (session != null ? 0 : 1);
                spiRep.WriteTo(writer);

                if(session != null)
                {
                    // SPI data
                    hdr._wType                  = SGMsgHdr.SGMSG_TYPE_SPIDATA2;
                    hdr._cbEnt                  = (ushort) (SGMsgHdr.Size + SGMsgSpiData2.Size);
                    hdr.WriteTo(writer);
                    
                    SGMsgSpiData2 spiData       = new SGMsgSpiData2();
                    spiData._ipportI            = 0;
                    spiData._ipaI               = 0;
                    spiData._sgaddr             = new byte[20];
                    spiData._wVersionKeyEx      = 1;
                    spiData._wFlagsKeyEx        = 1;
                    spiData._liNonce            = 123;
                    spiData._liTimeInit         = (ulong) session._fileTimeSessionStarted;
                    spiData._fCs                = 1;
                    spiData.WriteTo(writer);  
                    
                    hdr._wType                  = SGMsgHdr.SGMSG_TYPE_AUTHDATA2;
                    hdr._cbEnt                  = SGAuthData3.Size;
                    hdr.WriteTo(writer);
                    
                    SGAuthData3 authdata        = new SGAuthData3();
                    authdata._dwTitleID         = session._uiTitleId;
                    authdata._qwXboxID          = session._ulMachineId;
                    authdata._users[0]._userId  = session._users[0];
                    authdata._users[1]._userId  = session._users[1];
                    authdata._users[2]._userId  = session._users[2];
                    authdata._users[3]._userId  = session._users[3];
                    authdata.WriteTo(writer);
                }
                
                authSocket.SendTo(memStream.ToArray(), endPointRequester);
            }
        }
        
        private static Thread               _authThread         = null;
        private static bool                 _fShutdown          = false;
        private static Hashtable            _sessionTable       = new Hashtable();
    }

    // *** SG Protocol stuff ***
    
    // SGMsgHdr
    // SG message header 
    class SGMsgHdr 
    {
        public const int    Size                    = 4;

        public const int    SGMSG_TYPE_SPIDATA_REQ2 = 0x4710;  // CSgMsgSpiReq2
        public const int    SGMSG_TYPE_SPIDATA_REP2 = 0x4711;  // CSgMsgSpiRep2
        public const int    SGMSG_TYPE_SPIDATA2     = 0x4782;  // CSgMsgSpiData2 in the payload
        public const int    SGMSG_TYPE_AUTHDATA2    = 0x4783;  // SGAuthData2
    
        public ushort       _wType = 0;
        public ushort       _cbEnt = 0;

        public void ReadFrom(BinaryReader reader)
        {
            _wType = reader.ReadUInt16();
            _cbEnt = reader.ReadUInt16();
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_wType);
            writer.Write(_cbEnt);
        }
    }

    // SGMsgSpiReq
    // SPI request
    class SGMsgSpiReq2
    {
        public const int    Size                    = 10;

        public uint         _dwReqNum               = 0;        // Request number from requester
        public uint         _ipaZ                   = 0;        // IP address of the client on the DMZ
        public ushort       _ipportZ                = 0;        // IP port of the client on the DMZ

        public void ReadFrom(BinaryReader reader)
        {
            _dwReqNum = reader.ReadUInt32();
            _ipaZ = reader.ReadUInt32();
            _ipportZ = reader.ReadUInt16();
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_dwReqNum);
            writer.Write(_ipaZ);
            writer.Write(_ipportZ);
        }
    }

    // SGMsgSpiRep
    // SPI response
    class SGMsgSpiRep2
    {
        public const int    Size                    = 11;

        public uint         _dwReqNum               = 0;        // Copy of _dwReqNum from request
        public uint         _ipaZ                   = 0;        // IP address of the client on the DMZ
        public ushort       _ipportZ                = 0;        // IP port of the client on the DMZ
        public byte         _fNotFound              = 0;        // TRUE if client not found (no auth-data enclosed)

        public void ReadFrom(BinaryReader reader)
        {
            _dwReqNum = reader.ReadUInt32();
            _ipaZ = reader.ReadUInt32();
            _ipportZ = reader.ReadUInt16();
            _fNotFound = reader.ReadByte();
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_dwReqNum);
            writer.Write(_ipaZ);
            writer.Write(_ipportZ);
            writer.Write(_fNotFound);
        }
    }

    // SGMsgSpiData
    class SGMsgSpiData2
    {
        public const int    Size                = 50;
        
        public ushort       _ipportI            = 0;        // IP port of the client on the Internet
        public uint         _ipaI               = 0;        // IP address of the client on the Internet
        public byte[/*20*/] _sgaddr             = new byte[20];     // SGADDR of the client (size = 20 bytes)
        public ushort       _wVersionKeyEx      = 1;        // KeyEx version of the client
        public ushort       _wFlagsKeyEx        = 1;        // Flags sent in KeyEx initiator
        public ulong        _liNonce            = 0;        // A random nonce associated with this session
        public ulong        _liTimeInit         = 0;        // FILETIME marking session initiation
        public uint         _fCs                = 0;        // TRUE if SG is providing connection services

        public void ReadFrom(BinaryReader reader)
        {
            _ipportI        = reader.ReadUInt16();
            _ipaI           = reader.ReadUInt32();
            _sgaddr         = reader.ReadBytes(20);
            _wVersionKeyEx  = reader.ReadUInt16();
            _wFlagsKeyEx    = reader.ReadUInt16();
            _liNonce        = reader.ReadUInt64();
            _liTimeInit     = reader.ReadUInt64();
            _fCs            = reader.ReadUInt32();
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_ipportI);
            writer.Write(_ipaI);
            writer.Write(_sgaddr);
            writer.Write(_wVersionKeyEx);
            writer.Write(_wFlagsKeyEx);
            writer.Write(_liNonce);
            writer.Write(_liTimeInit);
            writer.Write(_fCs);
        }
    }

    // SGAuthData
    class SGAuthData3
    {
        public const int    Size                    = 44 + (4*SGXUID.Size) + (12*4) + (4*4);
        public const ushort XONLINE_AUTHDATA_VERSION = 3;

        public ushort       _wAuthDataVersion       = XONLINE_AUTHDATA_VERSION;
        public ushort       _wAuthDataSize          = Size;
        public ushort       _wMajorVersion          = 1;
        public ushort       _wMinorVersion          = 2;
        public ushort       _wBuildNumber           = 3;
        public ushort       _wQFENumber             = 4;
        public uint         _dwTitleID              = 0;
        public uint         _dwTitleVersion         = 0;
        public uint         _dwTitleRegion          = 0;
        public uint         _dwConsoleRegion        = 0;
        public uint         _dwMediaId              = 0;
        public ushort       _wLanguageId            = 0;
        public uint         _dwAuthDataFlags        = 0;
        public ushort       _wNumPrivileges         = 0;
        public uint[]       _rgPrivileges           = new uint[8];
        public ulong        _qwXboxID               = 0;
        public SGXUID[]     _users                  = new SGXUID[4];
        public float[]      _afltTrustFactor        = new float[4];
        public ushort       _wNumServices           = 0;
        public uint[]       _dwServiceID            = new uint[12];
        public uint[]       _rgAltTitleId           = new uint[4];
        public byte[]       _key                    = new byte[16];
        

        public void ReadFrom(BinaryReader reader)
        {
            _wAuthDataVersion = reader.ReadUInt16();
            _wAuthDataSize = reader.ReadUInt16();
            _wMajorVersion = reader.ReadUInt16();
            _wMinorVersion = reader.ReadUInt16();
            _wBuildNumber = reader.ReadUInt16();
            _wQFENumber = reader.ReadUInt16();
            _dwTitleID = reader.ReadUInt32();
            _dwTitleVersion = reader.ReadUInt32();
            _dwTitleRegion = reader.ReadUInt32();
            _dwConsoleRegion = reader.ReadUInt32();
            _dwMediaId = reader.ReadUInt32();
            _dwAuthDataFlags = reader.ReadUInt32();
            _wNumPrivileges = reader.ReadUInt16();
            
            for(int iPriv=0; iPriv < _rgPrivileges.Length; iPriv++)
            {
                _rgPrivileges[iPriv] = reader.ReadUInt32();
            }
            
            _qwXboxID = reader.ReadUInt64();

            for(int iUser=0; iUser < _users.Length; iUser++)
            {
                _users[iUser].ReadFrom(reader);
            }
            
            for(int iTrustFactor=0; iTrustFactor < _afltTrustFactor.Length; iTrustFactor++)
            {
                _afltTrustFactor[iTrustFactor] = reader.ReadSingle();
            }
            
            _wNumServices = reader.ReadUInt16();
            
            for(int iService=0; iService < _dwServiceID.Length; iService++)
            {
                _dwServiceID[iService] = reader.ReadUInt32();
            }
            
            for(int iAltTitle=0; iAltTitle < _rgAltTitleId.Length; iAltTitle++)
            {
                _rgAltTitleId[iAltTitle] = reader.ReadUInt32();
            }
            
            _key = reader.ReadBytes(_key.Length);
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_wAuthDataVersion);
            writer.Write(_wAuthDataSize);
            writer.Write(_wMajorVersion);
            writer.Write(_wMinorVersion);
            writer.Write(_wBuildNumber);
            writer.Write(_wQFENumber);
            writer.Write(_dwTitleID);
            writer.Write(_dwTitleVersion);
            writer.Write(_dwTitleRegion);
            writer.Write(_dwConsoleRegion);
            writer.Write(_dwMediaId);
            writer.Write(_wLanguageId);
            writer.Write(_dwAuthDataFlags);
            writer.Write(_wNumPrivileges);
            
            for(int iPriv=0; iPriv < _rgPrivileges.Length; iPriv++)
            {
                writer.Write(_rgPrivileges[iPriv]);
            }
            
            writer.Write(_qwXboxID);

            for(int iUser=0; iUser < _users.Length; iUser++)
            {
                _users[iUser].WriteTo(writer);
            }
            for(int iTrustFactor=0; iTrustFactor < _afltTrustFactor.Length; iTrustFactor++)
            {
                writer.Write(_afltTrustFactor[iTrustFactor]);
            }

            writer.Write(_wNumServices);
            
            for(int iService=0; iService < _dwServiceID.Length; iService++)
            {
                writer.Write(_dwServiceID[iService]);
            }
            
            for(int iAltTitle=0; iAltTitle < _rgAltTitleId.Length; iAltTitle++)
            {
                writer.Write(_rgAltTitleId[iAltTitle]);
            }
            
            writer.Write(_key);
        }
    } 

    // SGXUID
    // user id
    struct SGXUID 
    {
        public const int    Size                    = 12;

        public ulong        _userId;
        public uint         _userFlags;
 
        public void ReadFrom(BinaryReader reader)
        {
            _userId = reader.ReadUInt64();
            _userFlags = reader.ReadUInt32();
        }
        
        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_userId);
            writer.Write(_userFlags);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\common\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__common_3_none_12.4.56.0_none_2758e45a43f77aac
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_common_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.manifest
XP_MANIFEST_PATH=manifests\x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.cat
XP_CATALOG_PATH=manifests\x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.cat
XP_PAYLOAD_PATH=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_common_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamerprofile\EnumAdditional.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace Achievement
{
    /// <summary>
    /// Summary description for EnumAdditional.
    /// </summary>
    [TestGroup, TestFrequency("Regression"), Description("Additional Test Cases for Enum Achievement APIs in xstatsfd.dll")]
    public class EnumAdditional : TestNode
    {
        public static ulong OwnerInvUser = 0;
        public static ulong UserInvOwner = 0;

        public EnumAdditional()
        {
            AddChild(new EnumNonExistingUser(50));
            AddChild(new EnumSP0Size10(50));
            AddChild(new EnumSP1Size10(50));
            AddChild(new EnumSP8Size10(50));
            AddChild(new EnumSP9Size10(50));
            AddChild(new EnumSP5Size5(50));
            AddChild(new EnumSP1Size0(50));
            AddChild(new EnumSP9Size1(50));
            AddChild(new EnumSP1Size5(50));
            AddChild(new EnumSP10Size1(50));
            AddChild(new EnumRandomlyEarnedAchievementsAllStartingIndices(50));
            AddChild(new EnumInOrderEarnedAchievementsAllStartingIndices(50));

            AddChild(new EnumMax(54));
            AddChild(new EnumMaxPlus1(54));
            AddChild(new TCInvalidSmallPKT());
            AddChild(new TCInvalidLargePKT());

            AddChild(new SGAuthDiffTitleSamePub(50));
            AddChild(new SGAuthDiffTitleDiffPub(50));
            AddChild(new InvalidSGAuthUser(50));

            // Parental controls
            AddChild(new Activity_Friends(50));
            AddChild(new Activity_None(50));
            AddChild(new Activity_All(50));

            AddChild(new ReadActivityAll(50));
            AddChild(new ReadActivityFriends(50));
            AddChild(new ReadActivityNone(50));

            //local test cases
            AddChild(new EnumLocalefr(96));
            AddChild(new EnumLocale13(96));
        }

        public override void PreRun()
        {
            FriendsCommon fc = new FriendsCommon();

            PNUser _Owner = fc.CreateUser(true);
            PNUser _Friend = fc.CreateUser(true);
            PNUser _nonFriend = fc.CreateUser(true);
            PNUser _OwnerInvUser = fc.CreateUser(true);
            PNUser _UserInvOwner = fc.CreateUser(true);

            try
            {
                fc.RequestFriend(_Owner, _OwnerInvUser);
                fc.RequestFriend(_UserInvOwner, _Owner);
                fc.MakeFriend(_Friend, _Owner);
            }
            catch (System.Exception e)
            {
                Global.RO.Warn("some of the test may fail because presence had problem" + e);
            }

            ulong Owner = _Owner.UserId;
            ulong friend = _Friend.UserId;
            ulong nonfriend = _nonFriend.UserId;
            OwnerInvUser = _OwnerInvUser.UserId;
            UserInvOwner = _UserInvOwner.UserId;

            //while(_Friend.IsBuddy(_Owner));

            AchivementBase.init(Owner, friend, nonfriend);

            //AchivementBase.init(501,502,503);
        }
    }

    public class TCInvalidSmallPKT : TestNode
    {
        public override void Run()
        {
            InvalidXRLRequest tmp = new InvalidXRLRequest(10, "/xstats/xachievementenum.ashx");
            uint xerror = tmp.Execute();
            if (xerror != HResult.XONLINE_E_END_OF_STREAM)
                throw new Exception("Invalid Xerror Expected :" + HResult.E_FAIL + " recived:" + xerror);
        }
    }

    public class TCInvalidLargePKT : TestNode
    {
        public override void Run()
        {

            InvalidXRLRequest tmp = new InvalidXRLRequest(1000 * 100, "/xstats/xachievementenum.ashx");
            uint xerror = tmp.Execute();
            if (xerror != HResult.XONLINE_E_SERVER_ERROR)
                throw new Exception("Invalid Xerror Expected :" + HResult.E_FAIL + " recived:" + xerror);
        }
    }

    public class EnumLocalefr : AchivementBase
    {
        public EnumLocalefr(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 702;
            int stid = 0;
            int count = 5;
            ClearAchivement(UWoner);
            LoadAchievement(1, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, 0, (ushort)stid, (ushort)count);
            req.LanguageID = (uint)Languageids.fr;
            req.CountryID = (uint)32;
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, (ushort)Locales.fr_FR, false, enumresp, stid, count, UWonerScore);
        }
    }

    public class EnumLocale13 : AchivementBase
    {
        public EnumLocale13(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 702;
            int stid = 0;
            int count = 5;
            ClearAchivement(UWoner);
            LoadAchievement(1, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, 0, (ushort)stid, (ushort)count);
            req.LanguageID = (uint)12; //da
            req.CountryID = (uint)25; //dk
            AchievementEnumResponse enumresp = req.Execute();
            // KKLINE - Locale doesn't exist, so it defaults to EN-US, which is what we should check for.
            verifyEnum(UWoner, _Title, (ushort)Locales.en_US, false, enumresp, stid, count, UWonerScore); //should get default for dk country
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Activity Blocked")]
    public class ReadActivityNone : AchivementBase
    {
        public ReadActivityNone(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            this.UWoner = Owner;
            ClearAchivement(Owner);
            LoadAchievement(4, DateTime.UtcNow);

        }

        protected override void run()
        {
            int stid = 0;
            int count = 10;
            //self
            Global.RO.Info("Reading Self");
            XRLEnumAchievement req = new XRLEnumAchievement(Title, Owner, Owner, locale, (ushort)stid, (ushort)count);
            req.Modifyflag = AuthModify.Read_Activity_None;
            AchievementEnumResponse enumresp = req.Execute();

            verifyEnum(Owner, Title, locale, false, enumresp, stid, count, UWonerScore);
            // friend
            Global.RO.Info("Reading friend");
            XRLEnumAchievement req1 = new XRLEnumAchievement(Title, Friend, Owner, locale, (ushort)stid, (ushort)count);
            req1.Modifyflag = AuthModify.Read_Activity_None;
            AchievementEnumResponse enumresp1 = req1.Execute();
            if (enumresp1.xResult != HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                throw new Exception("Invalid XError :" + enumresp1.xResult);
            // nonfriend
            Global.RO.Info("Reading non friend");
            XRLEnumAchievement req2 = new XRLEnumAchievement(Title, NonFriend, Owner, locale, (ushort)stid, (ushort)count);
            req2.Modifyflag = AuthModify.Read_Activity_None;
            AchievementEnumResponse enumresp2 = req2.Execute();
            if (enumresp2.xResult != HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                throw new Exception("Invalid XError :" + enumresp2.xResult);

        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Activity Everyone")]
    public class ReadActivityAll : AchivementBase
    {
        public ReadActivityAll(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            this.UWoner = Owner;
            ClearAchivement(Owner);
            LoadAchievement(4, DateTime.UtcNow);

        }

        protected override void run()
        {
            int stid = 0;
            int count = 10;
            //self
            Global.RO.Info("Reading self");
            XRLEnumAchievement req = new XRLEnumAchievement(Title, Owner, Owner, locale, (ushort)stid, (ushort)count);
            req.Modifyflag = AuthModify.Read_Activity_All;
            AchievementEnumResponse enumresp = req.Execute();

            verifyEnum(Owner, Title, locale, false, enumresp, stid, count, UWonerScore);

            //one way firnds  EnumAdditional
            Global.RO.Info("Reading friend");
            XRLEnumAchievement req3 = new XRLEnumAchievement(Title, EnumAdditional.OwnerInvUser, Owner, locale, (ushort)stid, (ushort)count);
            req3.Modifyflag = AuthModify.Read_Activity_All;
            AchievementEnumResponse enumresp3 = req3.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp3, stid, count, UWonerScore);

            // friend
            Global.RO.Info("Reading friend");
            XRLEnumAchievement req1 = new XRLEnumAchievement(Title, Friend, Owner, locale, (ushort)stid, (ushort)count);
            req1.Modifyflag = AuthModify.Read_Activity_All;
            AchievementEnumResponse enumresp1 = req1.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp1, stid, count, UWonerScore);

            // one way nonfriend 
            Global.RO.Info("Reading non friend");
            XRLEnumAchievement req4 = new XRLEnumAchievement(Title, EnumAdditional.UserInvOwner, Owner, locale, (ushort)stid, (ushort)count);
            req4.Modifyflag = AuthModify.Read_Activity_All;
            AchievementEnumResponse enumresp4 = req4.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp4, stid, count, UWonerScore);

            // nonfriend
            Global.RO.Info("Reading non friend");
            XRLEnumAchievement req2 = new XRLEnumAchievement(Title, NonFriend, Owner, locale, (ushort)stid, (ushort)count);
            req2.Modifyflag = AuthModify.Read_Activity_All;
            AchievementEnumResponse enumresp2 = req2.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp2, stid, count, UWonerScore);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Activity Friends Only")]
    public class ReadActivityFriends : AchivementBase
    {
        public ReadActivityFriends(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            this.UWoner = Owner;
            ClearAchivement(Owner);
            LoadAchievement(4, DateTime.UtcNow);

        }

        protected override void run()
        {
            int stid = 0;
            int count = 10;
            //self
            Global.RO.Info("Reading self");
            XRLEnumAchievement req = new XRLEnumAchievement(Title, Owner, Owner, locale, (ushort)stid, (ushort)count);
            req.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            AchievementEnumResponse enumresp = req.Execute();

            verifyEnum(Owner, Title, locale, false, enumresp, stid, count, UWonerScore);

            //one way firnds  EnumAdditional
            Global.RO.Info("Reading friend");
            XRLEnumAchievement req3 = new XRLEnumAchievement(Title, EnumAdditional.OwnerInvUser, Owner, locale, (ushort)stid, (ushort)count);
            req3.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            AchievementEnumResponse enumresp3 = req3.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp3, stid, count, UWonerScore);

            // friend
            Global.RO.Info("Reading friend");
            XRLEnumAchievement req1 = new XRLEnumAchievement(Title, Friend, Owner, locale, (ushort)stid, (ushort)count);
            req1.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            AchievementEnumResponse enumresp1 = req1.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp1, stid, count, UWonerScore);

            // one way nonfriend 
            Global.RO.Info("Reading non friend");
            XRLEnumAchievement req4 = new XRLEnumAchievement(Title, EnumAdditional.UserInvOwner, Owner, locale, (ushort)stid, (ushort)count);
            req4.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            AchievementEnumResponse enumresp4 = req4.Execute();
            if (enumresp4.xResult != HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                throw new Exception("Invalid XError :" + enumresp4.xResult);

            // nonfriend
            Global.RO.Info("Reading non friend");
            XRLEnumAchievement req2 = new XRLEnumAchievement(Title, NonFriend, Owner, locale, (ushort)stid, (ushort)count);
            req2.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            AchievementEnumResponse enumresp2 = req2.Execute();
            if (enumresp2.xResult != HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                throw new Exception("Invalid XError :" + enumresp2.xResult);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Activity Friends Only")]
    public class Activity_Friends : AchivementBase
    {
        public Activity_Friends(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ClearAchivement(Owner);
            addPermission(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);
            this.UWoner = Owner;
            LoadAchievement(4, DateTime.UtcNow);

        }

        protected override void run()
        {
            int stid = 0;
            int count = 10;
            //self
            XRLEnumAchievement req = new XRLEnumAchievement(Title, Owner, Owner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp, stid, count, UWonerScore);

            // one way friend 
            XRLEnumAchievement req3 = new XRLEnumAchievement(Title, EnumAdditional.OwnerInvUser, Owner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp3 = req3.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp3, stid, count, UWonerScore);
            // friend
            XRLEnumAchievement req1 = new XRLEnumAchievement(Title, Friend, Owner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp1 = req1.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp1, stid, count, UWonerScore);

            //one way  nonfriend
            XRLEnumAchievement req4 = new XRLEnumAchievement(Title, EnumAdditional.UserInvOwner, Owner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp4 = req4.Execute();
            if (enumresp4.xResult != HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                throw new Exception("Invalid XError :" + enumresp4.xResult);

            // nonfriend
            XRLEnumAchievement req2 = new XRLEnumAchievement(Title, NonFriend, Owner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp2 = req2.Execute();
            if (enumresp2.xResult != HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                throw new Exception("Invalid XError :" + enumresp2.xResult);

        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Activity Blocked")]
    public class Activity_None : AchivementBase
    {
        public Activity_None(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ClearAchivement(Owner);
            addPermission(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE);
            this.UWoner = Owner;
            LoadAchievement(4, DateTime.UtcNow);

        }

        protected override void run()
        {
            int stid = 0;
            int count = 10;
            //self
            XRLEnumAchievement req = new XRLEnumAchievement(Title, Owner, Owner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp, stid, count, UWonerScore);
            // friend
            XRLEnumAchievement req1 = new XRLEnumAchievement(Title, Friend, Owner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp1 = req1.Execute();
            if (enumresp1.xResult != HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                throw new Exception("Invalid XError :" + enumresp1.xResult);

            // nonfriend
            XRLEnumAchievement req2 = new XRLEnumAchievement(Title, NonFriend, Owner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp2 = req2.Execute();
            if (enumresp2.xResult != HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                throw new Exception("Invalid XError :" + enumresp2.xResult);

        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Activity Everyone")]
    public class Activity_All : AchivementBase
    {
        public Activity_All(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            //addPermission(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE);
            ProfileWS.ResetUserSetttings(Owner);
            this.UWoner = Owner;
            ClearAchivement(Owner);
            LoadAchievement(10, DateTime.UtcNow);
        }

        protected override void run()
        {
            int stid = 0;
            int count = 10;
            //self
            XRLEnumAchievement req = new XRLEnumAchievement(Title, Owner, Owner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp, stid, count, UWonerScore);
            // friend
            XRLEnumAchievement req1 = new XRLEnumAchievement(Title, Friend, Owner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp1 = req1.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp1, stid, count, UWonerScore);

            // nonfriend
            XRLEnumAchievement req2 = new XRLEnumAchievement(Title, NonFriend, Owner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp2 = req2.Execute();
            verifyEnum(Owner, Title, locale, false, enumresp2, stid, count, UWonerScore);
        }
    }

    public class InvalidSGAuthUser : AchivementBase
    {
        public InvalidSGAuthUser(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 703;
            int stid = 1;
            int count = 10;

            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            req.Modifyflag = AuthModify.Change_User;
            AchievementEnumResponse enumresp = req.Execute();

            if (enumresp.xResult != HResult.XONLINE_E_SERVER_ERROR)
                throw new Exception("Invalid Xerror :" + enumresp.xResult);
        }
    }

    //SGAuthDiffTitlePub
    public class SGAuthDiffTitleDiffPub : AchivementBase
    {
        public SGAuthDiffTitleDiffPub(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 704;
            int stid = 1;
            int count = 10;
            int expectedRec = 9;

            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            req.Modifyflag = AuthModify.Change_Title_PUB;
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, expectedRec, UWonerScore);
        }
    }

    public class SGAuthDiffTitleSamePub : AchivementBase
    {
        public SGAuthDiffTitleSamePub(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 705;
            int stid = 1;
            int count = 10;
            int expectedRec = 9;
            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            req.Modifyflag = AuthModify.Change_Title;
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, expectedRec, UWonerScore);
        }
    }

    public class EnumMaxPlus1 : AchivementBase
    {
        public EnumMaxPlus1(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 707;
            int stid = 10;
            int count = 33;
            int expectedRec = 33;
            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();

            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, expectedRec, UWonerScore);
        }
    }

    [TestFrequency("BVT"), TestCasePriority(1), BVT, Description("Achievement Enumeration Max Request BVT")]
    public class EnumMax : AchivementBase
    {
        public EnumMax(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 701;
            int stid = 10;
            int count = 32;
            int expectedRec = 32;
            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, expectedRec, UWonerScore);
        }
    }

    public class EnumSP10Size1 : AchivementBase
    {
        public EnumSP10Size1(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 708;
            int stid = 10;
            int count = 1;
            int expectedRec = 0;
            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, expectedRec, UWonerScore);
        }
    }

    public class EnumSP1Size5 : AchivementBase
    {
        public EnumSP1Size5(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 709;
            int stid = 1;
            int count = 5;
            int expectedRec = 5;
            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, expectedRec, UWonerScore);
        }
    }

    public class EnumSP9Size1 : AchivementBase
    {
        public EnumSP9Size1(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 710;
            int stid = 9;
            int count = 1;
            int expectedRec = 1;
            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, expectedRec, UWonerScore);
        }
    }

    public class EnumSP1Size0 : AchivementBase
    {
        public EnumSP1Size0(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 711;
            int stid = 1;
            int count = 0;
            int expectedRec = 0;
            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, expectedRec, UWonerScore);
        }
    }

    public class EnumSP5Size5 : AchivementBase
    {
        public EnumSP5Size5(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 712;
            int stid = 5;
            int count = 5;
            int expectedRec = 5;
            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, expectedRec, UWonerScore);
        }
    }

    public class EnumSP9Size10 : AchivementBase
    {
        public EnumSP9Size10(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 713;
            int stid = 9;
            int count = 10;
            int expectedRec = 1;
            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, expectedRec, UWonerScore);
        }
    }

    public class EnumSP8Size10 : AchivementBase
    {
        public EnumSP8Size10(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 714;
            int stid = 8;
            int count = 10;
            int expectedRec = 2;
            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, expectedRec, UWonerScore);
        }
    }

    public class EnumSP1Size10 : AchivementBase
    {
        public EnumSP1Size10(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 715;
            int stid = 1;
            int count = 10;
            int expectedRec = 9;
            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, expectedRec, UWonerScore);
        }
    }

    public class EnumSP0Size10 : AchivementBase
    {
        public EnumSP0Size10(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 716;
            int stid = 0;
            int count = 10;
            ClearAchivement(UWoner);
            LoadAchievement(4, DateTime.UtcNow);

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, count, UWonerScore);
        }
    }

    public class EnumNonExistingUser : AchivementBase
    {
        public EnumNonExistingUser(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            UWoner = 505;
            int stid = 0;
            int count = 10;

            ClearAchivement(UWoner);


            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stid, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stid, count, UWonerScore);
        }
    }

    public class EnumRandomlyEarnedAchievementsAllStartingIndices : AchivementBase
    {
        public EnumRandomlyEarnedAchievementsAllStartingIndices(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            // Expected order of returned achievements is:
            // 9
            // 7
            // 5
            // 3
            // 1
            // 2
            // 4
            // 6
            // 8
            // 10

            UWoner = 716;

            for (int startingIndex = 0, count = 10; startingIndex < 10; ++startingIndex, --count)
            {
                ClearAchivement(UWoner);

                Global.RO.Info("Enum with startingIndex: " + startingIndex + " and count: " + count);

                LoadAchievementsByIds(new uint[] { 1, 3, 5, 7, 9 }, DateTime.UtcNow);

                XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)startingIndex, (ushort)count);
                AchievementEnumResponse enumresp = req.Execute();
                verifyEnum(UWoner, _Title, locale, false, enumresp, startingIndex, count, UWonerScore);
            }
        }
    }

    public class EnumInOrderEarnedAchievementsAllStartingIndices : AchivementBase
    {
        public EnumInOrderEarnedAchievementsAllStartingIndices(uint title)
            : base(title)
        {
        }

        public override void Run()
        {
            // Expected order of returned achievements is:
            // 7
            // 6
            // 5
            // 4
            // 1
            // 2
            // 3
            // 8
            // 9
            // 10

            UWoner = 716;

            for (int startingIndex = 0, count = 10; startingIndex < 10; ++startingIndex, --count)
            {
                ClearAchivement(UWoner);

                Global.RO.Info("Enum with startingIndex: " + startingIndex + " and count: " + count);

                LoadAchievementByIndex(3, 4, DateTime.UtcNow); // Earn achievements 4, 5, 6, 7

                XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)startingIndex, (ushort)count);
                AchievementEnumResponse enumresp = req.Execute();
                verifyEnum(UWoner, _Title, locale, false, enumresp, startingIndex, count, UWonerScore);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamerprofile\Achievement.cs ===
using System;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Database;
using  ServerTestFramework.LiveService.Achievement;
using  xonline.common.config;
using System.IO;

[assembly: RootNode(typeof(Achievement.AchievementSuite))]

namespace Achievement
{
    /// <summary>
    /// The Achievement Suite is used for testing the Achievement APIs
    /// and added in Spring 2009, the AvatarAsset APIs.  The reason for this is that
    /// the AvatarAsset APIs are extremely similar to the Achievement, and I felt this
    /// would fit in this suite.
    /// </summary>
    [TestFrequency("Regression"), TestCasePriority(3), Owner("KKline")] 
    public class AchievementSuite: TestNode
    {
        public AchievementSuite()
        {
        }

        public override void PreRun()
        {
            // Let the fake SG know where to send state updates
            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence).ToString());

            // Titles 50-97 for Achievements
            // Titles 200-204 for AvatarAssets
            uint [] titles = {50,51,52,53,54,96,97,98,99,200,201,202,203,204};
            string pathToConfigFiles = "InputFiles\\GamerProfile\\";
            //let's make sure the title information is present...
            foreach(uint title in titles) {
                try {
                    TitleConfig.GetTitle(title);
                } catch (ApplicationException) {
                    //prop the title accordingly
                    Global.RO.Info("Title number " + title + " not found in NPDB--attempting to remedy via sql file...");
                    try {
                        StreamReader file = File.OpenText(pathToConfigFiles + "achievement" + title + ".sql");
                        String sql;
                        sql = file.ReadToEnd();
                        Npdb npdb = new Npdb();
                        npdb.ConnectToServer();
                        npdb.IssueCommand(sql);
                        npdb.Close();

                    } catch (Exception e) {
                        Global.RO.Warn("Could not prop title " + title + "!  Test results may be inaccurate.");
                        Global.RO.Warn("Text is as follows:" + e.ToString());
                    }
                    Global.RO.Info("Title configuration info added successfully!");
                }
            }

            AchivementBase.gconfig.Load(titles);
        }

        /* Cut this so that we can have proper attribute tagging 
        public override TestBaseGroupList GetTests()
        {
            TestBaseGroupList TestGroups = new TestBaseGroupList();
            // Add test Groups here.
            TestGroups.Add(new PSyncEnum());
            TestGroups.Add(new EnumAdditional());
            
            // KKline added for the AvatarAsset Awarding API's
            // which are very similar to and based off the Achievement API's
            // which is why I decided to place them inside this location
            TestGroups.Add(new PSyncEnumAvatarAssets());
            
            // These are for the stats console audit list uploading API
            // which goes along with the addition avatarasset stuff
            TestGroups.Add(new UploadConsoleAuditListTests());

            return TestGroups;
        }
        */
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamerprofile\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamerprofile\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_achievement_none_12.4.56.0_none_6aa92fc6e635d5e2
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=achievement
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2.manifest
XP_MANIFEST_PATH=manifests\msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2.cat
XP_CATALOG_PATH=manifests\msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2.cat
XP_PAYLOAD_PATH=msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=achievement,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamerprofile\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamerprofile\UploadConsoleAuditListTests.cs ===
﻿using System;
using System.Threading;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.LiveService.UploadConsoleList;

namespace Achievement
{
    [TestGroup, TestFrequency("Regression"), Description("Test Cases for UploadConsoleAuditList APIs in xstatsfd.dll")]
    public class UploadConsoleAuditListTests : TestNode
    {

        public UploadConsoleAuditListTests()
        {
            /* This test uses the TestCase attribute instead of adding the test cases here
            Positive Cases
                P_SingleSync:           User=801
                P_MultiConsoleListSync: User=802
                P_MaxConsoleListSync:   User=803
                P_MergeConsoleListSync: User=804
                P_UploadConsoleDiffSigningConsoleSync: User=805
                
            Negative Cases
                N_EmptySync:                    User=820
                N_MaxPlusOneConsoleListSync:    User=821
                N_InvalidPCClient:              User=822
                N_InvalidXbox1Client:           User=823
                N_InvalidXenonBackCompatClient: User=824 - commented out
                
            */
        }

        [TestCase, BVT, TestCasePriority(1), Description("Single Console List consoleId upload"), TestFrequency("BVT")]
        // Test case for upload with one consoleId used for upload/signing and consoleList
        public class P_SingleSync : TestNode
        {
            public P_SingleSync() { }

            public override void Run()
            {
                uint hr;
                ulong user = 801;

                // Clear the user
                ProfileWS.ResetUserConsoleAuditList(user);

                byte[] consoleId = new byte[] { 0x11, 0x22, 0x33, 0x44, 0x55 };

                // Sync request has no avatarassets in it
                Global.RO.Info("calling upload request with one consoleId in list");
                XRLUploadConsoleListRequest req = new XRLUploadConsoleListRequest(user, consoleId);
                hr = req.PostXRLUploadConsoleListRequest(user, req, CSGInfo.ClientType.Xenon);

                Global.RO.Info("Uploading ConsoleId: " + ConsoleIdData.GetDecimalValue(consoleId));

                // verify the response was ok
                if (hr != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + hr.ToString("x"));

                Global.RO.Info("Validating row count from t_user_console_audit_list");
                int count = ProfileWS.UserConsoleAuditListCount(user);
                if (count != 1)
                    throw new Exception("Unexpected count returned for user from t_user_console_audit_list: " + count + " expecting: 1");
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Mulitple Consoles in consoleList to upload")]
        // Test case for having multiple consoles in the consoleList in the sync
        public class P_MultiConsoleListSync : TestNode
        {
            public P_MultiConsoleListSync() { }

            public override void Run()
            {
                uint hr;
                ulong user = 802;

                // Clear the user
                ProfileWS.ResetUserConsoleAuditList(user);

                byte[] consoleId = new byte[] { 0x00, 0x00, 0x00, 0x00, 0xFF };
                ConsoleIdData[] consoleList = new ConsoleIdData[5];

                // Loop through and create some random consoleids
                for (int i = 0; i < consoleList.Length; i++)
                {
                    consoleList[i] = new ConsoleIdData(new byte[] { (byte)i, 0x11, 0x11, 0x11, 0x11 });
                }

                // Sync request with 5 consoleIds in the list, and the same signing/uploading console
                Global.RO.Info("Callling upload with 5 ConsoleIDs in the Console List");
                XRLUploadConsoleListRequest req = new XRLUploadConsoleListRequest(user, consoleId, consoleId, consoleList);

                hr = req.PostXRLUploadConsoleListRequest(user, req, CSGInfo.ClientType.Xenon);

                Global.RO.Info("Uploading ConsoleId: " + ConsoleIdData.GetDecimalValue(consoleId));

                // verify the response was ok
                if (hr != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + hr.ToString("x"));

                Global.RO.Info("Validating row count from t_user_console_audit_list");
                int count = ProfileWS.UserConsoleAuditListCount(user);

                if (count != 5)
                    throw new Exception("Unexpected count returned for user from t_user_console_audit_list: " + count + " expecting: 5");

                Global.RO.Info("Validating i_first_seen_ordinal from t_user_console_audit_list");
                int ordinal = ProfileWS.UserConsoleAuditListFirstSeenOrdinalValue(user, ConsoleIdData.GetDecimalValue(consoleId), ConsoleIdData.GetDecimalValue(consoleId), ConsoleIdData.GetDecimalValue(consoleList[0].ConsoleId));

                if (ordinal != 0)
                    throw new Exception("Unexpected i_first_seen_ordinal returned for user from t_user_console_audit_list: " + ordinal + " expecting: 0");
            }
        }

        [TestCase, Description("Max Consoles in consoleList to upload")]
        // Test case to call upload with the Max number of consoles in the ConsoleList
        public class P_MaxConsoleListSync : TestNode
        {
            public P_MaxConsoleListSync() { }

            public override void Run()
            {
                uint hr;
                ulong user = 803;

                // Clear the user
                ProfileWS.ResetUserConsoleAuditList(user);

                byte[] consoleId = new byte[] { 0x01, 0x11, 0x11, 0x11, 0x02 };
                ConsoleIdData[] consoleList = new ConsoleIdData[xonline.common.service.XOn.XONLINE_MAX_CONSOLE_AUDIT_LIST];

                // Loop through and create some random consoleids
                for (int i = 0; i < consoleList.Length; i++)
                {
                    consoleList[i] = new ConsoleIdData(new byte[] { (byte)i, 0x11, 0x11, 0x11, 0x02 });
                }

                // Sync request with max consoleList consoleIds
                Global.RO.Info("Sync MAX ConsoleIDs in the Console List");
                XRLUploadConsoleListRequest req = new XRLUploadConsoleListRequest(user, consoleId, consoleId, consoleList);

                hr = req.PostXRLUploadConsoleListRequest(user, req, CSGInfo.ClientType.Xenon);

                Global.RO.Info("Uploading ConsoleId: " + ConsoleIdData.GetDecimalValue(consoleId));

                // verify the response was ok
                if (hr != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + hr.ToString("x"));

                Global.RO.Info("Validating row count from t_user_console_audit_list");
                int count = ProfileWS.UserConsoleAuditListCount(user);

                if (count != xonline.common.service.XOn.XONLINE_MAX_CONSOLE_AUDIT_LIST)
                    throw new Exception("Unexpected count returned for user from t_user_console_audit_list: " + count + " expecting: " + xonline.common.service.XOn.XONLINE_MAX_CONSOLE_AUDIT_LIST);

                Global.RO.Info("Validating i_first_seen_ordinal for last consoleid from t_user_console_audit_list");
                int ordinal = ProfileWS.UserConsoleAuditListFirstSeenOrdinalValue(user, ConsoleIdData.GetDecimalValue(consoleId), ConsoleIdData.GetDecimalValue(consoleId), ConsoleIdData.GetDecimalValue(consoleList[xonline.common.service.XOn.XONLINE_MAX_CONSOLE_AUDIT_LIST - 1].ConsoleId));

                if (ordinal != xonline.common.service.XOn.XONLINE_MAX_CONSOLE_AUDIT_LIST - 1)
                    throw new Exception("Unexpected i_first_seen_ordinal returned for user from t_user_console_audit_list: " + ordinal + " expecting: " + (xonline.common.service.XOn.XONLINE_MAX_CONSOLE_AUDIT_LIST - 1));
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Merging of signing/uploading/user console list sync")]
        // Test case which calls multiple uploads where the console list will be merged with existing list
        public class P_MergeConsoleListSync : TestNode
        {
            public P_MergeConsoleListSync() { }

            public override void Run()
            {
                uint hr;
                ulong user = 804;

                // Clear the user
                ProfileWS.ResetUserConsoleAuditList(user);

                byte[] consoleId = new byte[] { 0x20, 0x00, 0x00, 0x00, 0x00 };
                ConsoleIdData[] consoleList = new ConsoleIdData[2];

                // Start by adding 2 consoleIds to the list
                for (int i = 0; i < consoleList.Length; i++)
                {
                    consoleList[i] = new ConsoleIdData(new byte[] { (byte)(i + 0x20), 0x00, 0x00, 0x00, 0x00 });
                }

                // Sync request with the 2 consoleIds
                Global.RO.Info("Sync 2 ConsoleIDs in the Console List");
                XRLUploadConsoleListRequest req = new XRLUploadConsoleListRequest(user, consoleId, consoleId, consoleList);

                hr = req.PostXRLUploadConsoleListRequest(user, req, CSGInfo.ClientType.Xenon);
                Global.RO.Info("Uploading Console: " + ConsoleIdData.GetDecimalValue(consoleId)); ;

                // verify the response was ok
                if (hr != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + hr.ToString("x"));


                Global.RO.Info("Validating row count from t_user_console_audit_list");
                int count = ProfileWS.UserConsoleAuditListCount(user);

                if (count != 2)
                    throw new Exception("Unexpected count returned for user from t_user_console_audit_list: " + count + " expecting: 2");

                // Now add 3 more to the list, with one of those being the same
                ConsoleIdData[] consoleList2 = new ConsoleIdData[3];

                for (int i = 0; i < consoleList.Length; i++)
                {
                    consoleList[i] = new ConsoleIdData(new byte[] { (byte)(i + 0x1E), 0x00, 0x00, 0x00, 0x00 });
                }
                Global.RO.Info("Sync 3 ConsoleIDs in the Console List, only 1 is new");
                XRLUploadConsoleListRequest req2 = new XRLUploadConsoleListRequest(user, consoleId, consoleId, consoleList);

                hr = req2.PostXRLUploadConsoleListRequest(user, req2, CSGInfo.ClientType.Xenon);

                Global.RO.Info("Uploading Console: " + ConsoleIdData.GetDecimalValue(consoleId)); ;

                // verify the response was ok
                if (hr != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + hr.ToString("x"));

                // Because we merged the 2 console Lists, we should expect 4 rows, not 5 (only 1 row overlapped
                Global.RO.Info("Validating row count from t_user_console_audit_list");
                count = ProfileWS.UserConsoleAuditListCount(user);

                if (count != 4)
                    throw new Exception("Unexpected merged count returned for user from t_user_console_audit_list: " + count + " expecting: 4");

                Global.RO.Info("Validating i_first_seen_ordinal for merged consoleid from t_user_console_audit_list");
                int ordinal = ProfileWS.UserConsoleAuditListFirstSeenOrdinalValue(user, ConsoleIdData.GetDecimalValue(consoleId), ConsoleIdData.GetDecimalValue(consoleId), ConsoleIdData.GetDecimalValue(consoleId));

                if (ordinal != 0)
                    throw new Exception("Unexpected i_first_seen_ordinal returned for user from t_user_console_audit_list: " + ordinal + " expecting: 0");
            }
        }

        [TestCase, Description("Uploading ConsoleId different from Signing ConsoleId")]
        // Test case where uploading console is different from the signing console
        public class P_UploadConsoleDiffSigningConsoleSync : TestNode
        {
            public P_UploadConsoleDiffSigningConsoleSync() { }

            public override void Run()
            {
                uint hr;
                ulong user = 805;

                // Clear the user
                ProfileWS.ResetUserConsoleAuditList(user);

                byte[] uploadingconsoleId = new byte[] { 0x01, 0x00, 0x00, 0x00, 0x00 };
                byte[] signingconsoleId = new byte[] { 0x10, 0x00, 0x00, 0x00, 0x00 };

                // Add the signing console to the consoleList only
                ConsoleIdData[] consoleList = new ConsoleIdData[1];
                consoleList[0] = new ConsoleIdData();
                consoleList[0].ConsoleId = signingconsoleId;

                // Sync request with different signing and uploading consoles
                Global.RO.Info("Sync with different signing and uploading consoleIds");
                XRLUploadConsoleListRequest req = new XRLUploadConsoleListRequest(user, uploadingconsoleId, signingconsoleId, consoleList);

                hr = req.PostXRLUploadConsoleListRequest(user, req, CSGInfo.ClientType.Xenon);

                Global.RO.Info("Uploading Console: " + ConsoleIdData.GetDecimalValue(uploadingconsoleId));
                Global.RO.Info("Signing Console: " + ConsoleIdData.GetDecimalValue(signingconsoleId));

                // verify the response was ok
                if (hr != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + hr.ToString("x"));


                Global.RO.Info("Validating row count from t_user_console_audit_list");
                int count = ProfileWS.UserConsoleAuditListCount(user);

                if (count != 1)
                    throw new Exception("Unexpected count returned for user from t_user_console_audit_list: " + count + " expecting: 1");
            }
        }

        [TestCase, Description("Empty Sync to XRLUploadConsoleAuditList")]
        // Test case to simply call a sync with no data to sync
        public class N_EmptySync : TestNode
        {
            public N_EmptySync() { }

            public override void Run()
            {
                uint hr;
                ulong user = 820;

                // Clear the user
                ProfileWS.ResetUserConsoleAuditList(user);

                XRLUploadConsoleListRequest req = new XRLUploadConsoleListRequest();
                req.UserId = user;  //required for the fakesg slot

                // Sync request has no avatarassets in it
                Global.RO.Info("Calling upload with empty request");
                hr = req.PostXRLUploadConsoleListRequest(user, req, CSGInfo.ClientType.Xenon);

                Global.RO.Info("Expecting XONLINE_E_STAT_CONSOLE_LIST_EMPTY returned");
                // verify the response error code comes back properly
                if (hr != xonline.common.service.HResult.XONLINE_E_STAT_CONSOLE_LIST_EMPTY)
                    throw new Exception("Unexpected XError returned by server " + hr.ToString("x"));

                Global.RO.Info("Validating row count from t_user_console_audit_list");
                int count = ProfileWS.UserConsoleAuditListCount(user);

                if (count != 0)
                    throw new Exception("Unexpected count returned for user from t_user_console_audit_list: " + count + " expecting: 0");
            }
        }

        [TestCase, Description("Max Plus One Consoles in List Sync to XRLUploadConsoleAuditList")]
        // Test case to call with a Max Plus One consoleList - fails with Invalid Arg
        public class N_MaxPlusOneConsoleListSync : TestNode
        {
            public N_MaxPlusOneConsoleListSync() { }

            public override void Run()
            {
                uint hr;
                ulong user = 821;

                // Clear the user
                ProfileWS.ResetUserConsoleAuditList(user);

                byte[] consoleId = new byte[] { 0x01, 0x11, 0x11, 0x11, 0x11 };
                ConsoleIdData[] consoleList = new ConsoleIdData[xonline.common.service.XOn.XONLINE_MAX_CONSOLE_AUDIT_LIST + 1];

                // Create MAX plus 1 consoleIds
                for (int i = 0; i < consoleList.Length; i++)
                {
                    consoleList[i] = new ConsoleIdData(new byte[] { (byte)i, 0x11, 0x11, 0x11, 0x11 });
                }

                // Sync request has with MAX plus one consoleids in the consoleList
                Global.RO.Info("Sync Max Plus One ConsoleIDs in the Console List");
                XRLUploadConsoleListRequest req = new XRLUploadConsoleListRequest(user, consoleId, consoleId, consoleList);

                hr = req.PostXRLUploadConsoleListRequest(user, req, CSGInfo.ClientType.Xenon);

                Global.RO.Info("Expecting E_INVALIDARG returned");
                // verify the response was Invalid Arg
                if (hr != HResult.XONLINE_E_DESERIALIZATION_ERROR)
                    throw new Exception("Unexpected XError returned by server: " + hr.ToString("x") + " Expecting: " + HResult.E_INVALIDARG.ToString("x"));

                Global.RO.Info("Validating row count from t_user_console_audit_list");
                int count = ProfileWS.UserConsoleAuditListCount(user);

                if (count != 0)
                    throw new Exception("Unexpected count returned for user from t_user_console_audit_list: " + count + " expecting: 0");
            }
        }

        [TestCase, Description("Invalid PC Client Type to XRLUploadConsoleAuditList")]
        // Test case to try with a PC Client 
        public class N_InvalidPCClient : TestNode
        {
            public N_InvalidPCClient() { }

            public override void Run()
            {
                uint hr;
                ulong user = 822;

                // Clear the user
                ProfileWS.ResetUserConsoleAuditList(user);

                byte[] consoleId = new byte[] { 0x11, 0x22, 0x33, 0x44, 0x55 };

                // Call upload with just the one consoleId for all consoleID fields
                Global.RO.Info("Sync Single Console List");
                XRLUploadConsoleListRequest req = new XRLUploadConsoleListRequest(user, consoleId);

                // Set the ClientType to PC for the request
                hr = req.PostXRLUploadConsoleListRequest(user, req, CSGInfo.ClientType.PC);
                Global.RO.Info("Uploading Console: " + ConsoleIdData.GetDecimalValue(consoleId));

                Global.RO.Info("Validate sync returned XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED");
                // Invalid request client should return error
                if (hr != xonline.common.service.HResult.XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED)
                    throw new Exception("Unexpected XError returned by server: " + hr.ToString("x") + " Expecting: " + xonline.common.service.HResult.XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED.ToString("x"));

                Global.RO.Info("Validating row count from t_user_console_audit_list");
                int count = ProfileWS.UserConsoleAuditListCount(user);

                if (count != 0)
                    throw new Exception("Unexpected count returned for user from t_user_console_audit_list: " + count + " expecting: 0");
            }
        }

        [TestCase, Description("Invalid Xbox 1 Client Type to XRLUploadConsoleAuditList")]
        // Test case to try with an Xbox One Client 
        public class N_InvalidXbox1Client : TestNode
        {
            public N_InvalidXbox1Client() { }

            public override void Run()
            {
                uint hr;
                ulong user = 823;

                // Clear the user
                ProfileWS.ResetUserConsoleAuditList(user);

                byte[] consoleId = new byte[] { 0x11, 0x22, 0x33, 0x44, 0x55 };

                // Call upload with just the one consoleId for all consoleID fields
                Global.RO.Info("Sync Single Console List");
                XRLUploadConsoleListRequest req = new XRLUploadConsoleListRequest(user, consoleId);

                // Set the ClientType to Xbox 1 for the request
                hr = req.PostXRLUploadConsoleListRequest(user, req, CSGInfo.ClientType.Xbox);
                Global.RO.Info("Uploading Console: " + ConsoleIdData.GetDecimalValue(consoleId));

                Global.RO.Info("Validate sync returned XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED");
                // Invalid request client should return error
                if (hr != xonline.common.service.HResult.XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED)
                    throw new Exception("Unexpected XError returned by server: " + hr.ToString("x") + " Expecting: " + xonline.common.service.HResult.XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED.ToString("x"));

                Global.RO.Info("Validating row count from t_user_console_audit_list");
                int count = ProfileWS.UserConsoleAuditListCount(user);

                if (count != 0)
                    throw new Exception("Unexpected count returned for user from t_user_console_audit_list: " + count + " expecting: 0");
            }
        }

        /* CSGInfo doesn't actually have an equivalent to XOn.XPLT_INTERNAL - not sure how to test that default case?
        [TestCase, Description("Invalid XenonBackCompat Client Type to XRLUploadConsoleAuditList")]
        // Test case to try with an XenonBackCompat Client 
        public class N_InvalidXenonBackCompatClient : TestNode
        {
            public N_InvalidXenonBackCompatClient() { }

            public override void  Run()
            {
                uint hr;
                ulong user = 824;

                // Clear the user
                ProfileWS.ResetUserConsoleAuditList(user);

                byte[] consoleId = new byte[] { 0x11, 0x22, 0x33, 0x44, 0x55 };

                // Call upload with just the one consoleId for all consoleID fields
                Global.RO.Info("Sync Single Console List");
                XRLUploadConsoleListRequest req = new XRLUploadConsoleListRequest(user, consoleId);

                // Set the ClientType to XenonBackCompat for the request
                hr = req.PostXRLUploadConsoleListRequest(user, req, CSGInfo.ClientType.XenonBackCompat);
                Global.RO.Info("Uploading Console: " + ConsoleIdData.GetDecimalValue(consoleId));

                Global.RO.Info("Validate sync returned XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED");
                // Invalid request client should return error
                if (hr != xonline.common.service.HResult.XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED)
                    throw new Exception("Unexpected XError returned by server: " + hr.ToString("x") + " Expecting: " + xonline.common.service.HResult.XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED.ToString("x"));

                Global.RO.Info("Validating row count from t_user_console_audit_list");
                int count = ProfileWS.UserConsoleAuditListCount(user);
                if (count != 0)
                    throw new Exception("Unexpected count returned for user from t_user_console_audit_list: " + count + " expecting: 0");
            }
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamerprofile\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_achievement_none_12.4.56.0_none_6aa92fc6e635d5e2
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=achievement
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2.manifest
XP_MANIFEST_PATH=manifests\msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2.cat
XP_CATALOG_PATH=manifests\msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2.cat
XP_PAYLOAD_PATH=msil_achievement_no-public-key_12.4.56.0_x-ww_f3b56cb2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=achievement,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamerprofile\PSyncEnumAvatarAssets.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.AvatarAsset;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.webplatform.livecache;

namespace Achievement
{
    [TestGroup, TestFrequency("Regression"), Description("Test Cases for Sync and Enum AvatarAsset APIs in xstatsfd.dll")]
    public class PSyncEnumAvatarAssets : TestNode
    {
        // These are for the Permission cases
        public static ulong OwnerInvUser = 0;
        public static ulong UserInvOwner = 0;

        public PSyncEnumAvatarAssets()
        {
            //XLAST Title breakdown for these tests
            //Title 200 - 5 assets, all unisex
            //Title 201 - 34 assets, all unisex
            //Title 202 - 5 assets, male and female
            //Title 203 - 5 assets, all unisex, PC and Xbox 360 Cross Platform Title
            //Title 204 - 5 assets, all unisex, all with ShowUnachieved set to FALSE

            // Positive Tests Cases
            AddChild(new P_EmptySync(200, 600));
            AddChild(new P_SyncEnumSingleAsset(200, 601));
            AddChild(new P_SyncEnumOfflineEarned(200, 602));
            AddChild(new P_SyncEnumMultiAssets(202, 603));
            AddChild(new P_SyncEnumMaxAssets(201, 604));
            AddChild(new P_SyncMoreFlagsPending(201, 605));
            AddChild(new P_SyncResponseNotAchievableFlag(200, 606));
            AddChild(new P_EnumNotAchievableFlag(200, 607));
            AddChild(new P_SyncNonDefaultLocale(200, 608));
            AddChild(new P_EnumNonDefaultLocale(200, 609));
            AddChild(new P_SyncEnumCrossPlatformTitle(203, 610));
            AddChild(new P_SyncEnumOfflineSequence(200, 611));
            AddChild(new P_SyncEnumOnlineOfflineMix(200, 612));
            AddChild(new P_SyncEnumNotShowUnachieved(204, 613));
            AddChild(new P_SyncEnumMultiTitle(200, 201, 203, 614));
            AddChild(new P_SyncEnumMultiTitleMaxPlus(200, 201, 615));
            AddChild(new P_EnumMultiTitleWithNotAchievableFlag(200, 201, 616));
            AddChild(new EnumRandomlyEarnedAvatarAssetsAllStartingIndices(200,601));
            AddChild(new EnumInOrderEarnedAvatarAssetsAllStartingIndices(200, 601));

            // Negative Test Cases
            AddChild(new N_SyncEnumNonExistentAsset(200, 620));
            AddChild(new N_SyncEnumNonExistentTitle(199, 621));  //Title not valid
            AddChild(new N_SyncPCClientXbox360PlatformOnly(200, 622));
            AddChild(new N_SyncXboxOneXbox360PlatformOnly(200, 623));
            AddChild(new N_SyncMaxPlusOneAssets(201, 624));
            AddChild(new N_EnumLocaleNotExist(200, 625));
            AddChild(new N_SyncInvalidStatusFlag(200, 626));

            // Permission Test Cases
            // These set the Profile Permission for the Owner, and then try various
            // users to query that data
            AddChild(new EnumAvatarActivityAllPermissions(200));
            AddChild(new EnumAvatarActivityFriendsOnly(200));
            AddChild(new EnumAvatarActivityNone(200));

            // These tests modify the SGInfo to possibly simulate a child account
            // although this is unknown to me, copying from Achievement code.
            AddChild(new ReadAvatarActivityAll(200));
            AddChild(new ReadAvatarActivityFriends(200));
            AddChild(new ReadAvatarActivityNone(200));

            // New Client Platforms Windows Mobile and WebGames
            AddChild(new SyncEnumSingleAssetValidWinMobile(98, 708));  // Title 98 is a Mobile Title
            AddChild(new SyncEnumSingleAssetValidWebGames(99, 709));  // Title 99 is a WebGames Title
            AddChild(new N_SyncEnumSingleAssetInvalidPlatformsFor360(51, 710));  // Title 51 is NOT a Mobile Title
            AddChild(new N_SyncEnumSingleAssetInvalid360PlatformsForWinMo(98, 711));  // Title 98 is NOT a 360 Title
            AddChild(new N_SyncEnumSingleAssetInvalid360PlatformsForWebGames(99, 712));  // Title 99 is NOT a 360 Title
            AddChild(new P_AvatarAssetSync_LiveCacheClient(98, 713));
        }

        /// <summary>
        /// Copied from livecache tests
        /// Internal class used to set Livecache privileges for access. The LiveCache client DLL only exposes the interface, and partner teams are expected 
        /// to implement the interface themselves to call any APIs that require authentication. This is an implementation for the test code that was created
        /// by copying the private implementation out of the client code.
        /// </summary>
        public class AuthSettings : IExtendedAuthDataProvider
        {
            private ulong _livePuid;
            private byte _tier;
            private uint[] _privileges;
            private byte clientType;
            public ulong XboxPuid { get { return 0; } }
            public byte ClientPlatform { get { return clientType; } set { clientType = value; } }

            public AuthSettings()
            {
                _livePuid = LivecacheRequest.PublicRequestLivePuid;
                _tier = 0;

                // hard code privileges to baseline level
                _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
                AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
                AddPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING);
            }

            public AuthSettings(ulong puid, LivecacheClientType clientType)
            {
                _livePuid = puid;
                _tier = 0;

                // hard code privileges to baseline level
                _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
                AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
                AddPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING);
                ClientPlatform = (byte)clientType;
            }

            public AuthSettings(LivecacheClientType clientType)
            {
                _livePuid = LivecacheRequest.PublicRequestLivePuid;
                _tier = 0;

                // hard code privileges to baseline level
                _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
                AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
                AddPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING);
                ClientPlatform = (byte)clientType;
            }

            private void AddPrivilege(int privilegeId)
            {
                uint mask = (uint)1 << (privilegeId % 32);
                _privileges[privilegeId / 32] |= mask;
            }

            public ulong LivePuid
            {
                get { return _livePuid; }
            }

            public byte Tier
            {
                get { return _tier; }
            }

            public uint[] Privileges
            {
                get { return _privileges; }
            }

            public IPEndPoint ClientIPEndPoint
            {
                get { return new IPEndPoint(0, 0); }
            }
        }

        // Stolen from the EnumAdditional test code for the permission stuff of Achievements
        // which we are also doing for the EnumAvatarAssets
        public override void PreRun()
        {

            FriendsCommon fc = new FriendsCommon();

            PNUser _Owner = fc.CreateUser(true);
            PNUser _Friend = fc.CreateUser(true);
            PNUser _nonFriend = fc.CreateUser(true);
            PNUser _OwnerInvUser = fc.CreateUser(true);
            PNUser _UserInvOwner = fc.CreateUser(true);

            try
            {
                fc.RequestFriend(_Owner, _OwnerInvUser);
                fc.RequestFriend(_UserInvOwner, _Owner);
                fc.MakeFriend(_Friend, _Owner);
            }
            catch (System.Exception e)
            {
                Global.RO.Warn("some of the test may fail because presence had problem" + e);
            }

            ulong Owner = _Owner.UserId;
            ulong friend = _Friend.UserId;
            ulong nonfriend = _nonFriend.UserId;
            OwnerInvUser = _OwnerInvUser.UserId;
            UserInvOwner = _UserInvOwner.UserId;

            AvatarAssetBase.init(Owner, friend, nonfriend);
        }
    }

    #region Positive Test Cases
    // Test case to simply call a sync with no data to sync, the console frequently does this
    // because all profile syncs (Profile, Titles, Achievements, Assets) are in the same call.
    [TestFrequency("Daily"), TestCasePriority(1), Description("Empty Sync")]
    public class P_EmptySync : AvatarAssetBase
    {
        public P_EmptySync(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // Sync request has no avatarassets in it
            Global.RO.Info("Sync Empty Asset");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { });
            SyncAvatarAssetsResponse resp = req.Execute();

            // verify the response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected for this user/title
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            Global.RO.Info("Enumerate Empty Asset");
            // Enumerate and make sure we have nothing for this user
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            // Need to validate the enum response with the assets sent up
            // We are just making sure that the first item was not achieved
            Global.RO.Info("Validate first asset ordinal=1, flags=0x00000008");
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != 1)
                throw new Exception("First Enum Avatar Item on Empty Sync was not first item.  Expected: 0, Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);
            // This asset in xlast allows show unachieved, so this flag is set and sent from the server
            if (enumresp.AvatarAssets[0].Flags != avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00000008, Received: 0x" + enumresp.AvatarAssets[0].Flags.ToString("x"));
        }
    }

    // Standard single unisex asset sync for a user
    [BVT, TestFrequency("BVT"), TestCasePriority(1), Description("Single Avatar Asset Sync BVT")]
    public class P_SyncEnumSingleAsset : AvatarAssetBase
    {
        public P_SyncEnumSingleAsset(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // Chose the 3rd item, so in the response we can see it comes first
            // Pass ShowUnachieved because we validate against this later, and the server will send that flag back because
            // it is set for this asset
            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync Single Asset");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.Execute();

            // Verify the response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            Global.RO.Info("Enum Single Asset");
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            Global.RO.Info("Validate first asset returned is ordinal=3, flags=0x00130008");
            // Need to validate the enum response with the assets sent up
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != 3)
                throw new Exception("First Enum Avatar Item was not most recently synced.  Expected: 3, Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[0].Flags != assets.Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00130008, Received: 0x" + enumresp.AvatarAssets[0].Flags.ToString("x"));
        }
    }

    // Offline Earned asset sync - earn online, then offline followed by online in one sync
    // this ensures that we are correctly putting the offline sync'ed item in between the right time stamp
    [TestFrequency("Daily"), TestCasePriority(1), Description("Offline Earned Sync")]
    public class P_SyncEnumOfflineEarned : AvatarAssetBase
    {
        public P_SyncEnumOfflineEarned(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            AvatarAssetWD assets = new AvatarAssetWD(2, (byte)3, 0, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.Execute();

            // Verify the response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // Skip some of the assets so we can make sure we get the right order later
            //TODO - need to say OFFLINE Earned, but the WD constructor always adds the online flag
            AvatarAssetWD assets1 = new AvatarAssetWD(4, (byte)3, 1, (int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, false);
            AvatarAssetWD assets2 = new AvatarAssetWD(3, (byte)3, 2, (int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, true);

            XRLSyncAvatarAssets req2 = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets1, assets2 });
            SyncAvatarAssetsResponse resp2 = req2.Execute();

            // Verify the response was ok
            if (resp2.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp2.xResult);

            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            Global.RO.Info("Validate first asset returned is ordinal=3, flags=0x00120008");
            // Need to validate the enum response with the assets sent up
            // In this instance we need to make sure the order is 3, 4, 2 and then the rest unearned.
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != 3)
                throw new Exception("First Enum Avatar Item was not most recently synced.  Expected: 3, Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[0].Flags != assets2.Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00120008, Received: 0x" + enumresp.AvatarAssets[0].Flags.ToString("x"));

            Global.RO.Info("Validate second asset returned is ordinal=4, flags=0x00120008");
            if (enumresp.AvatarAssets[1].AvatarAssetOrdinal != 4)
                throw new Exception("First Enum Avatar Item was not most recently synced.  Expected: 3, Received: " + enumresp.AvatarAssets[1].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[1].Flags != assets1.Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00120008, Received: 0x" + enumresp.AvatarAssets[1].Flags.ToString("x"));

            Global.RO.Info("Validate third asset returned is ordinal=2, flags=0x00130008");
            if (enumresp.AvatarAssets[2].AvatarAssetOrdinal != 2)
                throw new Exception("First Enum Avatar Item was not most recently synced.  Expected: 3, Received: " + enumresp.AvatarAssets[2].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[2].Flags != assets.Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00130008, Received: 0x" + enumresp.AvatarAssets[2].Flags.ToString("x"));
        }
    }

    // Sync multiple assets of male/female type for a single title/user
    [TestFrequency("Daily"), TestCasePriority(1), Description("Multiple Awards Sync")]
    public class P_SyncEnumMultiAssets : AvatarAssetBase
    {
        public P_SyncEnumMultiAssets(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // This title has 5 male/female assets, going to earn 2-5
            AvatarAssetWD[] assetList = new AvatarAssetWD[8];

            int iAssetOrdinal = 2;
            int i;
            for (i = 0; i < 8; i += 2)
            {
                assetList[i] = new AvatarAssetWD((uint)iAssetOrdinal, (byte)1, (uint)i + 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
                assetList[i + 1] = new AvatarAssetWD((uint)iAssetOrdinal, (byte)2, (uint)i + 2, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
                iAssetOrdinal++;
            }

            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, assetList);
            SyncAvatarAssetsResponse resp = req.Execute();

            // Make sure the server responded ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            // Need to validate the enum response with the assets sent up
            Global.RO.Info("Validating assets enumerated");

            i--;  // We incremented to 8, go down to 7

            for (int j = 0; j < 8; j += 2, i--)
            {
                Global.RO.Info("Validating returned asset " + j);
                // iAssetOrdinal still set to last item sync'ed above
                // Should see the female component
                if (enumresp.AvatarAssets[j].AvatarAssetOrdinal != assetList[i].AvatarAssetOrdinal)
                    throw new Exception("AvatarAssetOrdinal incorrect.  Expected: " + assetList[i].AvatarAssetOrdinal + ", Received: " + enumresp.AvatarAssets[j].AvatarAssetOrdinal);

                if (enumresp.AvatarAssets[j].Flags != assetList[i].Flags)
                    throw new Exception("Flags incorrect.  Expected: 0x00130008, Received: 0x" + enumresp.AvatarAssets[j].Flags.ToString("x"));

                if (enumresp.AvatarAssets[j].BodyTypeMask != assetList[i - 1].BodyTypeMask) // Male/Female assets are returned in the same order as inserted, not opposite
                    throw new Exception("BodyTypeMask.  Expected: " + assetList[i].BodyTypeMask + ", Received: " + enumresp.AvatarAssets[j].BodyTypeMask);

                i--;

                Global.RO.Info("Validating returned asset " + (j + 1));
                // Now the male component
                if (enumresp.AvatarAssets[j + 1].AvatarAssetOrdinal != assetList[i].AvatarAssetOrdinal)
                    throw new Exception("AvatarAssetOrdinal incorrect.  Expected: " + assetList[i].AvatarAssetOrdinal + ", Received: " + enumresp.AvatarAssets[j + 1].AvatarAssetOrdinal);

                if (enumresp.AvatarAssets[j + 1].Flags != assetList[i].Flags)
                    throw new Exception("Flags incorrect.  Expected: 0x00130008, Received: 0x" + enumresp.AvatarAssets[j + 1].Flags.ToString("x"));

                if (enumresp.AvatarAssets[j + 1].BodyTypeMask != assetList[i + 1].BodyTypeMask) // Male/Female assets are returned in the same order as inserted, not opposite
                    throw new Exception("BodyTypeMask.  Expected: " + assetList[i].BodyTypeMask + ", Received: " + enumresp.AvatarAssets[j + 1].BodyTypeMask);
            }
        }
    }

    // This test will try to get the MAX number of assets for a title you can get
    // That means that we are overriding the current number of 5 assets per title
    // with an xlast that has 32 assets to be able to test this
    [TestFrequency("Daily"), TestCasePriority(2), Description("Max Awards Sync")]
    public class P_SyncEnumMaxAssets : AvatarAssetBase
    {
        public P_SyncEnumMaxAssets(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            AvatarAssetWD[] assetList = new AvatarAssetWD[AvatarAssetConst.MAX_AvatarAssets];

            //Loop and create all MAX Assets (32)
            for (int i = 0; i < assetList.Length; i++)
            {
                assetList[i] = new AvatarAssetWD((uint)(i + 1), (byte)3, (uint)i, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            }

            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, assetList);
            SyncAvatarAssetsResponse resp = req.Execute();

            // Make sure the server responded ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            // Need to validate the enum response with the assets sent up
            Global.RO.Info("Validate first asset returned is ordinal=32, flags=0x00130008");
            // Need to validate the enum response with the assets sent up
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != assetList[AvatarAssetConst.MAX_AvatarAssets - 1].AvatarAssetOrdinal)
                throw new Exception("First Enum Avatar Item was not most recently synced.  Expected: 3, Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[0].Flags != assetList[AvatarAssetConst.MAX_AvatarAssets - 1].Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00130008, Received: " + enumresp.AvatarAssets[0].Flags.ToString("x"));

            Global.RO.Info("Validate last asset returned is ordinal=1, flags=0x00130008");
            // Need to validate the enum response with the assets sent up
            if (enumresp.AvatarAssets[AvatarAssetConst.MAX_AvatarAssets - 1].AvatarAssetOrdinal != assetList[0].AvatarAssetOrdinal)
                throw new Exception("First Enum Avatar Item was not last item synced.  Expected: 1, Received: " + enumresp.AvatarAssets[AvatarAssetConst.MAX_AvatarAssets - 1].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[AvatarAssetConst.MAX_AvatarAssets - 1].Flags != assetList[0].Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00130008, Received: " + enumresp.AvatarAssets[AvatarAssetConst.MAX_AvatarAssets - 1].Flags.ToString("x"));

        }
    }

    // Like the MAX Assets test, we are overriding the xlast with more than the 5 assets a 
    // title can have, in this case 34 assets.  This test will need to make multiple calls
    // to earn 34 assets for a user, and then do an empty sync to see that all 34 can't be returned
    // at once, at which point the MoreAvatarAssetPending will return true.
    public class P_SyncMoreFlagsPending : AvatarAssetBase
    {
        public P_SyncMoreFlagsPending(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            AvatarAssetWD[] assetList = new AvatarAssetWD[AvatarAssetConst.MAX_AvatarAssets];

            for (int i = 0; i < assetList.Length; i++)
            {
                assetList[i] = new AvatarAssetWD((uint)(i + 1), (byte)3, (uint)i, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            }

            Global.RO.Info("Sync First 32 assets (max in one sync request)");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, assetList);
            SyncAvatarAssetsResponse resp = req.Execute();

            // Make sure the server responded ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // Now get 2 more, so we exceed the max sync response amount of 32
            AvatarAssetWD assets1 = new AvatarAssetWD(33, (byte)3, 33, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AvatarAssetWD assets2 = new AvatarAssetWD(34, (byte)3, 34, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync 2 more assets for a total of 34 assets");
            XRLSyncAvatarAssets req2 = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets1, assets2 });
            SyncAvatarAssetsResponse resp2 = req2.Execute();

            // Make sure the server responded ok
            if (resp2.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp2.xResult);

            // Set the client version back (arbitrarily picked 9 years)]
            // So the empty sync will now send the server that it doesn't know about anything
            // and try to get all the data about the title from the server for this user
            DateTime clientver = DateTime.Now.AddYears(-9);

            Global.RO.Info("Now do an empty sync with old version to get all 34 assets");
            XRLSyncAvatarAssets req3 = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { }, clientver);
            SyncAvatarAssetsResponse resp3 = req3.Execute();

            // Make sure the server responded ok
            if (resp3.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp3.xResult);

            Global.RO.Info("Validating MoreAssets pending flag set to 1");
            // There should be 34 assets coming back, but only 32 allowed, so this flag better be set
            if (resp3.MoreAvatarAssetPending == 0)
                throw new Exception("Sync response should have More Assets pending flag set to 1, but it is set to 0");

            Global.RO.Info("Now do an empty sync with old version and index 32 to get the last 2 assets");
            // Set the starting index to 32, where we left off from the last sync
            XRLSyncAvatarAssets req4 = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { }, clientver, 32);
            SyncAvatarAssetsResponse resp4 = req4.Execute();

            // Make sure the server responded ok
            if (resp4.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp3.xResult);

            Global.RO.Info("Validating MoreAssets pending flag reset to 0");
            // Now we should have gotten them all
            if (resp4.MoreAvatarAssetPending == 1)
                throw new Exception("Unexpected MoreAvatarAssetPending Flag Set to 1");

        }
    }

    // If the XAVATAR_DETAILS_NOT_ACHIEVABLE flag is set, the sync response on new server version should still
    // include the avatar asset, but show that the flag is set so the client can process
    // this is different from achievements where the server does not send down achievements that
    // have that flag set.
    public class P_SyncResponseNotAchievableFlag : AvatarAssetBase
    {
        public P_SyncResponseNotAchievableFlag(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            uint assetOrdinal = (uint)2;

            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // First sync the achievement
            AvatarAssetWD assets = new AvatarAssetWD(assetOrdinal, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync Avatar Asset for the user prior to marking in NOT_ACHIEVABLE");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.Execute();

            // make sure the server response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            Global.RO.Info("Updating Sync'ed item in UODB to have the XAVATAR_NOT_ACHIEVABLE flag");
            // Now update the database to have the XAVATAR_NOT_ACHIEVABLE flag
            ProgressWS.MarkAvatarAssetNotAchievable(UWoner, _Title, assetOrdinal);

            // Set the client version back (arbitrarily picked 9 years)]
            // So the empty sync will now send the server that it doesn't know about anything
            // and try to get all the data about the title from the server for this user
            DateTime clientver = DateTime.Now.AddYears(-9);

            Global.RO.Info("Empty Sync with old version to get the NOT_ACHIEVABLE asset returned");
            XRLSyncAvatarAssets req2 = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { }, clientver, 0, locale);
            SyncAvatarAssetsResponse enumresp = req2.Execute();

            // make sure the server response was ok
            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + enumresp.xResult);

            // Need to validate that the Sync Response includes the item we just sync'ed, but
            // that it has the proper NOT_ACHIEVABLE flag set.
            Global.RO.Info("Validate asset returned is ordinal= " + assetOrdinal + ", flags=0x00140008");
            // Need to validate the enum response with the assets sent up
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != assetOrdinal)
                throw new Exception("First Enum Avatar Item was not last item synced.  Expected: " + assetOrdinal + ", Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);

            int notAchievableFlag = 0x00170008; // 1 = platform, 7 = achieved + achieved online + not achievable, 8 = show unachieved
            // Sync Response does not send down the SHOW_UNACHIEVED flag like an enum does
            if (enumresp.AvatarAssets[0].Flags != notAchievableFlag)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00140000, Received: 0x" + enumresp.AvatarAssets[0].Flags.ToString("x"));
        }
    }

    // If the XAVATAR_DETAILS_NOT_ACHIEVABLE flag is set, the enum response should still
    // include the avatar asset, but show that the flag is set so the client can process
    // this is different from achievements where the server does not send down achievements that
    // have that flag set.
    public class P_EnumNotAchievableFlag : AvatarAssetBase
    {
        public P_EnumNotAchievableFlag(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            uint assetOrdinal = (uint)2;

            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // First sync the achievement
            AvatarAssetWD assets = new AvatarAssetWD(assetOrdinal, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync Avatar Asset for the user prior to marking in NOT_ACHIEVABLE");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.Execute();

            // make sure the server response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            Global.RO.Info("Updating Sync'ed item in UODB to have the XAVATAR_NOT_ACHIEVABLE flag");
            // Now update the database to have the XAVATAR_NOT_ACHIEVABLE Flag
            ProgressWS.MarkAvatarAssetNotAchievable(UWoner, _Title, assetOrdinal);

            Global.RO.Info("Enum Avatar Asset for the user");
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            Global.RO.Info("Validate enum for NOT_ACHIEVABLE");
            // Need to validate the enum response with the assets sent up
            // Enum code will now return the Not Achievable awarded items in the ordinal order
            // and not at the beginning of the list. 
            // Check the 2nd item flags, not the first since we are awarding the 2 ordinal 
            if (enumresp.AvatarAssets[1].AvatarAssetOrdinal != assetOrdinal)
                throw new Exception("First Enum Avatar Item was not last item synced.  Expected: " + assetOrdinal + ", Received: " + enumresp.AvatarAssets[1].AvatarAssetOrdinal);

            // Enum code will now return the Not Achievable awarded items in the ordinal order
            // and not at the beginning of the list. 
            // Check the 2nd item flags, not the first since we are awarding the 2 ordinal 
            int notAchievableFlag = 0x00040008;
            if (enumresp.AvatarAssets[1].Flags != notAchievableFlag)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00140008, Received: 0x" + enumresp.AvatarAssets[1].Flags.ToString("x"));
        }
    }

    // Sync Response with a locale of FR-FR (which is set in the xlast file)
    [TestFrequency("Daily"), TestCasePriority(2), Description("Non Default Locale Sync Response")]
    public class P_SyncNonDefaultLocale : AvatarAssetBase
    {
        public P_SyncNonDefaultLocale(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            //FR-FR locale set for this 
            locale = 1036;
            // From Title 200 XLAST description string id 79 used by asset ordinal 2
            string FRFRDescriptionAsset2 = "le asset description 2";

            AvatarAssetWD assets = new AvatarAssetWD(2, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync Avatar Asset for the user");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.Execute();

            // make sure the server response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            // Set the client version back (arbitrarily picked 9 years)]
            // So the empty sync will now send the server that it doesn't know about anything
            // and try to get all the data about the title from the server for this user
            DateTime clientver = DateTime.Now.AddYears(-9);

            Global.RO.Info("Empty Sync with old version and locale set to FR-FR");
            XRLSyncAvatarAssets req2 = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { }, clientver, 0, locale);
            SyncAvatarAssetsResponse enumresp = req2.Execute();

            Global.RO.Info("Validating asset returned with correct locale description string of FR-FR");
            // make sure the server response was ok
            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + enumresp.xResult);

            // Validate the locale we get back is not the default locale but the FR-FR locale string
            if (enumresp.AvatarAssets[0].Description != FRFRDescriptionAsset2)
                throw new Exception("Locale incorrect for description.  Expected FR-FR string: " + FRFRDescriptionAsset2 + ", Received: " + enumresp.AvatarAssets[0].Description);
        }
    }

    // Enumerate with locale of FR-FR (which is set in the xlast file)
    [TestFrequency("Daily"), TestCasePriority(2), Description("Non Default Locale Enumeration")]
    public class P_EnumNonDefaultLocale : AvatarAssetBase
    {
        public P_EnumNonDefaultLocale(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            //FR-FR locale set for this 
            locale = 1036;
            // From Title 200 XLAST description string id 79 used by asset ordinal 2
            string FRFRDescriptionAsset2 = "le asset description 2";

            AvatarAssetWD assets = new AvatarAssetWD(2, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync Avatar Asset for the user");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.Execute();

            // make sure the server response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            Global.RO.Info("Enum Avatar Asset for the user with locale set to FR-FR");
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            Global.RO.Info("Validating asset returned with correct locale description string of FR-FR");
            // Validate the locale we get back is not the default locale but the FR-FR locale string
            if (enumresp.AvatarAssets[0].Description != FRFRDescriptionAsset2)
                throw new Exception("Locale incorrect for description.  Expected FR-FR string: " + FRFRDescriptionAsset2 + ", Received: " + enumresp.AvatarAssets[0].Description);
        }
    }

    // Other platforms are supported, although not used initially 
    // XLAST title will need to have both PC and Xbox 360 clients specified, and we will
    // award an item from the PC Client
    public class P_SyncEnumCrossPlatformTitle : AvatarAssetBase
    {
        public P_SyncEnumCrossPlatformTitle(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // In this case, the XPLT_PC doesn't matter, the Req will override it.  We need to actually pass the req
            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 0, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_PC));
            //AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 0, avatarassetflags.SetPlatformTypeInFlags((int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_PC));

            Global.RO.Info("Sync Avatar Asset for the user with PC Client type set");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets }, CSGInfo.ClientType.PC);
            SyncAvatarAssetsResponse resp = req.Execute();

            //make sure the server responded with an ok since this title supports PC and 360alright
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            Global.RO.Info("Enum Avatar Asset for the user with 360 client type");
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            Global.RO.Info("Validate first asset returned is ordinal=3, flags=0x00230008");
            // Need to validate the enum response with the assets sent up
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != 3)
                throw new Exception("First Enum Avatar Item was not most recently synced.  Expected: 3, Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[0].Flags != assets.Flags)
                throw new Exception("Flags incorrectly returned.  Expected: " + assets.Flags.ToString("x") + ", Received: 0x" + enumresp.AvatarAssets[0].Flags.ToString("x"));
        }
    }

    // Offline Sync of multiple asset awards, with the Sequence numbers set
    // to validate server awarding is done in the correct order
    public class P_SyncEnumOfflineSequence : AvatarAssetBase
    {
        public P_SyncEnumOfflineSequence(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            AvatarAssetWD assets = new AvatarAssetWD(2, (byte)3, 0, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync Avatar Asset for the user earned online");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.Execute();

            // Verify the response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            Global.RO.Info("Sync Avatar Assets for the user earned offline for sequence check");
            // Sequence passed out of order, so we can make sure we get the right order later
            AvatarAssetWD assets1 = new AvatarAssetWD(4, (byte)3, 1, (int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, false);
            AvatarAssetWD assets2 = new AvatarAssetWD(3, (byte)3, 3, (int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, false);
            AvatarAssetWD assets3 = new AvatarAssetWD(1, (byte)3, 2, (int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, false);

            XRLSyncAvatarAssets req2 = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets1, assets2, assets3 });
            SyncAvatarAssetsResponse resp2 = req2.Execute();

            // Verify the response was ok
            if (resp2.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp2.xResult);

            Global.RO.Info("Enum Avatar Assets for the user");
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            // Need to validate the enum response with the assets sent up
            // In this instance we need to make sure the order is 3, 1, 4, 2 and then the rest unearned.
            // Check asset2's settings against the enumresp for the first item.
            Global.RO.Info("Validate first asset, Avatar Asset Ordinal 3, Sequence 3, Flags 0x00120008");
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != assets2.AvatarAssetOrdinal)
                throw new Exception("First Enum Avatar Item was not most recently synced.  Expected: 3, Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[0].Flags != assets2.Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00120008, Received: 0x" + enumresp.AvatarAssets[0].Flags.ToString("x"));

            if (enumresp.AvatarAssets[0].Sequence != assets2.Sequence)
                throw new Exception("Sequence incorrectly returned.  Expected: 3, Received: " + enumresp.AvatarAssets[0].Sequence);

            Global.RO.Info("Validate last earned asset, Avatar Asset Ordinal 2, Sequence 0, Flags 0x00130008");
            if (enumresp.AvatarAssets[3].AvatarAssetOrdinal != assets.AvatarAssetOrdinal)
                throw new Exception("Last earned enum Avatar Item was not correct.  Expected: 2, Received: " + enumresp.AvatarAssets[3].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[3].Flags != assets.Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00130008, Received: 0x" + enumresp.AvatarAssets[3].Flags.ToString("x"));

            if (enumresp.AvatarAssets[3].Sequence != assets.Sequence)
                throw new Exception("Sequence incorrectly returned.  Expected: 0, Received: " + enumresp.AvatarAssets[3].Sequence);
        }
    }

    // Online followed by 2 Offline awards to validate sequencing
    public class P_SyncEnumOnlineOfflineMix : AvatarAssetBase
    {
        public P_SyncEnumOnlineOfflineMix(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // Skip some of the assets so we can make sure we get the right order later
            AvatarAssetWD assets1 = new AvatarAssetWD(4, (byte)3, 1, (int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, true);
            AvatarAssetWD assets2 = new AvatarAssetWD(2, (byte)3, 3, (int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, false);
            AvatarAssetWD assets3 = new AvatarAssetWD(1, (byte)3, 2, (int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, false);

            Global.RO.Info("Sync Avatar Assets for the user with online and offline assets earned");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets1, assets2, assets3 });
            SyncAvatarAssetsResponse resp = req.Execute();

            // Verify the response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            Global.RO.Info("Enum Avatar Assets for the user");
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            Global.RO.Info("Validating Avatar Assets for the user");
            // Need to validate the enum response with the assets sent up
            // In this instance we need to make sure the order is 2, 1, 4 and then the rest unearned.
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != assets2.AvatarAssetOrdinal)
                throw new Exception("Avatar Item was not most recently synced.  Expected: 2, Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[0].Flags != assets2.Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x" + assets2.Flags.ToString("x") + ", Received: " + enumresp.AvatarAssets[0].Flags.ToString("x"));

            if (enumresp.AvatarAssets[0].Sequence != assets2.Sequence)
                throw new Exception("Sequence incorrectly returned.  Expected: 3, Received: " + enumresp.AvatarAssets[0].Sequence);
        }
    }

    // Sync Test with Assets that are hidden until earned
    public class P_SyncEnumNotShowUnachieved : AvatarAssetBase
    {
        public P_SyncEnumNotShowUnachieved(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // Chose the 3rd item, so in the response we can see it comes first
            // Pass ShowUnachieved because we validate against this later, and the server will send that flag back because
            // it is set for this asset
            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync Avatar Assets for the user");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.Execute();

            // Verify the response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            Global.RO.Info("Enum Avatar Assets for the user");
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            Global.RO.Info("Validating Avatar Assets for the user");
            // Need to validate the enum response with the assets sent up
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != assets.AvatarAssetOrdinal)
                throw new Exception("First Enum Avatar Item was not most recently synced.  Expected: 3, Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);

            // ShowUnachieved flag was not sent down
            if (enumresp.AvatarAssets[0].Flags != assets.Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00130000, Received: 0x" + enumresp.AvatarAssets[0].Flags.ToString("x"));
        }
    }

    // Sync assets for multiple titles and enumerate across titles
    [TestFrequency("Daily"), TestCasePriority(1), Description("Multiple Title Enum")]
    public class P_SyncEnumMultiTitle : AvatarAssetBase
    {
        public uint[] _Titles;

        public P_SyncEnumMultiTitle(uint title1, uint title2, uint title3, ulong user)
            : base()
        {
            // Start with the titles out of order
            _Titles = new uint[] { title2, title1, title3 };
            UWoner = user;
        }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // each title has at least 5 unisex assets, going to earn 2-5
            AvatarAssetWD[] assetList = new AvatarAssetWD[]{
                new AvatarAssetWD(2, 3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360)),
                new AvatarAssetWD(3, 3, 2, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360)),
                new AvatarAssetWD(4, 3, 3, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360)),
                new AvatarAssetWD(5, 3, 4, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360))
            };

            // Award assets from each title
            foreach (uint title in _Titles)
            {
                XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(title, UWoner, assetList);
                SyncAvatarAssetsResponse resp = req.Execute();

                // Make sure the server responded ok
                if (resp.xResult != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + resp.xResult);

                // The server sent something back, but this is unexpected.
                if (resp.AvatarAssetsCount > 0)
                    throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);
            }

            // We want all awards, so pass title == 0
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(0, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            // Need to validate the enum response with the assets sent up
            Global.RO.Info("Validating assets enumerated");

            // The assets should come back sorted by title id.
            Array.Sort(_Titles);

            for (int i = 0; i < _Titles.Length * assetList.Length; ++i)
            {
                Global.RO.Info("Validating returned asset " + i);

                int iAsset = i % assetList.Length;
                int iTitle = i / assetList.Length;

                AvatarAssetId assetId = new AvatarAssetId(new Guid(enumresp.AvatarAssets[i].AvatarAssetId));
                if (assetId.TitleId != _Titles[iTitle])
                    throw new Exception("AvatarAsset title incorrect.  Expected: " + _Titles[iTitle] + ", Received: " + assetId.TitleId);

                if (enumresp.AvatarAssets[i].AvatarAssetOrdinal != assetList[iAsset].AvatarAssetOrdinal)
                    throw new Exception("AvatarAssetOrdinal incorrect.  Expected: " + assetList[iAsset].AvatarAssetOrdinal + ", Received: " + enumresp.AvatarAssets[i].AvatarAssetOrdinal);

                if (enumresp.AvatarAssets[i].Flags != assetList[iAsset].Flags)
                    throw new Exception("Flags incorrect.  Expected: 0x00130008, Received: 0x" + enumresp.AvatarAssets[i].Flags.ToString("x"));

                if (enumresp.AvatarAssets[i].BodyTypeMask != assetList[iAsset].BodyTypeMask)
                    throw new Exception("BodyTypeMask.  Expected: " + assetList[iAsset].BodyTypeMask + ", Received: " + enumresp.AvatarAssets[i].BodyTypeMask);
            }
        }
    }

    // Multiple Title Enum with more than Max Assets to retrieve
    [TestFrequency("Regression"), TestCasePriority(2), Description("Multiple Title Enum with more than Max Assets to retrieve")]
    public class P_SyncEnumMultiTitleMaxPlus : AvatarAssetBase
    {
        public uint[] _Titles;

        public P_SyncEnumMultiTitleMaxPlus(uint title1, uint title2, ulong user)
            : base()
        {
            // Start with the titles out of order
            _Titles = new uint[] { title2, title1 };
            UWoner = user;
        }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            AvatarAssetWD[] assetList = new AvatarAssetWD[AvatarAssetConst.MAX_AvatarAssets];

            //Loop and create all MAX Assets (32)
            for (int i = 0; i < assetList.Length; i++)
            {
                assetList[i] = new AvatarAssetWD((uint)(i + 1), (byte)3, (uint)i, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            }

            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Titles[0], UWoner, assetList);
            SyncAvatarAssetsResponse resp = req.Execute();

            // Make sure the server responded ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            // each title has at least 5 unisex assets, going to earn 2-5
            AvatarAssetWD[] assetList2 = new AvatarAssetWD[]{
                new AvatarAssetWD(2, 3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360)),
                new AvatarAssetWD(3, 3, 2, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360)),
                new AvatarAssetWD(4, 3, 3, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360)),
                new AvatarAssetWD(5, 3, 4, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360))
            };

            XRLSyncAvatarAssets req2 = new XRLSyncAvatarAssets(_Titles[1], UWoner, assetList2);
            SyncAvatarAssetsResponse resp2 = req2.Execute();

            // Make sure the server responded ok
            if (resp2.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp2.xResult);

            // The server sent something back, but this is unexpected.
            if (resp2.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp2.AvatarAssetsCount);

            // now enum avatar assets with titleid=0, which allows for querying for all earned title awards
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(0, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            // Need to validate the enum response with the assets sent up
            Global.RO.Info("Validate first asset returned is ordinal=2, flags=0x00130008");
            // Need to validate the enum response with the assets sent up
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != assetList2[0].AvatarAssetOrdinal)
                throw new Exception("First asset was not the first title first earned asset.  Returned asset ordinal= " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[0].Flags != assetList2[0].Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00130008, Received: " + enumresp.AvatarAssets[0].Flags.ToString("x"));

            // The items come back in sorted title order, so we need to check _Title[1] first
            AvatarAssetId assetId = new AvatarAssetId(new Guid(enumresp.AvatarAssets[0].AvatarAssetId));
            if (assetId.TitleId != _Titles[1])
                throw new Exception("AvatarAsset title incorrect.  Expected: " + _Titles[1] + ", Received: " + assetId.TitleId);

            assetId = new AvatarAssetId(new Guid(enumresp.AvatarAssets[4].AvatarAssetId));
            if (assetId.TitleId != _Titles[0])
                throw new Exception("AvatarAsset title incorrect.  Expected: " + _Titles[0] + ", Received: " + assetId.TitleId);

            // the 5th asset should be the first asset in the second title.
            if (enumresp.AvatarAssets[4].AvatarAssetOrdinal != assetList[0].AvatarAssetOrdinal)
                throw new Exception("First asset was not the first asset ordinal = " + enumresp.AvatarAssets[4].AvatarAssetOrdinal);
        }
    }


    // Not achievable marked assets do not enumerate
    [TestFrequency("Regression"), TestCasePriority(3), Description("Not achievable marked assets do not enumerate")]
    public class P_EnumMultiTitleWithNotAchievableFlag : AvatarAssetBase
    {
        public uint[] _Titles;

        public P_EnumMultiTitleWithNotAchievableFlag(uint title1, uint title2, ulong user)
            : base()
        {
            // Start with the titles out of order
            _Titles = new uint[] { title2, title1 };
            UWoner = user;
        }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // each title has at least 5 unisex assets, going to earn 2-5
            AvatarAssetWD[] assetList = new AvatarAssetWD[]{
                new AvatarAssetWD(2, 3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360)),
                new AvatarAssetWD(3, 3, 2, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360)),
                new AvatarAssetWD(4, 3, 3, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360)),
                new AvatarAssetWD(5, 3, 4, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360))
            };

            // Award assets from each title
            foreach (uint title in _Titles)
            {
                XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(title, UWoner, assetList);
                SyncAvatarAssetsResponse resp = req.Execute();

                // Make sure the server responded ok
                if (resp.xResult != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + resp.xResult);

                // The server sent something back, but this is unexpected.
                if (resp.AvatarAssetsCount > 0)
                    throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);
            }

            Global.RO.Info("Updating Sync'ed item in UODB to have the XAVATAR_NOT_ACHIEVABLE flag");
            // Now update the database to have the XAVATAR_NOT_ACHIEVABLE flag
            // for the 3rd asset ordinal for each title sync'ed
            uint assetOrdinal = (uint)3;
            ProgressWS.MarkAvatarAssetNotAchievable(UWoner, _Titles[0], assetOrdinal);
            ProgressWS.MarkAvatarAssetNotAchievable(UWoner, _Titles[1], assetOrdinal);

            // We want all awards, so pass title == 0
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(0, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            // Need to validate the enum response with the assets sent up
            Global.RO.Info("Validating assets enumerated");

            if (enumresp.AvatarAssetsCount != 6)
                throw new Exception("AvatarAsset count incorrect.  Expected 6, Received: " + enumresp.AvatarAssetsCount.ToString());
        }
    }

    #endregion

    #region Negative Test Cases
    // NEGATIVE CASES
    // Sync to the server a bad avatar asset and ensure the server handles it
    public class N_SyncEnumNonExistentAsset : AvatarAssetBase
    {
        public N_SyncEnumNonExistentAsset(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // Asset 100 does not exist for the title
            AvatarAssetWD assets = new AvatarAssetWD(100, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync non existent asset for the user");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.Execute();

            //verify the server response was ok, even though we sent up an invalid asset
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            Global.RO.Info("Enum Avatar Assets for the user");
            // Now get the enum and we can make sure we didn't get something back set
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + enumresp.xResult);

            Global.RO.Info("Validating No Avatar Assets earned for the user");
            // Flag should be set to SHOWUNACHIEVED only
            if (enumresp.AvatarAssets[0].Flags != avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00000008, Received: 0x" + enumresp.AvatarAssets[0].Flags.ToString("x"));
        }
    }

    // Sync an asset for a non existent title and make sure the server ignores it and succeeds
    public class N_SyncEnumNonExistentTitle : AvatarAssetBase
    {
        public N_SyncEnumNonExistentTitle(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            AvatarAssetWD assets = new AvatarAssetWD(0, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync avatar asset for non existent title");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.Execute();

            //make sure the server response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            Global.RO.Info("Enum avatar asset for non existent title");

            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            Global.RO.Info("Validate enum returned S_OK");
            //make sure the server response was S_OK since the service ignores assets when the titleconfig is not found
            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + enumresp.xResult);
        }
    }

    // Other platforms are supported, but in this case, the xlast says it is a 360 title only
    // and we are trying to sync the asset from an PC client platform, which shouldn't be allowed for this title
    public class N_SyncPCClientXbox360PlatformOnly : AvatarAssetBase
    {
        public N_SyncPCClientXbox360PlatformOnly(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // In this case, the XPLT_PC doesn't matter, the Req will override it.  We need to actually pass the req
            AvatarAssetWD assets = new AvatarAssetWD(4, (byte)3, 0, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_PC));

            Global.RO.Info("Sync avatar asset from PC client for xbox 360 only title");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets }, CSGInfo.ClientType.PC);
            SyncAvatarAssetsResponse resp = req.Execute();

            Global.RO.Info("Validate sync returned XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED");
            //make sure the server responded with an error since this shouldn't have been awardable
            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);
        }
    }

    // Other platforms are supported, but in this case, the xlast says it is a 360 title only
    // and we are trying to sync the asset from an xbox1 platform, which shouldn't be allowed
    // This case is different from a PC client sync, because PC is a valid type, just not for that title
    // but an Xbox 1 Client is always invalid.
    public class N_SyncXboxOneXbox360PlatformOnly : AvatarAssetBase
    {
        public N_SyncXboxOneXbox360PlatformOnly(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // In this case, the XPLT_PC doesn't matter, the Req will override it.  We need to actually pass the req
            AvatarAssetWD assets = new AvatarAssetWD(4, (byte)3, 0, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX1));

            Global.RO.Info("Sync avatar asset from xbox1 client for xbox 360 only title");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets }, CSGInfo.ClientType.Xbox);
            SyncAvatarAssetsResponse resp = req.Execute();

            Global.RO.Info("Validate sync returned XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED");
            //make sure the server responded with an error since this shouldn't have been awardable
            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);
        }
    }

    // Try to sync one more than the max allowed assets for a title in one sync
    // and the server should not allow this
    public class N_SyncMaxPlusOneAssets : AvatarAssetBase
    {
        public N_SyncMaxPlusOneAssets(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            // Make Max plus 1 assets to sync up
            AvatarAssetWD[] assetList = new AvatarAssetWD[AvatarAssetConst.MAX_AvatarAssets + 1];

            for (int i = 0; i < assetList.Length; i++)
            {
                assetList[i] = new AvatarAssetWD((uint)(i + 1), (byte)3, (uint)i, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            }
            Global.RO.Info("Sync max plus 1 avatar assets");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, assetList);
            SyncAvatarAssetsResponse resp = req.Execute();

            Global.RO.Info("Validate Sync returned E_INVALIDARG");
            // Is this the response we will get back?
            if (resp.xResult != HResult.XONLINE_E_DESERIALIZATION_ERROR)
                throw new Exception("Unexpected Hresult : " + resp.xResult + " was expecting E_INVALIDARG");
        }
    }

    // If you send up a non existent locale or one that isn't set in the xlast, 
    // the default Locale for the xlast should be returned.
    public class N_EnumLocaleNotExist : AvatarAssetBase
    {
        public N_EnumLocaleNotExist(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);
            // I don't know what 1037 is, but it's not a valid locale for this title
            locale = 1037;

            AvatarAssetWD assets = new AvatarAssetWD(2, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync avatar asset for user");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.Execute();

            // Verify the response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            Global.RO.Info("Enum avatar assets for user with non existent locale");
            // Enumerate with the locale we want to try to get, which isn't valid
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            // Validate the locale we get back is the default locale since 1037 isn't defined in the xlast tool.
            Global.RO.Info("Validate asset locale correctly returned with titles default locale");
            // Validate the locale we get back is not the default locale but the EN-US locale string
            // this is the default EN-US string stored in xlast for the asset2 item.
            string descriptionAsset2 = "description 2";
            if (enumresp.AvatarAssets[0].Description != descriptionAsset2)
                throw new Exception("Locale incorrect for description.  Expected EN-US string: " + descriptionAsset2 + ", Received: " + enumresp.AvatarAssets[0].Description);
        }
    }

    // Sync an asset for a non existent title and make sure the server handles it.
    public class N_SyncInvalidStatusFlag : AvatarAssetBase
    {
        public N_SyncInvalidStatusFlag(uint title, ulong user) : base(title, user) { }

        public override void Run()
        {
            // Clean out the database for this user
            ClearAvatarAsset(UWoner);

            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED | avatarassetflags.XAVATAR_DETAILS_NOT_ACHIEVABLE, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync avatar asset with invalid Sync Flag of Not Achievable");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.Execute();

            //make sure the server response was ok - even though the award is rejected
            //the server still returns ok so the entire request isn't dumped for this one failure.
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            Global.RO.Info("Enum avatar asset for non existent title");
            // TODO:  What happens here, if you enum on a title that doesn't exist?
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            Global.RO.Info("Validate first asset returned is ordinal=0, flags=0x00000008");
            // Need to validate the enum response shows the first item for the title (since we shouldn't have any)
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != 1)
                throw new Exception("First Enum Avatar should be first for the title.  Expected: 0, Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[0].Flags != avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00000008, Received: 0x" + enumresp.AvatarAssets[0].Flags.ToString("x"));
        }
    }

    #endregion

    #region Permission Test Cases
    // PERMISSION based cases
    // Currently none of these tests are important because you can't view another gamertag's avatar award
    public class ReadAvatarActivityAll : AvatarAssetBase
    {
        public ReadAvatarActivityAll(uint title) : base(title) { }

        public override void Run()
        {
            this.UWoner = Owner;
            ClearAvatarAsset(Owner);

            // Chose the 2nd and 3rd item, so in the response we can see it comes first
            AvatarAssetWD assets1 = new AvatarAssetWD(2, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AvatarAssetWD assets2 = new AvatarAssetWD(3, (byte)3, 2, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync assets for owner for permission tests");
            XRLSyncAvatarAssets sreq = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets1, assets2 });
            SyncAvatarAssetsResponse sresp = sreq.Execute();

            // Verify the response was ok
            if (sresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError on Sync returned by server " + sresp.xResult);


            //self
            Global.RO.Info("Reading Self");
            XRLEnumAvatarAsset req = new XRLEnumAvatarAsset(Title, Owner, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            req.Modifyflag = AuthModify.Read_Activity_All;
            AvatarAssetEnumResponse enumresp = req.Execute();
            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected S_OK):" + enumresp.xResult);

            // friend
            Global.RO.Info("Reading friend");
            XRLEnumAvatarAsset req1 = new XRLEnumAvatarAsset(Title, Friend, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            req1.Modifyflag = AuthModify.Read_Activity_All;
            AvatarAssetEnumResponse enumresp1 = req1.Execute();
            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected S_OK):" + enumresp.xResult);

            // nonfriend
            Global.RO.Info("Reading non friend");
            XRLEnumAvatarAsset req2 = new XRLEnumAvatarAsset(Title, NonFriend, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            req2.Modifyflag = AuthModify.Read_Activity_All;
            AvatarAssetEnumResponse enumresp2 = req2.Execute();
            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected S_OK):" + enumresp.xResult);
        }

    }

    public class ReadAvatarActivityFriends : AvatarAssetBase
    {
        public ReadAvatarActivityFriends(uint title) : base(title) { }

        public override void Run()
        {
            this.UWoner = Owner;
            ClearAvatarAsset(Owner);

            // Chose the 2nd and 3rd item, so in the response we can see it comes first
            AvatarAssetWD assets1 = new AvatarAssetWD(2, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AvatarAssetWD assets2 = new AvatarAssetWD(3, (byte)3, 2, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync assets for owner for permission tests");
            XRLSyncAvatarAssets sreq = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets1, assets2 });
            SyncAvatarAssetsResponse sresp = sreq.Execute();

            // Verify the response was ok
            if (sresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError on Sync returned by server " + sresp.xResult);


            //self
            Global.RO.Info("Reading Self");
            XRLEnumAvatarAsset req = new XRLEnumAvatarAsset(Title, Owner, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            req.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            AvatarAssetEnumResponse enumresp = req.Execute();
            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected S_OK):" + enumresp.xResult);

            // friend
            Global.RO.Info("Reading friend");
            XRLEnumAvatarAsset req1 = new XRLEnumAvatarAsset(Title, Friend, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            req1.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            AvatarAssetEnumResponse enumresp1 = req1.Execute();
            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected S_OK):" + enumresp.xResult);

            // nonfriend
            Global.RO.Info("Reading non friend");
            XRLEnumAvatarAsset req2 = new XRLEnumAvatarAsset(Title, NonFriend, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            req2.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            AvatarAssetEnumResponse enumresp2 = req2.Execute();
            if (enumresp2.xResult != HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                throw new Exception("Invalid XError (Expected Permission Denied):" + enumresp2.xResult);
        }

    }

    public class ReadAvatarActivityNone : AvatarAssetBase
    {
        public ReadAvatarActivityNone(uint title) : base(title) { }

        public override void Run()
        {
            this.UWoner = Owner;
            ClearAvatarAsset(Owner);

            // Chose the 2nd and 3rd item, so in the response we can see it comes first
            AvatarAssetWD assets1 = new AvatarAssetWD(2, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AvatarAssetWD assets2 = new AvatarAssetWD(3, (byte)3, 2, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync assets for owner for permission tests");
            XRLSyncAvatarAssets sreq = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets1, assets2 });
            SyncAvatarAssetsResponse sresp = sreq.Execute();

            // Verify the response was ok
            if (sresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError on Sync returned by server " + sresp.xResult);


            //self
            Global.RO.Info("Reading Self");
            XRLEnumAvatarAsset req = new XRLEnumAvatarAsset(Title, Owner, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            req.Modifyflag = AuthModify.Read_Activity_None;
            AvatarAssetEnumResponse enumresp = req.Execute();
            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected S_OK):" + enumresp.xResult);

            // friend
            Global.RO.Info("Reading friend");
            XRLEnumAvatarAsset req1 = new XRLEnumAvatarAsset(Title, Friend, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            req1.Modifyflag = AuthModify.Read_Activity_None;
            AvatarAssetEnumResponse enumresp1 = req1.Execute();
            if (enumresp1.xResult != HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                throw new Exception("Invalid XError (Expected Permission Denied):" + enumresp1.xResult);

            // nonfriend
            Global.RO.Info("Reading non friend");
            XRLEnumAvatarAsset req2 = new XRLEnumAvatarAsset(Title, NonFriend, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            req2.Modifyflag = AuthModify.Read_Activity_None;
            AvatarAssetEnumResponse enumresp2 = req2.Execute();
            if (enumresp2.xResult != HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                throw new Exception("Invalid XError (Expected Permission Denied):" + enumresp2.xResult);
        }
    }

    public class EnumAvatarActivityAllPermissions : AvatarAssetBase
    {
        public EnumAvatarActivityAllPermissions(uint title) : base(title) { }

        public override void Run()
        {
            this.UWoner = Owner;
            ClearAvatarAsset(Owner);

            // Chose the 2nd and 3rd item, so in the response we can see it comes first
            AvatarAssetWD assets1 = new AvatarAssetWD(2, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AvatarAssetWD assets2 = new AvatarAssetWD(3, (byte)3, 2, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync assets for owner for permission tests");
            XRLSyncAvatarAssets sreq = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets1, assets2 });
            SyncAvatarAssetsResponse sresp = sreq.Execute();

            // Verify the response was ok
            if (sresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError on Sync returned by server " + sresp.xResult);

            //self
            XRLEnumAvatarAsset req = new XRLEnumAvatarAsset(Title, Owner, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = req.Execute();

            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected S_OK):" + enumresp.xResult);

            // friend
            XRLEnumAvatarAsset req1 = new XRLEnumAvatarAsset(Title, Owner, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp1 = req1.Execute();

            if (enumresp1.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected S_OK):" + enumresp1.xResult);

            // nonfriend
            XRLEnumAvatarAsset req2 = new XRLEnumAvatarAsset(Title, Owner, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp2 = req2.Execute();

            if (enumresp2.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected S_OK):" + enumresp2.xResult);
        }
    }

    public class EnumAvatarActivityFriendsOnly : AvatarAssetBase
    {
        public EnumAvatarActivityFriendsOnly(uint title) : base(title) { }

        public override void Run()
        {
            addPermission(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);
            this.UWoner = Owner;
            ClearAvatarAsset(Owner);

            // Chose the 2nd and 3rd item, so in the response we can see it comes first
            AvatarAssetWD assets1 = new AvatarAssetWD(2, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AvatarAssetWD assets2 = new AvatarAssetWD(3, (byte)3, 2, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync assets for owner for permission tests");
            XRLSyncAvatarAssets sreq = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets1, assets2 });
            SyncAvatarAssetsResponse sresp = sreq.Execute();

            // Verify the response was ok
            if (sresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError on Sync returned by server " + sresp.xResult);


            //self
            XRLEnumAvatarAsset req = new XRLEnumAvatarAsset(Title, Owner, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = req.Execute();

            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected S_OK):" + enumresp.xResult);

            // friend
            XRLEnumAvatarAsset req1 = new XRLEnumAvatarAsset(Title, Owner, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp1 = req1.Execute();

            if (enumresp1.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected S_OK):" + enumresp1.xResult);

            // nonfriend
            XRLEnumAvatarAsset req2 = new XRLEnumAvatarAsset(Title, Owner, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp2 = req2.Execute();

            if (enumresp2.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected Permission Denied):" + enumresp2.xResult);
        }
    }

    public class EnumAvatarActivityNone : AvatarAssetBase
    {
        public EnumAvatarActivityNone(uint title) : base(title) { }

        public override void Run()
        {
            addPermission(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE);
            this.UWoner = Owner;
            ClearAvatarAsset(Owner);

            // Chose the 2nd and 3rd item, so in the response we can see it comes first
            AvatarAssetWD assets1 = new AvatarAssetWD(2, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AvatarAssetWD assets2 = new AvatarAssetWD(3, (byte)3, 2, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync assets for owner for permission tests");
            XRLSyncAvatarAssets sreq = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets1, assets2 });
            SyncAvatarAssetsResponse sresp = sreq.Execute();

            // Verify the response was ok
            if (sresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError on Sync returned by server " + sresp.xResult);


            //self
            XRLEnumAvatarAsset req = new XRLEnumAvatarAsset(Title, Owner, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = req.Execute();

            if (enumresp.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected S_OK):" + enumresp.xResult);

            // friend
            XRLEnumAvatarAsset req1 = new XRLEnumAvatarAsset(Title, Owner, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp1 = req1.Execute();

            if (enumresp1.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected Permission Denied):" + enumresp1.xResult);

            // nonfriend
            XRLEnumAvatarAsset req2 = new XRLEnumAvatarAsset(Title, Owner, Owner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp2 = req2.Execute();

            if (enumresp2.xResult != HResult.S_OK)
                throw new Exception("Invalid XError (Expected Permission Denied):" + enumresp2.xResult);
        }
    }
    #endregion

    // -- Valid Platform Tests new Clients (Windows Mobile and Web Games)--
    [TestFrequency("BVT"), TestCasePriority(1), Description("BVT for Windows Mobile Avatar Asset Sync")]
    public class SyncEnumSingleAssetValidWinMobile : AvatarAssetBase
    {
        public SyncEnumSingleAssetValidWinMobile(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAvatarAsset(UWoner);

            // Chose the 3rd item, so in the response we can see it comes first
            // Pass ShowUnachieved because we validate against this later, and the server will send that flag back because
            // it is set for this asset
            //AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_MOBILE));            
            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1, avatarassetflags.SetPlatformTypeInFlags((int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_MOBILE));

            Global.RO.Info("Sync Single Asset");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });

            // call the ExecuteInt function with the proper XPLT and XPLTOnBehalfOf
            SyncAvatarAssetsResponse resp = req.ExecuteInt(xonline.common.service.XOn.XPLT_INTERNAL_LIVEN, xonline.common.service.XOn.XPLT_MOBILE);

            Global.RO.Info("Syncing Avatar Asset from Mobile...");

            // Verify the response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            Global.RO.Info("Enum Single Asset");
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            Global.RO.Info("Validate first asset returned is ordinal=3, flags=0x00330008");
            // Need to validate the enum response with the assets sent up
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != 3)
                throw new Exception("First Enum Avatar Item was not most recently synced.  Expected: 3, Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[0].Flags != assets.Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00330008, Received: 0x" + enumresp.AvatarAssets[0].Flags.ToString("x"));
        }
    }

    [TestFrequency("BVT"), TestCasePriority(1), Description("BVT for WebGames Avatar Asset Sync")]
    public class SyncEnumSingleAssetValidWebGames : AvatarAssetBase
    {
        public SyncEnumSingleAssetValidWebGames(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAvatarAsset(UWoner);

            // Chose the 3rd item, so in the response we can see it comes first
            // Pass ShowUnachieved because we validate against this later, and the server will send that flag back because
            // it is set for this asset
            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1, avatarassetflags.SetPlatformTypeInFlags((int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_WEB_GAMES));

            Global.RO.Info("Sync Single Asset");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });

            // call the ExecuteInt function with the proper XPLT and XPLTOnBehalfOf
            SyncAvatarAssetsResponse resp = req.ExecuteInt(xonline.common.service.XOn.XPLT_INTERNAL_LIVEN, xonline.common.service.XOn.XPLT_WEB_GAMES);

            Global.RO.Info("Syncing Avatar Asset from Web Games...");

            // Verify the response was ok
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);

            // The server sent something back, but this is unexpected.
            if (resp.AvatarAssetsCount > 0)
                throw new Exception("Unexpected Assets returned.  Count=" + resp.AvatarAssetsCount);

            Global.RO.Info("Enum Single Asset");
            XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, 0, AvatarAssetConst.MAX_AvatarAssets);
            AvatarAssetEnumResponse enumresp = ereq.Execute();

            Global.RO.Info("Validate first asset returned is ordinal=3, flags=0x00430008");
            // Need to validate the enum response with the assets sent up
            if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != 3)
                throw new Exception("First Enum Avatar Item was not most recently synced.  Expected: 3, Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);

            if (enumresp.AvatarAssets[0].Flags != assets.Flags)
                throw new Exception("Flags incorrectly returned.  Expected: 0x00430008, Received: 0x" + enumresp.AvatarAssets[0].Flags.ToString("x"));
        }
    }

    public class N_SyncEnumSingleAssetInvalidPlatformsFor360 : AvatarAssetBase
    {
        public N_SyncEnumSingleAssetInvalidPlatformsFor360(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAvatarAsset(UWoner);

            // Chose the 3rd item, so in the response we can see it comes first
            // Pass ShowUnachieved because we validate against this later, and the server will send that flag back because
            // it is set for this asset
            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1, avatarassetflags.SetPlatformTypeInFlags((int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_MOBILE));

            Global.RO.Info("Sync Single Asset");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse resp = req.ExecuteInt(xonline.common.service.XOn.XPLT_INTERNAL_LIVEN, xonline.common.service.XOn.XPLT_MOBILE);

            Global.RO.Info("Validate sync returned XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED");
            //make sure the server responded with an error since this shouldn't have been awardable
            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);
        }
    }

    public class N_SyncEnumSingleAssetInvalid360PlatformsForWinMo : AvatarAssetBase
    {
        public N_SyncEnumSingleAssetInvalid360PlatformsForWinMo(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAvatarAsset(UWoner);

            // Chose the 3rd item, so in the response we can see it comes first
            // Pass ShowUnachieved because we validate against this later, and the server will send that flag back because
            // it is set for this asset
            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1, avatarassetflags.SetPlatformTypeInFlags((int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync Single Asset");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });

            // Call 360 sync, for a Mobile title
            SyncAvatarAssetsResponse resp = req.Execute();

            Global.RO.Info("Validate sync returned XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED");
            //make sure the server responded with an error since this shouldn't have been awardable
            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);
        }
    }

    public class N_SyncEnumSingleAssetInvalid360PlatformsForWebGames : AvatarAssetBase
    {
        public N_SyncEnumSingleAssetInvalid360PlatformsForWebGames(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAvatarAsset(UWoner);

            // Chose the 3rd item, so in the response we can see it comes first
            // Pass ShowUnachieved because we validate against this later, and the server will send that flag back because
            // it is set for this asset
            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1, avatarassetflags.SetPlatformTypeInFlags((int)avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            Global.RO.Info("Sync Single Asset");
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { assets });

            // Call 360 sync, for a Mobile title
            SyncAvatarAssetsResponse resp = req.Execute();

            Global.RO.Info("Validate sync returned XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED");
            //make sure the server responded with an error since this shouldn't have been awardable
            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED)
                throw new Exception("Unexpected XError returned by server " + resp.xResult);
        }
    }

    // LiveCache test - actually makes call through live Cache as a LIVEn client type
    [TestFrequency("Daily"), TestCasePriority(1), Description("Validate Avatar Award sync from LiveCache client"), Ignore]
    public class P_AvatarAssetSync_LiveCacheClient : AvatarAssetBase
    {
        public P_AvatarAssetSync_LiveCacheClient(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {

            Global.RO.Info("Sync Avatar Awards");

            /*
            xonline.common.protocol.AvatarAsset[] assetList = new xonline.common.protocol.AvatarAsset[1];
            assetList[0] = new xonline.common.protocol.AvatarAsset();
            assetList[0].AvatarAssetId = new byte[1]{3};
            assetList[0].BodyTypeMask = (byte)3;
            assetList[0].Sequence = 0;
            assetList[0].Flags = (int)xonline.common.service.XOn.XAVATAR_DETAILS_ACHIEVED | (int)xonline.common.service.XOn.XAVATAR_DETAILS_ACHIEVED_ONLINE;

            LcAchievement LcAch = new LcAchievement(LivecacheClientType.LIVEn, XOn.WEB_TITLE_ID, new PSyncEnumAvatarAssets.AuthSettings(UWoner, LivecacheClientType.LIVEn));
            // Had to not use the test implementation of this becuase of the stats call requiring this
            xonline.common.protocol.SyncAvatarAssetRequest req = new xonline.common.protocol.SyncAvatarAssetRequest();
            req.UserId = UWoner;
            req.TitleId = _Title;
            req.AvatarAssets = assetList;
            req.AvatarAssetCount = (ushort)assetList.Length;

            try
            {
                xonline.common.protocol.SyncAvatarAssetResponse resp = LcAch.SyncAvatarAssets(req,);
                
                t(req, new ValidateAvatarManifest.AuthSettings(Userid, LivecacheClientType.LIVEn));
            }
            catch (Exception e)
            {
                Global.RO.Error(e.Message);
                ResultCode = TEST_RESULTS.FAILED;
            }
            
            Global.RO.Info("Validate the result");
            */
        }

    }

    public class EnumRandomlyEarnedAvatarAssetsAllStartingIndices : AvatarAssetBase
    {
        public EnumRandomlyEarnedAvatarAssetsAllStartingIndices(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            // Expected order of returned avatar assets is:
            // 5
            // 3
            // 1
            // 2
            // 4

            uint[] expectedAssetOrdinals = new uint[] { 5, 3, 1, 2, 4 };
            const uint totalAvatarAssets = 5;

            for (uint startingIndex = 0; startingIndex < 5; ++startingIndex)
            {
                ClearAvatarAsset(UWoner);

                Global.RO.Info("Enum with startingIndex: " + startingIndex);

                // Populate the user with some assets
                AvatarAssetWD asset1 = new AvatarAssetWD(1, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
                AvatarAssetWD asset2 = new AvatarAssetWD(3, (byte)3, 2, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
                AvatarAssetWD asset3 = new AvatarAssetWD(5, (byte)3, 3, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

                XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { asset1, asset2, asset3 });
                SyncAvatarAssetsResponse resp = req.Execute();
                if (resp.xResult != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + resp.xResult);

                // Send the enum request
                XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, (ushort)startingIndex, AvatarAssetConst.MAX_AvatarAssets);
                AvatarAssetEnumResponse enumresp = ereq.Execute();

                // Verify the assets were returned in the correct order
                uint[] currentExpectedOrdinals = new uint[totalAvatarAssets - startingIndex];
                Array.Copy(expectedAssetOrdinals, startingIndex, currentExpectedOrdinals, 0, totalAvatarAssets - startingIndex);

                if (currentExpectedOrdinals.Length != enumresp.AvatarAssets.Length)
                {
                    throw new Exception("Expected and actual avatar asset lengths do not match! Expected: " + currentExpectedOrdinals.Length + " Actual: " + enumresp.AvatarAssets.Length);
                }

                for (int i = 0; i < totalAvatarAssets - startingIndex; ++i)
                {
                    if (currentExpectedOrdinals[i] != enumresp.AvatarAssets[i].AvatarAssetOrdinal)
                    {
                        throw new Exception("Ordinals do not match as expected. Expected: " + currentExpectedOrdinals[i] + " Actual: " + enumresp.AvatarAssets[i].AvatarAssetOrdinal);
                    }
                }
            }
        }
    }

    public class EnumInOrderEarnedAvatarAssetsAllStartingIndices : AvatarAssetBase
    {
        public EnumInOrderEarnedAvatarAssetsAllStartingIndices(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            // Expected order of returned avatar assets is:
            // 3
            // 2
            // 1
            // 4
            // 5

            uint[] expectedAssetOrdinals = new uint[] { 3, 2, 1, 4, 5 };
            const uint totalAvatarAssets = 5;

            for (uint startingIndex = 0; startingIndex < 5; ++startingIndex)
            {
                ClearAvatarAsset(UWoner);

                Global.RO.Info("Enum with startingIndex: " + startingIndex);

                // Populate the user with some assets
                AvatarAssetWD asset1 = new AvatarAssetWD(2, (byte)3, 1, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
                AvatarAssetWD asset2 = new AvatarAssetWD(3, (byte)3, 2, BuildAvatarAssetWDFlagForPlatform(avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

                XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(_Title, UWoner, new AvatarAssetWD[] { asset1, asset2 });
                SyncAvatarAssetsResponse resp = req.Execute();
                if (resp.xResult != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + resp.xResult);

                // Send the enum request
                XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(_Title, UWoner, UWoner, locale, (ushort)startingIndex, AvatarAssetConst.MAX_AvatarAssets);
                AvatarAssetEnumResponse enumresp = ereq.Execute();

                // Verify the assets were returned in the correct order
                uint[] currentExpectedOrdinals = new uint[totalAvatarAssets - startingIndex];
                Array.Copy(expectedAssetOrdinals, startingIndex, currentExpectedOrdinals, 0, totalAvatarAssets - startingIndex);

                if (currentExpectedOrdinals.Length != enumresp.AvatarAssets.Length)
                {
                    throw new Exception("Expected and actual avatar asset lengths do not match! Expected: " + currentExpectedOrdinals.Length + " Actual: " + enumresp.AvatarAssets.Length);
                }

                for (int i = 0; i < totalAvatarAssets - startingIndex; ++i)
                {
                    if (currentExpectedOrdinals[i] != enumresp.AvatarAssets[i].AvatarAssetOrdinal)
                    {
                        throw new Exception("Ordinals do not match as expected. Expected: " + currentExpectedOrdinals[i] + " Actual: " + enumresp.AvatarAssets[i].AvatarAssetOrdinal);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamerprofile\PSyncEnum.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.LiveService.FakeSG;

namespace Achievement
{
    /// <summary>
    /// Summary description for PSyncEnum.
    /// </summary>
    [TestGroup, TestFrequency("Regression"), Description("Test Cases for Sync and Enum Achievement APIs in xstatsfd.dll")]
    public class PSyncEnum : TestNode
    {
        public PSyncEnum()
        {
            AddChild(new SyncEnumSingleAchievements(50, 601));
            AddChild(new SyncEnumNonExistantAchievements(100, 602));
            AddChild(new SyncEnumMultipleAchievements(50, 603));
            AddChild(new SyncEnumMultAchievementsMultTitle(623)); //duplicate 
            AddChild(new SyncEnumMax_1Achievements(51, 606));
            AddChild(new SyncEnumMaxAchievements(52, 607));
            AddChild(new StartIdxEqualSize(54, 612));
            AddChild(new StartIdxEqualSizeP1(54, 613));
            AddChild(new MaxSyncResponse(53, 615));
            AddChild(new SyncEnumAchievementsLocaleFR(50, 616));
            AddChild(new SyncEnumNonexistingLocale(50, 617));
            AddChild(new SGAuthDiffentTitle(50, 618));

            // invalid
            AddChild(new InvalidMaxPlus1Achievements(52, 619));
            AddChild(new DuplicateAchievements(52, 620));
            AddChild(new SGAuthDiffUser(50, 621));
            AddChild(new TCInvalidSmallPKT());
            AddChild(new TCInvalidLargePKT());

            //multiprofile tests
            AddChild(new SPMAOnOffLine(50, 622));
            AddChild(new SPMAOnOffLine2(50, 623));
            AddChild(new PanoramaAnd360(50, 624));
            AddChild(new PanoramaAndDash(50, 625));
            AddChild(new SameAch360onlineandPanorama(50, 626));
            AddChild(new SameAch360offlinesync360andPanorama(50, 627));
            AddChild(new SameAchPanoramaAnd360online(50, 628));
            AddChild(new SameAch360offlineandPanoramaAnd360sync(50, 629));
            AddChild(new SameAch360offlinesync360FailedPanorama(50, 630));
            AddChild(new TESTCASE_1_3_2(50, 630));
            AddChild(new MultiProfileSyncFailed(50, 631));
            AddChild(new LegacyOnOffLine(50, 632));
            AddChild(new LegacyOnOffLine2(50, 633));

            //new languages
            AddChild(new SyncEnumAchievementsLocale_ZH_PL_RU(97, 634));

            // Bad Client (PC/Xbox1) Achievement Syncs
            AddChild(new SyncEnumSingleAchievementsBadClients(50, 701));
            AddChild(new SyncEnumNonExistantAchievementsBadClients(100, 702));
            AddChild(new SyncEnumMultipleAchievementsBadClients(50, 703));
            AddChild(new SyncEnumMultAchievementsMultTitleBadClients(704));

            // Valid Clients Platform-bit Specified Achievement Sync
            AddChild(new SyncEnumSingleAchievementValid360(51, 705)); // Title 51 has PlatformBit in XLAST define for just Xbox 360
            AddChild(new SyncEnumSingleAchievementValid360AndPCFrom360(52, 706)); // Title 52 has both Xbox 360 and PC
            AddChild(new SyncEnumSingleAchievementValid360AndPCFromPC(52, 707));

            // New Client Platforms Windows Mobile and WebGames
            AddChild(new SyncEnumSingleAchievementValidWinMobile(98, 708));  // Title 98 is a Mobile Title
            AddChild(new SyncEnumSingleAchievementValidWebGames(99, 709));  // Title 99 is a WebGames Title
            AddChild(new N_SyncEnumSingleAchievementInvalidPlatformsFor360(51, 710));
            AddChild(new N_SyncEnumSingleAchievementInvalid360PlatformsForWinMo(98, 711));
            AddChild(new N_SyncEnumSingleAchievementInvalid360PlatformsForWebGames(99, 711));
        }

        public class TCInvalidSmallPKT : TestNode
        {
            public override void Run()
            {
                InvalidXRLRequest tmp = new InvalidXRLRequest(10, "/xstats/syncachievements.ashx");
                uint xerror = tmp.Execute();
                if (xerror != HResult.XONLINE_E_END_OF_STREAM)
                    throw new Exception("Invalid Xerror Expected :" + HResult.E_FAIL + " received:" + xerror);
            }
        }

        public class TCInvalidLargePKT : TestNode
        {
            public override void Run()
            {
                InvalidXRLRequest tmp = new InvalidXRLRequest(1000 * 100, "/xstats/syncachievements.ashx");
                uint xerror = tmp.Execute();
                if (xerror != xonline.common.service.HResult.XONLINE_E_DESERIALIZATION_ERROR)
                    throw new Exception("Invalid XError Expected :" + xonline.common.service.HResult.XONLINE_E_DESERIALIZATION_ERROR.ToString("X") + " received:" + xerror.ToString("X"));
            }
        }

        public static int BuildAchievementWDFlagForPlatform(uint flag, byte clientType)
        {
            uint newFlags = flag & ~xonline.common.service.XOn.XACHIEVEMENT_DETAILS_PLATFORM_MASK;

            uint achFlag = (uint)MapPlatformTypeFlags((int)clientType);

            newFlags |= achFlag & xonline.common.service.XOn.XACHIEVEMENT_DETAILS_PLATFORM_MASK;

            return (int)newFlags;
        }

        // Function added to map the XPL_* platform flags to the XACHIEVEMENT_DETAILS_* flags
        // which was needed when we added Windows Mobile and WebGames Platforms that can now earn achievements
        public static int MapPlatformTypeFlags(int platformType)
        {
            uint achFlag = 0;

            switch (platformType)
            {
                case xonline.common.service.XOn.XPLT_XBOX360:
                    achFlag = xonline.common.service.XOn.XACHIEVEMENT_DETAILS_PLATFORM_360;
                    break;
                case xonline.common.service.XOn.XPLT_PC:
                    achFlag = xonline.common.service.XOn.XACHIEVEMENT_DETAILS_PLATFORM_PC;
                    break;
                case xonline.common.service.XOn.XPLT_MOBILE:
                    achFlag = xonline.common.service.XOn.XACHIEVEMENT_DETAILS_PLATFORM_MOBILE;
                    break;
                case xonline.common.service.XOn.XPLT_WEB_GAMES:
                    achFlag = xonline.common.service.XOn.XACHIEVEMENT_DETAILS_PLATFORM_WEB_GAMES;
                    break;
                default:
                    break;
            }
            return (int)achFlag;
        }
    }

    //Legacy
    public class LegacyOnOffLine2 : AchivementBase
    {
        public LegacyOnOffLine2(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);
            EarnedLAchievement(userp1, 1);
            EarnedLAchievement(userp1, 2);
            AchievementsEarned(userp1, 3, false, DateTime.UtcNow);

            Thread.Sleep(2000);
            SyncAchievementsResponse resp = AchievementsEarned(userp1, 4, true, DateTime.UtcNow);
            verify(resp, null);
        }
    }

    public class LegacyOnOffLine : AchivementBase
    {
        public LegacyOnOffLine(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);
            EarnedLAchievement(userp1, 1);
            EarnedLAchievement(userp1, 2);

            Thread.Sleep(2000);
            SyncAchievementsResponse resp = AchievementsEarned(userp1, 3, true, DateTime.UtcNow);
            verify(resp, null);
        }
    }

    public class MultiProfileSyncFailed : AchivementBase
    {
        public MultiProfileSyncFailed(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            //KKLINE - this test case is now fixed! The order will be {6,5,2,1,4,3}
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);
            DateTime lastversion = DateTime.UtcNow;
            AchievementsEarned(userp1, 1, false, DateTime.UtcNow);
            Thread.Sleep(1000);
            AchievementsEarned(userp1, 2, true, DateTime.UtcNow, false);

            Thread.Sleep(10000);
            UserAchProfile panoramaP1 = new UserAchProfile(UWoner, _Title);
            panoramaP1.SortIndex = 2;
            AchievementsEarned(panoramaP1, 3, false, lastversion);
            Thread.Sleep(1000);
            SyncAchievementsResponse resp2 = AchievementsEarned(panoramaP1, 4, true, lastversion);

            // KKLINE - Fixed the problem by adding these Achievements to userp1
            // so that when we verify, it's in the correct order
            userp1.AchievementsEarned.Add(panoramaP1.AchievementsEarned[0]);
            userp1.AchievementsEarned.Add(panoramaP1.AchievementsEarned[1]);
            Thread.Sleep(10000);
            userp1.SortIndex = userp1.SortIndex + 2;
            AchievementsEarned(userp1, 5, false, lastversion);
            SyncAchievementsResponse resp = AchievementsEarned(userp1, 6, true, lastversion);
            verify(resp, new uint[] { 3, 4 });
        }
    }

    public class SameAch360offlinesync360FailedPanorama : AchivementBase
    {
        public SameAch360offlinesync360FailedPanorama(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);

            SyncAchievementsResponse resp = AchievementsEarned(userp1, 1, true, DateTime.UtcNow);
            Thread.Sleep(10000);
            //AchievementsEarned(userp1, 2, false, resp.Version);  //KKLINE - comment out, not needed for this case
            AchievementsEarned(userp1, 3, true, resp.Version, false);

            Thread.Sleep(10000);
            UserAchProfile panoramaP1 = new UserAchProfile(UWoner, _Title);
            //panoramaP1.machinePuid = 0xFB00000012341234;  //panorama machines look like this.
            SyncAchievementsResponse resp2 = AchievementsEarned(panoramaP1, 3, true, DateTime.UtcNow);
            verify(resp2, null);
            Thread.Sleep(10000);
            resp = AchievementsEarned(userp1, 0, true, resp.Version);
            verify(resp, new uint[] { 3 });
        }
    }

    public class TESTCASE_1_3_2 : AchivementBase
    {
        public TESTCASE_1_3_2(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);

            SyncAchievementsResponse resp = AchievementsEarned(userp1, 1, true, DateTime.UtcNow);
            Thread.Sleep(10000);
            AchievementsEarned(userp1, 3, true, resp.Version, false);
            Thread.Sleep(10000);
            AchievementsEarned(userp1, 2, false, resp.Version);

            Thread.Sleep(10000);
            UserAchProfile panoramaP1 = new UserAchProfile(UWoner, _Title);
            //          panoramaP1.machinePuid = 0xFB00000012341234;  //panorama machines look like this.
            SyncAchievementsResponse resp2 = AchievementsEarned(panoramaP1, 3, true, DateTime.UtcNow);
            verify(resp2, null);
            Thread.Sleep(10000);
            resp = AchievementsEarned(userp1, 0, true, resp.Version);
            verify(resp, new uint[] { 3 });
        }
    }

    public class SameAch360onlineandPanorama : AchivementBase
    {
        public SameAch360onlineandPanorama(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);

            SyncAchievementsResponse resp = AchievementsEarned(userp1, 1, true, DateTime.UtcNow);
            Thread.Sleep(10000);
            resp = AchievementsEarned(userp1, 2, true, resp.Version);
            verify(resp, null);
            Thread.Sleep(10000);
            UserAchProfile panoramaP1 = new UserAchProfile(UWoner, _Title);
            SyncAchievementsResponse resp2 = AchievementsEarned(panoramaP1, 2, true, DateTime.UtcNow);
            verify(resp2, null);
            Thread.Sleep(10000);
            resp = AchievementsEarned(userp1, 0, true, resp.Version);
            verify(resp, null);
        }
    }

    public class SameAch360offlinesync360andPanorama : AchivementBase
    {
        public SameAch360offlinesync360andPanorama(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);

            SyncAchievementsResponse resp = AchievementsEarned(userp1, 1, true, DateTime.UtcNow);
            Thread.Sleep(10000);
            AchievementsEarned(userp1, 2, false, resp.Version);
            resp = AchievementsEarned(userp1, 0, true, resp.Version);
            verify(resp, null);
            Thread.Sleep(10000);
            UserAchProfile panoramaP1 = new UserAchProfile(UWoner, _Title);
            SyncAchievementsResponse resp2 = AchievementsEarned(panoramaP1, 2, true, DateTime.UtcNow);
            verify(resp2, null);
            Thread.Sleep(10000);
            resp = AchievementsEarned(userp1, 0, true, resp.Version);
            verify(resp, null);
        }
    }

    public class SameAchPanoramaAnd360online : AchivementBase
    {
        public SameAchPanoramaAnd360online(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);

            SyncAchievementsResponse resp = AchievementsEarned(userp1, 1, true, DateTime.UtcNow);
            Thread.Sleep(10000);

            UserAchProfile panoramaP1 = new UserAchProfile(UWoner, _Title);
            SyncAchievementsResponse resp2 = AchievementsEarned(panoramaP1, 2, true, DateTime.UtcNow);
            verify(resp2, null);
            Thread.Sleep(10000);
            resp = AchievementsEarned(userp1, 2, true, resp.Version);
            verify(resp, new uint[] { 2 });
        }
    }

    public class SameAch360offlineandPanoramaAnd360sync : AchivementBase
    {
        public SameAch360offlineandPanoramaAnd360sync(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);

            SyncAchievementsResponse resp = AchievementsEarned(userp1, 1, true, DateTime.UtcNow);
            Thread.Sleep(10000);
            AchievementsEarned(userp1, 2, false, resp.Version);
            Thread.Sleep(10000);
            UserAchProfile panoramaP1 = new UserAchProfile(UWoner, _Title);
            SyncAchievementsResponse resp2 = AchievementsEarned(panoramaP1, 2, true, DateTime.UtcNow);
            verify(resp2, null);
            Thread.Sleep(10000);
            resp = AchievementsEarned(userp1, 0, true, resp.Version);
            verify(resp, new uint[] { 2 });
        }
    }

    public class PanoramaAndDash : AchivementBase
    {
        public PanoramaAndDash(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);

            SyncAchievementsResponse resp = AchievementsEarned(userp1, 1, true, DateTime.UtcNow);
            Thread.Sleep(10000);
            resp = AchievementsEarned(userp1, 2, true, resp.Version);
            verify(resp, null);
            Thread.Sleep(10000);
            UserAchProfile panoramaP1 = new UserAchProfile(UWoner, _Title);
            SyncAchievementsResponse resp2 = AchievementsEarned(panoramaP1, 3, true, DateTime.UtcNow);
            verify(resp2, null);
            Thread.Sleep(10000);
            resp = AchievementsEarned(userp1, 0, true, resp.Version);
            verify(resp, new uint[] { 3 });
        }
    }

    public class PanoramaAnd360 : AchivementBase
    {
        public PanoramaAnd360(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);

            //Earn achievement 1 online
            SyncAchievementsResponse resp = AchievementsEarned(userp1, 1, true, DateTime.UtcNow);
            Thread.Sleep(10000);
            //Earn achievement 2 online
            resp = AchievementsEarned(userp1, 2, true, resp.Version);
            verify(resp, null);
            Thread.Sleep(10000);
            //Take another profile and earn achievement 3 online.  Note Panorama should give a
            //sequence number 1, because it's never been played before.
            UserAchProfile panoramaP1 = new UserAchProfile(UWoner, _Title);
            SyncAchievementsResponse resp2 = AchievementsEarned(panoramaP1, 3, true, DateTime.UtcNow);
            verify(resp2, null);
            Thread.Sleep(10000);
            resp = AchievementsEarned(userp1, 4, true, resp.Version);
            verify(resp, new uint[] { 3 });
        }
    }

    public class SPMAOnOffLine2 : AchivementBase
    {
        public SPMAOnOffLine2(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);

            SyncAchievementsResponse resp = AchievementsEarned(userp1, 1, true, DateTime.UtcNow);
            verify(resp, null);
            Thread.Sleep(5000);
            AchievementsEarned(userp1, 3, false, DateTime.UtcNow);
            resp = AchievementsEarned(userp1, 2, true, DateTime.UtcNow);
            verify(resp, null);
        }
    }

    public class SPMAOnOffLine : AchivementBase
    {
        public SPMAOnOffLine(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            UserAchProfile userp1 = new UserAchProfile(UWoner, _Title);

            SyncAchievementsResponse resp = AchievementsEarned(userp1, 1, true, DateTime.UtcNow);
            verify(resp, null);
            Thread.Sleep(5000);
            AchievementsEarned(userp1, 3, false, DateTime.UtcNow);
            resp = AchievementsEarned(userp1, 0, true, DateTime.UtcNow);
            verify(resp, null);
        }
    }

    public class SGAuthDiffentTitle : AchivementBase
    {
        public SGAuthDiffentTitle(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achive = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AddAchievementsToVerify(UWoner, _Title, achive);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive });
            req.Modifyflag = AuthModify.Change_Title;
            SyncAchievementsResponse resp = req.Execute();
            verify(resp, null);
        }
    }

    public class SGAuthDiffUser : AchivementBase
    {
        public SGAuthDiffUser(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achive = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AddAchievementsToVerify(UWoner, _Title, achive);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive });
            req.Modifyflag = AuthModify.Change_User;
            SyncAchievementsResponse resp = req.Execute();

            if (resp.xResult != HResult.XONLINE_E_SERVER_ERROR)
                throw new Exception("Invalid Xerror " + resp.xResult);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Duplicate Achievement Sync")]
    public class DuplicateAchievements : AchivementBase
    {
        public DuplicateAchievements(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            locale = (ushort)Locales.da_DK;
            ClearAchivement(UWoner);
            DateTime ver = DateTime.UtcNow;
            AchievementWD achive1 = new AchievementWD(1, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive2 = new AchievementWD(7, 2, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive3 = new AchievementWD(3, 3, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive4 = new AchievementWD(9, 4, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            AddAchievementsToVerify(UWoner, _Title, achive1);
            AddAchievementsToVerify(UWoner, _Title, achive2);
            AddAchievementsToVerify(UWoner, _Title, achive3);
            AddAchievementsToVerify(UWoner, _Title, achive4);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive1, achive2, achive3, achive2, achive4 }, DateTime.UtcNow, 0, locale);
            SyncAchievementsResponse resp = req.Execute();
            verify(resp, null);
        }
    }

    public class InvalidMaxPlus1Achievements : AchivementBase
    {
        public InvalidMaxPlus1Achievements(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            DateTime ver = DateTime.UtcNow;
            AchievementWD[] achievements = new AchievementWD[AchievConst.MAX_Achievement + 1];
            for (int i = 0; i < AchievConst.MAX_Achievement + 1; i++)
                achievements[i] = new AchievementWD((uint)(1 + i), (uint)(1 + i), PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, achievements, DateTime.UtcNow, 0, locale);
            SyncAchievementsResponse resp = req.Execute();

            if (resp.xResult != HResult.XONLINE_E_DESERIALIZATION_ERROR)
                throw new Exception("Unexpected Hresult : " + resp.xResult);
        }
    }

    public class SyncEnumNonexistingLocale : AchivementBase
    {
        public SyncEnumNonexistingLocale(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            locale = (ushort)Locales.da_DK;
            ClearAchivement(UWoner);
            DateTime ver = DateTime.UtcNow;
            AchievementWD achive1 = new AchievementWD(1, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive2 = new AchievementWD(7, 2, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive3 = new AchievementWD(3, 3, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive4 = new AchievementWD(9, 4, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            AddAchievementsToVerify(UWoner, _Title, achive1);
            AddAchievementsToVerify(UWoner, _Title, achive2);
            AddAchievementsToVerify(UWoner, _Title, achive3);
            AddAchievementsToVerify(UWoner, _Title, achive4);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive1, achive2, achive3, achive4 }, DateTime.UtcNow, 0, locale);
            SyncAchievementsResponse resp = req.Execute();
            verify(resp, null);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("FR Locale Sync Response")]
    public class SyncEnumAchievementsLocaleFR : AchivementBase
    {
        public SyncEnumAchievementsLocaleFR(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            locale = (ushort)Locales.fr_FR;
            ClearAchivement(UWoner);
            DateTime ver = DateTime.UtcNow;

            AchievementWD achive2 = new AchievementWD(7, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED | achievementflags.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive3 = new AchievementWD(3, 2, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED | achievementflags.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive4 = new AchievementWD(9, 3, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED | achievementflags.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED, XOn.XPLT_XBOX360));

            AddAchievementsToVerify(UWoner, _Title, achive2);
            AddAchievementsToVerify(UWoner, _Title, achive3);
            AddAchievementsToVerify(UWoner, _Title, achive4);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive2, achive3, achive4 });
            SyncAchievementsResponse resp = req.Execute();

            DateTime Server = resp.Version;
            DateTime ClientVer = Server.AddDays(-1);
            Thread.Sleep(500);
            AchievementWD achive1 = new AchievementWD(1, 4, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED | achievementflags.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED, XOn.XPLT_XBOX360));
            AddAchievementsToVerify(UWoner, _Title, achive1);
            XRLSyncAchievements req2 = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive1 }, ClientVer, 0, locale);
            SyncAchievementsResponse resp2 = req2.Execute();

            verifySingleWrite(resp2, new uint[] { 3, 7, 9 });

            //verify local using SGinfo
            XRLSyncAchievements req3 = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive1 }, ClientVer, 0, 0);
            req3.LanguageID = (uint)Languageids.fr;
            SyncAchievementsResponse resp3 = req3.Execute();
            verifySingleWrite(resp3, new uint[] { 1, 3, 7, 9 });
        }
    }

    public class SyncEnumAchievementsLocale_ZH_PL_RU : AchivementBase
    {
        public SyncEnumAchievementsLocale_ZH_PL_RU(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ushort[] locales = { (ushort)Locales.fr_FR,
                                  (ushort)Locales.zh_CHS, 
                                  (ushort)Locales.pl_PL, 
                                  (ushort)Locales.ru_RU };
            uint[] languageIDs = { (uint)Languageids.fr,
                                    (uint)Languageids.zh_chs,
                                    (uint)Languageids.pl,
                                    (uint)Languageids.ru };
            uint[] achievementToEarn = { 1, 11, 12, 13 };  //these three languages have strings in
            //the appropriate languages.
            DateTime ClientVer = DateTime.MinValue;  //use this to set a verison.

            for (int i = 0; i < locales.Length; i++)
            {
                Global.RO.Info("Running with languageID:" + languageIDs[i] + " and locale ID " + locale);
                locale = locales[i];
                ClearAchivement(UWoner);
                ClearExpectedAchievements();

                DateTime ver = DateTime.UtcNow;
                AchievementWD achievement = new AchievementWD(achievementToEarn[i], 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

                AddAchievementsToVerify(UWoner, _Title, achievement);
                XRLSyncAchievements req;
                SyncAchievementsResponse resp;
                if (i == 0)
                { //let's add it one way if i==0...
                    req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achievement });
                    req.LanguageID = (uint)languageIDs[i];
                }
                else
                {   //and try a second way if i!=0...
                    req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achievement }, ClientVer, 0, locale);
                }
                resp = req.Execute();
                DateTime Server = resp.Version;  //use this to prepare for the next time...
                ClientVer = Server.AddDays(-1);

                verify(resp, null);
                //			verifySingleWrite(resp,new uint[]{achievementToEarn[i]});
                Global.RO.Success("Language " + languageIDs[i] + " verifies correctly");
            }
        }
    }

    public class StartIdxEqualSizeP1 : AchivementBase
    {
        public StartIdxEqualSizeP1(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            DateTime Serversion = LoadAchievement(10, DateTime.UtcNow, 0xffffffff);
            Thread.Sleep(500);

            DateTime clientver = Serversion.AddDays(-1);

            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { }, clientver, 11);
            SyncAchievementsResponse resp = req.Execute();
            if (resp.TotalAchievements != 10)
                throw new Exception("Invalid TotalAchievements : " + resp.TotalAchievements);

            verifySingleWrite(resp, new uint[] { });
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Starting Index Sync")]
    public class StartIdxEqualSize : AchivementBase
    {
        public StartIdxEqualSize(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            DateTime Serversion = LoadAchievement(10, DateTime.UtcNow, 0xffffffff);
            Thread.Sleep(500);

            DateTime clientver = Serversion.AddDays(-1);

            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { }, clientver, 10);
            SyncAchievementsResponse resp = req.Execute();
            if (resp.TotalAchievements != 10)
                throw new Exception("Invalid TotalAchievements : " + resp.TotalAchievements);

            verifySingleWrite(resp, new uint[] { 10 });
        }
    }

    public class ServerVersionNewerThenClientwith45records : AchivementBase
    {
        public ServerVersionNewerThenClientwith45records(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            DateTime Serversion = LoadAchievement(AchievConst.MAX_Achievement + 10, DateTime.UtcNow, 0xffffffff);
            Thread.Sleep(500);

            DateTime clientver = Serversion.AddDays(-1);

            AchievementWD achive = new AchievementWD(43, (uint)AchievConst.MAX_Achievement + 11, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AddAchievementsToVerify(UWoner, _Title, achive);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive }, clientver, 0);
            SyncAchievementsResponse resp = req.Execute();
            if (resp.TotalAchievements != AchievConst.MAX_Achievement + 10)
                throw new Exception("Invalid TotalAchievements : " + resp.TotalAchievements);
            uint[] alist = new uint[AchievConst.MAX_Achievement];
            for (int i = 0; i < AchievConst.MAX_Achievement; i++)
            {
                alist[i] = (uint)(i + 1);
            }
            verifySingleWrite(resp, alist);

            XRLSyncAchievements req2 = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive }, clientver, 33);
            SyncAchievementsResponse resp2 = req2.Execute();
            uint[] alist2 = new uint[10];
            for (int i = 0; i < 10; i++)
            {
                alist2[i] = (uint)(i + 33);
            }
            verifySingleWrite(resp2, alist2);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Max Achievement Sync Response")]
    public class MaxSyncResponse : AchivementBase
    {
        public MaxSyncResponse(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            DateTime Serversion = LoadAchievement(AchievConst.MAX_Achievement, DateTime.UtcNow, 0xffffffff);
            Thread.Sleep(500);

            DateTime clientver = Serversion.AddDays(-1);

            AchievementWD achive = new AchievementWD(33, (uint)AchievConst.MAX_Achievement + 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AddAchievementsToVerify(UWoner, _Title, achive);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive }, clientver);
            SyncAchievementsResponse resp = req.Execute();
            uint[] alist = new uint[AchievConst.MAX_Achievement];
            for (int i = 0; i < AchievConst.MAX_Achievement; i++)
            {
                alist[i] = (uint)(i + 1);
            }
            verifySingleWrite(resp, alist);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Max Achievement Sync")]
    public class SyncEnumMaxAchievements : AchivementBase
    {
        public SyncEnumMaxAchievements(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);

            AchievementWD[] lalist = new AchievementWD[AchievConst.MAX_Achievement];
            for (int i = 0; i < lalist.Length; i++)
            {
                lalist[i] = new AchievementWD((uint)(i + 1), (uint)i + 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
                AddAchievementsToVerify(UWoner, _Title, lalist[i]);
            }

            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, lalist);
            SyncAchievementsResponse resp = req.Execute();
            verify(resp, null);
        }
    }

    [Description("Max Achievement Minus 1 Sync")]
    public class SyncEnumMax_1Achievements : AchivementBase
    {
        public SyncEnumMax_1Achievements(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);

            AchievementWD[] lalist = new AchievementWD[AchievConst.MAX_Achievement - 1];
            for (int i = 0; i < lalist.Length; i++)
            {
                lalist[i] = new AchievementWD((uint)(i + 1), (uint)i + 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
                AddAchievementsToVerify(UWoner, _Title, lalist[i]);
            }

            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, lalist);
            SyncAchievementsResponse resp = req.Execute();
            verifySingleWrite(resp, null);
        }
    }

    // SyncEnumMultAchievementsMultTitle
    [TestFrequency("Daily"), TestCasePriority(1), Description("Multi Achievement Sync for Multi Titles")]
    public class SyncEnumMultAchievementsMultTitle : AchivementBase
    {
        public SyncEnumMultAchievementsMultTitle(ulong user)
            : base(0, user)
        {
        }

        public void AddtitleAndVerify(uint title)
        {
            this._Title = title;

            AchievementWD achive1 = new AchievementWD(1, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive2 = new AchievementWD(7, 2, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive3 = new AchievementWD(3, 3, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive4 = new AchievementWD(10, 4, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            AddAchievementsToVerify(UWoner, _Title, achive1);
            AddAchievementsToVerify(UWoner, _Title, achive2);
            AddAchievementsToVerify(UWoner, _Title, achive3);
            AddAchievementsToVerify(UWoner, _Title, achive4);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive1, achive2, achive3, achive4 });
            SyncAchievementsResponse resp = req.Execute();
            verify(resp, null);
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AddtitleAndVerify(50);
            AddtitleAndVerify(51);
            AddtitleAndVerify(52);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(1), Description("Multi Achievement Single Title Sync")]
    public class SyncEnumMultipleAchievements : AchivementBase
    {
        public SyncEnumMultipleAchievements(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achive1 = new AchievementWD(1, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive2 = new AchievementWD(7, 2, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive3 = new AchievementWD(3, 3, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive4 = new AchievementWD(10, 4, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            AddAchievementsToVerify(UWoner, _Title, achive1);
            AddAchievementsToVerify(UWoner, _Title, achive2);
            AddAchievementsToVerify(UWoner, _Title, achive3);
            AddAchievementsToVerify(UWoner, _Title, achive4);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive1, achive2, achive3, achive4 });
            SyncAchievementsResponse resp = req.Execute();
            verify(resp, null);
        }
    }

    public class SyncEnumNonExistantAchievements : SyncEnumSingleAchievements
    {
        public SyncEnumNonExistantAchievements(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achive = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive });
            SyncAchievementsResponse resp = req.Execute();
            verify(resp, null);
        }
    }

    [TestFrequency("BVT"), TestCasePriority(1), BVT, Description("Single Achievement Sync BVT")]
    public class SyncEnumSingleAchievements : AchivementBase
    {
        public SyncEnumSingleAchievements(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achive = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AddAchievementsToVerify(UWoner, _Title, achive);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive });
            SyncAchievementsResponse resp = req.Execute();
            verify(resp, null);
        }
    }

    // -- Bad Platform Tests --

    public class SyncEnumMultAchievementsMultTitleBadClients : AchivementBase
    {
        public SyncEnumMultAchievementsMultTitleBadClients(ulong user)
            : base(0, user)
        {
        }

        public void AddtitleAndVerify(uint title)
        {
            this._Title = title;

            AchievementWD achive1 = new AchievementWD(1, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive2 = new AchievementWD(7, 2, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive3 = new AchievementWD(3, 3, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive4 = new AchievementWD(10, 4, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));

            AddAchievementsToVerify(UWoner, _Title, achive1);
            AddAchievementsToVerify(UWoner, _Title, achive2);
            AddAchievementsToVerify(UWoner, _Title, achive3);
            AddAchievementsToVerify(UWoner, _Title, achive4);

            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive1, achive2, achive3, achive4 });

            Global.RO.Info("Syncing Multiple Achievements for Multiple Titles from Xbox1...");

            req.SetMachineClientType(CSGInfo.ClientType.Xbox);
            SyncAchievementsResponse resp = req.Execute();

            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED)
                throw new Exception("Invalid Xerror " + resp.xResult);
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AddtitleAndVerify(50);
            AddtitleAndVerify(51);
            AddtitleAndVerify(52);
        }
    }

    public class SyncEnumMultipleAchievementsBadClients : AchivementBase
    {
        public SyncEnumMultipleAchievementsBadClients(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achive1 = new AchievementWD(1, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive2 = new AchievementWD(7, 2, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive3 = new AchievementWD(3, 3, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AchievementWD achive4 = new AchievementWD(10, 4, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AddAchievementsToVerify(UWoner, _Title, achive1);
            AddAchievementsToVerify(UWoner, _Title, achive2);
            AddAchievementsToVerify(UWoner, _Title, achive3);
            AddAchievementsToVerify(UWoner, _Title, achive4);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive1, achive2, achive3, achive4 });

            Global.RO.Info("Syncing Multiple Achievements from Xbox1...");

            req.SetMachineClientType(CSGInfo.ClientType.Xbox);
            SyncAchievementsResponse resp = req.Execute();

            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED)
                throw new Exception("Invalid Xerror " + resp.xResult);

            Global.RO.Info("Syncing Multiple Achievements from PC...");

            req.SetMachineClientType(CSGInfo.ClientType.PC);
            resp = req.Execute();

            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED)
                throw new Exception("Invalid Xerror " + resp.xResult);
        }
    }

    public class SyncEnumNonExistantAchievementsBadClients : SyncEnumSingleAchievements
    {
        public SyncEnumNonExistantAchievementsBadClients(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achive = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive });

            Global.RO.Info("Syncing NonExistent Achievement from Xbox1...");

            req.SetMachineClientType(CSGInfo.ClientType.Xbox);
            SyncAchievementsResponse resp = req.Execute();
            verify(resp, null);

            Global.RO.Info("Syncing NonExistent Achievement from PC...");

            req.SetMachineClientType(CSGInfo.ClientType.PC);
            resp = req.Execute();
            verify(resp, null);
        }
    }

    public class SyncEnumSingleAchievementsBadClients : AchivementBase
    {
        public SyncEnumSingleAchievementsBadClients(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achive = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AddAchievementsToVerify(UWoner, _Title, achive);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive });

            Global.RO.Info("Syncing Achievement from Xbox1...");

            req.SetMachineClientType(CSGInfo.ClientType.Xbox);
            SyncAchievementsResponse resp = req.Execute();

            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED)
                throw new Exception("Invalid Xerror " + resp.xResult);

            Global.RO.Info("Syncing Achievement from PC...");

            req.SetMachineClientType(CSGInfo.ClientType.PC);
            resp = req.Execute();

            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED)
                throw new Exception("Invalid Xerror " + resp.xResult);
        }
    }

    // -- Valid Platform Tests --
    [Description("Invalid Xbox Sync for 360 Achievement with Positive Sync from 360")]
    public class SyncEnumSingleAchievementValid360 : AchivementBase
    {
        public SyncEnumSingleAchievementValid360(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achive = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AddAchievementsToVerify(UWoner, _Title, achive);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive });

            Global.RO.Info("Syncing Achievement from Xbox1...");

            req.SetMachineClientType(CSGInfo.ClientType.Xbox);
            SyncAchievementsResponse resp = req.Execute();

            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED)
                throw new Exception("Invalid Xerror " + resp.xResult);

            Global.RO.Info("Syncing Achievement from Xbox 360... [This should PASS]");

            req.SetMachineClientType(CSGInfo.ClientType.Xenon);
            resp = req.Execute();
            verify(resp, null);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(1), Description("Cross Platform Title 360 Sync")]
    public class SyncEnumSingleAchievementValid360AndPCFrom360 : AchivementBase
    {
        public SyncEnumSingleAchievementValid360AndPCFrom360(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achive = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_XBOX360));
            AddAchievementsToVerify(UWoner, _Title, achive);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive });

            Global.RO.Info("Syncing Achievement from Xbox1...");

            req.SetMachineClientType(CSGInfo.ClientType.Xbox);
            SyncAchievementsResponse resp = req.Execute();

            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED)
                throw new Exception("Invalid Xerror " + resp.xResult);

            Global.RO.Info("Syncing Achievement from Xbox 360... [This should PASS]");

            req.SetMachineClientType(CSGInfo.ClientType.Xenon);
            resp = req.Execute();
            verify(resp, null);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(1), Description("Cross Platform Title PC Sync")]
    public class SyncEnumSingleAchievementValid360AndPCFromPC : AchivementBase
    {
        public SyncEnumSingleAchievementValid360AndPCFromPC(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achive = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, XOn.XPLT_PC));
            AddAchievementsToVerify(UWoner, _Title, achive);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achive });

            Global.RO.Info("Syncing Achievement from Xbox1...");

            req.SetMachineClientType(CSGInfo.ClientType.Xbox);
            SyncAchievementsResponse resp = req.Execute();

            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED)
                throw new Exception("Invalid Xerror " + resp.xResult);

            Global.RO.Info("Syncing Achievement from PC... [This should PASS]");

            req.SetMachineClientType(CSGInfo.ClientType.PC);
            resp = req.Execute();
            verify(resp, null);
        }
    }

    // -- Valid Platform Tests new Clients (Windows Mobile and Web Games)--
    [TestFrequency("BVT"), TestCasePriority(1), Description("BVT for Windows Mobile Achievement Sync")]
    public class SyncEnumSingleAchievementValidWinMobile : AchivementBase
    {
        public SyncEnumSingleAchievementValidWinMobile(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achieve = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, xonline.common.service.XOn.XPLT_MOBILE));
            AddAchievementsToVerify(UWoner, _Title, achieve);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achieve });

            Global.RO.Info("Syncing Achievement from Mobile...");

            // call the ExecuteInt function with the proper XPLT and XPLTOnBehalfOf
            SyncAchievementsResponse resp = req.ExecuteInt(xonline.common.service.XOn.XPLT_INTERNAL_LIVEN, xonline.common.service.XOn.XPLT_MOBILE);

            verify(resp, null);
        }
    }

    [TestFrequency("BVT"), TestCasePriority(1), Description("BVT for WebGames Achievement Sync")]
    public class SyncEnumSingleAchievementValidWebGames : AchivementBase
    {
        public SyncEnumSingleAchievementValidWebGames(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achieve = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, xonline.common.service.XOn.XPLT_WEB_GAMES));
            AddAchievementsToVerify(UWoner, _Title, achieve);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achieve });

            Global.RO.Info("Syncing Achievement from WebGames...");

            // call the ExecuteInt function with the proper XPLT and XPLTOnBehalfOf
            SyncAchievementsResponse resp = req.ExecuteInt(xonline.common.service.XOn.XPLT_INTERNAL_LIVEN, xonline.common.service.XOn.XPLT_WEB_GAMES);

            verify(resp, null);
        }
    }

    public class N_SyncEnumSingleAchievementInvalidPlatformsFor360 : AchivementBase
    {
        public N_SyncEnumSingleAchievementInvalidPlatformsFor360(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achieve = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, xonline.common.service.XOn.XPLT_WEB_GAMES));
            AddAchievementsToVerify(UWoner, _Title, achieve);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achieve });

            Global.RO.Info("Syncing Achievement from Mobile client for 360 Only Title");

            // call the ExecuteInt function with the proper XPLT and XPLTOnBehalfOf
            SyncAchievementsResponse resp = req.ExecuteInt(xonline.common.service.XOn.XPLT_INTERNAL_LIVEN, xonline.common.service.XOn.XPLT_MOBILE);

            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED)
                throw new Exception("Invalid Xerror " + resp.xResult + " expected XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED");

            Global.RO.Info("Sync call properly threw exception/event for achievement not supported for the calling client");

            Global.RO.Info("Syncing Achievement from WebGames client for 360 Only Title");

            // call the ExecuteInt function with the proper XPLT and XPLTOnBehalfOf
            resp = req.ExecuteInt(xonline.common.service.XOn.XPLT_INTERNAL_LIVEN, xonline.common.service.XOn.XPLT_WEB_GAMES);

            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED)
                throw new Exception("Invalid Xerror " + resp.xResult + " expected XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED");

            Global.RO.Info("Sync call properly threw exception/event for achievement not supported for the calling client");
        }
    }

    public class N_SyncEnumSingleAchievementInvalid360PlatformsForWinMo : AchivementBase
    {
        public N_SyncEnumSingleAchievementInvalid360PlatformsForWinMo(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achieve = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, xonline.common.service.XOn.XPLT_XBOX360));
            AddAchievementsToVerify(UWoner, _Title, achieve);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achieve });

            Global.RO.Info("Syncing Achievement for Mobile Title from a 360 client, which should fail");

            // call the execute
            SyncAchievementsResponse resp = req.Execute();

            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED)
                throw new Exception("Invalid Xerror " + resp.xResult + " expected XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED");

            Global.RO.Info("Sync call properly threw exception/event for achievement not supported for the calling client");
        }
    }

    public class N_SyncEnumSingleAchievementInvalid360PlatformsForWebGames : AchivementBase
    {
        public N_SyncEnumSingleAchievementInvalid360PlatformsForWebGames(uint title, ulong user)
            : base(title, user)
        {
        }

        public override void Run()
        {
            ClearAchivement(UWoner);
            AchievementWD achieve = new AchievementWD(2, 1, PSyncEnum.BuildAchievementWDFlagForPlatform(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED, xonline.common.service.XOn.XPLT_XBOX360));
            AddAchievementsToVerify(UWoner, _Title, achieve);
            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, new AchievementWD[] { achieve });

            Global.RO.Info("Syncing Achievement for WebGames Title from a 360 client, which should fail");

            // call the execute
            SyncAchievementsResponse resp = req.Execute();

            if (resp.xResult != xonline.common.service.HResult.XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED)
                throw new Exception("Invalid Xerror " + resp.xResult + " expected XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED");

            Global.RO.Info("Sync call properly threw exception/event for achievement not supported for the calling client");
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\EnumContext.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Database;
using xonline.common.config;

namespace GamerSettings
{
	/// <summary>
	/// Summary description for EnumContext.
	/// </summary>
	public class EnumContext :TestNode
	{
		public EnumContext()
		{
            AddChild(new EnumSP0NCount10(150));
            AddChild(new EnumSP1NCount10(150));
            AddChild(new EnumSP9NCount10(150));
            AddChild(new EnumSP8NCount10(150));
            AddChild(new EnumSP10NCount10(150));
            AddChild(new EnumSP9NCount1(150));
            AddChild(new EnumSP5NCount2(150));
            AddChild(new EnumMax(151));
            AddChild(new EnumMax_1(151));
            AddChild(new EnumMaxPlus1(151));
            AddChild(new Enum35(151));

            AddChild(new EnumLocaleDE(150));
            AddChild(new EnumNonExistentLocale(150));

			// invalid request
            AddChild(new EnumContextInvalidTitle(155));
            AddChild(new EnumInvalidContextId(150));

            AddChild(new TCInvalidSmallPKT());
            AddChild(new TCInvalidLargePKT());

		}
		
		public class TCInvalidSmallPKT:TestBase
		{
			override protected void Execute()
			{

				InvalidXRLRequest tmp = new InvalidXRLRequest(10,"/xstats/contextenum.ashx");
				uint xerror= tmp.Execute();
				if(xerror != HResult.XONLINE_E_END_OF_STREAM)
					throw new Exception("Invalid Xerror Expected :"+ HResult.E_FAIL+" recived:"+xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

		public class TCInvalidLargePKT:TestBase
		{
			override protected void Execute()
			{

				InvalidXRLRequest tmp = new InvalidXRLRequest(1000*1000,"/xstats/contextenum.ashx");
				uint xerror= tmp.Execute();
				if(xerror != HResult.XONLINE_E_SERVER_ERROR)
					throw new Exception("Invalid Xerror Expected :"+ HResult.E_FAIL+" recived:"+xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

	}

	public class EnumInvalidContextId:ContextBase
	{
		public EnumInvalidContextId(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=0;
			count =10;
			ExpectedCount=10;
			locale=1038;    //de_DE = 1031, // German (Germany)
			ContextId = this.ContextId+10;

		}

		public override  void Run()
		{
			ContextEnumRequest req= new ContextEnumRequest(Title,ContextId,locale,startIdx,count);
			ContextEnumResponse resp =req.Execute();

			if(resp.XError!= HResult.E_INVALIDARG)
				throw new Exception("Invalid Xerror returned : "+resp.XError);
		}

	}


	public class EnumContextInvalidTitle:ContextBase
	{
		public EnumContextInvalidTitle(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=0;
			count =10;
			ExpectedCount=10;
			locale=1038;    //de_DE = 1031, // German (Germany)

		}

		public override  void Run()
		{
			ContextEnumRequest req= new ContextEnumRequest(Title,ContextId,locale,startIdx,count);
			ContextEnumResponse resp =req.Execute();

			if(resp.XError!= HResult.XONLINE_E_SERVER_ERROR)
				throw new Exception("Invalid Xerror returned : "+resp.XError);
		}

	}


	public class EnumNonExistentLocale:ContextBase
	{
		public EnumNonExistentLocale(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=0;
			count =10;
			ExpectedCount=10;
			locale=1038;    //de_DE = 1031, // German (Germany)

		}

	}

	public class EnumLocaleDE:ContextBase
	{
		public EnumLocaleDE(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=0;
			count =10;
			ExpectedCount=10;
			locale=1031;    //de_DE = 1031, // German (Germany)

		}

	}


	public class Enum35:ContextBase
	{
		public Enum35(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=0;
			count =32;
			ExpectedCount=32;
			this.TotalSize=35;
			

		}

		public override  void Run()
		{
			EnumAndVerify();
			// enum gain from 33 to 35..
			startIdx=0;
			count =32;
			ExpectedCount=32;

			EnumAndVerify();
		}

	}

	//EnumMaxPlus1
	public class EnumMaxPlus1:ContextBase
	{
		public EnumMaxPlus1(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=0;
			count =33;
			ExpectedCount=33;
			this.TotalSize=35;

		}

		public override  void Run()
		{
			ContextEnumRequest req= new ContextEnumRequest(Title,ContextId,locale,startIdx,count);
			ContextEnumResponse resp =req.Execute();

			if(resp.XError!=HResult.E_INVALIDARG)
				throw new Exception("Invalid XError " + resp.XError);
		}

	}


	public class EnumMax_1:ContextBase
	{
		public EnumMax_1(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=0;
			count =31;
			ExpectedCount=31;
			this.TotalSize=35;

		}

	}

	public class EnumMax:ContextBase
	{
		public EnumMax(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=0;
			count =320;
			ExpectedCount=32;
			this.TotalSize=35;

		}

	}

	public class EnumSP5NCount2:ContextBase
	{
		public EnumSP5NCount2(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=5;
			count =2;
			ExpectedCount=2;

		}

	}

	public class EnumSP9NCount1:ContextBase
	{
		public EnumSP9NCount1(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=9;
			count =1;
			ExpectedCount=1;

		}

	}

	public class EnumSP10NCount10:ContextBase
	{
		public EnumSP10NCount10(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=10;
			count =10;
			ExpectedCount=0;

		}

	}

	public class EnumSP8NCount10:ContextBase
	{
		public EnumSP8NCount10(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=8;
			count =10;
			ExpectedCount=2;

		}

	}

	public class EnumSP9NCount10:ContextBase
	{
		public EnumSP9NCount10(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=9;
			count =10;
			ExpectedCount=1;

		}

	}

	public class EnumSP1NCount10:ContextBase
	{
		public EnumSP1NCount10(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=1;
			count =10;
			ExpectedCount=9;

		}

	}

	public class EnumSP0NCount10:ContextBase
	{
		public EnumSP0NCount10(uint title):base(title)
		{}

		protected override void  Init()
		{
			startIdx=0;
			count =10;
			ExpectedCount=10;

		}

	}


	public class ContextBase :TestBase
	{
		public static GameConfig gconfig = null;
		protected uint Title=0;
		protected uint ContextId=32779;
		protected uint startIdx=0;
		protected uint count =0;
		protected uint ExpectedCount=0;
		protected uint Xerror =0;
		protected ushort locale=1033;  //en-us
		protected ushort DefaultLocale=1033; //en-us
		protected ushort TotalSize=10;
		public ContextBase(uint title)
		{
			Title=title;
		}

		
		protected virtual void  Init()
		{
		}

	
		protected override void Execute()
		{
			Init();
			Run();
			ResultCode = TEST_RESULTS.PASSED;
		}
		
		public new virtual  void Run()
		{
			EnumAndVerify();
		}

		public void EnumAndVerify()
		{

			ContextEnumRequest req= new ContextEnumRequest(Title,ContextId,locale,startIdx,count);

			ContextEnumResponse resp =req.Execute();
			if(ExpectedCount!= resp.ContextsLen)
				throw new Exception("Invlaid COunt Expected :"+ExpectedCount+" server returned :"+resp.ContextsLen);

			if(TotalSize != resp.TotalContexts)
				throw new Exception("Invlaid Total Count Expected :"+TotalSize+" server returned :"+resp.TotalContexts);

			ArrayList list= gconfig.ContextSting(Title,ContextId,locale);

			for(int i=0;i<ExpectedCount;i++)
			{
				int ridx= (int)(i+startIdx);
				ContextStr tmp =(ContextStr)list[ridx];
				if(resp.Contexts[i].ContextId != tmp.ContextId)
					throw new Exception("Wrong Context value ID Expected :"+tmp.ContextId+"Recived :"+resp.Contexts[i].ContextId);
				if(resp.Contexts[i].Name != tmp.Name)
					throw new Exception("Wrong Context value name Expected :"+tmp.Name+"Recived :"+resp.Contexts[i].Name);
			}
					
		}

		
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\GamerSettings.cs ===
using System;
using System.Xml;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Database;
using xonline.common.config;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.LiveService.Achievement;

[assembly: RootNode(typeof(GamerSettings.GamerSettings))]

namespace GamerSettings
{
    /// <summary>
    /// Profile related tests for xstatsfd.dll
    /// Sync/Read Settings
    /// Sync/Enum Titles
    /// </summary>
    [TestFrequency("Regression"), TestCasePriority(3), Owner("KKline")]
    public class GamerSettings: TestNode
    {
        public GamerSettings()
        {
            AddChild(new PosSyncGetGlobalSettings());
            AddChild(new PosSyncGetTitleSettings());
            AddChild(new AddGetSettings());
            AddChild(new NegSyncGetSettings());
            AddChild(new Permission());
            AddChild(new PosSyncTitles());
            AddChild(new EnumTitles());
            AddChild(new PersonalPic());
            AddChild(new ClearTitle());
            AddChild(new SyncAvatarManifest());
            AddChild(new ValidateAvatarManifest());
            //AddChild(new SyncAll());  Sync is done my using enum. this XRL is removed
            //AddChild(new EnumContext());  this is cut for launch bug 19863
        }

        public override void PreRun()
        {

            int needflush = 0; 
            // Let the fake SG know where to send state updates
            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence).ToString());

            //DBHelper.ClearTestSettings();

            //Clear the cached profile settings (from possibly last run of these tests) from Cache
            xonline.common.service.Acceleration xb = new xonline.common.service.Acceleration(Interface.ProfileCache);
            //all the profile keys start with the common prefix profile, so remove them by prefix!
            byte[] key = new byte[]{(byte)'P',(byte)'r',(byte)'o',(byte)'f',(byte)'i',(byte)'l',(byte)'e'};
            xb.Remove(key, false);

            //clear the settings that are cached in SettingsIDs in current tfgui
            SettingIds.Flush();

            //Prop the settings used in this suite!
            Type UserSettings = typeof(TestUSetting);

            foreach(string s in Enum.GetNames(UserSettings))
            {
                if(s == "Test_Activity")
                {
                    needflush += DBHelper.AddSetting(((int)Enum.Parse(UserSettings,s)),s,"t_user_settings",PROFILE_FLG.XPROFILE_SETTING_ENFORCE_ACTIVITY);
                }
                else if (s == "Test_UCC")
                {
                    needflush += DBHelper.AddSetting(((int)Enum.Parse(UserSettings,s)),s,"t_user_settings",PROFILE_FLG.XPROFILE_SETTING_ENFORCE_UCC);
                }
                else if (s == "Test_Console_RO")
                {
                    needflush += DBHelper.AddSetting(((int)Enum.Parse(UserSettings,s)),s,"t_user_settings",PROFILE_FLG.XPROFILE_SETTING_ENFORCE_CONSOLE_RO);
                }
                else if (s =="Test_Web_RO")
                {
                    needflush += DBHelper.AddSetting(((int)Enum.Parse(UserSettings,s)),s,"t_user_settings",PROFILE_FLG.XPROFILE_SETTING_ENFORCE_WEB_RO);
                }
                else if (s == "Test_Title_RO")
                {
                    needflush += DBHelper.AddSetting(((int)Enum.Parse(UserSettings,s)),s,"t_user_settings",PROFILE_FLG.XPROFILE_SETTING_ENFORCE_TITLE_RO);
                }
                else if (s == "Test_Not_Shared")
                {
                    needflush += DBHelper.AddSetting(((int)Enum.Parse(UserSettings,s)),s,"t_user_settings",PROFILE_FLG.XPROFILE_SETTING_ENFORCE_NOT_SHARED);
                }
                else if (s == "Test_Friend_Only")
                {
                    needflush += DBHelper.AddSetting(((int)Enum.Parse(UserSettings,s)),s,"t_user_settings",PROFILE_FLG.XPROFILE_SETTING_ENFORCE_FRIENDS_ONLY);
                }
                else
                {
                    needflush += DBHelper.AddSetting(((int)Enum.Parse(UserSettings,s)),s,"t_user_settings",0);
                }
            
            }
            
            //used in the speed check
            int max = 512;
            for( int i=1;i<max;i++)
            {
                needflush += DBHelper.AddSetting((int)TestUSetting.Test_bMaxNo+i,(TestUSetting.Test_bMaxNo.ToString()+i),"t_user_settings",0);
            }

            //if we propped any new settings, we need to tell all the servers that expose xstatsfd to flush their local settings cached to pick up the changes
            if(needflush>0)
                Global.XEnv.ExecuteXmgmtCommand(Interface.profilefd, "e :xstatsfd cacheflush");

            int maxuser = GSLimits.XONLINE_MAX_SETTING_USERS+5;
            if(UserSettingBase.gusers.Count!=maxuser)
            {
                for(int i=1;i<=maxuser;i++)
                {
                    UserSettingBase.gusers.Add("User"+i,(ulong)(9000+i));

                }
                GetSettingBase.gusers= UserSettingBase.gusers;
            }

            uint[] titles= new uint[52];
            for(int tidx=0;tidx<45;tidx++)
            {
                titles[tidx]=(uint)(50+tidx);
            }
            titles[45]=(uint)150;
            titles[46]=(uint)151;

            titles[47] = (uint)210;
            titles[48] = (uint)211;
            titles[49] = (uint)212;
            titles[50] = (uint)213;
            titles[51] = (uint)214;
            
            //yoinked from jefferson's gamerprofile addition
            string pathToConfigFiles = "InputFiles\\GamerProfile\\";
            //let's make sure the title information is present...
            foreach(uint title in titles) 
            {
                try 
                {
                    TitleConfig.GetTitle(title);
                } 
                catch (ApplicationException) 
                {
                    //prop the title accordingly
                    Global.RO.Info("Title number " + title + " not found in NPDB--attempting to remedy via sql file...");
                    try 
                    {
                        string totalPath = pathToConfigFiles + "Achievement"+title+".sql";
                        if (title >= 55 && title <= 95) totalPath = pathToConfigFiles + "40titles.sql";
                        StreamReader file = File.OpenText(totalPath);
                        String sql;
                        sql = file.ReadToEnd();
                        Npdb npdb = new Npdb();
                        npdb.ConnectToServer();
                        npdb.IssueCommand(sql);
                        npdb.Close();

                    } catch (Exception e) {
                        Global.RO.Warn("Could not prop title " + title + "!  Test results may be inaccurate.");
                        Global.RO.Warn("Text is as follows:" + e.ToString());
                    }
                    Global.RO.Info("Title configuration info added successfully!");
                }
            }

/* local caching disabled in acceleration/ProfileCache.
            string query = "select vc_value from t_settings where vc_setting='xbanc_localCacheItemDuration'";
            Npdb npdb2 = new Npdb();
            npdb2.ConnectToServer();
            UserSettingBase.cacheTimeout = Convert.ToInt32(npdb2.ExecuteScalar(query));
            npdb2.Close();
*/
            TitleBase.gconfig.Load(titles);
            EnumBase.gconfig=TitleBase.gconfig;
            ContextBase.gconfig=AchivementBase.gconfig=TitleBase.gconfig;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\AddGetSettings.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.config;

namespace GamerSettings
{
    /// <summary>
    /// Summary description for AddGetSettings.
    /// </summary>
    public class AddGetSettings : TestNode
    {
        public AddGetSettings()
        {
            AddChild(new GetGlobalwithNoSetting(Titles.Global));
            AddChild(new GetTitlewithNoSetting(Titles.PosTitle1));
            AddChild(new GetTitlewithGlobalSet(Titles.PosTitle1));
            AddChild(new GetGlobalMultipleSettings(Titles.Global));
            AddChild(new GetTitleMultipleSettings(Titles.PosTitle1));
            AddChild(new GetTitleSamePub(Titles.PosTitle1));
            AddChild(new GetTitleDiffPub(Titles.PosTitle1));
            AddChild(new GetMixMultipleSettings(Titles.PosTitle1)); // some title and some global
            AddChild(new GetMix2MultipleSettings(Titles.PosTitle1)); // some title and some global some novalue
            AddChild(new GetMultUserMultSetting(Titles.Global));
            AddChild(new GetMultUserSingleSetting(Titles.Global));
            AddChild(new GetMaxUserMaxSetting(Titles.PosTitle1));
            AddChild(new IntGetTitleMultipleSettings(Titles.PosTitle1));
            AddChild(new GetMembershipTier(Titles.PosTitle1));
            AddChild(new ReadSettingsSpeedTest(Titles.PosTitle1));
        }

        public class GetMembershipTier : GetSettingBase
        {
            public GetMembershipTier(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                settingsids = new uint[1];
                settingsids[0] = 268697658; // Gamer_Tier_Information

                FriendsCommon fc = new FriendsCommon();
                PNUser user = fc.CreateXenonUser(false);

                users = new ulong[1];
                users[0] = user.UserId;

                UodbWS.SetUserTier(user.UserId, (byte)TierEnum.Silver);

                Tsettings = new UserSetting[1];
                byte[] data = new byte[] { (byte)TierEnum.Silver, 0, 0, 0 };
                Tsettings[0] = new UserSetting(users[0], settingsids[0], data, SettingSource.XSOURCE_DEFAULT);
            }

            protected override void run()
            {
                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, settingsids);
                ReadSettingsResponse gresp = greq.ExecuteInt();
                verifyXerror(gresp);
                verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            }
        }

        public class IntGetTitleMultipleSettings : GetSettingBase
        {
            public IntGetTitleMultipleSettings(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                addsettings(1, 5, SettingSource.XSOURCE_TITLE);
            }

            protected override void run()
            {
                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, settingsids);
                ReadSettingsResponse gresp = greq.ExecuteInt();
                verifyXerror(gresp);
                verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            }
        }

        public class GetMix2MultipleSettings : GetMixMultipleSettings
        {
            public GetMix2MultipleSettings(uint title)
                : base(title)
            {

            }
            protected override void init()
            {
                int maxuser = GSLimits.XONLINE_MAX_SETTING_USERS;
                int maxset = GSLimits.XONLINE_MAX_SETTING_COUNT;
                addsettings(5, 5, SettingSource.XSOURCE_TITLE);

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
                Thread.Sleep(UserSettingBase.cacheTimeout * 1000);

                appendsettings((uint)Titles.Global, 5, SettingSource.XSOURCE_DEFAULT);

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
                Thread.Sleep(UserSettingBase.cacheTimeout * 1000);

                appendnullsettings(1);
            }

            public void appendnullsettings(int settingcount)
            {
                int oldScount = settingsids.Length;

                uint[] tempsettingsids = new uint[settingcount + settingsids.Length];
                Array.Copy(settingsids, tempsettingsids, settingsids.Length);

                uint baseid = (uint)TestUSetting.Test_bMaxNo + (uint)settingsids.Length;
                int start = settingsids.Length;
                for (uint p = 0; p < settingcount; p++)
                {
                    tempsettingsids[start + p] = baseid + p;
                }

                int totalsettings = users.Length * settingcount;
                // grow Tsettings also
                UserSetting[] tmpTsettings = new UserSetting[totalsettings + Tsettings.Length];

                int total = 0;
                for (int i = 0; i < users.Length; i++)
                {

                    //copy oldsettingsfor user then append new
                    int TSidx = (i * oldScount);
                    int tmpTSidx = TSidx + (i * settingcount);
                    Array.Copy(Tsettings, TSidx, tmpTsettings, tmpTSidx, oldScount);
                    int TSettingstart = TSidx + oldScount;

                    for (int j = 0; j < settingcount; j++)
                    {
                        tmpTsettings[TSettingstart + total++] = new UserSetting(users[i], (uint)tempsettingsids[start + j]);
                    }

                }

                settingsids = tempsettingsids;
                Tsettings = tmpTsettings;
            }

            protected override void run()
            {
                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, settingsids);
                ReadSettingsResponse gresp = greq.Execute();
                verifyXerror(gresp);
                verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            }

        }

        public class GetMixMultipleSettings : GetSettingBase
        {
            public GetMixMultipleSettings(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                int maxuser = GSLimits.XONLINE_MAX_SETTING_USERS;
                int maxset = GSLimits.XONLINE_MAX_SETTING_COUNT;
                addsettings(5, 5, SettingSource.XSOURCE_TITLE);

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
                Thread.Sleep(UserSettingBase.cacheTimeout * 1000);

                appendsettings((uint)Titles.Global, 5, SettingSource.XSOURCE_DEFAULT);
            }

            public void appendsettings(uint _title, int settingcount, SettingSource source)
            {
                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
                Thread.Sleep(UserSettingBase.cacheTimeout * 1000);

                int oldScount = settingsids.Length;
                RandomEx rand = new RandomEx();
                uint[] tempsettingsids = new uint[settingcount + settingsids.Length];
                Array.Copy(settingsids, tempsettingsids, settingsids.Length);

                uint baseid = (uint)TestUSetting.Test_bMaxNo + (uint)settingsids.Length;
                int start = settingsids.Length;
                for (uint p = 0; p < settingcount; p++)
                {
                    tempsettingsids[start + p] = baseid + p;
                }

                int totalsettings = users.Length * settingcount;
                // grow Tsettings also
                UserSetting[] tmpTsettings = new UserSetting[totalsettings + Tsettings.Length];

                int max = (int)GSLimits.XONLINE_MAX_SETTING_VALUE_BYTES;
                int total = 0;
                for (int i = 0; i < users.Length; i++)
                {

                    //copy oldsettingsfor user then append new
                    int TSidx = (i * oldScount);
                    int tmpTSidx = TSidx + (i * settingcount);
                    Array.Copy(Tsettings, TSidx, tmpTsettings, tmpTSidx, oldScount);
                    int TSettingstart = TSidx + oldScount;

                    UserSetting[] settings = new UserSetting[settingsids.Length];
                    for (int j = 0; j < settingcount; j++)
                    {
                        tmpTsettings[TSettingstart + total++] = settings[j] = new UserSetting(users[i], tempsettingsids[start + j], rand.GenerateRandomBlob(max), source);
                    }

                    SyncSettingsRequest req = new SyncSettingsRequest(_title, users[i], settings, DateTime.UtcNow);

                    SyncSettingsResponse resp = req.Execute();
                    if (resp.XError != 0)
                        throw new Exception("Error loading settings XError: " + resp.XError);
                }

                settingsids = tempsettingsids;
                Tsettings = tmpTsettings;

            }

            protected override void run()
            {
                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, settingsids);
                ReadSettingsResponse gresp = greq.Execute();
                verifyXerror(gresp);
                verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            }

        }

        [TestFrequency("Daily"), TestCasePriority(1), Description("Read max user settings")]
        public class GetMaxUserMaxSetting : GetSettingBase
        {
            public GetMaxUserMaxSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                int maxuser = GSLimits.XONLINE_MAX_SETTING_USERS;
                int maxset = GSLimits.XONLINE_MAX_SETTING_COUNT;
                addsettings(maxuser, maxset, SettingSource.XSOURCE_TITLE);
            }

            protected override void run()
            {
                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
                Thread.Sleep(UserSettingBase.cacheTimeout * 1000);

                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, settingsids);
                ReadSettingsResponse gresp = greq.Execute();
                verifyXerror(gresp);
                verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            }
        }

        [TestFrequency("Daily"), TestCasePriority(1), Description("Read single setting multi users")]
        public class GetMultUserSingleSetting : GetSettingBase
        {
            public GetMultUserSingleSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                addsettings(5, 1, SettingSource.XSOURCE_DEFAULT);
            }

            protected override void run()
            {
                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
                Thread.Sleep(UserSettingBase.cacheTimeout * 1000);

                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, settingsids);
                ReadSettingsResponse gresp = greq.Execute();
                verifyXerror(gresp);
                verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            }
        }

        [TestFrequency("Daily"), TestCasePriority(1), Description("Read multi setting multi users")]
        public class GetMultUserMultSetting : GetSettingBase
        {
            public GetMultUserMultSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                addsettings(5, 5, SettingSource.XSOURCE_DEFAULT);
            }

            protected override void run()
            {
                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, settingsids);
                ReadSettingsResponse gresp = greq.Execute();
                verifyXerror(gresp);
                verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            }

        }

        public class GetTitleSamePub : GetSettingBase
        {
            public GetTitleSamePub(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                addsettings(1, 5, SettingSource.XSOURCE_TITLE);
            }

            protected override void run()
            {
                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
                Thread.Sleep(UserSettingBase.cacheTimeout * 1000);

                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, settingsids);
                greq.Modifyflag = AuthModify.Change_Title;
                ReadSettingsResponse gresp = greq.Execute();
                verifyXerror(gresp);
                verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            }
        }

        public class GetTitleDiffPub : GetSettingBase
        {
            public GetTitleDiffPub(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                addsettings(1, 5, SettingSource.XSOURCE_TITLE);
            }

            protected override void run()
            {
                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, settingsids);
                greq.Modifyflag = AuthModify.Change_Title_PUB;
                ReadSettingsResponse gresp = greq.Execute();
                if (gresp.XError != HResult.XONLINE_E_SERVER_ERROR)
                    throw new Exception("Unexpected XError returned by server: " + gresp.XError);
            }
        }

        public class GetTitleMultipleSettings : GetSettingBase
        {
            public GetTitleMultipleSettings(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                addsettings(1, 5, SettingSource.XSOURCE_TITLE);
            }

            protected override void run()
            {
                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
                Thread.Sleep(UserSettingBase.cacheTimeout * 1000);

                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, settingsids);
                ReadSettingsResponse gresp = greq.Execute();
                verifyXerror(gresp);
                verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            }
        }

        public class GetGlobalMultipleSettings : GetSettingBase
        {
            public GetGlobalMultipleSettings(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                addsettings(1, 5, SettingSource.XSOURCE_DEFAULT);
            }

            protected override void run()
            {
                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, settingsids);
                ReadSettingsResponse gresp = greq.Execute();
                verifyXerror(gresp);
                verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            }
        }

        public class GetTitlewithGlobalSet : GetSettingBase
        {
            public GetTitlewithGlobalSet(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                addsettings(1, 1, SettingSource.XSOURCE_TITLE);
            }

            protected override void run()
            {
                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, settingsids);
                ReadSettingsResponse gresp = greq.Execute();
                verifyXerror(gresp);
                verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            }
        }

        public class GetTitlewithNoSetting : GetSettingBase
        {
            public GetTitlewithNoSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                users = new ulong[1];
                users[0] = GetUser("User1");
                for (int i = 0; i < users.Length; i++)
                {
                    ProfileWS.ResetUserSetttings(users[i]);
                }
            }

            protected override void run()
            {
                uint[] sIds = new uint[1];
                sIds[0] = (uint)TestUSetting.Test_stringLM_1;

                ReadSettingsRequest req = new ReadSettingsRequest(Title, users[0], users, sIds);
                ReadSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(users[0], TestUSetting.Test_stringLM_1);
                Tsettings = settings;
                verifySettings(resp.Settings, (int)resp.SettingsLen);
            }
        }

        public class GetGlobalwithNoSetting : GetSettingBase
        {
            public GetGlobalwithNoSetting(uint title)
            {
                Title = title;
            }
            protected override void init()
            {
                users = new ulong[1];
                users[0] = GetUser("User1");
                for (int i = 0; i < users.Length; i++)
                    ProfileWS.ResetUserSetttings(users[i]);
            }

            protected override void run()
            {
                uint[] sIds = new uint[1];
                sIds[0] = (uint)TestUSetting.Test_stringLM_1;

                ReadSettingsRequest req = new ReadSettingsRequest(Title, users[0], users, sIds);
                ReadSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(users[0], TestUSetting.Test_stringLM_1);
                Tsettings = settings;
                verifySettings(resp.Settings, (int)resp.SettingsLen);
            }
        }

        public class ReadSettingsSpeedTest : GetSettingBase
        {
            public ReadSettingsSpeedTest(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                return;
            }

            protected override void run()
            {
                DateTime now = DateTime.Now;
                double timePassed = 0;
                DateTime then = DateTime.Now;
                long ticksPassed = 0;
                DateTime nanny = DateTime.Now;
                DateTime ooo = DateTime.Now;
                long ticksPerSecond = ooo.AddSeconds(1).Ticks - ooo.Ticks;

                double[][] timeUncachedMatrix = new double[16][];
                double[][] timeCachedMatrix = new double[16][];
                for (int i = 0; i < 16; i++)
                {
                    timeUncachedMatrix[i] = new double[32];
                    timeCachedMatrix[i] = new double[32];
                }

                //create 16  users
                ulong[] userArray = new ulong[16];
                FriendsCommon fc;
                PNUser xboxUser;
                for (int i = 0; i < userArray.Length; i++)
                {
                    fc = new FriendsCommon();
                    xboxUser = fc.CreateUser(true);
                    //assign this user to global userid for validation later
                    userArray[i] = xboxUser.UserId;
                }

                fc = new FriendsCommon();
                xboxUser = fc.CreateUser(true);
                //assign this user to global userid for validation later
                ulong user = xboxUser.UserId;

                //uncached tests
                uint settingsNum = (uint)TestUSetting.Test_bMaxNo;
                for (int numUsers = 1; numUsers < 17; numUsers++)
                {
                    for (int numSettings = 1; numSettings < 33; numSettings++)
                    {

                        ulong[] users = new ulong[numUsers];
                        //create the user array
                        for (int i = 0; i < numUsers; i++)
                        {
                            users[i] = userArray[i];
                        }
                        //create the settings array
                        uint[] settings = new uint[numSettings];
                        for (int i = 0; i < numSettings; i++)
                        {
                            settings[i] = settingsNum++;
                        }
                        try
                        {

                            now = DateTime.Now;

                            ReadSettingsRequest req = new ReadSettingsRequest(Title, user, users, settings);
                            ReadSettingsResponse resp = req.Execute();

                            then = DateTime.Now;

                            verifyXerror(resp);

                            ticksPassed = then.Ticks - now.Ticks;
                            timePassed = ticksPassed / (double)ticksPerSecond;
                        }
                        catch (Exception e)
                        {
                            _report.Warn("error while sending request: " + e);
                            timeUncachedMatrix[numUsers - 1][numSettings - 1] = -1;
                        }

                        timeUncachedMatrix[numUsers - 1][numSettings - 1] = timePassed;
                    }
                }

                //cached tests
                settingsNum = (uint)TestUSetting.Test_bMaxNo;
                for (int numUsers = 1; numUsers < 17; numUsers++)
                {
                    for (int numSettings = 1; numSettings < 33; numSettings++)
                    {

                        ulong[] users = new ulong[numUsers];
                        //create the user array
                        for (int i = 0; i < numUsers; i++)
                        {
                            users[i] = userArray[i];
                        }
                        //create the settings array
                        uint[] settings = new uint[numSettings];
                        for (int i = 0; i < numSettings; i++)
                        {
                            settings[i] = settingsNum++;
                        }

                        try
                        {
                            now = DateTime.Now;

                            ReadSettingsRequest req = new ReadSettingsRequest(Title, user, users, settings);
                            ReadSettingsResponse resp = req.Execute();

                            then = DateTime.Now;

                            verifyXerror(resp);

                            ticksPassed = then.Ticks - now.Ticks;
                            timePassed = ticksPassed / (double)ticksPerSecond;
                        }

                        catch (Exception e)
                        {
                            _report.Warn("Error while sending request: " + e);
                            timeCachedMatrix[numUsers - 1][numSettings - 1] = -1;
                        }

                        timeCachedMatrix[numUsers - 1][numSettings - 1] = timePassed;

                    }
                }

                //print
                double[] cachedUsers = new double[16];
                double[] uncachedUsers = new double[16];
                double[] cachedSettings = new double[32];
                double[] uncachedSettings = new double[32];
                double cachedOverall = 0;
                for (int i = 0; i < 16; i++)
                {
                    for (int j = 0; j < 32; j++)
                    {
                        _report.Debug("Uncached time for " + i + " users and " + j + " settings " + timeUncachedMatrix[i][j]);
                        _report.Debug("Cached time for " + i + " users and " + j + " settings " + timeCachedMatrix[i][j]);
                        Thread.Sleep(200);
                        cachedUsers[i] += timeCachedMatrix[i][j];
                        uncachedUsers[i] += timeUncachedMatrix[i][j];
                        cachedOverall += timeCachedMatrix[i][j];
                        cachedSettings[j] += timeCachedMatrix[i][j];
                        uncachedSettings[j] += timeUncachedMatrix[i][j];

                    }
                    cachedUsers[i] = cachedUsers[i] / 16.0;
                    uncachedUsers[i] = uncachedUsers[i] / 16.0;
                }

                for (int i = 0; i < 16; i++)
                {
                    _report.Debug("Cached average time for " + i + " users " + cachedUsers[i]);
                    _report.Debug("Uncached average time for " + i + " users " + uncachedUsers[i]);
                    Thread.Sleep(200);
                }
                for (int i = 0; i < 32; i++)
                {
                    _report.Debug("Cached average time for " + i + " Settings " + cachedSettings[i] / 32.0);
                    _report.Debug("Uncached average time for " + i + " settings " + uncachedSettings[i] / 32.0);
                    Thread.Sleep(200);
                }


                _report.Debug("Cached average time FOR ALL " + cachedOverall / (16.0 * 32.0));

            }
        }
    }

    public abstract class GetSettingBase : TestNode
    {
        public static Hashtable gusers = new Hashtable();
        protected uint Title = 0;
        protected ulong[] users = null;
        protected UserSetting[] Tsettings = null;
        protected uint[] settingsids = null;
        protected Report _report = new Report("Log");

        abstract protected void init();
        abstract protected void run();

        public ulong GetUser(string name)
        {
            return (ulong)gusers[name];
        }
        private bool isValidSettingID(UserSetting setting)
        {
            return SettingIds.isValidSettingID((uint)setting.SettingId);
        }
        //1 IMPORTANT global variable Title needs to contain the title this setting was synced with! 
        private void verifyCacheEntryAfterSyncSetting(UserSetting setting) //param is the setting that was synced 
        {

            xonline.common.service.Acceleration xb = new xonline.common.service.Acceleration(Interface.ProfileCache);
            byte[] expectedValue = setting.Value;
            uint expectedRetVal = HResult.S_OK;
            uint titleID = (setting.Source == (uint)SettingSource.XSOURCE_DEFAULT) ? XOn.XENON_DASH_TITLE_ID : Title;

            //should be in Cache because of the Syncsettings call, unless we're requesting the public gamerpicture of a friend that has the non special key cached
            //cache won't return the special value that we're looking for, so we'll just skip it all together
            if (setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY ||
                setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE ||
                setting.SettingId == ProfileDefs.XPROFILE_GAMER_TIER ||
                setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS)
            {
                return;
            }

            //determine the correct title to query for
            //first, is this setting title writeable? if it is not, and we tried to sync something to it, then it isn't cached, so we should expect NOTHING from cache
            SettingInfo sinfo = null;
            if (isValidSettingID(setting))
            {
                sinfo = SettingIds.Item(setting.SettingId);
                if (sinfo == null)
                {
                    throw new Exception("Failed to load setting " + setting.SettingId + " to determine if it is title writeable during cache verification.");
                }
            }

            //not going to be in cache cases: expect S_FALSE

            if (!isValidSettingID(setting) ||
                (!sinfo.IsTitleWritable() && titleID != XOn.XENON_DASH_TITLE_ID) ||
                setting.Source == (uint)SettingSource.XSOURCE_PERMISSION_DENIED)
            {
                expectedRetVal = HResult.S_FALSE;
                expectedValue = null;
            }
            //the NoValueCases
            else if (setting.Source == (uint)SettingSource.XSOURCE_NO_VALUE) //the setting was zeroed out
            {
                expectedValue = xonline.common.protocol.ProfileDefs.CacheNoValue;
                expectedRetVal = HResult.S_OK;
            }

            //syncing either puts the value in cache, or it is not there.
            //build the cache key
            byte[] key = xonline.common.protocol.ProfileDefs.BuildCacheKey(setting.SettingId, titleID, setting.userId);
            byte[] value = null;

            //query cache for the setting
            uint hr = xb.Query(key, out value);
            if (hr != expectedRetVal)
            {
                throw new Exception("Querying Cache for Setting: " + setting.SettingId + " TitleID: " + titleID + " and UserID: " + setting.userId + " Returned: " + hr + ", Expected: " + expectedRetVal);
            }
            if (expectedRetVal == HResult.S_OK) //something was returned from the query. let's see if it was expected.
            {
                //compare the returned value with the expected value
                if (!xonline.common.service.Acceleration.CompareByteArrays(expectedValue, value))
                {
                    throw new Exception("Querying Cache for Setting: " + setting.SettingId + " TitleID: " + titleID + " and UserID: " + setting.userId + " did not return the expected value.");
                }
            }
        }

        //1 IMPORTANT global variable Title needs to contain the title this setting was read with! 
        private void verifyCacheEntryAfterReadSetting(UserSetting setting) //param is the result of the readsettings
        {
            xonline.common.service.Acceleration xb = new xonline.common.service.Acceleration(Interface.ProfileCache);
            byte[] expectedValue = setting.Value;
            uint expectedRetVal = HResult.S_OK;
            uint titleID = Title;

            uint hr;
            byte[] key = null;
            byte[] value = null;

            //should be in Cache because of the Syncsettings call, unless we're requesting the public gamerpicture of a friend that has the non special key cached
            //cache won't return the special value that we're looking for, so we'll just skip it all together
            if (setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY ||
                setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE ||
                setting.SettingId == ProfileDefs.XPROFILE_GAMER_TIER ||
                setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS)
            {
                return;
            }

            if (Title != XOn.XENON_DASH_TITLE_ID)
            {
                //see what cache stored into the TITLE OVERRIDE
                SettingInfo sinfo = null;
                if (isValidSettingID(setting))
                {
                    sinfo = SettingIds.Item(setting.SettingId);
                    if (sinfo == null)
                    {
                        throw new Exception("Failed to load setting " + setting.SettingId + " to determine if it is title writeable during cache verification.");
                    }
                }

                //not going to be in cache cases: expect S_FALSE
                if (!isValidSettingID(setting) ||
                    !sinfo.IsTitleWritable() ||
                    setting.Source == (uint)SettingSource.XSOURCE_PERMISSION_DENIED)
                {
                    expectedRetVal = HResult.S_FALSE;
                    expectedValue = null;
                }
                //the NoValueCases
                else if (setting.Source == (uint)SettingSource.XSOURCE_DEFAULT || //the setting returned came from the dash
                    setting.Source == (uint)SettingSource.XSOURCE_NO_VALUE) //the setting does not exist
                {
                    expectedValue = xonline.common.protocol.ProfileDefs.CacheNoValue;
                    expectedRetVal = HResult.S_OK;
                }

                //build the cache key
                key = xonline.common.protocol.ProfileDefs.BuildCacheKey(setting.SettingId, titleID, setting.userId);
                value = null;

                //query cache for the setting
                hr = xb.Query(key, out value);
                if (hr != expectedRetVal)
                {
                    throw new Exception("Querying Cache for Setting: " + setting.SettingId + " TitleID: " + titleID + " and UserID: " + setting.userId + " Returned: " + hr + ", Expected: " + expectedRetVal);
                }
                if (expectedRetVal == HResult.S_OK) //something was returned from the query. let's see if it was expected.
                {
                    //compare the returned value with the expected value
                    if (!xonline.common.service.Acceleration.CompareByteArrays(expectedValue, value))
                    {
                        throw new Exception("Querying Cache for Setting: " + setting.SettingId + " TitleID: " + titleID + " and UserID: " + setting.userId + " did not return the expected value.");
                    }
                }
            }
            //do the same thing for the DASH
            titleID = XOn.XENON_DASH_TITLE_ID;
            expectedValue = setting.Value;
            expectedRetVal = HResult.S_OK;

            //not going to be in cache cases: expect S_FALSE
            if (!isValidSettingID(setting) ||
                setting.Source == (uint)SettingSource.XSOURCE_PERMISSION_DENIED)
            {
                expectedRetVal = HResult.S_FALSE;
                expectedValue = null;
            }
            //NoValue cases
            else if (setting.Source == (uint)SettingSource.XSOURCE_NO_VALUE) //the setting does not exist
            {
                expectedValue = xonline.common.protocol.ProfileDefs.CacheNoValue;
                expectedRetVal = HResult.S_OK;
            }
            //weird case where there is both title and dash settings in the database, but we asked for the title, so we don't know what is the dash id- so we can't verify the data
            else if (setting.Source == (uint)SettingSource.XSOURCE_TITLE)
            {
                //we don't know if there is no value for the dash or not.
                expectedRetVal = HResult.S_OK;
                expectedValue = null;
            }

            //build the cache key
            key = xonline.common.protocol.ProfileDefs.BuildCacheKey(setting.SettingId, titleID, setting.userId);
            value = null;

            //query cache for the setting
            hr = xb.Query(key, out value);
            if (hr != expectedRetVal)
            {
                throw new Exception("Querying Cache for Setting: " + setting.SettingId + " TitleID: " + titleID + " and UserID: " + setting.userId + " Returned: " + hr + ", Expected: " + expectedRetVal);
            }
            if (expectedRetVal == HResult.S_OK) //something was returned from the query. let's see if it was expected.
            {
                //compare the returned value with the expected value
                if (expectedValue != null && !xonline.common.service.Acceleration.CompareByteArrays(expectedValue, value))
                {
                    throw new Exception("Querying Cache for Setting: " + setting.SettingId + " TitleID: " + titleID + " and UserID: " + setting.userId + " did not return the expected value.");
                }
            }
        }

        public void addsettings(int usercount, int settingcount, SettingSource source)
        {
            RandomEx rand = new RandomEx();
            settingsids = new uint[settingcount];

            uint baseid = (uint)TestUSetting.Test_bMaxNo;
            for (uint p = 0; p < settingcount; p++)
            {
                settingsids[p] = baseid + p;
            }

            users = new ulong[usercount];
            int totalsettings = usercount * settingcount;
            Tsettings = new UserSetting[totalsettings];

            int max = (int)GSLimits.XONLINE_MAX_SETTING_VALUE_BYTES;
            int total = 0;
            for (int i = 0; i < usercount; i++)
            {
                users[i] = GetUser("User" + (i + 1));
                ProfileWS.ResetUserSetttings(users[i]);

                UserSetting[] settings = new UserSetting[settingsids.Length];
                for (int j = 0; j < settingsids.Length; j++)
                {
                    Tsettings[total++] = settings[j] = new UserSetting(users[i], settingsids[j], rand.GenerateRandomBlob(max - 10), source);
                }



                SyncSettingsRequest req = new SyncSettingsRequest(Title, users[i], settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.Execute();
                if (resp.XError != 0)
                    throw new Exception("Error loading settings XError: " + resp.XError);
                foreach (UserSetting s in settings)
                {
                    verifyCacheEntryAfterSyncSetting(s);
                }
            }

        }

        public void verifyXerror(ReadSettingsResponse resp)
        {
            if (resp.XError != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server: " + resp.XError);

        }

        public override void Run()
        {
            init();
            run();
        }

        public void verifySettings(UserSetting[] respsettings, int respSettingLen)
        {
            if (respSettingLen != Tsettings.Length)
                throw new Exception("Setting count is different Expected: " + Tsettings.Length + " Received: " + respSettingLen);

            for (int i = 0; i < Tsettings.Length; i++)
            {
                if (respsettings[i].SettingId != Tsettings[i].SettingId)
                    throw new Exception("Setting ID is different Expected: " + Tsettings[i].SettingId + " Received: " + respsettings[i].SettingId);

                if (respsettings[i].Source != Tsettings[i].Source)
                    throw new Exception("Setting Source is different Expected: " + Tsettings[i].Source + " Received: " + respsettings[i].Source);

                if (respsettings[i].Source == (uint)SettingSource.XSOURCE_NO_VALUE)
                    continue;

                if (respsettings[i].ValueLen != Tsettings[i].Value.Length)
                    throw new Exception("Setting value len is different Expected: " + Tsettings[i].ValueLen + " Received: " + respsettings[i].ValueLen);


                for (int vl = 0; vl < Tsettings[i].Value.Length; vl++)
                {
                    if (respsettings[i].Value[vl] != Tsettings[i].Value[vl])
                        throw new Exception("Setting value  is different at idx " + vl + " Expected: " + Tsettings[i].Value[vl] + " Received: " + respsettings[i].Value[vl]);
                }

                //verify the correct settings are in cache- assume verifySettings is called after ReadSettings
                verifyCacheEntryAfterReadSetting(respsettings[i]);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\NegSyncGetSettings.cs ===
using System;
using System.Collections;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace GamerSettings
{
    /// <summary>
    /// Summary description for NegSyncGetSettings.
    /// </summary>
    public class NegSyncGetSettings : TestNode
    {
        public static void verifyXErrorNum(uint actual, uint expected)
        {
            if (actual != expected)
                throw new Exception("Expected HR=" + expected.ToString("X") +
                                    " but received:" + actual.ToString("X"));
        }

        public NegSyncGetSettings()
        {
            AddChild(new InvalidSettingIDGlobal(Titles.Global));
            AddChild(new InvalidSettingIDTitle(Titles.NegTitle1));
            AddChild(new MixValidAndInvalidSetting(Titles.NegTitle1));
            AddChild(new InvalidValueLenPlus1(Titles.NegTitle1));
            AddChild(new InvalidValueLen4XMax(Titles.NegTitle1));
            AddChild(new InvalidCountLenPlus1(Titles.NegTitle1));
            AddChild(new InvalidGetMaxPlus1(Titles.NegTitle1));

            // test that need new xrl object.
            AddChild(new InvalidValueMismatchLen(Titles.NegTitle1));
            AddChild(new InvalidMixGoodandMixmatchvalLen(Titles.NegTitle1));
            AddChild(new InvalidMixGoodandMixmatchvalLen2(Titles.NegTitle1));
            AddChild(new InvalidSettingMismatchCount(Titles.NegTitle1));
            AddChild(new InvalidUserGetMismatchCount(Titles.NegTitle1));
            AddChild(new InvalidSettingGetMismatchCount(Titles.NegTitle1));
            AddChild(new InvalidLongHttpheaders(Titles.NegTitle1));

            // SGAuth tests
            AddChild(new SGAuthDiffuser(Titles.NegTitle1));
            AddChild(new HttpAuthDiffuser(Titles.NegTitle1));

            AddChild(new TCInvalidSmallPKT());
            AddChild(new TCInvalidLargePKT());

            //TransientProfileSettingTests
            AddChild(new InvalidSyncTransientPartyInfoSettingMaxLenPlus1(Titles.Global));
            AddChild(new InvalidSyncTransientPartyInfoSettingNull(Titles.Global));
            AddChild(new InvalidSyncTransientPartyInfoSettingEmpty(Titles.Global));

            // BUG 37303 - Hacking the gamerzone profile field causes crash
            AddChild(new InvalidSyncGamerZone(Titles.Global));
        }

        public class ProfileInvalidXRLRequest : XRLPayload
        {
            int _bytestosend = 0;
            string _url = null;

            public ProfileInvalidXRLRequest(int bytestosend, string url)
            {
                _bytestosend = bytestosend;
                _url = url;
            }

            protected override string GetServiceName()
            {
                return _url;
            }

            new public uint Execute()
            {
                // Prepare request 
                MemoryStream reqStream = new MemoryStream(512);
                byte[] buffer = new byte[_bytestosend];
                Random rand = new Random();
                rand.NextBytes(buffer);
                BinaryWriter writer = new BinaryWriter(reqStream);
                writer.Write(buffer);

                bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.profilefd), reqStream);
                return this.XErr;
            }
        }

        public class TCInvalidSmallPKT : UserSettingBase
        {
            public override void Run()
            {
                ProfileInvalidXRLRequest tmp = new ProfileInvalidXRLRequest(10, "/xstats/syncsettings.ashx");
                uint xerror = tmp.Execute();
                verifyXErrorNum(xerror, HResult.XONLINE_E_END_OF_STREAM);
            }
        }

        public class TCInvalidLargePKT : UserSettingBase
        {
            public override void Run()
            {
                ProfileInvalidXRLRequest tmp = new ProfileInvalidXRLRequest(1000 * 1000, "/xstats/syncsettings.ashx");
                uint xerror = tmp.Execute();
            }
        }


        public class HttpAuthDiffuser : UserSettingBase
        {
            public HttpAuthDiffuser(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                req.Modifyflag = AuthModify.Change_User;

                SyncSettingsResponse resp = req.ExecuteToInt();
                verifyXErrorNum(resp.XError, HResult.XONLINE_E_SERVER_ERROR);
            }
        }

        public class SGAuthDiffuser : UserSettingBase
        {
            public SGAuthDiffuser(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {

                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                req.Modifyflag = AuthModify.Change_User;

                SyncSettingsResponse resp = req.Execute();
                verifyXErrorNum(resp.XError, HResult.XONLINE_E_SERVER_ERROR);
            }
        }

        public class InvalidLongHttpheaders : UserSettingBase
        {
            public InvalidLongHttpheaders(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                req.CustomHeader = "LongHeader : " + rand.GenerateRandomUTFString(2000) + "\r\n";

                SyncSettingsResponse resp = req.Execute();

                verifyByReading(settings);
            }
        }

        public class InvalidUserGetMismatchCount : GetSettingBase
        {
            public InvalidUserGetMismatchCount(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                addsettings(2, 5, SettingSource.XSOURCE_DEFAULT);
            }

            protected override void run()
            {
                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, 5, settingsids, 5);
                ReadSettingsResponse gresp = greq.Execute();

                verifyXErrorNum(gresp.XError, HResult.XONLINE_E_END_OF_STREAM);
            }
        }

        public class InvalidSettingGetMismatchCount : GetSettingBase
        {
            public InvalidSettingGetMismatchCount(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                addsettings(1, 5, SettingSource.XSOURCE_DEFAULT);
            }


            protected override void run()
            {
                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, 1, settingsids, 10);
                ReadSettingsResponse gresp = greq.Execute();

                verifyXErrorNum(gresp.XError, HResult.XONLINE_E_END_OF_STREAM);
            }

        }

        public class InvalidSettingMismatchCount : UserSettingBase
        {
            public InvalidSettingMismatchCount(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                UserSetting[] settings = new UserSetting[2];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)123456));
                settings[1] = new UserSetting(Userid, TestUSetting.Test_binary16, SConvert.Bytes((int)12345));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, 3, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXErrorNum(resp.XError, HResult.XONLINE_E_END_OF_STREAM);
            }
        }

        public class InvalidMixGoodandMixmatchvalLen2 : UserSettingBase
        {
            public InvalidMixGoodandMixmatchvalLen2(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                UserSetting[] settings = new UserSetting[2];
                uint len = 25;
                settings[1] = new UserSetting(Userid, TestUSetting.Test_binaryM_2, rand.GenerateRandomBlob((int)len), len + 10, SettingSource.XSOURCE_DEFAULT);
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXErrorNum(resp.XError, HResult.XONLINE_E_END_OF_STREAM);
            }
        }

        public class InvalidMixGoodandMixmatchvalLen : UserSettingBase
        {
            public InvalidMixGoodandMixmatchvalLen(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                UserSetting[] settings = new UserSetting[2];
                uint len = 25;
                settings[1] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));
                settings[0] = new UserSetting(Userid, TestUSetting.Test_binaryM_2, rand.GenerateRandomBlob((int)len), len + 10, SettingSource.XSOURCE_DEFAULT);

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXErrorNum(resp.XError, HResult.XONLINE_E_END_OF_STREAM);
            }
        }

        public class InvalidValueMismatchLen : UserSettingBase
        {
            public InvalidValueMismatchLen(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                UserSetting[] settings = new UserSetting[1];
                uint len = 4;
                settings[0] = new UserSetting(Userid, TestUSetting.Test_binaryM_2, rand.GenerateRandomBlob((int)len), len + 4, SettingSource.XSOURCE_DEFAULT);
                settings[0].ManualArraySize = true;

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                // Is this a bug to enter?  If the last setting has an invalid length, the server deals with it just fine
                // but if there is a setting after the invalid length setting, than the server will fail appropriately
                // This actually will work, changing from expecting XONLINE_E_END_OF_STREAM
                //verifyXErrorNum(resp.XError, HResult.S_OK);
                verifyXErrorNum(resp.XError, HResult.XONLINE_E_END_OF_STREAM);
            }
        }

        public class InvalidGetMaxPlus1 : GetSettingBase
        {
            int maxuser = 0;
            int maxset = 0;
            UserSetting[] settings;
            public InvalidGetMaxPlus1(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                maxuser = GSLimits.XONLINE_MAX_SETTING_USERS;
                maxset = GSLimits.XONLINE_MAX_SETTING_COUNT;
                addsettings(maxuser, maxset, SettingSource.XSOURCE_TITLE);

                settings = new UserSetting[1];
                settings[0] = new UserSetting(GetUser("User1"), TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, GetUser("User1"), settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
            }

            protected override void run()
            {
                int len = (maxset) + 1;
                uint[] newsetids = new uint[len];
                Array.Copy(settingsids, newsetids, len - 1);
                newsetids[len - 1] = settings[0].SettingId;
                ReadSettingsRequest greq = new ReadSettingsRequest(Title, users[0], users, newsetids);
                ReadSettingsResponse gresp = greq.Execute();

                verifyXErrorNum(gresp.XError, HResult.XONLINE_E_DESERIALIZATION_ERROR);
            }

        }

        public class InvalidCountLenPlus1 : UserSettingBase
        {
            public InvalidCountLenPlus1(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                int maxsettings = (int)GSLimits.XONLINE_MAX_SETTING_COUNT + 1;
                UserSetting[] settings = new UserSetting[maxsettings];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < maxsettings; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)));
                }

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXErrorNum(resp.XError, HResult.XONLINE_E_DESERIALIZATION_ERROR);
            }

        }

        public class InvalidValueLen4XMax : UserSettingBase
        {
            public InvalidValueLen4XMax(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                Global.RO.Info("length =1");
                int max = (int)GSLimits.XONLINE_MAX_SETTING_VALUE_BYTES;
                Global.RO.Info("length =4*Max");
                AddsettingandVerify(max * 4);
            }

            protected void AddsettingandVerify(int length)
            {
                RandomEx rand = new RandomEx();
                UserSetting[] settings = new UserSetting[1];
                string data = rand.GenerateRandomString(length);
                byte[] bytedata = SConvert.Bytes(data, length);
                settings[0] = new UserSetting(Userid, TestUSetting.Test_binaryM, bytedata);

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXErrorNum(resp.XError, HResult.XONLINE_E_DESERIALIZATION_ERROR);
            }
        }

        public class InvalidValueLenPlus1 : UserSettingBase
        {
            public InvalidValueLenPlus1(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                Global.RO.Info("length =1");

                int length = (int)GSLimits.XONLINE_MAX_SETTING_VALUE_BYTES + 1;
                RandomEx rand = new RandomEx();
                UserSetting[] settings = new UserSetting[1];
                string data = rand.GenerateRandomString(length);
                byte[] bytedata = SConvert.Bytes(data, length);
                settings[0] = new UserSetting(Userid, TestUSetting.Test_binaryM, bytedata);

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXErrorNum(resp.XError, HResult.XONLINE_E_DESERIALIZATION_ERROR);
            }
        }

        public class MixValidAndInvalidSetting : UserSettingBase
        {
            public MixValidAndInvalidSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[2];
                int setid = ((int)TestUSetting.Test_bMaxNo + 512);
                settings[0] = new UserSetting(Userid, (uint)setid, SConvert.Bytes((long)42174382));
                settings[1] = new UserSetting(Userid, TestUSetting.Test_binaryM_1, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXerror(resp);

                settings[0].Source = (uint)SettingSource.XSOURCE_NO_VALUE;
                settings[0].ValueLen = 0;
                settings[0].Value = null;

                verifyByReading(settings);
            }
        }

        public class InvalidSettingIDTitle : UserSettingBase
        {
            public InvalidSettingIDTitle(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[1];
                int setid = ((int)TestUSetting.Test_bMaxNo + 512);
                settings[0] = new UserSetting(Userid, (uint)setid, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXerror(resp);

                settings[0].Source = (uint)SettingSource.XSOURCE_NO_VALUE;
                settings[0].ValueLen = 0;
                settings[0].Value = null;
                verifyByReading(settings);
            }
        }

        public class InvalidSettingIDGlobal : UserSettingBase
        {
            public InvalidSettingIDGlobal(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[1];
                int setid = ((int)TestUSetting.Test_bMaxNo + 512);
                settings[0] = new UserSetting(Userid, (uint)setid, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXerror(resp);

                settings[0].Source = (uint)SettingSource.XSOURCE_NO_VALUE;
                settings[0].ValueLen = 0;
                settings[0].Value = null;
                verifyByReading(settings);
            }
        }

        // Transient Profile Setting Test Case
        // Sync PARTY_INFO setting for a user, and then read it
        public class InvalidSyncTransientPartyInfoSettingMaxLenPlus1 : UserSettingBase
        {
            public InvalidSyncTransientPartyInfoSettingMaxLenPlus1(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User10");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();
                UserSetting[] settings = new UserSetting[1];
                int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO >> 16) & 0x3FF);
                settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO, rand.GenerateRandomBlob(settingIDMaxSize + 1));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXerror(resp);
                // Verify that no value is returned, and that cache also fails to find the request
                //verifyByReadingNoValue(settings);

                // KKLINE - Rather than try to create a new function for just this one case
                // I'm just extracting the code from verifyByReadingNoValue which expects HR=1 for the xbanc return

                ulong[] friends = new ulong[1];
                friends[0] = Userid;

                uint[] sIds = new uint[settings.Length];

                for (int i = 0; i < settings.Length; i++)
                {
                    sIds[i] = settings[i].SettingId;
                }

                ReadSettingsRequest rreq = new ReadSettingsRequest(Title, Userid, friends, sIds);
                ReadSettingsResponse rresp = rreq.Execute();

                if (rresp.XError != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server :" + rresp.XError);

                if (rresp.SettingsLen != settings.Length)
                    throw new Exception("Setting count is different Expected :" + settings.Length + " Received:" + rresp.SettingsLen);

                for (int i = 0; i < settings.Length; i++)
                {

                    if (rresp.Settings[i].SettingId != settings[i].SettingId)
                        throw new Exception("Setting ID is different Expected :" + settings[i].SettingId + " Received:" + rresp.Settings[i].SettingId);

                    if (rresp.Settings[i].Source != (uint)SettingSource.XSOURCE_NO_VALUE)
                        throw new Exception("Setting Source is different Expected :" + SettingSource.XSOURCE_NO_VALUE + " Received:" + rresp.Settings[i].Source);

                    if (rresp.Settings[i].ValueLen != 0)
                        throw new Exception("Setting ValueLen is different Expected :0 Received:" + rresp.Settings[i].ValueLen);

                    xonline.common.service.Acceleration xb = new xonline.common.service.Acceleration(Interface.ProfileCache);
                    byte[] expectedValue = settings[i].Value;

                    uint hr;
                    byte[] key = null;
                    byte[] value = null;

                    //build the cache key
                    key = xonline.common.protocol.ProfileDefs.BuildCacheKey(settings[i].SettingId, Title, settings[i].userId);
                    value = null;

                    //query cache for the setting
                    hr = xb.Query(key, out value);
                    if (hr != 1)
                    {
                        throw new Exception("Querying Cache for setting " + settings[i].SettingId + " titleID " + Title + " and userID " + settings[i].userId + " returned hr: " + hr + ", expected hr: 0");
                    }
                }

            }
        }

        // Transient Profile Setting Test Case
        // Sync PARTY_INFO setting for a user, and then read it
        public class InvalidSyncTransientPartyInfoSettingNull : UserSettingBase
        {
            public InvalidSyncTransientPartyInfoSettingNull(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User11");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO, null);

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXerror(resp);
                settings[0].Source = (uint)SettingSource.XSOURCE_NO_VALUE;
                settings[0].ValueLen = 0;
                settings[0].Value = null;
                verifyByReading(settings);
            }
        }

        // Transient Profile Setting Test Case
        // Sync PARTY_INFO setting for a user, and then read it
        public class InvalidSyncTransientPartyInfoSettingEmpty : UserSettingBase
        {
            public InvalidSyncTransientPartyInfoSettingEmpty(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User13");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO, rand.GenerateRandomBlob(0));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXerror(resp);
                settings[0].Source = (uint)SettingSource.XSOURCE_NO_VALUE;
                settings[0].ValueLen = 0;
                settings[0].Value = null;
                verifyByReading(settings);

            }
        }

        // Invalid Sync of XPROFILE_GAMERCARD_ZONE field outside of the acceptable values
        // Unable to do this without hacking your profile, but when you do it crashes the console
        // and any console that tries to read the invalid value from our database
        // Valid values are:  0 = xbox1, 1 = Recreation, 2 = Pro, 3 = Family, 4 = Underground
        public class InvalidSyncGamerZone : UserSettingBase
        {
            public InvalidSyncGamerZone(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User2");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();
                UserSetting[] settings = new UserSetting[1];
                // Set the value to 5, the first invalid value you can pass
                settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_ZONE, SConvert.Bytes(5));

                Global.RO.Info("Sync invalid XPROFILE_GAMERCARD_ZONE of 5 to the service");
                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                Global.RO.Info("The value is rejected, so validate that no value is returned from xbanc");
                verifyXerror(resp);
                // Server ignores the out of range value and it never goes in xbanc
                verifyByReadingNoValue(settings);

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\ClearTitle.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.AvatarAsset;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Database;
using xonline.common.config;


namespace GamerSettings
{
    /// <summary>
    /// Summary description for ClearTitle.
    /// </summary>
    public class ClearTitle : TestNode
    {
        public ClearTitle()
        {
            AddChild(new ClearSingletitle());
            AddChild(new ClearMultipletitle());
            AddChild(new Clearnonexistingtitle());
            AddChild(new ClearnonexistingUser());
            AddChild(new TCInvalidSmallPKT());
            AddChild(new TCInvalidLargePKT());
            //Case for making sure ClearTitle also clears Cache
            AddChild(new ClearTitleAndVerifyCacheClear());

            // Added to validate Title Clear updates
            // to validate no gamerscore prior to deleting title, and that
            // no achievements or avatar assets have the Not Achievable flag marked
            AddChild(new P_ClearTitleWithAvatarAssets());
            AddChild(new N_ClearTitlewithAchievements());
            AddChild(new N_ClearTitleAvatarAssetswithNotAchievableFlag());
            AddChild(new N_ClearTitlewithAchievementsNotAchievable());
            AddChild(new N_ClearTitlewithAchievementsWasNotAchievable());
        }

        public class ClearnonexistingUser : TestNode
        {
            public override void Run()
            {
                ulong user = 501;

                TitleBase tbase = new TitleBase();
                tbase.loadtitles(1, user);

                TitleClearRequest req = new TitleClearRequest(user + 98765, tbase.titlebase);
                if (!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd)))
                {
                    if (req.XErr != HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD)
                        throw new Exception("unexpected Xerror recived Expected =" + HResult.XONLINE_E_STAT_USER_NOT_FOUND + " Received =" + req.XErr);
                }
            }
        }

        public class Clearnonexistingtitle : TestNode
        {
            public override void Run()
            {
                ulong user = 501;

                TitleBase tbase = new TitleBase();
                tbase.loadtitles(1, user);

                TitleClearRequest req = new TitleClearRequest(user, tbase.titlebase + 500);
                if (!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd)))
                {
                    if (req.XErr != HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD)
                        throw new Exception("unexpected Xerror recived Expected =" + HResult.XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD + " Received =" + req.XErr);
                }
            }
        }

        public class ClearMultipletitle : TestNode
        {

            public override void Run()
            {
                ulong user = 501;

                TitleBase tbase = new TitleBase();
                tbase.loadtitles(10, user);

                for (int i = 0; i < 3; i++)
                {
                    TitleClearRequest req = new TitleClearRequest(user, (uint)(tbase.titlebase + i));
                    if (req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd)))
                    {
                        //enum and verify that title data is deleted
                        EnumTitlesRequest ereq = new EnumTitlesRequest(user, user, 0, 10, 1033);
                        EnumTitlesResponse eresp = ereq.Execute();
                        if (0 != eresp.XError)
                            throw new Exception("UnExpected HResult excepted =" + 0 + "Received" + eresp.XError);

                        if ((9 - i) != eresp.TitlesLen)
                            throw new Exception("Number of titles returned are different excepted =" + (9 - i) + "Received" + eresp.TitlesLen);

                        for (int j = 0; j < eresp.TitlesLen; j++)
                        {
                            UserTitle recived = eresp.Titles[j];
                            if (recived.TitleId < tbase.titlebase + i)
                                throw new Exception("unexpected title returned " + recived.TitleId);
                        }
                    }
                    else
                    {
                        throw new TestSuiteException("ClearMultipletitle failed");
                    }
                }
            }
        }

        [TestFrequency("Daily"), TestCasePriority(1), Description("Clear single title")]
        public class ClearSingletitle : TestNode
        {
            public override void Run()
            {
                ulong user = 501;

                TitleBase tbase = new TitleBase();
                tbase.loadtitles(1, user);

                TitleClearRequest creq = new TitleClearRequest(user, tbase.titlebase);
                if (creq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd)))
                {
                    //enum and verify that title data is deleted
                    EnumTitlesRequest req = new EnumTitlesRequest(user, user, 0, 10, 1033);
                    EnumTitlesResponse resp = req.Execute();
                    if (0 != resp.XError)
                        throw new Exception("UnExpected HResult excepted =" + 0 + "Received" + resp.XError);

                    if (0 != resp.TitlesLen)
                        throw new Exception("Number of titles returned are different excepted =" + 0 + "Received" + resp.TitlesLen);
                }
            }
        }

        public class TCInvalidSmallPKT : TestNode
        {
            public override void Run()
            {
                InvalidXRLRequest tmp = new InvalidXRLRequest(10, "/xstats/cleartitle.ashx");
                uint xerror = tmp.Execute();
                if (xerror != HResult.XONLINE_E_END_OF_STREAM)
                    throw new Exception("Invalid Xerror Expected :" + HResult.E_FAIL + " received:" + xerror);
            }
        }

        public class TCInvalidLargePKT : TestNode
        {
            public override void Run()
            {
                // kkline - changed this to 1200 from 1000*1000 because this case wasn't working
                // and honestly i have no idea what it was really trying to accomplish
                InvalidXRLRequest tmp = new InvalidXRLRequest(1000 * 100, "/xstats/cleartitle.ashx");
                uint xerror = tmp.Execute();

                if (xerror != HResult.XONLINE_E_SERVER_ERROR)
                    throw new Exception("Invalid Xerror Expected : " + HResult.E_FAIL + " received: " + xerror);
            }
        }

        // This test validates that when you clear a title from a user's profile
        // Cache is also cleared of any title specific settings for that user
        [Ignore("This is being ignored because ProfileMvc has not yet implemented DeleteSetting. This work is being tracked by TFS#82149")]
        [TestFrequency("BVT"), BVT, TestCasePriority(1), Description("Clear single title with cache validation")]
        public class ClearTitleAndVerifyCacheClear : TestNode
        {
            public override void Run()
            {
                ulong user = 501;

                // Load one title for us to clear
                TitleBase tbase = new TitleBase();
                tbase.loadtitles(1, user);

                // Now sync a title specific setting for this user and title
                // so that we can make sure the setting in Cache is cleared
                ProfileWS.ResetUserSetttings(user);
                UserSetting[] settings = new UserSetting[1];
                // using a profile setting that has the title flag set, and using the source for titles
                settings[0] = new UserSetting(user, ProfileDefs.XPROFILE_TITLE_SPECIFIC1, SConvert.Bytes((long)123456), SettingSource.XSOURCE_TITLE);
                SyncSettingsRequest sreq = new SyncSettingsRequest(tbase.titlebase, user, settings, DateTime.UtcNow);
                SyncSettingsResponse sresp = sreq.Execute();
                if (sresp.XError != 0)
                    throw new Exception("error loading settings XERROR " + sresp.XError);

                // Clear the title
                TitleClearRequest creq = new TitleClearRequest(user, tbase.titlebase);
                if (creq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd)))
                {
                    //enum and verify that title data is deleted
                    EnumTitlesRequest req = new EnumTitlesRequest(user, user, 0, 10, 1033);
                    EnumTitlesResponse resp = req.Execute();
                    if (0 != resp.XError)
                        throw new Exception("Unexpected HResult: expected =" + 0 + "Received" + resp.XError);

                    if (0 != resp.TitlesLen)
                        throw new Exception("Number of titles returned are different expected =" + 0 + "Received" + resp.TitlesLen);

                    // Now that we validated the title is cleared
                    // we need to ensure the setting was cleared from cache for this title
                    uint[] sIds = new uint[1];
                    sIds[0] = settings[0].SettingId;

                    ReadSettingsRequest greq = new ReadSettingsRequest(tbase.titlebase, user, new ulong[] { user }, sIds);
                    ReadSettingsResponse gresp = greq.Execute();

                    // use the function for verifying that a no value was returned from cache for this setting
                    // for the user and title 
                    UserSettingBase ubase = new UserSettingBase();
                    ubase.Title = tbase.titlebase;
                    ubase.Userid = user;
                    ubase.verifyByReadingNoValue(settings);
                }
            }
        }

        [TestFrequency("Daily"), TestCasePriority(1), Description("Try to call TitleClear for a user/title/avatarawarded items with no gamerscore")]
        public class P_ClearTitleWithAvatarAssets : TestNode
        {
            public override void Run()
            {
                ulong user = 550;
                uint title = 50;
                uint assetOrdinal = 3;

                TitleBase tbase = new TitleBase();
                Global.RO.Info("Sync Single Title");
                // First title is Title 50
                tbase.loadtitles(1, user);

                // Award an Avatar Asset in Title 50
                Global.RO.Info("Sync Single Asset");
                AvatarAssetBase avbase = new AvatarAssetBase();
                avbase.ClearAvatarAsset(user);
                AvatarAssetWD asset = new AvatarAssetWD(assetOrdinal, (byte)3, 1);
                XRLSyncAvatarAssets avreq = new XRLSyncAvatarAssets(title, user, new AvatarAssetWD[] { asset });
                SyncAvatarAssetsResponse avresp = avreq.Execute();

                // Verify the response was ok
                if (avresp.xResult != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + avresp.xResult);

                // At this point we have a user with a title and an asset with no gamerscore
                Global.RO.Info("Call Title Clear");
                TitleClearRequest creq = new TitleClearRequest(user, tbase.titlebase);
                if (creq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd)))
                {
                    //enum and verify that title data is deleted
                    Global.RO.Info("Enum Title and make sure it's gone");
                    EnumTitlesRequest req = new EnumTitlesRequest(user, user, 0, 10, 1033);
                    EnumTitlesResponse resp = req.Execute();
                    if (0 != resp.XError)
                        throw new Exception("Unexpected HResult excepted=0, Received= " + resp.XError);

                    if (0 != resp.TitlesLen)
                        throw new Exception("Number of titles returned are different expected= 0, Received= " + resp.TitlesLen);

                    // Enum Avatar Assets
                    Global.RO.Info("Enum Single Asset");
                    XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(title, user, user, 1033, 0, AvatarAssetConst.MAX_AvatarAssets);
                    AvatarAssetEnumResponse enumresp = ereq.Execute();

                    Global.RO.Info("Validate first asset returned is first one, unachieved");
                    // Need to validate the enum response with the assets sent up
                    if (enumresp.AvatarAssets[0].AvatarAssetOrdinal != 1)
                        throw new Exception("First Enum Avatar Item was not most recently synced.  Expected: 1, Received: " + enumresp.AvatarAssets[0].AvatarAssetOrdinal);
                    if (enumresp.AvatarAssets[0].Flags != avatarassetflags.XAVATAR_DETAILS_SHOWUNACHIEVED)
                        throw new Exception("Flags incorrectly returned.  Expected: 0x00000008, Received: 0x" + enumresp.AvatarAssets[0].Flags.ToString("x"));
                }
            }
        }

        [TestFrequency("Daily"), TestCasePriority(1), Description("Try to call TitleClear for a user/title that has Gamerscore which will fail to clear")]
        public class N_ClearTitlewithAchievements : TestNode
        {
            public override void Run()
            {
                ulong user = 551;
                uint title = 50;
                uint achId = 2;

                TitleBase tbase = new TitleBase();
                Global.RO.Info("Sync Single Title");
                // First title is Title 50
                tbase.loadtitles(1, user);

                // Award an Achievement in Title 50
                Global.RO.Info("Sync Single Achievement");
                AchivementBase achbase = new AchivementBase();
                achbase.ClearAchivement(user);
                AchievementWD achievement = new AchievementWD(achId, 1);
                XRLSyncAchievements req = new XRLSyncAchievements(title, user, new AchievementWD[] { achievement });
                SyncAchievementsResponse resp = req.Execute();

                // Verify the response was ok
                if (resp.xResult != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + resp.xResult);

                // At this point we have a user with a title and an achievement and gamerscore for the title
                Global.RO.Info("Call Title Clear");
                TitleClearRequest creq = new TitleClearRequest(user, tbase.titlebase);
                if (creq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd)))
                {
                    Global.RO.Info("Enum Title and make sure we still get it back");
                    //enum and verify that title data is not deleted
                    EnumTitlesRequest ereq = new EnumTitlesRequest(user, user, 0, 10, 1033);
                    EnumTitlesResponse eresp = ereq.Execute();
                    if (eresp.XError != 0)
                        throw new Exception("Unexpected HResult expected= " + 0 + "Received= " + eresp.XError);

                    // Title Clear should fail and not remove the title
                    if (eresp.TitlesLen != 1)
                        throw new Exception("Number of titles returned are different expected= 1, Received= " + eresp.TitlesLen);

                    // Enum Achievements
                    XRLEnumAchievement eareq = new XRLEnumAchievement(title, user, user, 1033, 0, 50);
                    AchievementEnumResponse enumresp = eareq.Execute();
                    if (enumresp.xResult != 0)
                        throw new Exception("Unexpected HResult expected= " + 0 + "Received= " + enumresp.xResult);

                    Global.RO.Info("Enumerate first achievement, should still be the one we earned");
                    if (enumresp.Achievements[0].AchievementId != achId)
                        throw new Exception("First Achievement expected: " + achId + ", Received: " + enumresp.Achievements[0].AchievementId);
                    if (enumresp.Achievements[0].Flags != 0x00130008)
                        throw new Exception("First Achievement Flags expected: 0x00130008, Received: " + enumresp.Achievements[0].Flags.ToString("x"));
                }
            }
        }

        [TestFrequency("Daily"), TestCasePriority(2), Description("Try to call TitleClear for a user/title/avatarawarded items with avatar award that has been marked Not Achievable")]
        public class N_ClearTitleAvatarAssetswithNotAchievableFlag : TestNode
        {
            public override void Run()
            {
                ulong user = 552;
                uint title = 50;
                uint assetOrdinal = 2;

                TitleBase tbase = new TitleBase();
                Global.RO.Info("Sync Single Title");
                // First title is Title 50
                tbase.loadtitles(1, user);

                // Award an Avatar Asset in Title 50
                Global.RO.Info("Sync Single Asset");
                AvatarAssetBase avbase = new AvatarAssetBase();
                avbase.ClearAvatarAsset(user);
                AvatarAssetWD asset = new AvatarAssetWD(assetOrdinal, (byte)3, 1);
                XRLSyncAvatarAssets avreq = new XRLSyncAvatarAssets(title, user, new AvatarAssetWD[] { asset });
                SyncAvatarAssetsResponse avresp = avreq.Execute();

                // Verify the response was ok
                if (avresp.xResult != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + avresp.xResult);

                Global.RO.Info("Updating Sync'ed item in UODB to have the XAVATAR_NOT_ACHIEVABLE flag");
                // Now update the database to have the XAVATAR_NOT_ACHIEVABLE flag
                ProgressWS.MarkAvatarAssetNotAchievable(user, title, assetOrdinal);

                // At this point we have a user with a title and an asset with no gamerscore
                Global.RO.Info("Call Title Clear");
                TitleClearRequest creq = new TitleClearRequest(user, tbase.titlebase);
                if (creq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd)))
                {
                    Global.RO.Info("Enum Title and make sure we still get it back");
                    //enum and verify that title data is deleted
                    EnumTitlesRequest req = new EnumTitlesRequest(user, user, 0, 10, 1033);
                    EnumTitlesResponse resp = req.Execute();
                    if (0 != resp.XError)
                        throw new Exception("Unexpected HResult excepted=0, Received= " + resp.XError);

                    if (0 != resp.TitlesLen)
                        throw new Exception("Number of titles returned are different expected= 0, Received= " + resp.TitlesLen);

                    // Enum Avatar Assets
                    Global.RO.Info("Enum Single Asset");
                    XRLEnumAvatarAsset ereq = new XRLEnumAvatarAsset(title, user, user, 1033, 0, AvatarAssetConst.MAX_AvatarAssets);
                    AvatarAssetEnumResponse enumresp = ereq.Execute();

                    Global.RO.Info("Validate first asset returned is first one, unachieved");
                    // Need to validate the enum response with the assets sent up
                    if (enumresp.AvatarAssets[1].AvatarAssetOrdinal != assetOrdinal)
                        throw new Exception("First Enum Avatar Item was not most recently synced.  Expected: " + assetOrdinal + ", Received: " + enumresp.AvatarAssets[1].AvatarAssetOrdinal);
                    int notAchievableFlag = 0x00040008;
                    if (enumresp.AvatarAssets[1].Flags != notAchievableFlag)
                        throw new Exception("Flags incorrectly returned.  Expected: " + notAchievableFlag.ToString("x") + ", Received: 0x" + enumresp.AvatarAssets[1].Flags.ToString("x"));
                }
            }
        }

        [TestFrequency("Daily"), TestCasePriority(2), Description("Try to call TitleClear for a user/title that has no Gamerscore but has achievements marked not achievable")]
        public class N_ClearTitlewithAchievementsNotAchievable : TestNode
        {
            public override void Run()
            {
                ulong user = 553;
                uint title = 50;
                uint achId = 2;

                TitleBase tbase = new TitleBase();
                Global.RO.Info("Sync Single Title");
                // First title is Title 50
                tbase.loadtitles(1, user);

                // Award an Achievement in Title 50
                Global.RO.Info("Sync Single Achievement");
                AchivementBase achbase = new AchivementBase();
                achbase.ClearAchivement(user);
                AchievementWD achievement = new AchievementWD(achId, 1);
                XRLSyncAchievements req = new XRLSyncAchievements(title, user, new AchievementWD[] { achievement });
                SyncAchievementsResponse resp = req.Execute();

                // Verify the response was ok
                if (resp.xResult != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + resp.xResult);

                // Reset the users achievements with not achievable
                Global.RO.Info("Gamerscore reset this user");
                string sqlquery = "exec p_stats_reset_user_achievements " + user + ",'<a xuid=\"" + user + "\" />'";
                UodbWS.ExecuteSQLNonQuery(sqlquery, null);

                // At this point we have a user with a title and an achievement and gamerscore for the title
                Global.RO.Info("Call Title Clear");
                TitleClearRequest creq = new TitleClearRequest(user, tbase.titlebase);
                if (creq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd)))
                {
                    Global.RO.Info("Enum Title and make sure we still get it back");
                    //enum and verify that title data is not deleted
                    EnumTitlesRequest ereq = new EnumTitlesRequest(user, user, 0, 10, 1033);
                    EnumTitlesResponse eresp = ereq.Execute();
                    if (eresp.XError != 0)
                        throw new Exception("Unexpected HResult expected= " + 0 + "Received= " + eresp.XError);

                    // Title Clear should fail and not remove the title
                    if (eresp.TitlesLen != 1)
                        throw new Exception("Number of titles returned are different expected= 1, Received= " + eresp.TitlesLen);

                    // Enum Achievements
                    XRLEnumAchievement eareq = new XRLEnumAchievement(title, user, user, 1033, 0, 50);
                    AchievementEnumResponse enumresp = eareq.Execute();
                    if (enumresp.xResult != 0)
                        throw new Exception("Unexpected HResult expected= " + 0 + "Received= " + enumresp.xResult);

                    Global.RO.Info("Enumerate second achievement, should return as not earned, flags of 0x00000008");
                    if (enumresp.Achievements[1].AchievementId != achId)
                        throw new Exception("Second Achievement expected: " + achId + ", Received: " + enumresp.Achievements[1].AchievementId);
                    if (enumresp.Achievements[1].Flags != 0x00000008)
                        throw new Exception("Second Achievement Flags expected: 0x00000008, Received: " + enumresp.Achievements[1].Flags.ToString("x"));
                }
            }
        }

        [Description("Try to call TitleClear for a user/title that was gamerscore reset and had it undone")]
        public class N_ClearTitlewithAchievementsWasNotAchievable : TestNode
        {
            public override void Run()
            {
                ulong user = 554;
                uint title = 50;
                uint achId = 2;

                TitleBase tbase = new TitleBase();
                Global.RO.Info("Sync Single Title");
                // First title is Title 50
                tbase.loadtitles(1, user);

                // Award an Achievement in Title 50
                Global.RO.Info("Sync Single Achievement");
                AchivementBase achbase = new AchivementBase();
                achbase.ClearAchivement(user);
                AchievementWD achievement = new AchievementWD(achId, 1);
                XRLSyncAchievements req = new XRLSyncAchievements(title, user, new AchievementWD[] { achievement });
                SyncAchievementsResponse resp = req.Execute();

                // Verify the response was ok
                if (resp.xResult != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server " + resp.xResult);

                // Reset the users achievements with not achievable
                Global.RO.Info("Gamerscore reset this user");
                string sqlquery = "exec p_stats_reset_user_achievements " + user + ",'<a xuid=\"" + user + "\" />'";
                UodbWS.ExecuteSQLNonQuery(sqlquery, null);

                // UnReset the users achievements with not achievable
                Global.RO.Info("Un-Gamerscore reset this user");
                string sqlquery2 = "exec p_stats_unreset_user_achievements " + user + ",'<a xuid=\"" + user + "\" />'";
                UodbWS.ExecuteSQLNonQuery(sqlquery2, null);

                // Now we are going to have to recalc the gamerscore so this title can't be deleted.
                bool success = ProgressWS.RecalcUsersTitleGamerscore(title, user, 1, 1, DateTime.Now);
                if (!success)
                    throw new Exception("Unexpected RecalcUsersGamerscore failure");

                // At this point we have a user with a title and an achievement and gamerscore for the title
                Global.RO.Info("Call Title Clear");
                TitleClearRequest creq = new TitleClearRequest(user, tbase.titlebase);
                if (creq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd)))
                {
                    Global.RO.Info("Enum Title and make sure we still get it back");
                    //enum and verify that title data is not deleted
                    EnumTitlesRequest ereq = new EnumTitlesRequest(user, user, 0, 10, 1033);
                    EnumTitlesResponse eresp = ereq.Execute();
                    if (eresp.XError != 0)
                        throw new Exception("Unexpected HResult expected= " + 0 + "Received= " + eresp.XError);

                    // Title Clear should fail and not remove the title
                    if (eresp.TitlesLen != 1)
                        throw new Exception("Number of titles returned are different expected= 1, Received= " + eresp.TitlesLen);

                    // Enum Achievements
                    XRLEnumAchievement eareq = new XRLEnumAchievement(title, user, user, 1033, 0, 50);
                    AchievementEnumResponse enumresp = eareq.Execute();
                    if (enumresp.xResult != 0)
                        throw new Exception("Unexpected HResult expected= " + 0 + "Received= " + enumresp.xResult);

                    Global.RO.Info("Enumerate first achievement, should return as earned, flags of 0x001B0008");
                    if (enumresp.Achievements[0].AchievementId != achId)
                        throw new Exception("First Achievement expected: " + achId + ", Received: " + enumresp.Achievements[0].AchievementId);
                    if (enumresp.Achievements[0].Flags != 0x001B0008)
                        throw new Exception("First Achievement Flags expected: 0x001B0008, Received: " + enumresp.Achievements[0].Flags.ToString("x"));
                    if (enumresp.Achievements[0].Cred != 1)
                        throw new Exception("Achievement cred expected: 1, Received: " + enumresp.Achievements[0].Cred);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\PersonalPic.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace GamerSettings
{
	/// <summary>
	/// Summary description for PersonalPic.
	/// </summary>
	public class PersonalPic : TestNode
	{
		public PersonalPic()
		{
			AddChild(new SetReadPPic((uint)Titles.PosTitle1));
			AddChild(new SetReadPPicFList((uint)Titles.PosTitle1));
			AddChild(new SetReadPPicFList2((uint)Titles.PosTitle1));
			AddChild(new ReadPPicNotSet((uint)Titles.PosTitle1));
			AddChild(new ReadPPicSetTo0((uint)Titles.PosTitle1));
            AddChild(new SetReadAvatarPPic((uint)Titles.PosTitle1));
            AddChild(new SetReadAvatarPublicPic((uint)Titles.PosTitle1));
		}
	}
	
    //SetReadPPicFList
	public class SetReadPPicFList2: PersonalPicBase
	{
		public SetReadPPicFList2(uint  title)
		{
			Title=(uint)title;
		}
		protected override void init()
		{
			CreateUsers();
			ProfileWS.ResetUserSetttings(NonFriend);
			ProfileWS.ResetUserSetttings(OwnerInvUser);
			ProfileWS.ResetUserSetttings(UserInvOwner);
			ProfileWS.ResetUserSetttings(Friend);
		}
		protected void addsettigs(ulong user ,UserSetting[] settings, int pic)
		{
			settings[0]= new UserSetting(user,ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY,SConvert.UnicodeBytes((Title.ToString("X8")+"BBBBBBBBSSSSSSSS")),SettingSource.XSOURCE_DEFAULT);
			settings[1]= new UserSetting(user,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(("FFFE0700"+"0000"+pic.ToString("X4")+"0000"+pic.ToString("X4"))),SettingSource.XSOURCE_DEFAULT);
			SyncSettingsRequest req = new SyncSettingsRequest(Title,user,settings,DateTime.UtcNow);
			SyncSettingsResponse resp = req.Execute();
			verifyXerror(resp);
		}

		protected override void run()
		{
			// set setting for Owner
			RandomEx rand = new RandomEx();
			int pic = rand.Next(9999);
			UserSetting[] settings = new UserSetting[2];
			UserSetting[] respsettings = new UserSetting[8];

			addsettigs(Friend ,settings,pic);
			respsettings[0]= settings[0];
			respsettings[0].Value= getPPicSetting(settings[0],"0000"+pic.ToString("X4"),Friend.ToString("X16"));
			respsettings[0].ValueLen= (ushort)settings[0].Value.Length;
			respsettings[1]=settings[1];
			addsettigs(OwnerInvUser ,settings,pic);
			respsettings[2]= settings[0];
			respsettings[3]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(""),SettingSource.XSOURCE_PERMISSION_DENIED);
			addsettigs(UserInvOwner ,settings,pic);
			respsettings[4]= settings[0];
			respsettings[5]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(""),SettingSource.XSOURCE_PERMISSION_DENIED);
			addsettigs(NonFriend ,settings,pic);
			respsettings[6]=  settings[0];
			respsettings[7]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(""),SettingSource.XSOURCE_PERMISSION_DENIED);

			ulong[] friends = new ulong[4];
			friends[0]=Friend;
			friends[1]=OwnerInvUser;
			friends[2]=UserInvOwner;
			friends[3]=NonFriend;

			uint[] sIds =new uint[settings.Length];
			for (int i=0;i<settings.Length;i++)
				sIds[i]= settings[i].SettingId;

			ReadSettingsRequest rreq= new ReadSettingsRequest(Title,Owner,friends,sIds);
			ReadSettingsResponse rresp= rreq.Execute();

			if(rresp.XError != HResult.S_OK)
				throw new Exception( "UnExpected XError returned by server :"+rresp.XError);

			verifySettings(respsettings,rresp.Settings,(int)rresp.SettingsLen);
		}
	}

	public class SetReadPPicFList: PersonalPicBase
	{
		public SetReadPPicFList(uint  title)
		{
			Title=(uint)title;
		}
		protected override void init()
		{
			CreateUsers();
			ProfileWS.ResetUserSetttings(NonFriend);
			ProfileWS.ResetUserSetttings(OwnerInvUser);
			ProfileWS.ResetUserSetttings(UserInvOwner);
			ProfileWS.ResetUserSetttings(Friend);
		}
		protected void addsettigs(ulong user ,UserSetting[] settings, int pic)
		{
			
			settings[0]= new UserSetting(user,ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY,SConvert.UnicodeBytes((Title.ToString("X8")+"BBBBBBBBSSSSSSSS")),SettingSource.XSOURCE_DEFAULT);
			settings[1]= new UserSetting(user,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(("FFFE0700"+"0000"+pic.ToString("X4")+"0000"+pic.ToString("X4"))),SettingSource.XSOURCE_DEFAULT);
			SyncSettingsRequest req = new SyncSettingsRequest(Title,user,settings,DateTime.UtcNow);
			SyncSettingsResponse resp = req.Execute();
			verifyXerror(resp);
		}

		protected override void run()
		{
			// set setting for Owner
			RandomEx rand = new RandomEx();
			int pic = rand.Next(9999);
			UserSetting[] settings = new UserSetting[2];
			UserSetting[] respsettings = new UserSetting[8];

			addsettigs(NonFriend ,settings,pic);
			respsettings[0]= settings[0];
			respsettings[1]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(""),SettingSource.XSOURCE_PERMISSION_DENIED);
			addsettigs(OwnerInvUser ,settings,pic);
			respsettings[2]= settings[0];
			respsettings[3]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(""),SettingSource.XSOURCE_PERMISSION_DENIED);
			addsettigs(UserInvOwner ,settings,pic);
			respsettings[4]= settings[0];
			respsettings[5]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(""),SettingSource.XSOURCE_PERMISSION_DENIED);
			addsettigs(Friend ,settings,pic);
			respsettings[6]=  settings[0];
			respsettings[6].Value= getPPicSetting(settings[0],"0000"+pic.ToString("X4"),Friend.ToString("X16"));
			respsettings[6].ValueLen= (ushort)settings[0].Value.Length;
			respsettings[7]= settings[1];

			ulong[] friends = new ulong[4];
			friends[0]=NonFriend;
			friends[1]=OwnerInvUser;
			friends[2]=UserInvOwner;
			friends[3]=Friend;

			uint[] sIds =new uint[settings.Length];
			for (int i=0;i<settings.Length;i++)
				sIds[i]= settings[i].SettingId;

			ReadSettingsRequest rreq= new ReadSettingsRequest(Title,Owner,friends,sIds);
			ReadSettingsResponse rresp= rreq.Execute();

			if(rresp.XError != HResult.S_OK)
				throw new Exception( "UnExpected XError returned by server :"+rresp.XError);

			verifySettings(respsettings,rresp.Settings,(int)rresp.SettingsLen);
		}
	}

    [TestFrequency("BVT"), BVT, TestCasePriority(1), Description("Sync Personal Picture Key")]
	public class SetReadPPic: PersonalPicBase
	{
		public SetReadPPic(uint  title)
		{
			Title=(uint)title;
		}
		protected override void init()
		{
			CreateUsers();
			ProfileWS.ResetUserSetttings(Userid);
		}

		protected override void run()
		{
			// set setting for Owner
			UserSetting[] settings = new UserSetting[2];
			RandomEx rand = new RandomEx();
			int pic = rand.Next(9999);
			settings[0]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY,SConvert.UnicodeBytes((Title.ToString("X8")+"BBBBBBBBSSSSSSSS\0")),SettingSource.XSOURCE_DEFAULT);
			settings[1]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(("FFFE0700"+"0000"+pic.ToString("X4")+"0000"+pic.ToString("X4"))),SettingSource.XSOURCE_DEFAULT);
			SyncSettingsRequest req = new SyncSettingsRequest(Title,Owner,settings,DateTime.UtcNow);
			SyncSettingsResponse resp = req.Execute();
			verifyXerror(resp);

			UserSetting[] nonfriendsettings = new UserSetting[2];

			nonfriendsettings[0]= settings[0];
			nonfriendsettings[1]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(""),SettingSource.XSOURCE_PERMISSION_DENIED);;

			//read setting for non friend.
			verifyByReading(nonfriendsettings,Owner,NonFriend);

			//one way  nonfriend
			verifyByReading(nonfriendsettings,Owner,OwnerInvUser);
			verifyByReading(nonfriendsettings,Owner,UserInvOwner);

			// the response will change 
            //Need to strip off the \0 at the end of the first setting in this instance
            settings[0].Value= getPPicSetting(settings[0],"0000"+pic.ToString("X4"),Owner.ToString("X16"));
            settings[0].ValueLen= (ushort)settings[0].Value.Length;
			// friend
			verifyByReading(settings,Owner,Friend);

			// self
			verifyByReading(settings,Owner,Owner);
		}
	}

    [TestFrequency("Daily"), TestCasePriority(1), Description("Read personal picture not set")]
	public class ReadPPicNotSet: PersonalPicBase
	{
		public ReadPPicNotSet(uint  title)
		{
			Title=(uint)title;
		}
		protected override void init()
		{
			CreateUsers();
			ProfileWS.ResetUserSetttings(Userid);
		}

		protected override void run()
		{
			// set setting for Owner
			UserSetting[] settings = new UserSetting[1];
			RandomEx rand = new RandomEx();
			int pic = rand.Next(9999);
			settings[0]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY,SConvert.UnicodeBytes((Title.ToString("X8")+"BBBBBBBBSSSSSSSS")),SettingSource.XSOURCE_DEFAULT);
			
			SyncSettingsRequest req = new SyncSettingsRequest(Title,Owner,settings,DateTime.UtcNow);
			SyncSettingsResponse resp = req.Execute();
			verifyXerror(resp);

			UserSetting[] settingsresp= new UserSetting[2];

			settingsresp[0]= settings[0];
			settingsresp[1]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(""),SettingSource.XSOURCE_PERMISSION_DENIED);

			//read setting for non friend.
			verifyByReading(settingsresp,Owner,NonFriend);

			//one way  nonfriend
			verifyByReading(settingsresp,Owner,OwnerInvUser);
			verifyByReading(settingsresp,Owner,UserInvOwner);

			//friend
			settingsresp[1]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(""),SettingSource.XSOURCE_NO_VALUE);
			verifyByReading(settingsresp,Owner,Friend);

			// self
			verifyByReading(settingsresp,Owner,Owner);
		}
	}

	public class ReadPPicSetTo0: PersonalPicBase
	{
		public ReadPPicSetTo0(uint  title)
		{
			Title=(uint)title;
		}
		protected override void init()
		{
			CreateUsers();
			ProfileWS.ResetUserSetttings(Userid);
		}

		protected override void run()
		{
			// set setting for Owner
			UserSetting[] settings = new UserSetting[2];
			RandomEx rand = new RandomEx();
			int pic = rand.Next(9999);
			settings[0]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY,SConvert.UnicodeBytes((Title.ToString("X8")+"BBBBBBBBSSSSSSSS")),SettingSource.XSOURCE_DEFAULT);
			settings[1]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes("000000000000000000000000"),SettingSource.XSOURCE_DEFAULT);
			SyncSettingsRequest req = new SyncSettingsRequest(Title,Owner,settings,DateTime.UtcNow);
			SyncSettingsResponse resp = req.Execute();
			verifyXerror(resp);

			UserSetting[] nonfriendsettings = new UserSetting[2];

			nonfriendsettings[0]= settings[0];
			nonfriendsettings[1]= new UserSetting(Owner,ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,SConvert.UnicodeBytes(""),SettingSource.XSOURCE_PERMISSION_DENIED);

			//read setting for non friend.
			verifyByReading(nonfriendsettings,Owner,NonFriend);

			//one way  nonfriend
			verifyByReading(nonfriendsettings,Owner,OwnerInvUser);
			verifyByReading(nonfriendsettings,Owner,UserInvOwner);

			// the response will change 
			settings[0].Value= getPPicSetting(settings[0],"000000000000","000000000000");
			settings[0].ValueLen= (ushort)settings[0].Value.Length;
			// friend
			verifyByReading(settings,Owner,Friend);

			// self
			verifyByReading(settings,Owner,Owner);
		}
	}

    [TestFrequency("Daily"), TestCasePriority(1), Description("Sync Avatar personal gamerpicture")]
    public class SetReadAvatarPPic : PersonalPicBase
    {
        public SetReadAvatarPPic(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            CreateUsers();
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            UserSetting[] settings = new UserSetting[1];
            RandomEx rand = new RandomEx();
            int pic = rand.Next(9999);
            settings[0] = new UserSetting(Owner, ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE, SConvert.UnicodeBytes(("FFFE0854" + "0001" + pic.ToString("X4") + "0001" + pic.ToString("X4") + "\0")), SettingSource.XSOURCE_DEFAULT);
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Owner, settings, DateTime.UtcNow);
            SyncSettingsResponse resp = req.Execute();
            verifyXerror(resp);

            // self
            verifyByReading(settings, Owner, Owner);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(1), Description("Sync Avatar gamerpicture")]
    public class SetReadAvatarPublicPic : PersonalPicBase
    {
        public SetReadAvatarPublicPic(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            CreateUsers();
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // set setting for Owner
            UserSetting[] settings = new UserSetting[1];
            RandomEx rand = new RandomEx();
            int pic = rand.Next(9999);

            settings[0] = new UserSetting(Owner, ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY, SConvert.UnicodeBytes(("FFFE0854" + "0001" + pic.ToString("X4") + "0001" + pic.ToString("X4") + "\0")), SettingSource.XSOURCE_DEFAULT);
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Owner, settings, DateTime.UtcNow);
            SyncSettingsResponse resp = req.Execute();
            verifyXerror(resp);
            
            // the response will change 
            byte[] value = new byte[settings[0].Value.Length];

            // Avatars use gamertag instead of XUID like custom pics do
            // and we need to pad out all the characters if the gamertag is less than max gamertag
            string gamertag = UodbWS.GetGamertag(Owner);
            for (int i = gamertag.Length; i < 16; i++)
                gamertag += "\0";

            value = SConvert.UnicodeBytes("0001" + pic.ToString("X4") + gamertag + "\0"); 
            settings[0].Value = value;
            settings[0].ValueLen = (ushort)settings[0].Value.Length;

            // self
            verifyByReading(settings, Owner, Owner);
        }
    }

    public class PersonalPicBase : UserSettingBase
    {
        protected ulong Owner;
        protected ulong Friend;
        protected ulong NonFriend;
        protected ulong UserInvOwner;
        protected ulong OwnerInvUser;
        public void CreateUsers()
        {
            FriendsCommon fc = new FriendsCommon();

            PNUser _Owner = fc.CreateUser(true);
            PNUser _Friend = fc.CreateUser(true);
            PNUser _OwnerInvUser = fc.CreateUser(true);
            PNUser _UserInvOwner = fc.CreateUser(true);
            PNUser _nonFriend = fc.CreateUser(true);

            try
            {
                fc.RequestFriend(_Owner, _OwnerInvUser);
                fc.RequestFriend(_UserInvOwner, _Owner);
                fc.MakeFriend(_Friend, _Owner);
            }
            catch (System.Exception e)
            {
                Global.RO.Warn("Some tests may fail due to presence issue : " + e);
            }

            Owner = _Owner.UserId;
            Friend = _Friend.UserId;
            OwnerInvUser = _OwnerInvUser.UserId;
            UserInvOwner = _UserInvOwner.UserId;
            NonFriend = _nonFriend.UserId;
        }

        public byte[] getPPicSetting(UserSetting pic_Key, string personal_pic, string user)
        {
            personal_pic = personal_pic.ToUpper() + user.ToUpper();
            byte[] bpic = SConvert.UnicodeBytes(personal_pic);
            //byte[] tmp = new byte[pic_Key.Value.Length+bpic.Length+2];
            byte[] tmp;
            int length;

            if (pic_Key.Value[pic_Key.Value.Length - 2] == (byte)'\0')
            {
                tmp = new byte[pic_Key.Value.Length + bpic.Length];
                length = pic_Key.Value.Length - 2;
            }
            else
            {
                tmp = new byte[pic_Key.Value.Length + bpic.Length + 2];
                length = pic_Key.Value.Length;
            }

            for (int i = 0; i < length; i++)
            //for(int i=0;i<pic_Key.Value.Length;i++)
            {
                tmp[i] = pic_Key.Value[i];
            }

            int j = length;
            //int j=pic_Key.Value.Length;
            for (int i = 0; i < bpic.Length; i++, j++)
            {
                tmp[j] = (byte)bpic[i];

            }
            tmp[j] = 0;
            tmp[j + 1] = 0;

            return tmp;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\PosSyncGetTitleSettings.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Utilities;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.config;

namespace GamerSettings
{
    /// <summary>
    /// Summary description for PosSyncGetTitleSettings.
    /// </summary>
    public class PosSyncGetTitleSettings : TestNode
    {
        public const uint XPROFILE_TITLE_SPECIFIC3 = 0x63E83FFD;
        public const uint XPROFILE_TITLE_SPECIFIC2 = 0x63E83FFE;
        public const uint XPROFILE_TITLE_SPECIFIC1 = 0x63E83FFF;

        public PosSyncGetTitleSettings()
        {
            AddChild(new NotitleSetting(Titles.PosTitle1));
            AddChild(new SingleUserSetting(Titles.PosTitle1));
            AddChild(new SingleUserMultiSetting(Titles.PosTitle1));
            AddChild(new UpdateSingleUserSetting(Titles.PosTitle1));
            AddChild(new Delete1UserSetting(Titles.PosTitle1));
            AddChild(new SetGlobaltitleDeleteTitle(Titles.PosTitle1));
            AddChild(new SetGlobalDeleteTitle(Titles.PosTitle1));
            AddChild(new VersionZero(Titles.PosTitle1));
            AddChild(new LatestVersion(Titles.PosTitle1));
            AddChild(new MiddleVersion(Titles.PosTitle1));
            AddChild(new VersionZerotitleAndGlobal(Titles.PosTitle1));
            AddChild(new SetGlobalreadTitle(Titles.PosTitle1));

            // following requests are sent to internal port.
            AddChild(new IntSingleUserSetting(Titles.PosTitle1));
            AddChild(new VerifyPartition(Titles.PosTitle2));

        }

        [Ignore("Now that settings live outside of UODB, we can't always guarantee they will have the same physical partitions.")]
        [TestFrequency("Regression"), TestCasePriority(1), Description("Verify Partitions"), EnvRequirement("Xblobonly")]
        public class VerifyPartition : UserSettingBase
        {
            public VerifyPartition(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {

            }

            protected override void run()
            {
                ulong[] users = new ulong[100];

                FriendsCommon fc = new FriendsCommon();

                for (int i = 0; i < 100; i++)
                {
                    PNUser user = fc.CreateXenonUser(false);
                    users[i] = user.UserId;

                    Global.RO.Info("Synching setting for user: " + users[i]);

                    UserSetting[] settings = new UserSetting[1];
                    settings[0] = new UserSetting(users[i], TestUSetting.Test_int64, SConvert.Bytes((long)42174382), SettingSource.XSOURCE_TITLE);

                    SyncSettingsRequest req = new SyncSettingsRequest(Title, users[i], settings, DateTime.UtcNow);

                    SyncSettingsResponse resp = req.Execute();
                    verifyXerror(resp);
                }

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    uint[] usersPerUodb = new uint[ws.PhysicalPartitions];
                    for (int j = 0; j < 100; j++)
                    {
                        Global.RO.Info("verifing partition for user :" + users[j]);

                        string q1 = "Select count(*) from  [t_users] where bi_user_puid='" + users[j] + "'";
                        string q2 = "Select count(*) from  [t_user_settings] where bi_user_puid='" + users[j] + "'";
                        //ensure that the dev has placed the user on the right
                        //partition.

                        //for every UODB...
                        for (int k = 0; k < ws.PhysicalPartitions; k++)
                        {
                            //run q1 on this UODB
                            ws.PhysicalPartition = k;
                            ws.CommandSql = q1;
                            object val = ws.ExecuteScalar();
                            if (val != null && ((int)val >= 1))  //if we find the user...
                            {
                                //run q2 on the uodb
                                ws.CommandSql = q2;
                                object val2 = (ws.ExecuteScalar());
                                if (val2 != null && ((int)val2 >= 1))   //make sure a
                                //corresponding
                                //setting exists.
                                {
                                    //if we get answers on both, then
                                    //increment the value in the array
                                    //corresponding to the uodb.
                                    usersPerUodb[k] += 1;
                                    //	System.Console.WriteLine("user "+users[j]+"on correct partition ");
                                }
                                else
                                    throw new Exception("setting for user " + users[j] + "not foundon correct partition ");
                            }
                        }
                    }

                    //print results
                    for (int p = 0; p < usersPerUodb.Length; p++)
                    {
                        System.Console.WriteLine("Partition number " + p + " has " + usersPerUodb[p] + " records");
                    }
                }
            }
        }

        public class IntSingleUserSetting : UserSettingBase
        {
            public IntSingleUserSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User13");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382), SettingSource.XSOURCE_TITLE);

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.ExecuteToInt(xonline.common.service.XOn.XPLT_XBOX360); // Set the platform header
                verifyXerror(resp);

                verifyByReading(settings);
            }
        }

        public class LatestVersion : UserSettingBase
        {
            public LatestVersion(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User9");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                UserSetting[] settings0 = new UserSetting[1];
                settings0[0] = new UserSetting(Userid, TestUSetting.Test_stringL1, rand.GenerateRandomBlob(rand.Next(1000)), SettingSource.XSOURCE_TITLE);

                SyncSettingsRequest req0 = new SyncSettingsRequest(Title, Userid, settings0, DateTime.UtcNow);

                SyncSettingsResponse resp0 = req0.Execute();
                verifyXerror(resp0);

                int maxsettingsm1 = 3;
                UserSetting[] settings = new UserSetting[maxsettingsm1];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < maxsettingsm1; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)), SettingSource.XSOURCE_TITLE);
                }

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                Thread.Sleep(500);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                UserSetting[] settings2 = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, rand.GenerateRandomBlob(rand.Next(1000)), SettingSource.XSOURCE_TITLE);

                Thread.Sleep(500);
                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings, resp.Version);

                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);

                if (resp2.SettingsLen != 0)
                    throw new Exception("Expect setting count 0 but recived : " + resp2.SettingsLen);
            }
        }

        public class MiddleVersion : UserSettingBase
        {
            public MiddleVersion(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User10");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                UserSetting[] settings0 = new UserSetting[1];
                settings0[0] = new UserSetting(Userid, TestUSetting.Test_stringL1, rand.GenerateRandomBlob(rand.Next(1000)), SettingSource.XSOURCE_TITLE);

                SyncSettingsRequest req0 = new SyncSettingsRequest(Title, Userid, settings0, DateTime.UtcNow);

                SyncSettingsResponse resp0 = req0.Execute();
                verifyXerror(resp0);

                int maxsettingsm1 = 3;
                UserSetting[] settings = new UserSetting[maxsettingsm1];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < maxsettingsm1; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)), SettingSource.XSOURCE_TITLE);
                }

                Thread.Sleep(500);
                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, TestUSetting.Test_int64, rand.GenerateRandomBlob(rand.Next(1000)), SettingSource.XSOURCE_TITLE);

                Thread.Sleep(500);
                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, resp0.Version);

                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);

                UserSetting[] expectedSettings = new UserSetting[]
                {
                    settings[0],
                    settings[1],
                    settings[2]
                };

                verifySettings(expectedSettings, resp2.Settings, (int)resp2.SettingsLen);
            }
        }

        public class VersionZerotitleAndGlobal : UserSettingBase
        {
            public VersionZerotitleAndGlobal(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User11");
                ProfileWS.ResetUserSetttings(Userid);
            }
            protected override void run()
            {
                RandomEx rand = new RandomEx();

                int maxsettingsm1 = 3;
                UserSetting[] totalsettings = new UserSetting[maxsettingsm1 * 2];
                UserSetting[] gsettings = new UserSetting[maxsettingsm1];
                UserSetting[] settings = new UserSetting[maxsettingsm1];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < maxsettingsm1; i++)
                {
                    totalsettings[i] = gsettings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)), SettingSource.XSOURCE_DEFAULT);
                }
                startsettingid = startsettingid + maxsettingsm1;
                for (int i = 0; i < maxsettingsm1; i++)
                {
                    totalsettings[i + maxsettingsm1] = settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)), SettingSource.XSOURCE_TITLE);
                }

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                if (resp.SettingsLen != 0)
                    throw new Exception("Expect setting count 0 but recived : " + resp.SettingsLen);

                SyncSettingsRequest greq = new SyncSettingsRequest((uint)Titles.Global, Userid, gsettings, DateTime.UtcNow);
                Thread.Sleep(500);
                SyncSettingsResponse gresp = greq.Execute();
                verifyXerror(gresp);
                if (gresp.SettingsLen != 0)
                    throw new Exception("Expect setting count 0 but recived : " + gresp.SettingsLen);

                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, TestUSetting.Test_int64, rand.GenerateRandomBlob(rand.Next(1000)), SettingSource.XSOURCE_TITLE);

                DateTime clsver = DateTime.UtcNow;
                clsver = clsver.AddYears(-2);
                Thread.Sleep(500);

                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, clsver);

                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);

                UserSetting[] expectedSettings = new UserSetting[]
                {
                    settings[0],
                    settings[1],
                    settings[2]
                };

                verifySettings(expectedSettings, resp2.Settings, (int)resp2.SettingsLen);
            }
        }

        [TestFrequency("Daily"), TestCasePriority(2), Description("Sync with old version to get all the data")]
        public class VersionZero : UserSettingBase
        {
            public VersionZero(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User8");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                int maxsettingsm1 = 3;
                UserSetting[] settings = new UserSetting[maxsettingsm1];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < maxsettingsm1; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)), SettingSource.XSOURCE_TITLE);
                }

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                if (resp.SettingsLen != 0)
                    throw new Exception("Expect setting count 0 but recived : " + resp.SettingsLen);

                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, TestUSetting.Test_int64, rand.GenerateRandomBlob(rand.Next(1000)), SettingSource.XSOURCE_TITLE);

                DateTime clsver = DateTime.UtcNow;
                clsver = clsver.AddYears(-2);

                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, clsver);
                Thread.Sleep(500);
                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);

                UserSetting[] expectedSettings = new UserSetting[]
                {
                    settings[0],
                    settings[1],
                    settings[2]
                };

                verifySettings(expectedSettings, resp2.Settings, (int)resp2.SettingsLen);
            }
        }

        //SetGlobalreadTitle
        public class SetGlobalreadTitle : UserSettingBase
        {
            public SetGlobalreadTitle(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User15");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest reqGlobal = new SyncSettingsRequest((uint)Titles.Global, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse respGlobal = reqGlobal.Execute();
                verifyXerror(respGlobal);

                //title  settings 
                DateTime old = DateTime.UtcNow;
                old = old.AddDays(-1);

                UserSetting[] settings2 = new UserSetting[0];
                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, old);
                SyncSettingsResponse resp2 = req2.Execute();

                if (resp2.SettingsLen != 0)
                    throw new Exception("Unexpected settings length expected 0 received " + resp2.SettingsLen);
                verifyXerror(resp2);
            }
        }

        public class SetGlobalDeleteTitle : UserSettingBase
        {
            public SetGlobalDeleteTitle(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User7");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                //set the global (dash) setting, then query for it
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));
                //need to make Title = Dash so that we can check if we stored/received the dash setting correctly
                uint storeOldTitle = Title;
                Title = Titles.Global;
                SyncSettingsRequest reqGlobal = new SyncSettingsRequest(Titles.Global, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse respGlobal = reqGlobal.Execute();
                verifyXerror(respGlobal);
                verifyByReading(settings);
                //Change the Title back to original title
                Title = storeOldTitle;

                //check to make sure we still get the dash title back because there is no setting stored for the title
                verifyByReading(settings);

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                //Delete title  settings, make sure we still get back the global setting
                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, TestUSetting.Test_int64);
                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, DateTime.UtcNow);
                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);

                //when reading, we should get the Titles.Global setting back, because we deleted the title setting
                verifyByReading(settings);
            }
        }

        public class SetGlobaltitleDeleteTitle : UserSettingBase
        {
            public SetGlobaltitleDeleteTitle(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User6");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382), SettingSource.XSOURCE_TITLE);

                SyncSettingsRequest reqGlobal = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsRequest reqTitle = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse respGlobal = reqGlobal.Execute();
                SyncSettingsResponse respTitle = reqTitle.Execute();
                verifyXerror(respGlobal);
                verifyXerror(respTitle);

                verifyByReading(settings);

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                //Delete title  settings 
                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, TestUSetting.Test_int64);
                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, DateTime.UtcNow);
                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);
                verifyByReading(settings2);
            }
        }

        public class Delete1UserSetting : UserSettingBase
        {
            public Delete1UserSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User5");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                uint oldTitle = Title;
                //need shared Title variable to contain the dash title so we can verify the setting was changed in verifyByReading
                Title = Titles.Global;
                //make sure there is no global title setting for this user/id

                UserSetting[] settingsSetup = new UserSetting[1];
                settingsSetup[0] = new UserSetting(Userid, TestUSetting.Test_int64);
                SyncSettingsRequest reqSetup = new SyncSettingsRequest(Titles.Global, Userid, settingsSetup, DateTime.UtcNow);
                SyncSettingsResponse respSetup = reqSetup.Execute();
                verifyXerror(respSetup);
                verifyByReading(settingsSetup);

                Title = oldTitle;

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                //set the title setting to some value
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382), SettingSource.XSOURCE_TITLE);
                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                verifyByReading(settings);

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                //delete Title setting
                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, TestUSetting.Test_int64);
                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, DateTime.UtcNow);
                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);
                verifyByReading(settings2);
            }
        }

        [TestFrequency("BVT"), BVT, TestCasePriority(1), Description("Sync updating an existing setting")]
        public class UpdateSingleUserSetting : UserSettingBase
        {
            public UpdateSingleUserSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User4");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382), SettingSource.XSOURCE_TITLE);

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                verifyByReading(settings);

                //update settings to different value

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)1111111), SettingSource.XSOURCE_TITLE);
                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, DateTime.UtcNow);
                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);
                verifyByReading(settings2);
            }
        }

        [TestFrequency("Daily"), TestCasePriority(1), Description("Sync multiple settings")]
        public class SingleUserMultiSetting : UserSettingBase
        {
            public SingleUserMultiSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {

                Userid = GetUser("User3");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[5];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382), SettingSource.XSOURCE_TITLE);
                settings[1] = new UserSetting(Userid, TestUSetting.Test_binary16, SConvert.Bytes((short)666), SettingSource.XSOURCE_TITLE);
                settings[2] = new UserSetting(Userid, TestUSetting.Test_binary32, SConvert.Bytes((int)999999), SettingSource.XSOURCE_TITLE);
                settings[3] = new UserSetting(Userid, TestUSetting.Test_binaryM_1, SConvert.Bytes((short)10), SettingSource.XSOURCE_TITLE);
                settings[4] = new UserSetting(Userid, TestUSetting.Test_binary64, SConvert.Bytes((long)898989), SettingSource.XSOURCE_TITLE);

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                verifyByReading(settings);
            }
        }

        [TestFrequency("BVT"), BVT, TestCasePriority(1), Description("Sync new User Setting")]
        public class SingleUserSetting : UserSettingBase
        {
            public SingleUserSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User17");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382), SettingSource.XSOURCE_TITLE);

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                verifyByReading(settings);
            }
        }

        public class NotitleSetting : UserSettingBase
        {
            uint readtitle;

            public NotitleSetting(uint title)
            {
                Title = (uint)Titles.Global;
                readtitle = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                // set the global setting 
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                verifyByReading(settings);

                // Read title specific value .
                Title = readtitle;
                verifyByReading(settings);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\PosSyncGetSettings.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.config;


namespace GamerSettings
{
    /// <summary>
    /// Summary description for PosSyncGetSettings.
    /// </summary>
    public class PosSyncGetGlobalSettings : TestNode
    {
        public PosSyncGetGlobalSettings()
        {
            AddChild(new SingleUserSetting(Titles.Global));
            AddChild(new SingleUserMultiSetting(Titles.Global));
            AddChild(new UpdateSingleUserSetting(Titles.Global));
            AddChild(new SettingTypeInt64(Titles.Global));
            AddChild(new SettingTypeString(Titles.Global));
            AddChild(new SettingTypeBinary(Titles.PosTitle2));
            AddChild(new BinaryDiffLength(Titles.Global));
            AddChild(new StringDiffLength(Titles.Global));
            AddChild(new LengthZero(Titles.Global));
            AddChild(new SettingCountMax(Titles.Global));
            AddChild(new SettingCountMax_1(Titles.PosTitle2));
            AddChild(new Delete1UserSetting(Titles.Global));
            AddChild(new DeleteUserNoSetting(Titles.Global));

            AddChild(new VersionZero(Titles.Global));
            AddChild(new LatestVersion(Titles.Global));
            AddChild(new MiddleVersion(Titles.Global));
            AddChild(new MiddleVersion2(Titles.Global));
            AddChild(new SyncResponse128(Titles.PosTitle1));
            AddChild(new SyncStidxEqualtoSize(Titles.Global));
            AddChild(new SyncStidxEqualtoSizeP1(Titles.Global));

            // add 3 settings  and then add 2 more with one setting that already added by req1 . the resp should have 2 setting
            AddChild(new UpdateVersion(Titles.Global));

            // following requests are sent to internal port.
            AddChild(new IntSingleUserSetting(Titles.Global));

            AddChild(new DuplicateSettings(Titles.Global));
            AddChild(new SGAuthDiffTitle(Titles.Global));
            AddChild(new HttpAuthDiffTitle(Titles.NegTitle1));

            //new profile setting: service type test cases
            AddChild(new SyncServiceTypeAndMultipleSettingsDash(Titles.Global));
            AddChild(new SyncServiceTypeAndMultipleSettingsTitle(Titles.PosTitle1));
            AddChild(new ReadServiceTypeSetting3UsersDash(Titles.Global));
            AddChild(new ReadServiceTypeAndMultipleSettingsTitle(Titles.PosTitle1));

            //new profile setting:  Transient test cases (no uodb, only stored in cache)
            //therefore reading setting that is not cached should fail
            AddChild(new SyncTransientPartyInfoSetting(Titles.Global));
            AddChild(new ReadTransientPartyInfoSettingNotCached(Titles.Global));
            AddChild(new SyncTransientVideoMetadata(Titles.Global));

            //new profile setting: JumpInList.
            AddChild(new SyncJumpInListSetting(Titles.Global));
        }

        public class HttpAuthDiffTitle : UserSettingBase
        {
            public HttpAuthDiffTitle(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User12");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {

                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                req.Modifyflag = AuthModify.Change_Title;

                SyncSettingsResponse resp = req.ExecuteToInt();
                verifyXerror(resp);
                verifyByReading(settings);
            }
        }

        public class SGAuthDiffTitle : UserSettingBase
        {
            public SGAuthDiffTitle(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User11");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {

                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                req.Modifyflag = AuthModify.Change_Title;

                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                verifyByReading(settings);
            }
        }

        public class DuplicateSettings : UserSettingBase
        {
            public DuplicateSettings(uint title)
            {
                Title = (uint)title;
            }

            protected override void init()
            {
                Userid = GetUser("User10");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[5];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));
                settings[1] = new UserSetting(Userid, TestUSetting.Test_binary16, SConvert.Bytes((short)666));
                settings[2] = new UserSetting(Userid, TestUSetting.Test_binary32, SConvert.Bytes((int)999999));
                settings[3] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((short)10));
                settings[4] = new UserSetting(Userid, TestUSetting.Test_binary64, SConvert.Bytes((long)898989));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                settings[0] = settings[3];

                verifyByReading(settings);
            }
        }

        public class IntSingleUserSetting : UserSettingBase
        {
            public IntSingleUserSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User8");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382), SettingSource.XSOURCE_DEFAULT); // Dashboard titleid gives it a default source

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.ExecuteToInt();
                verifyXerror(resp);

                verifyByReading(settings);
            }
        }


        public class UpdateVersion : UserSettingBase
        {
            public UpdateVersion(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                int maxsettingsm1 = 3;
                UserSetting[] settings = new UserSetting[maxsettingsm1];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < maxsettingsm1; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)));
                }

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                if (resp.SettingsLen != 0)
                    throw new Exception("Expect setting count 0 but received: " + resp.SettingsLen);

                Thread.Sleep(100);

                DateTime ClsVer = resp.Version.AddMinutes(-1);
                UserSetting[] settingsUpdated = new UserSetting[]
                {
                    new UserSetting(Userid, TestUSetting.Test_int64, rand.GenerateRandomBlob(rand.Next(1000))),
                    settings[1],
                    settings[2]
                };

                Thread.Sleep(500);

                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settingsUpdated, ClsVer);
                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);

                // With the new PrivacyDb, a privacy setting will be created and returned because of the init code
                UserSetting[] expectedSettings = new UserSetting[settings.Length + 1];
                expectedSettings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_PERMISSIONS, new byte[] { 0, 0, 0, 0 });
                for (int i = 0; i < settings.Length; ++i)
                {
                    expectedSettings[i + 1] = settings[i];
                }

                // Expect to get back the original settings
                verifySettings(expectedSettings, resp2.Settings, (int)resp2.SettingsLen);
            }
        }

        [TestFrequency("Daily"), TestCasePriority(2), Description("Sync the Latest Version")]
        public class LatestVersion : UserSettingBase
        {
            public LatestVersion(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                UserSetting[] settings0 = new UserSetting[1];
                settings0[0] = new UserSetting(Userid, TestUSetting.Test_stringL1, rand.GenerateRandomBlob(rand.Next(1000)));

                SyncSettingsRequest req0 = new SyncSettingsRequest(Title, Userid, settings0, DateTime.UtcNow);
                SyncSettingsResponse resp0 = req0.Execute();
                verifyXerror(resp0);


                int maxsettingsm1 = 3;
                UserSetting[] settings = new UserSetting[maxsettingsm1];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < maxsettingsm1; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)));
                }

                DateTime middle = DateTime.UtcNow;
                middle = middle.AddDays(-5);

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, middle);
                Thread.Sleep(500);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                UserSetting[] settings2 = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, rand.GenerateRandomBlob(rand.Next(1000)));

                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings, resp.Version);
                Thread.Sleep(500);
                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);

                if (resp2.SettingsLen != 0)
                    throw new Exception("Expect setting count 0 but received: " + resp2.SettingsLen);
            }
        }

        public class MiddleVersion : UserSettingBase
        {
            public MiddleVersion(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                UserSetting[] settings0 = new UserSetting[1];
                settings0[0] = new UserSetting(Userid, TestUSetting.Test_stringL1, rand.GenerateRandomBlob(rand.Next(1000)));

                SyncSettingsRequest req0 = new SyncSettingsRequest(Title, Userid, settings0, DateTime.UtcNow);
                SyncSettingsResponse resp0 = req0.Execute();
                verifyXerror(resp0);

                Thread.Sleep(500);
                int maxsettingsm1 = 3;
                UserSetting[] settings = new UserSetting[maxsettingsm1];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < maxsettingsm1; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)));
                }

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                Thread.Sleep(500);
                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, TestUSetting.Test_int64, rand.GenerateRandomBlob(rand.Next(1000)));

                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, resp0.Version);
                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);

                verifySettings(settings, resp2.Settings, (int)resp2.SettingsLen);
            }
        }

        public class MiddleVersion2 : UserSettingBase
        {
            public MiddleVersion2(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                UserSetting[] settings0 = new UserSetting[1];
                settings0[0] = new UserSetting(Userid, TestUSetting.Test_stringL1, rand.GenerateRandomBlob(rand.Next(1000)));

                SyncSettingsRequest req0 = new SyncSettingsRequest(Title, Userid, settings0, DateTime.UtcNow);
                SyncSettingsResponse resp0 = req0.Execute();
                verifyXerror(resp0);

                Thread.Sleep(500);
                int maxsettingsm1 = 3;
                UserSetting[] settings = new UserSetting[maxsettingsm1];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < maxsettingsm1; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)));
                }

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                //sync a stale setting!
                Thread.Sleep(500);
                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, (uint)(startsettingid), rand.GenerateRandomBlob(rand.Next(1000)));

                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, resp0.Version);

                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);

                verifySettings(settings, resp2.Settings, (int)resp2.SettingsLen);

                //read the new 3 settings
                verifyByReading(settings, Userid, Userid);
            }
        }

        public class VersionZero : UserSettingBase
        {
            public VersionZero(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                int maxsettingsm1 = 3;
                UserSetting[] settings = new UserSetting[maxsettingsm1];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < maxsettingsm1; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)));
                }

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                if (resp.SettingsLen != 0)
                    throw new Exception("Expect setting count 0 but received: " + resp.SettingsLen);

                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, TestUSetting.Test_int64, rand.GenerateRandomBlob(rand.Next(1000)));

                DateTime cleintversion = DateTime.UtcNow;
                cleintversion = cleintversion.AddYears(-2);

                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, cleintversion);
                Thread.Sleep(500);
                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);

                // With the new PrivacyDb, a privacy setting will be created and returned because of the init code
                UserSetting[] expectedSettings = new UserSetting[settings.Length + 1];
                expectedSettings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_PERMISSIONS, new byte[] { 0, 0, 0, 0 });
                for (int i = 0; i < settings.Length; ++i)
                {
                    expectedSettings[i + 1] = settings[i];
                }

                verifySettings(expectedSettings, resp2.Settings, (int)resp2.SettingsLen);
            }
        }

        public class DeleteUserNoSetting : UserSettingBase
        {

            public DeleteUserNoSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                //try to delete settings  that does not exist value = null
                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, TestUSetting.Test_int64);
                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, DateTime.UtcNow);
                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);
                verifyByReading(settings2);
            }
        }

        public class Delete1UserSetting : UserSettingBase
        {

            public Delete1UserSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {

                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                verifyByReading(settings);

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                //delete settings  value = null
                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, TestUSetting.Test_int64);
                SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, settings2, DateTime.UtcNow);
                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);
                verifyByReading(settings2);
            }
        }

        public class SettingCountMax_1 : UserSettingBase
        {
            public SettingCountMax_1(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User6");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                int maxsettingsm1 = (int)GSLimits.XONLINE_MAX_SETTING_COUNT - 1;
                UserSetting[] settings = new UserSetting[maxsettingsm1];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < maxsettingsm1; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)));
                }

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                verifyByReading(settings);
            }

        }

        //SyncStidxEqualtoSize
        public class SyncStidxEqualtoSizeP1 : UserSettingBase
        {
            public SyncStidxEqualtoSizeP1(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                int settingsCount = (int)10;
                UserSetting[] settings = new UserSetting[settingsCount];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < settingsCount; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)));
                }

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                // try to sync with zero settings
                DateTime old = DateTime.UtcNow;
                old = old.AddYears(-2);
                SyncSettingsRequest req3 = new SyncSettingsRequest(Title, Userid, new UserSetting[0], old, 12);
                SyncSettingsResponse resp3 = req3.Execute();

                // 11 because of the original 10 + 1 for permissions from privacy (which is the first setting)
                if (resp3.TotalSettings != 11)
                    throw new Exception("Wrong total settings. Expected: 11 Received: " + resp3.TotalSettings);

                verifyXerror(resp3);

                verifySettings(new UserSetting[] { }, resp3.Settings, (int)resp3.SettingsLen);
            }
        }

        public class SyncStidxEqualtoSize : UserSettingBase
        {
            public SyncStidxEqualtoSize(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                int settingsCount = (int)10;
                UserSetting[] settings = new UserSetting[settingsCount];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < settingsCount; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)));
                }

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                // try to sync with zero settings
                DateTime old = DateTime.UtcNow;
                old = old.AddYears(-2);
                SyncSettingsRequest req3 = new SyncSettingsRequest(Title, Userid, new UserSetting[0], old, 11);
                SyncSettingsResponse resp3 = req3.Execute();

                // 11 because of the original 10 + 1 for permissions from privacy (which is the first setting)
                if (resp3.TotalSettings != 11)
                    throw new Exception("Wrong total settings. Expected: 11 Received: " + resp3.TotalSettings);

                verifyXerror(resp3);

                verifySettings(new UserSetting[] { settings[9] }, resp3.Settings, (int)resp3.SettingsLen);
            }
        }

        [Ignore("This is being ignored because of a known bug in the sproc p_user_settings_read_unsynced. The fix is being tracked by bug TFS#133590")]
        public class SyncResponse128 : UserSettingBase
        {
            public SyncResponse128(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User20");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();
                UserSetting[] Tsettings = new UserSetting[128];

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                int startsettingid = (int)TestUSetting.Test_bMaxNo;
                for (int p = 0; p < 4; p++)
                {
                    int maxsettings = (int)GSLimits.XONLINE_MAX_SETTING_COUNT;
                    UserSetting[] settings = new UserSetting[maxsettings];

                    for (int i = 0; i < maxsettings; i++)
                    {
                        Tsettings[(p * 32) + i] = settings[i] = new UserSetting(Userid, (uint)((startsettingid + ((p * 32))) + i), rand.GenerateRandomBlob(rand.Next(1000)), SettingSource.XSOURCE_TITLE);
                    }

                    SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                    SyncSettingsResponse resp = req.Execute();
                    verifyXerror(resp);
                    verifyByReading(settings);
                }

                ////// The new sproc for reading during the sync call, p_user_settings_read_unsynched returns settings in descending order by dt_Change_datetime.
                ////// This means the settings for each of our sync calls needs to reversed. The settings within each call remain the same, but the order of each batch
                ////// must be reversed.
                ////UserSetting[] expectedSettings = new UserSetting[128];
                ////Array.Copy(Tsettings, GSLimits.XONLINE_MAX_SETTING_COUNT * 3, expectedSettings, 0, GSLimits.XONLINE_MAX_SETTING_COUNT);
                ////Array.Copy(Tsettings, GSLimits.XONLINE_MAX_SETTING_COUNT * 2, expectedSettings, GSLimits.XONLINE_MAX_SETTING_COUNT * 1, GSLimits.XONLINE_MAX_SETTING_COUNT);
                ////Array.Copy(Tsettings, GSLimits.XONLINE_MAX_SETTING_COUNT * 1, expectedSettings, GSLimits.XONLINE_MAX_SETTING_COUNT * 2, GSLimits.XONLINE_MAX_SETTING_COUNT);
                ////Array.Copy(Tsettings, 0, expectedSettings, GSLimits.XONLINE_MAX_SETTING_COUNT * 3, GSLimits.XONLINE_MAX_SETTING_COUNT);

                // try to sync with zero settings and we should get 128 settings back.
                DateTime old = DateTime.UtcNow;
                old = old.AddYears(-2);
                SyncSettingsRequest req3 = new SyncSettingsRequest(Title, Userid, new UserSetting[0], old);
                SyncSettingsResponse resp3 = req3.Execute();

                if (resp3.TotalSettings != 128)
                    throw new Exception("Wrong total settings. Expected: 128 Received: " + resp3.TotalSettings);
                verifyXerror(resp3);
                verifySettings(Tsettings, resp3.Settings, (int)resp3.SettingsLen);
            }
        }

        public class SettingCountMax : UserSettingBase
        {
            public SettingCountMax(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                int maxsettings = (int)GSLimits.XONLINE_MAX_SETTING_COUNT;
                UserSetting[] settings = new UserSetting[maxsettings];

                int startsettingid = (int)TestUSetting.Test_bMaxNo;

                for (int i = 0; i < maxsettings; i++)
                {
                    settings[i] = new UserSetting(Userid, (uint)(startsettingid + i), rand.GenerateRandomBlob(rand.Next(1000)));
                }

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                verifyByReading(settings);
            }
        }

        public class LengthZero : UserSettingBase
        {
            public LengthZero(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User3");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_binaryM, rand.GenerateRandomBlob(0), SettingSource.XSOURCE_NO_VALUE);

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                verifyByReading(settings);
            }

        }

        public class StringDiffLength : UserSettingBase
        {
            public StringDiffLength(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User2");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                Global.RO.Info("length =1");

                AddsettingandVerify(1);
                int max = (int)GSLimits.XONLINE_MAX_SETTING_VALUE_BYTES;

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                Global.RO.Info("length =Max");
                AddsettingandVerify(max);

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                Global.RO.Info("length =Max-1");
                AddsettingandVerify(max - 1);

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                Global.RO.Info("length =Max/2");
                AddsettingandVerify(max / 2);

            }

            protected void AddsettingandVerify(int length)
            {
                RandomEx rand = new RandomEx();
                UserSetting[] settings = new UserSetting[1];
                string data = rand.GenerateRandomString(length);
                byte[] bytedata = SConvert.Bytes(data, length);
                settings[0] = new UserSetting(Userid, TestUSetting.Test_binaryM, bytedata);

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                verifyByReading(settings);
            }
        }

        public class BinaryDiffLength : UserSettingBase
        {
            public BinaryDiffLength(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                Global.RO.Info("length =1");
                AddsettingandVerify(1);
                int max = (int)GSLimits.XONLINE_MAX_SETTING_VALUE_BYTES;

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                Global.RO.Info("length =Max");
                AddsettingandVerify(max);

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                Global.RO.Info("length =Max-1");
                AddsettingandVerify(max - 1);

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                Global.RO.Info("length =Max/2");
                AddsettingandVerify(max / 2);

            }

            protected void AddsettingandVerify(int length)
            {
                RandomEx rand = new RandomEx();
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_binaryM, rand.GenerateRandomBlob(length));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                verifyByReading(settings);
            }

        }

        public class SettingTypeBinary : UserSettingBase
        {
            public SettingTypeBinary(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();

                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_binaryM_1, rand.GenerateRandomBlob(100));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                verifyByReading(settings);
            }
        }

        public class SettingTypeString : UserSettingBase
        {
            public SettingTypeString(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {

                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_stringLM, SConvert.Bytes("asdfghjklqwertyuiop", 18));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                verifyByReading(settings);
            }
        }

        public class SettingTypeInt64 : UserSettingBase
        {
            public SettingTypeInt64(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User19");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                verifyByReading(settings);
            }
        }

        [TestFrequency("BVT"), BVT, TestCasePriority(1), Description("Update single setting")]
        public class UpdateSingleUserSetting : UserSettingBase
        {

            public UpdateSingleUserSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {

                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);

                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);

                verifyByReading(settings);

                //update settings to different value
                UserSetting[] settings2 = new UserSetting[1];
                settings2[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)1111111));
                SyncSettingsRequest req2 = new SyncSettingsRequest((uint)Titles.PosTitle1, Userid, settings2, DateTime.UtcNow);
                SyncSettingsResponse resp2 = req2.Execute();
                verifyXerror(resp2);

                // With Local Caching, we need to wait for the local cache to timeout before validating. 
                Global.RO.Info("Sleeping for " + cacheTimeout + " seconds for local cache");
                Thread.Sleep(cacheTimeout * 1000);

                verifyByReading(settings2);
            }
        }

        [TestFrequency("Daily"), TestCasePriority(1), Description("Update multiple settings single user")]
        public class SingleUserMultiSetting : UserSettingBase
        {
            public SingleUserMultiSetting(uint title)
            {
                Title = (uint)title;
            }

            protected override void init()
            {

                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                // For the PARTY_INTO setting
                RandomEx rand = new RandomEx();

                UserSetting[] settings = new UserSetting[6];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));
                settings[1] = new UserSetting(Userid, TestUSetting.Test_binary16, SConvert.Bytes((short)666));
                settings[2] = new UserSetting(Userid, TestUSetting.Test_binary32, SConvert.Bytes((int)999999));
                settings[3] = new UserSetting(Userid, TestUSetting.Test_binaryM_1, SConvert.Bytes((short)10));
                settings[4] = new UserSetting(Userid, TestUSetting.Test_binary64, SConvert.Bytes((long)898989));
                // Added PARTY_INFO setting to this case to make sure it works with other setting calls - kkline
                settings[5] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO, rand.GenerateRandomBlob(128));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                verifyByReading(settings);
            }
        }

        [TestFrequency("Daily"), TestCasePriority(1), Description("Sync single setting")]
        public class SingleUserSetting : UserSettingBase
        {
            public SingleUserSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                // This is "ExecuteToInt" because the JumpInList is special, and never synced by
                // consoles.  It is only written to directly from the service.
                SyncSettingsResponse resp = req.ExecuteToInt();
                verifyXerror(resp);

                verifyByReading(settings);
            }
        }


        public class SyncServiceTypeAndMultipleSettingsDash : UserSettingBase
        {
            public SyncServiceTypeAndMultipleSettingsDash(uint title)
            {
                Title = (uint)title;
            }

            protected override void run()
            {
                //create xbox  user
                FriendsCommon fc = new FriendsCommon();
                PNUser xboxUser = fc.CreateUser(true);
                //assign this user to global userid for validation later
                Userid = xboxUser.UserId;

                //user will sync and read a test setting, servicetype setting, test setting

                //create settings to sync, try to sync a zune service bit (shouldn't work)
                UserSetting[] settingsToSync = new UserSetting[3];
                settingsToSync[0] = new UserSetting(xboxUser.UserId, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));
                settingsToSync[1] = new UserSetting(xboxUser.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS, SConvert.Bytes(xonline.common.protocol.ProfileDefs.XPROFILE_SERVICE_TYPE_FLAG_ZUNE));
                settingsToSync[2] = new UserSetting(xboxUser.UserId, TestUSetting.Test_stringLM, SConvert.Bytes("asdfghjklqwertyuiop", 18));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, xboxUser.UserId, settingsToSync, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                //create expected settings
                UserSetting[] expectedSettings = new UserSetting[3];
                expectedSettings[0] = settingsToSync[0];
                expectedSettings[1] = new UserSetting(xboxUser.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS, SConvert.Bytes((int)xonline.common.protocol.ProfileDefs.XPROFILE_SERVICE_TYPE_FLAG_XBOX));
                expectedSettings[2] = settingsToSync[2];

                verifyByReading(expectedSettings);
            }

        }

        public class SyncServiceTypeAndMultipleSettingsTitle : UserSettingBase
        {
            public SyncServiceTypeAndMultipleSettingsTitle(uint title)
            {
                Title = (uint)title;
            }

            protected override void run()
            {

                //create xbox  user
                FriendsCommon fc = new FriendsCommon();
                PNUser xboxUser = fc.CreateUser(true);
                //assign this user to global userid for validation later
                Userid = xboxUser.UserId;

                //user will sync and read a test setting, servicetype setting, test setting

                //create settings to sync, try to sync a zune service bit (shouldn't work)
                UserSetting[] settingsToSync = new UserSetting[3];
                settingsToSync[0] = new UserSetting(xboxUser.UserId, TestUSetting.Test_int64, SConvert.Bytes((long)42174382));
                settingsToSync[1] = new UserSetting(xboxUser.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS, SConvert.Bytes(xonline.common.protocol.ProfileDefs.XPROFILE_SERVICE_TYPE_FLAG_ZUNE));
                settingsToSync[2] = new UserSetting(xboxUser.UserId, TestUSetting.Test_stringLM, SConvert.Bytes("asdfghjklqwertyuiop", 18));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, xboxUser.UserId, settingsToSync, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();
                verifyXerror(resp);
                //create expected settings
                UserSetting[] expectedSettings = new UserSetting[3];
                expectedSettings[0] = settingsToSync[0];
                expectedSettings[1] = new UserSetting(xboxUser.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS, SConvert.Bytes((int)xonline.common.protocol.ProfileDefs.XPROFILE_SERVICE_TYPE_FLAG_XBOX));
                expectedSettings[2] = settingsToSync[2];

                verifyByReading(expectedSettings);
            }
        }

        public class ReadServiceTypeSetting3UsersDash : UserSettingBase
        {
            public ReadServiceTypeSetting3UsersDash(uint title)
            {
                Title = (uint)title;
            }

            protected override void run()
            {
                //create xbox live only user
                FriendsCommon fc = new FriendsCommon();
                PNUser xboxLiveOnlyUser = fc.CreateUser(true); //xbox bit automatically set

                //create zune only user
                PNUser zuneOnlyUser = fc.CreateUser(true);
                //remove xbox bit (automatically set to xbox when user was created)
                DBHelper.ClearServiceTypeSettingsByUser(zuneOnlyUser.UserId);
                //add zune but
                DBHelper.AddServiceType(zuneOnlyUser.UserId, 2, DateTime.Now, DateTime.Now, DateTime.Now, DateTime.Now, 1, DateTime.Now, 0, DateTime.Now);

                //create xbox and zune user
                PNUser xboxAndZuneUser = fc.CreateUser(true);
                //add zune but
                DBHelper.AddServiceType(xboxAndZuneUser.UserId, 2, DateTime.Now, DateTime.Now, DateTime.Now, DateTime.Now, 1, DateTime.Now, 0, DateTime.Now);

                //read all 3 of their settings

                //three user id's
                ulong[] userIDs = new ulong[3];
                userIDs[0] = xboxLiveOnlyUser.UserId;
                userIDs[1] = zuneOnlyUser.UserId;
                userIDs[2] = xboxAndZuneUser.UserId;
                //one setting ID - Service_type
                uint[] sIds = new uint[1] { xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS };

                ReadSettingsRequest rreq = new ReadSettingsRequest(Title, xboxLiveOnlyUser.UserId, userIDs, sIds);
                ReadSettingsResponse rresp = rreq.Execute();

                if (rresp.XError != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server: " + rresp.XError);

                //create expected response from read response
                UserSetting[] expectedSettings = new UserSetting[3];
                expectedSettings[0] = new UserSetting(xboxLiveOnlyUser.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS, SConvert.Bytes((int)xonline.common.protocol.ProfileDefs.XPROFILE_SERVICE_TYPE_FLAG_XBOX));
                expectedSettings[1] = new UserSetting(zuneOnlyUser.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS, SConvert.Bytes((int)xonline.common.protocol.ProfileDefs.XPROFILE_SERVICE_TYPE_FLAG_ZUNE));
                expectedSettings[2] = new UserSetting(xboxAndZuneUser.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS, SConvert.Bytes((int)(xonline.common.protocol.ProfileDefs.XPROFILE_SERVICE_TYPE_FLAG_XBOX | xonline.common.protocol.ProfileDefs.XPROFILE_SERVICE_TYPE_FLAG_ZUNE)));

                verifySettings(expectedSettings, rresp.Settings, (int)rresp.SettingsLen);

            }

        }

        public class ReadServiceTypeAndMultipleSettingsTitle : UserSettingBase
        {
            public ReadServiceTypeAndMultipleSettingsTitle(uint title)
            {
                Title = (uint)title;
            }

            protected override void run()
            {

                //create xbox live only user
                FriendsCommon fc = new FriendsCommon();
                PNUser xboxLiveOnlyUser = fc.CreateUser(true); //xbox bit automatically set

                //create zune only user
                PNUser zuneOnlyUser = fc.CreateUser(true);
                //remove xbox bit (automatically set to xbox when user was created)
                DBHelper.ClearServiceTypeSettingsByUser(zuneOnlyUser.UserId);
                //add zune but
                DBHelper.AddServiceType(zuneOnlyUser.UserId, 2, DateTime.Now, DateTime.Now, DateTime.Now, DateTime.Now, 1, DateTime.Now, 0, DateTime.Now);

                //create xbox and zune user
                PNUser xboxAndZuneUser = fc.CreateUser(true);
                //add zune but
                DBHelper.AddServiceType(xboxAndZuneUser.UserId, 2, DateTime.Now, DateTime.Now, DateTime.Now, DateTime.Now, 1, DateTime.Now, 0, DateTime.Now);

                //read all 3 of their settings

                //three user id's
                ulong[] userIDs = new ulong[3];
                userIDs[0] = xboxLiveOnlyUser.UserId;
                userIDs[1] = zuneOnlyUser.UserId;
                userIDs[2] = xboxAndZuneUser.UserId;
                //one setting ID - Service_type
                uint[] sIds = new uint[1] { xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS };

                ReadSettingsRequest rreq = new ReadSettingsRequest(Title, xboxLiveOnlyUser.UserId, userIDs, sIds);
                ReadSettingsResponse rresp = rreq.Execute();

                if (rresp.XError != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server: " + rresp.XError);

                //create expected response from read response
                UserSetting[] expectedSettings = new UserSetting[3];
                expectedSettings[0] = new UserSetting(xboxLiveOnlyUser.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS, SConvert.Bytes((int)xonline.common.protocol.ProfileDefs.XPROFILE_SERVICE_TYPE_FLAG_XBOX));
                expectedSettings[1] = new UserSetting(zuneOnlyUser.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS, SConvert.Bytes((int)xonline.common.protocol.ProfileDefs.XPROFILE_SERVICE_TYPE_FLAG_ZUNE));
                expectedSettings[2] = new UserSetting(xboxAndZuneUser.UserId, xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS, SConvert.Bytes((int)(xonline.common.protocol.ProfileDefs.XPROFILE_SERVICE_TYPE_FLAG_XBOX | xonline.common.protocol.ProfileDefs.XPROFILE_SERVICE_TYPE_FLAG_ZUNE)));

                verifySettings(expectedSettings, rresp.Settings, (int)rresp.SettingsLen);

            }

        }

        // Transient Profile Setting Test Case
        // Sync PARTY_INFO setting for a user, and then read it
        [TestFrequency("Daily"), TestCasePriority(1), Description("Sync Transient Party Info Setting")]
        public class SyncTransientPartyInfoSetting : UserSettingBase
        {
            public SyncTransientPartyInfoSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User1");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();
                UserSetting[] settings = new UserSetting[1];
                int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO >> 16) & 0x3FF);
                settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO, rand.GenerateRandomBlob(settingIDMaxSize));

                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                verifyXerror(resp);
                verifyByReading(settings);
            }

        }

        // Try to Read a XPROFILE_GAMERCARD_PARTY_INFO setting for a user that isn't in the cache
        // which should fail because the lookup won't go to UODB as it isn't stored there.
        [TestFrequency("Daily"), TestCasePriority(1), Description("Read Transient Party Info Setting")]
        public class ReadTransientPartyInfoSettingNotCached : UserSettingBase
        {
            public ReadTransientPartyInfoSettingNotCached(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User2");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();
                UserSetting[] settings = new UserSetting[1];
                int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO >> 16) & 0x3FF);
                settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO, rand.GenerateRandomBlob(settingIDMaxSize));
                settings[0].Source = (uint)SettingSource.XSOURCE_DEFAULT;

                // Need to read the value but the value won't have been sync'ed (and does not exist in the DB)
                //verifyByReadingNoValue(settings);

                // KKLINE - Rather than try to create a new function for just this one case
                // I'm just extracting the code from verifyByReadingNoValue which expects HR=1 for the xbanc return

                ulong[] friends = new ulong[1];
                friends[0] = Userid;

                uint[] sIds = new uint[settings.Length];

                for (int i = 0; i < settings.Length; i++)
                {
                    sIds[i] = settings[i].SettingId;
                }

                ReadSettingsRequest req = new ReadSettingsRequest(Title, Userid, friends, sIds);
                ReadSettingsResponse resp = req.Execute();

                if (resp.XError != HResult.S_OK)
                    throw new Exception("Unexpected XError returned by server: " + resp.XError);

                if (resp.SettingsLen != settings.Length)
                    throw new Exception("Setting count is different. Expected: " + settings.Length + " Received: " + resp.SettingsLen);

                for (int i = 0; i < settings.Length; i++)
                {

                    if (resp.Settings[i].SettingId != settings[i].SettingId)
                        throw new Exception("Setting ID is different. Expected: " + settings[i].SettingId + " Received: " + resp.Settings[i].SettingId);

                    if (resp.Settings[i].Source != (uint)SettingSource.XSOURCE_NO_VALUE)
                        throw new Exception("Setting Source is different. Expected: " + SettingSource.XSOURCE_NO_VALUE + " Received: " + resp.Settings[i].Source);

                    if (resp.Settings[i].ValueLen != 0)
                        throw new Exception("Setting ValueLen is different. Expected: 0 Received: " + resp.Settings[i].ValueLen);

                    xonline.common.service.Acceleration xb = new xonline.common.service.Acceleration(Interface.ProfileCache);
                    byte[] expectedValue = settings[i].Value;

                    uint hr;
                    byte[] key = null;
                    byte[] value = null;

                    //build the cache key
                    key = xonline.common.protocol.ProfileDefs.BuildCacheKey(settings[i].SettingId, Title, settings[i].userId);
                    value = null;

                    //query cache for the setting
                    hr = xb.Query(key, out value);
                    if (hr != 1)
                    {
                        throw new Exception("Querying Cache for setting " + settings[i].SettingId + " titleID " + Title + " and userID " + settings[i].userId + " returned hr: " + hr + ", expected hr: 0");
                    }
                }

            }
        }

        // Transient Profile Setting Test Case
        // Sync XPROFILE_VIDEO_METADATA setting for a user, and then read it
        // The value is not stored in the DB, but Cache only
        [TestFrequency("Daily"), TestCasePriority(2), Description("Sync Video Metadata Setting")]
        public class SyncTransientVideoMetadata : UserSettingBase
        {
            public SyncTransientVideoMetadata(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User3");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                RandomEx rand = new RandomEx();
                UserSetting[] settings = new UserSetting[1];
                int settingIDMaxSize = (int)((xonline.common.protocol.ProfileDefs.XPROFILE_VIDEO_METADATA >> 16) & 0x3FF);
                settings[0] = new UserSetting(Userid, xonline.common.protocol.ProfileDefs.XPROFILE_VIDEO_METADATA, rand.GenerateRandomBlob(settingIDMaxSize));

                Global.RO.Info("Sync Request");
                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.Execute();

                Global.RO.Info("Verifying sync response");
                verifyXerror(resp);
                Global.RO.Info("Validating sync by enumerating, not stored in DB only in Cache");
                verifyByReading(settings);
            }
        }

        // Transient Profile Setting Test Case
        // Sync XPROFILE_VIDEO_METADATA setting for a user, and then read it
        // The value is not stored in the DB, but Cache only
        [TestFrequency("Daily"), TestCasePriority(2), Description("Sync Jump In List")]
        public class SyncJumpInListSetting : UserSettingBase
        {
            public SyncJumpInListSetting(uint title)
            {
                Title = (uint)title;
            }
            protected override void init()
            {
                Userid = GetUser("User3");
                ProfileWS.ResetUserSetttings(Userid);
            }

            protected override void run()
            {
                const int SIZE_OF_JUMPIN_LIST = 1000;

                RandomEx rand = new RandomEx();
                UserSetting[] settings = new UserSetting[1];
                settings[0] = new UserSetting(Userid, xonline.common.protocol.ProfileDefs.XPROFILE_JUMP_IN_LIST,
                                              rand.GenerateRandomBlob(SIZE_OF_JUMPIN_LIST));
                SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
                SyncSettingsResponse resp = req.ExecuteToInt();
                verifyXerror(resp);

                verifyByReading(settings);
            }
        }

    }

    public class UserSettingBase : TestNode
    {
        public static Hashtable gusers = new Hashtable();
        public uint Title = 0;
        public ulong Userid = 0;
        public static int cacheTimeout = 0;

        virtual protected void init() { }
        virtual protected void run() { }

        public ulong GetUser(string name)
        {
            return (ulong)gusers[name];
        }


        public override void Run()
        {
            init();
            run();
        }

        public void verifySettings(UserSetting[] settings, UserSetting[] respsettings, int respSettingLen)
        {
            if (respSettingLen != settings.Length)
                throw new Exception("Setting count is different. Expected: " + settings.Length + " Received: " + respSettingLen);

            for (int i = 0; i < settings.Length; i++)
            {

                if (respsettings[i].SettingId != settings[i].SettingId)
                    throw new Exception("Setting ID is different. Expected: " + settings[i].SettingId + " Received: " + respsettings[i].SettingId);

                if (respsettings[i].Source != settings[i].Source)
                    throw new Exception("Setting Source is different. Expected: " + settings[i].Source + " Received: " + respsettings[i].Source);

                if (respsettings[i].Source == (uint)SettingSource.XSOURCE_NO_VALUE)
                    continue;

                if (respsettings[i].ValueLen != settings[i].Value.Length)
                    throw new Exception("Setting value len is different. Expected: " + settings[i].ValueLen + " Received: " + respsettings[i].ValueLen);


                for (int vl = 0; vl < settings[i].Value.Length; vl++)
                {
                    if (respsettings[i].Value[vl] != settings[i].Value[vl])
                        throw new Exception("Setting value  is different at idx " + vl + " Expected: " + settings[i].Value[vl] + " Received: " + respsettings[i].Value[vl]);
                }
            }
        }

        public void verifyXerror(SyncSettingsResponse resp)
        {
            if (resp.XError != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server: " + resp.XError);

        }

        private bool isValidSettingID(UserSetting setting)
        {
            return SettingIds.isValidSettingID(setting.SettingId);
        }

        //1 IMPORTANT global variable Title needs to contain the title this setting was synced with! 
        private void verifyCacheEntryAfterSyncSetting(UserSetting setting) //param is the setting that was synced 
        {

            xonline.common.service.Acceleration xb = new xonline.common.service.Acceleration(Interface.ProfileCache);
            byte[] expectedValue = setting.Value;
            uint expectedRetVal = HResult.S_OK;
            uint titleID = (setting.Source == (uint)SettingSource.XSOURCE_DEFAULT) ? XOn.XENON_DASH_TITLE_ID : Title;

            //should be in Cache because of the Syncsettings call, unless we're requesting the public gamerpicture of a friend that has the non special key cached
            //cache won't return the special value that we're looking for, so we'll just skip it all together
            if (setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY ||
                setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE ||
                setting.SettingId == ProfileDefs.XPROFILE_GAMER_TIER ||
                setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS)
            {
                return;
            }

            //determine the correct title to query for
            //first, is this setting title writeable? if it is not, and we tried to sync something to it, then it isn't cached, so we should expect NOTHING from cache
            SettingInfo sinfo = null;
            if (isValidSettingID(setting))
            {
                sinfo = SettingIds.Item(setting.SettingId);
                if (sinfo == null)
                {
                    throw new Exception("Failed to load setting " + setting.SettingId + " to determine if it is title writeable during cache verification.");
                }
            }

            //not going to be in cache cases: expect S_FALSE

            if (!isValidSettingID(setting) ||
                (!sinfo.IsTitleWritable() && titleID != XOn.XENON_DASH_TITLE_ID) ||
                setting.Source == (uint)SettingSource.XSOURCE_PERMISSION_DENIED)
            {
                expectedRetVal = HResult.S_FALSE;
                expectedValue = null;
            }
            //the NoValueCases
            else if (setting.Source == (uint)SettingSource.XSOURCE_NO_VALUE) //the setting was zeroed out
            {
                expectedValue = xonline.common.protocol.ProfileDefs.CacheNoValue;
                expectedRetVal = HResult.S_OK;
            }

            //syncing either puts the value in cache, or it is not there.
            //build the cache key
            byte[] key = xonline.common.protocol.ProfileDefs.BuildCacheKey(setting.SettingId, titleID, setting.userId);
            byte[] value = null;

            // Temp debugging for bucket
            uint sum = 0;
            for (int i = 0; i < key.Length; i++)
            {
                sum += (uint)key[i];
            }

            uint bucketid = sum % 420;

            //query cache for the setting
            uint hr = xb.Query(key, out value);
            if (hr != expectedRetVal)
            {
                throw new Exception("Querying Cache for setting " + setting.SettingId + " titleID " + titleID + " and userID " + setting.userId + " returned " + hr + ", expected " + expectedRetVal);
            }
            if (expectedRetVal == HResult.S_OK) //something was returned from the query. let's see if it was expected.
            {
                //compare the returned value with the expected value
                if (!xonline.common.service.Acceleration.CompareByteArrays(expectedValue, value))
                {
                    throw new Exception("Querying Cache for setting " + setting.SettingId + " titleID " + titleID + " and userID " + setting.userId + " did not return the expected value.");
                }
            }
        }

        //1 IMPORTANT global variable Title needs to contain the title this setting was read with! 
        private void verifyCacheEntryAfterReadSetting(UserSetting setting) //param is the result of the readsettings
        {
            xonline.common.service.Acceleration xb = new xonline.common.service.Acceleration(Interface.ProfileCache);
            byte[] expectedValue = setting.Value;
            uint expectedRetVal = HResult.S_OK;
            uint titleID = Title;

            uint hr;
            byte[] key = null;
            byte[] value = null;

            //should be in Cache because of the Syncsettings call, unless we're requesting the public gamerpicture of a friend that has the non special key cached
            //cache won't return the special value that we're looking for, so we'll just skip it all together
            if (setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY ||
                setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE ||
                setting.SettingId == ProfileDefs.XPROFILE_GAMER_TIER ||
                setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS)
            {
                return;
            }

            if (Title != XOn.XENON_DASH_TITLE_ID)
            {
                //see what cache stored into the TITLE OVERRIDE
                SettingInfo sinfo = null;
                if (isValidSettingID(setting))
                {
                    sinfo = SettingIds.Item(setting.SettingId);
                    if (sinfo == null)
                    {
                        throw new Exception("Failed to load setting " + setting.SettingId + " to determine if it is title writeable during cache verification.");
                    }
                }

                //not going to be in cache cases: expect S_FALSE
                if (!isValidSettingID(setting) ||
                    !sinfo.IsTitleWritable() ||
                    setting.Source == (uint)SettingSource.XSOURCE_PERMISSION_DENIED)
                {
                    expectedRetVal = HResult.S_FALSE;
                    expectedValue = null;
                }
                //the NoValueCases
                else if (setting.Source == (uint)SettingSource.XSOURCE_DEFAULT || //the setting returned came from the dash
                    setting.Source == (uint)SettingSource.XSOURCE_NO_VALUE) //the setting does not exist
                {
                    expectedValue = xonline.common.protocol.ProfileDefs.CacheNoValue;
                    expectedRetVal = HResult.S_OK;
                }

                //build the cache key
                key = xonline.common.protocol.ProfileDefs.BuildCacheKey(setting.SettingId, titleID, setting.userId);
                value = null;

                //query cache for the setting
                hr = xb.Query(key, out value);
                if (hr != expectedRetVal)
                {
                    throw new Exception("Querying Cache for setting " + setting.SettingId + " titleID " + titleID + " and userID " + setting.userId + " returned " + hr + ", expected " + expectedRetVal);
                }
                if (expectedRetVal == HResult.S_OK) //something was returned from the query. let's see if it was expected.
                {
                    //compare the returned value with the expected value
                    if (!xonline.common.service.Acceleration.CompareByteArrays(expectedValue, value))
                    {
                        throw new Exception("Querying Cache for setting " + setting.SettingId + " titleID " + titleID + " and userID " + setting.userId + " did not return the expected value.");
                    }
                }
            }
            //do the same thing for the DASH
            titleID = XOn.XENON_DASH_TITLE_ID;
            expectedValue = setting.Value;
            expectedRetVal = HResult.S_OK;

            //not going to be in cache cases: expect S_FALSE
            if (!isValidSettingID(setting) ||
                setting.Source == (uint)SettingSource.XSOURCE_PERMISSION_DENIED)
            {
                expectedRetVal = HResult.S_FALSE;
                expectedValue = null;
            }
            //NoValue cases
            else if (setting.Source == (uint)SettingSource.XSOURCE_NO_VALUE) //the setting does not exist
            {
                expectedValue = xonline.common.protocol.ProfileDefs.CacheNoValue;
                expectedRetVal = HResult.S_OK;
            }
            //weird case where there is both title and dash settings in the database, but we asked for the title, so we don't know what is the dash id- so we can't verify the data
            else if (setting.Source == (uint)SettingSource.XSOURCE_TITLE)
            {
                //we don't know if there is no value for the dash or not.
                expectedRetVal = HResult.S_OK;
                expectedValue = null;
            }

            //build the cache key
            key = xonline.common.protocol.ProfileDefs.BuildCacheKey(setting.SettingId, titleID, setting.userId);
            value = null;

            //query cache for the setting
            hr = xb.Query(key, out value);
            if (hr != expectedRetVal)
            {
                throw new Exception("Querying Cache for setting " + setting.SettingId + " titleID " + titleID + " and userID " + setting.userId + " returned " + hr + ", expected " + expectedRetVal);
            }
            if (expectedRetVal == HResult.S_OK) //something was returned from the query. let's see if it was expected.
            {
                //compare the returned value with the expected value
                if (expectedValue != null && !xonline.common.service.Acceleration.CompareByteArrays(expectedValue, value))
                {
                    throw new Exception("Querying Cache for setting " + setting.SettingId + " titleID " + titleID + " and userID " + setting.userId + " did not return the expected value.");
                }
            }
        }

        public void verifyByReading(UserSetting[] settings, ulong friend, ulong owner)
        {
            ulong[] friends = new ulong[1];
            friends[0] = friend;

            uint[] sIds = new uint[settings.Length];
            //assume we had to sync it before we read it
            for (int i = 0; i < settings.Length; i++)
            {

                verifyCacheEntryAfterSyncSetting(settings[i]);

                sIds[i] = settings[i].SettingId;
            }

            ReadSettingsRequest req = new ReadSettingsRequest(Title, owner, friends, sIds);
            ReadSettingsResponse resp = req.Execute();

            if (resp.XError != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server: " + resp.XError);
            //should be in Cache because of ReadSettings call
            foreach (UserSetting s in resp.Settings)
            {
                verifyCacheEntryAfterReadSetting(s);
            }

            verifySettings(settings, resp.Settings, (int)resp.SettingsLen);
        }


        public void verifyByReading(UserSetting[] settings)
        {
            verifyByReading(settings, Userid, Userid);
        }

        public void verifyByReadingNoValue(UserSetting[] settings)
        {
            ulong[] friends = new ulong[1];
            friends[0] = Userid;

            uint[] sIds = new uint[settings.Length];

            for (int i = 0; i < settings.Length; i++)
            {
                sIds[i] = settings[i].SettingId;
            }

            ReadSettingsRequest req = new ReadSettingsRequest(Title, Userid, friends, sIds);
            ReadSettingsResponse resp = req.Execute();

            if (resp.XError != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server: " + resp.XError);

            if (resp.SettingsLen != settings.Length)
                throw new Exception("Setting count is different. Expected: " + settings.Length + " Received: " + resp.SettingsLen);

            for (int i = 0; i < settings.Length; i++)
            {

                if (resp.Settings[i].SettingId != settings[i].SettingId)
                    throw new Exception("Setting ID is different. Expected: " + settings[i].SettingId + " Received: " + resp.Settings[i].SettingId);

                if (resp.Settings[i].Source != (uint)SettingSource.XSOURCE_NO_VALUE)
                    throw new Exception("Setting Source is different. Expected: " + SettingSource.XSOURCE_NO_VALUE + " Received: " + resp.Settings[i].Source);

                if (resp.Settings[i].ValueLen != 0)
                    throw new Exception("Setting ValueLen is different. Expected: 0 Received: " + resp.Settings[i].ValueLen);


                xonline.common.service.Acceleration xb = new xonline.common.service.Acceleration(Interface.ProfileCache);
                byte[] expectedValue = settings[i].Value;

                uint hr;
                byte[] key = null;
                byte[] value = null;

                //build the cache key
                key = xonline.common.protocol.ProfileDefs.BuildCacheKey(settings[i].SettingId, Title, settings[i].userId);
                value = null;

                //query cache for the setting
                hr = xb.Query(key, out value);
                if (hr != 0)
                {
                    throw new Exception("Querying Cache for setting " + settings[i].SettingId + " titleID " + Title + " and userID " + settings[i].userId + " returned hr: " + hr + ", expected hr: 0");
                }

                // No Value string returned by cache
                byte[] novalue = new byte[] { 78, 111, 32, 86, 97, 108, 117, 101 };

                System.Text.Encoding encoding = new System.Text.ASCIIEncoding();
                string strnovalue = encoding.GetString(novalue);
                string strvalue = encoding.GetString(value);

                //compare the string returned with 'No Value' expected
                if (strnovalue != strvalue)
                {
                    throw new Exception("Querying Cache for setting " + settings[i].SettingId + " titleID " + Title + " and userID " + settings[i].userId + " returned value: " + strvalue + ", expected: " + strnovalue);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\PosSyncTitles.cs ===
using System;
using System.IO;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using  xonline.common.config;

namespace GamerSettings
{
    /// <summary>
    /// Summary description for PosSyncTitles.
    /// </summary>
    public class PosSyncTitles : TestNode
    {
        public PosSyncTitles()
        {
            AddChild(new SingleTitleinfo()); //BVT

            AddChild(new xbox1_xenonTitleinfo());
            AddChild(new MultipleTitleinfo());
            AddChild(new UpdateSingleTitleinfo());
            AddChild(new UpdateMultipleTitleinfo());
            AddChild(new AddMultipleTitles());
            AddChild(new MixAdd_UpdateMultTitle());
            AddChild(new SyncMaxTitles());
            AddChild(new SyncMax_1Titles());

            AddChild(new SyncResponseGreaterthen32());
            AddChild(new SyncStartIdxEqualSize());
            AddChild(new SyncStartIdxEqualSizeP1());
            AddChild(new SyncMaxRespTitles());
            AddChild(new MultipleLocaleTitleinfo());
            AddChild(new MultipleUsersTitleinfo());

            AddChild(new InvalidTryToWriteTotalCred());
            AddChild(new InvalidSyncMaxPlus1Titles());
            AddChild(new InvalidDupTitleinfo());
            AddChild(new InvalidSGAuth());
            AddChild(new TcSGAuthDiffTitle());
            AddChild(new TCInvalidSmallPKT());
            AddChild(new TCInvalidLargePKT());

            // scenario based test
            AddChild(new OfflineOnLineTitlesplayed());
            AddChild(new PanoramaAndXboxTitlesplayed());
            AddChild(new MProfileOff_OnLineTitlesplayed1());
            AddChild(new MProfileOff_OnLineTitlesplayed2());
            AddChild(new MProfileOff_OnLineSyncFailed());
            AddChild(new OfflinetplayedDashSync());
            AddChild(new onOfflinetplayedDashSync());
            AddChild(new DashSync());

            AddChild(new LegacyUserSync());
            AddChild(new LegacyUserSyncMulti());

            AddChild(new OnLineOfflineTitlesplayed());
            AddChild(new ZeroTitlesplayed());
        }
    }

    public class ZeroTitlesplayed : TitleBase
    {
        public override void Run()
        {
            ulong user = 5000001;
            ResetUsertitles(user);
            UserTitleProfile UProfile1 = new UserTitleProfile(user);

            SyncTitlesResponse resp1 = playtitle(0, DateTime.UtcNow, UProfile1, true);

            verifyGamerSetting(user, 0);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Sync Online and Offline Titles")]
    public class OnLineOfflineTitlesplayed : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ResetUsertitles(user);
            UserTitleProfile UProfile1 = new UserTitleProfile(user);

            SyncTitlesResponse resp = playtitle(50, starttime, UProfile1, true);
            verifysync(resp, null, user, 1033);

            playtitle(50, starttime.AddDays(5), UProfile1, false);
            Thread.Sleep(20000);
            SyncTitlesResponse resp1 = playtitle(0, resp.Version, UProfile1, true);
            verifysync(resp1, null, user, 1033);

            verifybyEnum(user);
        }
    }

    public class LegacyUserSyncMulti : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            UserTitleProfile UProfile1 = new UserTitleProfile(user);
            ResetUsertitles(user);
            DateTime start = DateTime.UtcNow;
            start = start.AddDays(-2);
            AddLegacytitlerow(UProfile1, 50, start, 2);
            start = start.AddHours(2);
            AddLegacytitlerow(UProfile1, 51, start, 5);
            start = start.AddHours(2);
            AddLegacytitlerow(UProfile1, 52, start, 6);

            start = DateTime.UtcNow;
            UserTitleProfile UProfile2 = UProfile1.Copy();

            playtitle(50, start, UProfile1, false);  //offline
            UProfile2.LastIntSyncIdx = UProfile2.LastSyncIdx = UProfile2.Count();
            playtitle(53, start, UProfile2, false);  //offline

            // With Local Caching, we need to wait for the local cache to timeout before validating. 
            Global.RO.Info("Sleeping for 2 seconds for local cache");
            Thread.Sleep(2000);

            start = DateTime.UtcNow;
            SyncTitlesResponse resp = playtitle(0, start, UProfile1, true);
            verifysync(resp, null, user, 1033);

            // With Local Caching, we need to wait for the local cache to timeout before validating. 
            Global.RO.Info("Sleeping for 2 seconds for local cache");
            Thread.Sleep(2000);

            // Verify the previous title is returned with the response sync time minus 1 second (if equal would return nothing)
            SyncTitlesResponse resp2 = playtitle(0, resp.Version.AddSeconds(-1), UProfile2, true);
            verifysync(resp2, new uint[] { 50 }, user, 1033);

            // Now if we were to sync with the version of resp2, we should get nothing
            SyncTitlesRequest req3 = new SyncTitlesRequest(user, resp2.Version, null);
            SyncTitlesResponse resp3 = req3.Execute();
            verifysync(resp3, null, user, 1033);

            verifybyEnum(user, user, 1033, -1, false);
        }
    }

    public class LegacyUserSync : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            UserTitleProfile UProfile1 = new UserTitleProfile(user);
            ResetUsertitles(user);
            DateTime start = DateTime.UtcNow;
            start = start.AddDays(-2);
            AddLegacytitlerow(UProfile1, 50, start, 2);
            start = start.AddHours(2);
            AddLegacytitlerow(UProfile1, 51, start, 5);
            start = start.AddHours(2);
            AddLegacytitlerow(UProfile1, 52, start, 6);
            start = DateTime.UtcNow;
            playtitle(50, start, UProfile1, false);
            playtitle(53, start, UProfile1, false);

            Thread.Sleep(2000);
            start = DateTime.UtcNow;
            SyncTitlesResponse resp = playtitle(0, start, UProfile1, true);
            verifysync(resp, null, user, 1033);

            verifybyEnum(user, user, 1033, -1, false);
        }
    }

    public class DashSync : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ResetUsertitles(user);
            UserTitleProfile UProfile1 = new UserTitleProfile(user);

            SyncTitlesResponse resp = playtitle(50, DateTime.UtcNow, UProfile1, true);
            verifysync(resp, null, user, 1033);

            Thread.Sleep(20000);

            SyncTitlesResponse resp1 = playtitle(0, resp.Version, UProfile1, true);
            verifysync(resp1, null, user, 1033);

            verifybyEnum(user);
        }
    }

    public class onOfflinetplayedDashSync : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ResetUsertitles(user);
            UserTitleProfile UProfile1 = new UserTitleProfile(user);

            playtitle(50, starttime, UProfile1, false);
            playtitle(51, starttime.AddDays(5), UProfile1, true, false);
            Thread.Sleep(20000);
            playtitle(51, starttime.AddDays(5), UProfile1, false);
            Thread.Sleep(20000);
            SyncTitlesResponse resp1 = playtitle(0, DateTime.UtcNow, UProfile1, true);
            verifysync(resp1, null, user, 1033);

            verifybyEnum(user);
        }
    }

    public class OfflinetplayedDashSync : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ResetUsertitles(user);
            UserTitleProfile UProfile1 = new UserTitleProfile(user);

            playtitle(50, starttime, UProfile1, false);
            playtitle(51, starttime.AddDays(5), UProfile1, false);
            Thread.Sleep(20000);
            SyncTitlesResponse resp1 = playtitle(0, DateTime.UtcNow, UProfile1, true);
            verifysync(resp1, null, user, 1033);

            verifybyEnum(user);
        }
    }

    public class MProfileOff_OnLineSyncFailed : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ResetUsertitles(user);
            UserTitleProfile UProfile1 = new UserTitleProfile(user);
            playtitle(51, starttime, UProfile1, false);
            playtitle(50, starttime, UProfile1, true, true);
            playtitle(52, starttime, UProfile1, false);

            Thread.Sleep(20000);
            UserTitleProfile UProfile2 = new UserTitleProfile(user);

            SyncTitlesResponse resp2 = playtitle(53, DateTime.UtcNow, UProfile2, true);
            verifysync(resp2, null, user, 1033);
            Thread.Sleep(20000);

            SyncTitlesResponse resp3 = playtitle(54, starttime, UProfile1, true);
            verifysync(resp3, new uint[] { 53 }, user, 1033);

            verifybyEnum(user);
        }
    }

    public class MProfileOff_OnLineTitlesplayed2 : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ResetUsertitles(user);
            UserTitleProfile UProfile1 = new UserTitleProfile(user);
            playtitle(51, starttime, UProfile1, false);
            SyncTitlesResponse resp = playtitle(50, starttime, UProfile1, true);
            verifysync(resp, null, user, 1033);
            Thread.Sleep(20000);
            UserTitleProfile UProfile2 = UProfile1.Copy();
            playtitle(51, DateTime.UtcNow, UProfile2, false);

            SyncTitlesResponse resp1 = playtitle(52, resp.Version, UProfile1, true);
            verifysync(resp1, null, user, 1033);
            Thread.Sleep(20000);

            SyncTitlesResponse resp2 = playtitle(53, resp.Version, UProfile2, true);
            verifysync(resp2, new uint[] { 52 }, user, 1033);
            Thread.Sleep(20000);
            SyncTitlesResponse resp3 = playtitle(52, resp1.Version, UProfile1, true);
            verifysync(resp3, new uint[] { 51, 53 }, user, 1033);

            verifybyEnum(user);
        }
    }

    public class MProfileOff_OnLineTitlesplayed1 : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ResetUsertitles(user);
            UserTitleProfile UProfile1 = new UserTitleProfile(user);

            playtitle(51, starttime, UProfile1, false);
            SyncTitlesResponse resp = playtitle(50, starttime, UProfile1, true);
            verifysync(resp, null, user, 1033);

            UserTitleProfile UProfile2 = UProfile1.Copy();
            Thread.Sleep(20000);
            playtitle(51, starttime.AddDays(6), UProfile2, false);
            SyncTitlesResponse resp1 = playtitle(53, resp.Version, UProfile2, true);
            verifysync(resp1, null, user, 1033);

            Thread.Sleep(20000);

            SyncTitlesResponse resp2 = playtitle(52, resp.Version, UProfile1, true);
            verifysync(resp2, new uint[] { 51, 53 }, user, 1033);

            verifybyEnum(user);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Sync PC and 360 TItles Played")]
    public class PanoramaAndXboxTitlesplayed : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ResetUsertitles(user);
            UserTitleProfile UProfile1 = new UserTitleProfile(user);

            playtitle(51, starttime, UProfile1, false);
            SyncTitlesResponse resp = playtitle(50, starttime, UProfile1, true);
            verifysync(resp, null, user, 1033);

            Thread.Sleep(20000);

            UserTitleProfile UPanoramaProfile = new UserTitleProfile(user);
            SyncTitlesResponse resp1 = playtitle(53, DateTime.UtcNow, UPanoramaProfile, true);
            verifysync(resp1, null, user, 1033);

            Thread.Sleep(20000);

            SyncTitlesResponse resp2 = playtitle(52, resp.Version, UProfile1, true);
            verifysync(resp2, new uint[] { 53 }, user, 1033);

            verifybyEnum(user);
        }
    }

    public class OfflineOnLineTitlesplayed : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ResetUsertitles(user);
            UserTitleProfile UProfile1 = new UserTitleProfile(user);

            SyncTitlesResponse resp = playtitle(50, starttime, UProfile1, true);
            verifysync(resp, null, user, 1033);

            playtitle(51, starttime.AddDays(5), UProfile1, false);
            Thread.Sleep(20000);
            SyncTitlesResponse resp1 = playtitle(52, resp.Version, UProfile1, true);
            verifysync(resp1, null, user, 1033);

            verifybyEnum(user);
        }
    }

    public class TCInvalidSmallPKT : TestNode
    {
        public override void Run()
        {
            InvalidXRLRequest tmp = new InvalidXRLRequest(10, "/xstats/synctitles.ashx");
            uint xerror = tmp.Execute();
            if (xerror != HResult.XONLINE_E_END_OF_STREAM)
                throw new Exception("Invalid Xerror. Expected: " + HResult.E_FAIL + " Received: " + xerror);
        }
    }

    public class TCInvalidLargePKT : TestNode
    {
        public override void Run()
        {

            InvalidXRLRequest tmp = new InvalidXRLRequest(1000 * 100, "/xstats/synctitles.ashx");
            uint xerror = tmp.Execute();
            if (xerror != xonline.common.service.HResult.XONLINE_E_DESERIALIZATION_ERROR)
                throw new Exception("Invalid Xerror. Expected: " + xonline.common.service.HResult.XONLINE_E_DESERIALIZATION_ERROR.ToString("X") + " Received: " + xerror.ToString("X"));
        }
    }

    public class TcSGAuthDiffTitle : TitleBase
    {
        public override void Run()
        {
            ulong user = 502;
            ProgressWS.ResetUsertitles(user);
            UserTitle[] utitles = new UserTitle[5];
            DateTime now = DateTime.UtcNow;
            for (int i = 0; i < 5; i++)
            {
                DateTime time = now.AddHours(-1 * i);
                utitles[i] = new UserTitle((uint)(50 + i), time, 5, 1, (uint)i + 1);
                AddTitleToVerify(user, utitles[i]);
            }

            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            req.Modifyflag = AuthModify.Change_Title;
            SyncTitlesResponse resp = req.Execute();
            verifysync(resp, null, user, 1033);

            if (resp.Titles.Length == 0)
            {
                verifybyEnum(user);
            }
        }
    }

    public class InvalidSGAuth : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ProgressWS.ResetUsertitles(user);
            UserTitle[] utitles = new UserTitle[1];
            utitles[0] = new UserTitle(51, DateTime.UtcNow, 5, 1, 1);
            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);

            req.Modifyflag = AuthModify.Change_User; // 1 means invalid user
            SyncTitlesResponse resp = req.Execute();

            if (resp.XError != HResult.XONLINE_E_SERVER_ERROR)
                throw new Exception("Unexpected Error: " + resp.XError);
        }
    }

    public class InvalidDupTitleinfo : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ProgressWS.ResetUsertitles(user);
            UserTitle[] utitles = new UserTitle[5];
            DateTime now = DateTime.UtcNow;
            for (int i = 0; i < 4; i++)
            {
                DateTime time = now.AddHours(-1 * i);
                utitles[i] = new UserTitle((uint)(50 + i), time, 5, 1, (uint)i - 1);

            }
            utitles[4] = new UserTitle((uint)(52), DateTime.UtcNow, 5, 1, 5);

            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();

            // commenting as Permission bug 18250
            //if(resp.XError !=HResult.XONLINE_E_STAT_BAD_REQUEST)
            //	throw new Exception("UnExpected Error "+resp.XError);
        }
    }

    public class InvalidSyncMaxPlus1Titles : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            uint count = 33;
            ProgressWS.ResetUsertitles(user);
            UserTitle[] utitles = new UserTitle[count];
            DateTime now = DateTime.UtcNow;
            for (int i = 0; i < count; i++)
            {
                DateTime time = now.AddHours(-1 * i);
                utitles[i] = new UserTitle((uint)(titlebase + i), time, 5, 1, (uint)i + 1);
                AddTitleToVerify(user, utitles[i]);
            }

            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();

            if (resp.XError != HResult.XONLINE_E_DESERIALIZATION_ERROR)
                throw new Exception("Unexpected Error: " + resp.XError);
        }
    }

    public class validTryToWriteOnlintime : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ProgressWS.ResetUsertitles(user);
            UserTitle[] utitles = new UserTitle[1];
            utitles[0] = new UserTitle(51, DateTime.UtcNow, 5, 1, 1);
            //AddTitleToVerify(user,utitles[0]);
            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.ExecuteInt();

            verifysync(resp, null, user, 1033);
            verifybyEnum(user);
        }
    }

    public class InvalidTryToWriteTotalCred : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ProgressWS.ResetUsertitles(user);
            UserTitle[] utitles = new UserTitle[1];
            utitles[0] = new UserTitle(51, DateTime.UtcNow, 5, 1, 1);
            utitles[0].TotalCred = 500;
            //AddTitleToVerify(user,utitles[0]);
            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();

            if (resp.XError != HResult.S_OK)
                throw new Exception("Unexpected Error. Expected: " + HResult.S_OK + " Received: " + resp.XError);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Sync Max Titles Response")]
    public class SyncMaxRespTitles : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            loadtitles(32, user);
            DateTime old = DateTime.UtcNow;
            old = old.AddYears(-1);

            UserTitle[] utitles = new UserTitle[0];

            Thread.Sleep(15000);
            SyncTitlesRequest req = new SyncTitlesRequest(user, old, utitles);
            SyncTitlesResponse resp = req.Execute();

            uint[] titles = new uint[32];
            for (int i = 0; i < 32; i++)
                titles[i] = (uint)(i + 50);
            verifysync(resp, titles, user, 1033);
            verifybyEnum(user, user, 1033, 32, true);
        }
    }

    public class MultipleUsersTitleinfo : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            for (int i = 0; i < 5; i++)
                loadtitles(31, user + 1);
        }
    }

    public class MultipleLocaleTitleinfo : TitleBase
    {
        public override void Run()
        {
            ulong user = 503;
            ProgressWS.ResetUsertitles(user);
            UserTitle[] utitles = new UserTitle[5];
            DateTime now = DateTime.UtcNow;
            for (int i = 0; i < 5; i++)
            {
                DateTime time = now.AddHours(-1 * i);
                utitles[i] = new UserTitle((uint)(50 + i), time, 5, 1, (uint)i + 1);
                AddTitleToVerify(user, utitles[i], 1036);
                AddTitleToVerify(user, utitles[i]);
            }

            Thread.Sleep(2000);
            SyncTitlesRequest req = new SyncTitlesRequest(user, 1034, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();
            verifysync(resp, null, user, 1033);

            Thread.Sleep(2000);
            SyncTitlesRequest req2 = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp2 = req2.Execute();
            verifysync(resp2, null, user, 1033);

            if (resp.Titles.Length == 0 && resp2.Titles.Length == 0)
            {
                verifybyEnum(user);
                verifybyEnum(user, user, 1036);
            }
        }
    }

    public class SyncMax_1Titles : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            loadtitles(31, user);

            UserTitle[] utitles = new UserTitle[1];
            utitles[0] = new UserTitle(90, DateTime.UtcNow, 5, 1, 33);
            AddTitleToVerify(user, utitles[0]);
            DateTime old = DateTime.UtcNow;
            old = old.AddYears(-2);
            SyncTitlesRequest req = new SyncTitlesRequest(user, old, utitles);
            SyncTitlesResponse resp = req.Execute();

            uint[] titles = new uint[31];
            for (int i = 0; i < 31; i++)
                titles[i] = (uint)(i + 50);
            verifysync(resp, titles, user, 1033);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(1), Description("Sync Max Titles")]
    public class SyncMaxTitles : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            loadtitles(32, user);

            UserTitle[] utitles = new UserTitle[1];
            utitles[0] = new UserTitle(90, DateTime.UtcNow, 5, 1, 1);
            AddTitleToVerify(user, utitles[0]);
            DateTime old = DateTime.UtcNow;
            old = old.AddYears(-2);
            SyncTitlesRequest req = new SyncTitlesRequest(user, old, utitles);
            SyncTitlesResponse resp = req.Execute();

            uint[] titles = new uint[32];
            for (int i = 0; i < 32; i++)
                titles[i] = (uint)(i + 50);
            verifysync(resp, titles, user, 1033);
        }
    }

    public class MixAdd_UpdateMultTitle : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            loadtitles(5, user);

            UserTitle[] utitles = new UserTitle[4];
            utitles[0] = new UserTitle(titlebase, DateTime.UtcNow, 10, 30, 7);
            utitles[1] = new UserTitle(titlebase + 4, DateTime.UtcNow, 10, 30, 8);
            utitles[2] = new UserTitle(titlebase + 10, DateTime.UtcNow, 10, 30, 9);
            utitles[3] = new UserTitle(titlebase + 11, DateTime.UtcNow, 9, 30, 10);
            AddTitleToVerify(user, utitles[0]);
            AddTitleToVerify(user, utitles[1]);
            AddTitleToVerify(user, utitles[2]);
            AddTitleToVerify(user, utitles[3]);
            Thread.Sleep(15000);
            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();
            verifysync(resp, null, user, 1033);

            verifybyEnum(user);
        }
    }

    public class AddMultipleTitles : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            loadtitles(1, user); //sync title 50

            UserTitle[] utitles = new UserTitle[2];
            utitles[0] = new UserTitle(titlebase + 1, DateTime.UtcNow, 10, 30, 7); //add title 51 to sync
            utitles[1] = new UserTitle(titlebase + 2, DateTime.UtcNow, 10, 30, 8); //add title 52 to sync

            AddTitleToVerify(user, utitles[0]);
            AddTitleToVerify(user, utitles[1]);

            Thread.Sleep(1000);

            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles); //sync new titles
            SyncTitlesResponse resp = req.Execute();
            verifysync(resp, null, user, 1033);

            verifybyEnum(user);
        }
    }

    public class UpdateMultipleTitleinfo : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            loadtitles(5, user);

            UserTitle[] utitles = new UserTitle[2];
            utitles[0] = new UserTitle(titlebase, DateTime.UtcNow, 10, 30, 7);
            utitles[1] = new UserTitle(titlebase + 4, DateTime.UtcNow, 10, 30, 8);
            AddTitleToVerify(user, utitles[0]);
            AddTitleToVerify(user, utitles[1]);
            Thread.Sleep(15000);
            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();
            verifysync(resp, null, user, 1033);

            verifybyEnum(user);
        }
    }

    [TestFrequency("BVT"), BVT, TestCasePriority(1), Description("Sync Title Update")]
    public class UpdateSingleTitleinfo : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            loadtitles(5, user);

            UserTitle[] utitles = new UserTitle[1];
            utitles[0] = new UserTitle(titlebase + 3, DateTime.UtcNow, 10, 30, 7);
            AddTitleToVerify(user, utitles[0]);
            Thread.Sleep(15000);
            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();
            verifysync(resp, null, user, 1033);

            verifybyEnum(user);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(1), Description("Sync Multiple Titles")]
    public class MultipleTitleinfo : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ProgressWS.ResetUsertitles(user);
            UserTitle[] utitles = new UserTitle[5];
            DateTime now = DateTime.UtcNow;
            for (int i = 0; i < 5; i++)
            {
                DateTime time = now.AddHours(-1 * (10 - i));
                utitles[i] = new UserTitle((uint)(50 + i), time, 5, 1, (uint)i + 1);
                AddTitleToVerify(user, utitles[i]);
            }

            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();
            verifysync(resp, null, user, 1033);

            if (resp.Titles.Length == 0)
            {
                verifybyEnum(user);
            }
        }
    }

    //SyncStartIdxEqualSize
    public class SyncStartIdxEqualSizeP1 : TitleBase
    {
        public override void Run()
        {
            ulong user = 510;
            ProgressWS.ResetUsertitles(user);
            Thread.Sleep(100);

            // add 10 titles 
            loadtitles(10, user);

            DateTime yesturday = DateTime.UtcNow;
            yesturday = yesturday.AddYears(-2);

            UserTitle[] utitles2 = new UserTitle[0];

            SyncTitlesRequest req1 = new SyncTitlesRequest(user, yesturday, utitles2, 11);
            SyncTitlesResponse resp1 = req1.Execute();

            if (resp1.TotalTitles != 10)
                throw new Exception("Wrong Total Size. Expected: 10 Received: " + resp1.TotalTitles);

            verifysync(resp1, new uint[] { }, user, 1033);
        }
    }

    public class SyncStartIdxEqualSize : TitleBase
    {
        public override void Run()
        {
            ulong user = 510;
            ProgressWS.ResetUsertitles(user);
            Thread.Sleep(100);

            // add 10 titles 
            loadtitles(10, user);

            DateTime yesturday = DateTime.UtcNow;
            yesturday = yesturday.AddYears(-2);

            UserTitle[] utitles2 = new UserTitle[0];

            SyncTitlesRequest req1 = new SyncTitlesRequest(user, yesturday, utitles2, 10);
            SyncTitlesResponse resp1 = req1.Execute();

            if (resp1.TotalTitles != 10)
                throw new Exception("Wrong Total Size. Expected: 10 Received: " + resp1.TotalTitles);

            verifysync(resp1, new uint[] { (uint)titlebase }, user, 1033);
        }
    }

    public class SyncResponseGreaterthen32 : TitleBase
    {
        public override void Run()
        {
            ulong user = 510;
            ProgressWS.ResetUsertitles(user);
            Thread.Sleep(5000);

            // add 37 titles 
            loadtitles(32, user);

            //added additional 5
            UserTitle[] utitles = new UserTitle[5];
            for (int i = 0; i < 5; i++)
            {
                utitles[i] = new UserTitle((uint)(titlebase + 32 + i), DateTime.UtcNow, 5, 1, (uint)(32 + i + 1));
                AddTitleToVerify(user, utitles[i]);
            }

            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();
            //verifysync(resp,null,user,1033);

            Thread.Sleep(15000);
            DateTime yesturday = DateTime.UtcNow;
            yesturday = yesturday.AddYears(-2);

            UserTitle[] utitles2 = new UserTitle[0];

            SyncTitlesRequest req1 = new SyncTitlesRequest(user, yesturday, utitles2);
            SyncTitlesResponse resp1 = req1.Execute();

            uint[] expectedtitle = new uint[32];
            for (int j = 0; j < 32; j++)
                expectedtitle[j] = (uint)(titlebase + j + 5);

            // KKline - changed this from 37 because 37 is not possible as defined in xon.cs
            // XONLINE_MAX_SETTING_COUNT = 32
            if (resp1.TotalTitles != 32)
                throw new Exception("Wrong Total Size. Expected: 32 Received: " + resp1.TotalTitles);

            verifysync(resp1, expectedtitle, user, 1033);

            SyncTitlesRequest req2 = new SyncTitlesRequest(user, yesturday, utitles2, 33);
            SyncTitlesResponse resp2 = req2.Execute();

            uint[] expectedtitle2 = new uint[5];
            for (int j = 0; j < 5; j++)
                expectedtitle2[j] = (uint)(titlebase + j);
            verifysync(resp2, expectedtitle2, user, 1033);
        }
    }

    //xbox1_xenonTitleinfo
    public class xbox1_xenonTitleinfo : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ProgressWS.ResetUsertitles(user);

            // add xbox1 title 
            DateTime old = DateTime.UtcNow;
            old = old.AddMinutes(-5);

            ProgressWS.AddTitleToMsgTitle(user, -4129280, old);
            UserTitle[] utitles = new UserTitle[1];
            utitles[0] = new UserTitle(51, DateTime.UtcNow, 5, 1, 1);
            AddTitleToVerify(user, utitles[0]);

            DateTime yesturday = DateTime.UtcNow;
            yesturday = yesturday.AddDays(-1);
            Thread.Sleep(200);

            SyncTitlesRequest req = new SyncTitlesRequest(user, yesturday, utitles);
            SyncTitlesResponse resp = req.Execute();

            verifysync(resp, null, user, 1033);

            if (resp.Titles.Length == 0)
            {
                verifybyEnum(user);
            }
        }
    }

    [TestFrequency("BVT"), BVT, TestCasePriority(1), Description("Sync Title BVT")]
    public class SingleTitleinfo : TitleBase
    {
        public override void Run()
        {
            ulong user = 501;
            ResetUsertitles(user);
            UserTitle[] utitles = new UserTitle[1];
            utitles[0] = new UserTitle(51, DateTime.UtcNow, 5, 1, 1);
            AddTitleToVerify(user, utitles[0]);
            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();

            verifysync(resp, null, user, 1033);

            if (resp.Titles.Length == 0)
            {
                verifybyEnum(user);
            }
        }
    }

    public class TitleList
    {
        public ArrayList m_Titlelist = new ArrayList();
        public int LastSyncIdx = 0;
        public int LastIntSyncIdx = 0;

        public void playtitle(UserTitle titleid)
        {
            UserTitle tmp = null;

            if (m_Titlelist.Contains(titleid))
            {
                foreach (UserTitle ut in m_Titlelist)
                {
                    if (titleid.TitleId == ut.TitleId)
                    {
                        tmp = ut;
                        break;
                    }
                }
                m_Titlelist.Remove(titleid);
                if (LastSyncIdx != 0)
                    LastSyncIdx--;
                if (LastIntSyncIdx != 0)
                    LastIntSyncIdx--;

            }
            if (tmp != null && tmp.LastPlayed.CompareTo(titleid.LastPlayed) > 0)
                m_Titlelist.Add(tmp);
            else
                m_Titlelist.Add(titleid);
        }

        public int Count()
        {
            return m_Titlelist.Count;
        }
        public void syncwithserver(UserTitle[] titles)
        {
            UserTitle currenttitle = (UserTitle)m_Titlelist[m_Titlelist.Count - 1];
            for (int i = 0; i < titles.Length; i++)
            {
                playtitle(titles[i]);
            }
            playtitle(currenttitle);
        }

        public UserTitle Contains(uint titleid)
        {
            for (int i = 0; i < m_Titlelist.Count; i++)
            {
                if (((UserTitle)m_Titlelist[i]).TitleId == titleid)
                    return (UserTitle)m_Titlelist[i];
            }
            return null;
        }
    }

    public class UserTitleProfile : TitleList
    {
        public ulong userid;
        public uint sequence = 1;

        public UserTitleProfile(ulong uid)
        {
            userid = uid;
        }

        public UserTitleProfile Copy()
        {
            UserTitleProfile tmp = new UserTitleProfile(userid);
            foreach (UserTitle title in m_Titlelist)
            {
                tmp.m_Titlelist.Add(title);
            }
            tmp.LastSyncIdx = LastSyncIdx;

            return tmp;
        }
    }

    public class TitleBase : TestNode
    {
        public static GameConfig gconfig = new GameConfig();
        public uint titlebase = 50;
        protected DateTime starttime = new DateTime(2000, 11, 15);

        public void ResetUsertitles(ulong user)
        {
            if (Servertitles.ContainsKey(user))
            {
                Servertitles.Remove(user);
            }
            ProgressWS.ResetUsertitles(user);
        }

        public override void Run()
        {
        }

        protected Hashtable Servertitles = new Hashtable();

        public void AddTitleToVerify(ulong user, UserTitle title)
        {
            AddTitleToVerify(user, title, (ushort)1033);
        }

        public void AddTitleToVerify(ulong user, UserTitle title, ushort locale)
        {

            if (!Servertitles.ContainsKey(user))
            {
                TitleList tlist = new TitleList();
                tlist.playtitle(title);
                Servertitles.Add(user, tlist);
            }
            else
            {
                TitleList tlist = (TitleList)Servertitles[user];
                tlist.playtitle(title);
            }
        }

        public void AddLegacytitlerow(UserTitleProfile userp, int titleid, DateTime logontime, int sequence)
        {
            Random rd = new Random();
            if (titleid != 0)
            {
                UserTitle utitle = new UserTitle((uint)titleid, logontime, (uint)rd.Next(), (ushort)rd.Next(), (uint)sequence);
                userp.playtitle(utitle);
            }

            ProgressWS.AddLegacyTitleRow(userp.userid, titleid, logontime, sequence);
            userp.sequence = (uint)sequence;
            userp.LastSyncIdx = userp.Count();
        }


        public SyncTitlesResponse playtitle(uint titleid, DateTime LastSyncTime, UserTitleProfile userp, bool online)
        {
            return playtitle(titleid, LastSyncTime, userp, online, false);
        }

        public SyncTitlesResponse playtitle(uint titleid, DateTime LastSyncTime, UserTitleProfile userp, bool online, bool forcefail)
        {
            Random rd = new Random();
            SyncTitlesResponse resp = null;
            if (online)
            {
                if (titleid != 0)
                {
                    UserTitle utitle = new UserTitle(titleid, DateTime.UtcNow, (uint)rd.Next(), (ushort)rd.Next(), userp.sequence++);
                    userp.playtitle(utitle);
                }

                int count = userp.Count() - userp.LastSyncIdx;
                UserTitle[] utitles = new UserTitle[count];
                for (int i = userp.LastSyncIdx, j = 0; i < userp.Count(); i++, j++)
                {
                    utitles[j] = (UserTitle)userp.m_Titlelist[i];
                }

                for (int i = userp.LastIntSyncIdx, j = 0; i < userp.Count(); i++, j++)
                {
                    AddTitleToVerify(userp.userid, (UserTitle)userp.m_Titlelist[i]);
                }

                if (!forcefail)
                {
                    SyncTitlesRequest req = new SyncTitlesRequest(userp.userid, LastSyncTime, utitles);
                    resp = req.Execute();
                    if (resp.XError != 0)
                        throw new Exception("Unexpected Error: " + resp.XError);

                    userp.LastIntSyncIdx = userp.LastSyncIdx = userp.Count();
                }
                else
                    userp.LastIntSyncIdx = userp.Count();
            }
            else
            {
                DateTime minval = new DateTime(1753, 1, 1);
                UserTitle utitle = new UserTitle(titleid, minval, (uint)rd.Next(), (ushort)rd.Next(), userp.sequence++);
                userp.playtitle(utitle);
            }

            return resp;
        }

        public void loadtitles(int count, ulong user)
        {
            Random rd = new Random();
            ProgressWS.ResetUsertitles(user);
            if (Servertitles.ContainsKey(user))
                Servertitles.Remove(user);

            UserTitle[] utitles = new UserTitle[count];
            DateTime now = DateTime.UtcNow;
            for (int i = 0; i < count; i++)
            {
                DateTime time = now.AddHours(-1 * (count - i));
                utitles[i] = new UserTitle((uint)(titlebase + i), time, (uint)rd.Next(), (ushort)rd.Next(), (uint)(i + 1));
                AddTitleToVerify(user, utitles[i]);
            }

            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();

            if (resp.XError != 0)
                throw new Exception("Unexpected Error: " + resp.XError);

            if (resp.Titles.Length == 0)
            {
                verifybyEnum(user);
            }
        }

        public void verifyGamerSetting(ulong user, int value)
        {
            // title =  _Title, user = UWoner, gamerscore = UWonerScore

            //--read settings and enum title and verify.
            uint[] settings = new uint[1];
            settings[0] = ProfileDefs.GAMERCARD_TITLES_PLAYED;

            ReadSettingsRequest req = new ReadSettingsRequest(50, user, new ulong[] { user }, settings);
            ReadSettingsResponse resp = req.Execute();

            foreach (UserSetting us in resp.Settings)
            {
                if (us.Value.Length == 0)
                {
                    if (value != 0)
                        throw new Exception("GAMERCARD_TITLES_PLAYED Expected: 0 Received: " + value);
                    return;
                }
                BinaryReader red = new System.IO.BinaryReader(new MemoryStream(us.Value));
                int Respvalue = red.ReadInt32();

                if (Respvalue != value)
                    throw new Exception("GAMERCARD_TITLES_PLAYED Expected: " + value + " Received: " + Respvalue);
            }
        }

        public void verifybyEnum(ulong user)
        {
            verifybyEnum(user, user, 1033);
        }

        public void verifybyEnum(ulong user, ulong friend, ushort Locale)
        {
            verifybyEnum(user, friend, Locale, -1, true);
        }

        public void verifybyEnum(ulong user, ulong friend, ushort Locale, short _count, bool verifyTotaltitlessetting)
        {
            ushort count = (ushort)_count;

            EnumTitlesRequest req = new EnumTitlesRequest(user, friend, 0, count, Locale);
            EnumTitlesResponse resp = req.Execute();

            if (resp.XError == HResult.S_OK)
            {
                if (Servertitles.ContainsKey(friend))
                {
                    TitleList tlist = (TitleList)Servertitles[user];
                    if (_count == -1)
                        count = (ushort)(tlist.Count());
                    if (count != resp.TitlesLen)
                        throw new Exception("Unexpected title count in enum response. Expected: " + count + " Received: " + resp.TitlesLen);

                    for (int i = 0; i < resp.TitlesLen; i++)
                    {
                        UserTitle recived = resp.Titles[i];

                        UserTitle expected = (UserTitle)tlist.m_Titlelist[(tlist.Count() - (i + 1))];

                        string titlename = gconfig.GetTitleName(recived.TitleId, Locale);
                        uint TotaltitleCread = gconfig.GetTotalCread(recived.TitleId);
                        if (expected.TitleId != recived.TitleId)
                            throw new Exception("Invalid Title ID. Expected: " + expected.TitleId + " Received: " + recived.TitleName);
                        if (titlename != recived.TitleName)
                            throw new Exception("Invalid Name. Expected: " + titlename + " Received: " + recived.TitleName);
                        if (expected.LastPlayed.ToString() != recived.LastPlayed.ToString())
                            throw new Exception("Invalid LastPlayed. Expected: " + expected.LastPlayed + " Received: " + recived.LastPlayed);
                        if (expected.Sequence != recived.Sequence)
                            throw new Exception("Invalid Sequence. Expected: " + expected.Sequence + " Received: " + recived.Sequence);
                        /*if(expected.NumAchievements!=recived.NumAchievements)
                          throw new Exception("Invalid NumAchievements excepted ="+expected.NumAchievements+"Recived"+recived.NumAchievements);
                          if(expected.NumCreds!=recived.NumCreds)
                          throw new Exception("Invalid NumCreds excepted ="+TotaltitleCread+"Recived"+recived.NumCreds);
                          if(TotaltitleCread!=recived.TotalCred)
                          throw new Exception("Invalid TotalCred excepted ="+expected.TotalCred+"Recived"+recived.TotalCred);
                          ushort TAchiements= gconfig.GetTotalAchievements(recived.TitleId);
                          if(TAchiements!=recived.TotalAchievements)
                          throw new Exception("Invalid TotalAchievements excepted ="+TAchiements+"Recived"+recived.TotalAchievements);
                        */
                    }

                    if (verifyTotaltitlessetting)
                        verifyGamerSetting(user, tlist.Count());
                }
                else
                    throw new Exception("Unexpected user " + friend);
            }
            else
                throw new Exception("Unexpected Error: " + resp.XError);

        }

        public void verifysync(SyncTitlesResponse resp, uint[] Expectedtitles, ulong friend, ushort Locale)
        {
            int count;

            int ExpectedRec = 0;

            if (Expectedtitles != null)
                ExpectedRec = Expectedtitles.Length;

            if (resp.TitlesLen != ExpectedRec)
                throw new Exception("Unexpected number of records. Expected: " + ExpectedRec + " Received:" + resp.TitlesLen);

            if (resp.XError == HResult.S_OK)
            {
                TitleList tlist = null;
                if (Servertitles.ContainsKey(friend))
                    tlist = (TitleList)Servertitles[friend];
                else
                    throw new Exception("User not found " + friend);

                count = (ushort)tlist.Count();
                for (int i = 0; i < resp.TitlesLen; i++)
                {
                    UserTitle recived = resp.Titles[i];
                    bool found = false;
                    for (int expt = 0; expt < Expectedtitles.Length; expt++)
                    {
                        if (recived.TitleId == Expectedtitles[expt])
                        {
                            found = true;
                            break;
                        }
                    }

                    if (!found)
                        throw new Exception("Unexpected title recived in Sync: " + recived.TitleId);

                    UserTitle expected = tlist.Contains(recived.TitleId);
                    if (expected != null)
                    {

                        string titlename = gconfig.GetTitleName(recived.TitleId, Locale);
                        if (titlename != recived.TitleName)
                            throw new Exception("Invalid Name. Expected: " + titlename + " Received: " + recived.TitleName);
                        if (expected.LastPlayed.ToString() != recived.LastPlayed.ToString())
                            throw new Exception("Invalid LastPlayed. Expected: " + expected.LastPlayed + " Received: " + recived.LastPlayed);
                        if (expected.Sequence != recived.Sequence)
                            throw new Exception("Invalid Sequence. Expected: " + expected.Sequence + " Received: " + recived.Sequence);
                        /*	if(expected.NumAchievements!=recived.NumAchievements)
                          throw new Exception("Invalid NumAchievements excepted ="+expected.NumAchievements+"Recived"+recived.NumAchievements);
                          if(expected.NumCreds!=recived.NumCreds)
                          throw new Exception("Invalid NumCreds excepted ="+expected.NumCreds+"Recived"+recived.NumCreds);
                          uint TotalCread= gconfig.GetTotalCread(recived.TitleId);
                          if(TotalCread!=recived.TotalCred)
                          throw new Exception("Invalid TotalCred excepted ="+TotalCread+"Recived"+recived.TotalCred);
                          ushort TAchiements= gconfig.GetTotalAchievements(recived.TitleId);
                          if(TAchiements!=recived.TotalAchievements)
                          throw new Exception("Invalid TotalAchievements excepted ="+TAchiements+"Recived"+recived.TotalAchievements);
                        */
                    }
                    else
                        throw new Exception("Unexpected title in Sync Response: " + resp.Titles[i].TitleId);
                }
            }
            else
                throw new Exception("Unexpected Error: " + resp.XError);
        }
    }

    class TitleKey
    {
        ulong user;
        uint title;

        public TitleKey(ulong _user, uint _title)
        {
            user = _user;
            title = _title;
        }

        public override bool Equals(object obj)
        {
            return (user == ((TitleKey)obj).user)
                && (title == ((TitleKey)obj).title);
        }

        public override int GetHashCode()
        {
            return (int)(title + user);
        }
    }

    public class InvalidXRLRequest : XRLPayload
    {
        int _bytestosend = 0;
        string _url = null;

        public InvalidXRLRequest(int bytestosend, string url)
        {
            _bytestosend = bytestosend;
            _url = url;
        }

        protected override string GetServiceName()
        {
            return _url;
        }

        new public uint Execute()
        {
            // Prepare request 
            MemoryStream reqStream = new MemoryStream(512);
            byte[] buffer = new byte[_bytestosend];
            Random rand = new Random();
            rand.NextBytes(buffer);
            BinaryWriter writer = new BinaryWriter(reqStream);
            writer.Write(buffer);

            bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd), reqStream);
            return this.XErr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\SyncAll.cs ===
using System;
using System.IO;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using  xonline.common.config;
using ServerTestFramework.LiveService.Achievement;

namespace GamerSettings
{
	/// <summary>
	/// Summary description for SyncAll.
	/// </summary>
	public class SyncAll :TestNode
	{
		public SyncAll()
		{
			AddChild(new SyncSingleAll());
			AddChild(new SyncMaxRequestAll());
			AddChild(new SyncMaxResponseAll());
			AddChild(new SyncDiffeLenAll());
			AddChild(new SGAuthDiffTitle());
			AddChild(new ReSyncUsingOldGUID());
			AddChild(new SyncAllZeroGUID());
			AddChild(new InvalidMisMatchLen());
			AddChild(new InvalidSGAuthPuid());
			AddChild(new TCInvalidSmallPKT());
			AddChild(new TCInvalidLargePKT());

        }
		public class TCInvalidSmallPKT:TestBase
		{
			override protected void Execute()
			{

				InvalidXRLRequest tmp = new InvalidXRLRequest(10,"/xstats/syncall.ashx");
				uint xerror= tmp.Execute();
                if (xerror != HResult.XONLINE_E_END_OF_STREAM)
                    throw new Exception("Invalid Xerror. Expected: " + HResult.E_FAIL + " Received: " + xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

		public class TCInvalidLargePKT:TestBase
		{
			override protected void Execute()
			{

				InvalidXRLRequest tmp = new InvalidXRLRequest(1000*1000,"/xstats/syncall.ashx");
				uint xerror= tmp.Execute();
                if (xerror != HResult.E_INVALIDARG && xerror != HResult.XONLINE_E_SERVER_ERROR)
                    throw new Exception("Invalid Xerror. Expected: " + HResult.E_FAIL + " Received: " + xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

		public class SGAuthDiffTitle: SyncAllBase
		{

			override protected void Execute()
			{
				Guid  tmp =Guid.NewGuid();
				Init(50,9001,1033,tmp.ToByteArray());
				AddAchievements(1);
				AddSettings(1);
				AddTitles(1);

				Req.TitlesVersion=Req.AchievementsVersion=Req.SettingsVersion= DateTime.UtcNow;
				Req.Modifyflag=AuthModify.Change_Title;
			
				SyncAllResponse resp = Req.Execute();
                if (resp.XError == 0)
                    VerifyAll();
                else
                    throw new Exception("Unexpected Xerror " + resp.XError);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

	}

	public class InvalidMisMatchLen: SyncAllBase
	{

		override protected void Execute()
		{
			Guid  tmp =Guid.NewGuid();
			Init(52,9001,1033,tmp.ToByteArray());
			AddAchievements(5);
			AddSettings(5);
			AddTitles(5);
			Req.AchievementsLen=10;
			Req.SettingsLen=5;
			Req.TitlesLen=5;
			Req.ManualArraySize=true;

			Req.TitlesVersion=Req.AchievementsVersion=Req.SettingsVersion= DateTime.UtcNow;
			
			SyncAllResponse resp = Req.Execute();
            if (!HResult.Failed(resp.XError))
                throw new Exception("Unexpected Xerror " + resp.XError);

			Req.AchievementsLen=5;
			Req.SettingsLen=10;

			SyncAllResponse resp1 = Req.Execute();
            if (!HResult.Failed(resp1.XError))
                throw new Exception("Unexpected Xerror " + resp1.XError);

			Req.SettingsLen=5;
			Req.TitlesLen=15;

			SyncAllResponse resp2 = Req.Execute();
            if (!HResult.Failed(resp2.XError))
                throw new Exception("Unexpected Xerror " + resp2.XError);


			ResultCode = TEST_RESULTS.PASSED;
		}
	}


	public class SyncAllZeroGUID: SyncAllBase
	{

		override protected void Execute()
		{
			Init(50,9001,1033,new byte[]{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0});
			AddAchievements(1);
			AddSettings(1);
			AddTitles(1);

			Req.TitlesVersion=Req.AchievementsVersion=Req.SettingsVersion= DateTime.UtcNow;
			
			SyncAllResponse resp = Req.Execute();
            if (resp.XError == 0)
                VerifyAll();
            else
                throw new Exception("Unexpected Xerror " + resp.XError);
			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	public class ReSyncUsingOldGUID: SyncAllBase
	{

		override protected void Execute()
		{
			Guid  tmp =Guid.NewGuid();
			Init(50,9001,1033,tmp.ToByteArray());
			AddAchievements(1);
			AddSettings(1);
			AddTitles(1);

			Req.TitlesVersion=Req.AchievementsVersion=Req.SettingsVersion= DateTime.UtcNow;
			
			SyncAllResponse resp = Req.Execute();
            if (resp.XError == 0)
                VerifyAll();
            else
                throw new Exception("Unexpected Xerror " + resp.XError);

			int Occurrence = StatsWS.GetGUIDOccurrences(tmp,9001);
            if (Occurrence != 1)
                throw new Exception("Guid Occurrence should be 1 but is " + Occurrence);

			SyncAllResponse resp1 = Req.Execute();

            if (resp1.XError != HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                throw new Exception("Invalid XError " + resp1.XError);


			Occurrence = StatsWS.GetGUIDOccurrences(tmp,9001);
            if (Occurrence != 2)
                throw new Exception("Guid Occurrence should be 2 but is " + Occurrence);

			// resubmit with same GUID.

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	public class InvalidSGAuthPuid: SyncAllBase
	{

		override protected void Execute()
		{
			Guid  tmp =Guid.NewGuid();
			Init(50,9001,1033,tmp.ToByteArray());
			AddAchievements(1);
			AddSettings(1);
			AddTitles(1);

			Req.TitlesVersion=Req.AchievementsVersion=Req.SettingsVersion= DateTime.UtcNow;
			Req.Modifyflag=AuthModify.Change_User;
			
			SyncAllResponse resp = Req.Execute();
            if (resp.XError != HResult.XONLINE_E_SERVER_ERROR)
                throw new Exception("Invalid Xerror " + resp.XError);

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	
	public class SyncDiffeLenAll: SyncAllBase
	{

		override protected void Execute()
		{

			// first load max all
			Guid  tmp =Guid.NewGuid();
			Init(52,9001,1033,tmp.ToByteArray());
			AddAchievements(10);
			AddSettings(5);
			AddTitles(22);

			Req.TitlesVersion=Req.AchievementsVersion=Req.SettingsVersion= DateTime.UtcNow;
			
			SyncAllResponse resp = Req.Execute();
            if (resp.XError == 0)
                VerifyAll();
            else
                throw new Exception("unexpected Xerror " + resp.XError);

			// request with all zero

			XRLSyncAllRequest SyncReq= new XRLSyncAllRequest(9001,52,1033,Guid.NewGuid().ToByteArray());
			DateTime Old = DateTime.UtcNow;
			SyncReq.TitlesVersion=SyncReq.AchievementsVersion=SyncReq.SettingsVersion= Old.AddYears(-2);
			SyncAllResponse Maxresp = SyncReq.Execute();

			VerifySyncAll(Maxresp,10,22);

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	public class SyncMaxResponseAll: SyncAllBase
	{

		override protected void Execute()
		{

			// first load max all
			Guid  tmp =Guid.NewGuid();
			Init(52,9001,1033,tmp.ToByteArray());
			AddAchievements(AchievConst.MAX_Achievement);
			AddSettings(GSLimits.XONLINE_MAX_SETTING_COUNT);
			AddTitles(GSLimits.XONLINE_MAX_SETTING_COUNT);

			Req.TitlesVersion=Req.AchievementsVersion=Req.SettingsVersion= DateTime.UtcNow;
			
			SyncAllResponse resp = Req.Execute();
            if (resp.XError == 0)
                VerifyAll();
            else
                throw new Exception("Unexpected Xerror " + resp.XError);

			// request with all zero

			XRLSyncAllRequest SyncReq= new XRLSyncAllRequest(9001,52,1033,Guid.NewGuid().ToByteArray());
			DateTime Old = DateTime.UtcNow;
			SyncReq.TitlesVersion=SyncReq.AchievementsVersion=SyncReq.SettingsVersion= Old.AddYears(-2);
			SyncAllResponse Maxresp = SyncReq.Execute();

			VerifySyncAll(Maxresp,AchievConst.MAX_Achievement,GSLimits.XONLINE_MAX_SETTING_COUNT);

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [TestFrequency("Daily"), TestCasePriority(2), Description("Sync Max All")]
	public class SyncMaxRequestAll: SyncAllBase
	{

		override protected void Execute()
		{
			Guid  tmp =Guid.NewGuid();
			Init(52,9001,1033,tmp.ToByteArray());
			AddAchievements(AchievConst.MAX_Achievement);
			AddSettings(GSLimits.XONLINE_MAX_SETTING_COUNT);
			AddTitles(GSLimits.XONLINE_MAX_SETTING_COUNT);

			Req.TitlesVersion=Req.AchievementsVersion=Req.SettingsVersion= DateTime.UtcNow;
			
			SyncAllResponse resp = Req.Execute();
            if (resp.XError == 0)
                VerifyAll();
            else
                throw new Exception("Unexpected Xerror " + resp.XError);
			ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [TestFrequency("Daily"), TestCasePriority(1), Description("Sync All for user")]
	public class SyncSingleAll: SyncAllBase
	{

		override protected void Execute()
		{
			Guid  tmp =Guid.NewGuid();
			Init(50,9001,1033,tmp.ToByteArray());
			AddAchievements(1);
			AddSettings(1);
			AddTitles(1);

			Req.TitlesVersion=Req.AchievementsVersion=Req.SettingsVersion= DateTime.UtcNow;
			
			SyncAllResponse resp = Req.Execute();
            if (resp.XError == 0)
                VerifyAll();
            else
                throw new Exception("Unexpected Xerror " + resp.XError);
			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	public class SyncAllBase:TestBase
	{
		public ulong User=0;
		public uint Title=0;
		public ushort Locale;

		public UserSettingBase setting = new UserSettingBase();
		public TitleBase	   titles = new TitleBase();
		public AchivementBase  Achievements= new  AchivementBase();
		public UserSetting[] settings = null;
		public XRLSyncAllRequest Req= null;

		public void  Init(uint title,ulong user,ushort localeId,byte[] guid)
		{
			User=user;
			Title=title;
			Locale=localeId;

			Req = new XRLSyncAllRequest(user,title,localeId,guid);
		}
		override protected void Execute()
		{
		}

		public void AddTitles(int count)
		{
			Random rd= new Random();
			ProgressWS.ResetUsertitles(User);
			UserTitle[] utitles = new UserTitle[count];
			DateTime now = DateTime.UtcNow;
			for(int i=0;i<count;i++)
			{
				DateTime time =now.AddHours(-1*i);
				utitles[i]= new UserTitle((uint)(titles.titlebase+i),time,(uint)rd.Next(),(ushort)rd.Next(),(uint)(count-1));
				titles.AddTitleToVerify(User,utitles[i]);
			}
			Req.Titles=utitles; 
		}

		public void AddSettings(int count)
		{
			ProfileWS.ResetUserSetttings(User);
			RandomEx rand= new RandomEx();
			int startsettingid = (int)TestUSetting.Test_bMaxNo;

			settings= new UserSetting[count];
			for(int i=0;i<count;i++)
			{
				settings[i]= new UserSetting(User,(uint)(startsettingid+i),rand.GenerateRandomBlob(rand.Next(1000)));
			}

			Req.Settings=settings;
		}

		public void AddAchievements(int count)
		{
            ProgressWS.ResetUserAchievements(User);
			AchievementWD[] lalist = new AchievementWD[count];
			DateTime now = DateTime.UtcNow;
			for( int i=0;i<lalist.Length;i++)
			{
				DateTime time =now.AddHours(-1*i);
				uint id =(uint)(i+1);
				lalist[i] = new AchievementWD(id,(uint)i+1);
				Achievements.AddAchievementsToVerify(User,Title,lalist[i]);
			}
			Req.Achievements=lalist;
		}

		public void VerifySyncAll(SyncAllResponse resp, int excpetedachievements,int Expectedtitles)
		{
			setting.verifySettings(settings,resp.Settings.Settings,resp.Settings.SettingsLen);

			uint[] _titles = new uint[Expectedtitles]; 
			for(int i=0;i<Expectedtitles;i++)
				_titles[i]=(uint)(titles.titlebase+i);
			titles.verifysync(resp.Titles,_titles,User,Locale);
			uint[] Achieved = new uint[excpetedachievements];
			for(int i=0;i<excpetedachievements;i++)
			{
				Achieved[i]=(uint)(i+1);
			}
			Achievements.verifySync(User,Title,resp.Achievements,Achieved);
		}

		public void VerifyAll()
		{
			// verify Settings.
			setting.Title=Title;
			setting.Userid=User;
			setting.verifyByReading(settings);
			//verify Titles
			titles.verifybyEnum(User);
			//verify Achievements
			XRLEnumAchievement req= new XRLEnumAchievement (Title,User,User,Locale,0,AchievConst.MAX_Achievement);
			AchievementEnumResponse enumresp =req.Execute();
			Achievements.verifyEnum(User,Title,Locale,false,enumresp);
			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\EnumTitles.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;


namespace GamerSettings
{
    /// <summary>
    /// Summary description for EnumTitles.
    /// </summary>
    public class EnumTitles : TestNode
    {
        public static ulong Owner = 0;
        public static ulong friend = 0;
        public static ulong nonfriend = 0;
        public static ulong OwnerInvUser = 0;
        public static ulong UserInvOwner = 0;
        public static ulong PaginationTesterId = 0;

        public EnumTitles()
        {
            AddChild(new EnumSP0NTitle10(501));
            AddChild(new EnumSP1NTitle10(501));
            AddChild(new EnumSP8NTitle10(501));
            AddChild(new EnumSP9NTitle10(501));
            AddChild(new EnumSP5NTitle5(501));
            AddChild(new EnumSP10NTitle1(501));
            AddChild(new EnumSP1NTitle9(501));
            AddChild(new EnumSP1NTitleMax(502));
            AddChild(new EnumSP1NTitleMaxXboxCom(509));
            AddChild(new EnumSP1NTitleMax_1(502));
            AddChild(new EnumDemoTitles(505));
            AddChild(new EnumTestDupe32ndTitle_73799(PaginationTesterId));

            AddChild(new InvalidEnumMaxPlus1(502));
            AddChild(new InvalidNonExistantUser());
            AddChild(new validNonExistantLocale(501));
            AddChild(new validLocalefrFR(501));
            AddChild(new EnumLocalInSGAuth(501));
            AddChild(new AcitivityNone());
            AddChild(new Acitivityfriends());
            AddChild(new Acitivityall());
            AddChild(new ReadActivityAll());
            AddChild(new ReadActivityfriends());
            AddChild(new ReadActivityNone());

            // SGAUTH
            AddChild(new SGAuthDiffTitle(501));
            AddChild(new SGAuthInvalidUser(501));

            AddChild(new TCInvalidSmallPKT());
            AddChild(new TCInvalidLargePKT());

            AddChild(new EnumTitleExtendedData());
            AddChild(new EnumTitleExtendedDataDefaults());
        }

        public override void PreRun()
        {
            FriendsCommon fc = new FriendsCommon();

            PNUser _Owner = fc.CreateUser(true);
            PNUser _OwnerInvUser = fc.CreateUser(true);
            PNUser _UserInvOwner = fc.CreateUser(true);
            PNUser _Friend = fc.CreateUser(true);
            PNUser _nonFriend = fc.CreateUser(true);

            try
            {
                fc.RequestFriend(_Owner, _OwnerInvUser);
                fc.RequestFriend(_UserInvOwner, _Owner);
                fc.MakeFriend(_Friend, _Owner);
            }
            catch (System.Exception e)
            {
                Global.RO.Warn("Some tests may fail due to presence issue : " + e);
            }

            Owner = _Owner.UserId;
            friend = _Friend.UserId;
            nonfriend = _nonFriend.UserId;
            OwnerInvUser = _OwnerInvUser.UserId;
            UserInvOwner = _UserInvOwner.UserId;

            //clean 

            // load 10 titles for Owner.
            EnumBase.UserstitlestoVerify.Clear();
            EnumBase.loadtitles(10, 501);

            //load 100 titles for nonfriend.
            EnumBase.loadtitles(32, 502);
            EnumBase.loadtitles(32, 509);
            EnumBase.loadtitles(10, Owner);

        }

        public class TCInvalidSmallPKT : TestNode
        {
            public override void Run()
            {

                InvalidXRLRequest tmp = new InvalidXRLRequest(10, "/xstats/enumtitles.ashx");
                uint xerror = tmp.Execute();
                if (xerror != HResult.XONLINE_E_END_OF_STREAM)
                    throw new Exception("Invalid Xerror Expected :" + HResult.E_FAIL + " received:" + xerror);
            }
        }

        public class TCInvalidLargePKT : TestNode
        {
            public override void Run()
            {

                InvalidXRLRequest tmp = new InvalidXRLRequest(1000 * 100, "/xstats/enumtitles.ashx");
                uint xerror = tmp.Execute();
                if (xerror != HResult.XONLINE_E_SERVER_ERROR && xerror != HResult.E_INVALIDARG)
                    throw new Exception("Invalid Xerror Expected :" + HResult.E_FAIL + " received:" + xerror);
            }
        }
    }

    public class SGAuthDiffTitle : EnumBase
    {
        public SGAuthDiffTitle(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            this.Modifyflag = AuthModify.Change_Title;
            startIdx = 1;
            count = 9;
            ExpectedCount = 9;
        }
    }

    public class SGAuthInvalidUser : EnumBase
    {
        public SGAuthInvalidUser(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            this.Modifyflag = AuthModify.Change_User;
            startIdx = 1;
            count = 9;
            ExpectedCount = 9;
            this.Xerror = HResult.XONLINE_E_SERVER_ERROR;
        }
    }

    [TestFrequency("Daily"), TestCasePriority(1), Description("Enum Titles with all Permissions")]
    public class Acitivityall : TitleBase
    {
        ulong Owner;
        ulong friend;
        ulong nonfriend;
        public Acitivityall()
        {
        }

        public override void Run()
        {
            Owner = EnumTitles.Owner;
            friend = EnumTitles.friend;
            nonfriend = EnumTitles.nonfriend;
            ProfileWS.ResetUserSetttings(Owner);

            // enum title owner.
            EnumBase enumowner0 = new EnumBase(Owner, Owner, 1, 5, HResult.S_OK);
            enumowner0.Run();
            // enum title friend
            EnumBase enumowner1 = new EnumBase(friend, Owner, 1, 5, HResult.S_OK);
            enumowner1.Run();

            // enum title nonfirend.
            EnumBase enumowner2 = new EnumBase(nonfriend, Owner, 1, 5, HResult.S_OK);
            enumowner2.Run();
        }
    }

    //ReadActivityAll
    public class ReadActivityAll : TitleBase
    {
        ulong Owner;
        ulong friend;
        ulong nonfriend;
        public ReadActivityAll()
        {
        }

        public override void Run()
        {
            Owner = EnumTitles.Owner;
            friend = EnumTitles.friend;
            nonfriend = EnumTitles.nonfriend;
            ProfileWS.ResetUserSetttings(Owner);

            // enum title owner.
            EnumBase enumowner0 = new EnumBase(Owner, Owner, 1, 5, HResult.S_OK);
            enumowner0.Modifyflag = AuthModify.Read_Activity_All;
            enumowner0.Run();

            // enum one way friend
            EnumBase enumowner3 = new EnumBase(EnumTitles.OwnerInvUser, Owner, 1, 5, HResult.S_OK);
            enumowner3.Modifyflag = AuthModify.Read_Activity_All;
            enumowner3.Run();

            // enum title friend
            EnumBase enumowner1 = new EnumBase(friend, Owner, 1, 5, HResult.S_OK);
            enumowner1.Modifyflag = AuthModify.Read_Activity_All;
            enumowner1.Run();

            // enum one way  nonfirend.
            EnumBase enumowner4 = new EnumBase(EnumTitles.UserInvOwner, Owner, 1, 5, HResult.S_OK);
            enumowner4.Modifyflag = AuthModify.Read_Activity_All;
            enumowner4.Run();

            // enum title nonfirend.
            EnumBase enumowner2 = new EnumBase(nonfriend, Owner, 1, 5, HResult.S_OK);
            enumowner2.Modifyflag = AuthModify.Read_Activity_All;
            enumowner2.Run();
        }
    }

    public class ReadActivityfriends : TitleBase
    {
        ulong Owner;
        ulong friend;
        ulong nonfriend;
        public ReadActivityfriends()
        {
        }

        public override void Run()
        {
            Owner = EnumTitles.Owner;
            friend = EnumTitles.friend;
            nonfriend = EnumTitles.nonfriend;
            ProfileWS.ResetUserSetttings(Owner);


            // enum title owner.
            EnumBase enumowner0 = new EnumBase(Owner, Owner, 1, 5, HResult.S_OK);
            enumowner0.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            enumowner0.Run();

            // enum one way friend
            EnumBase enumowner3 = new EnumBase(EnumTitles.OwnerInvUser, Owner, 1, 5, HResult.S_OK);
            enumowner3.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            enumowner3.Run();

            // enum title friend
            EnumBase enumowner1 = new EnumBase(friend, Owner, 1, 5, HResult.S_OK);
            enumowner1.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            enumowner1.Run();

            // enum one way  nonfirend.
            EnumBase enumowner4 = new EnumBase(EnumTitles.UserInvOwner, Owner, 1, 5, HResult.XONLINE_E_STAT_PERMISSION_DENIED);
            enumowner4.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            enumowner4.Run();

            // enum title nonfirend.
            EnumBase enumowner2 = new EnumBase(nonfriend, Owner, 1, 5, HResult.XONLINE_E_STAT_PERMISSION_DENIED);
            enumowner2.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            enumowner2.Run();
        }

    }

    public class ReadActivityNone : TitleBase
    {
        ulong Owner;
        ulong friend;
        ulong nonfriend;
        public ReadActivityNone()
        {
        }

        public override void Run()
        {
            Owner = EnumTitles.Owner;
            friend = EnumTitles.friend;
            nonfriend = EnumTitles.nonfriend;
            ProfileWS.ResetUserSetttings(Owner);
            // add setting Activity none for owner.

            // enum title owner.
            EnumBase enumowner0 = new EnumBase(Owner, Owner, 1, 5, HResult.S_OK);
            enumowner0.Modifyflag = AuthModify.Read_Activity_None;
            enumowner0.Run();

            // enum title friend
            EnumBase enumowner1 = new EnumBase(friend, Owner, 1, 5, HResult.XONLINE_E_STAT_PERMISSION_DENIED);
            enumowner1.Modifyflag = AuthModify.Read_Activity_None;
            enumowner1.Run();

            // enum title nonfirend.
            EnumBase enumowner2 = new EnumBase(nonfriend, Owner, 1, 5, HResult.XONLINE_E_STAT_PERMISSION_DENIED);
            enumowner2.Modifyflag = AuthModify.Read_Activity_None;
            enumowner2.Run();
        }
    }

    public class Acitivityfriends : TitleBase
    {
        ulong Owner;
        ulong friend;
        ulong nonfriend;
        public Acitivityfriends()
        {
        }

        public override void Run()
        {
            Owner = EnumTitles.Owner;
            friend = EnumTitles.friend;
            nonfriend = EnumTitles.nonfriend;
            // add setting Activity none for owner.
            ProfileWS.ResetUserSetttings(Owner);
            PermissionBase.init(Owner, friend, nonfriend);
            PermissionBase permission = new PermissionBase(51);
            permission.addPermission(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);

            // enum title owner.
            EnumBase enumowner0 = new EnumBase(Owner, Owner, 1, 5, HResult.S_OK);
            enumowner0.Run();

            //enumtitle for one way friend 
            EnumBase enumowner3 = new EnumBase(EnumTitles.OwnerInvUser, Owner, 1, 5, HResult.S_OK);
            enumowner3.Run();

            // enum title friend
            EnumBase enumowner1 = new EnumBase(friend, Owner, 1, 5, HResult.S_OK);
            enumowner1.Run();

            // enum title nonfriend.
            EnumBase enumowner4 = new EnumBase(EnumTitles.UserInvOwner, Owner, 1, 5, HResult.XONLINE_E_STAT_PERMISSION_DENIED);
            enumowner4.Run();

            // enum title nonfriend.
            EnumBase enumowner2 = new EnumBase(nonfriend, Owner, 1, 5, HResult.XONLINE_E_STAT_PERMISSION_DENIED);
            enumowner2.Run();
        }

    }

    public class AcitivityNone : TitleBase
    {
        ulong Owner;
        ulong friend;
        ulong nonfriend;
        public AcitivityNone()
        {

        }

        public override void Run()
        {
            Owner = EnumTitles.Owner;
            friend = EnumTitles.friend;
            nonfriend = EnumTitles.nonfriend;

            // add setting Activity none for owner.
            ProfileWS.ResetUserSetttings(Owner);
            PermissionBase.init(Owner, friend, nonfriend);
            PermissionBase permission = new PermissionBase(51);
            permission.addPermission(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE);

            // enum title owner.
            EnumBase enumowner0 = new EnumBase(Owner, Owner, 1, 5, HResult.S_OK);
            enumowner0.Run();
            // enum title friend
            EnumBase enumowner1 = new EnumBase(friend, Owner, 1, 5, HResult.XONLINE_E_STAT_PERMISSION_DENIED);
            enumowner1.Run();

            // enum title nonfirend.
            EnumBase enumowner2 = new EnumBase(nonfriend, Owner, 1, 5, HResult.XONLINE_E_STAT_PERMISSION_DENIED);
            enumowner2.Run();
        }

    }

    //EnumLocalInSGAuth

    public class EnumLocalInSGAuth : EnumBase
    {
        public EnumLocalInSGAuth(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 1;
            count = 32;
            ExpectedCount = 9;
            locale = 0;
            Modifyflag = AuthModify.AddLocale;
            verifylocale = 1036;
        }
    }

    //validLocalefrFR
    public class validLocalefrFR : EnumBase
    {
        public validLocalefrFR(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 1;
            count = 32;
            ExpectedCount = 9;
            locale = 1036;
            verifylocale = 1036;
        }
    }

    public class validNonExistantLocale : EnumBase
    {
        public validNonExistantLocale(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 1;
            count = 32;
            ExpectedCount = 9;
            locale = 1041;
        }
    }

    public class InvalidNonExistantUser : EnumBase
    {
        public InvalidNonExistantUser()
            : base(21, 21)
        { }

        protected override void init()
        {
            startIdx = 1;
            count = 10;
            ExpectedCount = 0;
            Xerror = HResult.S_OK;
        }
    }

    public class InvalidEnumMaxPlus1 : EnumBase
    {
        public InvalidEnumMaxPlus1(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 0;
            count = 33;
            ExpectedCount = 32;
        }
    }

    public class EnumSP1NTitleMax_1 : EnumBase
    {
        public EnumSP1NTitleMax_1(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 0;
            count = 31;
            ExpectedCount = 31;
        }
    }
    //EnumSP1NTitleMaxXboxCom
    public class EnumSP1NTitleMaxXboxCom : EnumBase
    {
        public EnumSP1NTitleMaxXboxCom(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 0;
            count = 100;
            ExpectedCount = 37;

            Random rd = new Random();
            UserTitle[] utitles = new UserTitle[5];
            DateTime now = DateTime.UtcNow;

            for (int i = 0; i < 5; i++)
            {
                DateTime time = now.AddHours((-1 * (90 - 33)));
                utitles[i] = new UserTitle((uint)(TITLEBASE + 32 + i), time, (uint)rd.Next(), (ushort)rd.Next(), (uint)(33 + 1));
                AddUsersTitlesToVerify(user, utitles[i]);
            }

            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();

            if (resp.XError != 0)
                throw new Exception("UnExpected Error " + resp.XError);

        }
        public override void run()
        {
            EnumTitlesRequest req = new EnumTitlesRequest(user, friend, startIdx, count, locale);
            if (Modifyflag != AuthModify.None)
            {
                req.Modifyflag = Modifyflag;
                if (verifylocale == 1036)
                    req.LanguageID = (uint)Languageids.fr;
            }
            EnumTitlesResponse resp = req.ExecuteINT();

            if (Xerror != resp.XError)
                throw new Exception("UnExpected HResult excepted =" + Xerror + "Received" + resp.XError);

            if (HResult.Failed(Xerror))
                return;


            if (ExpectedCount != resp.TitlesLen)
                throw new Exception("Number of titles returned are different excepted =" + ExpectedCount + "Received" + resp.TitlesLen);


            if (resp.XError == HResult.S_OK && ExpectedCount != 0)
            {
                if (UserstitlestoVerify.ContainsKey(friend))
                {
                    UsersTitles tmp = (UsersTitles)UserstitlestoVerify[friend];
                    ArrayList ExpectedResults = tmp.getTitles();

                    for (int i = 0; i < resp.TitlesLen; i++)
                    {
                        UserTitle received = resp.Titles[i];
                        UserTitle expected = (UserTitle)ExpectedResults[startIdx + i];

                        string titlename = gconfig.GetTitleName(received.TitleId, verifylocale);
                        if (titlename != received.TitleName)
                            throw new Exception("Invalid Name excepted =" + titlename + "Received" + received.TitleName);
                        if (expected.LastPlayed.ToString() != received.LastPlayed.ToString())
                            throw new Exception("Invalid LastPlayed excepted =" + expected.LastPlayed + "Received" + received.LastPlayed);
                        if (expected.Sequence != received.Sequence)
                            throw new Exception("Invalid Sequence excepted =" + expected.Sequence + "Received" + received.Sequence);
                    }
                }
                else
                    throw new Exception("Unexpecte user " + friend);
            }
            else if (resp.XError != HResult.S_OK)
                throw new Exception("UnExpected Error " + resp.XError);

        }
    }

    public class EnumSP1NTitleMax : EnumBase
    {
        public EnumSP1NTitleMax(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 0;
            count = 32;
            ExpectedCount = 32;
        }
    }

    public class EnumSP1NTitle9 : EnumBase
    {
        public EnumSP1NTitle9(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 1;
            count = 9;
            ExpectedCount = 9;
        }
    }

    public class EnumSP10NTitle1 : EnumBase
    {
        public EnumSP10NTitle1(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 9;
            count = 1;
            ExpectedCount = 1;
        }
    }

    public class EnumSP1NTitle0 : EnumBase
    {
        public EnumSP1NTitle0(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 1;
            count = 0;
            ExpectedCount = 0;
        }
    }

    public class EnumSP5NTitle5 : EnumBase
    {
        public EnumSP5NTitle5(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 5;
            count = 5;
            ExpectedCount = 5;
        }
    }

    public class EnumSP8NTitle10 : EnumBase
    {
        public EnumSP8NTitle10(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 8;
            count = 10;
            ExpectedCount = 2;
        }
    }

    public class EnumSP9NTitle10 : EnumBase
    {
        public EnumSP9NTitle10(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 9;
            count = 10;
            ExpectedCount = 1;
        }
    }

    //EnumDemoTitles
    public class EnumDemoTitles : EnumBase
    {
        public EnumDemoTitles(ulong _user) : base(_user, _user) { }

        protected override void init()
        {
            EnumBase.loadtitles(5, 505);
            ProgressWS.SetLastTitleToDemoTitle(505, (int)(TITLEBASE + 1));
            startIdx = 1;
            count = 5;
            ExpectedCount = 3;
        }

        public override void run()
        {
            EnumTitlesRequest req = new EnumTitlesRequest(user, friend, startIdx, count, locale);
            if (Modifyflag != AuthModify.None)
                req.Modifyflag = Modifyflag;
            EnumTitlesResponse resp = req.Execute();

            if (Xerror != resp.XError)
                throw new Exception("UnExpected HResult excepted =" + Xerror + "Received" + resp.XError);

            if (HResult.Failed(Xerror))
                return;

            if (ExpectedCount != resp.TitlesLen)
                throw new Exception("Number of titles returned are different excepted =" + ExpectedCount + "Received" + resp.TitlesLen);


            if (resp.XError == HResult.S_OK && ExpectedCount != 0)
            {
                if (UserstitlestoVerify.ContainsKey(friend))
                {
                    UsersTitles tmp = (UsersTitles)UserstitlestoVerify[friend];
                    ArrayList ExpectedResults = tmp.getTitles();
                    ExpectedResults.RemoveAt(3);
                    for (int i = 0; i < resp.TitlesLen; i++)
                    {
                        UserTitle received = resp.Titles[i];
                        UserTitle expected = (UserTitle)ExpectedResults[startIdx + i];

                        //if(expected.TitleName!=received.TitleName)
                        //	throw new Exception("Invalid Name excepted ="+expected.TitleName+"Received"+received.TitleName);
                        if (expected.LastPlayed.ToString() != received.LastPlayed.ToString())
                            throw new Exception("Invalid LastPlayed excepted =" + expected.LastPlayed + "Received" + received.LastPlayed);
                        if (expected.Sequence != received.Sequence)
                            throw new Exception("Invalid Sequence excepted =" + expected.Sequence + "Received" + received.Sequence);
                        /*
                        uint TotaltitleCread= gconfig.GetTotalCread(received.TitleId);
                        if(TotaltitleCread!=received.TotalCred)
                            throw new Exception("Invalid TotalCred excepted ="+TotaltitleCread+"Received"+received.TotalCred);
                        if(expected.NumCreds!=received.NumCreds)
                            throw new Exception("Invalid NumCreds excepted ="+expected.NumCreds+"Received"+received.NumCreds);
                        if(expected.NumAchievements!=received.NumAchievements)
                            throw new Exception("Invalid NumAchievements excepted ="+expected.NumAchievements+"Received"+received.NumAchievements);
                        ushort TAchiements= gconfig.GetTotalAchievements(received.TitleId);
                        if(TAchiements!=received.TotalAchievements)
                            throw new Exception("Invalid TotalAchievements excepted ="+TAchiements+"Received"+received.TotalAchievements);
                            */
                    }

                }
                else
                    throw new Exception("Unexpecte user " + friend);
            }
            else if (resp.XError != HResult.S_OK)
                throw new Exception("UnExpected Error " + resp.XError);
        }
    }

    public class EnumTestDupe32ndTitle_73799 : EnumBase
    {
        public EnumTestDupe32ndTitle_73799(ulong _user) : base(_user, _user) { }

        protected override void init()
        {
            startIdx = 1;
            count = 32;
            ExpectedCount = 32;
        }
        public override void Run()
        {
            //load 40 titles for user 510.  Note there is a magic number limit--32 max
            //in both a sync and enum.
            bool success = true;
            FriendsCommon fc = new FriendsCommon();
            PNUser paginationTester = fc.CreateUser(true);
            ulong paginationTesterId = paginationTester.UserId;
            EnumBase.loadtitles(40, paginationTesterId);
            Global.RO.Info("Using ID " + paginationTesterId);
            //                        fc.LogonUser(paginationTester);
            //                        fc.LogoffUser(paginationTester);

            //make sure we log in user # 510.  Sync him up with just the dash.
            /*
                        UserTitle[] utitles = new UserTitle[1];
                        Random rd= new Random();
                        DateTime time = DateTime.UtcNow.AddHours((-1*(90-(50))));
                        utitles[0]= new UserTitle(0xfffe07d1,time,(uint)rd.Next(),(ushort)rd.Next(), (uint)0);
            
                        SyncTitlesRequest syncReq= new SyncTitlesRequest(user,DateTime.UtcNow,utitles);
                        SyncTitlesResponse syncResp= syncReq.Execute();
            */
            Global.RO.Info("Using user " + paginationTesterId);
            user = paginationTesterId;
            friend = user;
            count = 32;
            EnumTitlesRequest req = new EnumTitlesRequest(user, friend, startIdx, count, locale);
            req.MaxTitles = 32;
            Hashtable titlesFound = new Hashtable();
            EnumTitlesResponse resp = req.Execute();
            for (int i = 0; i < resp.TitlesLen; i++)
            {
                UserTitle received = resp.Titles[i];
                Global.RO.Info("Found titleid:" + received.TitleId + ".  Name:" + received.TitleName);
                if (titlesFound[received.TitleId] != null)
                {
                    //we found a duplicate!  badness.
                    Global.RO.Error("Found a duplicate titleid! " + received.TitleId);
                    success = false;
                }
                else
                {
                    titlesFound[received.TitleId] = 1;
                }
            }

            Global.RO.Info("Reading second set:  there should be no duplicates.");
            startIdx = 32;
            count = 32;
            req = new EnumTitlesRequest(user, friend, startIdx, count, locale);
            req.MaxTitles = 32;

            resp = req.Execute();
            for (int i = 0; i < resp.TitlesLen; i++)
            {
                UserTitle received = resp.Titles[i];
                Global.RO.Info("Found titleid:" + received.TitleId + "...Name:" + received.TitleName);
                if (titlesFound[received.TitleId] != null)
                {
                    //we found a duplicate!  badness.
                    Global.RO.Error("Found a duplicate titleid! " + received.TitleId);
                    success = false;
                }
                else
                {
                    titlesFound[received.TitleId] = 1;
                }
            }
            if (!success)
                throw new TestSuiteException("EnumTestDupe32ndTitle_73799 failed");
        }
    }


    public class EnumSP1NTitle10 : EnumBase
    {
        public EnumSP1NTitle10(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 1;
            count = 10;
            ExpectedCount = 9;
        }
    }

    public class EnumSP0NTitle10 : EnumBase
    {
        public EnumSP0NTitle10(ulong _user)
            : base(_user, _user)
        { }

        protected override void init()
        {
            startIdx = 0;
            count = 10;
            ExpectedCount = 10;
        }
    }

    public class EnumTitleExtendedData : TitleBase
    {
        ulong _user = 0;

        public EnumTitleExtendedData()
        {
            _user = 501;
        }

        // FROM XON.CS

        // Title Types
        //public const uint TITLE_TYPE_SYSTEM = 0;
        //public const uint TITLE_TYPE_STANDARD = 1;
        //public const uint TITLE_TYPE_DEMO = 2;
        //public const uint TITLE_TYPE_ARCADE = 3;
        //public const uint TITLE_TYPE_APPLICATION = 5;

        // Platform Types
        //public const byte XPLT_XBOX1 = 0;
        //public const byte XPLT_XBOX360 = 1;
        //public const byte XPLT_PC = 2;
        //public const byte XPLT_INTERNAL = 3;
        //public const byte XPLT_WEB = 4;
        //public const byte XPLT_INTERNAL_XBOXCOM = 5;
        //public const byte XPLT_INTERNAL_ZUNE = 6;
        //public const byte XPLT_INTERNAL_XNA = 7;
        //public const byte XPLT_INTERNAL_WGX = 8;
        //public const byte XPLT_ZUNEV1 = 9;
        //public const byte XPLT_ZUNEV2 = 10;
        //public const byte XPLT_MEDIA_CENTER = 11;
        //public const byte XPLT_ZUNEV3 = 12;
        //public const byte XPLT_ZUNE_MOBILE = 13;
        //public const byte XPLT_INTERNAL_LIVEN = 14;
        //public const byte XPLT_MOBILE = 15;
        //public const byte XPLT_WEB_GAMES = 16;
        //public const byte XPLT_INVALID = 255;

        public override void Run()
        {
            // Clear this user's existing titles
            ResetUsertitles(_user);

            DateTime syncTime = DateTime.Now.AddHours(-1);

            UserTitle[] titlesToSync = new UserTitle[4];
            titlesToSync[0] = CreateTitle(210, syncTime, 4, (byte)XOn.TITLE_TYPE_SYSTEM, new uint[] { XOn.XPLT_XBOX360 }); // Type: 0, Platform: Xbox 360
            titlesToSync[1] = CreateTitle(211, syncTime, 3, (byte)XOn.TITLE_TYPE_STANDARD, new uint[] { XOn.XPLT_XBOX360 }); // Type: 1, Platform: Xbox 360
            titlesToSync[2] = CreateTitle(212, syncTime, 2, (byte)XOn.TITLE_TYPE_DEMO, new uint[] { XOn.XPLT_XBOX360, XOn.XPLT_PC }); // Type: 2, Platform: Xbox 360, PC
            // codyluit: You can only sync titles for the platform you are on, which is xbox360 in this case
            //titlesToSync[3] = CreateTitle(213, syncTime, 1, (byte)XOn.TITLE_TYPE_ARCADE, new uint[] { XOn.XPLT_MOBILE, XOn.XPLT_WEB_GAMES }); // Type: 3, Platform: Mobile, Web
            titlesToSync[3] = CreateTitle(214, syncTime, 0, (byte)XOn.TITLE_TYPE_APPLICATION, new uint[] { XOn.XPLT_XBOX360, XOn.XPLT_PC, XOn.XPLT_MOBILE, XOn.XPLT_WEB_GAMES }); // Type: 5, Platform: Xbox 360, PC, Mobile, WebGames

            SyncTitlesRequest syncRequest = new SyncTitlesRequest(_user, syncTime, titlesToSync);
            SyncTitlesResponse syncResponse = syncRequest.Execute();

            EnumTitlesRequest request = new EnumTitlesRequest(_user, _user, 0, 32);
            EnumTitlesResponse response = request.Execute();

            if(response.Titles.Length != titlesToSync.Length)
                throw new Exception(String.Format("Did not receive the number of titles expected. Expected: {0}, Actual: {1}", titlesToSync.Length, response.Titles.Length));

            for (int i = 0; i < titlesToSync.Length; ++i)
            {
                VerifyExtendedData(response.Titles[i], titlesToSync[i]);
            }
        }

        private UserTitle CreateTitle(uint titleId, DateTime lastPlayed, uint sequence, byte titleType, uint[] platforms)
        {
            UserTitle title = new UserTitle(titleId, lastPlayed, 0, 0, sequence);

            // Set flag so we know it has extended data
            title.HasExtendedData = 1;

            // Set title type
            title.TitleType = titleType;

            // Calculate platform flags and apply
            foreach (uint platform in platforms)
            {
                title.SetPlatformFlag(platform, true);
            }

            return title;
        }

        private void VerifyExtendedData(UserTitle actualTitle, UserTitle expectedTitle)
        {
            Global.RO.Info("Validating TitleId: " + actualTitle.TitleId);

            // Verify title ids match (ordering is correct)
            if (actualTitle.TitleId != expectedTitle.TitleId)
                throw new Exception(String.Format("TitleIds do not match. Expected: {0}, Actual: {1}", expectedTitle.TitleId, actualTitle.TitleId));

            // Verify the 3 new fields
            if (actualTitle.HasExtendedData != expectedTitle.HasExtendedData)
                throw new Exception(String.Format("Title {0} did not have expected HasExtendedData. Expected: {1}, Actual: {2}", actualTitle.TitleId, expectedTitle.HasExtendedData, actualTitle.HasExtendedData));
            if (actualTitle.TitleType != expectedTitle.TitleType)
                throw new Exception(String.Format("Title {0} did not have expected TitleType. Expected: {1}, Actual: {2}", actualTitle.TitleId, expectedTitle.TitleType, actualTitle.TitleType));
            if (actualTitle.PlatformFlags != expectedTitle.PlatformFlags)
                throw new Exception(String.Format("Title {0} did not have expected PlatformFlags. Expected: {1}, Actual: {2}", actualTitle.TitleId, expectedTitle.PlatformFlags, actualTitle.PlatformFlags));
        }
    }

    public class EnumTitleExtendedDataDefaults : TitleBase
    {
        ulong _user = 0;
        uint _titleId = 50; // Title 50 has no platform or titletype set so it will get the defaults (Standard 360 title)

        public EnumTitleExtendedDataDefaults()
        {
            _user = 501;
        }

        public override void Run()
        {
            // Clear this user's existing titles
            ResetUsertitles(_user);

            DateTime syncTime = DateTime.Now.AddHours(-1);

            UserTitleProfile userProfile = new UserTitleProfile(_user);
            SyncTitlesResponse resp = playtitle(_titleId, starttime, userProfile, true);
            verifysync(resp, null, _user, 1033);

            EnumTitlesRequest request = new EnumTitlesRequest(_user, _user, 0, 32);
            EnumTitlesResponse response = request.Execute();

            if (response.Titles.Length != 1)
                throw new Exception(String.Format("Did not receive the number of titles expected. Expected: {0}, Actual: {1}", 1, response.Titles.Length));

            // Verify title ids match (ordering is correct)
            if (_titleId != response.Titles[0].TitleId)
                throw new Exception(String.Format("TitleIds do not match. Expected: {0}, Actual: {1}", _titleId, response.Titles[0].TitleId));

            // Verify the 3 new fields
            if (1 != response.Titles[0].HasExtendedData)
                throw new Exception(String.Format("Title {0} did not have expected HasExtendedData. Expected: {1}, Actual: {2}", _titleId, 1, response.Titles[0].HasExtendedData));
            if ((byte)XOn.TITLE_TYPE_STANDARD != response.Titles[0].TitleType)
                throw new Exception(String.Format("Title {0} did not have expected TitleType. Expected: {1}, Actual: {2}", _titleId, (byte)XOn.TITLE_TYPE_STANDARD, response.Titles[0].TitleType));
            if (2 != response.Titles[0].PlatformFlags) // 2 is 360
                throw new Exception(String.Format("Title {0} did not have expected PlatformFlags. Expected: {1}, Actual: {2}", _titleId, 2, response.Titles[0].PlatformFlags));
        }
    }

    public class EnumBase : TestNode
    {
        public static GameConfig gconfig;
        public static uint TITLEBASE = 50;
        public static Hashtable UserstitlestoVerify = new Hashtable();
        public AuthModify Modifyflag = AuthModify.None;

        protected ulong user = 0;
        protected ulong friend = 0;
        protected ushort startIdx = 0;
        protected ushort count = 0;
        protected uint ExpectedCount = 0;
        protected uint Xerror = 0;
        protected ushort locale = 1033;  //en-us
        protected ushort verifylocale = 1033;  //en-us
        protected ushort DefaultLocale = 1033; //en-us


        public EnumBase(ulong _user, ulong _friend)
        {
            user = _user;
            friend = _friend;
        }

        public EnumBase(ulong _user, ulong _friend, ushort start, ushort size, uint error)
        {
            user = _user;
            friend = _friend;
            startIdx = start;
            ExpectedCount = count = size;
            Xerror = error;
        }
        protected virtual void init()
        {
        }

        public static void AddUsersTitlesToVerify(ulong user, UserTitle title)
        {
            if (UserstitlestoVerify.Contains(user))
            {
                UsersTitles tmp = (UsersTitles)UserstitlestoVerify[user];
                tmp.AddTitle(title);
            }
            else
            {
                UsersTitles tmp = new UsersTitles(user);
                tmp.AddTitle(title);
                UserstitlestoVerify.Add(user, tmp);
            }

        }

        public static void loadtitles(int count, ulong user)
        {
            ProgressWS.ResetUsertitles(user);
            if (count > 32)
            { //there's a client limit--32 sync/enums at once.  Split
                //to multiple requests, if necessary.
                int numFullLoops = (int)(count / 32);
                int numTitlesInLastLoop = (count % 32);
                for (int i = 0; i < numFullLoops; i++)
                {
                    AddTitlesToUser(i * 32, 32, user);
                }
                AddTitlesToUser(numFullLoops * 32, numTitlesInLastLoop, user);
            }
            else
            {
                AddTitlesToUser(0, count, user);
            }
        }

        //here, offset modifies which title number the inserts will begin at.  the time and 
        public static void AddTitlesToUser(int offset, int numTitles, ulong user)
        {
            Random rd = new Random();
            UserTitle[] utitles = new UserTitle[numTitles];
            DateTime now = DateTime.UtcNow;
            for (int i = 0; i < numTitles; i++)
            {
                DateTime time = now.AddHours((-1 * (90 - (i + offset))));
                utitles[i] = new UserTitle((uint)(TITLEBASE + offset + i), time, (uint)rd.Next(), (ushort)rd.Next(), (uint)i + 1);
                AddUsersTitlesToVerify(user, utitles[i]);

            }

            SyncTitlesRequest req = new SyncTitlesRequest(user, DateTime.UtcNow, utitles);
            SyncTitlesResponse resp = req.Execute();

            if (resp.XError != 0)
                throw new Exception("Unexpected Error " + resp.XError);
        }

        public override void Run()
        {
            init();
            run();
        }

        public virtual void run()
        {
            EnumTitlesRequest req = new EnumTitlesRequest(user, friend, startIdx, count, locale);
            if (Modifyflag != AuthModify.None)
            {
                req.Modifyflag = Modifyflag;
                if (verifylocale == 1036)
                    req.LanguageID = (uint)Languageids.fr;
            }
            EnumTitlesResponse resp = req.Execute();

            if (Xerror != resp.XError)
                throw new Exception("UnExpected HResult excepted =" + Xerror + "Received" + resp.XError);

            if (HResult.Failed(Xerror))
                return;


            if (ExpectedCount != resp.TitlesLen)
                throw new Exception("Number of titles returned are different excepted =" + ExpectedCount + "Received" + resp.TitlesLen);


            if (resp.XError == HResult.S_OK && ExpectedCount != 0)
            {
                if (UserstitlestoVerify.ContainsKey(friend))
                {
                    UsersTitles tmp = (UsersTitles)UserstitlestoVerify[friend];
                    ArrayList ExpectedResults = tmp.getTitles();

                    for (int i = 0; i < resp.TitlesLen; i++)
                    {
                        UserTitle received = resp.Titles[i];
                        UserTitle expected = (UserTitle)ExpectedResults[startIdx + i];

                        string titlename = gconfig.GetTitleName(received.TitleId, verifylocale);
                        if (titlename != received.TitleName)
                            throw new Exception("Invalid Name excepted =" + titlename + "Received" + received.TitleName);
                        if (expected.LastPlayed.ToString() != received.LastPlayed.ToString())
                            throw new Exception("Invalid LastPlayed excepted =" + expected.LastPlayed + "Received" + received.LastPlayed);
                        if (expected.Sequence != received.Sequence)
                            throw new Exception("Invalid Sequence excepted =" + expected.Sequence + "Received" + received.Sequence);

                        /*	uint TotaltitleCread= gconfig.GetTotalCread(received.TitleId);
                            if(TotaltitleCread!=received.TotalCred)
                                throw new Exception("Invalid TotalCred excepted ="+TotaltitleCread+"Received"+received.TotalCred);
                            if(expected.Sequence!=received.Sequence)
                                throw new Exception("Invalid Sequence excepted ="+expected.Sequence+"Received"+received.Sequence);
                            if(expected.NumCreds!=received.NumCreds)
                                throw new Exception("Invalid NumCreds excepted ="+expected.NumCreds+"Received"+received.NumCreds);
                            if(expected.NumAchievements!=received.NumAchievements)
                                throw new Exception("Invalid NumAchievements excepted ="+expected.NumAchievements+"Received"+received.NumAchievements);
                            ushort TAchiements= gconfig.GetTotalAchievements(received.TitleId);
                            if(TAchiements!=received.TotalAchievements)
                                    throw new Exception("Invalid TotalAchievements excepted ="+TAchiements+"Received"+received.TotalAchievements);
                                    */
                    }
                }
                else
                    throw new Exception("Unexpecte user " + friend);
            }
            else if (resp.XError != HResult.S_OK)
                throw new Exception("UnExpected Error " + resp.XError);

        }
    }

    public class UsersTitles
    {
        ulong puid = 0;
        ArrayList _titles = new ArrayList();
        public UsersTitles(ulong user)
        {
            puid = user;
        }
        public void AddTitle(UserTitle _title)
        {
            _titles.Add(_title);
        }
        public ArrayList getTitles()
        {
            _titles.Sort();
            return _titles;

        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\Permission.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace GamerSettings
{
    /// <summary>
    /// Summary description for Permission.
    /// </summary>
    public class Permission : TestNode
    {
        ulong Owner = 0;
        ulong friend = 0;
        ulong nonfriend = 0;
        public static ulong OwnerInvUser = 0;
        public static ulong UserInvOwner = 0;
        public static ulong friend1 = 0;
        public static ulong friend2 = 0;
        public static ulong friend3 = 0;


        public Permission()
        {
            AddChild(new Activity_none((uint)Titles.Global));
            AddChild(new Activity_friends((uint)Titles.Global));
            AddChild(new Activity_friendslist((uint)Titles.Global));
            AddChild(new Activity_friendslist2((uint)Titles.Global));
            AddChild(new Activity_all((uint)Titles.Global));

            AddChild(new UCC_all((uint)Titles.Global));
            AddChild(new UCC_friends((uint)Titles.Global));
            AddChild(new UCC_friendsList((uint)Titles.Global));
            AddChild(new UCC_friendsList2((uint)Titles.Global));
            AddChild(new UCC_none((uint)Titles.Global));
            AddChild(new UCC_none_bug116640((uint)Titles.Global));

            AddChild(new ConsoleRo((uint)Titles.Global));
            AddChild(new MultiSettingWithOneConsoleRo((uint)Titles.Global));
            AddChild(new WebRo((uint)Titles.PosTitle1));
            AddChild(new TitleRo((uint)Titles.PosTitle1));
            AddChild(new SETTING_ENFORCE_FRIENDS_ONLY((uint)Titles.PosTitle1));

            AddChild(new Not_Shared((uint)Titles.Global));

            AddChild(new ReadActivity_All((uint)Titles.Global));
            AddChild(new ReadActivity_friends((uint)Titles.Global));
            AddChild(new ReadActivity_friendsList((uint)Titles.Global));
            AddChild(new ReadActivity_friendsList2((uint)Titles.Global));
            AddChild(new ReadActivity_friendsList3((uint)Titles.Global));
            AddChild(new ReadActivity_friendsList4((uint)Titles.Global));
            AddChild(new ReadActivity_friendsList5((uint)Titles.Global));
            AddChild(new ReadActivity_friendsList6((uint)Titles.Global));
            AddChild(new ReadActivity_None((uint)Titles.Global));

            AddChild(new ReadUCC_All((uint)Titles.Global));
            AddChild(new ReadUCC_friends((uint)Titles.Global));
            //AddChild(new ReadUCC_friendslist((uint)Titles.Global));
            //AddChild(new ReadUCC_friendslist2((uint)Titles.Global));
            AddChild(new ReadUCC_None((uint)Titles.Global));

            // Transient Profile Setting Check
            // Permissions not enforced for this setting, so non friends pass
            AddChild(new ReadTransientSetting_FriendsOnly((uint)Titles.Global));

            // Permission tests for the XPROFILE_VIDEO_METADATA field
            AddChild(new ReadVideoMetadata_All((uint)Titles.Global));
            AddChild(new ReadVideoMetadata_Noone((uint)Titles.Global));
        }

        public override void PreRun()
        {
            FriendsCommon fc = new FriendsCommon();

            PNUser _Owner = fc.CreateUser(true);
            PNUser _Friend = fc.CreateUser(true);
            PNUser _OwnerInvUser = fc.CreateUser(true);
            PNUser _UserInvOwner = fc.CreateUser(true);
            PNUser _nonFriend = fc.CreateUser(true);
            PNUser _Friend1 = fc.CreateUser(true);
            PNUser _Friend2 = fc.CreateUser(true);
            PNUser _Friend3 = fc.CreateUser(true);

            try
            {
                fc.RequestFriend(_Owner, _OwnerInvUser);
                fc.RequestFriend(_UserInvOwner, _Owner);
                fc.MakeFriend(_Friend, _Owner);
                fc.MakeFriend(_Friend1, _Owner);
                fc.MakeFriend(_Friend2, _Owner);
                fc.MakeFriend(_Friend3, _Owner);
            }
            catch (System.Exception e)
            {
                Global.RO.Warn("Some tests may fail due to presence issue: " + e);
            }

            Owner = _Owner.UserId;
            friend = _Friend.UserId;
            nonfriend = _nonFriend.UserId;
            OwnerInvUser = _OwnerInvUser.UserId;
            UserInvOwner = _UserInvOwner.UserId;
            friend1 = _Friend1.UserId;
            friend2 = _Friend2.UserId;
            friend3 = _Friend3.UserId;

            //while(_Friend.IsBuddy(_Owner));
            //PermissionBase.ClearTSettings();
            PermissionBase.init(Owner, friend, nonfriend);
        }
    }

    public class ReadUCC_None : PermissionBase
    {
        public ReadUCC_None(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_UCC, 123456, SettingSource.XSOURCE_DEFAULT);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_UCC;

            //self
            Global.RO.Info("Redaing setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_UCC_None;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);

            // friend
            Global.RO.Info("Redaing setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            greq1.Modifyflag = AuthModify.Read_UCC_None;
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifyPermissionDenied(gresp1);

            // nonfriend
            Global.RO.Info("Redaing setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            greq2.Modifyflag = AuthModify.Read_UCC_None;
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyPermissionDenied(gresp2);
        }
    }

    //ReadActivity_All
    public class ReadUCC_All : PermissionBase
    {
        public ReadUCC_All(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_UCC, 123456, SettingSource.XSOURCE_DEFAULT);
        }

        protected override void run()
        {

            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_UCC;

            //self
            Global.RO.Info("Redaing setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_UCC_All;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);

            //oneway friend 
            Global.RO.Info("Redaing setting for friend");
            ReadSettingsRequest greq3 = new ReadSettingsRequest(Title, Permission.OwnerInvUser, friends, sIds);
            greq3.Modifyflag = AuthModify.Read_UCC_All;
            ReadSettingsResponse gresp3 = greq3.Execute();
            verifyXerror(gresp3);
            verifySettings(gresp3.Settings, (int)gresp3.SettingsLen);

            // friend
            Global.RO.Info("Redaing setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            greq1.Modifyflag = AuthModify.Read_UCC_All;
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifySettings(gresp1.Settings, (int)gresp1.SettingsLen);

            //oneway nonfriend 
            Global.RO.Info("Redaing setting for friend");
            ReadSettingsRequest greq4 = new ReadSettingsRequest(Title, Permission.UserInvOwner, friends, sIds);
            greq4.Modifyflag = AuthModify.Read_UCC_All;
            ReadSettingsResponse gresp4 = greq4.Execute();
            verifyXerror(gresp4);
            verifySettings(gresp4.Settings, (int)gresp4.SettingsLen);

            // nonfriend
            Global.RO.Info("Redaing setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            greq2.Modifyflag = AuthModify.Read_UCC_All;
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifySettings(gresp2.Settings, (int)gresp2.SettingsLen);
        }
    }

    public class ReadUCC_friends : PermissionBase
    {
        public ReadUCC_friends(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_UCC, 123456, SettingSource.XSOURCE_DEFAULT);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_UCC;

            //self
            Global.RO.Info("Redaing setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_UCC_Friends;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            Thread.Sleep(50);

            // friend
            Global.RO.Info("Redaing setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            greq1.Modifyflag = AuthModify.Read_UCC_Friends;
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifySettings(gresp1.Settings, (int)gresp1.SettingsLen);
            Thread.Sleep(50);

            //oneway friend 
            Global.RO.Info("Redaing setting for friend");
            ReadSettingsRequest greq3 = new ReadSettingsRequest(Title, Permission.OwnerInvUser, friends, sIds);
            greq3.Modifyflag = AuthModify.Read_UCC_Friends;
            ReadSettingsResponse gresp3 = greq3.Execute();
            verifyXerror(gresp3);
            verifySettings(gresp3.Settings, (int)gresp3.SettingsLen);
            Thread.Sleep(50);

            //oneway nonfriend 
            Global.RO.Info("Redaing setting for friend");
            ReadSettingsRequest greq4 = new ReadSettingsRequest(Title, Permission.UserInvOwner, friends, sIds);
            greq4.Modifyflag = AuthModify.Read_UCC_Friends;
            ReadSettingsResponse gresp4 = greq4.Execute();
            verifyXerror(gresp4);
            verifyPermissionDenied(gresp4);
            //verifySettings(gresp4.Settings,(int)gresp4.SettingsLen);
            Thread.Sleep(50);

            // nonfriend
            Global.RO.Info("Redaing setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            greq2.Modifyflag = AuthModify.Read_UCC_Friends;
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyPermissionDenied(gresp2);
        }
    }

    //Read new Profile Transient Setting
    //Using existing case logic for reading Activity Friends Only
    //Which should respect the Friends Only setting, Permissions for Transient settings
    //are open to all, unless Friends Only is set.
    [TestFrequency("Daily"), TestCasePriority(2), Description("Read Transient Profile setting")]
    public class ReadTransientSetting_FriendsOnly : PermissionBase
    {
        public ReadTransientSetting_FriendsOnly(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings(ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO, 1234567890, SettingSource.XSOURCE_DEFAULT);
        }

        protected override void run()
        {

            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            Thread.Sleep(50);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            greq1.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifySettings(gresp1.Settings, (int)gresp1.SettingsLen);
            Thread.Sleep(50);

            //oneway friend 
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq3 = new ReadSettingsRequest(Title, Permission.OwnerInvUser, friends, sIds);
            greq3.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp3 = greq3.Execute();
            verifyXerror(gresp3);
            verifySettings(gresp3.Settings, (int)gresp3.SettingsLen);
            Thread.Sleep(50);

            //oneway nonfriend 
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq4 = new ReadSettingsRequest(Title, Permission.UserInvOwner, friends, sIds);
            greq4.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp4 = greq4.Execute();
            verifyXerror(gresp4);
            // This should now be valid, permissions should be open for the XSAM party info setting
            verifySettings(gresp4.Settings, (int)gresp4.SettingsLen);
            Thread.Sleep(50);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq5 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            greq5.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp5 = greq5.Execute();
            verifyXerror(gresp5);
            // This should now be valid, permissions should be open for the XSAM party info setting
            verifySettings(gresp5.Settings, (int)gresp5.SettingsLen);
        }

    }

    public class ReadActivity_None : PermissionBase
    {
        public ReadActivity_None(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_Activity_None;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            greq1.Modifyflag = AuthModify.Read_Activity_None;
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifyPermissionDenied(gresp1);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            greq2.Modifyflag = AuthModify.Read_Activity_None;
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyPermissionDenied(gresp2);
        }
    }

    //ReadActivity_All
    public class ReadActivity_All : PermissionBase
    {
        public ReadActivity_All(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            // With Local Caching, we need to wait for the local cache to timeout before validating. 
            Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
            Thread.Sleep(UserSettingBase.cacheTimeout * 1000);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_Activity_All;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);

            //oneway friend 
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq3 = new ReadSettingsRequest(Title, Permission.OwnerInvUser, friends, sIds);
            greq3.Modifyflag = AuthModify.Read_Activity_All;
            ReadSettingsResponse gresp3 = greq3.Execute();
            verifyXerror(gresp3);
            verifySettings(gresp3.Settings, (int)gresp3.SettingsLen);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            greq1.Modifyflag = AuthModify.Read_Activity_All;
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifySettings(gresp1.Settings, (int)gresp1.SettingsLen);

            //oneway nonfriend 
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq4 = new ReadSettingsRequest(Title, Permission.UserInvOwner, friends, sIds);
            greq4.Modifyflag = AuthModify.Read_Activity_All;
            ReadSettingsResponse gresp4 = greq4.Execute();
            verifyXerror(gresp4);
            verifySettings(gresp4.Settings, (int)gresp4.SettingsLen);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            greq2.Modifyflag = AuthModify.Read_Activity_All;
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifySettings(gresp2.Settings, (int)gresp2.SettingsLen);
        }
    }

    //ReadActivity_friendsList
    public class ReadActivity_friendsList6 : PermissionBase
    {
        UserSetting[] expectedSettings = new UserSetting[4];

        public ReadActivity_friendsList6(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(NonFriend);
            expectedSettings[0] = addsettings(NonFriend, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[0].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;

            ProfileWS.ResetUserSetttings(Friend);
            expectedSettings[1] = addsettings(Friend, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            ProfileWS.ResetUserSetttings(Permission.friend2);
            expectedSettings[2] = addsettings(Permission.friend2, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            ProfileWS.ResetUserSetttings(Permission.friend3);
            expectedSettings[3] = addsettings(Permission.friend3, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[4];

            friends[0] = NonFriend;
            friends[1] = Friend;
            friends[2] = Permission.friend2;
            friends[3] = Permission.friend3;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            Global.RO.Info("Reading setting for Owner and firend");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(expectedSettings, gresp.Settings, (int)gresp.SettingsLen);
        }

    }
    public class ReadActivity_friendsList5 : PermissionBase
    {
        UserSetting[] expectedSettings = new UserSetting[4];

        public ReadActivity_friendsList5(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Permission.UserInvOwner);
            expectedSettings[0] = addsettings(Permission.UserInvOwner, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            ProfileWS.ResetUserSetttings(Friend);
            expectedSettings[1] = addsettings(Friend, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            ProfileWS.ResetUserSetttings(Permission.friend2);
            expectedSettings[2] = addsettings(Permission.friend2, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            ProfileWS.ResetUserSetttings(Permission.friend3);
            expectedSettings[3] = addsettings(Permission.friend3, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[4];

            friends[0] = Permission.UserInvOwner;
            friends[1] = Friend;
            friends[2] = Permission.friend2;
            friends[3] = Permission.friend3;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            Global.RO.Info("Redaing setting for Owner and firend");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(expectedSettings, gresp.Settings, (int)gresp.SettingsLen);
        }

    }
    public class ReadActivity_friendsList4 : PermissionBase
    {
        UserSetting[] expectedSettings = new UserSetting[4];

        public ReadActivity_friendsList4(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Permission.OwnerInvUser);
            expectedSettings[0] = addsettings(Permission.OwnerInvUser, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[0].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;

            ProfileWS.ResetUserSetttings(Friend);
            expectedSettings[1] = addsettings(Friend, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            ProfileWS.ResetUserSetttings(Permission.friend2);
            expectedSettings[2] = addsettings(Permission.friend2, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            ProfileWS.ResetUserSetttings(Permission.friend3);
            expectedSettings[3] = addsettings(Permission.friend3, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[4];

            friends[0] = Permission.OwnerInvUser;
            friends[1] = Friend;
            friends[2] = Permission.friend2;
            friends[3] = Permission.friend3;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            Global.RO.Info("Reading setting for Owner and firend");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(expectedSettings, gresp.Settings, (int)gresp.SettingsLen);
        }

    }
    public class ReadActivity_friendsList3 : PermissionBase
    {
        UserSetting[] expectedSettings = new UserSetting[4];

        public ReadActivity_friendsList3(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Permission.friend1);
            expectedSettings[0] = addsettings(Permission.friend1, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            ProfileWS.ResetUserSetttings(Friend);
            expectedSettings[1] = addsettings(Friend, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            ProfileWS.ResetUserSetttings(Permission.friend2);
            expectedSettings[2] = addsettings(Permission.friend2, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            ProfileWS.ResetUserSetttings(Permission.friend3);
            expectedSettings[3] = addsettings(Permission.friend3, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[4];

            friends[0] = Permission.friend1;
            friends[1] = Friend;
            friends[2] = Permission.friend2;
            friends[3] = Permission.friend3;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            Global.RO.Info("Reading setting for Owner and firend");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(expectedSettings, gresp.Settings, (int)gresp.SettingsLen);
        }
    }

    public class ReadActivity_friendsList2 : PermissionBase
    {
        UserSetting[] expectedSettings = new UserSetting[4];

        public ReadActivity_friendsList2(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Permission.OwnerInvUser);
            expectedSettings[1] = addsettings(Permission.OwnerInvUser, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[1].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;

            ProfileWS.ResetUserSetttings(Permission.UserInvOwner);
            expectedSettings[2] = addsettings(Permission.UserInvOwner, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            ProfileWS.ResetUserSetttings(Friend);
            expectedSettings[0] = addsettings(Friend, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            ProfileWS.ResetUserSetttings(NonFriend);
            expectedSettings[3] = addsettings(NonFriend, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[3].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;
        }

        protected override void run()
        {
            ulong[] friends = new ulong[4];
            friends[3] = NonFriend;
            friends[1] = Permission.OwnerInvUser;
            friends[2] = Permission.UserInvOwner;
            friends[0] = Friend;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(expectedSettings, gresp.Settings, (int)gresp.SettingsLen);
        }
    }

    public class ReadActivity_friendsList : PermissionBase
    {
        UserSetting[] expectedSettings = new UserSetting[4];

        public ReadActivity_friendsList(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Permission.OwnerInvUser);
            expectedSettings[1] = addsettings(Permission.OwnerInvUser, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[1].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;

            ProfileWS.ResetUserSetttings(Permission.UserInvOwner);
            expectedSettings[2] = addsettings(Permission.UserInvOwner, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            ProfileWS.ResetUserSetttings(Friend);
            expectedSettings[3] = addsettings(Friend, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            ProfileWS.ResetUserSetttings(NonFriend);
            expectedSettings[0] = addsettings(NonFriend, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[0].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;

        }

        protected override void run()
        {
            ulong[] friends = new ulong[4];
            friends[0] = NonFriend;
            friends[1] = Permission.OwnerInvUser;
            friends[2] = Permission.UserInvOwner;
            friends[3] = Friend;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(expectedSettings, gresp.Settings, (int)gresp.SettingsLen);
        }
    }

    public class ReadActivity_friends : PermissionBase
    {
        public ReadActivity_friends(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            // With Local Caching, we need to wait for the local cache to timeout before validating. 
            Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
            Thread.Sleep(UserSettingBase.cacheTimeout * 1000);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            greq.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            greq1.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifySettings(gresp1.Settings, (int)gresp1.SettingsLen);

            //oneway friend 
            Global.RO.Info("Reading setting for User invited owner ");
            ReadSettingsRequest greq3 = new ReadSettingsRequest(Title, Permission.OwnerInvUser, friends, sIds);
            greq3.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp3 = greq3.Execute();
            verifyXerror(gresp3);
            verifySettings(gresp3.Settings, (int)gresp3.SettingsLen);

            //oneway nonfriend 
            Global.RO.Info("Reading setting for owner invited friend ");
            ReadSettingsRequest greq4 = new ReadSettingsRequest(Title, Permission.UserInvOwner, friends, sIds);
            greq4.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp4 = greq4.Execute();
            verifyXerror(gresp4);
            verifyPermissionDenied(gresp4);
            //verifySettings(gresp4.Settings,(int)gresp4.SettingsLen);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            greq2.Modifyflag = AuthModify.Read_Activity_FriendOnly;
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyPermissionDenied(gresp2);
        }
    }

    public class Not_Shared : PermissionBase
    {
        public Not_Shared(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_Not_Shared, 123456, SettingSource.XSOURCE_DEFAULT);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Not_Shared;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyPermissionDenied(gresp1);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyPermissionDenied(gresp2);
        }
    }

    public class TitleRo : PermissionBase
    {

        public TitleRo(uint title)
            : base(title)
        {

        }
        public override void Run()
        {
            //empty tsettings
            cleanup();
            // error 
            ProfileWS.ResetUserSetttings(Owner);
            UserSetting[] settings = new UserSetting[1];
            settings[0] = new UserSetting(Owner, (uint)TestUSetting.Test_Title_RO, SConvert.Bytes(1234567), SettingSource.XSOURCE_DEFAULT);
            SyncSettingsRequest req = new SyncSettingsRequest((uint)Titles.Global, Owner, settings, DateTime.UtcNow);

            SyncSettingsResponse resp = req.Execute();
            if (resp.XError != 0)
                throw new Exception("Error in Sync settings XERROR: " + resp.XError);

            UserSetting[] settings1 = new UserSetting[1];
            settings1[0] = new UserSetting(Owner, (uint)TestUSetting.Test_Title_RO, SConvert.Bytes(67543), SettingSource.XSOURCE_TITLE);
            SyncSettingsRequest req1 = new SyncSettingsRequest(Title, Owner, settings1, DateTime.UtcNow);
            SyncSettingsResponse resp2 = req1.ExecuteToInt();
            if (resp2.XError != 0)
                throw new Exception("Error in Sync settings XERROR: " + resp2.XError);

            // make sure that the setting value is 1234567
            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Title_RO;
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            Tsettings.Add((uint)TestUSetting.Test_Title_RO, settings[0]);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);
        }
    }

    public class WebRo : PermissionBase
    {

        public WebRo(uint title)
            : base(title)
        {

        }
        public override void Run()
        {
            //empty tsettings
            cleanup();

            // error 
            ProfileWS.ResetUserSetttings(Owner);
            UserSetting[] settings = new UserSetting[1];
            settings[0] = new UserSetting(Owner, (uint)TestUSetting.Test_Web_RO, SConvert.Bytes(1234567), SettingSource.XSOURCE_DEFAULT);
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Owner, settings, DateTime.UtcNow);

            SyncSettingsResponse resp = req.Execute();
            if (resp.XError != HResult.S_OK)
                throw new Exception("Error in Sync settings XERROR: " + resp.XError);

            UserSetting[] settings2 = new UserSetting[1];
            settings2[0] = new UserSetting(Owner, (uint)TestUSetting.Test_Web_RO, SConvert.Bytes(67543), SettingSource.XSOURCE_DEFAULT);
            SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Owner, settings2, DateTime.UtcNow);
            SyncSettingsResponse resp2 = req2.ExecuteToInt();
            if (resp2.XError != HResult.S_OK)
                throw new Exception("Error in Sync settings XERROR: " + resp2.XError);

            // make sure that the setting value is 1234567
            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Web_RO;
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            Tsettings.Add((uint)TestUSetting.Test_Web_RO, settings[0]);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);
        }
    }

    public class MultiSettingWithOneConsoleRo : PermissionBase
    {

        public MultiSettingWithOneConsoleRo(uint title)
            : base(title)
        {

        }
        public override void Run()
        {
            //empty tsettings
            cleanup();

            // error 
            ProfileWS.ResetUserSetttings(Owner);
            UserSetting[] settings = new UserSetting[1];
            settings[0] = new UserSetting(Owner, (uint)TestUSetting.Test_Console_RO, SConvert.Bytes(1234567), SettingSource.XSOURCE_DEFAULT);
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Owner, settings, DateTime.UtcNow);

            SyncSettingsResponse resp2 = req.ExecuteToInt();
            if (resp2.XError != HResult.S_OK)
                throw new Exception("Error in Sync settings XERROR: " + resp2.XError);

            UserSetting[] settings2 = new UserSetting[2];
            settings2[0] = new UserSetting(Owner, (uint)TestUSetting.Test_Console_RO, SConvert.Bytes(67543), SettingSource.XSOURCE_DEFAULT);
            settings2[1] = new UserSetting(Owner, (uint)TestUSetting.Test_binary32, SConvert.Bytes(70707), SettingSource.XSOURCE_DEFAULT);
            SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Owner, settings2, DateTime.UtcNow);

            SyncSettingsResponse resp = req2.Execute();
            if (resp.XError != HResult.S_OK)
                throw new Exception("Error in Sync settings XERROR: " + resp.XError);

            // make sure that the setting value is 1234567
            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Console_RO;
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            Tsettings.Add((uint)TestUSetting.Test_Console_RO, settings[0]);
            Tsettings.Add((uint)TestUSetting.Test_binary32, settings2[1]);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);
        }
    }

    public class ConsoleRo : PermissionBase
    {

        public ConsoleRo(uint title)
            : base(title)
        {

        }
        public override void Run()
        {
            //empty tsettings
            cleanup();

            // error 
            ProfileWS.ResetUserSetttings(Owner);
            UserSetting[] settings = new UserSetting[1];
            settings[0] = new UserSetting(Owner, (uint)TestUSetting.Test_Console_RO, SConvert.Bytes(1234567), SettingSource.XSOURCE_DEFAULT);
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Owner, settings, DateTime.UtcNow);

            SyncSettingsResponse resp2 = req.ExecuteToInt();
            if (resp2.XError != HResult.S_OK)
                throw new Exception("Error in Sync settings XERROR: " + resp2.XError);

            UserSetting[] settings2 = new UserSetting[1];
            settings2[0] = new UserSetting(Owner, (uint)TestUSetting.Test_Console_RO, SConvert.Bytes(67543), SettingSource.XSOURCE_DEFAULT);
            SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Owner, settings2, DateTime.UtcNow);

            SyncSettingsResponse resp = req2.Execute();
            if (resp.XError != HResult.S_OK)
                throw new Exception("Error in Sync settings XERROR: " + resp.XError);

            // make sure that the setting value is 1234567
            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Console_RO;
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            Tsettings.Add((uint)TestUSetting.Test_Console_RO, settings[0]);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Read UCC setting Everyone permissions")]
    public class UCC_all : PermissionBase
    {
        public UCC_all(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_UCC, 123456, SettingSource.XSOURCE_DEFAULT);

            // With Local Caching, we need to wait for the local cache to timeout before validating. 
            Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
            Thread.Sleep(UserSettingBase.cacheTimeout * 1000);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_UCC;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifySettings(gresp1.Settings, (int)gresp1.SettingsLen);

            // nonfriend
            Global.RO.Info("Reading setting for nonfirend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyXerror(gresp2);
            verifySettings(gresp2.Settings, (int)gresp2.SettingsLen);
        }
    }


    public class UCC_friendsList2 : PermissionBase
    {
        UserSetting[] expectedSettings = new UserSetting[4];

        public UCC_friendsList2(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Permission.OwnerInvUser);
            expectedSettings[1] = addsettings(Permission.OwnerInvUser, (uint)TestUSetting.Test_UCC, 123456, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[1].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;
            addPermission(Permission.OwnerInvUser, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS);

            ProfileWS.ResetUserSetttings(Permission.UserInvOwner);
            expectedSettings[2] = addsettings(Permission.UserInvOwner, (uint)TestUSetting.Test_UCC, 23456, SettingSource.XSOURCE_DEFAULT);
            addPermission(Permission.UserInvOwner, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS);

            ProfileWS.ResetUserSetttings(Friend);
            expectedSettings[0] = addsettings(Friend, (uint)TestUSetting.Test_UCC, 23456, SettingSource.XSOURCE_DEFAULT);
            addPermission(Friend, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS);

            ProfileWS.ResetUserSetttings(NonFriend);
            expectedSettings[3] = addsettings(NonFriend, (uint)TestUSetting.Test_UCC, 23456, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[3].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;
            addPermission(NonFriend, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS);

            // With Local Caching, we need to wait for the local cache to timeout before validating. 
            Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
            Thread.Sleep(UserSettingBase.cacheTimeout * 1000);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[4];
            friends[3] = NonFriend;
            friends[1] = Permission.OwnerInvUser;
            friends[2] = Permission.UserInvOwner;
            friends[0] = Friend;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_UCC;

            //self
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(expectedSettings, gresp.Settings, (int)gresp.SettingsLen);
        }
    }

    public class UCC_friendsList : PermissionBase
    {
        UserSetting[] expectedSettings = new UserSetting[4];

        public UCC_friendsList(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Permission.OwnerInvUser);
            expectedSettings[1] = addsettings(Permission.OwnerInvUser, (uint)TestUSetting.Test_UCC, 123456, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[1].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;
            addPermission(Permission.OwnerInvUser, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS);

            ProfileWS.ResetUserSetttings(Permission.UserInvOwner);
            expectedSettings[2] = addsettings(Permission.UserInvOwner, (uint)TestUSetting.Test_UCC, 23456, SettingSource.XSOURCE_DEFAULT);
            addPermission(Permission.UserInvOwner, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS);

            ProfileWS.ResetUserSetttings(Friend);
            expectedSettings[3] = addsettings(Friend, (uint)TestUSetting.Test_UCC, 23456, SettingSource.XSOURCE_DEFAULT);
            addPermission(Friend, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS);

            ProfileWS.ResetUserSetttings(NonFriend);
            expectedSettings[0] = addsettings(NonFriend, (uint)TestUSetting.Test_UCC, 23456, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[0].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;
            addPermission(NonFriend, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS);

            // With Local Caching, we need to wait for the local cache to timeout before validating. 
            Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
            Thread.Sleep(UserSettingBase.cacheTimeout * 1000);
        }

        protected override void run()
        {

            ulong[] friends = new ulong[4];
            friends[0] = NonFriend;
            friends[1] = Permission.OwnerInvUser;
            friends[2] = Permission.UserInvOwner;
            friends[3] = Friend;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_UCC;

            //self
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(expectedSettings, gresp.Settings, (int)gresp.SettingsLen);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Read UCC setting Friends Only permission")]
    public class UCC_friends : PermissionBase
    {
        public UCC_friends(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_UCC, 123456, SettingSource.XSOURCE_DEFAULT);
            addPermission(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS);

            // With Local Caching, we need to wait for the local cache to timeout before validating. 
            Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
            Thread.Sleep(UserSettingBase.cacheTimeout * 1000);
        }

        protected override void run()
        {

            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_UCC;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            Thread.Sleep(50);

            //Permission
            Global.RO.Info("Reading setting for one way  friend");
            ReadSettingsRequest greq3 = new ReadSettingsRequest(Title, Permission.OwnerInvUser, friends, sIds);
            ReadSettingsResponse gresp3 = greq3.Execute();
            verifyXerror(gresp3);
            verifySettings(gresp3.Settings, (int)gresp3.SettingsLen);
            Thread.Sleep(50);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifySettings(gresp1.Settings, (int)gresp1.SettingsLen);
            Thread.Sleep(50);

            // nonfriend
            Global.RO.Info("Reading setting for one way nonfriend");
            ReadSettingsRequest greq4 = new ReadSettingsRequest(Title, Permission.UserInvOwner, friends, sIds);
            ReadSettingsResponse gresp4 = greq4.Execute();
            verifyPermissionDenied(gresp4);

            Thread.Sleep(50);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyPermissionDenied(gresp2);

            Thread.Sleep(50);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(2), Description("Read UCC setting Blocked permission")]
    public class UCC_none : PermissionBase
    {
        public UCC_none(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_UCC, 123456, SettingSource.XSOURCE_DEFAULT);
            addPermission(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_UCC_NOONE);

            // With Local Caching, we need to wait for the local cache to timeout before validating. 
            Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
            Thread.Sleep(UserSettingBase.cacheTimeout * 1000);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_UCC;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyPermissionDenied(gresp1);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyPermissionDenied(gresp2);
        }
    }

    public class UCC_none_bug116640 : PermissionBase
    {
        public UCC_none_bug116640(uint title)
            : base(title)
        {
        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_UCC, 123456, SettingSource.XSOURCE_DEFAULT);
            addPermission(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_UCC_NOONE);

            // With Local Caching, we need to wait for the local cache to timeout before validating. 
            Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
            Thread.Sleep(UserSettingBase.cacheTimeout * 1000);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[3];
            sIds[0] = (uint)0x402C0011; //motto
            sIds[1] = (uint)0x41040040; //name 
            sIds[2] = (uint)0x43E80043; //userbio

            UserSetting[] settings = new UserSetting[3];
            settings[0] = new UserSetting(Owner, sIds[0], new byte[] { 1, 2, 3, 4 });
            settings[1] = new UserSetting(Owner, sIds[1], new byte[] { 51, 52, 53, 54 });
            settings[2] = new UserSetting(Owner, sIds[2], new byte[] { 100, 200, 254, 255 });

            addsettings(Owner, settings);

            //self
            //create the list of settings we're going to read
            sIds = new uint[5];
            sIds[0] = (uint)0x402C0011; //motto
            sIds[1] = (uint)0x41040040; //name 
            sIds[2] = (uint)0x43E80043; //userbio
            sIds[3] = (uint)0x10040000; //permissions
            sIds[4] = (uint)TestUSetting.Test_UCC; //test ucc setting

            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            //now these settings should be all cached in Cache

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyPermissionDenied(gresp1);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyPermissionDenied(gresp2);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(1), Description("Read settings with all activity set")]
    public class Activity_all : PermissionBase
    {
        public Activity_all(uint title)
            : base(title)
        {
        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);

            // With Local Caching, we need to wait for the local cache to timeout before validating. 
            Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
            Thread.Sleep(UserSettingBase.cacheTimeout * 1000);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifySettings(gresp1.Settings, (int)gresp1.SettingsLen);

            // nonfriend
            Global.RO.Info("Reading setting for nonfirend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyXerror(gresp2);
            verifySettings(gresp2.Settings, (int)gresp2.SettingsLen);
        }

    }

    public class Activity_friendslist2 : PermissionBase
    {
        UserSetting[] expectedSettings = new UserSetting[4];
        public Activity_friendslist2(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Permission.OwnerInvUser);
            expectedSettings[1] = addsettings(Permission.OwnerInvUser, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[1].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;
            addPermission(Permission.OwnerInvUser, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);

            ProfileWS.ResetUserSetttings(Permission.UserInvOwner);
            expectedSettings[2] = addsettings(Permission.UserInvOwner, (uint)TestUSetting.Test_Activity, 23456, SettingSource.XSOURCE_DEFAULT);
            addPermission(Permission.UserInvOwner, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);

            ProfileWS.ResetUserSetttings(Friend);
            expectedSettings[0] = addsettings(Friend, (uint)TestUSetting.Test_Activity, 3456, SettingSource.XSOURCE_DEFAULT);
            addPermission(Friend, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);

            ProfileWS.ResetUserSetttings(NonFriend);
            expectedSettings[3] = addsettings(NonFriend, (uint)TestUSetting.Test_Activity, 45678, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[3].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;
            addPermission(NonFriend, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[4];
            friends[3] = NonFriend;
            friends[1] = Permission.OwnerInvUser;
            friends[2] = Permission.UserInvOwner;
            friends[0] = Friend;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(expectedSettings, gresp.Settings, (int)gresp.SettingsLen);
            Thread.Sleep(50);
        }
    }

    public class Activity_friendslist : PermissionBase
    {
        UserSetting[] expectedSettings = new UserSetting[4];
        public Activity_friendslist(uint title)
            : base(title)
        {
        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Permission.OwnerInvUser);
            expectedSettings[1] = addsettings(Permission.OwnerInvUser, (uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[1].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;
            addPermission(Permission.OwnerInvUser, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);

            ProfileWS.ResetUserSetttings(Permission.UserInvOwner);
            expectedSettings[2] = addsettings(Permission.UserInvOwner, (uint)TestUSetting.Test_Activity, 23456, SettingSource.XSOURCE_DEFAULT);
            addPermission(Permission.UserInvOwner, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);

            ProfileWS.ResetUserSetttings(Friend);
            expectedSettings[3] = addsettings(Friend, (uint)TestUSetting.Test_Activity, 3456, SettingSource.XSOURCE_DEFAULT);
            addPermission(Friend, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);

            ProfileWS.ResetUserSetttings(NonFriend);
            expectedSettings[0] = addsettings(NonFriend, (uint)TestUSetting.Test_Activity, 45678, SettingSource.XSOURCE_DEFAULT);
            expectedSettings[0].Source = (uint)SettingSource.XSOURCE_PERMISSION_DENIED;
            addPermission(NonFriend, PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[4];
            friends[0] = NonFriend;
            friends[1] = Permission.OwnerInvUser;
            friends[2] = Permission.UserInvOwner;
            friends[3] = Friend;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(expectedSettings, gresp.Settings, (int)gresp.SettingsLen);
        }
    }

    public class Activity_friends : PermissionBase
    {
        public Activity_friends(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            addPermission(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);

            // With Local Caching, we need to wait for the local cache to timeout before validating. 
            Global.RO.Info("Sleeping for " + UserSettingBase.cacheTimeout + " seconds for local cache");
            Thread.Sleep(UserSettingBase.cacheTimeout * 1000);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            Thread.Sleep(50);

            //one way friend
            Global.RO.Info("Reading setting a one way friend");
            ReadSettingsRequest greq3 = new ReadSettingsRequest(Title, Permission.OwnerInvUser, friends, sIds);
            ReadSettingsResponse gresp3 = greq3.Execute();
            verifyXerror(gresp3);
            verifySettings(gresp3.Settings, (int)gresp3.SettingsLen);
            Thread.Sleep(50);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifySettings(gresp1.Settings, (int)gresp1.SettingsLen);
            Thread.Sleep(50);

            //one way  nonfriend
            Global.RO.Info("Reading setting fora one way  nonfriend");
            ReadSettingsRequest greq4 = new ReadSettingsRequest(Title, Permission.UserInvOwner, friends, sIds);
            ReadSettingsResponse gresp4 = greq4.Execute();
            verifyPermissionDenied(gresp4);
            Thread.Sleep(50);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyPermissionDenied(gresp2);
        }
    }

    [TestFrequency("Daily"), TestCasePriority(1), Description("Read Permission Blocked")]
    public class Activity_none : PermissionBase
    {
        public Activity_none(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_Activity, 123456, SettingSource.XSOURCE_DEFAULT);
            addPermission(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Activity;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyPermissionDenied(gresp1);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyPermissionDenied(gresp2);
        }
    }


    public class SETTING_ENFORCE_FRIENDS_ONLY : PermissionBase
    {
        public SETTING_ENFORCE_FRIENDS_ONLY(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            ProfileWS.ResetUserSetttings(Owner);
            addsettings((uint)TestUSetting.Test_Friend_Only, 123456, SettingSource.XSOURCE_DEFAULT);
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = (uint)TestUSetting.Test_Friend_Only;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            Thread.Sleep(50);

            //one way friend
            Global.RO.Info("Reading setting a one way friend");
            ReadSettingsRequest greq3 = new ReadSettingsRequest(Title, Permission.OwnerInvUser, friends, sIds);
            ReadSettingsResponse gresp3 = greq3.Execute();
            verifyPermissionDenied(gresp3);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifySettings(gresp1.Settings, (int)gresp1.SettingsLen);
            Thread.Sleep(50);

            //one way  nonfriend
            Global.RO.Info("Reading setting fora one way  nonfriend");
            ReadSettingsRequest greq4 = new ReadSettingsRequest(Title, Permission.UserInvOwner, friends, sIds);
            ReadSettingsResponse gresp4 = greq4.Execute();
            verifyPermissionDenied(gresp4);
            Thread.Sleep(50);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyPermissionDenied(gresp2);
        }
    }

    //Read new Profile Video Metadata Transient Setting
    //Set the Permission which only has an Everyone or Noone value (no friends option)
    [TestFrequency("Daily"), TestCasePriority(1), Description("Read Video Metadata with all permission set")]
    public class ReadVideoMetadata_All : PermissionBase
    {
        public ReadVideoMetadata_All(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            // Not needed, addsettings does this call for me.
            //ProfileWS.ResetUserSetttings(Owner); 
            addsettings(ProfileDefs.XPROFILE_VIDEO_METADATA, 1234567890, SettingSource.XSOURCE_DEFAULT);
            // Turn on the permission to allow others to see my video metadata, and set the option as well
            addPermission(Owner, (byte)(PROFILE_FLG.XPROFILE_PERMISSION_SHARE_VIDEO_EVERYONE | PROFILE_FLG.XPROFILE_PERMISSION_SHARE_VIDEO_OPTION));
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = ProfileDefs.XPROFILE_VIDEO_METADATA;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            Thread.Sleep(50);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyXerror(gresp1);
            verifySettings(gresp1.Settings, (int)gresp1.SettingsLen);
            Thread.Sleep(50);

            //oneway friend 
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, Permission.OwnerInvUser, friends, sIds);
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyXerror(gresp2);
            verifySettings(gresp2.Settings, (int)gresp2.SettingsLen);
            Thread.Sleep(50);

            //oneway nonfriend 
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq3 = new ReadSettingsRequest(Title, Permission.UserInvOwner, friends, sIds);
            ReadSettingsResponse gresp3 = greq3.Execute();
            verifyXerror(gresp3);
            verifySettings(gresp3.Settings, (int)gresp3.SettingsLen);
            Thread.Sleep(50);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq4 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            ReadSettingsResponse gresp4 = greq4.Execute();
            verifyXerror(gresp4);
            verifySettings(gresp4.Settings, (int)gresp4.SettingsLen);
        }
    }
    //Read new Profile Video Metadata Transient Setting
    //Set the Permission which only has an Everyone or Noone value (no friends only)
    [TestFrequency("Daily"), TestCasePriority(1), Description("Read Video Metadata with blocked permission set")]
    public class ReadVideoMetadata_Noone : PermissionBase
    {
        public ReadVideoMetadata_Noone(uint title)
            : base(title)
        {

        }
        protected override void init()
        {
            // Not needed, addsettings does this call for me.
            //ProfileWS.ResetUserSetttings(Owner); 
            addsettings(ProfileDefs.XPROFILE_VIDEO_METADATA, 12345678780, SettingSource.XSOURCE_DEFAULT);
            // Don't set this permission so it is defaultly set to No One
            // CodyLuit: I had to set the permission again because since the users are shared, the previous test setting it to Everyone would break this test.
            //           It was being set to no one by default (so the test would pass when run by itself), but this will make it work in automation
            addPermission(Owner, (byte)(/*PROFILE_FLG.XPROFILE_PERMISSION_SHARE_VIDEO_EVERYONE |*/ PROFILE_FLG.XPROFILE_PERMISSION_SHARE_VIDEO_OPTION));
        }

        protected override void run()
        {
            ulong[] friends = new ulong[1];
            friends[0] = Owner;

            uint[] sIds = new uint[1];
            sIds[0] = ProfileDefs.XPROFILE_VIDEO_METADATA;

            //self
            Global.RO.Info("Reading setting for Owner");
            ReadSettingsRequest greq = new ReadSettingsRequest(Title, Owner, friends, sIds);
            ReadSettingsResponse gresp = greq.Execute();
            verifyXerror(gresp);
            verifySettings(gresp.Settings, (int)gresp.SettingsLen);
            Thread.Sleep(50);

            // friend
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq1 = new ReadSettingsRequest(Title, Friend, friends, sIds);
            ReadSettingsResponse gresp1 = greq1.Execute();
            verifyPermissionDenied(gresp1);
            Thread.Sleep(50);

            //oneway friend 
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq2 = new ReadSettingsRequest(Title, Permission.OwnerInvUser, friends, sIds);
            ReadSettingsResponse gresp2 = greq2.Execute();
            verifyPermissionDenied(gresp2);
            Thread.Sleep(50);

            //oneway nonfriend 
            Global.RO.Info("Reading setting for friend");
            ReadSettingsRequest greq3 = new ReadSettingsRequest(Title, Permission.UserInvOwner, friends, sIds);
            ReadSettingsResponse gresp3 = greq3.Execute();
            verifyPermissionDenied(gresp3);
            Thread.Sleep(50);

            // nonfriend
            Global.RO.Info("Reading setting for nonfriend");
            ReadSettingsRequest greq4 = new ReadSettingsRequest(Title, NonFriend, friends, sIds);
            ReadSettingsResponse gresp4 = greq4.Execute();
            verifyPermissionDenied(gresp4);
        }
    }

    public class PermissionBase : PCBase
    {
        protected Hashtable Tsettings = new Hashtable();

        public PermissionBase(uint title)
            : base(title)
        {
            Title = title;
        }
        protected override void cleanup()
        {
            Tsettings.Clear();
        }

        public UserSetting addsettings(ulong user, uint settingid, long svalue, SettingSource source)
        {
            UserSetting[] settings = new UserSetting[1];
            settings[0] = new UserSetting(user, settingid, SConvert.Bytes(svalue), source);

            SyncSettingsRequest req = new SyncSettingsRequest(Title, user, settings, DateTime.UtcNow);

            SyncSettingsResponse resp = req.Execute();
            if (resp.XError != 0)
                throw new Exception("Error loading settings XERROR: " + resp.XError);
            return settings[0];
        }

        public void addsettings(ulong user, UserSetting[] settings)
        {
            SyncSettingsRequest req = new SyncSettingsRequest(Title, user, settings, DateTime.UtcNow);
            SyncSettingsResponse resp = req.Execute();

            if (resp.XError != 0)
                throw new Exception("Error adding settings XERROR: " + resp.XError);

            foreach (UserSetting sett in settings)
            {
                Tsettings.Add(sett.SettingId, sett);
            }
        }

        public void addsettings(uint settingid, long svalue, SettingSource source)
        {
            ProfileWS.ResetUserSetttings(Owner);
            UserSetting[] settings = new UserSetting[1];
            settings[0] = new UserSetting(Owner, settingid, SConvert.Bytes(svalue), source);
            Tsettings.Add(settingid, settings[0]);
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Owner, settings, DateTime.UtcNow);

            SyncSettingsResponse resp = req.Execute();
            if (resp.XError != 0)
                throw new Exception("Error loading settings. XERROR: " + resp.XError);
        }

        public void verifyPermissionDenied(ReadSettingsResponse resp)
        {
            if (resp.XError != 0)
                throw new Exception("Unexpected XError returned by server: " + resp.XError);

            for (int i = 0; i < resp.Settings.Length; i++)
            {
                if (resp.Settings[i].SettingId == 0x10040000) continue;
                if (resp.Settings[i].Source != (uint)SettingSource.XSOURCE_PERMISSION_DENIED)
                    throw new Exception("Unexpected Source for setting id: " + resp.Settings[i].SettingId + ". Expected: 3 (Permision Denied) Received: " + resp.Settings[i].Source);
            }
        }

        public void verifyXerror(ReadSettingsResponse resp)
        {
            if (resp.XError != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server :" + resp.XError);
        }

        public void addPermission(ulong user, byte svalue)
        {
            uint settingid = (uint)PROFILE_FLG.XPROFILE_PERMISSIONS;
            //ProfileWS.SetUserProfileItemDirect(0xfffe07d1, user, DateTime.UtcNow, settingid, new byte[1] { 0x00 });
            UserSetting[] settings = new UserSetting[1];
            settings[0] = new UserSetting(user, settingid, new byte[] { svalue }, SettingSource.XSOURCE_DEFAULT);
            //Tsettings.Add(settingid,settings[0]);
            SyncSettingsRequest req = new SyncSettingsRequest(0, user, settings, DateTime.UtcNow);

            SyncSettingsResponse resp = req.Execute();
            if (resp.XError != 0)
                throw new Exception("Error loading settings XERROR: " + resp.XError);
        }

        public override void addPermission(byte svalue)
        {
            uint settingid = (uint)PROFILE_FLG.XPROFILE_PERMISSIONS;

            //ProfileWS.SetUserProfileItemDirect(0xfffe07d1, Owner, DateTime.UtcNow, settingid, new byte[1] { 0x00 });
            UserSetting[] settings = new UserSetting[1];
            settings[0] = new UserSetting(Owner, settingid, new byte[] { svalue, 0, 0, 0 }, SettingSource.XSOURCE_DEFAULT);
            Tsettings.Add(settingid, settings[0]);
            SyncSettingsRequest req = new SyncSettingsRequest(0, Owner, settings, DateTime.UtcNow);

            SyncSettingsResponse resp = req.Execute();
            if (resp.XError != 0)
                throw new Exception("Error loading settings XERROR: " + resp.XError);
        }

        public void verifySettings(UserSetting[] respsettings, int respSettingLen)
        {
            for (int i = 0; i < respsettings.Length; i++)
            {
                if (Tsettings.ContainsKey(respsettings[i].SettingId))
                {

                    UserSetting uset = (UserSetting)Tsettings[respsettings[i].SettingId];
                    if (respsettings[i].Source != uset.Source)
                        throw new Exception("Setting Source is different. Expected: " + uset.Source + " Received: " + respsettings[i].Source);
                    if (respsettings[i].Source == (uint)SettingSource.XSOURCE_NO_VALUE)
                        continue;
                    if (respsettings[i].ValueLen != uset.Value.Length)
                        throw new Exception("Setting value len is different. Expected: " + uset.ValueLen + " Received: " + respsettings[i].ValueLen);

                    for (int vl = 0; vl < uset.Value.Length; vl++)
                    {
                        if (respsettings[i].Value[vl] != uset.Value[vl])
                            throw new Exception("Setting value  is different at idx " + vl + " Expected: " + uset.Value[vl] + " Received: " + respsettings[i].Value[vl]);
                    }
                }
                else
                {
                    throw new Exception("UnExpected Setting ID " + respsettings[i].SettingId);
                }
            }
        }

        public void verifySettings(UserSetting[] expectedResp, UserSetting[] respsettings, int respSettingLen)
        {
            if (expectedResp.Length != respsettings.Length)
                throw new Exception("# of settings in response is not equal to expected");

            for (int i = 0; i < respsettings.Length; i++)
            {
                UserSetting uset = (UserSetting)expectedResp[i];
                if (respsettings[i].userId != uset.userId)
                    throw new Exception("Setting user is different. Expected: " + uset.userId + " Received: " + respsettings[i].userId);

                if (respsettings[i].Source != uset.Source)
                    throw new Exception("Setting Source is different. Expected: " + uset.Source + " Received: " + respsettings[i].Source);
                if (respsettings[i].Source == (uint)SettingSource.XSOURCE_NO_VALUE || respsettings[i].Source == (uint)SettingSource.XSOURCE_PERMISSION_DENIED)
                    continue;
                if (respsettings[i].ValueLen != uset.Value.Length)
                    throw new Exception("Setting value len is different. Expected: " + uset.ValueLen + " Received: " + respsettings[i].ValueLen);

                for (int vl = 0; vl < uset.Value.Length; vl++)
                {
                    if (respsettings[i].Value[vl] != uset.Value[vl])
                        throw new Exception("Setting value  is different at idx " + vl + " Expected: " + uset.Value[vl] + " Received: " + respsettings[i].Value[vl]);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_gamersettings_none_12.4.56.0_none_728b517857e11eba
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=gamersettings
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6.manifest
XP_MANIFEST_PATH=manifests\msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6.cat
XP_CATALOG_PATH=manifests\msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6.cat
XP_PAYLOAD_PATH=msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=gamersettings,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_gamersettings_none_12.4.56.0_none_728b517857e11eba
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=gamersettings
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6.manifest
XP_MANIFEST_PATH=manifests\msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6.cat
XP_CATALOG_PATH=manifests\msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6.cat
XP_PAYLOAD_PATH=msil_gamersettings_no-public-key_12.4.56.0_x-ww_1863f9e6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=gamersettings,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\LB64\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\LB64\Stress.cs ===
#define NEWLBSTATE
//#define OLDLBSTATE

using System;
using System.Xml;
using System.Threading;
using System.Collections.Generic;

using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService.Stats.Util;

//using xonline.server.stats.common;

[assembly: RootNode(typeof(LB64.LB64Suite))]

namespace LB64
{
    #region Stress Management

    // Setup and Teardown

    public partial class LB64Suite : TestNode
    {
        /// <summary>
        /// Called as part of StfRunner's GUI loading process for Stress
        /// </summary>
        public override void OneTimeSetup(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

            //
            // This loads before the GUI, progress text doesn't help, app seems hung
            // must modify so this runs once.
            //

            // Set flag so on first run we'll create the leaderboards, but never again (for this stf session).
            LB64StressMgr.Initialized = false;
        }

        /// <summary>
        /// Called when StfRunner is closed as part of GUI teardown for Stress
        /// </summary>
        public override void OneTimeCleanup(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

            //
            // Any output here is likely to never be seen by the client...
            //

            if (LB64StressMgr.Initialized)
            {
                // Clean up leaderboards
                DBHelper dbh = new DBHelper();
                foreach (LbState lbState in LB64StressMgr.Leaderboards)
                {
                    // Delete Leaderboard
                    LbSvr.DeleteLeaderboard(LB64StressMgr.Server, lbState.TitleId, lbState.Id, /*IgnoreExceptions=*/true);
                }

                LB64StressMgr.Leaderboards = null;
            }
        }

        /// <summary>
        /// Called for Stress when user hits 'Start'
        /// </summary>
        /// <param name="config">XmlDoc reference to stf.xml</param>
        public override void PreRun(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

            // Setup should only be done once per session:
            if (!LB64StressMgr.Initialized)
            {
                LB64StressMgr.Init();
            }
        }
    }

    // State Management

    public static class LB64StressMgr
    {
        public static bool Initialized = false;
        public static void Init()
        {
            Server = ServerIndex.LB64;
            Leaderboards = new LbStateCollection();

            uint titleId = 0x00000052;

            // Create Leaderboards
            int lbCount = 10; //1000;
            int progressMod = lbCount / 10;

            Global.RO.Info("Creating " + lbCount + " Leaderboards for title: 0x" + titleId.ToString("X8"));

            DBHelper dbh = new DBHelper();
            for (uint lbid = 1; lbid <= lbCount; ++lbid)
            {

#if OLDLBSTATE
                LbState lbState = new LbState(titleId, lbid);
#endif

#if NEWLBSTATE
                LbState lbState = new LbState(
                    titleId         // Title Id
                  , lbid            // Leaderboard Id
                  , UInt64.MinValue // Min Puid
                  , UInt64.MaxValue // Max Puid
                  , 100             // Window Size
                  , 64              // Cycles
                );
#endif

                // Create Leaderboard (nuking any previous copy)
                LbSvr.CreateLeaderboard(Server, titleId, lbid);

                if (lbid % progressMod == 0)
                {
                    Global.RO.Info("Created leaderboards " + (lbid - progressMod + 1) + " to " + lbid);
                }

                Leaderboards.Add(lbState);
            }

            Global.RO.Info("Finished creating Leaderboards.");

            LbSvr.PadConnectionQueue(Server, 1000);

            Initialized = true;
        }

        public static ServerIndex Server;
        public static LbStateCollection Leaderboards;
    }

    public class LbStateCollection : List<LbState>
    {
        private RandEx _rand;

        public LbStateCollection()
            : base()
        {
            _rand = new RandEx();
        }

#if OLDLBSTATE
        public LbState Add(uint TitleId, uint LbId)
        {
            LbState lbState = new LbState(titleId, lbid);

            this.Add(lbState);

            return lbState;
        }
#endif

#if NEWLBSTATE
        public LbState Add(uint TitleId, uint LbId, ulong MinPuid, ulong MaxPuid, ulong WindowSize, int Cycles)
        {
            LbState lbState = new LbState(
                TitleId     // Title Id
              , LbId        // Leaderboard Id
              , MinPuid     // Min Puid
              , MaxPuid     // Max Puid
              , WindowSize  // Window Size
              , Cycles      // Cycles
            );

            this.Add(lbState);

            return lbState;
        }
#endif

        public LbState GetRandom()
        {
            int count = this.Count;
            if (count == 0)
            {
                throw new InvalidOperationException("Collection must have at least one entry!");
            }

            int idx = _rand.Next(0, count - 1);
            return this[idx];
        }
    }

    // Leaderboard State

    public class LbNotReadyException : Exception
    {
        public LbNotReadyException() : base() { }
        public LbNotReadyException(string Message) : base(Message) { }
        public LbNotReadyException(string Message, Exception InnerException) : base(Message, InnerException) { }
    }

#if NEWLBSTATE
    public class LbState
    {
        private volatile uint _numberOfEntries;
        public uint NumberOfEntries
        {
            get
            {
                return _numberOfEntries;
            }
        }

        private uint _titleId;
        public uint TitleId
        {
            get
            {
                return _titleId;
            }
        }

        private uint _lbId;
        public uint Id
        {
            get
            {
                return _lbId;
            }
        }

        private Mutex _muxPuid;

        private RandEx _rand;

        private ulong _minPuid;
        private ulong _maxPuid;

        private ulong _currentPuid;
        private int   _puidLoopbackCount;

        private uint _currentWindow;
        private int  _windowLoopbackCount;

        private int   _cycles;
        private ulong _windowSize;

        public LbState(uint TitleId, uint LbId, ulong MinPuid, ulong MaxPuid, ulong WindowSize, int Cycles)
        {
            // Leaderboard Info
            _titleId = TitleId;
            _lbId = LbId;

            _numberOfEntries = 0;

            // Utilitiies
            _rand = new RandEx();

            // Users
            _muxPuid = new Mutex(/*initiallyOwned=*/false);

            _minPuid = MinPuid;
            _maxPuid = MaxPuid;

            _currentPuid = 0;

            // Sliding Window State
            _windowSize = WindowSize;

            _cycles = Cycles;
            _puidLoopbackCount = 0;

            _windowLoopbackCount = 0;

            _currentWindow = 0;
        }

        public void NextPuidForWrite(out ulong Puid, out int UseCount)
        {
            _muxPuid.WaitOne();
            try
            {
                Puid = _currentPuid;
                UseCount = _puidLoopbackCount * (_windowLoopbackCount + 1);

                ulong minPuid = _windowSize * _currentWindow;
                ulong maxPuid = _windowSize * (_currentWindow + 1) - 1;
                if (maxPuid > _maxPuid)
                {
                    maxPuid = _maxPuid;
                }

                if (_currentPuid < maxPuid)
                {
                    ++_currentPuid;

                    // If we have looped back, then we aren't adding any
                    // 'new' entries, just updating old ones
                    if (_puidLoopbackCount == 0 && _windowLoopbackCount == 0)
                    {
                        ++_numberOfEntries;
                    }
                }
                else
                {
                    if (_puidLoopbackCount < _cycles)
                    {
                        ++_puidLoopbackCount;
                    }
                    else
                    {
                        Global.RO.Info("Sliding window moving, new range: " + minPuid + " - " + maxPuid);

                        _puidLoopbackCount = 0;

                        ++_currentWindow;
                    }


                    // reset the puids
                    _currentPuid = _minPuid;
                }

            }
            finally
            {
                _muxPuid.ReleaseMutex();
            }
        }

        public ulong GetPuidForRead()
        {
            while (_numberOfEntries == 0)
            {
                Thread.Sleep(500);
            }

            return _rand.NextULong(1, _numberOfEntries);
        }

        public uint GetRankForRead()
        {
            while (_numberOfEntries == 0)
            {
                Thread.Sleep(500);
            }

            return unchecked((uint)_rand.NextULong(1, _numberOfEntries));
        }

        // This get will only pull from a subset of the available entries
        // because it is the only way we can garuntee that the read will find
        // the entry it is looking for
        public ulong GetRatingForRead()
        {
            ulong puid = _rand.NextULong(_minPuid, _currentPuid);

            int cycles = _cycles * _windowLoopbackCount; // at least this many cycles have occured
            if ( puid < _minPuid + (_windowSize * _currentWindow) )
            {
                // full complement of cycles have occured
                cycles += _cycles;
            }
            else
            {
                // only as many cycles as loopbackCount contains have occured
                cycles += _windowLoopbackCount;
            }

            return GenerateRating(puid, cycles);
        }

        static public ulong GenerateRating(ulong Puid, int UseCount)
        {
            return unchecked(((ulong)UseCount << 32) + (0x00000000FFFFFFFF & Puid));
        }
    }
#endif
#if OLDLBSTATE
    public class LbState
    {
        private volatile uint _numberOfEntries;
        public uint NumberOfEntries
        {
            get
            {
                return _numberOfEntries;
            }
        }

        private uint _titleId;
        public uint TitleId
        {
            get
            {
                return _titleId;
            }
        }

        private uint _lbId;
        public uint Id
        {
            get
            {
                return _lbId;
            }
        }

        private RandEx _rand;

        private Mutex _muxPuid;
        private ulong _maxPuid;
        private ulong _currentPuid;
        private int _puidLoopbackCount;

        public LbState(uint TitleId, uint LbId)
        {
            // Leaderboard Info
            _titleId = TitleId;
            _lbId = LbId;

            _numberOfEntries = 0;

            // Utilitiies
            _rand = new RandEx();

            // Users
            _muxPuid = new Mutex(/*initiallyOwned=*/false);

            _maxPuid = ulong.MaxValue;

            _currentPuid = 0;
            _puidLoopbackCount = 0;
        }

        public void NextPuidForWrite(out ulong Puid, out int UseCount)
        {
            _muxPuid.WaitOne();
            try
            {
                if (_currentPuid < _maxPuid)
                {
                    // returned puid must never equal zero
                    ++_currentPuid;

                    // If we have looped back, then we aren't adding any
                    // 'new' entries, just updating old ones
                    if (_puidLoopbackCount == 0)
                    {
                        ++_numberOfEntries;
                    }
                }
                else
                {
                    // If this overflows were are simply out of luck
                    // if we just keep going the verify step will fail
                    // so, the best thing to do here is just to die.
                    // We can at least rely on the data that has been
                    // written to be verifiable
                    ++_puidLoopbackCount;

                    // returned puid must never equal zero
                    _currentPuid = 1;
                }

                Puid = _currentPuid;
                UseCount = _puidLoopbackCount;
            }
            finally
            {
                _muxPuid.ReleaseMutex();
            }
        }

        public ulong GetPuidForRead()
        {
            if (_numberOfEntries == 0)
            {
                throw new LbNotReadyException();
            }

            return _rand.NextULong(1, _numberOfEntries);
        }

        public ulong GetRankForRead()
        {
            if (_numberOfEntries == 0)
            {
                throw new LbNotReadyException();
            }

            return _rand.NextULong(1, _numberOfEntries);
        }

        // This get will only pull from a subset of the available entries
        // because it is the only way we can garuntee that the read will find
        // the entry it is looking for
        public ulong GetRatingForRead()
        {
            ulong puid = _rand.NextULong(1, _currentPuid);
            return GenerateRating(puid, _puidLoopbackCount);
        }

        static public ulong GenerateRating(ulong Puid, int UseCount)
        {
            return unchecked(((ulong)UseCount << 32) + (0x00000000FFFFFFFF & Puid));
        }
    }
#endif

    // Randomness

    public class RandEx : Random
    {
        public ulong NextULong()
        {
            return NextULong(0, ulong.MaxValue);
        }

        public ulong NextULong(ulong MaxValue)
        {
            return NextULong(0, MaxValue);
        }

        public ulong NextULong(ulong MinValue, ulong MaxValue)
        {
            // Get a raw ulong
            ulong ul = unchecked((ulong)this.NextDouble());

            // Shoehorn the raw ulong into the requested range
            ul = (ul % (MaxValue - MinValue + 1)) + MinValue;

            // Return spiffy ulong that meets the criteria
            return ul;
        }
    }

    #endregion // Stress Management

    #region Stress Cases

    [StressTest(Priority = 200, TargetTPS = 1000)]
    [StressInstantiate]
    public class StressWrite : TestBase
    {
        private short ColumnId(int Count)
        {
            return (short)(Count % 60 + 1);
        }

        protected override void Execute()
        {
            ulong puid;
            int count;

            LbState lb = LB64StressMgr.Leaderboards.GetRandom();
            lb.NextPuidForWrite(out puid, out count);

            ulong rating = LbState.GenerateRating(puid, count);

            object[] procBlob = LbSvr.GenerateStatWriteBlob(
                lb.TitleId  // Title Id
              , lb.Id       // Leaderboard Id
              , puid        // User Id
              , 0           // Session Start Time

                // Attributes
              , new object[] {
                        (Int16)ColumnId(count)
                      , (Int32)count
                      , (Int16)SpecialAttrib.Rating
                      , unchecked((Int64)rating)
                    }
            );

            LbsvrClientConnection con = LbSvr.OpenConnection(LB64StressMgr.Server);

            LbSvr.ExecuteSingleProcCall(
                con
              , LbsvrClientConnection.LbProcIdStatWrite
              , procBlob
            );

            con.Close();

            ResultCode = TEST_RESULTS.PASSED;
        }
    }

    [StressTest(Priority = 1000, TargetTPS = 20000)]
    [StressInstantiate]
    public class StressRead : TestBase
    {
        protected override void Execute()
        {
            LbsvrClientConnection con = LbSvr.OpenConnection(LB64StressMgr.Server);

            try
            {
                LbState lb = LB64StressMgr.Leaderboards.GetRandom();
                ulong puid = lb.GetPuidForRead();

                unchecked
                {
                    LbSvr.ExecuteSingleProcCall(
                       con,
                       LbsvrClientConnection.LbProcIdStatRead,
                       new object[] {
                                (Int32)lb.TitleId // Title Id
                              , (Int32)lb.Id      // Leaderboard Id
                              , (Int64)puid       // User Id
                            }
                   );
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
            catch (LbNotReadyException)
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
            }
            finally
            {
                if (con != null) { con.Close(); }
            }
        }
    }

    [StressTest(Priority = 5, TargetTPS = 10)]
    [StressInstantiate]
    public class StressEnum : TestBase
    {
        protected override void Execute()
        {
            LbsvrClientConnection con = LbSvr.OpenConnection(LB64StressMgr.Server);

            try
            {
                LbState lb = LB64StressMgr.Leaderboards.GetRandom();
                uint rank = lb.GetRankForRead();

                unchecked
                {
                    LbSvr.ExecuteSingleProcCall(
                        con,
                        LbsvrClientConnection.LbProcIdStatEnum,
                        new object[] {
                                        (Int32)lb.TitleId // Title Id
                                      , (Int32)lb.Id      // Leaderboard Id
                                      , (Int32)rank       // Starting Rank
                                      , (Int32)100        // Page Size
                                    }
                    );
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
            catch (LbNotReadyException)
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
            }
            finally
            {
                if (con != null) { con.Close(); }
            }
        }
    }

    #endregion // Stress Cases
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\LB64\Common.cs ===
using System;
using System.Text;
using System.Collections;
using System.Data;
using System.Data.SqlClient;

using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Stats.Util;
using ServerTestFramework.LiveService.Stats;

using System.Net;
//using xonline.server.stats.common;

using System.Diagnostics;

namespace LB64
{
    public partial class LB64Suite : TestNode
    {
        // Here for any setup that could be considered 'common'
    }

    [TestGroup]
    public partial class LB64Tests : TestNode
    {
        // Just here to establish 'TestGroup' Attribute
    }

    // BUGBUG: Temp Kludge... where do I find TestException? -- It's UnexpectedTestResultException
    public class TestException : Exception
    {
        public TestException(string Message)
            : base(Message)
        {

        }

        public TestException(string Message, Exception InnerException)
            : base(Message, InnerException)
        {

        }
    }

    #region LBSVR Communication

    public enum ServerIndex : byte
    {
      LB64  = 0
      , LB64b = 1
          //LB32 is removed, as we no longer have any 32-bit servers.
    }

    public static class LbSvr
    {
        // Lazy loading of the DBHelper
        private static DBHelper _dbHelper;
        private static DBHelper _dbh
        {
            get
            {
                if (_dbHelper == null)
                {
                    _dbHelper = new DBHelper();
                }

                return _dbHelper;
            }
        }

        /// <summary>
        /// Open a connection to a leaderboard server using a ServerIndex
        /// </summary>
        /// <param name="Server">Server Index to connection to</param>
        /// <returns>An LbsvrClientConnection used to communicate with the lbsvr</returns>
        public static LbsvrClientConnection OpenConnection(ServerIndex Server)
        {
            IPEndPoint endpoint = DBHelper.LBSinfo((int)Server);
            if (endpoint == null)
            {
                throw new TestException(
                    "LBSinfo() for Server Index " + (int)Server
                  + " came back 'null'"
                );
            }

            return LbsvrClientConnection.OpenConnection(endpoint);
        }

        /// <summary>
        /// Adds count number of active connections to the connection pool for the provided IPEndPoint
        /// </summary>
        /// <param name="lbsvrendpt">IPEndPoint for the server to connect to</param>
        /// <param name="count">Number of connections to open to the lbsvr</param>
        static public void PadConnectionQueue(ServerIndex Server, int Count)
        {
            LbsvrClientConnection[] connections = new LbsvrClientConnection[Count];

            // This loop can throw if we exceed MaxPoolSize connections for LbsvrClientConnection (see lbsvrclient.cs)
            try
            {
                // Create & Connect 'Count' number of times
                for (int i = 0; i < Count; ++i)
                {
                    connections[i] = OpenConnection(Server);
                }
            }
            finally
            {
                // Move the opened connections to the pool
                for (int i = 0; i < Count; ++i)
                {
                    if (connections[i] != null)
                    {
                        connections[i].Close();
                    }
                }
            }
        }

        /// <summary>
        /// Creates a new leaderboard on the requested server, destroying any previous copies
        /// </summary>
        /// <param name="Server">Server Index to create the leaderboard on</param>
        /// <param name="TitleId">Title Id for the leaderboard</param>
        /// <param name="LbId">Leaderboard Id</param>
        public static void CreateLeaderboard(ServerIndex Server, uint TitleId, uint LbId)
        {
            // If we can't delete because it doesn't exist... well, that happens sometimes.
            // If the error was something else, we're going to throw again when we try to create
            // the leaderboard again.
            //
            // In short, we're swallowing the exception, but if it was other than we "expect"
            // it will bite us again in the next call... and *not* be swallowed.

            NukeLeaderboard(TitleId, LbId);

            int retval = -1;
            unchecked
            {
                retval = _dbh.CreateNewLeaderBoards(
                    (int)TitleId,   // Title Id
                    (int)LbId,      // Leaderboard Id
                    0/*=never*/,    // Reset Type
                    60,             // Attributes per Row
                    11 * 1024,      // Max Attachment Size(11MB)
                    0/*=false*/,    // Top100 (Lightweight) Leaderboard ?
                    0/*=never*/,    // Decay (in days)
                    "",             // Elo Parameters
                    0/*=false*/,    // Team Leaderboard ?
                    0/*=false*/,    // Arbitrated Leaderboard ?
                    (int)Server     // Server Index
                );
            }

            if (retval != 0)
            {
                throw new TestException("Failed to create new leaderbord with error number: " + retval);
            }

            Global.RO.Debug(
                "Created new leaderboard: " + LbId
              + " for title: 0x"
              + TitleId.ToString("X8")
              + " on ServerIndex " + (int)Server  
            );
        }

        public static void LoadLeaderboard(LbsvrClientConnection Con, uint TitleId, uint LbId)
        {
            ExecuteSingleProcCall(
                Con,
                LbsvrClientConnection.LbProcIdCreateAndLoadOneLb,
                new object[] {
                    unchecked((Int32)TitleId),
                    unchecked((Int32)LbId)
                }
            );

            FlushResults(Con);

            // Must remember to set read-write
        }

        /// <summary>
        /// Assumes you know what you are doing and have put the leaderboard into the proper state already
        /// </summary>
        /// <param name="Con"></param>
        /// <param name="TitleId"></param>
        /// <param name="LbId"></param>
        public static void DeleteLeaderboard(LbsvrClientConnection Con, uint TitleId, uint LbId)
        {
            ExecuteSingleProcCall(
                Con,
                LbsvrClientConnection.LbProcIdDeleteLb,
                new object[] {
                    (Int32)TitleId,
                    (Int32)LbId
                }
            );

            FlushResults(Con);
        }

        /// <summary>
        /// Removes the leaderboard from any and all lbsvrs
        /// </summary>
        /// <param name="TitleId">Title Id for the leaderboard</param>
        /// <param name="LbId">Leaderboard Id</param>
        public static void NukeLeaderboard(uint TitleId, uint LbId)
        {
            Global.RO.Debug("Nuking Leaderboard: " + LbId + " for Title: 0x" + TitleId.ToString("X8"));

            bool wasFound = false;

            IPEndPoint[] servers = ServerTestFramework.Global.XEnv.GetInterface("lbsvr");
            foreach (IPEndPoint server in servers)
            {
                try
                {
                    LbsvrClientConnection con = LbsvrClientConnection.OpenConnection(server);

                    try
                    {
                        DeleteLeaderboard(con, TitleId, LbId);

                        Global.RO.Debug("Found and deleted on " + server.Address);
                        wasFound = true;
                    }
                    finally
                    {
                        con.Close();
                    }
                }
                catch
                { /* Ignore any failures here */ }
            }

            if (!wasFound)
            {
                Global.RO.Debug("Leaderboard was not found on any servers");
            }

            Global.RO.Debug("Done Nuking Leaderboard");
        }

        /// <summary>
        /// Delete a leaderboard from the cache and NPDB
        /// </summary>
        /// <param name="Server">Server Index to delete leaderboard from</param>
        /// <param name="TitleId">Title Id for the leaderboard</param>
        /// <param name="LbId">Leaderboard Id</param>
        public static void DeleteLeaderboard(ServerIndex Server, uint TitleId, uint LbId)
        {
            DeleteLeaderboard(Server, TitleId, LbId, /*IgnoreExceptions=*/false);
        }

        public static void DeleteLeaderboard(ServerIndex Server, uint TitleId, uint LbId, bool IgnoreExceptions)
        {
            try
            {
                unchecked
                {
                    _dbh.deleteLeaderBoard(
                        (int)TitleId
                      , (int)LbId
                      , (int)Server
                    );
                }

                Global.RO.Debug("Deleted leaderboard: " + LbId + " for title: 0x" + TitleId.ToString("X8"));
            }
            catch (Exception e)
            {
                Global.RO.Debug(
                    "Failed to delete leaderboard: " + LbId
                  + " for title: 0x" + TitleId.ToString("X8")
                  + " with error: " + e.Message
                );

                if (!IgnoreExceptions)
                {
                    throw;
                }
            }
        }

        public static void ExecuteSingleProcCall(LbsvrClientConnection Con, uint ProcId, object[] ProcBlob)
        {
            Con.BeginRequest(1);
            Con.CallProc(ProcId, ProcBlob);
            Con.SendRequest();
        }

        /// <summary>
        /// A more robust way to clear pending results than Reset()ing the conncetion alone
        /// </summary>
        /// <param name="Con">Leaderboard Server Connection to operate on</param>
        public static void FlushResults(LbsvrClientConnection Con)
        {
            // Check for an error
            LbsvrClientResult result = Con.NextResult();
            if (result == LbsvrClientResult.Message)
            {
                throw new Exception("Error processing LB Request.");
            }

            // Swallow rowsets until the end.
            if (result != LbsvrClientResult.None)
            {
                while (Con.NextRowset())
                    ;
            }
        }

        public static object[] GenerateStatWriteBlob(uint TitleId, uint LbId, ulong UserId, ulong SessionStartTime, object[] Attributes)
        {
            ArrayList blob = new ArrayList();

            blob.Add((Int32)TitleId);
            blob.Add((Int32)LbId);
            blob.Add((Int64)UserId);
            blob.Add((Int64)SessionStartTime);

            // If there are not an even number of attributes (keys and values)
            // then we simply pretend there were no attributes at all.
            int attribCount = (Attributes != null && Attributes.Length % 2 == 0) ? Attributes.Length / 2 : 0;

            // No matter what we need to poast a number of attributes, even if that number is 0.
            // Attributes come in pairs (header & value), so the length
            // of the Attribute array will be double the number of attributes.
            blob.Add((Int16)attribCount);
            if (attribCount > 0)
            {
                blob.AddRange(Attributes);
            }

            return blob.ToArray();
        }
    }
    #endregion // LBSVR Communicaiton

    /// <summary>
    /// Base class with helper functions for the Zero Downtime Upgrade test scenarios.
    /// </summary>
    public class LB64ZDT : LB64TestBase
    {
        [Flags]
        protected enum MigrationState
        {
            None                 = 0x0000
          , LbExists             = 0x0001
          , LbLivesHere          = 0x0002
          , LbIsReadOnly         = 0x0010
          , LbHasNoPendingWrites = 0x0020
        }

        protected void CleanupLb(ServerIndex server, MigrationState state, uint titleId, uint lbId, out string errorText)
        {
            errorText = "";

            if ( (state & MigrationState.LbExists) != 0)
            {
                LbsvrClientConnection con = LbSvr.OpenConnection(server);

                try
                {
                    if ( (state & MigrationState.LbLivesHere) != 0)
                    {
                        if ( (state & MigrationState.LbIsReadOnly) != 0)
                        {
                            LbSvr.ExecuteSingleProcCall(
                                con,
                                LbsvrClientConnection.LbProcIdSetLbToReadWrite,
                                new object[] {
                                    unchecked((Int32)titleId),
                                    unchecked((Int32)lbId)
                                }
                            );

                            LbSvr.FlushResults(con);
                        }

                        LbSvr.DeleteLeaderboard(server, titleId, lbId);

                        // errorText, cleanup success
                    }
                    else if ( state == (MigrationState.LbIsReadOnly | MigrationState.LbHasNoPendingWrites) )
                    {
                        LbSvr.ExecuteSingleProcCall(
                            con,
                            LbsvrClientConnection.LbProcIdDeleteLbFromMemoryOnly,
                            new object[] {
                                unchecked((Int32)titleId),
                                unchecked((Int32)lbId)
                            }
                        );

                        LbSvr.FlushResults(con);

                        // errorText, cleanup success
                    }
                    else
                    {
                        // Whatever state we are in, it is not safe to attempt recovery, give up and warn the user:
                    }

                    // We aren't going to worry about leaking this connection at this point
                    // things would have to be pretty bad if we fail in this try-block.
                    con.Close();
                }
                catch (Exception e)
                {
                    // One of our proc calls failed, warn the user and allow any exceptions thrown getting here to be propegated
                    Exception bs = e;
                    throw;
                }
            }
        }

        protected void UpdateServerForLb(uint TitleId, uint LbId, ServerIndex Server)
        {
            string serverName = DBHelper.LBSname((int)Server);

            Npdb npdb = new Npdb();

            try
            {
                npdb.ConnectToServer();
            }
            catch (SqlException)
            {
                // Couldn't connect
                // Issue a warning and clean up the memory used for the connection object
                Global.RO.Warn("Could not connect to NPDB.");
                return;
            }

            try
            {
                SqlCommand command = npdb.CreateCommand();
                command.CommandText = "p_stats_update_server_for_lb";
                command.CommandType = CommandType.StoredProcedure;

                command.Parameters.Add("@vc_server", SqlDbType.VarChar, 64).Value = serverName;

                command.Parameters.AddWithValue("@i_title_id", unchecked((Int32)TitleId));
                command.Parameters.AddWithValue("@i_lb_id", unchecked((Int32)LbId));

                npdb.ExecuteScalar(command);
            }
            finally
            {
                npdb.Close();
            }
        }

        protected void WaitForDelayedWrites
        (
            LbsvrClientConnection Con,
            uint TitleId,
            uint LbId,
            uint SwapSeed
        )
        {
            bool readyToDelete = false;
            object[] procBlob = new object[] {
                        (Int32)SwapSeed
            };

            while (!readyToDelete)
            {
                // Sleep for one second.
                System.Threading.Thread.Sleep(1000);

                LbSvr.ExecuteSingleProcCall(Con, LbsvrClientConnection.LbProcIdIsSafeToDeleteLb, procBlob);
                LbsvrClientResult result = Con.NextResult();
                if (result != LbsvrClientResult.Rowset || !Con.Read())
                {
                    throw new Exception(
                        "Failed to set leaderboard (0x" + TitleId.ToString("X8") + ":0x" + LbId.ToString("X8") + ") to read-only "
                      + " on server '" + DBHelper.LBSname((int)ServerIndex.LB64) + "'."
                    );
                }

                readyToDelete = ((sbyte)Con.GetColumn(0)) > 0 ? true : false;
                Con.Reset();
            }
        }
    }

    /// <summary>
    /// Base class with helper functions for all LB64 test scenarios
    /// </summary>
    public class LB64TestBase : TestBase
    {
        #region Constants

        protected const int WRITE_HEADER_LENGTH = 5;
        protected const int READ_HEADER_LENGTH  = 3;
        protected const int ENUM_HEADER_LENGTH  = 2;

        protected const ushort BytesPerPage = 8 * 1024;

        #endregion // Constants

        #region Counter Accessors

        private string GetLbMemoryStat(ServerIndex Server, uint TitleId, uint LbId, string Stat)
        {
            string statVal = String.Empty;

            IPEndPoint lbsInfo = DBHelper.LBSinfo((int)Server);

            //TODO: Replace this hard-coded XMGMT Port with a dynamically supplied one.
            // Copy Address into a new IPEndPoint and override the port to be xmgmt.
            // Note, we have to do it this way, because if we simply override it on the passed IPEndPoint, it changes the data
            // for future LBSinfo() calls as well.... wtf?
            IPEndPoint endpoint = new IPEndPoint(lbsInfo.Address, 4100);

            string commandString = "e :lbsvr dumplbmemorystats 0x" + TitleId.ToString("X8") + " " + LbId;

            string[] responses;
            uint hr = XManagement.Execute(endpoint, commandString, out responses);
            if (hr >> 32 == 1) // === FAILED()
            {
                throw new Exception("XManagement.Exceute() returned hr=0x" + hr.ToString("X8"));
            }

            foreach (string response in responses)
            {
                string key;
                string value;

                // If we find a valid key-value pair, parse it; if there is no valid key-value pair
                // then we just ignore this response.  The data returned from the command includes
                // some headers which are not of the "key-value pair" syntax.
                string[] tokens = response.Split(new char[] { '=' });
                if (tokens.Length == 2)
                {
                    key   = tokens[0].Trim().ToLower();
                    value = tokens[1].Trim();

                    // BUGBUG: This returns the *first* matching stat, however the results are returned in two batches
                    //         one for the userid tree, and one for the rating tree.  I am not sure in which order they
                    //         are returned, nor if they are equivalent in terms of memory usage.  My assumptions were
                    //         all built upon the rating tree and I am not sure they hold true for the userid tree.
                    if (key == Stat)
                    {
                        statVal = value;
                        break;
                    }
                }
            }

            if (statVal == String.Empty)
            {
                throw new Exception("XManagement: Stat '" + Stat + "' D.N.E.!");
            }

            return statVal;
        }

        protected ulong GetNodeCountForLeaderboard(ServerIndex Server, uint TitleId, uint LbId)
        {
            // TODO: cpagext ?
            string val = GetLbMemoryStat(Server, TitleId, LbId, "cpage");
            return ulong.Parse(val);
        }

        protected ulong GetByteCountForLeaderboard(ServerIndex Server, uint TitleId, uint LbId)
        {
            // TODO: cbyteext ?
            string val = GetLbMemoryStat(Server, TitleId, LbId, "cbytes");
            return ulong.Parse(val);
        }

        #endregion // Counter Accessors

        #region Helper Fuctions

        protected delegate object[] RowBlobDelegate(uint TitleId, uint LbId, uint Row);

        protected object[] AscendingRank(uint TitleId, uint LbId, uint Row)
        {
            uint userId = Row + 1;
            object[] blob = LbSvr.GenerateStatWriteBlob(
                TitleId,
                LbId,
                userId,
                0,      // Session Start Time

                // Attributes
                new object[] {
                                (Int16)SpecialAttrib.Rating,
                                (Int64)userId
               }
            );

            return blob;
        }

        protected object[] DescendingRank(uint TitleId, uint LbId, uint Row)
        {
            uint userId = Row + 1;
            object[] blob = LbSvr.GenerateStatWriteBlob(
                TitleId,
                LbId,
                userId,
                0,      // Session Start Time

                // Attributes
                new object[] {
                                (Int16)SpecialAttrib.Rating,
                                (Int64)(-userId)
                }
            );

            return blob;
        }

        protected void AddRowsToLeaderboard
        (
            LbsvrClientConnection Con,
            uint TitleId,
            uint LbId,
            uint RowCount,
            RowBlobDelegate BlobForRow
        )
        {
            for (uint row = 0; row < RowCount; ++row)
            {
                object[] procBlob = BlobForRow(TitleId, LbId, row);

                LbSvr.ExecuteSingleProcCall(Con, LbsvrClientConnection.LbProcIdStatWrite, procBlob);
                LbSvr.FlushResults(Con);
            }
        }

        protected uint FillFirstLeaderboardPage
        (
            LbsvrClientConnection Con,
            uint TitleId,
            uint LbId,
            RowBlobDelegate BlobForRow
        )
        {
            // Add entries to a leaderboard
            uint currentRow = 0;
            ulong bytesUsed = 0;

            // Add entries in pairs (two with 1 attribute, two with 2, etc ... up to 10)
            // Until we have less than 300 bytes left AND we have just completed a 'pair' of entries
            while ((BytesPerPage - bytesUsed) > 300)
            {
                object[] procBlob = BlobForRow(TitleId, LbId, currentRow);
                LbSvr.ExecuteSingleProcCall(Con, LbsvrClientConnection.LbProcIdStatWrite, procBlob);
                LbSvr.FlushResults(Con);

                // We do care how much memory we've used so far, but we only want to update
                // the count after each 'pair' otherwise we would exit early
                if (currentRow % 2 != 0) // true on all odd numbers: n*2+1. where n = 0,1,2,...
                {
                    bytesUsed = GetByteCountForLeaderboard(ServerIndex.LB64, TitleId, LbId);
                }

                ++currentRow;
            }

            // Fill the remaining space with one entry
            // First add the entry we will fill out.
            {
                object[] procBlob = LbSvr.GenerateStatWriteBlob(
                    TitleId,    // Title Id
                    LbId,       // Leaderboard Id
                    currentRow, // User Id
                    0,          // Session Start Time
                    null        // Attributes to Post
                );

                LbSvr.ExecuteSingleProcCall(Con, LbsvrClientConnection.LbProcIdStatWrite, procBlob);
                LbSvr.FlushResults(Con);

                // Check to see what. if any, space is left to fill
                bytesUsed = GetByteCountForLeaderboard(ServerIndex.LB64, TitleId, LbId);
                ulong bytesLeft = BytesPerPage - bytesUsed;
                if (bytesLeft != 0)
                {
                    // There was space left over, so re-post the last user with
                    // a string that coincidentally takes up the remaining space.

                    byte[] fillerBytes = new byte[bytesLeft];
                    string fillerString = ASCIIEncoding.ASCII.GetString(fillerBytes);

                    procBlob = LbSvr.GenerateStatWriteBlob(
                        TitleId,    // Title Id
                        LbId,       // Leaderboard Id
                        currentRow, // User Id
                        0,          // Session Start Time
                        new object[] {
                                (Int16)31337,           // Attribute Id
                                (string)fillerString    // Attribute Value
                            }
                    );

                    LbSvr.ExecuteSingleProcCall(Con, LbsvrClientConnection.LbProcIdStatWrite, procBlob);
                    LbSvr.FlushResults(Con);
                }
            }

            return currentRow;
        }

        #endregion // Helper Fuctions

        #region General Verification

        protected void VerifyNodeCountForLeaderboard(ulong ExpectedNodeCount, ServerIndex Server, uint TitleId, uint LbId)
        {
            ulong numberOfNodes = GetNodeCountForLeaderboard(ServerIndex.LB64, TitleId, LbId);
            if (numberOfNodes != ExpectedNodeCount)
            {
                throw new TestException(
                    "On server: " + DBHelper.LBSname((int)Server)
                  + " we found " + numberOfNodes + " nodes"
                  + " for tid: 0x" + TitleId.ToString("X8") + " lbid: 0x" + LbId.ToString("X8")
                  + ", but expected " + ExpectedNodeCount + "."
                );
            }
        }

        protected void VerifyLbContents
        (
            LbsvrClientConnection Con,
            uint TitleId,
            uint LbId,
            uint ExpectedRowCount,
            RowBlobDelegate BlobForRow
        )
        {
            LbsvrClientResult result;

            // Does the leaderboard have the expected number of rows?
            LbSvr.ExecuteSingleProcCall(
                Con,
                LbsvrClientConnection.LbProcIdGetLbRankedEntryCount,
                new object[] {
                    (Int32)TitleId,
                    (Int32)LbId
                }
            );

            result = Con.NextResult();
            if (result != LbsvrClientResult.Rowset)
            {
                throw new Exception("Expected Rowset, got " + result);
            }

            Con.Read();
            uint rowCount = unchecked((UInt32)(Int32)Con.GetColumn(0));
            Con.Reset();

            if (rowCount != ExpectedRowCount)
            {
                throw new Exception(
                    "Returned rowcount (" + rowCount + ")"
                  + " did not match the expected (" + ExpectedRowCount + ")"
                );
            }

            // Do the row contents match what we posted?
            // TODO: extend this to support >1000 rows
            LbSvr.ExecuteSingleProcCall(
                Con,
                LbsvrClientConnection.LbProcIdStatEnum,
                new object[] {
                    	(Int32) /*UInt32*/ TitleId,
	                    (Int32) /*UInt32*/ LbId,
	                    (Int32) /*UInt32*/ 1,               // Starting Rank
	                    (Int32) /*UInt32*/ ExpectedRowCount
                }
            );

            result = Con.NextResult();
            if (result != LbsvrClientResult.Rowset)
            {
                throw new Exception("Expected Rowset, got " + result);
            }

            uint row = 0;
            while (Con.Read())
            {
                object[] blob = BlobForRow(TitleId, LbId, row);

                int serverColCount = Con.GetColumnCount() - ENUM_HEADER_LENGTH;
                int clientColCount = blob.Length - WRITE_HEADER_LENGTH;

                if (serverColCount != clientColCount)
                {
                    throw new Exception(
                        "Number of columns (" + serverColCount + ")"
                      + " did not match the expected (" + clientColCount + ")"
                    );
                }
                
                // Verify User Id
                ulong clientUserId = unchecked((UInt64)(Int64)blob[2]);
                ulong serverUserId = unchecked((UInt64)(Int64)Con.GetColumn(1));

                if (clientUserId != serverUserId)
                {
                    throw new Exception("Server returned UserId: " + serverUserId + " expected: " + clientUserId);
                }

                for (int i = 0; i < serverColCount; ++i)
                {
                    // We are comparing objects which represent other types
                    // therefore we must compare both the types of the objects
                    // and their values.

                    object serverCol = Con.GetColumn(i + ENUM_HEADER_LENGTH);
                    object clientCol = blob[i + WRITE_HEADER_LENGTH];

                    Type serverColType = serverCol.GetType();
                    Type clientColType = clientCol.GetType();

                    if (serverColType != clientColType)
                    {
                        throw new Exception(
                            "Column type (" + serverColType + ")"
                          + " did not match the expected (" + clientColType + ")"
                        );
                    }

                    if (serverCol.ToString() != clientCol.ToString())
                    {
                        throw new Exception(
                            "Column value (" + serverCol + ")"
                          + " did not match the expected (" + clientCol + ")"
                        );
                    }
                }

                ++row;
            }

            Con.Reset();
        }

        #endregion // General Verification

        protected DBHelper _dbh  = new DBHelper(); // Don't keep in-memory stats lb.
        protected RandomEx _rand = new RandomEx();

        protected override void Execute()
        {
            throw new NotImplementedException("Derivatives of LB64TestBase must implement this.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\LB64\lbsvrclient.cs ===
//****************************************************************************
// 
// LbsvrClient.cs
//
// Lbsvr client implementation.
// 
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//****************************************************************************

using ServerTestFramework;

using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using xonline.common.mgmt;
using xonline.common.diagnostics;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.lbsvrclient)]

namespace LB64
{
    public class LbsvrClientException : Exception
    {
        public LbsvrClientException(string message, int error, Exception e) 
            : base(message, e)
        {
            _error = error;
        }
        
        public int Error
        {
            get { return _error; }
        }
        
        protected int _error = 0;
    }
    
    public class LbsvrClientNetworkException : LbsvrClientException
    {
        public LbsvrClientNetworkException(string message, Exception e)
            : base(message, -1, e)
        {}
    }
    
    public class LbsvrClientRequestFailureException : LbsvrClientException
    {
        public LbsvrClientRequestFailureException(string message, int error, Exception e)
            : base(message, error, e)
        {
        }
    }
    
    public enum LbsvrClientState
    {
        Disconnected,
        Connected,
        SendingRequest,
        ReceivingResults,
        ReceivingRowset
    }

    //leaderboard in read or write status
    public enum LbStatus
    {
        DontExist = 0,
        Created   = 1, //created - no operation can be performed
        Loading   = 2, //loading but not complete yet - no operation can be performed
        UnLoading = 3, //unloading - no operation can be performed
        ReadOnly  = 4, //can be read
        ReadWrite = 5  //can be read or written
    }
    
    public enum LbsvrClientResult
    {
        None,
        Rowset,
        Message
    };
    
    // Similar to CLR's NetworkStream, but buffered
    public class BufferedNetworkStream : Stream
    {
        // BufferedNetworkStream
        public BufferedNetworkStream(
            Socket socket,
            int readBufferSize,
            int writeBufferSize
        )
        {
            _readBuffer  = new MemoryStream(readBufferSize);
            _writeBuffer = new MemoryStream(writeBufferSize);
            
            _socket      = socket; 
        }
        
        // Yes, you can read from it
        public override bool CanRead
        {
            get { return true; }
        }
        
        // Yes, you can write to it
        public override bool CanWrite
        {
            get { return true; }
        }
        
        // No, you can't seek
        public override bool CanSeek
        {
            get { return false; }
        }
        
        // Getting the Length of the stream is not supported
        public override long Length
        {
            get 
            {
                throw new NotSupportedException();
            }
        }
        
        // Getting or setting the position is also not supported
        public override long Position
        {
            get 
            {
                throw new NotSupportedException();
            }
            
            set
            {
                throw new NotSupportedException();
            }
        }
        
        // Read bytes from the stream. If succeeds, it will read at least one
        // byte and at most 'count' bytes. It might return 0 bytes if the 
        // socket is being shutdown
        public override int Read(
            byte [] buffer, 
            int offset, 
            int count
        )
        {
            int read = 0;

            if (count <= 0)
            {
                throw new Exception("BufferedNetworkStream Called with count <= 0");
            }
            // Try to read the requested amount of bytes from the read buffer.
            // If we are able to read at least one byte, then we're fine.
            if((read = _readBuffer.Read(buffer, offset, count)) == 0)
            {
                // Read buffer is empty. Time to refill using the socket.
                if (_socket.Poll(-1, SelectMode.SelectRead))
                {
                    try
                    {
                        byte[] rcvbuffer = _readBuffer.GetBuffer();
                        int rcvd = _socket.Receive(rcvbuffer);
                        _readBuffer = new MemoryStream(rcvbuffer, 0, rcvd, false, true);

                        // Try to read the data from the buffer again. If it's still
                        // empty, then it's because the socket is probably being 
                        // shutdown
                        read = _readBuffer.Read(buffer, offset, count);
                    }
                    catch (SocketException)
                    {
                        // Socket Timed Out, we'll leave the readBuffer
                        // empty and return zero bytes.
                    }
                }
            }
            
            return read;
        }
        
        // Write bytes to the stream.
        public override void Write(
            byte [] buffer, 
            int offset, 
            int count
        )
        {
            // If the data can't be fitted in the write buffer, flush the 
            // write buffer.
            if(_writeBuffer.Capacity - _writeBuffer.Length < count)
            {
                Flush();
                Assert.IsTrue(_writeBuffer.Length == 0);
            }
            
            if(count < _writeBuffer.Capacity)
            {
                // WARNING: This means that we can only write blobs that 
                // can fit in the write buffer. Should not be a problem as
                // far as the lbsvr is concerned but if we decide to use
                // this for something else in the future, it's something that
                // can be easily fixed
                
                _writeBuffer.Write(buffer, offset, count);
            }
        }
        
        // Sends all the pending data in the write buffer to the socket
        public override void Flush()
        {         
            if(_writeBuffer.Length > 0)
            {
                byte[] buffer = _writeBuffer.GetBuffer();
                
                int written = _socket.Send(buffer, (int)_writeBuffer.Length, SocketFlags.None);
                
                if(written != _writeBuffer.Length)
                {
                    throw new LbsvrClientNetworkException(
                        String.Format("_socket.Send returned a number of bytes {0} different that was specified {1}", 
                            written, _writeBuffer.Length), null);
                }
                
                _writeBuffer.Seek(0, SeekOrigin.Begin);
                _writeBuffer.SetLength(0);
            }
        }
        
        // Seek is not supported
        public override long Seek(
            long offset,
            SeekOrigin origin
        )
        {
            throw new NotSupportedException();
        }
        
        // SetLength is not supported
        public override void SetLength(
            long value
        )
        {
            throw new NotSupportedException();
        }
        
        // Socket
        protected Socket       _socket;
        
        // Read buffer
        protected MemoryStream _readBuffer;
        
        // Write buffer
        protected MemoryStream _writeBuffer;
    }
    
    public class LbsvrClientConnection : LbsvrClientBase
    {
        static public LbsvrClientConnection OpenConnection(IPEndPoint lbsvrendpt)
        {
            LbsvrClientConnection cnt = null;
                
            // Try to get a connection from the pool first
            
            //Don't lock on global object - hash table can support multiple reader 1 - writer
            Queue pool = (Queue) _connectionPool[lbsvrendpt];
            if(pool != null)
            {
                try
                {
                    // Attempt to Dequeue a value, if the Queue is empty, we'll handle it later
                    cnt = (LbsvrClientConnection) pool.Dequeue(); //pool is a synchronized queue
                }
                catch (InvalidOperationException)
                {
                    // The Queue was empty so we'll simply act as if there were no Queue.
                }

                if (cnt != null)
                {
                    Assert.IsTrue(cnt._state == LbsvrClientState.Connected);
                    cnt._isInPool = false;
                }
            }
            

            // If there was no connection in the pool, make a new one.
            if(cnt == null)
            {
                cnt = new LbsvrClientConnection();
                cnt.InternalOpenConnection("LB64_Stress", lbsvrendpt);
            }
            
            return cnt;
        }
        
        public void Close()
        {
            if(_state == LbsvrClientState.Disconnected)
                return;
            
            try
            {
                SetDefaultCommandTimeOut(); //consider letting the user do this if there is performance problem
                
                // Reset the connection back to the 'Connected' state
                base.Reset(/*ignoreErrors=*/true);
                
                // Add connection to the pool 
                if(!_isInPool)
                {
                    Queue pool = (Queue) _connectionPool[_lbsvrendpt];
                    
                    if(pool == null)
                    {
                        Queue poolNotSynchronized = new Queue(MaxPoolSize);
                        pool = Queue.Synchronized(poolNotSynchronized); //return a wrapper around the synchronized Queue
                        lock(_connectionPool)
                        {
                            if (_connectionPool[_lbsvrendpt] == null)
                            {
                                _connectionPool[_lbsvrendpt] = pool;
                            }
                            else
                            {
                                pool = (Queue) _connectionPool[_lbsvrendpt]; //some other thread created the pool - use the existing one
                            }
                        }
                    }
                    
                    if(pool.Count < MaxPoolSize)
                    {
                        _isInPool = true;
                        pool.Enqueue(this);
                    }
                    else
                    {
                        InternalCloseConnection();
                    }
                }
            }
            catch(Exception /*e*/)
            {
                // Close connection
                try {
                    InternalCloseConnection();
                } catch (Exception) {}
                
                //Global.RO.Debug("Failed while trying to reset and close connection: " + e.Message);
            }
        }
        
        new public void BeginRequest(int procCount)
        {
            try
            {
                base.BeginRequest(procCount);
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        new public void SendRequest()
        {
            try
            {
                base.SendRequest();
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        new public void CallProc(UInt32 procId, object[] parameters)
        {
            try
            {
                base.CallProc(procId, parameters);
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        new public LbsvrClientResult NextResult()
        {
            try
            {
                return base.NextResult();
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        new public bool NextRowset()
        {
            try
            {
                return base.NextRowset();
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        new public bool Read()
        {
            try
            {
                return base.Read();
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        public void Reset()
        {
            try
            {
                base.Reset(/*fIgnoreErrors=*/false);
            }
            catch(Exception)
            {
                InternalCloseConnection();
                throw;
            }
        }
        
        // Object cannot be constructed directly
        protected LbsvrClientConnection()
        {
        }

        protected const int MaxPoolSize = 2000; // HACKHACK
        static protected Hashtable _connectionPool = new Hashtable();
        protected bool _isInPool = false;
    }
    
    public class LbsvrClientBase
    {
        //********************************************************************
        // Public methods
        //********************************************************************
        
        public void BeginRequest(int procCount)
        {
            Assert.IsTrue(_state == LbsvrClientState.Connected);
            
            _state = LbsvrClientState.SendingRequest; 
            LbspReqBeginRequest beginReq = new LbspReqBeginRequest();
            beginReq.dwReqId    = ++_reqId;
            beginReq.wProcCount = (UInt16) procCount;
            
            BeginMessage(LbspIdReqBeginRequest);
            beginReq.WriteStream(GetSendBw());
            EndMessage();
        }
        
        public void SendRequest()
        {
            Assert.IsTrue(_state == LbsvrClientState.SendingRequest);
            Flush();
            _state = LbsvrClientState.ReceivingResults;
        }
        
        public void CallProc(UInt32 procId, object[] parameters)
        {
            Assert.IsTrue(_state == LbsvrClientState.SendingRequest);
            
            LbspReqProcCall procCall = new LbspReqProcCall();
            procCall.dwProcId = procId;
            procCall.rgParam  = parameters;
            
            BeginMessage(LbspIdReqProcCall);
            procCall.WriteStream(GetSendBw());
            EndMessage();
        }
        
        // Jump to the next result in the stream
        public LbsvrClientResult NextResult()
        {
            // If we're not receiving results, don't bother
            if(_state != LbsvrClientState.ReceivingResults &&
               _state != LbsvrClientState.ReceivingRowset)
            {
                #if DEBUG
                Assert.IsTrue(_resultType == LbsvrClientResult.None);
                #endif
                return LbsvrClientResult.None;
            }
            
            // Process messages until we find a message, the beginning of a 
            // new rowset or the end of the request
            for(;;)
            {
                UInt16 msgId = ProcessNextMessage();
                
                if(msgId == LbspIdRepMessage)
                {
                    if(_message.dwErrorId != 0)
                    {
                        // If message is an error, throw it now
                        if(_message.dwErrorId != 0)
                            throw new LbsvrClientRequestFailureException("Request failure. Error="+_message.dwErrorId+
                                " and message is:\n" + _message.message, (int)_message.dwErrorId, null);
                    }
                    
                    // New message detected 
                    break;
                }
                else if(
                    msgId == LbspIdRepRowsetStart ||
                    msgId == LbspIdRepEndRequest)
                {
                    
                    // New rowset or end of request detected
                    break;
                }
            }
            
            return _resultType;
        }
        
        // Jump to the next rowset on the stream
        public bool NextRowset()
        {
            for(;;)
            {
                // Just call NextResult until we run out of results or until
                // we reach a rowset
                LbsvrClientResult res = NextResult();
                
                if(res == LbsvrClientResult.None)
                    return false;
                    
                if(res == LbsvrClientResult.Rowset)
                    return true;
            }
        }
        
        // Read the next row of the rowset
        public bool Read()
        {
            // If current result is not a rowset, don't bother
            if(_resultType != LbsvrClientResult.Rowset)
                return false;
                
            // If we're not parsing the rowset anymore (because we reached the 
            // end of the rowset in a previous call to Read), don't bother
            if(_state != LbsvrClientState.ReceivingRowset)
                return false;
                
            // If the next message is not a LbspIdRepRowsetRow, then we reached
            // the end of the rowset. (ProcessNextMessage will take the 
            // appropriate action in case of protocol errors)
            if(ProcessNextMessage() != LbspIdRepRowsetRow)
                return false;
                
            // New row available
            return true;
        }
        
        public int GetColumnCount()
        {
            Assert.IsTrue(_state == LbsvrClientState.ReceivingRowset);
            return _row.rgColumns.Length;
        }
        
        public object GetColumn(int iCol)
        {
            Assert.IsTrue(_state == LbsvrClientState.ReceivingRowset);
            return _row.rgColumns[iCol];
        }
        
        //********************************************************************
        // Constants
        //********************************************************************
        
        // Limits
        public const UInt32 LbspMaxClientName      = 32;
        public const UInt32 LbspMaxProcCount       = 1000;
        public const UInt32 LbspMaxProcParamCount  = 1000;
        public const UInt32 LbspMaxSizeStringParam = 1024;
        public const UInt32 LbspMaxSizeMessage     = 1024;
        public const UInt32 LbspMaxRowsetColumns   = 1000;

        // Value types
        public const byte   LbspTypeIdInt8         = 0x01;
        public const byte   LbspTypeIdInt16        = 0x02;
        public const byte   LbspTypeIdInt32        = 0x03;
        public const byte   LbspTypeIdInt64        = 0x04;
        public const byte   LbspTypeIdDouble       = 0x05;
        public const byte   LbspTypeIdString       = 0x06;
        public const byte   LbspTypeIdTypeMask     = 0x7F;
        public const byte   LbspTypeIdNullFlag     = 0x80;
        
        // Low-level LBSP Message Ids
        public const UInt16  LbspIdReqHello         = 1;
        public const UInt16  LbspIdRepHello         = 2;
        public const UInt16  LbspIdReqBeginRequest  = 3;
        public const UInt16  LbspIdReqProcCall      = 5;
        public const UInt16  LbspIdRepRowsetStart   = 8;
        public const UInt16  LbspIdRepRowsetRow     = 9;
        public const UInt16  LbspIdRepRowsetEnd     = 11;
        public const UInt16  LbspIdRepMessage       = 12;
        public const UInt16  LbspIdRepEndRequest    = 13;
        public const UInt16  LbspIdReqPing          = 14;
        public const UInt16  LbspIdRepPing          = 15;
        
        // Procedure ids
        public const UInt32  LbProcIdLoadLb                = 1; //this is create lbs - does not load anything
        public const UInt32  LbProcIdDeleteLb              = 2;
        public const UInt32  LbProcIdStatRead              = 3;
        public const UInt32  LbProcIdStatWrite             = 4;
        public const UInt32  LbProcIdStatEnum              = 5;
        public const UInt32  LbProcIdDeleteTitle           = 6;
        public const UInt32  LbProcIdGetLbRankedEntryCount = 7;
        public const UInt32  LbProcIdResetPuid             = 8;
        public const UInt32  LbProcIdStatEnumNearPuid      = 9;
        public const UInt32  LbProcIdResetLb               = 10;
        public const UInt32  LbProcIdStatEnumNearRating    = 11;

        public const UInt32  LbProcIdDeleteLbFromMemoryOnly = 12;
        public const UInt32  LbProcIdSetLbToReadOnly        = 13;
        public const UInt32  LbProcIdSetLbToReadWrite       = 14; 
        public const UInt32  LbProcIdIsSafeToDeleteLb       = 15;
        public const UInt32  LbProcIdCreateAndLoadOneLb     = 16;
        public const UInt32  LbProcIdGetLbStatus            = 17;
        public const UInt32  LbProcIdEstimateRankForRatings = 18;
        
        public const UInt32  LbProcIdTestAutoReset         = 1001;
        public const UInt32  LbProcIdTestAutoDecay         = 1002;
        public const UInt32  LbProcIdTestChangeLastUpdateTime = 1003;
        
        // Errors
        public const UInt32 LbspErrorInvalidProcId   = 0x00000001;
        public const UInt32 LbspErrorLbAlreadyExists = 0x00000002;
        public const UInt32 LbspErrorLbDoesntExist   = 0x00000003;
        public const UInt32 LbspErrorInvalidParam    = 0x00000004;
        public const UInt32 LbspErrorFailureOccurred = 0xFFFFFFFE;
        public const UInt32 LbspErrorUnexpected      = 0xFFFFFFFF;

        public const UInt32 LbspErrorOperationNotPermitted = 0xF0000001;
        
        //********************************************************************
        // Protocol structures
        //********************************************************************
        
        // All LBSP messages start with this header
        protected struct LbspMsgHeader
        {
            // Size of the message in bytes including header
            public UInt16 wMsgSize;
            
            // Message type. One of the LbspId* constants
            public UInt16 wMsgType;
        
            public void ReadStream(BinaryReader br)
            {
                wMsgSize = br.ReadUInt16();
                wMsgType = br.ReadUInt16();
            }
            
            public void WriteStream(BinaryWriter bw)
            {
                bw.Write(wMsgSize);
                bw.Write(wMsgType);
            }
            
            public int Size
            {
                get { return 4; }
            }
        };
        
        // Sent by the client upon establishing a connection
        protected struct LbspReqHello
        {
            // Size in bytes of clientName. Maximum size is LbspMaxClientName
            public UInt16 wClientNameLen;
            
            // Client name. ANSI string. Not null terminated
            public byte[] clientName;
            
            public void SetClientName(string name)
            {
                if(name == null 
                   || name.Length <= 0
                   || name.Length > LbspMaxClientName)
                {
                    throw new ArgumentException("Invalid parameter.", "name");
                }
                
                clientName     = Encoding.ASCII.GetBytes(name);
                wClientNameLen = (UInt16) clientName.Length;
            }
            
            public void WriteStream(BinaryWriter bw)
            {
                #if DEBUG
                    Assert.IsTrue(clientName != null);
                    Assert.IsTrue(clientName.Length > 0 && clientName.Length <= LbspMaxClientName);
                    Assert.IsTrue(clientName.Length == wClientNameLen);
                #endif
                
                bw.Write(wClientNameLen);
                bw.Write(clientName);
            }
            
        };
        
        // Sent by the server in response to a LbspReqHello
        protected struct LbspRepHello
        {
            // Connection id assigned by the Leaderboard Server. The client should 
            // include the connection id on its error messages and logs.  
            public UInt32 dwCid;
            
            public void ReadStream(BinaryReader br)
            {
                dwCid = br.ReadUInt32();
            }
        };
        
        // Sent by the client to start a request
        protected struct LbspReqBeginRequest
        {
            // This is an arbitrary id assigned by the client. It will be used by
            // the server in error messages. It has no other purpose.
            public UInt32 dwReqId;

            // Number of procedures in the request
            public UInt16 wProcCount;
            
            public void ReadStream(BinaryReader br)
            {
                dwReqId    = br.ReadUInt32();
                wProcCount = br.ReadUInt16();
            }
            
            public void WriteStream(BinaryWriter bw)
            {
                bw.Write(dwReqId);
                bw.Write(wProcCount);
            }
        };

        // A procedure in a request
        protected struct LbspReqProcCall
        {
            // The id of the server procedure
            public UInt32 dwProcId;

            // Number of parameters in rgParam
            public UInt16 wParamCount;

            // Procedure parameters
            // (this array is part of this message and should be taken in
            // consideration when specifying the size of the message in the header)
            public object[] rgParam;
            
            public void ReadStream(BinaryReader br)
            {
                dwProcId = 0;
                wParamCount = 0;
                rgParam = null;
                Assert.IsTrue(false);
            }
            
            public void WriteStream(BinaryWriter bw)
            {
                wParamCount = (UInt16)rgParam.Length;
                
                bw.Write(dwProcId);
                bw.Write(wParamCount);
                
                for(int i=0; i < rgParam.Length; i++)
                {
                    object param = rgParam[i];
                    
                    if(param == null)
                    {
                        bw.Write((byte)LbspTypeIdNullFlag);
                    }
                    else if(param is sbyte)
                    {
                        bw.Write((byte)LbspTypeIdInt8);
                        bw.Write((sbyte)param);
                    }
                    else if(param is Int16)
                    {
                        bw.Write((byte)LbspTypeIdInt16);
                        bw.Write((Int16)param);
                    }
                    else if(param is Int32)
                    {
                        bw.Write((byte)LbspTypeIdInt32);
                        bw.Write((Int32)param);
                    }
                    else if(param is Int64)
                    {
                        bw.Write((byte)LbspTypeIdInt64);
                        bw.Write((Int64)param);
                    }
                    else if(param is Double)
                    {
                        bw.Write((byte)LbspTypeIdDouble);
                        bw.Write((Double)param);
                    }
                    else if(param is string)
                    {
                        byte[] binstr = Encoding.UTF8.GetBytes((string)param);
                        bw.Write((byte)LbspTypeIdString);
                        bw.Write((Int16)binstr.Length);
                        bw.Write(binstr);
                    }
                    else
                    {
                        throw new Exception("Data type not supported.");
                    }
                    
                }

                //Global.RO.Debug("Writing proc call message:\n" + ToString());
                
            }
            
            public override string ToString()
            {
                StringBuilder bldr = new StringBuilder();
                bldr.Append("dwProcId=" + dwProcId + "\n");
                bldr.Append("wParamCount=" + wParamCount + "\n");
                bldr.Append("rgParam:\n");
                for (int i = 0; i < rgParam.Length; i++)
                {
                    object param = rgParam[i];
                    
                    bldr.Append("rgParam[" + i + "]=");
                    
                    if(param == null)
                    {
                        bldr.Append("(null)");
                    }
                    else if(param is sbyte)
                    {
                        bldr.Append("(int8) ");
                        bldr.Append(((sbyte)param).ToString("x"));
                    }
                    else if(param is Int16)
                    {
                        bldr.Append("(int16) ");
                        bldr.Append(((Int16)param).ToString("x"));
                    }
                    else if(param is Int32)
                    {
                        bldr.Append("(int32) ");
                        bldr.Append(((Int32)param).ToString("x"));
                    }
                    else if(param is Int64)
                    {
                        bldr.Append("(int64) ");
                        bldr.Append(((Int64)param).ToString("x"));
                    }
                    else if(param is Double)
                    {
                        bldr.Append("(double) ");
                        bldr.Append((Double)param);
                    }
                    else if(param is string)
                    {
                        byte[] binstr = Encoding.UTF8.GetBytes((string)param);
                        bldr.Append("(string) ");
                        bldr.Append(binstr);
                    }
                    else
                    {
                        bldr.Append("Unknown type!");
                    }
                    bldr.Append("\n");
                }
                
                return bldr.ToString();
            }    
                                    
                    
            
        };

        protected struct LbspRepRowsetRow
        {
            public UInt16 wColCount;
            public object[] rgColumns;
            
            public void ReadStream(BinaryReader br)
            {
                wColCount = br.ReadUInt16();
                
                if(wColCount > LbspMaxRowsetColumns)
                    throw new LbsvrClientNetworkException("Number of rows exceeds maximum", null);
                
                rgColumns = new object[wColCount];
                
                for(int i=0; i < rgColumns.Length; i++)
                {
                    byte bType = br.ReadByte();
                    
                    if((bType & LbspTypeIdNullFlag) != 0)
                    {
                        rgColumns[i] = null;
                        continue;
                    }
                    
                    switch(bType)
                    {
                    case LbspTypeIdInt8:
                        rgColumns[i] = (object) br.ReadSByte();
                        break;
                        
                    case LbspTypeIdInt16:
                        rgColumns[i] = (object) br.ReadInt16();
                        break;
                    
                    case LbspTypeIdInt32:
                        rgColumns[i] = (object) br.ReadInt32();
                        break;
                    
                    case LbspTypeIdInt64:
                        rgColumns[i] = (object) br.ReadInt64();
                        break;
                    
                    case LbspTypeIdDouble:
                        rgColumns[i] = (object) br.ReadDouble();
                        break;
                    
                    case LbspTypeIdString:
                        UInt16 wStrSize = br.ReadUInt16();
                        
                        if(wStrSize > LbspMaxSizeStringParam)
                            throw new LbsvrClientNetworkException("Size of string column exceeds maximum", null);
                        if (wStrSize > 0)
                        {
                            byte[] binstr = br.ReadBytes(wStrSize);
                            rgColumns[i] = (object) Encoding.UTF8.GetString(binstr);
                        }
                        else
                        {
                            rgColumns[i] = (object) String.Empty;
                        }
                        
                        break;
                    
                    default:
                        throw new LbsvrClientNetworkException("Invalid column type", null);
                    }
                }
            }
        };

        protected struct LbspRepMessage
        {
            public UInt32 dwErrorId;
            public UInt16 wMsgLen;
            public string message;
            
            public void ReadStream(BinaryReader br)
            {
                dwErrorId = br.ReadUInt32();
                wMsgLen   = br.ReadUInt16();
                
                if(wMsgLen > LbspMaxSizeMessage)
                    throw new LbsvrClientNetworkException("Size of message string exceeds maximum", null);

                if (wMsgLen > 0)
                {
                    byte[] binmsg = br.ReadBytes(wMsgLen);
                    message = Encoding.UTF8.GetString(binmsg);
                }
                else
                {
                    message = String.Empty;
                }
            }
        };

        protected struct LbspRepEndRequest
        {
            public UInt32 dwReqId;
            
            public void ReadStream(BinaryReader br)
            {
                dwReqId = br.ReadUInt32();
            }
        };
        
        protected struct LbspReqPing
        {
            public UInt32 dwPing;
            
            public void WriteStream(BinaryWriter bw)
            {
                bw.Write(dwPing);
            }
        }
        
        protected struct LbspRepPing
        {
            public UInt32 dwPing;
            
            public void ReadStream(BinaryReader br)
            {
                dwPing = br.ReadUInt32();
            }
        }
        
        //********************************************************************
        // Protected methods
        //********************************************************************
        
        protected LbsvrClientBase()
        {
            _msgSendBuffer = new byte[LbspMaxSizeMessage];
            _msgSendStream = new MemoryStream(_msgSendBuffer);
            _msgBw         = new BinaryWriterWrapper(_msgSendStream);
        }

        public void SetLongCommandTimeOut()
        {
            if (null != _socket)
            {
                _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, CommandTimeoutLong);
            }
        }

        public void SetDefaultCommandTimeOut()
        {
            if (null != _socket)
            {
                _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, CommandTimeout);
            }
        }
        
        protected void InternalOpenConnection(string clientName, IPEndPoint lbsvrendpt)
        {
            InternalCloseConnection();
        
            _lbsvrendpt = new IPEndPoint(lbsvrendpt.Address, lbsvrendpt.Port);

            Assert.IsTrue(_socket == null && _netStream == null);
            
            // Connect
            try
            {
                // Create new TCP socket and connect
                _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                _socket.Connect(lbsvrendpt);
                
                // Create stream to handle socket IO. 
                _netStream = new BufferedNetworkStream(_socket, SendBufferSize, SendBufferSize);
                _netBr     = new BinaryReader(_netStream);
                _netBw     = new BinaryWriterWrapper(_netStream);
                
                // Handshake with the server
                Handshake(clientName);
            
                // Set timeout settings
                _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, SendTimeout);
                _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, CommandTimeout);
                
                _state = LbsvrClientState.Connected;
            }
            catch(Exception e)
            {
                if(_netStream != null)
                {
                    _netStream.Close();
                    _netStream = null;
                }
                
                if(_socket != null)
                {
                    _socket.Close();
                    _socket = null;
                }
                    
                throw new LbsvrClientNetworkException("Failed to connect to "+lbsvrendpt, e);
            }
        }

        protected void InternalCloseConnection()
        {
            if(_netStream != null)
            {
                _netStream.Close();
                _netStream = null;
            }
            
            if(_socket != null)
            {
                try
                {
                    // Try to close connection gracefully
                    _socket.Shutdown(SocketShutdown.Both);
                } 
                finally
                {
                    // Close socket
                    _socket.Close();
                    _socket = null;
                }
            }
            
            _state = LbsvrClientState.Disconnected;
        }
        
        // Reset connection state
        protected void Reset(bool fIgnoreErrors)
        {
            if (fIgnoreErrors)
            {
                _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, 500);

                BinaryReader br = GetRecvBr();
                if (br != null)
                {
                    while (-1 != br.Read())
                    { /* spin */ }

                    _state = LbsvrClientState.Connected;
                }
                else
                {
                    // we should, possibly, throw here (but what?).
                }
            }
            else
            {
                // Ignore all messages (or at least a bunch of them)
                for (int i = 0; i < 30; i++)
                {
                    if (_state == LbsvrClientState.Connected)
                        return;

                    UInt16 msgId = ProcessNextMessage();

                    if (msgId == LbspIdRepMessage)
                    {
                        if (_message.dwErrorId != 0)
                        {
                            // If message is an error, throw it now
                            if (_message.dwErrorId != 0)
                            {
                                throw new LbsvrClientRequestFailureException(
                                    "Request failure. Error=" + _message.dwErrorId + " and message is:\n" + _message.message
                                  , (int)_message.dwErrorId
                                  , null
                                );
                            }
                        }
                    }
                }

                // If we got here, we failed to reset the connection
                throw new LbsvrClientNetworkException("Failed to reset connection", null);
            }
        }
        
        protected BinaryWriter GetSendBw()
        {
            Assert.IsTrue(_wMsgType != 0, "GetSendBw cannot be called before BeginMessage.");
            return _msgBw;
        }
        
        protected BinaryReader GetRecvBr()
        {
            return _netBr;
        }

        protected void BeginMessage(UInt16 wMsgType)
        {
            Assert.IsTrue(_wMsgType == 0, "BeginMessage called with another message pending.");
            
            _wMsgType = wMsgType;
            _msgSendStream.SetLength(0);
        }
        
        protected void EndMessage()
        {
            Assert.IsTrue(_wMsgType != 0, "EndMessage called with no message pending.");
            
            // Prepare the header
            LbspMsgHeader hdr = new LbspMsgHeader();
            hdr.wMsgSize = (UInt16) (hdr.Size + _msgSendStream.Length);
            hdr.wMsgType = _wMsgType;
            
            Assert.IsTrue(hdr.wMsgSize <= LbspMaxSizeMessage);
            
            // Write the header and then the message blob
            hdr.WriteStream(_netBw);
            _netStream.Write(_msgSendBuffer, 0, (int)_msgSendStream.Length);
            
            // Reset state for the next message
            _wMsgType = 0;
            _msgSendStream.SetLength(0);
        }
        
        protected void Flush()
        {
            _netStream.Flush();
        }
        
        // Process the next message in the stream. Return the message id.
        private UInt16 ProcessNextMessage()
        {
            LbspMsgHeader hdr = new LbspMsgHeader();
            hdr.ReadStream(GetRecvBr());
            
            switch(hdr.wMsgType)
            {
                case LbspIdRepEndRequest:
                    if(_state == LbsvrClientState.ReceivingResults)
                    {
                        LbspRepEndRequest endReq = new LbspRepEndRequest();
                        endReq.ReadStream(GetRecvBr());
                        
                        if(endReq.dwReqId != _reqId)
                        {
                            throw new LbsvrClientNetworkException(
                                "End-request message's reqId " +endReq.dwReqId+
                                " doesn't match current request id "+_reqId, null);
                        }
                        
                        _state      = LbsvrClientState.Connected;
                        _resultType = LbsvrClientResult.None;
                        break;
                    }
                    else
                    {
                        throw new LbsvrClientNetworkException("Unexpected message type " + hdr.wMsgType + 
                            "when state = " + _state.ToString(), null);
                    }
                    
                case LbspIdRepMessage:
                    if(_state == LbsvrClientState.ReceivingResults)
                    {
                        _message.ReadStream(GetRecvBr());
                        _resultType = LbsvrClientResult.Message;
                        break;
                    }
                    else 
                    {
                        throw new LbsvrClientRequestFailureException("Received non-error message response when "+
                            "when state = " + _state.ToString()+". Anyways, the message text is: " + 
                            _message.message, -1, null);
                    }
                
                case LbspIdRepRowsetStart:
                    if(_state == LbsvrClientState.ReceivingResults)
                    {
                        _state      = LbsvrClientState.ReceivingRowset;
                        _resultType = LbsvrClientResult.Rowset;
                        break;
                    }
                    else
                    {
                        throw new LbsvrClientNetworkException("Unexpected message type " + hdr.wMsgType + 
                            "when state = " + _state.ToString(), null);
                    }
                
                case LbspIdRepRowsetRow:
                    if(_state == LbsvrClientState.ReceivingRowset)
                    {
                        #if DEBUG
                        Assert.IsTrue(_resultType == LbsvrClientResult.Rowset);
                        #endif
                        _row.ReadStream(GetRecvBr());
                        break;
                    }
                    else
                    {
                        throw new LbsvrClientNetworkException("Unexpected message type " + hdr.wMsgType + 
                            "when state = " + _state.ToString(), null);
                    }
                    
                case LbspIdRepRowsetEnd:
                    if(_state == LbsvrClientState.ReceivingRowset)
                    {
                        if(hdr.wMsgSize != hdr.Size)
                            throw new LbsvrClientNetworkException("Unexpected message size", null);
                        
                        _state = LbsvrClientState.ReceivingResults;
                        break;
                    }
                    else
                    {
                        throw new LbsvrClientNetworkException("Unexpected message type " + hdr.wMsgType + 
                            "when state = " + _state.ToString(), null);
                    }
                
                default:
                    throw new LbsvrClientNetworkException("Unexpected message type " + hdr.wMsgType, null);
            }
                
            return hdr.wMsgType;
        }
        
        private void Handshake(string clientName)
        {
            // Send hello message
            _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, SendTimeout);
            BeginMessage(LbspIdReqHello);
            LbspReqHello hello = new LbspReqHello();
            hello.SetClientName(clientName);
            hello.WriteStream(GetSendBw());
            EndMessage();
            Flush();
            
            // Server should send the hello reply in timely fashion
            _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, ConnectTimeout);
            LbspMsgHeader hdr = new LbspMsgHeader();
            hdr.ReadStream(_netBr);
            
            if(hdr.wMsgType != LbspIdRepHello)
                throw new LbsvrClientNetworkException("Server send unexpected message type ("+hdr.wMsgType+"). ", null);
            
            LbspRepHello repHello = new LbspRepHello();
            repHello.ReadStream(_netBr);
            
            // This is the connection id assigned by the server
            _cid = repHello.dwCid;
            
            // We use the connection id to initialize this 'ping seed'. We'll
            // increment it each time we send a ping in an attempt to generate
            // unique values
            _pingSeed = _cid << 16;
        }
        
        private void ProcessMessageResult()
        {
            _message.ReadStream(GetRecvBr());
            
            if(_message.dwErrorId != 0)
                throw new LbsvrClientRequestFailureException("Request failure. Error="+_message.dwErrorId+
                    " and message is:\n" + _message.message, (int)_message.dwErrorId, null);
        }
        
        //********************************************************************
        // Protected members
        //********************************************************************
        
        protected const int SendBufferSize      = 8192;    // TODO: config
        protected const int ConnectTimeout      = 5000;
        protected const int SendTimeout         = 5000;
        protected const int PingTimeout         = 1000;
        protected const int CommandTimeout      = 60000; 
        protected const int CommandTimeoutLong  = 1200000; 
        
        protected IPEndPoint _lbsvrendpt;
        protected LbsvrClientState _state  = LbsvrClientState.Disconnected;
        protected UInt16 _wMsgType         = 0;
        protected byte[] _msgSendBuffer    = null;
        protected MemoryStream _msgSendStream = null;
        protected BinaryWriterWrapper _msgBw      = null;
        
        protected Socket _socket           = null;
        protected BufferedNetworkStream _netStream = null;
        protected BinaryWriterWrapper _netBw      = null;
        protected BinaryReader _netBr      = null;
        
        protected UInt32 _cid              = 0;
        protected UInt32 _reqId            = 0;
        protected UInt32 _pingSeed         = 0;
        
        protected LbspRepMessage _message  = new LbspRepMessage();
        protected LbspRepRowsetRow _row    = new LbspRepRowsetRow();
        protected LbsvrClientResult _resultType = LbsvrClientResult.None;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\LB64\TestCasesFunctional.cs ===
using System;
using System.Text;
using System.Collections.Generic;

using System.Threading;

using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService.Stats.Util;

//using xonline.common.diagnostics;
//using xonline.common.config;

//using xonline.server.stats.common;

namespace LB64
{
    public partial class LB64Tests : TestNode
    {
        #region Notes

        // 8k pages
        //
        // Bits Bytes   Name    Hex
        // ------------------------------------------
        // 8    1       BYTE    0x00
        // 16   2       WORD    0x0000
        // 32   4       DWORD   0x0000 0000
        // 64   8       QWORD   x00000 0000 0000 0000
        //
        //
        // Page Header
        // ====================
        // Flags            2
        // Size             2
        // EntryCount       2
        // FreeOffset       2
        // FreeSpace        2
        // AvailSpace       2
        // LPTR             8
        // RPTR             8
        // [TOTAL (Bytes)]  28  (16?)
        //
        //
        // minimal stats post:
        //
        // Attribute    Header  Payload     Total
        // Name         Size    Size        Size
        //              (Bytes) (Bytes)     (Bytes)
        // ========================================
        // <oh-Offset>  8       0           22
        // User ID      2       8           10
        // Rating       2       8           10
        //
        //             [TOTAL SIZE (Bytes)] 42
        //

        // 12 + 48x = 8 * 1024
        // x = 170+

        #endregion // Notes

        [
         TestCase,
         Owner("jeffng"), TestFrequency("Regression"),
         Description("Verify that the when a page becomes fragmented the available space is intelligently used.")
        ]
        public class PageFragmentationsAndDefragmentation : LB64TestBase
        {
            LbsvrClientConnection _con;

            uint _titleId = 0x00000001;
            uint _lbId    = 0x00000001;

            #region Helper Functions

            private int RatingFromRow(uint Row)
            {
                return ((int)((UInt32.MaxValue / 2) - Row));
            }

            private object[] GenProcBlob(uint Row, uint AttributeCount)
            {
                object[] procBlob = null;

                UInt64 userId = Row + 1;

                // LBSVR Expects attributes in ascending order.
                // That's ascending order, assuming we are dealing with unsinged shorts.
                // Even though we have to pass it signed shorts.
                // Thus: SpecialAttribute(s) must come last (and in order... of course)

                // Generate the attributes we are going to post
                object[] attributes = new object[AttributeCount * 2];
                if (attributes.Length > 0)
                {
                    for (int j = 0; j < attributes.Length - 2; j += 2)
                    {
                        attributes[j]     = (Int16)j;                  // Attribute Header
                        attributes[j + 1] = (Int64)(userId << 32 + j); // Attribute Value
                    }

                    // Rating
                    int rating = RatingFromRow(Row);
                    attributes[attributes.Length - 2] = (Int16)SpecialAttrib.Rating;
                    attributes[attributes.Length - 1] = (Int64)rating;
                }

                // Generate ProcCall Blob
                procBlob = LbSvr.GenerateStatWriteBlob(
                    _titleId,   // Title Id
                    _lbId,      // Leaderboard Id
                    Row,        // User Id
                    0,          // Session Start Time
                    attributes  // Attributes to Post
                );

                return procBlob;
            }

            private object[] ZeroToTenByOne(uint TitleId, uint LbId, uint Row)
            {
                // We ignore TitleId and LbId, since we already have them as
                // private variables.  GenProcBlob simply accesses those.

                uint attributeCount = (((Row / 2) % 10) + 1);
                return GenProcBlob(Row, attributeCount);
            }

            private object[] TwentyToZeroByTwo(uint TitleId, uint LbId, uint Row)
            {
                // We ignore TitleId and LbId, since we already have them as
                // private variables.  GenProcBlob simply accesses those.

                uint attributeCount = (20 - ((Row % 42) / 2));
                return GenProcBlob(Row, attributeCount);
            }

            private void RemoveOddEntries(uint TotalRows)
            {
                for (int row = 1; row < TotalRows; row += 2)
                {
                    LbSvr.ExecuteSingleProcCall(
                        _con,
                        LbsvrClientConnection.LbProcIdResetPuid,
                        new object[] {
                            (Int32)_titleId,    // Title Id
                            (Int32)_lbId,       // Leaderboard Id
                            (Int64)row          // User Id
                        }
                    );

                    LbSvr.FlushResults(_con);
                }
            }

            #endregion // Helper Functions

            protected override void Execute()
            {
                ServerIndex server = ServerIndex.LB64;

                _con = LbSvr.OpenConnection(server);

                // Create Leaderboard
                LbSvr.CreateLeaderboard(server, _titleId, _lbId);

                // Fill the leaderboard and save the number of rows added (minus the padding entry), we will need it later
                uint rowCount = FillFirstLeaderboardPage(_con, _titleId, _lbId, ZeroToTenByOne);

                // Verify we only have one leaf node (the root node, in this case)
                VerifyNodeCountForLeaderboard(1, server, _titleId, _lbId);

                // Remove every odd entry (except for the last, padding entry)
                RemoveOddEntries(rowCount);

                // Add back the same entries, but in reverse
                for (uint row = rowCount; row >= 1; row -= 2)
                {
                    object[] procBlob = ZeroToTenByOne(_titleId, _lbId, row);

                    LbSvr.ExecuteSingleProcCall(_con, LbsvrClientConnection.LbProcIdStatWrite, procBlob);
                    LbSvr.FlushResults(_con);
                }

                // Verify we still only have one leaf node
                VerifyNodeCountForLeaderboard(1, server, _titleId, _lbId);

                // Remove every odd entry again
                RemoveOddEntries(rowCount);

                // Add new entries with attributes from 20 down to 6 by 2 ( 20, 18, 16, ..., 4, 2 )
                // (ensuring that compaction must occur to keep them on one page)
                for (uint row = 0; row < rowCount / 2; row += 2)
                {
                    object[] procBlob = TwentyToZeroByTwo(_titleId, _lbId, row);

                    LbSvr.ExecuteSingleProcCall(_con, LbsvrClientConnection.LbProcIdStatWrite, procBlob);
                    LbSvr.FlushResults(_con);
                }

                // Verify we still only have the one leaf node... sheesh, like this is gonna change, right?  Right?
                VerifyNodeCountForLeaderboard(1, server, _titleId, _lbId);

                // Delete Leaderboard
                LbSvr.DeleteLeaderboard(server, _titleId, _lbId);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [
         TestCase,
         Owner("jeffng"), TestFrequency("Regression"),
         Description("Verify minimal split and merge functionality.")
        ]
        public class PageMergeAndSplit : LB64TestBase
        {
            LbsvrClientConnection _con;

            uint _titleId = 0x00000001;
            uint _lbId    = 0x00000001;

            #region Helper Functions

            private void CauseSplit()
            {
                ulong nodeCountAtStart = GetNodeCountForLeaderboard(ServerIndex.LB64, _titleId, _lbId);

                // Fill LB until we force a node to split
                uint userId = 1;
                ulong nodeCount = nodeCountAtStart;
                while (nodeCount == nodeCountAtStart)
                {
                    object[] procBlob = LbSvr.GenerateStatWriteBlob(
                        _titleId,   // Title Id
                        _lbId,      // Leaderboard Id
                        userId,     // User Id
                        0,          // Session Start Time

                        // Attributes
                        new object[] {
                            (Int16)SpecialAttrib.Rating,
                            (Int64)(-userId)
                        }
                    );

                    LbSvr.ExecuteSingleProcCall(
                        _con,
                        LbsvrClientConnection.LbProcIdStatWrite,
                        procBlob
                    );
                    LbSvr.FlushResults(_con);

                    nodeCount = GetNodeCountForLeaderboard(ServerIndex.LB64, _titleId, _lbId);
                    ++userId;
                }

                if (nodeCount < nodeCountAtStart)
                {
                    throw new Exception("We somehow merged while attempting to split");
                }
            }

            private void CauseMerge()
            {
                ulong nodeCountAtStart = GetNodeCountForLeaderboard(ServerIndex.LB64, _titleId, _lbId);

                // Remove entries from the LB until we cause a merge
                int userId = 1;
                ulong nodeCount = nodeCountAtStart;
                while (nodeCount == nodeCountAtStart)
                {
                    LbSvr.ExecuteSingleProcCall(
                        _con,
                        LbsvrClientConnection.LbProcIdResetPuid,
                        new object[] {
                            (Int32)_titleId,    // TitleId
                            (Int32)_lbId,       // Leaderboard Id
                            (Int64)userId       // User Id
                        }
                    );
                    LbSvr.FlushResults(_con);

                    nodeCount = GetNodeCountForLeaderboard(ServerIndex.LB64, _titleId, _lbId);
                    ++userId;
                }

                if (nodeCount > nodeCountAtStart)
                {
                    throw new Exception("We somehow split while attempting to merge");
                }
            }

            #endregion // Helper Functions

            protected override void Execute()
            {
                ServerIndex server = ServerIndex.LB64;

                _con = LbSvr.OpenConnection(ServerIndex.LB64);

                LbSvr.CreateLeaderboard(ServerIndex.LB64, _titleId, _lbId);

                // Verify one page
                VerifyNodeCountForLeaderboard(1, server, _titleId, _lbId);

                CauseSplit();

                // Verify three pages (root-node split scenario)
                VerifyNodeCountForLeaderboard(3, server, _titleId, _lbId);

                CauseSplit();

                // Verify four pages (child-node split scenario)
                VerifyNodeCountForLeaderboard(4, server, _titleId, _lbId);

                CauseMerge();
                
                // Verify three pages (child-node merge scenario)
                VerifyNodeCountForLeaderboard(3, server, _titleId, _lbId);

                CauseMerge();

                // Verify one page (root-node merge scenario)
                VerifyNodeCountForLeaderboard(1, server, _titleId, _lbId);

                LbSvr.DeleteLeaderboard(server, _titleId, _lbId);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // This cannot happen without a reset puid!  If we write additional items, they just get added, the
        // old never go away.
        [
         Ignore,
         TestCase,
         Owner("jeffng"), TestFrequency("Regression"),
         Description(
             "Create a leaderboard with all ratings == null, the LB Server should generate an 'Untier' which "
           + "will rank users in the order they were added to the leaderboard. This is an interesting scenario "
           + "as, if you change the number of attachments for a user, but their rank does not change (or they "
           + "have no rating in the first place), the offsets in the btree do not change, but the data they point "
           + "to shifts around.  We should be able to cause a page-split, even though we aren't really adding a new entry."
         )
        ]
        public class NoRankedEntries : LB64TestBase
        {
            LbsvrClientConnection _con;

            uint _titleId = 0x00000001;
            uint _lbId    = 0x00000001;

            #region Helper Functions

            private object[] BlobForRowDelegate(uint TitleId, uint LbId, uint Row)
            {
                return LbSvr.GenerateStatWriteBlob(
                    _titleId,   // Title Id
                    _lbId,      // Leaderboard Id
                    Row + 1,    // User Id
                    0,          // Session Start Time

                    // Attributes
                    new object[] {
                        (Int16)1337,                    // (k) User Att 1
                        (Int64)0,                       // (v) User Att 2

                        (Int16)SpecialAttrib.Rating,    // (k) Rating
                        (Int64)(-(Row+1))               // (v) Rating
                    }
                );
            }

            #endregion Helper Functions

            protected override void Execute()
            {
                ServerIndex server = ServerIndex.LB64;

                _con = LbSvr.OpenConnection(ServerIndex.LB64);

                LbSvr.CreateLeaderboard        ( server , _titleId , _lbId                      );
                FillFirstLeaderboardPage ( _con   , _titleId , _lbId , BlobForRowDelegate );
                
                // Verify one page
                VerifyNodeCountForLeaderboard(1, server, _titleId, _lbId);

                // Increase the number of attributes for an entry without changing its rank
                object[] procAddBlob = LbSvr.GenerateStatWriteBlob(
                    _titleId,   // Title Id
                    _lbId,      // Leaderboard Id
                    1,          // User Id
                    0,          // Session Start Time

                    // Attributes
                    new object[] {
                        (Int16)1337,                    // (k) User Att 1
                        (Int64)0,                       // (v) User Att 1
                        (Int16)31337,                   // (k) User Att 2 [new]
                        (Int64)0,                       // {v) User Att 2 [new]

                        (Int16)SpecialAttrib.Rating,    // (k) Rating
                        (Int64)(-1),                    // (v) Rating
                    }
                );

                LbSvr.ExecuteSingleProcCall(_con, LbsvrClientConnection.LbProcIdStatWrite, procAddBlob);
                LbSvr.FlushResults(_con);

                // Verify three pages (root node split scenario)
                VerifyNodeCountForLeaderboard(3, server, _titleId, _lbId);

                // Decrease the number of attributes on another entry by the same amount
                object[] procDelBlob = LbSvr.GenerateStatWriteBlob(
                    _titleId,   // Title Id
                    _lbId,      // Leaderboard Id   
                    2,          // User Id
                    0,          // Session Start Time

                    // Attributes
                    new object[] {
                        (Int16)SpecialAttrib.Rating,    // (k) Rating
                        (Int64)(-2)                     // (v) Rating
                        // Removed: (k,v) User Att 1
                    }
                );

                LbSvr.ExecuteSingleProcCall(_con, LbsvrClientConnection.LbProcIdStatWrite, procDelBlob);
                LbSvr.FlushResults(_con);

                // Verify one page (root node merge scenario)
                VerifyNodeCountForLeaderboard(1, server, _titleId, _lbId);

                LbSvr.DeleteLeaderboard(server, _titleId, _lbId);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //No ZDT Migration--Ignoring this test case.
        [
         TestCase, Ignore, 
         Owner("jeffng"), TestFrequency("Regression"),

         Description("[ZDT Upgrade Scenario] Verify that we can move a leaderboard from one server to another (64-2-64).")
        ]
        public class Migration : LB64ZDT
        {
            uint _titleId = 0x00000001;
            uint _lbId    = 0x00000002;

            protected override void Execute()
            {
                uint rowCount = 100;

                LbsvrClientConnection con64a = LbSvr.OpenConnection(ServerIndex.LB64);
                MigrationState         ms64a = MigrationState.None;

                LbsvrClientConnection con64b = LbSvr.OpenConnection(ServerIndex.LB64b);
                MigrationState         ms64b = MigrationState.None;

                try
                {
                    // On Server 1
                    ///////////////////////////

                    // Fill LB
                    LbSvr.CreateLeaderboard ( ServerIndex.LB64 , _titleId , _lbId                             );
                    AddRowsToLeaderboard    ( con64a           , _titleId , _lbId , rowCount , DescendingRank );

                    ms64a |= ( MigrationState.LbExists | MigrationState.LbLivesHere );

                    // Set LB Read Only
                    LbSvr.ExecuteSingleProcCall(
                        con64a,
                        LbsvrClientConnection.LbProcIdSetLbToReadOnly,
                        new object[] {
                            (Int32)_titleId,
                            (Int32)_lbId
                        }
                    );

                    LbsvrClientResult result = con64a.NextResult();
                    if (result != LbsvrClientResult.Rowset || !con64a.Read())
                    {
                        throw new Exception(
                            "Failed to set leaderboard (0x" + _titleId.ToString("X8") + ":0x" + _lbId.ToString("X8") + ") to read-only"
                          + " on server '" + DBHelper.LBSname((int)ServerIndex.LB64) + "'."
                        );
                    }

                    uint swapSeed = (uint)(Int32)con64a.GetColumn(0);
                    con64a.Reset();

                    ms64a |= MigrationState.LbIsReadOnly;

                    // Wait until all delayed writes have finished and it is ok to delete
                    WaitForDelayedWrites(con64a, _titleId, _lbId, swapSeed);

                    ms64a |= MigrationState.LbHasNoPendingWrites;

                    // On Server 2
                    ///////////////////////////

                    // Load LB on new server
                    LbSvr.ExecuteSingleProcCall(
                        con64b,
                        LbsvrClientConnection.LbProcIdLoadLb,
                        new object[] {
                                        (Int32)_titleId,
                                        (Int32)_lbId
                                     }
                    );

                    LbSvr.FlushResults(con64b);

                    ms64b |= MigrationState.LbExists | MigrationState.LbIsReadOnly;

                    // Set Leaderboard Read-Write
                    LbSvr.ExecuteSingleProcCall(
                        con64b,
                        LbsvrClientConnection.LbProcIdSetLbToReadWrite,
                        new object[] {
                            (Int32)_titleId,
                            (Int32)_lbId
                        }
                    );

                    LbSvr.FlushResults(con64b);

                    ms64b &= ~MigrationState.LbIsReadOnly;

                    // Update the server on which the leaderboard lives in NPDB
                    UpdateServerForLb(_titleId, _lbId, ServerIndex.LB64b);

                    ms64a &= ~MigrationState.LbLivesHere;
                    ms64b |=  MigrationState.LbLivesHere;


                    // On Server 1
                    ///////////////////////////

                    // Remove LB from old server
                    LbSvr.ExecuteSingleProcCall(
                        con64a,
                        LbsvrClientConnection.LbProcIdDeleteLbFromMemoryOnly,
                        new object[] {
                            (Int32)_titleId,
                            (Int32)_lbId
                        }
                    );

                    LbSvr.FlushResults(con64a);

                    ms64a = MigrationState.None;


                    // On Server 2
                    ///////////////////////////

                    VerifyLbContents(con64b, _titleId, _lbId, rowCount, DescendingRank);

                    LbSvr.DeleteLeaderboard(ServerIndex.LB64b, _titleId, _lbId);

                    ms64b = MigrationState.None;
                }
                catch (Exception e)
                {/*
                    string errorText;

                    Exception ne = new Exception();
                    ne.Message = "Cleaning up partially migrated leaderboard...\n";
                    ne.InnerException = e;

                    CleanupLb(ServerIndex.LB64 , ms64a, _titleId, _lbId, out errorText);
                    ne.Message += errorText + "\n";

                    CleanupLb(ServerIndex.LB64b, ms64b, _titleId, _lbId, out errorText);
                    ne.Message += errorText + "\n";

                    throw ne;
                 //*/
                    Exception bs = e;
                    throw;
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }


        //This case removed because we no longer have any 32-bit LB servers.
/*
        [
            TestCase,
         Description("[ZDT Upgrade Scenario] Verify that we can move a leaderboard from one server to another (32-2-64).")
        ]
        public class Upgrade32to64 : LB64ZDT
        {
            uint _titleId = 0x00000001;
            uint _lbId    = 0x00000003;

            protected override void Execute()
            {
                uint rowCount = 100;

                LbsvrClientConnection con32 = LbSvr.OpenConnection(ServerIndex.LB32);
                LbsvrClientConnection con64 = LbSvr.OpenConnection(ServerIndex.LB64);

                // On Server 1 (32-bit)
                {
                    // Fill LB
                    LbSvr.CreateLeaderboard ( ServerIndex.LB32 , _titleId , _lbId                             );
                    AddRowsToLeaderboard    ( con32            , _titleId , _lbId , rowCount , DescendingRank );

                    // Set LB Read Only
                    LbSvr.ExecuteSingleProcCall(
                       con32,
                       LbsvrClientConnection.LbProcIdSetLbToReadOnly,
                       new object[] {
                            (Int32)_titleId,
                            (Int32)_lbId
                        }
                   );

                    LbsvrClientResult result = con32.NextResult();
                    if (result != LbsvrClientResult.Rowset || !con32.Read())
                    {
                        throw new Exception(
                            "Failed to set leaderboard (" + _titleId + ":" + _lbId + ") to read-only"
                          + " on server '" + DBHelper.LBSname((int)ServerIndex.LB32) + "'."
                        );
                    }

                    uint swapSeed = (uint)(Int32)con32.GetColumn(0);
                    con32.Reset();

                    // Wait until all delayed writes have finished and it is ok to delete
                    WaitForDelayedWrites(con32, _titleId, _lbId, swapSeed);
                }

                // On Server 2
                // Load LB on new server
                LbSvr.ExecuteSingleProcCall(
                    con64,
                    LbsvrClientConnection.LbProcIdCreateAndLoadOneLb,
                    new object[] {
                        (Int32)_titleId,
                        (Int32)_lbId
                    }
                );

                LbSvr.FlushResults(con64);

                // On Server 2
                // Set Leaderboard Read-Write
                LbSvr.ExecuteSingleProcCall(
                    con64,
                    LbsvrClientConnection.LbProcIdSetLbToReadWrite,
                    new object[] {
                        (Int32)_titleId,
                        (Int32)_lbId
                    }
                );

                LbSvr.FlushResults(con64);

                // Update the server on which the leaderboard lives in NPDB
                UpdateServerForLb(_titleId, _lbId, ServerIndex.LB64);

                // On Server 1
                // Remove LB from old server
                LbSvr.ExecuteSingleProcCall(
                    con32,
                    LbsvrClientConnection.LbProcIdDeleteLbFromMemoryOnly,
                    new object[] {
                        (Int32)_titleId,
                        (Int32)_lbId
                    }
                );

                LbSvr.FlushResults(con32);

                VerifyLbContents(con64, _titleId, _lbId, rowCount, DescendingRank);

                LbSvr.DeleteLeaderboard(ServerIndex.LB64, _titleId, _lbId);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
*/
        [
         TestCase,
         Owner("jeffng"), TestFrequency("Regression"),
         Description("Create a LB with a tree of Depth 3.")
        ]
        public class TreeOfDepth3 : LB64TestBase
        {
            uint _titleId = 0x00000001;
            uint _lbId    = 0x00000001;

            protected override void Execute()
            {
                uint rowCount = 55955;
                ServerIndex server = ServerIndex.LB64;

                // Simply add entries till we get to the proper 'size' (use multiple threads to fill Lb more quickly: 60ish?)
                // 8KB Page Size
                // 30B per INTERNAL_NODE entry
                // 40B per EXTERNAL_NODE entry
                // Approx 55910 Entries with approx 2 MB of memory usage

                LbsvrClientConnection con = LbSvr.OpenConnection(server);

                LbSvr.CreateLeaderboard    ( server , _titleId , _lbId                            );
                AddRowsToLeaderboard ( con    , _titleId , _lbId , rowCount , DescendingRank );

                // If we can create it and it doesn't die, I'm happy.  Nothing else to see here, move along.
                LbSvr.DeleteLeaderboard(server, _titleId, _lbId);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\LB64\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\SyncAvatarManifest.cs ===
﻿using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.AvatarAsset;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;


namespace GamerSettings
{
    /// <summary>
    /// SyncAvatarManifest tests for syncing the setting XPROFILE_GAMERCARD_AVATAR_INFO_1
    /// which is now validated by the server
    /// </summary>
    public class SyncAvatarManifest : TestNode
    {
        public SyncAvatarManifest()
        {
            // Positive Cases
            AddChild(new P_SyncAvatarManifestTOCOnly(Titles.Global));
            AddChild(new P_SyncAvatarManifestTOCandAwarded(Titles.Global));
            AddChild(new P_SyncAvatarManifestTOCandPurchased(Titles.Global));
            AddChild(new P_SyncAvatarManifestAllTypes(Titles.Global));       //BVT case
            AddChild(new P_SyncAvatarManifestAwardedItemsNotSynced(Titles.Global));
            
            // Negative Cases
            AddChild(new N_SyncAvatarEmptyManifest(Titles.Global));
            AddChild(new N_SyncAvatarManifestTruncated(Titles.Global));
            AddChild(new N_SyncAvatarManifestInvalidVersion(Titles.Global));
            AddChild(new N_SyncAvatarManifestWithPurchasedButNotInTable(Titles.Global));
            AddChild(new N_SyncAvatarManifestWithPurchasedButNotInTableWithPreviousGoodManifest(Titles.Global));
            AddChild(new N_SyncAvatarManifestAwardedNotAchievableFlag(Titles.Global));
            AddChild(new N_SyncAvatarManifestAwardedItemsNotSyncedNot360Platform(Titles.Global));
        }

        public static void verifyXErrorNum(uint actual, uint expected)
        {
            if (actual != expected)
                throw new Exception("Expected HR: " + expected.ToString("X") +
                                    " but received:" + actual.ToString("X"));
        }
    }
    // Standard avatar with only TOC version 0 items worn
    [TestFrequency("Daily"), TestCasePriority(1), Description("Sync Manifest for TOC only Avatar")]
    public class P_SyncAvatarManifestTOCOnly : UserSettingBase
    {
        public P_SyncAvatarManifestTOCOnly(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            Userid = GetUser("User11");
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // avatar manifest created using avatar editor, TOC only items
            string manifestToc = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410003C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestToc));

            Global.RO.Info("Sync Avatar Info Setting");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            req.Slot.ChangeClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);  //explicitly set the 360 client type
            SyncSettingsResponse resp = req.Execute();

            Global.RO.Info("Validate the data stored");
            verifyXerror(resp);
            verifyByReading(settings);
        }
    }
    // TOC items with 1 avatar awarded item in the manifest. 
    [TestFrequency("Daily"), TestCasePriority(1), Description("Sync Manifest for TOC/Awards Avatar")]
    public class P_SyncAvatarManifestTOCandAwarded : UserSettingBase
    {
        public P_SyncAvatarManifestTOCandAwarded(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            Userid = GetUser("User12");
            // Clear this users settings and avatar assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarAssets(Userid);
        }

        protected override void run()
        {
            uint avatarTitle = 50;
            // starting with a TOC only avatar editor created avatar, replace an item 
            // with my own avatar asset from my Title 50
            string manifestTocandAwarded = "00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AC0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002670003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF0D0D0DFFEB7D80FF917A51FF0D0D0DFFF3BC7BFF0D0D0DFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E000200000000000000000000000000000"; 
            // this is the hat asset from Title50 asset 3
            manifestTocandAwarded += "0000004000034103CF4EE4BA00000032";
            // the rest of the manifest
            manifestTocandAwarded += "004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E0003557FA53576C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            Global.RO.Info("Sync Single Avatar Asset");
            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1);
            XRLSyncAvatarAssets avreq = new XRLSyncAvatarAssets(avatarTitle, Userid, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse avresp = avreq.Execute();
            // Verify the response was ok
            if (avresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server: " + avresp.xResult);

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestTocandAwarded));

            Global.RO.Info("Sync Avatar Info Setting");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            req.Slot.ChangeClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);  //explicitly set the 360 client type
            SyncSettingsResponse resp = req.Execute();

            Global.RO.Info("Validate the data stored");
            verifyXerror(resp);
            verifyByReading(settings);
        }
    }
    // Sync a manifest with TOC and a single purchased avatar item, no awardables
    [TestFrequency("Daily"), TestCasePriority(1), Description("Sync Manifest for TOC/Purchased Avatar")]
    public class P_SyncAvatarManifestTOCandPurchased : UserSettingBase
    {
        public P_SyncAvatarManifestTOCandPurchased(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            Userid = GetUser("User13");
            // Clear this users settings and any purchased avatar assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarPurchasedAssets(Userid);
        }

        protected override void run()
        {
            // Need to create a goood manifest that has avatar awards in it
            string manifestTOCAndPurchased = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410203C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            Guid guidPurchased = new Guid("00000004-0241-0203-C1C8-F109A19CB2E0");

            Global.RO.Info("Adding the Purchased Avatar GUID to the database for User puid 9013");
            ProgressWS.InsertPurchasedAvatarAsset(Userid, guidPurchased);

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestTOCAndPurchased));

            Global.RO.Info("Sync Avatar Info Setting");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            req.Slot.ChangeClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);  //explicitly set the 360 client type
            SyncSettingsResponse resp = req.Execute();

            Global.RO.Info("Validate the data stored");
            verifyXerror(resp);
            verifyByReading(settings);
        }
    }
    // Sync a manifest that has TOC, Awardable and purchased avatar items
    [TestFrequency("Daily"), BVT, TestCasePriority(1), Description("Sync Manifest for TOC/Award/Purchased Avatar")]
    public class P_SyncAvatarManifestAllTypes : UserSettingBase
    {
        public P_SyncAvatarManifestAllTypes(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            Userid = GetUser("User14");
            // Clear this users settings, avatar awards and purchased avatar items
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarAssets(Userid);
            ProgressWS.ResetUserAvatarPurchasedAssets(Userid);
        }

        protected override void run()
        {
            Guid guidPurchased = new Guid("00001000-0005-4203-C111-01235841089A");
            // the starting manifest for my avatar
            string manifestAll = "00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AC0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002670003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF0D0D0DFFEB7D80FF917A51FF0D0D0DFFF3BC7BFF0D0D0DFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E000200000000000000000000000000000"; 
            // this is the hat asset from Title50 asset 3
            manifestAll += "0000004000034103CF4EE4BA00000032";
            // this is the stuff after the hat setting, before the carryable
            manifestAll += "00400000000000000000000000000000";
            // this is the carryable, purchased item GUID
            manifestAll += "0000100000054203C11101235841089A";
            // this is the rest of the manifest
            manifestAll += "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E0003557FA53576C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            Global.RO.Info("Adding the Purchased Avatar GUID to the database for User puid 9013");
            ProgressWS.InsertPurchasedAvatarAsset(Userid, guidPurchased);

            Global.RO.Info("Sync Single Asset");
            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1);
            XRLSyncAvatarAssets avreq = new XRLSyncAvatarAssets(50, Userid, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse avresp = avreq.Execute();
            // Verify the response was ok
            if (avresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server: " + avresp.xResult);

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestAll));

            Global.RO.Info("Sync Avatar Info Setting");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            req.Slot.ChangeClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);  //explicitly set the 360 client type
            SyncSettingsResponse resp = req.Execute();

            Global.RO.Info("Validate the data stored");
            verifyXerror(resp);
            verifyByReading(settings);
        }
    }

    // Sync'ing a manifest that isn't yet in the t_avatar_awarded_items table is ok
    // because the sync setting calls happens before the sync avatar assets call, so it
    // won't yet be in the table.
    public class P_SyncAvatarManifestAwardedItemsNotSynced : UserSettingBase
    {
        public P_SyncAvatarManifestAwardedItemsNotSynced(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            Userid = GetUser("User15");
            // Clear this users settings and avatar assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarAssets(Userid);
        }
        protected override void run()
        {
            string manifestTocandAwarded = "00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AC0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002670003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF0D0D0DFFEB7D80FF917A51FF0D0D0DFFF3BC7BFF0D0D0DFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E000200000000000000000000000000000";
            // this is the hat asset from Title50 asset 3
            manifestTocandAwarded += "0000004000034103CF4EE4BA00000032";
            manifestTocandAwarded += "004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E0003557FA53576C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
     
            // Don't sync an avatar asset here, but add it to the avatar manifest
            // because on the client you could have earned and done this offline and then when you sync
            // it will sync the manifest first
            Global.RO.Info("Not calling SyncAvatarAsset as I want the db to be empty");

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestTocandAwarded));

            Global.RO.Info("Sync Avatar Info Setting");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            req.Slot.ChangeClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);  //explicitly set the 360 client type
            SyncSettingsResponse resp = req.Execute();

            Global.RO.Info("Validate the data is stored");
            verifyXerror(resp);
            verifyByReading(settings);
        }
    }

    // Try sync'ing an avatar manifest that is empty
    [TestFrequency("Daily"), TestCasePriority(1), Description("Sync Empty Manifest which should fail")]
    public class N_SyncAvatarEmptyManifest : UserSettingBase
    {
        public N_SyncAvatarEmptyManifest(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            Userid = GetUser("User16");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // Need to create a goood manifest that has avatar awards in it
            string manifestEmpty = "";

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestEmpty));

            Global.RO.Info("Sync Avatar Info Setting empty");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            req.Slot.ChangeClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);  //explicitly set the 360 client type
            SyncSettingsResponse resp = req.Execute();

            // Validate that we get a new version of the manifest back because the server updated it
            SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, null, resp.Version);
            SyncSettingsResponse resp2 = req2.Execute();

            Global.RO.Info("Validate the zero'd manifest is now returned");
            verifyXerror(resp);
            if (resp2.Settings[0].ValueLen != 0)
                throw new Exception("Setting ValueLen is not 0. Received: " + resp2.Settings[0].ValueLen);
        }
    }

    // Try sync'ing an avatar manifest that is truncated and not the full bytes
    public class N_SyncAvatarManifestTruncated : UserSettingBase
    {
        public N_SyncAvatarManifestTruncated(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            Userid = GetUser("User17");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // Just truncated a good TOC only manifest so it's not all there.
            string manifestTruncated = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F8";

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestTruncated));

            Global.RO.Info("Sync Avatar Info Setting truncated");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            req.Slot.ChangeClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);  //explicitly set the 360 client type
            SyncSettingsResponse resp = req.Execute();

            // Validate that we get a new version of the manifest back because the server updated it
            SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, null, resp.Version);
            SyncSettingsResponse resp2 = req2.Execute();

            Global.RO.Info("Validate the zero'd manifest is now returned");
            verifyXerror(resp);
            if (resp2.Settings[0].ValueLen != 0)
                throw new Exception("Setting ValueLen is not 0. Received: " + resp2.Settings[0].ValueLen);        
        }
    }

    // Sync a manifest that has an incorrect allowed version of 15
    // currently only 1,2, and 3 are valid.
    public class N_SyncAvatarManifestInvalidVersion : UserSettingBase
    {
        public N_SyncAvatarManifestInvalidVersion(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            Userid = GetUser("User18");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // Based off a good TOC only manifest with a bad version in it of 15 (F)
            string manifestInvalid = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410F03C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestInvalid));

            Global.RO.Info("Sync Avatar Info Setting with bad version");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            SyncSettingsResponse resp = req.Execute();

            // Should fail, verify by reading no value for this user from cache
            Global.RO.Info("Validate no value is saved to the server");
            verifyXerror(resp);
            verifyByReadingNoValue(settings);
        }
    }

    // Unlike the avatar assets items being ok to be empty from the table for the manifest sync,
    // the purchased items MUST be in the table to not fail.
    public class N_SyncAvatarManifestWithPurchasedButNotInTable : UserSettingBase
    {
        public N_SyncAvatarManifestWithPurchasedButNotInTable(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            Userid = GetUser("User19");
            // reset the user and purchased assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarPurchasedAssets(Userid);
        }

        protected override void run()
        {
            // Need to create a goood manifest that has avatar awards in it
            string manifestTOCAndPurchased = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410203C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            // Don't add the row into the table, so this will fail validation

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestTOCAndPurchased));

            Global.RO.Info("Sync Avatar Info Setting with purchased items but no purchased item in the table");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            req.Slot.ChangeClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);  //explicitly set the 360 client type
            SyncSettingsResponse resp = req.Execute();

            // Should fail, verify by reading no value for this user from cache
            Global.RO.Info("Validate no value is saved to the server");
            verifyXerror(resp);
            verifyByReadingNoValue(settings);
        }
    }
    public class N_SyncAvatarManifestWithPurchasedButNotInTableWithPreviousGoodManifest : UserSettingBase
    {
        public N_SyncAvatarManifestWithPurchasedButNotInTableWithPreviousGoodManifest(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            Userid = GetUser("User19");
            // reset the user and purchased assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarPurchasedAssets(Userid);
        }

        protected override void run()
        {
            // avatar manifest created using avatar editor, TOC only items
            string manifestToc = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410003C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestToc));

            Global.RO.Info("Sync Avatar Info Setting with only TOC items");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            SyncSettingsResponse resp = req.Execute();

            Global.RO.Info("Validate the data stored ok");
            verifyXerror(resp);
            verifyByReading(settings);

            // Need to create a goood manifest that has avatar awards in it
            string manifestTOCAndPurchased = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410203C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            // Don't add the row into the table, so this will fail validation
            UserSetting[] badSettings = new UserSetting[1];
            //int settingIDMaxSize2 = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            badSettings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestTOCAndPurchased));

            Global.RO.Info("Sync Avatar Info Setting with purchased items but no purchased item in the table");
            SyncSettingsRequest badreq = new SyncSettingsRequest(Title, Userid, badSettings, DateTime.UtcNow);
            SyncSettingsResponse badresp = badreq.Execute();

            // Should fail, verify by reading no value for this user from cache
            Global.RO.Info("Validate no value is saved to the server");
            verifyXerror(resp);
            verifyByReadingNoValue(badSettings);

            SyncSettingsRequest req2 = new SyncSettingsRequest(Title, Userid, null, badresp.Version);
            SyncSettingsResponse resp2 = req2.Execute();

            Global.RO.Info("Validate the empty manifest is now returned");
            verifyXerror(resp);
            if(resp2.Settings[0].ValueLen != 0)
                throw new Exception("Setting ValueLen is not 0. Received: " + resp2.Settings[0].ValueLen);
                
        }
    }

    // Awarded assets that have been Flagged Not Achievable for gamerscore cheaters
    // are not allowed to be worn, so we need to make sure this case fails the sync validation
    public class N_SyncAvatarManifestAwardedNotAchievableFlag : UserSettingBase
    {
        public N_SyncAvatarManifestAwardedNotAchievableFlag(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            Userid = GetUser("User20");
            // reset the user and the awarded assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarAssets(Userid);
        }

        protected override void run()
        {
            string manifestTocandAwarded = "00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AC0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002670003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF0D0D0DFFEB7D80FF917A51FF0D0D0DFFF3BC7BFF0D0D0DFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E000200000000000000000000000000000"; 
            // this is the hat asset from Title50 asset 3
            manifestTocandAwarded += "0000004000034103CF4EE4BA00000032";
            manifestTocandAwarded += "004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E0003557FA53576C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            
            uint assetOrdinal = (uint)3;

            Global.RO.Info("Sync Single Asset");
            AvatarAssetWD assets = new AvatarAssetWD(assetOrdinal, (byte)3, 1);
            XRLSyncAvatarAssets avreq = new XRLSyncAvatarAssets(50, Userid, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse avresp = avreq.Execute();
            // Verify the response was ok
            if (avresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server: " + avresp.xResult);

            Global.RO.Info("Updating Sync'ed item in UODB to have the XAVATAR_NOT_ACHIEVABLE flag");
            // Now update the database to have the XAVATAR_NOT_ACHIEVABLE flag
            ProgressWS.MarkAvatarAssetNotAchievable(Userid, 50, assetOrdinal);

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestTocandAwarded));

            Global.RO.Info("Sync Avatar Info Setting with not achievable marked assets");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            req.Slot.ChangeClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);  //explicitly set the 360 client type
            SyncSettingsResponse resp = req.Execute();

            // Should fail, verify by reading no value for this user from cache
            Global.RO.Info("Validate no value is saved to the server");
            verifyXerror(resp);
            verifyByReadingNoValue(settings);
        }
    }

    // Sync'ing a manifest that isn't yet in the t_avatar_awarded_items table is ok
    // because the sync setting calls happens before the sync avatar assets call, unless the platform
    // is not the 360, because then everything you try to equip is assumed to be sync'ed.
    public class N_SyncAvatarManifestAwardedItemsNotSyncedNot360Platform : UserSettingBase
    {
        public N_SyncAvatarManifestAwardedItemsNotSyncedNot360Platform(uint title)
        {
            Title = (uint)title;
        }
        protected override void init()
        {
            Userid = GetUser("User21");
            // Clear this users settings and avatar assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarAssets(Userid);
        }

        protected override void run()
        {
            string manifestTocandAwarded = "00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AC0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002670003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF0D0D0DFFEB7D80FF917A51FF0D0D0DFFF3BC7BFF0D0D0DFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E000200000000000000000000000000000";
            // this is the hat asset from Title50 asset 3
            manifestTocandAwarded += "0000004000034103CF4EE4BA00000032";
            manifestTocandAwarded += "004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E0003557FA53576C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            // Don't sync an avatar asset here, but add it to the avatar manifest
            // because on the client you could have earned and done this offline and then when you sync
            // it will sync the manifest first
            Global.RO.Info("Not calling SyncAvatarAsset as I want the db to be empty");

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestTocandAwarded));

            Global.RO.Info("Sync Avatar Info Setting");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            req.Slot.ChangeClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.PC);
            SyncSettingsResponse resp = req.Execute();

            // Should fail, verify by reading no value for this user from cache
            Global.RO.Info("Validate no value is saved to the server");
            verifyXerror(resp);
            verifyByReadingNoValue(settings);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\stats\test\gamersettings\ValidateAvatarManifest.cs ===
﻿using System;
using System.Collections;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.AvatarAsset;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.webplatform.livecache;

namespace GamerSettings
{
    /// <summary>
    /// ValidateAvatarManifest tests are for a new server API in xstatsfd
    /// The API is used by the client to validate an avatar manifest before sync'ing it
    /// This way the client can not allow gamerpics or full body shot sync's. 
    /// </summary>
    public class ValidateAvatarManifest : TestNode
    {
        public ValidateAvatarManifest()
        {
            // Some of these tests are the same as the SyncAvatarManifest SyncSettings API tests
            // since the validation code on the server is the same, but is now done with a 
            // new API as a separate call.
            // The other set of tests are specifically to the validation API, where we really do the bulk of 
            // the negative tests for all the different avatar manifest validation rules

            // Positive Cases
            AddChild(new P_ValidateAvatarManifest_TOCOnly());
            AddChild(new P_ValidateAvatarManifest_TOCandAwarded());
            AddChild(new P_ValidateAvatarManifest_TOCandPurchased());
            AddChild(new P_ValidateAvatarManifest_AllTypes());               //BVT case
            AddChild(new P_ValidateAvatarManifest_AwardedItemsNotSynced());
            AddChild(new P_ValidateAvatarManifest_NoChanges());
            AddChild(new P_ValidateAvatarManifest_MaxHeight());
            AddChild(new P_ValidateAvatarManifest_MinHeight());
            AddChild(new P_ValidateAvatarManifest_MaxWeight());
            AddChild(new P_ValidateAvatarManifest_MinWeight());
            AddChild(new P_ValidateAvatarManifest_ConsoleIDNotNull());
            AddChild(new P_ValidateAvatarManifest_LiveCacheClient());  // Hits LiveCache to test end to end
            AddChild(new P_Sync360AvatarManifestAwardedItemsNotSyncedWithAwardValidation());

            // Negative Cases
            AddChild(new N_ValidateAvatar_EmptyManifest());
            AddChild(new N_ValidateAvatarManifest_Truncated());
            AddChild(new N_ValidateAvatarManifest_InvalidVersion());
            AddChild(new N_ValidateAvatarManifest_WithPurchasedButNotInTable());
            AddChild(new N_ValidateAvatarManifest_AwardedNotAchievableFlag());
            AddChild(new N_SyncMobileAvatarManifestAwardedItemsNotSyncedWithAwardValidation());
            AddChild(new N_ValidateAvatarManifest_InvalidBodyType());
            AddChild(new N_ValidateAvatarManifest_InvalidHeadType());
            AddChild(new N_ValidateAvatarManifest_EmptyPreviousComponents());
            AddChild(new N_ValidateAvatarManifest_InvalidPreviousComponentsWrongBodyType());
            AddChild(new N_ValidateAvatarManifest_InvalidPreviousComponentsCostume());
            AddChild(new N_ValidateAvatarManifest_InvalidPreviousComponentsLongSleeveShirt());
            AddChild(new N_ValidateAvatarManifest_DuplicateComponents());
            AddChild(new N_ValidateAvatarManifest_ConflictingComponents());
            AddChild(new N_ValidateAvatarManifest_ConflictingComponentsWithCostume());
            AddChild(new N_ValidateAvatarManifest_MissingRequiredComponents());
            AddChild(new N_ValidateAvatarManifest_NoMaleGuestItems());
            AddChild(new N_ValidateAvatarManifest_NoFemaleGuestItems());
            AddChild(new N_ValidateAvatarManifest_FemaleItemsForMaleAvatar());
            AddChild(new N_ValidateAvatarManifest_MaleItemsForFemaleAvatar());
            AddChild(new N_ValidateAvatarManifest_InvalidBodyComponentForClothing());
            AddChild(new N_ValidateAvatarManifest_ExceedMaxHeight());
            AddChild(new N_ValidateAvatarManifest_ExceedMinHeight());
            AddChild(new N_ValidateAvatarManifest_ExceedMaxWeight());
            AddChild(new N_ValidateAvatarManifest_ExceedMinWeight());
            AddChild(new N_ValidateAvatarManifest_PurchasedMaleItemOnFemaleAvatar());
            AddChild(new N_ValidateAvatarManifest_PurchasedDuplicateComponents());
            AddChild(new N_ValidateAvatarManifest_BlendShapeInvalid());
            AddChild(new N_ValidateAvatarManifest_BlendShapeMissing());
            AddChild(new N_ValidateAvatarManifest_ReplacementTexturesRequiredInvalid());
            AddChild(new N_ValidateAvatarManifest_ReplacementTexturesRequiredMissing());
            AddChild(new N_ValidateAvatarManifest_ReplacementTexturesOptionalInvalid());

        }

        public static void verifyXErrorNum(uint actual, uint expected)
        {
            if (actual != expected)
                throw new Exception("Expected HR=" + expected.ToString("X") +
                                    " but received:" + actual.ToString("X"));
        }

        /// <summary>
        /// Copied from livecache tests
        /// Internal class used to set Livecache privileges for access. The LiveCache client DLL only exposes the interface, and partner teams are expected 
        /// to implement the interface themselves to call any APIs that require authentication. This is an implementation for the test code that was created
        /// by copying the private implementation out of the client code.
        /// </summary>
        public class AuthSettings : IExtendedAuthDataProvider
        {
            private ulong _livePuid;
            private byte _tier;
            private uint[] _privileges;
            private byte clientType;
            public ulong XboxPuid { get { return 0; } }
            public byte ClientPlatform { get { return clientType; } set { clientType = value; } }

            public AuthSettings()
            {
                _livePuid = LivecacheRequest.PublicRequestLivePuid;
                _tier = 0;

                // hard code privileges to baseline level
                _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
                AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
                AddPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING);
            }

            public AuthSettings(ulong puid, LivecacheClientType clientType)
            {
                _livePuid = puid;
                _tier = 0;

                // hard code privileges to baseline level
                _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
                AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
                AddPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING);
                ClientPlatform = (byte)clientType;
            }

            public AuthSettings(LivecacheClientType clientType)
            {
                _livePuid = LivecacheRequest.PublicRequestLivePuid;
                _tier = 0;

                // hard code privileges to baseline level
                _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
                AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
                AddPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING);
                ClientPlatform = (byte)clientType;
            }

            private void AddPrivilege(int privilegeId)
            {
                uint mask = (uint)1 << (privilegeId % 32);
                _privileges[privilegeId / 32] |= mask;
            }

            public ulong LivePuid
            {
                get { return _livePuid; }
            }

            public byte Tier
            {
                get { return _tier; }
            }

            public uint[] Privileges
            {
                get { return _privileges; }
            }

            public IPEndPoint ClientIPEndPoint
            {
                get { return new IPEndPoint(0, 0); }
            }
        }
    }
    #region Positive Cases

    // Standard avatar with only TOC version 0 items worn
    [TestFrequency("Daily"), TestCasePriority(1), Description("Validate Manifest for TOC only Avatar")]
    public class P_ValidateAvatarManifest_TOCOnly : UserSettingBase
    {
        public P_ValidateAvatarManifest_TOCOnly()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User1");
            // Clear this users settings for avatar manifest
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // avatar manifest created using avatar editor, TOC only items
            string manifestToc = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410003C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            
            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestToc));
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 0)
                throw new Exception("Validation Failed");
        }
    }

    // TOC items with 1 avatar awarded item in the manifest. 
    [TestFrequency("Daily"), TestCasePriority(1), Description("Validate Manifest for TOC/Awards Avatar")]
    public class P_ValidateAvatarManifest_TOCandAwarded : UserSettingBase
    {
        public P_ValidateAvatarManifest_TOCandAwarded()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User2");
            // Clear this users settings and avatar assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarAssets(Userid);
        }

        protected override void run()
        {
            uint avatarTitle = 50;
            // starting with a TOC only avatar editor created avatar, replace an item 
            // with my own avatar asset from my Title 50
            string manifestTocandAwarded = "00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AC0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002670003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF0D0D0DFFEB7D80FF917A51FF0D0D0DFFF3BC7BFF0D0D0DFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E000200000000000000000000000000000";
            // this is the hat asset from Title50 asset 3
            manifestTocandAwarded += "0000004000034103CF4EE4BA00000032";
            // the rest of the manifest
            manifestTocandAwarded += "004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E0003557FA53576C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            Global.RO.Info("Sync Single Avatar Asset");
            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1);
            XRLSyncAvatarAssets avreq = new XRLSyncAvatarAssets(avatarTitle, Userid, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse avresp = avreq.Execute();
            // Verify the response was ok
            if (avresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + avresp.xResult);

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestTocandAwarded));
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 0)
                throw new Exception("Validation Failed");
        }
    }
    // Validate a manifest with TOC and a single purchased avatar item, no awardables
    [TestFrequency("Daily"), TestCasePriority(1), Description("Validate Manifest for TOC/Purchased Avatar")]
    public class P_ValidateAvatarManifest_TOCandPurchased : UserSettingBase
    {
        public P_ValidateAvatarManifest_TOCandPurchased()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User3");
            // Clear this users settings and any purchased avatar assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarPurchasedAssets(Userid);
        }

        protected override void run()
        {
            // Need to create a goood manifest that has avatar awards in it
            string manifestTOCAndPurchased = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410203C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            Guid guidPurchased = new Guid("00000004-0241-0203-C1C8-F109A19CB2E0");

            Global.RO.Info("Adding the Purchased Avatar GUID to the database for User puid 9013");
            ProgressWS.InsertPurchasedAvatarAsset(Userid, guidPurchased);

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestTOCAndPurchased));
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 0)
                throw new Exception("Validation Failed");
        }
    }
    // Validate a manifest that has TOC, Awardable and purchased avatar items
    [TestFrequency("BVT"), BVT, TestCasePriority(1), Description("Validate Manifest for TOC/Awards/Purchased Avatar")]
    public class P_ValidateAvatarManifest_AllTypes : UserSettingBase
    {
        public P_ValidateAvatarManifest_AllTypes()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User4");
            // Clear this users settings, avatar awards and purchased avatar items
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarAssets(Userid);
            ProgressWS.ResetUserAvatarPurchasedAssets(Userid);
        }

        protected override void run()
        {
            Guid guidPurchased = new Guid("00001000-0005-4203-C111-01235841089A");
            // the starting manifest for my avatar
            string manifestAll = "00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AC0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002670003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF0D0D0DFFEB7D80FF917A51FF0D0D0DFFF3BC7BFF0D0D0DFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E000200000000000000000000000000000";
            // this is the hat asset from Title50 asset 3
            manifestAll += "0000004000034103CF4EE4BA00000032";
            // this is the stuff after the hat setting, before the carryable
            manifestAll += "00400000000000000000000000000000";
            // this is the carryable, purchased item GUID
            manifestAll += "0000100000054203C11101235841089A";
            // this is the rest of the manifest
            manifestAll += "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E0003557FA53576C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            Global.RO.Info("Adding the Purchased Avatar GUID to the database for User puid 9013");
            ProgressWS.InsertPurchasedAvatarAsset(Userid, guidPurchased);

            Global.RO.Info("Sync Single Asset");
            AvatarAssetWD assets = new AvatarAssetWD(3, (byte)3, 1);
            XRLSyncAvatarAssets avreq = new XRLSyncAvatarAssets(50, Userid, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse avresp = avreq.Execute();
            // Verify the response was ok
            if (avresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + avresp.xResult);

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestAll));
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 0)
                throw new Exception("Validation Failed");
        }
    }

    // Validate a manifest that isn't yet in the t_avatar_awarded_items table is ok
    // because the sync setting calls happens before the sync avatar assets call, so it
    // won't yet be in the table.
    public class P_ValidateAvatarManifest_AwardedItemsNotSynced : UserSettingBase
    {
        public P_ValidateAvatarManifest_AwardedItemsNotSynced()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User5");
            // Clear this users settings and avatar assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarAssets(Userid);
        }

        protected override void run()
        {
            string manifestTocandAwarded = "00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AC0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002670003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF0D0D0DFFEB7D80FF917A51FF0D0D0DFFF3BC7BFF0D0D0DFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E000200000000000000000000000000000";
            // this is the hat asset from Title50 asset 3
            manifestTocandAwarded += "0000004000034103CF4EE4BA00000032";
            manifestTocandAwarded += "004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E0003557FA53576C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            // Don't sync an avatar asset here, but add it to the avatar manifest
            // because on the client you could have earned and done this offline and then when you sync
            // it will sync the manifest first
            Global.RO.Info("Not calling ValidateAvatarAsset as I want the db to be empty");

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestTocandAwarded));
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 0)
                throw new Exception("Validation Failed");
        }
    }

    // Sync and then Re-Sync unchanged manifest
    public class P_ValidateAvatarManifest_NoChanges : UserSettingBase
    {
        public P_ValidateAvatarManifest_NoChanges()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User6");
            // Clear this users settings and avatar assets
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // avatar manifest created using avatar editor, TOC only items
            string manifestToc = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410003C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            UserSetting[] settings = new UserSetting[1];
            //int settingIDMaxSize = (int)((ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 >> 16) & 0x3FF);
            settings[0] = new UserSetting(Userid, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, AvatarManifestHelpers.HexToBytes(manifestToc));

            Global.RO.Info("Sync Avatar Info Setting");
            SyncSettingsRequest req = new SyncSettingsRequest(Title, Userid, settings, DateTime.UtcNow);
            SyncSettingsResponse resp = req.Execute();

            Global.RO.Info("Validate the data stored");
            verifyXerror(resp);
            verifyByReading(settings);

            Global.RO.Info("Validate Avatar Info with the same value");
            ValidateAvatarManifestRequest vreq = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestToc));
            ValidateAvatarManifestResponse vresp = vreq.Execute();

            Global.RO.Info("Validate the result");
            if (vresp.ValidationResult == 0)
                throw new Exception("Validation Failed");
        }
    }

    // Max Height
    [TestFrequency("Regression"), TestCasePriority(3), Description("Maximum allowed height")]
    public class P_ValidateAvatarManifest_MaxHeight : UserSettingBase
    {
        public P_ValidateAvatarManifest_MaxHeight()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User7");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            manifest.HeightFactor = (float)1.0;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 0)
                throw new Exception("Validation Failed");
        }
    }

    // Min height allowed
    [TestFrequency("Regression"), TestCasePriority(3), Description("Min height allowed")]
    public class P_ValidateAvatarManifest_MinHeight : UserSettingBase
    {
        public P_ValidateAvatarManifest_MinHeight()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User8");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            manifest.HeightFactor = (float)-1.0;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 0)
                throw new Exception("Validation Failed");
        }
    }

    // Weight maximum
    [TestFrequency("Regression"), TestCasePriority(3), Description("Weight maximum")]
    public class P_ValidateAvatarManifest_MaxWeight : UserSettingBase
    {
        public P_ValidateAvatarManifest_MaxWeight()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User9");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            manifest.WeightFactor = (float)1.0;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 0)
                throw new Exception("Validation Failed");
        }
    }

    // Weight minimum
    [TestFrequency("Regression"), TestCasePriority(3), Description("Weight minimum")]
    public class P_ValidateAvatarManifest_MinWeight : UserSettingBase
    {
        public P_ValidateAvatarManifest_MinWeight()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User10");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            manifest.WeightFactor = (float)-1.0;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 0)
                throw new Exception("Validation Failed");
        }
    }

    // ConsoleID will be non-zero when being synced from the Photobooth.  
    [TestFrequency("Regression"), TestCasePriority(3), Description("ConsoleID will be non-zero when being synced from the Photobooth.")]
    public class P_ValidateAvatarManifest_ConsoleIDNotNull : UserSettingBase
    {
        public P_ValidateAvatarManifest_ConsoleIDNotNull()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User16");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // Set the source consoleId to anything
            manifest.SrcConsoleId = new byte[] { 1, 1, 1, 1, 1 };

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 0)
                throw new Exception("Validation failed, but should have passed");
        }
    }

    // LiveCache test - actually makes Validate call through live Cache as a LIVEn client type
    [TestFrequency("Daily"), TestCasePriority(1), Description("Validate Manifest from LiveCache client")]
    public class P_ValidateAvatarManifest_LiveCacheClient : UserSettingBase
    {
        public P_ValidateAvatarManifest_LiveCacheClient()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User1");
            // Clear this users settings for avatar manifest
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // avatar manifest created using avatar editor, TOC only items
            string manifestToc = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410003C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            Global.RO.Info("Validate Avatar Manifest");

            LcStats stats = new LcStats(LivecacheClientType.LIVEn, XOn.WEB_TITLE_ID);
            // Had to not use the test implementation of this becuase of the stats call requiring this
            xonline.common.protocol.ValidateAvatarManifestRequest req = new xonline.common.protocol.ValidateAvatarManifestRequest();
            req.UserId=Userid;
            req.AvatarManifest = AvatarManifestHelpers.HexToBytes(manifestToc);
            req.ValidationFlags = 1;

            // since i used the xonline req, needed to also use the xonline response as well.
            xonline.common.protocol.ValidateAvatarManifestResponse resp = stats.ValidateAvatarManifest(req, new ValidateAvatarManifest.AuthSettings(Userid, LivecacheClientType.LIVEn));
            
            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 0)
                throw new Exception("Validation Failed");
        }
    }
    #endregion

    #region Negative Cases

    // Try validating an avatar manifest that is empty
    [TestFrequency("Daily"), TestCasePriority(2), Description("Validate Empty Manifest sync fails")]
    public class N_ValidateAvatar_EmptyManifest : UserSettingBase
    {
        public N_ValidateAvatar_EmptyManifest()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User11");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // Need to create a goood manifest that has avatar awards in it
            string manifestEmpty = "";

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestEmpty));
            // Currently the Service will reject this and fail the request with a server exception
            // So I'm just catching an exception here to make sure it does in fact do that.
            try
            {
                ValidateAvatarManifestResponse resp = req.Execute();
            }
            catch (Exception e)
            {
                Global.RO.Info("Request failed (as expected) due to value len, exception " + e.Message);
            }
        }
    }

    // Try validating an avatar manifest that is truncated and not the full bytes
    public class N_ValidateAvatarManifest_Truncated : UserSettingBase
    {
        public N_ValidateAvatarManifest_Truncated()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User12");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // Just truncated a good TOC only manifest so it's not all there.
            string manifestTruncated = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F8";

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestTruncated));
            // Currently the Service will reject this and fail the request with a server exception
            // So I'm just catching an exception here to make sure it does in fact do that.
            try
            {
                ValidateAvatarManifestResponse resp = req.Execute();
            }
            catch (Exception e)
            {
                Global.RO.Info("Request failed (as expected) due to value len, exception " + e.Message);
            }
        }
    }

    // Validate a manifest that has an incorrect allowed version of 15
    // currently only 1,2, and 3 are valid.
    public class N_ValidateAvatarManifest_InvalidVersion : UserSettingBase
    {
        public N_ValidateAvatarManifest_InvalidVersion()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User13");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // Based off a good TOC only manifest with a bad version in it of 15 (F)
            string manifestInvalid = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410F03C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestInvalid));
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Unlike the avatar assets items being ok to be empty from the table for the manifest validation,
    // the purchased items MUST be in the table to not fail.
    public class N_ValidateAvatarManifest_WithPurchasedButNotInTable : UserSettingBase
    {
        public N_ValidateAvatarManifest_WithPurchasedButNotInTable()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User14");
            // reset the user and purchased assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarPurchasedAssets(Userid);
        }

        protected override void run()
        {
            // Need to create a goood manifest that has avatar awards in it
            string manifestTOCAndPurchased = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410203C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            // Don't add the row into the table, so this will fail validation

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestTOCAndPurchased));
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Awarded assets that have been Flagged Not Achievable for gamerscore cheaters
    // are not allowed to be worn, so we need to make sure this case fails the validation
    public class N_ValidateAvatarManifest_AwardedNotAchievableFlag : UserSettingBase
    {
        public N_ValidateAvatarManifest_AwardedNotAchievableFlag()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User15");
            // reset the user and the awarded assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarAssets(Userid);
        }

        protected override void run()
        {
            string manifestTocandAwarded = "00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AC0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002670003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF0D0D0DFFEB7D80FF917A51FF0D0D0DFFF3BC7BFF0D0D0DFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E000200000000000000000000000000000";
            // this is the hat asset from Title50 asset 3
            manifestTocandAwarded += "0000004000034103CF4EE4BA00000032";
            manifestTocandAwarded += "004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E0003557FA53576C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            uint assetOrdinal = (uint)3;

            Global.RO.Info("Sync Single Asset");
            AvatarAssetWD assets = new AvatarAssetWD(assetOrdinal, (byte)3, 1);
            XRLSyncAvatarAssets avreq = new XRLSyncAvatarAssets(50, Userid, new AvatarAssetWD[] { assets });
            SyncAvatarAssetsResponse avresp = avreq.Execute();
            // Verify the response was ok
            if (avresp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server " + avresp.xResult);

            Global.RO.Info("Updating Sync'ed item in UODB to have the XAVATAR_NOT_ACHIEVABLE flag");
            // Now update the database to have the XAVATAR_NOT_ACHIEVABLE flag
            ProgressWS.MarkAvatarAssetNotAchievable(Userid, 50, assetOrdinal);

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestTocandAwarded));
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Sync'ing a manifest that isn't yet in the t_avatar_awarded_items table is ok
    // because the sync setting calls happens before the sync avatar assets call, unless the platform
    // is not the 360, because then everything you try to equip is assumed to be sync'ed.
    public class P_Sync360AvatarManifestAwardedItemsNotSyncedWithAwardValidation : UserSettingBase
    {
        public P_Sync360AvatarManifestAwardedItemsNotSyncedWithAwardValidation()
        {
        }

        protected override void init()
        {
            Userid = GetUser("User21");
            // Clear this users settings and avatar assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarAssets(Userid);
        }

        protected override void run()
        {
            string manifestTocandAwarded = "00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AC0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002670003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF0D0D0DFFEB7D80FF917A51FF0D0D0DFFF3BC7BFF0D0D0DFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E000200000000000000000000000000000";
            // this is the hat asset from Title50 asset 3
            manifestTocandAwarded += "0000004000034103CF4EE4BA00000032";
            manifestTocandAwarded += "004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E0003557FA53576C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            // Don't sync an avatar asset here, but add it to the avatar manifest
            // because on the client you could have earned and done this offline and then when you sync
            // it will sync the manifest first
            Global.RO.Info("Not calling SyncAvatarAsset as I want the db to be empty");

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestTocandAwarded));
            //req.ValidationFlags = 1; // Flags are ignored now
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 0)
                throw new Exception("Validation failed, but should have succeeded");
        }
    }

    // Sync'ing a manifest that isn't yet in the t_avatar_awarded_items table is ok
    // because the sync setting calls happens before the sync avatar assets call, unless the platform
    // is not the 360, because then everything you try to equip is assumed to be sync'ed.
    public class N_SyncMobileAvatarManifestAwardedItemsNotSyncedWithAwardValidation : UserSettingBase
    {
        public N_SyncMobileAvatarManifestAwardedItemsNotSyncedWithAwardValidation()
        {
        }

        protected override void init()
        {
            Userid = GetUser("User21");
            // Clear this users settings and avatar assets
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarAssets(Userid);
        }

        protected override void run()
        {
            string manifestTocandAwarded = "00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AC0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002670003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF0D0D0DFFEB7D80FF917A51FF0D0D0DFFF3BC7BFF0D0D0DFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E000200000000000000000000000000000";
            // this is the hat asset from Title50 asset 3
            manifestTocandAwarded += "0000004000034103CF4EE4BA00000032";
            manifestTocandAwarded += "004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E0003557FA53576C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            // Don't sync an avatar asset here, but add it to the avatar manifest
            // because on the client you could have earned and done this offline and then when you sync
            // it will sync the manifest first
            Global.RO.Info("Not calling SyncAvatarAsset as I want the db to be empty");

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, AvatarManifestHelpers.HexToBytes(manifestTocandAwarded));
            //req.ValidationFlags = 1; // Flags are ignored now
            ValidateAvatarManifestResponse resp = req.ExecuteInt(xonline.common.service.XOn.XPLT_INTERNAL_LIVEN, xonline.common.service.XOn.XPLT_MOBILE);

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation Passed, but should fail");
        }
    }

    // Body type not Male or Female
    [TestFrequency("Regression"), TestCasePriority(3), Description("Body type not Male or Female")]
    public class N_ValidateAvatarManifest_InvalidBodyType : UserSettingBase
    {
        public N_ValidateAvatarManifest_InvalidBodyType()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User17");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // Changed the 3rd component of the female body from 0x0002 -> 0x0003
            Guid invalidBody = new Guid(0x00000002, 0x0001, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0);
            manifest.BodyComponentInfo.ModelAssetId = invalidBody;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Only one valid head type
    [TestFrequency("Regression"), TestCasePriority(3), Description("Only one valid head type")]
    public class N_ValidateAvatarManifest_InvalidHeadType : UserSettingBase
    {
        public N_ValidateAvatarManifest_InvalidHeadType()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User18");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // Changed the 3rd component of the head from 0x0003 -> 0x0001 (unisex to male)
            Guid invalidHead = new Guid(0x00000001, 0x0002, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0);
            manifest.HeadComponentInfo.ModelAssetId = invalidHead;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Empty previous item for shirt, should never be allowed
    [TestFrequency("Regression"), TestCasePriority(3), Description("Empty previous items, should never be allowed")]
    public class N_ValidateAvatarManifest_EmptyPreviousComponents : UserSettingBase
    {
        public N_ValidateAvatarManifest_EmptyPreviousComponents()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User19");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // find the previous component shirt
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO previousCompShirt = Array.Find(manifest.PreviousRequiredComponentInfo, prci => (prci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Shirt) != 0);
            // set the Asset to empty and the component mask to None (required)
            previousCompShirt.ModelAssetId = new AvatarAssetId(Guid.Empty);
            previousCompShirt.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.None;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Previous male items for current female avatar
    [TestFrequency("Regression"), TestCasePriority(3), Description("Previous male items for current female avatar")]
    public class N_ValidateAvatarManifest_InvalidPreviousComponentsWrongBodyType : UserSettingBase
    {
        public N_ValidateAvatarManifest_InvalidPreviousComponentsWrongBodyType()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User1");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Female avatar from 12 pre-selected template ones
            string manifestDefaultFemale = "00000000BF000000BF80000000100000031B0003C1C8F109A19CB2E00008000003320003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E0000000000000000000000000000000000000200002BC0003C1C8F109A19CB2E00000000000000000000000000000000000004000026E0003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF98652FFF0D0D0DFFCF8562FF595D5CFF0D0D0DFFB37D59FF6E5326FFE18417FFE184170000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402170003C1C8F109A19CB2E0000400000000000000000000000000000080001801710002C1C8F109A19CB2E0001800000000000000000000000000000000002001010002C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001010002C1C8F109A19CB2E00020000000000000000000000000000000000010015B0002C1C8F109A19CB2E0001000000000000000000000000000000000000801200002C1C8F109A19CB2E0000800000000000000000000000000000000000402170003C1C8F109A19CB2E000040000000000000000000000000000E004B7A05AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultFemale));

            // find the previous component female pants
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO previousCompPants = Array.Find(manifest.PreviousRequiredComponentInfo, prci => (prci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Trousers) != 0);
            // set the Asset to male pants
            previousCompPants.ModelAssetId = new AvatarAssetId(AvatarAssets.LookupAssetByName("Male grunge pants"));

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Requires exactly 4 defined previous components, no costumes
    [TestFrequency("Regression"), TestCasePriority(3), Description("Requires exactly 4 defined previous components, no costumes")]
    public class N_ValidateAvatarManifest_InvalidPreviousComponentsCostume : UserSettingBase
    {
        public N_ValidateAvatarManifest_InvalidPreviousComponentsCostume()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User2");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Female avatar from 12 pre-selected template ones
            string manifestDefaultFemale = "00000000BF000000BF80000000100000031B0003C1C8F109A19CB2E00008000003320003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E0000000000000000000000000000000000000200002BC0003C1C8F109A19CB2E00000000000000000000000000000000000004000026E0003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF98652FFF0D0D0DFFCF8562FF595D5CFF0D0D0DFFB37D59FF6E5326FFE18417FFE184170000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402170003C1C8F109A19CB2E0000400000000000000000000000000000080001801710002C1C8F109A19CB2E0001800000000000000000000000000000000002001010002C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001010002C1C8F109A19CB2E00020000000000000000000000000000000000010015B0002C1C8F109A19CB2E0001000000000000000000000000000000000000801200002C1C8F109A19CB2E0000800000000000000000000000000000000000402170003C1C8F109A19CB2E000040000000000000000000000000000E004B7A05AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultFemale));

            // find the previous component female pants
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO previousCompPants = Array.Find(manifest.PreviousRequiredComponentInfo, prci => (prci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Trousers) != 0);
            // set the Asset to female suit costume and component mask 0x0218
            previousCompPants.ModelAssetId = new AvatarAssetId(AvatarAssets.LookupAssetByName("Formal trouser suit"));
            previousCompPants.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Wristwear;  //0x0200  
            previousCompPants.ComponentMask |= (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Trousers; //0x0010
            previousCompPants.ComponentMask |= (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Shirt; //0x0008
            
            // Not really required, but i'm going to set the rest of the items to empty
            // find the previous component female shirt
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO previousCompShirt = Array.Find(manifest.PreviousRequiredComponentInfo, prci => (prci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Shirt) != 0);
            // set the Shirt Asset to empty
            previousCompShirt.ModelAssetId = new AvatarAssetId(Guid.Empty);
            previousCompShirt.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.None;
            // find the previous component female shoes
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO previousCompShoes = Array.Find(manifest.PreviousRequiredComponentInfo, prci => (prci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Shoes) != 0);
            // set the Shoes Asset to empty
            previousCompShoes.ModelAssetId = new AvatarAssetId(Guid.Empty);
            previousCompShirt.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.None;
            // find the previous component female hair
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO previousCompHair = Array.Find(manifest.PreviousRequiredComponentInfo, prci => (prci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Hair) != 0);
            // set the Hair Asset to empty
            previousCompHair.ModelAssetId = new AvatarAssetId(Guid.Empty);
            previousCompShirt.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.None;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Requires exactly 4 defined previous components, no costumes
    [TestFrequency("Regression"), TestCasePriority(3), Description("Requires exactly 4 defined previous components, no costumes")]
    public class N_ValidateAvatarManifest_InvalidPreviousComponentsLongSleeveShirt : UserSettingBase
    {
        public N_ValidateAvatarManifest_InvalidPreviousComponentsLongSleeveShirt()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User17");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // find the previous component female pants
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO previousShirt = Array.Find(manifest.PreviousRequiredComponentInfo, prci => (prci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Shirt) != 0);
            // set the Asset to male blue formal shirt which will have both the shirt and wristwear component mask
            previousShirt.ModelAssetId = new AvatarAssetId(AvatarAssets.LookupAssetByName("Blue formal shirt"));
            previousShirt.ComponentMask |= (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Wristwear; //0x0208

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // No duplicate components allowed (2 shirts)
    [TestFrequency("Regression"), TestCasePriority(3), Description("No duplicate components allowed")]
    public class N_ValidateAvatarManifest_DuplicateComponents : UserSettingBase
    {
        public N_ValidateAvatarManifest_DuplicateComponents()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User3");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // set the pants item to a shirt item
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO pants = Array.Find(manifest.ComponentInfo, ci => (ci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Trousers) != 0);
            pants.ModelAssetId = new AvatarAssetId(AvatarAssets.LookupAssetByName("Polo shirt1"));
            // Make sure to also change the component mask to a shirt
            pants.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Shirt;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Can’t have a ring and gloves for instance 
    [TestFrequency("Regression"), TestCasePriority(3), Description("Can’t have a ring and gloves for instance")]
    public class N_ValidateAvatarManifest_ConflictingComponents : UserSettingBase
    {
        public N_ValidateAvatarManifest_ConflictingComponents()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User4");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // get the next free componentinfo
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO ring = Array.Find(manifest.ComponentInfo, ci => (ci.ModelAssetId.Id == Guid.Empty));
            ring.ModelAssetId = new AvatarAssetId(AvatarAssets.LookupAssetByName("Celtic ring"));
            ring.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Ring;
            
            // get the now next free componentinfo
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO gloves = Array.Find(manifest.ComponentInfo, ci => (ci.ModelAssetId.Id == Guid.Empty));
            gloves.ModelAssetId = new AvatarAssetId(AvatarAssets.LookupAssetByName("Woolly gloves"));
            // Gloves set both component masks of gloves and ring
            gloves.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Gloves;
            gloves.ComponentMask |= (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Ring;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Can’t have shirt and be wearing a costume
    [TestFrequency("Regression"), TestCasePriority(3), Description("Can’t have shirt and be wearing a costume")]
    public class N_ValidateAvatarManifest_ConflictingComponentsWithCostume : UserSettingBase
    {
        public N_ValidateAvatarManifest_ConflictingComponentsWithCostume()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User5");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // get the next free componentinfo
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO costume = Array.Find(manifest.ComponentInfo, ci => (ci.ModelAssetId.Id == Guid.Empty));
            // Set the model to a costume, and the masks for it (0x0238)
            costume.ModelAssetId = new AvatarAssetId(AvatarAssets.LookupAssetByName("Western duster"));
            costume.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Wristwear;  //0x0200  
            costume.ComponentMask |= (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Shoes; //0x0020
            costume.ComponentMask |= (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Trousers; //0x0010
            costume.ComponentMask |= (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Shirt; //0x0008

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Missing a required component, must wear pants
    [TestFrequency("Regression"), TestCasePriority(3), Description("Missing a required component, must wear pants")]
    public class N_ValidateAvatarManifest_MissingRequiredComponents : UserSettingBase
    {
        public N_ValidateAvatarManifest_MissingRequiredComponents()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User6");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // find the previous component shirt
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO pants = Array.Find(manifest.ComponentInfo, ci => (ci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Trousers) != 0);
            // set the Asset to empty
            pants.ModelAssetId = new AvatarAssetId(Guid.Empty);
            // set the component mask to none
            pants.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.None;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Not allowed to wear the male guest shirts
    [TestFrequency("Regression"), TestCasePriority(3), Description("Not allowed to wear the male guest shirt")]
    public class N_ValidateAvatarManifest_NoMaleGuestItems : UserSettingBase
    {
        public N_ValidateAvatarManifest_NoMaleGuestItems()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User7");
            // reset the user
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // get a reference to the shirt component and change it to the guid for the 'Male guest 1' shirt
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO shirt = Array.Find(manifest.ComponentInfo, ci => (ci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Shirt) != 0);
            shirt.ModelAssetId = new AvatarAssetId(AvatarAssets.LookupAssetByName("Male guest 1"));

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Not allowed to wear the female guest shirts
    [TestFrequency("Regression"), TestCasePriority(3), Description("Not allowed to wear the female guest shirt")]
    public class N_ValidateAvatarManifest_NoFemaleGuestItems : UserSettingBase
    {
        public N_ValidateAvatarManifest_NoFemaleGuestItems()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User8");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Female avatar from 12 pre-selected template ones
            string manifestDefaultFemale = "00000000BF000000BF80000000100000031B0003C1C8F109A19CB2E00008000003320003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E0000000000000000000000000000000000000200002BC0003C1C8F109A19CB2E00000000000000000000000000000000000004000026E0003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF98652FFF0D0D0DFFCF8562FF595D5CFF0D0D0DFFB37D59FF6E5326FFE18417FFE184170000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402170003C1C8F109A19CB2E0000400000000000000000000000000000080001801710002C1C8F109A19CB2E0001800000000000000000000000000000000002001010002C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001010002C1C8F109A19CB2E00020000000000000000000000000000000000010015B0002C1C8F109A19CB2E0001000000000000000000000000000000000000801200002C1C8F109A19CB2E0000800000000000000000000000000000000000402170003C1C8F109A19CB2E000040000000000000000000000000000E004B7A05AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultFemale));

            // get a reference to the shirt component and change it to the guid for the 'Female guest 1' shirt
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO shirt = Array.Find(manifest.ComponentInfo, ci => (ci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Shirt) != 0);
            shirt.ModelAssetId = new AvatarAssetId(AvatarAssets.LookupAssetByName("Female guest 1"));

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Male Avatar can’t wear female clothes
    [TestFrequency("Regression"), TestCasePriority(3), Description("Male Avatar can’t wear female clothes")]
    public class N_ValidateAvatarManifest_FemaleItemsForMaleAvatar : UserSettingBase
    {
        public N_ValidateAvatarManifest_FemaleItemsForMaleAvatar()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User9");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // find the male pants
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO pants = Array.Find(manifest.ComponentInfo, ci => (ci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Trousers) != 0);
            // set the Asset tp female pants
            pants.ModelAssetId = new AvatarAssetId(AvatarAssets.LookupAssetByName("Skinny fit jeans"));

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Female Avatar can’t wear male clothes
    [TestFrequency("Regression"), TestCasePriority(3), Description("Female Avatar can’t wear male clothes")]
    public class N_ValidateAvatarManifest_MaleItemsForFemaleAvatar : UserSettingBase
    {
        public N_ValidateAvatarManifest_MaleItemsForFemaleAvatar()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User10");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Female avatar from 12 pre-selected template ones
            string manifestDefaultFemale = "00000000BF000000BF80000000100000031B0003C1C8F109A19CB2E00008000003320003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E0000000000000000000000000000000000000200002BC0003C1C8F109A19CB2E00000000000000000000000000000000000004000026E0003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF98652FFF0D0D0DFFCF8562FF595D5CFF0D0D0DFFB37D59FF6E5326FFE18417FFE184170000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402170003C1C8F109A19CB2E0000400000000000000000000000000000080001801710002C1C8F109A19CB2E0001800000000000000000000000000000000002001010002C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001010002C1C8F109A19CB2E00020000000000000000000000000000000000010015B0002C1C8F109A19CB2E0001000000000000000000000000000000000000801200002C1C8F109A19CB2E0000800000000000000000000000000000000000402170003C1C8F109A19CB2E000040000000000000000000000000000E004B7A05AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultFemale));

            // find the female pants
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO pants = Array.Find(manifest.ComponentInfo, ci => (ci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Trousers) != 0);
            // set the Asset to male pants
            pants.ModelAssetId = new AvatarAssetId(AvatarAssets.LookupAssetByName("Male grunge pants"));

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }
   
    // As Jerry puts it, no second heads in a clothing slot
    [TestFrequency("Regression"), TestCasePriority(3), Description("As Jerry puts it, no second heads in a clothing slot")]
    public class N_ValidateAvatarManifest_InvalidBodyComponentForClothing : UserSettingBase
    {
        public N_ValidateAvatarManifest_InvalidBodyComponentForClothing()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User11");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Female avatar from 12 pre-selected template ones
            string manifestDefaultFemale = "00000000BF000000BF80000000100000031B0003C1C8F109A19CB2E00008000003320003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E0000000000000000000000000000000000000200002BC0003C1C8F109A19CB2E00000000000000000000000000000000000004000026E0003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF98652FFF0D0D0DFFCF8562FF595D5CFF0D0D0DFFB37D59FF6E5326FFE18417FFE184170000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402170003C1C8F109A19CB2E0000400000000000000000000000000000080001801710002C1C8F109A19CB2E0001800000000000000000000000000000000002001010002C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001010002C1C8F109A19CB2E00020000000000000000000000000000000000010015B0002C1C8F109A19CB2E0001000000000000000000000000000000000000801200002C1C8F109A19CB2E0000800000000000000000000000000000000000402170003C1C8F109A19CB2E000040000000000000000000000000000E004B7A05AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultFemale));

            // find the female pants
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO pants = Array.Find(manifest.ComponentInfo, ci => (ci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Trousers) != 0);
            // set the Asset to a head
            pants.ModelAssetId = new AvatarAssetId(AvatarAssets.LookupAssetByName("Head"));
            // for an accurate test, we need to set the component mask as well
            pants.ComponentMask = (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Head;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Height outside the allowed maximum
    [TestFrequency("Regression"), TestCasePriority(3), Description("Height outside the allowed maximum")]
    public class N_ValidateAvatarManifest_ExceedMaxHeight : UserSettingBase
    {
        public N_ValidateAvatarManifest_ExceedMaxHeight()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User12");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // Max Height is 1.0
            manifest.HeightFactor = (float)1.01;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Height outside the allowed minimum
    [TestFrequency("Regression"), TestCasePriority(3), Description("Height outside the allowed minimum")]
    public class N_ValidateAvatarManifest_ExceedMinHeight : UserSettingBase
    {
        public N_ValidateAvatarManifest_ExceedMinHeight()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User13");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // Min Height is -1.0
            manifest.HeightFactor = (float)-1.01;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Weight outside the allowed maximum
    [TestFrequency("Regression"), TestCasePriority(3), Description("Weight outside the allowed maximum")]
    public class N_ValidateAvatarManifest_ExceedMaxWeight : UserSettingBase
    {
        public N_ValidateAvatarManifest_ExceedMaxWeight()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User14");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // Max weight is 1.0
            manifest.WeightFactor = (float)1.01;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Weight outside the allowed minimum
    [TestFrequency("Regression"), TestCasePriority(3), Description("Weight outside the allowed minimum")]
    public class N_ValidateAvatarManifest_ExceedMinWeight : UserSettingBase
    {
        public N_ValidateAvatarManifest_ExceedMinWeight()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User15");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));

            // Min weight is -1.0
            manifest.WeightFactor = (float)-1.01;

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Female Avatar can’t wear purchased male clothes
    [TestFrequency("Regression"), TestCasePriority(3), Description("Female Avatar can’t wear purchased male clothes")]
    public class N_ValidateAvatarManifest_PurchasedMaleItemOnFemaleAvatar : UserSettingBase
    {
        public N_ValidateAvatarManifest_PurchasedMaleItemOnFemaleAvatar()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User16");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarPurchasedAssets(Userid);
        }

        protected override void run()
        {
            // First Female avatar from 12 pre-selected template ones
            string manifestDefaultFemale = "00000000BF000000BF80000000100000031B0003C1C8F109A19CB2E00008000003320003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E0000000000000000000000000000000000000200002BC0003C1C8F109A19CB2E00000000000000000000000000000000000004000026E0003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF98652FFF0D0D0DFFCF8562FF595D5CFF0D0D0DFFB37D59FF6E5326FFE18417FFE184170000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402170003C1C8F109A19CB2E0000400000000000000000000000000000080001801710002C1C8F109A19CB2E0001800000000000000000000000000000000002001010002C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001010002C1C8F109A19CB2E00020000000000000000000000000000000000010015B0002C1C8F109A19CB2E0001000000000000000000000000000000000000801200002C1C8F109A19CB2E0000800000000000000000000000000000000000402170003C1C8F109A19CB2E000040000000000000000000000000000E004B7A05AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultFemale));

            // find the female pants
            xonline.common.service.AvatarManifest.XAVATAR_COMPONENT_INFO pants = Array.Find(manifest.ComponentInfo, ci => (ci.ComponentMask & (ushort)AvatarManifestHelpers.XAVATAR_COMPONENT_MASK.Trousers) != 0);
            // set the Asset to male pants ("Male grunge Pants") with version changed to purchased    
            // The structure of awarded assets is as follows:
            // ID Structure:  gggggggg-xxxx-ryrb-Crrr-rrrrtttttttt (where y is the version of 0=TOC,1=Awarded,2=Purchased from AvatarAssetId.cs
            Guid purchasedMalePants = new Guid("00000010-0099-0201-C1C8-F109A19CB2E0"); 
            pants.ModelAssetId = new AvatarAssetId(purchasedMalePants);

            // This doesn't actually matter, it will fail the validation before it validates the purchase
            // but just in case that order is ever changed.
            Global.RO.Info("Adding the Purchased Avatar GUID to the database for User puid 9016");
            ProgressWS.InsertPurchasedAvatarAsset(Userid, purchasedMalePants);

            Global.RO.Info("Validate Avatar Manifest");
            ValidateAvatarManifestRequest req = new ValidateAvatarManifestRequest(Userid, (byte[])manifest);
            ValidateAvatarManifestResponse resp = req.Execute();

            Global.RO.Info("Validate the result");
            if (resp.ValidationResult == 1)
                throw new Exception("Validation passed, but should have failed");
        }
    }

    // Male Avatar can't wear 2 pants
    [TestFrequency("Regression"), TestCasePriority(3), Description("Male Avatar can't wear 2 pants")]
    public class N_ValidateAvatarManifest_PurchasedDuplicateComponents : UserSettingBase
    {
        public N_ValidateAvatarManifest_PurchasedDuplicateComponents()
        {
        }
        protected override void init()
        {
            Userid = GetUser("User16");
            // reset the user 
            ProfileWS.ResetUserSetttings(Userid);
            ProgressWS.ResetUserAvatarPurchasedAssets(Userid);
        }

        protected override void run()
        {
            // First Male avatar from 12 pre-selected template ones
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonlin