for ARPCB_REMOTE_IP.

Arguments:

    pKey        - Actually  the IP address (not ptr to IP address) in network-byte
                  order.
    pItem       - Points to ARPCB_REMOTE_IP.Hdr.HashLink.

Return Value:

    TRUE IFF the key (IP address) exactly matches the key of the specified 
    RemoteIp object.

--*/
{
    ENTER ("arpRemoteDestCompareKey", 0x62b9d9ae)
    PREMOTE_DEST_KEY pRemoteDestKey = (PREMOTE_DEST_KEY)pKey;
    ARPCB_REMOTE_IP *pRIP = 
        CONTAINING_RECORD(pItem, ARPCB_REMOTE_IP, Hdr.HashLink);
    BOOLEAN fCompare = FALSE;

        
    if ((pRIP->Key.u.u32 == pRemoteDestKey->u.u32)  &&
       (pRIP->Key.u.u16 == pRemoteDestKey->u.u16))
    {
        fCompare = TRUE; 
    }

    TR_INFO( ("Comparision %d Key %x %x %x %x %x %x pRemoteIP %x %x %x %x %x %x\n",
                fCompare,
                pRemoteDestKey->ENetAddress.addr[0],
                pRemoteDestKey->ENetAddress.addr[1],
                pRemoteDestKey->ENetAddress.addr[2],
                pRemoteDestKey->ENetAddress.addr[3],
                pRemoteDestKey->ENetAddress.addr[4],
                pRemoteDestKey->ENetAddress.addr[5],
                pRIP->Key.ENetAddress.addr[0],
                pRIP->Key.ENetAddress.addr[1],
                pRIP->Key.ENetAddress.addr[2],
                pRIP->Key.ENetAddress.addr[3],
                pRIP->Key.ENetAddress.addr[4],
                pRIP->Key.ENetAddress.addr[5]));

    EXIT();
    return fCompare;  // success
}

BOOLEAN
arpRemoteIpCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for ARPCB_REMOTE_IP.

Arguments:

    pKey        - Actually  the IP address 
    pItem       - Points to ARPCB_REMOTE_IP.Hdr.HashLink.

Return Value:

    TRUE IFF the key (IP address) exactly matches the key of the specified 
    RemoteIp object.

--*/
{
    ARPCB_REMOTE_IP *pRIP = 
        CONTAINING_RECORD(pItem, ARPCB_REMOTE_IP, Hdr.HashLink);

    if (pRIP->IpAddress == (ULONG) (ULONG_PTR) pKey)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}

BOOLEAN
arpRemoteEthCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for ARPCB_REMOTE_ETH.

Arguments:

    pKey        - Actually  the IP address (not ptr to IP address) in network-byte
                  order.
    pItem       - Points to ARPCB_REMOTE_ETH.Hdr.HashLink.

Return Value:

    TRUE IFF the key (IP address) exactly matches the key of the specified 
    RemoteEth object.

--*/
{
    ARPCB_REMOTE_ETH *pRE = 
        CONTAINING_RECORD(pItem, ARPCB_REMOTE_ETH, Hdr.HashLink);

    if (pRE->IpAddress == (ULONG) (ULONG_PTR) pKey)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOLEAN
arpDestinationCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for ARPCB_DEST.

Arguments:

    pKey        - Actually a pointer to a ARP_DEST_PARAMS structure.
    pItem       - Points to ARPCB_DEST.Hdr.HashLink.

Return Value:

    TRUE IFF the key (HW address) exactly matches the key of the specified 
    Dest object.

--*/
{
    ARPCB_DEST              *pD = CONTAINING_RECORD(pItem, ARPCB_DEST, Hdr.HashLink);
    PARP_DEST_PARAMS            pDestParams =  (PARP_DEST_PARAMS) pKey;
    NIC1394_DESTINATION     *pKeyHwAddr =  &pDestParams->HwAddr;
    NIC1394_ADDRESS_TYPE    AddressType = pKeyHwAddr->AddressType;

    if (pD->Params.HwAddr.AddressType == AddressType)
    {
        if (AddressType == NIC1394AddressType_FIFO)
        {
            if (pKeyHwAddr->FifoAddress.UniqueID == pD->Params.HwAddr.FifoAddress.UniqueID
             && pKeyHwAddr->FifoAddress.Off_Low == pD->Params.HwAddr.FifoAddress.Off_Low
             && pKeyHwAddr->FifoAddress.Off_High == pD->Params.HwAddr.FifoAddress.Off_High)
            {
                return TRUE;
            }
        }
        else if (AddressType == NIC1394AddressType_Channel)
        {
            if (pKeyHwAddr->Channel == pD->Params.HwAddr.Channel)
            {
                if (pDestParams->ReceiveOnly ==  pD->Params.ReceiveOnly)
                {
                    return TRUE;
                }
            }
        }
        else if (AddressType == NIC1394AddressType_MultiChannel)
        {
            return TRUE;
        }
        else if (AddressType == NIC1394AddressType_Ethernet)
        {
            return TRUE;
        }
    }

    return FALSE;
}

ULONG
arpDestinationHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash function responsible for returning a hash of pKey, which
    we expect to be pointer to a NIC1394_DESTINATION HW address.
    IMPORTANT: Since that address is a union of channel or Fifo (different sizes),
        we expect that the structure was first zero'd out (no uninitialized bits).
    We expect this pointer to be quadword aligned.

Arguments:

    pKey        - Actually a pointer to a  ARP_DEST_KEY structure.

Return Value:

    ULONG-sized hash of pKey.

--*/
{
    ULONG *pu = (ULONG*) pKey;

    // We expect both channel and fifo are at the beginning of the structure,
    // and the structure is atleast 2 dwords.
    // NOTE: we only look at the HwAddr field of ARP_DEST_PARAMS, so both
    // send and receive destinations will hash to the same value. Big deal.
    //
    ASSERT(
        FIELD_OFFSET(ARP_DEST_PARAMS,  HwAddr) == 0 &&
        FIELD_OFFSET(NIC1394_DESTINATION,  FifoAddress) == 0 &&
        FIELD_OFFSET(NIC1394_DESTINATION,  Channel) == 0     &&
        sizeof(NIC1394_DESTINATION) >= 2*sizeof(*pu));

    
    // Return 1st DWORD xor 2nd DWORD
    //
    return pu[0] ^ pu[1];
}


BOOLEAN
arpDhcpTableCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for ARPCB_DEST.

Arguments:

    pKey        - Actually a pointer to the xid .
    pItem       - Points to ARPCB_DEST.Hdr.HashLink.

Return Value:

    TRUE IFF the key (HW address) exactly matches the key of the specified 
    Dest object.

--*/
{
    ARP1394_ETH_DHCP_ENTRY  *pEntry = 
        CONTAINING_RECORD(pItem, ARP1394_ETH_DHCP_ENTRY  , Hdr.HashLink);

    if (pEntry->xid== (*(PULONG)pKey))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


ULONG
arpDhcpTableHash (
    PVOID           pKey
    )
/*++

Routine Description:

    

Arguments:

    pKey        - Actually a pointer to a  Xid of a dhcp transaction .

Return Value:

    ULONG-sized hash of pKey.

--*/
{
    ULONG *pu = (ULONG*) pKey;

    return (*pu);
}

// arpLocalIp_HashInfo contains information required maintain a hashtable
// of ARPCB_LOCAL_IP objects.
//
RM_HASH_INFO
arpLocalIp_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpLocalIpCompareKey,   // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpIpAddressHash        // pfnHash

};


// arpRemoteIp_HashInfo contains information required maintain a hashtable
// of ARPCB_REMOTE_IP objects.
//
RM_HASH_INFO
arpRemoteIp_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpRemoteIpCompareKey,  // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpIpAddressHash        // pfnHash

};


// arpRemoteIp_HashInfo contains information required maintain a hashtable
// of ARPCB_REMOTE_IP objects.
//
RM_HASH_INFO
arpRemoteEth_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpRemoteEthCompareKey, // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpIpAddressHash        // pfnHash

};

// arpDestination_HashInfo contains information required maintain a hashtable
// of ARPCB_DEST objects.
//
RM_HASH_INFO
arpDestination_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpDestinationCompareKey,   // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpDestinationHash      // pfnHash

};


// arpRemoteDest_HashInfo contains information required maintain a hashtable
// of ARPCB_REMOTE_IP objects.
//
RM_HASH_INFO
arpRemoteDest_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpRemoteDestCompareKey, // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpRemoteDestHash        // pfnHash
};


// arpRemoteDest_HashInfo contains information required maintain a hashtable
// of ARPCB_REMOTE_IP objects.
//
RM_HASH_INFO
arpDhcpTable_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpDhcpTableCompareKey, // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpDhcpTableHash        // pfnHash
};

// ArpGlobal_LocalIpStaticInfo contains static information about
// objects of type ARPCB_LOCAL_IP.
//
RM_STATIC_OBJECT_INFO
ArpGlobal_LocalIpStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "LocalIp",  // TypeName
    0, // Timeout

    arpLocalIpCreate,   // pfnCreate
    arpLocalIpDelete,       // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpLocalIp_HashInfo
};


// ArpGlobal_RemoteIpStaticInfo contains static information about
// objects of type ARPCB_REMOTE_IP.
//
RM_STATIC_OBJECT_INFO
ArpGlobal_RemoteIpStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "RemoteIp", // TypeName
    0, // Timeout

    arpRemoteDestCreate,  // pfnCreate
    arpRemoteIpDelete,      // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpRemoteDest_HashInfo
};


// ArpGlobal_RemoteEthStaticInfo contains static information about
// objects of type ARPCB_REMOTE_ETH.
//
RM_STATIC_OBJECT_INFO
ArpGlobal_RemoteEthStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "RemoteEth",    // TypeName
    0, // Timeout

    arpRemoteEthCreate,     // pfnCreate
    arpRemoteEthDelete,         // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpRemoteEth_HashInfo
};

// ArpGlobal_DestinationStaticInfo contains static information about
// objects of type ARPCB_DEST.
//
RM_STATIC_OBJECT_INFO
ArpGlobal_DestinationStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "Destination",  // TypeName
    0, // Timeout

    arpDestinationCreate,   // pfnCreate
    arpDestinationDelete,       // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpDestination_HashInfo
};

RM_STATIC_OBJECT_INFO
ArpGlobal_RemoteDestStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "RemoteIp", // TypeName
    0, // Timeout

    arpRemoteDestCreate,  // pfnCreate
    arpRemoteDestDelete,      // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpRemoteDest_HashInfo
};

RM_STATIC_OBJECT_INFO
ArpGlobal_DhcpTableStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "DhcpTableEntry", // TypeName
    0, // Timeout

    arpDhcpTableEntryCreate,  // pfnCreate
    arpDhcpTableEntryDelete,      // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpDhcpTable_HashInfo 
};

NDIS_STATUS
arpTaskDeactivateInterface(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    Task handler responsible for deactivating an IP interface (but leaving
    it allocated and linked to the adapter).

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused
--*/
{
    NDIS_STATUS         Status;
    PARP1394_INTERFACE  pIF;
    PTASK_DEACTIVATE_IF pShutdownTask;
    UINT                Stage;
    PARP1394_ADAPTER    pAdapter;
    enum
    {
        STAGE_Start,
        STAGE_StopMaintenanceTask,
        STAGE_CleanupVcComplete,
        STAGE_CloseLocalIpGroup,
        STAGE_CloseRemoteIpGroup,
        STAGE_CloseRemoteEthGroup,
        STAGE_CloseRemoteDhcpGroup,
        STAGE_CloseDestinationGroup,
        STAGE_SwitchedToPassive,
        STAGE_CloseAF,
        STAGE_CloseIp,
        STAGE_End
    };
    ENTER("TaskDeactivateInterface", 0x1a34699e)

    Status              = NDIS_STATUS_FAILURE;
    pIF                 = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pTask);
    pShutdownTask       = (PTASK_DEACTIVATE_IF) pTask;
    pAdapter            = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);


    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_Start;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    switch(Stage)
    {
        case STAGE_Start:
        {

        #if TEST_ICS_HACK
            arpDbgTryStopIcsTest(pIF, pSR);
        #endif // TEST_ICS_HACK

            // There should NOT be another activate/deactivate task running
            // on this interface. Why? Because an activate/deactivate task is ONLY
            // started in the context of the active primary task, and there can be
            // ONLY one active primary task on this IF at any one time.
            //
            TIMESTAMP("===DeinitIF:Starting");

            LOCKOBJ(pIF, pSR);
            if (pIF->pActDeactTask != NULL)
            {
                ASSERT(!"pIF->pActDeactTask != NULL");
                UNLOCKOBJ(pIF, pSR);
                Status = NDIS_STATUS_FAILURE;
                break;
            }
            arpSetSecondaryIfTask(pIF, pTask, ARPIF_AS_DEACTIVATING, pSR);
            UNLOCKOBJ(pIF, pSR);


            //
            // Stop the IF maintenance task if it's running.
            //
            Status =  arpTryStopIfMaintenanceTask(
                            pIF,
                            pTask,
                            STAGE_StopMaintenanceTask,
                            pSR
                            );
        }           

        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_StopMaintenanceTask:
        {
            LOCKOBJ(pIF, pSR);

            TIMESTAMP("===DeinitIF:MaintenanceTask stopped");
            // Unlink the explicit reference of the broadcast channel destination
            // from the interface.
            //
            if (pIF->pBroadcastDest != NULL)
            {
                PARPCB_DEST pBroadcastDest = pIF->pBroadcastDest;
                pIF->pBroadcastDest = NULL;
    
                // NOTE: We're unlinking the two with the IF lock (which is
                // is the same as the pBroadcastDest's lock) held.
                // This is OK to do.
                //
    
            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pIF->Hdr,
                    &pBroadcastDest->Hdr,
                    0x66bda49b,
                    ARPASSOC_LINK_IF_OF_BCDEST,
                    ARPASSOC_LINK_BCDEST_OF_IF,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pIF->Hdr, &pBroadcastDest->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING
    
            }

            //
            // If the VC state needs cleaning up, we need to get a task
            // going to clean it up. Other wise we fake the completion of this
            // stage so that we move on to the next...
            //
            if (pIF->recvinfo.VcHdr.NdisVcHandle == NULL)
            {
                UNLOCKOBJ(pIF, pSR);
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                PRM_TASK pCleanupCallTask = pIF->recvinfo.VcHdr.pCleanupCallTask;


                // If there is already an official cleanup-vc task, we pend on it.
                // Other wise we allocate our own, pend on it, and start it.
                //
                if (pCleanupCallTask != NULL)
                {
                    TR_WARN((
                        "IF %p Cleanup-vc task %p exists; pending on it.\n",
                         pIF,
                         pCleanupCallTask));
                    RmTmpReferenceObject(&pCleanupCallTask->Hdr, pSR);
    
                    UNLOCKOBJ(pIF, pSR);
                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_CleanupVcComplete,
                        pCleanupCallTask,
                        pSR
                        );

                    RmTmpDereferenceObject(&pCleanupCallTask->Hdr, pSR);
                    Status = NDIS_STATUS_PENDING;
                }
                else
                {
                    //
                    // Start the call cleanup task and pend on int.
                    //
                    UNLOCKOBJ(pIF, pSR);

                    Status = arpAllocateTask(
                                &pIF->Hdr,                  // pParentObject,
                                arpTaskCleanupRecvFifoCall, // pfnHandler,
                                0,                          // Timeout,
                                "Task: CleanupRecvFifo on shutdown IF", // szDescrip.
                                &pCleanupCallTask,
                                pSR
                                );
                

                    if (FAIL(Status))
                    {
                        // Couldn't allocate task.
                        //
                        TR_WARN(("FATAL: couldn't alloc cleanup call task!\n"));
                    }
                    else
                    {
                        Status = RmPendTaskOnOtherTask(
                                    pTask,
                                    STAGE_CleanupVcComplete,
                                    pCleanupCallTask,
                                    pSR
                                    );
                        ASSERT(!FAIL(Status));
                
                        // RmStartTask uses up the tmpref on the task
                        // which was added by arpAllocateTask.
                        //
                        Status = RmStartTask(
                                    pCleanupCallTask,
                                    0, // UserParam (unused)
                                    pSR
                                    );
                        // We rely on pending status to decide whether
                        // or not to fall through to the next stage.
                        //
                        Status = NDIS_STATUS_PENDING;
                    }
                }
            }
        }

        if (PEND(Status)) break;

        // FALL THROUGH 

        case STAGE_CleanupVcComplete:
        {
            TIMESTAMP("===DeinitIF:RecvFifo cleanup complete");
            // Initiate unload of all the items in the LocalIpGroup.
            //
            OBJLOG1(pTask, "    Unloading LocalIpGroup 0x%p\n",
                        &pIF->LocalIpGroup);
            RmUnloadAllObjectsInGroup(
                        &pIF->LocalIpGroup,
                        arpAllocateTask,
                        arpTaskUnloadLocalIp,
                        NULL,   // userParam
                        pTask, // pTask to unpend when the unload completes.
                        STAGE_CloseLocalIpGroup,      // uTaskPendCode
                        pSR
                        );

            Status = NDIS_STATUS_PENDING;
        }
        break;

        case STAGE_CloseLocalIpGroup:
        {
            // Initiate unload of all the items in the RemoteIpGroup.
            //
            TIMESTAMP("===DeinitIF:LocalIp objects cleaned up.");
            OBJLOG1(
                pTask,
                "    Unloading RemoteIpGroup 0x%p\n",
                &pIF->RemoteIpGroup
                );
            RmUnloadAllObjectsInGroup(
                        &pIF->RemoteIpGroup,
                        arpAllocateTask,
                        arpTaskUnloadRemoteIp,
                        NULL,   // userParam
                        pTask, // pTask to unpend when the unload is complete.
                        STAGE_CloseRemoteIpGroup,     // uTaskPendCode
                        pSR
                        );

            Status = NDIS_STATUS_PENDING;
        }
        break;

        case STAGE_CloseRemoteIpGroup:
        {

            if (ARP_BRIDGE_ENABLED(pAdapter))
            {

                // Initiate unload of all the items in the RemoteEthGroup.
                //
                TIMESTAMP("===DeinitIF:RemoteIp objects cleaned up.");
                OBJLOG1(
                    pTask,
                    "    Unloading RemoteEthGroup 0x%p\n",
                    &pIF->RemoteEthGroup
                    );
                RmUnloadAllObjectsInGroup(
                            &pIF->RemoteEthGroup,
                            arpAllocateTask,
                            arpTaskUnloadRemoteEth,
                            NULL,   // userParam
                            pTask, // pTask to unpend when the unload is complete.
                            STAGE_CloseRemoteEthGroup,    // uTaskPendCode
                            pSR
                            );

                Status = NDIS_STATUS_PENDING;
                break;
            }
            else
            {
                // Bridging not enabled ...
                // FALL THROUGH....
            }
        }

        case STAGE_CloseRemoteEthGroup:
        {
            // Initiate unload of all the items in the DestinationGroup.
            //
            
            if (ARP_BRIDGE_ENABLED(pAdapter))
            {

                TIMESTAMP("===DeinitIF:RemoteEth Dhcp objects cleaned up.");
                OBJLOG1(pTask, "    Unloading EthDhcpGroup 0x%p\n",
                            &pIF->EthDhcpGroup);

                RmUnloadAllObjectsInGroup(
                            &pIF->EthDhcpGroup,
                            arpAllocateTask,
                            arpTaskUnloadEthDhcpEntry,
                            NULL,   // userParam
                            pTask, // pTask to unpend when the unload is complete.
                            STAGE_CloseRemoteDhcpGroup,      // uTaskPendCode
                            pSR
                            );

                Status = NDIS_STATUS_PENDING;
                break;
            }
            else
            {
                // Bridging not enabled ...
                // FALL THROUGH....
            }
         }

        case STAGE_CloseRemoteDhcpGroup:
        {
            // Initiate unload of all the items in the DestinationGroup.
            //
            TIMESTAMP("===DeinitIF:RemoteIp objects cleaned up.");
            OBJLOG1(pTask, "    Unloading DestinationGroup 0x%p\n",
                        &pIF->DestinationGroup);
            RmUnloadAllObjectsInGroup(
                        &pIF->DestinationGroup,
                        arpAllocateTask,
                        arpTaskUnloadDestination,
                        NULL,   // userParam
                        pTask, // pTask to unpend when the unload is complete.
                        STAGE_CloseDestinationGroup,      // uTaskPendCode
                        pSR
                        );

            Status = NDIS_STATUS_PENDING;
        }
        break;

        
        case STAGE_CloseDestinationGroup:
        {
            //
            // Unlink the special "destination VCs"
            //
            LOCKOBJ(pIF, pSR);

            TIMESTAMP("===DeinitIF:Destination objects cleaned up.");

            if (pIF->pMultiChannelDest != NULL)
            {
                PARPCB_DEST pMultiChannelDest = pIF->pMultiChannelDest;
                pIF->pMultiChannelDest = NULL;
    
                // NOTE: We're unlinking the two with the IF lock (which is
                // is the same as the pBroadcastDest's lock) held.
                // This is OK to do.
                //
    
            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pIF->Hdr,
                    &pMultiChannelDest->Hdr,
                    0xf28090bd,
                    ARPASSOC_LINK_IF_OF_MCDEST,
                    ARPASSOC_LINK_MCDEST_OF_IF,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pIF->Hdr, &pMultiChannelDest->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING
    
            }

            if (pIF->pEthernetDest != NULL)
            {
                PARPCB_DEST pEthernetDest = pIF->pEthernetDest;
                pIF->pEthernetDest = NULL;
    
                // NOTE: We're unlinking the two with the IF lock (which is
                // is the same as the pBroadcastDest's lock) held.
                // This is OK to do.
                //
    
            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pIF->Hdr,
                    &pEthernetDest->Hdr,
                    0xf8eedcd1,
                    ARPASSOC_LINK_IF_OF_ETHDEST,
                    ARPASSOC_LINK_ETHDEST_OF_IF,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pIF->Hdr, &pEthernetDest->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING
    
            }

            UNLOCKOBJ(pIF, pSR);

            // If required, switch to passive. This check should obviously be done
            // without any locks held!
            if (!ARP_ATPASSIVE())
            {
                // We're not at passive level, but we need to be when we
                // call IP's del interface. So we switch to passive...
                //
                RmSuspendTask(pTask, STAGE_SwitchedToPassive, pSR);
                RmResumeTaskAsync(pTask, 0, &pShutdownTask->WorkItem, pSR);
                Status = NDIS_STATUS_PENDING;
            }
            else
            {
                Status = NDIS_STATUS_SUCCESS;
            }
        }

        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_SwitchedToPassive:
        {
            PVOID IpContext;

            TIMESTAMP("===DeinitIF:Switched to Passive(if we aren't already).");
            // We're now switched to passive
            //
            ASSERT(ARP_ATPASSIVE());

            // If required, del the IP interface.
            //
                
            LOCKOBJ(pIF, pSR);
            IpContext = pIF->ip.Context;

            if (IpContext == NULL)
            {

                // Pretend that we're waiting on IpClose because
                // we fall through below.
                //
                pShutdownTask->fPendingOnIpClose = TRUE;
                UNLOCKOBJ(pIF, pSR);

                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                ASSERT(!ARP_BRIDGE_ENABLED(pAdapter));
                pIF->ip.Context = NULL;
                ASSERT(!pShutdownTask->fPendingOnIpClose);

                // Note: a task's lock is it's parent's lock, and this task's
                // parent is pIF...
                //
                pShutdownTask->fPendingOnIpClose = TRUE;
                UNLOCKOBJ(pIF, pSR);

                // We'll suspend this task, waiting for our ArpIpClose routine to
                // be called...
                //
                RmSuspendTask(pTask, STAGE_CloseIp, pSR);

                TIMESTAMP("===DeinitIF:Calling IP's DellInterface Rtn");
                ArpGlobals.ip.pDelInterfaceRtn(
                    IpContext
                    ,0  // DeleteIndex (unused)
                    );

                Status = NDIS_STATUS_PENDING;
            }
        }
        
        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_CloseIp:
        {
            NDIS_HANDLE NdisAfHandle;

            TIMESTAMP("===DeinitIF:Done with deleting IP interface (if there was one)");
            //
            // IP has called our arpIpClose function (if we'd bound to IP)
            // NOTE: Task's locks actually are their parent's locks,
            // which in this case is pIF;
            //
            // We're done with all VCs, etc. Time to close the AF, if it's open.
            //

            LOCKOBJ(pTask, pSR);
            ASSERT(pShutdownTask->fPendingOnIpClose);
            pShutdownTask->fPendingOnIpClose = FALSE;
            NdisAfHandle = pIF->ndis.AfHandle;
            pIF->ndis.AfHandle = NULL;
            UNLOCKOBJ(pTask, pSR);
    
            if (NdisAfHandle == NULL)
            {
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                //
                // (Debug) Delete the association we added when the
                // address family was opened.
                //
                DBG_DELASSOC(
                    &pIF->Hdr,                  // pObject
                    NdisAfHandle,               // Instance1
                    NULL,                       // Instance2
                    ARPASSOC_IF_OPENAF,         // AssociationID
                    pSR
                    );

                //
                // Suspend task and call NdisCloseAdapter...
                //
                RmSuspendTask(pTask, STAGE_CloseAF, pSR);
                RM_ASSERT_NOLOCKS(pSR);
                TIMESTAMP("===DeinitIF: Calling NdisClCloseAddressFamily");
                Status = NdisClCloseAddressFamily(
                            NdisAfHandle
                            );
        
                if (Status != NDIS_STATUS_PENDING)
                {
                    ArpCoCloseAfComplete(
                            Status,
                            (NDIS_HANDLE)pIF
                            );
                    Status = NDIS_STATUS_PENDING;
                }
            }
        }
        
        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_CloseAF:
        {

            //
            // The close AF operation is complete.
            // We've not got anything else to do.
            //
            TIMESTAMP("===DeinitIF: Done with CloseAF");

            // Recover the last status ...
            //
            Status = (NDIS_STATUS) UserParam;

            // Status of the completed operation can't itself be pending!
            //
            ASSERT(Status != NDIS_STATUS_PENDING);

            //
            // By returning Status != pending, we implicitly complete
            // this task.
            //
        }
        break;

        case STAGE_End:
        {
            //
            // We are done with all async aspects of shutting down the interface.
            // Nothing to do besides clearing the actdeact task.
            //
            LOCKOBJ(pIF, pSR);
            arpClearSecondaryIfTask(pIF, pTask, ARPIF_AS_FAILEDACTIVATE, pSR);
            UNLOCKOBJ(pIF, pSR);

            TIMESTAMP("===DeinitIF: All done!");

            // Force status to be success
            //
            Status = NDIS_STATUS_SUCCESS;
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Stage)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskDeinitInterface(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    Task handler responsible for deinitializing and deleting an interface.

Arguments:

    UserParam   for (Code ==  RM_TASKOP_START)          : unused
    
--*/
{
    NDIS_STATUS         Status;
    PARP1394_INTERFACE  pIF;
    MYBOOL              fTryInitiateUnload;
    enum
    {
        PEND_ExistingPrimaryTaskComplete,
        PEND_DeactivateIfComplete
    };
    ENTER("TaskDeinitInterface", 0xf059b63b)

    Status              = NDIS_STATUS_FAILURE;
    pIF                 = (PARP1394_INTERFACE) RM_PARENT_OBJECT(pTask);
    fTryInitiateUnload  = FALSE;

    switch(Code)
    {
        case RM_TASKOP_START:
        {
            fTryInitiateUnload = TRUE;
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case PEND_ExistingPrimaryTaskComplete:
                {
                    fTryInitiateUnload = TRUE;
                }
                break;

                case PEND_DeactivateIfComplete:
                {
                    ASSERT(pIF->pPrimaryTask == pTask);

                    // We're done deactivating the IF. We actually delete the IF
                    // in the context of the END handler...
                    //
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
            }
        }
        break;

        case RM_TASKOP_END:
        {
            //
            // We are done with all async aspects of unloading the interface.
            // Now on to synchronous cleanup and deallocation...
            //

            ARP1394_ADAPTER *   pAdapter;

            // Nothing to do if we're not the active primary task.
            //
            if (pIF->pPrimaryTask != pTask)
            {
                // We should only get here if pIF was unloaded by someone else....
                //
                ASSERT(RM_IS_ZOMBIE(pIF));
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

            LOCKOBJ(pAdapter, pSR);

            // Remove linkage to adapter. Note: pIF lock is the adapter lock.
            //
            pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
            ASSERT(pIF->Hdr.pLock == pAdapter->Hdr.pLock);
            ASSERT(pAdapter->pIF == pIF);
            pAdapter->pIF = NULL;

            // Clear ourselves as the primary task of the interface object.
            //
            arpClearPrimaryIfTask(pIF, pTask, ARPIF_PS_DEINITED, pSR);

            // Deallocate the IF (adapter lock must be held when calling this)
            //
            arpDeleteInterface(pIF, pSR);

            UNLOCKOBJ(pAdapter, pSR);

            // Force status to be success
            //
            Status = NDIS_STATUS_SUCCESS;
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)


    if (fTryInitiateUnload)
    {
        LOCKOBJ(pIF, pSR);
        if (pIF->pPrimaryTask!=NULL)
        {
            //
            // There is an existing primary task -- we wait for it to complete.
            //
            PRM_TASK pPrimaryTask = pIF->pPrimaryTask;
            RmTmpReferenceObject(&pPrimaryTask->Hdr, pSR);
            UNLOCKOBJ(pIF,pSR);
            RmPendTaskOnOtherTask(
                pTask,
                PEND_ExistingPrimaryTaskComplete,
                pPrimaryTask,
                pSR
                );
            arpTryAbortPrimaryIfTask(pIF, pSR);
            RmTmpDereferenceObject(&pPrimaryTask->Hdr, pSR);
            Status = NDIS_STATUS_PENDING;
        }
        else  if (!RM_IS_ZOMBIE(pIF))
        {
            //
            // There is no primary task currently, and the IF is not already
            // been unloaded -- make pTask the primary task,
            // and initiate deactivation of  the IF. When it's done, we'll actually
            // delete the IF.
            //
            arpSetPrimaryIfTask(pIF, pTask, ARPIF_PS_DEINITING, pSR);
            UNLOCKOBJ(pIF,pSR);
            arpDeactivateIf(pIF, pTask, PEND_DeactivateIfComplete, pSR);
            Status = NDIS_STATUS_PENDING;
        }
        else
        {
            // pIF is already unloaded....
            //
            UNLOCKOBJ(pIF, pSR);
            Status = NDIS_STATUS_SUCCESS;
        }
    }

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskReinitInterface(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    Task handler responsible for reiniting (deactivating, then activating)
    an interface.

    This is a primary interface task.

Arguments:

    UserParam   for (Code ==  RM_TASKOP_START)          : unused
    
--*/
{
    NDIS_STATUS         Status;
    PARP1394_INTERFACE  pIF;
    MYBOOL              fTryInitiateReinit;
    enum
    {
        PEND_ExistingPrimaryTaskComplete,
        PEND_DeactivateIfComplete,
        PEND_ActivateIfComplete,
        PEND_DeinitInterfaceOnFailureComplete
    };
    ENTER("TaskReinitInterface", 0x8b670f05)
    Status              = NDIS_STATUS_FAILURE;
    pIF                 = (PARP1394_INTERFACE) RM_PARENT_OBJECT(pTask);
    fTryInitiateReinit  = FALSE;

    switch(Code)
    {
        case RM_TASKOP_START:
        {
            fTryInitiateReinit = TRUE;
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            Status = (NDIS_STATUS) UserParam;

            switch(RM_PEND_CODE(pTask))
            {
                case PEND_ExistingPrimaryTaskComplete:
                {
                    fTryInitiateReinit = TRUE;
                }
                break;

                case PEND_DeactivateIfComplete:
                {
                    //
                    // We're done deactivating the IF. We now
                    // activate the IF.
                    //
                    arpActivateIf(pIF, pTask, PEND_ActivateIfComplete, pSR);
                    Status = NDIS_STATUS_PENDING;
                }
                break;

                case PEND_ActivateIfComplete:
                {
                    // We're done activating the IF. 
                    //
                    LOCKOBJ(pIF, pSR);
                    if (FAIL(Status))
                    {
                        arpClearPrimaryIfTask(pIF, pTask, ARPIF_PS_FAILEDINIT, pSR);
                        UNLOCKOBJ(pIF, pSR);

                        arpDeinitIf(
                                pIF,
                                pTask,          //  pCallingTask
                                PEND_DeinitInterfaceOnFailureComplete,
                                pSR
                                );
                        Status = NDIS_STATUS_PENDING;
                    }
                    else
                    {
                        // 
                        // Successful activation. Clear the primary task
                        // and set the primary state appropriately.
                        //
                        arpClearPrimaryIfTask(pIF, pTask, ARPIF_PS_INITED, pSR);
                        UNLOCKOBJ(pIF, pSR);
                    }

                } // end case PEND_ActivateIfComplete
                break;
    
                case  PEND_DeinitInterfaceOnFailureComplete:
                {
                    // We expect pIF to be deallocated...
                    //
                    ASSERT(RM_IS_ZOMBIE(pIF));

                    //
                    // We ignore the return status of deinit inteface.
                    // and set Status to failure, because it is
                    // the reinit interface task that is failing.
                    //
                    Status = NDIS_STATUS_FAILURE;
                }
                break;
            }
        }
        break;

        case RM_TASKOP_END:
        {
            PARP1394_ADAPTER    pAdapter;
            PTASK_REINIT_IF     pReinitTask;

            pAdapter    = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);
            pReinitTask = (PTASK_REINIT_IF) pTask;
            Status = (NDIS_STATUS) UserParam;

            if (FAIL(Status))
            {
                ASSERT(RM_IS_ZOMBIE(pIF));
            }
            ASSERT(pIF->pPrimaryTask != pTask);

            //
            // IF the reconfig event is non NULL, signal completion of the net pnp
            // event that started this
            // reconfig task. No need to claim any locks here -- the fields
            // referenced below are not going to change...
            //
            if (pReinitTask->pNetPnPEvent != NULL)
            {
                NdisCompletePnPEvent(
                    Status,
                    pAdapter->bind.AdapterHandle,
                    pReinitTask->pNetPnPEvent
                    );
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)


    if (fTryInitiateReinit)
    {
        LOCKOBJ(pIF, pSR);
        if (pIF->pPrimaryTask!=NULL)
        {
            //
            // There is an existing primary task -- we wait for it to complete.
            //
            PRM_TASK pPrimaryTask = pIF->pPrimaryTask;
            RmTmpReferenceObject(&pIF->pPrimaryTask->Hdr, pSR);
            UNLOCKOBJ(pIF,pSR);
            RmPendTaskOnOtherTask(
                pTask,
                PEND_ExistingPrimaryTaskComplete,
                pPrimaryTask,
                pSR
                );
            RmTmpDereferenceObject(&pIF->pPrimaryTask->Hdr, pSR);
            Status = NDIS_STATUS_PENDING;
        }
        else
        {
            //
            // There is no primary task currently -- make pTask the primary task,
            // and initiate deactivation of  the IF. When it's done, we'll
            // reactivate the IF.
            //
            arpSetPrimaryIfTask(pIF, pTask, ARPIF_PS_REINITING, pSR);
            UNLOCKOBJ(pIF,pSR);
            arpDeactivateIf(pIF, pTask, PEND_DeactivateIfComplete, pSR);
            Status = NDIS_STATUS_PENDING;
        }
    }

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskUnloadLocalIp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    Task handler responsible for shutting down an IP interface.

    3/26/1999 JosephJ    TODO -- this being one of the earlier-written tasks,
    is ripe for a re-write!

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused
--*/
{
    ENTER("TaskUnloadLocalIp", 0xf42aaa68)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARPCB_LOCAL_IP* pLocalIp    = (ARPCB_LOCAL_IP*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE *pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pLocalIp);

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OtherUnloadComplete,
        PEND_AddressRegistrationComplete
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pLocalIp, pSR);

            // First check if pLocalIp is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pLocalIp))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // pLocalIp is allocated. Now check if there is already a
            // shutdown task attached to pLocalIp.
            //
            if (pLocalIp->pUnloadTask != NULL)
            {
                //
                // There is a shutdown task. We pend on it.
                //

                PRM_TASK pOtherTask = pLocalIp->pUnloadTask;
                TR_WARN(("Unload task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pLocalIp, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherUnloadComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no unload task going on. Let's
            // make this task THE unload task.
            // 
            pLocalIp->pUnloadTask = pTask;

            //
            // Since we're THE unload task, add an association to pLocalIp,
            // which will only get cleared when the pLocalIp->pUnloadTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pLocalIp->Hdr,                     // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_LOCALIP_UNLOAD_TASK,       // AssociationID
                "    Official unload task 0x%p (%s)\n", // szFormat
                pSR
                );

            //
            // If there is a registration task going, we cancel it and
            // wait for it to complete.
            //
            if (pLocalIp->pRegistrationTask != NULL)
            {
                PRM_TASK pOtherTask = pLocalIp->pRegistrationTask;
                TR_WARN(("Registration task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);

                UNLOCKOBJ(pLocalIp, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_AddressRegistrationComplete,
                    pOtherTask,
                    pSR
                    );
                //
                // TODO  Cancel Registration task (we haven't implemented cancel
                // yet!)
                //
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We're here because there is no async unload work to be done.
            // We simply return and finish synchronous cleanup in the END
            // handler for this task.
            //
            Status = NDIS_STATUS_SUCCESS;
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OtherUnloadComplete:
                {
        
                    //
                    // There was another unload task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    // TODO need standard way to propagate the error code.
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    
    
                case  PEND_AddressRegistrationComplete:
                {
                    //
                    // There was address-registration going on, but how it's
                    // complete. We should be able to synchronously clean up
                    // this task now
                    //

                    //
                    // If we're here, that means we're THE official unload
                    // task. Let's assert that fact.
                    // (no need to get the lock on the object).
                    //
                    ASSERTEX(pLocalIp->pUnloadTask == pTask, pLocalIp);

                    Status      = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pLocalIp, pSR);

            //
            // We're done. There should be no async activities left to do.
            //
            ASSERTEX(pLocalIp->pRegistrationTask == NULL, pLocalIp);

            //
            // If we're THE unload task, we go on and deallocate the object.
            //
            if (pLocalIp->pUnloadTask == pTask)
            {
                PARPCB_DEST pDest = pLocalIp->pDest;

                //
                // pLocalIp had better not be in a zombie state -- THIS task
                // is the one responsible for deallocating the object!
                //
                ASSERTEX(!RM_IS_ZOMBIE(pLocalIp), pLocalIp);

                if (pDest != NULL)
                {
                    RmTmpReferenceObject(&pDest->Hdr, pSR);
                    arpUnlinkLocalIpFromDest(pLocalIp, pSR);
                }

                pLocalIp->pUnloadTask = NULL;

                // Delete the association we added when we set
                // pLocalIp->pUnloadTask to pTask.
                //
                DBG_DELASSOC(
                    &pLocalIp->Hdr,                     // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_LOCALIP_UNLOAD_TASK,       // AssociationID
                    pSR
                    );

                RmFreeObjectInGroup(
                    &pIF->LocalIpGroup,
                    &(pLocalIp->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );

                ASSERTEX(RM_IS_ZOMBIE(pLocalIp), pLocalIp);

                UNLOCKOBJ(pLocalIp, pSR);

                //
                // If we were linked to a pDest, we unload it if it's
                // no longer used by anyone else.
                //
                if (pDest != NULL)
                {
                    arpDeinitDestination(pDest, TRUE, pSR); // TRUE==only if
                                                              // unused.

                    RmTmpDereferenceObject(&pDest->Hdr, pSR);
                }
            }
            else
            {
                //
                // We weren't THE unload task, nothing left to do.
                // The object had better be in the zombie state..
                //

                ASSERTEX(
                    pLocalIp->pUnloadTask == NULL && RM_IS_ZOMBIE(pLocalIp),
                    pLocalIp
                    );
                Status = NDIS_STATUS_SUCCESS;
            }

            Status = (NDIS_STATUS) UserParam;
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskUnloadRemoteIp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
    This task is responsible for shuttingdown and eventually deleting a remote IP
    object.

    It goes through the following stages:
        - Cancel any ongoing address resolution and wait for that to complete.
        - Unlink itself from a Destination object, if it's linked to one.
        - Remove itself from the interface's LocalIpGroup (and thereby deallocate
          itself).
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskUnloadRemoteIp", 0xf42aaa68)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARPCB_REMOTE_IP*    pRemoteIp   = (ARPCB_REMOTE_IP*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE *pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pRemoteIp);

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_AtPassiveLevel,
        PEND_OtherUnloadComplete,   
        PEND_SendPktsComplete,
        PEND_ResolutionComplete
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pRemoteIp, pSR);

            // First check if pRemoteIp is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pRemoteIp))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }


            //
            // pRemoteIp is allocated. Now check if there is already a
            // shutdown task attached to pRemoteIp.
            //
            if (pRemoteIp->pUnloadTask != NULL)
            {
                //
                // There is a shutdown task. We pend on it.
                //

                PRM_TASK pOtherTask = pRemoteIp->pUnloadTask;
                TR_WARN(("Unload task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pRemoteIp, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherUnloadComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no unload task going on. Let's
            // make this task THE unload task.
            // 
            pRemoteIp->pUnloadTask = pTask;

            //
            // Since we're THE unload task, add an association to pRemoteIp,
            // which will only get cleared when the  pRemoteIp->pUnloadTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pRemoteIp->Hdr,                    // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_REMOTEIP_UNLOAD_TASK,      // AssociationID
                "    Official unload task 0x%p (%s)\n", // szFormat
                pSR
                );


            //
            // if we are at dpc level then resume at passive
            //
            
            RmSuspendTask(pTask, PEND_AtPassiveLevel, pSR);

            UNLOCKOBJ(pRemoteIp,pSR);
            
            Status = NDIS_STATUS_PENDING;


            if (!ARP_ATPASSIVE())
            {

                // We're not at passive level, . So we switch to passive...
                //
                RmResumeTaskAsync(
                    pTask,
                    Status,
                    &((TASK_UNLOAD_REMOTE*)pTask)->WorkItem,
                    pSR
                    );
            }
            else
            {   
                // We resume right away if we are already at passive
                RmResumeTask(pTask,PEND_AtPassiveLevel,pSR);
            }

            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case PEND_AtPassiveLevel:
                {
                    LOCKOBJ (pRemoteIp, pSR);
                    //
                    // If there is a SendPkts task going, we cancel it and
                    // wait for it to complete.
                    // WARNING: We only do this check and wait ONCE. So we RELY
                    // on the fact that once there is a NONNULL pRemoteIp->pUnloadTask,
                    // NO NEW pSendPktsTasks will bind itself to pRemoteIP. If you
                    // look at the code for  arpTaskSendPktsOnRemoteIp,  you will
                    // see that it does not bind itself if pRemoteIp->pUnloadTask is nonnull
                    //
                    if (pRemoteIp->pSendPktsTask != NULL)
                    {
                        PRM_TASK pOtherTask = pRemoteIp->pSendPktsTask;
                        TR_WARN(("SendPkts task %p exists; pending on it.\n", pOtherTask));
                        RmTmpReferenceObject(&pOtherTask->Hdr, pSR);

                        UNLOCKOBJ(pRemoteIp, pSR);
                        RmPendTaskOnOtherTask(
                            pTask,
                            PEND_SendPktsComplete,
                            pOtherTask,
                            pSR
                            );
                        //
                        // TODO  Cancel SendPks task (we haven't implemented cancel
                        // yet!)
                        //
                        RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                        Status = NDIS_STATUS_PENDING;
                        break;
                    }

                    //
                    // We're here because there is no async unload work to be done.
                    // We simply return and finish synchronous cleanup in the END
                    // handler for this task.
                    //
                    if (pRemoteIp->pResolutionTask != NULL)
                    {
                        PRM_TASK pOtherTask = pRemoteIp->pResolutionTask ;
                        TR_WARN(("Resolution task %p exists; pending on it.\n", pOtherTask));
                        RmTmpReferenceObject(&pOtherTask->Hdr, pSR);

                        UNLOCKOBJ(pRemoteIp, pSR);
                        RmPendTaskOnOtherTask(
                            pTask,
                            PEND_ResolutionComplete,
                            pOtherTask,
                            pSR
                            );

                        RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                        Status = NDIS_STATUS_PENDING;
                        break;
            
                    }

                    //
                    // If there were no tasks pending then we have completed our task.
                    //
                    Status = NDIS_STATUS_SUCCESS;
                    
                }
                break;
                case  PEND_OtherUnloadComplete:
                {
        
                    //
                    // There was another unload task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    // TODO need standard way to propagate the error code.
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    
                case  PEND_SendPktsComplete:
                {
                    //
                    // There was a SendPktsTask going on, but how it's
                    // complete. We should be able to synchronously clean up
                    // this task now
                    //

                    //
                    // If we're here, that means we're THE official unload
                    // task. Let's assert that fact.
                    // (no need to get the lock on the object).
                    //
                    ASSERT(pRemoteIp->pUnloadTask == pTask);

                    Status      = NDIS_STATUS_SUCCESS;
                }
                break;

                case PEND_ResolutionComplete:
                {
                    //
                    // There was a resolution Task going on, but how it's
                    // complete. We should be able to synchronously clean up
                    // this task now
                    //

                    //
                    // If we're here, that means we're THE official unload
                    // task. Let's assert that fact.
                    // (no need to get the lock on the object).
                    //
                    ASSERT(pRemoteIp->pUnloadTask == pTask);

                    Status      = NDIS_STATUS_SUCCESS;

                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pRemoteIp, pSR);

            //
            // We're done. There should be no async activities left to do.
            //
            ASSERTEX(pRemoteIp->pResolutionTask == NULL, pRemoteIp);
            ASSERTEX(pRemoteIp->pSendPktsTask == NULL, pRemoteIp);

            //
            // If we're THE unload task, we go on and deallocate the object.
            //
            if (pRemoteIp->pUnloadTask == pTask)
            {
                PARPCB_DEST pDest = pRemoteIp->pDest;

                //
                // pRemoteIp had better not be in a zombie state -- THIS task
                // is the one responsible for deallocating the object!
                //
                ASSERTEX(!RM_IS_ZOMBIE(pRemoteIp), pRemoteIp);

                if (pDest != NULL)
                {
                    RmTmpReferenceObject(&pDest->Hdr, pSR);
                    arpUnlinkRemoteIpFromDest(pRemoteIp, pSR);
                }
                pRemoteIp->pUnloadTask = NULL;

                // Del  the association between pRCE and pRemoteIp...
                //
                ARP_WRITELOCK_IF_SEND_LOCK(pIF, pSR);

                arpDelRceList(pRemoteIp, pSR);   

                ARP_UNLOCK_IF_SEND_LOCK(pIF, pSR);
                

                RmFreeObjectInGroup(
                    &pIF->RemoteIpGroup,
                    &(pRemoteIp->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );

                ASSERTEX(RM_IS_ZOMBIE(pRemoteIp), pRemoteIp);
                     
                // Delete the association we added when we set
                // pRemoteIp->pUnloadTask to pTask.
                //
                DBG_DELASSOC(
                    &pRemoteIp->Hdr,                    // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_REMOTEIP_UNLOAD_TASK,      // AssociationID
                    pSR
                    );

                UNLOCKOBJ(pRemoteIp, pSR);

                //
                // If we were linked to a pDest, we unload it if it's
                // no longer used by anyone else.
                //
                if (pDest != NULL)
                {
                    arpDeinitDestination(pDest, TRUE, pSR); // TRUE==only if
                                                              // unused.

                    RmTmpDereferenceObject(&pDest->Hdr, pSR);
                }
            }
            else
            {
                //
                // We weren't THE unload task, nothing left to do.
                // The object had better be in the zombie state..
                //

                ASSERTEX(
                    pRemoteIp->pUnloadTask == NULL && RM_IS_ZOMBIE(pRemoteIp),
                    pRemoteIp
                    );
                Status = NDIS_STATUS_SUCCESS;
            }

            Status = (NDIS_STATUS) UserParam;
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskUnloadRemoteEth(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
    This task is responsible for shuttingdown and eventually deleting a remote IP
    object.

    It goes through the following stages:
        - Cancel any ongoing address resolution and wait for that to complete.
        - Unlink itself from a Destination object, if it's linked to one.
        - Remove itself from the interface's LocalIpGroup (and thereby deallocate
          itself).
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskUnloadRemoteEth", 0xf42aaa68)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARPCB_REMOTE_ETH*   pRemoteEth  = (ARPCB_REMOTE_ETH*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE *pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pRemoteEth);

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_AtPassiveLevel,
        PEND_OtherUnloadComplete
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pRemoteEth, pSR);

            // First check if pRemoteEth is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pRemoteEth))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // pRemoteEth is allocated. Now check if there is already a
            // shutdown task attached to pRemoteEth.
            //
            if (pRemoteEth->pUnloadTask != NULL)
            {
                //
                // There is a shutdown task. We pend on it.
                //

                PRM_TASK pOtherTask = pRemoteEth->pUnloadTask;
                TR_WARN(("Unload task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pRemoteEth, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherUnloadComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no unload task going on. Let's
            // make this task THE unload task.
            // 
            pRemoteEth->pUnloadTask = pTask;

            //
            // Since we're THE unload task, add an association to pRemoteEth,
            // which will only get cleared when the  pRemoteEth->pUnloadTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pRemoteEth->Hdr,                   // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_REMOTEETH_UNLOAD_TASK,     // AssociationID
                "    Official unload task 0x%p (%s)\n", // szFormat
                pSR
                );

            //
            // We're here because there is no async unload work to be done.
            
            //
            // if we are at dpc level then resume at passive
            //
            
            RmSuspendTask(pTask, PEND_AtPassiveLevel, pSR);

            UNLOCKOBJ(pRemoteEth,pSR);
            
            Status = NDIS_STATUS_PENDING;


            if (!ARP_ATPASSIVE())
            {

                // We're not at passive level, . So we switch to passive...
                //
                RmResumeTaskAsync(
                    pTask,
                    Status,
                    &((TASK_UNLOAD_REMOTE*)pTask)->WorkItem,
                    pSR
                    );
            }
            else
            {   
                // We resume right away if we are already at passive
                RmResumeTask(pTask,PEND_AtPassiveLevel,pSR);
            }


            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_AtPassiveLevel:
                {

                    //
                    Status = NDIS_STATUS_SUCCESS;

                }
                break;
                case  PEND_OtherUnloadComplete:
                {
        
                    //
                    // There was another unload task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    // TODO need standard way to propagate the error code.
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pRemoteEth, pSR);

            //
            // We're done. There should be no async activities left to do.
            //

            //
            // If we're THE unload task, we go on and deallocate the object.
            //
            if (pRemoteEth->pUnloadTask == pTask)
            {
                //
                // pRemoteEth had better not be in a zombie state -- THIS task
                // is the one responsible for deallocating the object!
                //
                ASSERTEX(!RM_IS_ZOMBIE(pRemoteEth), pRemoteEth);

                pRemoteEth->pUnloadTask = NULL;

                RmFreeObjectInGroup(
                    &pIF->RemoteEthGroup,
                    &(pRemoteEth->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );

                ASSERTEX(RM_IS_ZOMBIE(pRemoteEth), pRemoteEth);
                     
                // Delete the association we added when we set
                // pRemoteEth->pUnloadTask to pTask.
                //
                DBG_DELASSOC(
                    &pRemoteEth->Hdr,                   // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_REMOTEETH_UNLOAD_TASK,     // AssociationID
                    pSR
                    );

                UNLOCKOBJ(pRemoteEth, pSR);

            }
            else
            {
                //
                // We weren't THE unload task, nothing left to do.
                // The object had better be in the zombie state..
                //

                ASSERTEX(
                    pRemoteEth->pUnloadTask == NULL && RM_IS_ZOMBIE(pRemoteEth),
                    pRemoteEth
                    );
                Status = NDIS_STATUS_SUCCESS;
            }

            Status = (NDIS_STATUS) UserParam;
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}

NDIS_STATUS
arpTaskUnloadDestination(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for unloading a destination.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskUnloadDestination", 0x93f66831)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARPCB_DEST* pDest   = (ARPCB_DEST*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE *pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pDest);

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OtherUnloadComplete,
        PEND_CleanupVcComplete
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pDest, pSR);

            // First check if pDest is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pDest))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // pDest is allocated. Now check if there is already a
            // shutdown task attached to pDest.
            //
            if (pDest->pUnloadTask != NULL)
            {
                //
                // There is a shutdown task. We pend on it.
                //

                PRM_TASK pOtherTask = pDest->pUnloadTask;
                TR_WARN(("Unload task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pDest, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherUnloadComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no unload task going on. Let's
            // make this task THE unload task.
            // 
            pDest->pUnloadTask = pTask;

            //
            // Since we're THE unload task, add an association to pDest,
            // which will only get cleared when the  pDest->pUnloadTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pDest->Hdr,                        // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_DEST_UNLOAD_TASK,      // AssociationID
                "    Official unload task 0x%p (%s)\n", // szFormat
                pSR
                );

            //
            // If the VC state needs cleaning up, we need to get a task
            // going to clean it up.
            //
            if (arpNeedToCleanupDestVc(pDest))
            {
                PRM_TASK pCleanupCallTask = pDest->VcHdr.pCleanupCallTask;

                // If there is already an official cleanup-vc task, we pend on it.
                // Other wise we allocate our own, pend on it, and start it.
                //
                if (pCleanupCallTask != NULL)
                {
                    TR_WARN((
                        "Cleanup-vc task %p exists; pending on it.\n",
                         pCleanupCallTask));
                    RmTmpReferenceObject(&pCleanupCallTask->Hdr, pSR);
    
                    UNLOCKOBJ(pDest, pSR);
                    RmPendTaskOnOtherTask(
                        pTask,
                        PEND_CleanupVcComplete,
                        pCleanupCallTask,
                        pSR
                        );

                    RmTmpDereferenceObject(&pCleanupCallTask->Hdr, pSR);
                    Status = NDIS_STATUS_PENDING;
                    break;
                }
                else
                {
                    //
                    // Start the call cleanup task and pend on int.
                    //

                    UNLOCKOBJ(pDest, pSR);
                    RM_ASSERT_NOLOCKS(pSR);

                    Status = arpAllocateTask(
                                &pDest->Hdr,                // pParentObject,
                                arpTaskCleanupCallToDest,   // pfnHandler,
                                0,                          // Timeout,
                                "Task: CleanupCall on UnloadDest",  // szDescription
                                &pCleanupCallTask,
                                pSR
                                );
                
                    if (FAIL(Status))
                    {
                        TR_WARN(("FATAL: couldn't alloc cleanup call task!\n"));
                    }
                    else
                    {
                        RmPendTaskOnOtherTask(
                            pTask,
                            PEND_CleanupVcComplete,
                            pCleanupCallTask,               // task to pend on
                            pSR
                            );
                
                        // RmStartTask uses up the tmpref on the task
                        // which was added by arpAllocateTask.
                        //
                        Status = RmStartTask(
                                    pCleanupCallTask,
                                    0, // UserParam (unused)
                                    pSR
                                    );
                    }
                    break;
                }
            }

            //
            // We're here because there is no async unload work to be done.
            // We simply return and finish synchronous cleanup in the END
            // handler for this task.
            //
            Status = NDIS_STATUS_SUCCESS;
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OtherUnloadComplete:
                {
        
                    //
                    // There was another unload task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    // TODO need standard way to propagate the error code.
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    
    
                case  PEND_CleanupVcComplete:
                {
                    //
                    // There was vc-cleanup to be done, but how it's
                    // complete. We should be able to synchronously clean up
                    // this task now
                    //

                #if DBG
                    LOCKOBJ(pDest, pSR);

                    ASSERTEX(!arpNeedToCleanupDestVc(pDest), pDest);

                    //
                    // If we're here, that means we're THE official unload
                    // task. Let's assert that fact.
                    //
                    ASSERT(pDest->pUnloadTask == pTask);

                    UNLOCKOBJ(pDest, pSR);
                #endif DBG

                    Status      = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pDest, pSR);

            //
            // We're done. There should be no async activities left to do.
            //
            ASSERTEX(!arpNeedToCleanupDestVc(pDest), pDest);

            //
            // If we're THE unload task, we go on and deallocate the object.
            //
            if (pDest->pUnloadTask == pTask)
            {
                //
                // pDest had better not be in a zombie state -- THIS task
                // is the one responsible for deallocating the object!
                //
                ASSERTEX(!RM_IS_ZOMBIE(pDest), pDest);

                arpUnlinkAllRemoteIpsFromDest(pDest, pSR);

                RmFreeObjectInGroup(
                    &pIF->DestinationGroup,
                    &(pDest->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );

                ASSERTEX(RM_IS_ZOMBIE(pDest), pDest);

                     
                pDest->pUnloadTask = NULL;

                // Delete the association we added when we set
                // pDest->pUnloadTask to pTask.
                //
                DBG_DELASSOC(
                    &pDest->Hdr,                        // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_DEST_UNLOAD_TASK,      // AssociationID
                    pSR
                    );
            }
            else
            {
                //
                // We weren't THE unload task, nothing left to do.
                // The object had better be in the zombie state..
                //

                ASSERTEX(
                    pDest->pUnloadTask == NULL && RM_IS_ZOMBIE(pDest),
                    pDest
                    );
                Status = NDIS_STATUS_SUCCESS;
            }

            Status = (NDIS_STATUS) UserParam;
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}


// The following structure is to define a set of hard-coded arp entries...
//
typedef struct
{
    IP_ADDRESS              IpAddress;
    NIC1394_FIFO_ADDRESS    DestFifoAddr;

} UNICAST_REMOTE_IP_INFO;


// FakeDestinationsInfo contains information to setup a set of hard-coded 
// arp entries..
//
UNICAST_REMOTE_IP_INFO
FakeDestinationsInfo[] =
{
  //
  //{IpAddr,     {UniqueID, OffLow, OffHi}}
  //
#if 0
    {0x0100000a, {0, 0, 0x100}},    // 10.0.0.1 -> (0, 0, 0x100)
    {0x0200000a, {0, 0, 0x100}},    // 10.0.0.2
    {0x0300000a, {0, 0, 0x100}},    // 10.0.0.3
    {0x0400000a, {0, 0, 0x100}},    // 10.0.0.4
    {0x020000e0, {0, 0, 0x100}},    // 224.0.0.2 (mcast port)
    {0xff00000a, {0, 0, 0x100}},    // 10.0.0.-1 (local bcast)
    {0xffffffff, {0, 0, 0x100}},    // -1.-1.-1.-1 (bcast)
#endif //0

    {0, {0, 0, 0}}, // Must be last -- Indicates end.
};


VOID
arpAddStaticArpEntries(
    IN ARP1394_INTERFACE *pIF,  // LOCKING LOCKOUT
    IN PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Add static items into the RemoteIp group (the arp cache).
    TODO: we currently put in some fake entries.

--*/
{
    UNICAST_REMOTE_IP_INFO *pRemoteIpInfo;
    RM_DBG_ASSERT_LOCKED(&pIF->Hdr, pSR);

    for(
        pRemoteIpInfo =  FakeDestinationsInfo;
        pRemoteIpInfo->IpAddress != 0;
        pRemoteIpInfo++)
    {
        NDIS_STATUS Status;

        Status = arpAddOneStaticArpEntry(
                    pIF,
                    pRemoteIpInfo->IpAddress,
                    &pRemoteIpInfo->DestFifoAddr,
                    pSR
                    );
        if (FAIL(Status))
        {
            break;
        }
    }
}


VOID
arpLinkRemoteIpToDest(
    ARPCB_REMOTE_IP     *pRemoteIp, // LOCKIN LOCKOUT
    ARPCB_DEST          *pDest,     // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Link a remote IP entry (pRemoteIp) to the specified destination HW entry
    (pDest). Update the pRemoteIp's state to indicate that this
    is resolved.

--*/
{
    ENTER("arpLinkRemoteIpToDest", 0x3be06bc6)

    ARP_DUMP_MAPPING(
            pRemoteIp->IpAddress,
            (pDest==NULL)? NULL : &pDest->Params.HwAddr,
            "Linking Remote IP");

    TR_INFO(("Linking IP 0x%08lx to  Dest addr 0x%08lx\n",
                pRemoteIp->IpAddress,
                (UINT) pDest->Params.HwAddr.FifoAddress.UniqueID // Truncation
                ));

    RM_DBG_ASSERT_LOCKED(&pRemoteIp->Hdr, pSR);
    RM_DBG_ASSERT_LOCKED(&pDest->Hdr, pSR);

    if (pRemoteIp->pDest != NULL)
    {
        ASSERT(!"pRemoteIp->pDest != NULL");
    }
    else
    {
        pRemoteIp->pDest = pDest;
        InsertHeadList(&pDest->listIpToThisDest, &pRemoteIp->linkSameDest);
    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            &pRemoteIp->Hdr,
            &pDest->Hdr,
            0x597d0495,
            ARPASSOC_LINK_IPADDR_OF_DEST,
            "    REMOTE_IP of 0x%p (%s)\n",
            ARPASSOC_LINK_DEST_OF_IPADDR,
            "    DEST of 0x%p (%s)\n",
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(&pRemoteIp->Hdr, &pDest->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        // Now set the pRemoteIp state to reflect that it RESOLVED.
        //
        SET_REMOTEIP_RESOLVE_STATE(pRemoteIp, ARPREMOTEIP_RESOLVED);
    }

    EXIT()
}


VOID
arpUnlinkRemoteIpFromDest(
    ARPCB_REMOTE_IP     *pRemoteIp, // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Unlink the remote IP entry (pRemoteIp) from the destination HW entry its
    linked to. Clear pRemoteIp's resolved flag.

--*/
{
    ENTER("arpUnlinkRemoteIpFromDest", 0xc5809147)
    ARPCB_DEST          *pDest = pRemoteIp->pDest;
    
    ARP_DUMP_MAPPING(
            pRemoteIp->Key.IpAddress,
            (pDest==NULL)? NULL : &pDest->Params.HwAddr,
            "Unlink Remote IP");

    TR_INFO(("Unlinking IP 0x%p (Addr 0x%08lx) from  Dest 0x%p (addr 0x%08lx)\n",
                pRemoteIp,
                pRemoteIp->Key.IpAddress,
                pDest,
                (pDest==NULL)
                 ? 0
                 :((UINT) pDest->Params.HwAddr.FifoAddress.UniqueID) // Truncation
                ));
    if (pDest == NULL)
    {
        ASSERT(!"pRemoteIp->pDest == NULL");
    }
    else
    {
        //
        // We assume that both objects share the same lock.
        //
        ASSERT(pRemoteIp->Hdr.pLock == pDest->Hdr.pLock);

        RM_DBG_ASSERT_LOCKED(&pRemoteIp->Hdr, pSR);

        RemoveEntryList(&pRemoteIp->linkSameDest);

        pRemoteIp->pDest = NULL;
    
        // Now set the pRemoteIp state to reflect that it UNRESOLVED.
        //
        SET_REMOTEIP_RESOLVE_STATE(pRemoteIp, ARPREMOTEIP_UNRESOLVED);

    #if RM_EXTRA_CHECKING
        RmUnlinkObjectsEx(
            &pRemoteIp->Hdr,
            &pDest->Hdr,
            0x5ad067aa,
            ARPASSOC_LINK_IPADDR_OF_DEST,
            ARPASSOC_LINK_DEST_OF_IPADDR,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmUnlinkObjects(&pRemoteIp->Hdr, &pDest->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

    }

    EXIT()
}

VOID
arpUnlinkAllRemoteIpsFromDest(
    ARPCB_DEST  *pDest, // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Unlink all RemoteIps (if any) from destination pDest.

--*/
{
    ENTER("arpUnlinkAllRemoteIpsFromDest", 0x35120630)


    TR_INFO(("Unlinking All RemoteIps from  Dest 0x%p (addr 0x%08lx)\n",
                pDest,
                ((UINT) pDest->Params.HwAddr.FifoAddress.UniqueID) // Truncation
                ));

    RM_DBG_ASSERT_LOCKED(&pDest->Hdr, pSR);

    while (!IsListEmpty(&pDest->listIpToThisDest))
    {
        LIST_ENTRY *pLink;
        ARPCB_REMOTE_IP *pRemoteIp;

        pLink = RemoveHeadList(&pDest->listIpToThisDest);
        pRemoteIp = CONTAINING_RECORD(
                    pLink,
                    ARPCB_REMOTE_IP,
                    linkSameDest
                    );
        arpUnlinkRemoteIpFromDest(pRemoteIp, pSR);
    }

    EXIT()
}

VOID
arpLinkLocalIpToDest(
    ARPCB_LOCAL_IP  *pLocalIp,  // LOCKIN LOCKOUT
    ARPCB_DEST          *pDest,     // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Link a remote IP entry (pLocalIp) to the specified destination HW entry
    (pDest). Update the pLocalIp's state to indicate that this
    is resolved.

--*/
{
    ENTER("arpLinkLocalIpToDest", 0x3be06bc6)

    ARP_DUMP_MAPPING(pLocalIp->IpAddress, &pDest->Params.HwAddr, "Linking Local IP");

#if 0
    TR_INFO(("Linking Local IP 0x%08lx to  Dest addr 0x%08lx\n",
                pLocalIp->IpAddress,
                (UINT) pDest->Params.HwAddr.FifoAddress.UniqueID // Truncation
                ));
#endif // 0

    RM_DBG_ASSERT_LOCKED(&pLocalIp->Hdr, pSR);
    RM_DBG_ASSERT_LOCKED(&pDest->Hdr, pSR);

    if (pLocalIp->pDest != NULL)
    {
        ASSERT(!"pLocalIp->pDest != NULL");
    }
    else
    {
        //
        // LocalIps may only be linked to pDests of type
        // ReceiveOnly.
        //
        ASSERT(pDest->Params.ReceiveOnly);

        pLocalIp->pDest = pDest;
        InsertHeadList(&pDest->listLocalIp, &pLocalIp->linkSameDest);
    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            &pLocalIp->Hdr,
            &pDest->Hdr,
            0x597d0495,
            ARPASSOC_LINK_IPADDR_OF_DEST,
            "    LOCAL_IP of 0x%p (%s)\n",
            ARPASSOC_LINK_DEST_OF_IPADDR,
            "    DEST of Local 0x%p (%s)\n",
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(&pLocalIp->Hdr, &pDest->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

    }

    EXIT()
}


VOID
arpUnlinkLocalIpFromDest(
    ARPCB_LOCAL_IP  *pLocalIp,  // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Unlink the local IP entry (pLocalIp) from the destination HW entry its
    linked to.

--*/
{
    ENTER("arpUnlinkLocalIpFromDest", 0xc5809147)
    ARPCB_DEST          *pDest = pLocalIp->pDest;
    

    ARP_DUMP_MAPPING(
            pLocalIp->IpAddress,
            (pDest==NULL)? NULL : &pDest->Params.HwAddr,
            "Unlink Local IP");

    TR_INFO(("Unlinking Local IP 0x%p (Addr 0x%08lx) from  Dest 0x%p (addr 0x%08lx)\n",
                pLocalIp,
                pLocalIp->IpAddress,
                pDest,
                (pDest==NULL)
                 ? 0
                 :((UINT) pDest->Params.HwAddr.FifoAddress.UniqueID) // Truncation
                ));
    if (pDest == NULL)
    {
        ASSERT(!"pLocalIp->pDest == NULL");
    }
    else
    {
        //
        // We assume that both objects share the same lock.
        //
        ASSERT(pLocalIp->Hdr.pLock == pDest->Hdr.pLock);

        RM_DBG_ASSERT_LOCKED(&pLocalIp->Hdr, pSR);

        //
        // LocalIps may only be unlinked from pDests of type
        // ReceiveOnly.
        //
        ASSERT(pDest->Params.ReceiveOnly);

        RemoveEntryList(&pLocalIp->linkSameDest);

    #if RM_EXTRA_CHECKING
        RmUnlinkObjectsEx(
            &pLocalIp->Hdr,
            &pDest->Hdr,
            0x5ad067aa,
            ARPASSOC_LINK_IPADDR_OF_DEST,
            ARPASSOC_LINK_DEST_OF_IPADDR,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmUnlinkObjects(&pLocalIp->Hdr, &pDest->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        pLocalIp->pDest = NULL;
    
    }

    EXIT()
}

VOID
arpUnlinkAllLocalIpsFromDest(
    ARPCB_DEST  *pDest, // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Unlink all Localif any) from destination pDest.

--*/
{
    ENTER("arpUnlinkAllLocalIpsFromDest", 0x35120630)


    TR_INFO(("Unlinking All LocalIps from  Dest 0x%p (addr 0x%08lx)\n",
                pDest,
                ((UINT) pDest->Params.HwAddr.FifoAddress.UniqueID) // Truncation
                ));

    RM_DBG_ASSERT_LOCKED(&pDest->Hdr, pSR);

    //
    // LocalIps may only be unlinked from pDests of type
    // ReceiveOnly.
    //
    ASSERT(pDest->Params.ReceiveOnly);

    while (!IsListEmpty(&pDest->listLocalIp))
    {
        LIST_ENTRY *pLink;
        ARPCB_LOCAL_IP  *pLocalIp;

        pLink = RemoveHeadList(&pDest->listLocalIp);
        pLocalIp = CONTAINING_RECORD(
                    pLink,
                    ARPCB_LOCAL_IP,
                    linkSameDest
                    );
        arpUnlinkLocalIpFromDest(pLocalIp, pSR);
    }

    EXIT()
}


MYBOOL
arpNeedToCleanupDestVc(
        ARPCB_DEST *pDest   // LOCKING LOCKOUT
        )
/*++

Routine Description:

    Deterinine if we need to do any cleanup work on destination pDest.
    "Cleanup work" includes if there is any ongoing asynchronous activity
    involving pDest, such as a make call or close call in progress.

Return Value:

    TRUE    iff there is cleanup work to be done.
    FALSE   otherwise.

--*/
{
    // Note -- return true if  pDest->VcHdr.pCleanupCallTask is non-NULL, even if there
    // is nothing else to be done -- we do have to wait for this pCleanupCallTask
    // to complete.
    if (    pDest->VcHdr.pMakeCallTask != NULL
        ||  pDest->VcHdr.pCleanupCallTask!=NULL
        ||  pDest->VcHdr.NdisVcHandle!=NULL)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


PRM_OBJECT_HEADER
arpLocalIpCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARPCB_LOCAL_IP.

Arguments:

    pParentObject   - Actually a pointer to the interface (ARP1394_INTERFACE)
    pCreateParams   - Actually the IP address (not a pointer to the IP address)
                      to associate with this local IP.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ARPCB_LOCAL_IP *pLocalIp;
    PRM_OBJECT_HEADER pHdr;
    NDIS_STATUS Status;

    Status =  ARP_ALLOCSTRUCT(pLocalIp, MTAG_LOCAL_IP);

    if (Status != NDIS_STATUS_SUCCESS || pLocalIp== NULL)
    {
        return NULL;
    }

    ARP_ZEROSTRUCT(pLocalIp);

    pHdr = (PRM_OBJECT_HEADER) pLocalIp;
    ASSERT(pHdr == &pLocalIp->Hdr);

    // We expect the parent object to be the IF object!
    //
    ASSERT(pParentObject->Sig == MTAG_INTERFACE);
    

    if (pHdr)
    {

        RmInitializeHeader(
            pParentObject,
            pHdr,
            MTAG_LOCAL_IP,
            pParentObject->pLock,
            &ArpGlobal_LocalIpStaticInfo,
            NULL, // szDescription
            pSR
            );

            pLocalIp->IpAddress = (IP_ADDRESS) (UINT_PTR) pCreateParams;
    }
    return pHdr;
}


VOID
arpLocalIpDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        )
/*++

Routine Description:

    Free an object of type ARPCB_LOCAL_IP.

Arguments:

    pHdr    - Actually a pointer to the local ip object to be freed.

--*/
{
    ARPCB_LOCAL_IP *pLocalIp = (ARPCB_LOCAL_IP *) pHdr;
    ASSERT(pLocalIp->Hdr.Sig == MTAG_LOCAL_IP);
    pLocalIp->Hdr.Sig = MTAG_FREED;

    ARP_FREE(pHdr);
}

PRM_OBJECT_HEADER
arpRemoteIpCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARPCB_REMOTE_IP.

Arguments:

    pParentObject   - Actually a pointer to the interface (ARP1394_INTERFACE)
    pCreateParams   - Actually the IP address (not a pointer to the IP address)
                      to associate with this remote IP object.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ARPCB_REMOTE_IP *pRemoteIp;
    PRM_OBJECT_HEADER pHdr;
    NDIS_STATUS Status;  

    Status = ARP_ALLOCSTRUCT(pRemoteIp, MTAG_REMOTE_IP);

    if (Status != NDIS_STATUS_SUCCESS || pRemoteIp == NULL)
    {
        return NULL;
    }
    
    ARP_ZEROSTRUCT(pRemoteIp);

    pHdr = (PRM_OBJECT_HEADER) pRemoteIp;
    ASSERT(pHdr == &pRemoteIp->Hdr);

    // We expect the parent object to be the IF object!
    //
    ASSERT(pParentObject->Sig == MTAG_INTERFACE);
    

    if (pHdr)
    {
        RmInitializeHeader(
            pParentObject,
            pHdr,
            MTAG_REMOTE_IP,
            pParentObject->pLock,
            &ArpGlobal_RemoteIpStaticInfo,
            NULL, // szDescription
            pSR
            );

        pRemoteIp->IpAddress = (IP_ADDRESS) (UINT_PTR) pCreateParams;

        // Initialize  various other stuff...
        InitializeListHead(&pRemoteIp->sendinfo.listSendPkts);

        if (arpCanTryMcap(pRemoteIp->IpAddress))
        {
            SET_REMOTEIP_MCAP(pRemoteIp,  ARPREMOTEIP_MCAP_CAPABLE);
        }
    }
    return pHdr;
}


PRM_OBJECT_HEADER
arpRemoteEthCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARPCB_REMOTE_ETH.

Arguments:

    pParentObject   - Actually a pointer to the interface (ARP1394_INTERFACE)
    pCreateParams   - Points to a ARP_REMOTE_ETH_PARAMS structure
                      to associate with this remote IP object.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ARPCB_REMOTE_ETH *pRemoteEth;
    PARP_REMOTE_ETH_PARAMS pMyParams =  (PARP_REMOTE_ETH_PARAMS) pCreateParams;
    PRM_OBJECT_HEADER pHdr;
    NDIS_STATUS Status;

    Status = ARP_ALLOCSTRUCT(pRemoteEth, MTAG_REMOTE_ETH);

    if (Status != NDIS_STATUS_SUCCESS || pRemoteEth == NULL) 
    {
        return NULL;
    }
    
    ARP_ZEROSTRUCT(pRemoteEth);

    pHdr = (PRM_OBJECT_HEADER) pRemoteEth;
    ASSERT(pHdr == &pRemoteEth->Hdr);

    // We expect the parent object to be the IF object!
    //
    ASSERT(pParentObject->Sig == MTAG_INTERFACE);
    

    if (pHdr)
    {
        RmInitializeHeader(
            pParentObject,
            pHdr,
            MTAG_REMOTE_ETH,
            pParentObject->pLock,
            &ArpGlobal_RemoteEthStaticInfo,
            NULL, // szDescription
            pSR
            );

        pRemoteEth->IpAddress = pMyParams->IpAddress;
        pRemoteEth->EthAddress = pMyParams->EthAddress;

    }
    return pHdr;
}


VOID
arpRemoteIpDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        )
/*++

Routine Description:

    Free an object of type ARPCB_REMOTE_IP.

Arguments:

    pHdr    - Actually a pointer to the remote ip object to be freed.

--*/
{
    ARPCB_REMOTE_IP *pRemoteIp = (ARPCB_REMOTE_IP *) pHdr;
    ASSERT(pRemoteIp->Hdr.Sig == MTAG_REMOTE_IP);
    pRemoteIp->Hdr.Sig = MTAG_FREED;

    ARP_FREE(pHdr);
}


VOID
arpRemoteEthDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        )
/*++

Routine Description:

    Free an object of type ARPCB_REMOTE_IP.

Arguments:

    pHdr    - Actually a pointer to the remote ip object to be freed.

--*/
{
    ARPCB_REMOTE_ETH *pRemoteEth = (ARPCB_REMOTE_ETH *) pHdr;
    ASSERT(pRemoteEth->Hdr.Sig == MTAG_REMOTE_ETH);
    pRemoteEth->Hdr.Sig = MTAG_FREED;

    ARP_FREE(pHdr);
}

PRM_OBJECT_HEADER
arpDestinationCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARPCB_DEST.

Arguments:

    pParentObject   - Actually a pointer to the interface (ARP1394_INTERFACE)
    pCreateParams   - Actually a pointer to a ARP_DEST_KEY containing
                      the hw addresses to associate with this object.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ARPCB_DEST *pDest;
    PRM_OBJECT_HEADER pHdr;
    NDIS_STATUS Status;
    
    Status = ARP_ALLOCSTRUCT(pDest, MTAG_DEST);

    if (Status != NDIS_STATUS_SUCCESS || pDest == NULL)
    {
        return NULL;
    }
    
    ARP_ZEROSTRUCT(pDest);

    pHdr = (PRM_OBJECT_HEADER) pDest;
    ASSERT(pHdr == &pDest->Hdr);

    // We expect the parent object to be the IF object!
    //
    ASSERT(pParentObject->Sig == MTAG_INTERFACE);
    

    if (pHdr)
    {
        RmInitializeHeader(
            pParentObject,
            pHdr,
            MTAG_DEST,
            pParentObject->pLock,
            &ArpGlobal_DestinationStaticInfo,
            NULL, // szDescription
            pSR
            );

            pDest->Params = *((PARP_DEST_PARAMS) pCreateParams);

            InitializeListHead(&pDest->listIpToThisDest);
            InitializeListHead(&pDest->listLocalIp);

    }
    return pHdr;
}


VOID
arpDestinationDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        )
/*++

Routine Description:

    Free an object of type ARPCB_DEST.

Arguments:

    pHdr    - Actually a pointer to the destination object to be freed.

--*/
{
    ARPCB_DEST *pDest = (ARPCB_DEST *) pHdr;
    ASSERT(pDest->Hdr.Sig == MTAG_DEST);
    pDest->Hdr.Sig = MTAG_FREED;

    ARP_FREE(pHdr);
}



PRM_OBJECT_HEADER
arpDhcpTableEntryCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARPCB_REMOTE_IP.

Arguments:

    pParentObject   - Actually a pointer to the interface (ARP1394_INTERFACE)
    pCreateParams   - Actually the IP address (not a pointer to the IP address)
                      to associate with this remote IP object.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ENTER ("arpRemoteDestCreate", 0xa896311a)
    ARP1394_ETH_DHCP_ENTRY *pEntry = NULL;

    ULONG xid = *(PULONG)pCreateParams;
    PRM_OBJECT_HEADER pHdr;
    NDIS_STATUS Status;

    Status = ARP_ALLOCSTRUCT(pEntry, MTAG_ARP_GENERIC);

    if (Status != NDIS_STATUS_SUCCESS || pEntry == NULL)
    {
        return NULL;
    }
    
    ARP_ZEROSTRUCT(pEntry);

    pHdr = (PRM_OBJECT_HEADER) pEntry;
    ASSERT(pHdr == &pEntry->Hdr);

    // We expect the parent object to be the IF object!
    //
    ASSERT(pParentObject->Sig == MTAG_INTERFACE);
    

    if (pHdr)
    {
        RmInitializeHeader(
            pParentObject,
            pHdr,
            MTAG_ARP_GENERIC,
            pParentObject->pLock,
            &ArpGlobal_DhcpTableStaticInfo ,
            NULL, // szDescription
            pSR
            );

        TR_INFO( ("New XID %x \n", xid));
  
        // set up the key 
        pEntry->xid = xid;
        
    }
    EXIT()
    return pHdr;
}




VOID
arpDhcpTableEntryDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        )
/*++

Routine Description:

    Free an object of type ARPCB_REMOTE_IP.

Arguments:

    pHdr    - Actually a pointer to the remote ip object to be freed.

--*/
{
    ARP1394_ETH_DHCP_ENTRY *pEntry = (ARP1394_ETH_DHCP_ENTRY*) pHdr;
    ASSERT(pEntry->Hdr.Sig == MTAG_ARP_GENERIC);
    pEntry->Hdr.Sig = MTAG_FREED;

    ARP_FREE(pHdr);
}



NDIS_STATUS
arpTaskMakeCallToDest(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    This task is responsible for making a call to a destination
    (either send-FIFO or send/recv-CHANNEL).

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          :  unused

--*/
{
    ENTER("TaskMakeCallToDest", 0x25108eaa)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARPCB_DEST        * pDest   = (ARPCB_DEST*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE * pIF     = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pDest);
    TASK_MAKECALL     * pMakeCallTask =  (TASK_MAKECALL*) pTask;

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OtherMakeCallTaskComplete,
        PEND_MakeCallComplete
    };

    ASSERT(sizeof(ARP1394_TASK) >= sizeof(*pMakeCallTask));


    switch(Code)
    {
        case RM_TASKOP_START:
        {
            BOOLEAN IsFifo;
            PARP_STATIC_VC_INFO pVcStaticInfo;

            LOCKOBJ(pDest, pSR);

            DBGMARK(0x7a74bf2a);

            // First check if pDest is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pDest))
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            // If there is a call cleanup task in progress, we fail right away... 
            //
            if (pDest->VcHdr.pCleanupCallTask != NULL)
            {
                OBJLOG2(
                    pDest,
                    "Failing MakeCall task %p because Cleanup task %p exists.\n",
                    pTask,
                    pDest->VcHdr.pCleanupCallTask
                    );
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            //
            // pDest is allocated. Now check if there is already a
            // MakeCall task attached to pDest.
            //
            if (pDest->VcHdr.pMakeCallTask != NULL)
            {
                //
                // There is a make-call task. We pend on it.
                //

                PRM_TASK pOtherTask = pDest->VcHdr.pMakeCallTask;
                OBJLOG1(
                    pTask,
                    "MakeCall task %p exists; pending on it.\n",
                    pOtherTask);

                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pDest, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherMakeCallTaskComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // Grab the IF send lock and make sure we're in the position to make a
            // call -- there should be no VC handle.
            // We must do this BEFORE we become the official task, so that we don't
            // wipe out the connection as part of our cleanup.
            //
            ARP_WRITELOCK_IF_SEND_LOCK(pIF, pSR);
            if (pDest->VcHdr.NdisVcHandle != NULL)
            {
                OBJLOG1(
                 pTask,
                 "VcHandle 0x%p already exists!, failing make call attempt.\n",
                 pDest->VcHdr.NdisVcHandle);
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            ASSERT(pDest->sendinfo.OkToSend == FALSE);
            ASSERT(pDest->sendinfo.NumOutstandingSends == 0);

            //
            // There is no MakeCall task going on, and there's no VC handle. Let's
            // make this task THE MakeCall task.
            // 

            pDest->VcHdr.pMakeCallTask = pTask;

            //
            // Since we're THE MakeCall task, add an association to pDest,
            // which will only get cleared when the  pDest->VcHdr.pMakeCallTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pDest->Hdr,                        // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_DEST_MAKECALL_TASK,        // AssociationID
                "    Official makecall task 0x%p (%s)\n", // szFormat
                pSR
                );


            // Setup call params.
            //
            {
                PNIC1394_MEDIA_PARAMETERS p1394Params =
                            (PNIC1394_MEDIA_PARAMETERS)
                            &pMakeCallTask->MediaParams.Parameters;
                PNIC1394_DESTINATION    pDestAddr = &pDest->Params.HwAddr;

                //No need: ARP_ZEROSTRUCT(&pMakeCallTask->CallParams);
                //No need: ARP_ZEROSTRUCT(&pMakeCallTask->MediaParams);
                pMakeCallTask->CallParams.MediaParameters =
                                (PCO_MEDIA_PARAMETERS) &pMakeCallTask->MediaParams;
                pMakeCallTask->MediaParams.ParamType      = NIC1394_MEDIA_SPECIFIC;

                IsFifo = FALSE;

                switch(pDestAddr->AddressType)
                {
                case  NIC1394AddressType_Channel:
                    pMakeCallTask->MediaParams.Flags     = TRANSMIT_VC | RECEIVE_VC;
                    pVcStaticInfo = &g_ArpBroadcastChannelVcStaticInfo;
                    break;

                case  NIC1394AddressType_FIFO:
                    pMakeCallTask->MediaParams.Flags     = TRANSMIT_VC;
                    pVcStaticInfo = &g_ArpSendFifoVcStaticInfo;
                    IsFifo = TRUE;
                    break;

                case  NIC1394AddressType_MultiChannel:
                    pMakeCallTask->MediaParams.Flags     = RECEIVE_VC;
                    pVcStaticInfo = &g_ArpMultiChannelVcStaticInfo;
                    break;

                case  NIC1394AddressType_Ethernet:
                    pMakeCallTask->MediaParams.Flags     = TRANSMIT_VC | RECEIVE_VC;
                    pVcStaticInfo = &g_ArpEthernetVcStaticInfo;
                    break;

                default:
                    ASSERT(FALSE);
                    break;
                }


                TR_INFO(("Our Parameters offset = 0x%lx; Official offset = 0x%lx\n",
                    FIELD_OFFSET(ARP1394_CO_MEDIA_PARAMETERS,  Parameters),
                    FIELD_OFFSET(CO_MEDIA_PARAMETERS, MediaSpecific.Parameters)));
                    
                ASSERT(FIELD_OFFSET(ARP1394_CO_MEDIA_PARAMETERS,  Parameters)
                == FIELD_OFFSET(CO_MEDIA_PARAMETERS, MediaSpecific.Parameters));

                p1394Params->Destination        = *pDestAddr; // struct copy.
                p1394Params->Flags              = NIC1394_VCFLAG_FRAMED;
                p1394Params->MaxSendBlockSize   = -1; // (nic should pick)
                p1394Params->MaxSendSpeed       = -1; // (nic should pick)
                p1394Params->MTU                = ARP1394_ADAPTER_MTU;
                                                  // TODO --  make above based on
                                                  // config.
            }
            
            // Now create a vc and make the call...
            // 
            {
                RmUnlockAll(pSR);
                Status = arpInitializeVc(
                            pIF,
                            pVcStaticInfo,
                            &pDest->Hdr,
                            &pDest->VcHdr,
                            pSR
                            );
                if (FAIL(Status))
                {
                    break;
                }

                // Save away the fields within sendinfo...
                //
                ARP_WRITELOCK_IF_SEND_LOCK(pIF, pSR);
                pDest->sendinfo.OkToSend = FALSE;
                pDest->sendinfo.IsFifo  = IsFifo;
                ARP_UNLOCK_IF_SEND_LOCK(pIF, pSR);

                RmSuspendTask(pTask,  PEND_MakeCallComplete, pSR);

                DBGMARK(0xef9d8be3);

                //
                //  Make the Call now
                //
                if (IsFifo)
                {
                    LOGSTATS_TotalSendFifoMakeCalls(pIF);
                }
                else
                {
                    LOGSTATS_TotalChannelMakeCalls(pIF);
                }
                RM_ASSERT_NOLOCKS(pSR);
            #if ARPDBG_FAKE_CALLS
                Status = arpDbgFakeNdisClMakeCall(
                                pDest->VcHdr.NdisVcHandle,
                                &pMakeCallTask->CallParams,
                                NULL,               // ProtocolPartyContext
                                NULL,               // NdisPartyHandle
                                &pDest->Hdr,
                                &pDest->VcHdr,
                                pSR
                                );
            #else   // !ARPDBG_FAKE_CALLS
                Status = NdisClMakeCall(
                                pDest->VcHdr.NdisVcHandle,
                                &pMakeCallTask->CallParams,
                                NULL,               // ProtocolPartyContext
                                NULL                // NdisPartyHandle
                                );
            #endif  // !ARPDBG_FAKE_CALLS

        
                if (!PEND(Status))
                {
                    ArpCoMakeCallComplete(
                                Status,
                                (NDIS_HANDLE) (&pDest->VcHdr),
                                NULL,
                                &pMakeCallTask->CallParams
                                );
                    Status = NDIS_STATUS_PENDING;
                }
            }
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case   PEND_OtherMakeCallTaskComplete:
                {
        
                    //
                    // There was another makecall task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    
    
                case PEND_MakeCallComplete:
                {
                    //
                    // The make call is complete. We're done...
                    //
                    Status = (NDIS_STATUS) UserParam;

                #if ARPDBG_FAKE_CALLS
                    //
                    // In the fake case, we give the "user" the opportunity to change
                    // the status to Success for the special VC (BROADCAST
                    // MCAP, ETHERNET) make call fails,
                    // because otherwise the adapter bind itself is going to fail.
                    //
                    // We do this even in the retail build (if ARPDBG_FAKE_CALLS is
                    // enabled).
                    //
                    if ((1 || FAIL(Status)) && !pDest->sendinfo.IsFifo)
                    {
                        // To try the failure path of the BC make call, enable
                        // the if 0 code. Currently we change status to success
                        // so that stress tests which include loading/unloading
                        // of the driver will run without breaking here everytime.
                        //
                    #if 1
                        DbgPrint(
                            "A13: Fake %s failed. &Status=%p.\n",
                            pDest->VcHdr.pStaticInfo->Description,
                            &Status
                            );
                        DbgBreakPoint();
                    #else
                        Status = NDIS_STATUS_SUCCESS;
                    #endif
                    }
                #endif  // ARPDBG_FAKE_CALLS

                    LOCKOBJ(pDest, pSR);
                    ASSERT (pDest->VcHdr.pMakeCallTask == pTask);

                    ASSERT(pDest->VcHdr.NdisVcHandle != NULL);
    
                    ARP_WRITELOCK_IF_SEND_LOCK(pIF, pSR);

                    DBGMARK(0xd50a6864);


                    if (FAIL(Status))
                    {
                        pDest->sendinfo.OkToSend     = FALSE;
                    }
                    else
                    {
                        //
                        // Success! Packets can now be sent over this VC without
                        // further ado.
                        //
                        pDest->sendinfo.OkToSend     = TRUE;
                    }

                    RmUnlockAll(pSR);

                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

            LOCKOBJ(pDest, pSR);

            if (pDest->VcHdr.pMakeCallTask == pTask)
            {
                //
                // We're the official pMakeCallTask
                //

                // Delete the association we added when we set
                // pDest->VcHdr.pMakeCallTask to pTask.
                //
                DBG_DELASSOC(
                    &pDest->Hdr,                        // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_DEST_MAKECALL_TASK,        // AssociationID
                    pSR
                    );

                // Remove reference to us in pDest.
                //
                pDest->VcHdr.pMakeCallTask = NULL;

                if (FAIL(Status) && pDest->VcHdr.NdisVcHandle != NULL)
                {
                    UNLOCKOBJ(pDest, pSR);

                    // WARNING: the above completely nukes out pDest.VcHdr.
                    //
                    arpDeinitializeVc(pIF, &pDest->VcHdr, &pDest->Hdr, pSR);
                }
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskCleanupCallToDest(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
        This task is responsible for cleaning up a previously-made call to a
        destination.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskCleanupCallToDest", 0xc89dfb47)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARPCB_DEST        * pDest   = (ARPCB_DEST*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE * pIF     = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pDest);
    MYBOOL              fCloseCall = FALSE;
    NDIS_HANDLE         NdisVcHandle = NULL;

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OtherCleanupTaskComplete,
        PEND_OutstandingSendsComplete,
        PEND_CloseCallComplete
    };

    DBGMARK(0x6198198e);

    switch(Code)
    {
        case RM_TASKOP_START:
        {
            LOCKOBJ(pDest, pSR);

            // First check if pDest is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pDest))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // pDest is allocated. Now check if there is already a
            // CleanupCall task attached to pDest.
            //
            if (pDest->VcHdr.pCleanupCallTask != NULL)
            {
                //
                // There is an existing CleanupCall task. We pend on it.
                //

                PRM_TASK pOtherTask = pDest->VcHdr.pCleanupCallTask;
                OBJLOG1(
                    pTask,
                    "CleanupVc task %p exists; pending on it.\n",
                    pOtherTask
                    );
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pDest, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherCleanupTaskComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no CleanupCall task going on. Let's
            // make this task THE CleanupCall task.
            // 
            pDest->VcHdr.pCleanupCallTask = pTask;

            //
            // Since we're THE CleanupCall task, add an association to pDest,
            // which will only get cleared when the  pDest->VcHdr.pCleanupCallTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pDest->Hdr,                        // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_DEST_CLEANUPCALL_TASK,     // AssociationID
                "    Official CleanupCall task 0x%p (%s)\n", // szFormat
                pSR
                );

            //
            // Grab the IF send lock and disable further sends on this vc;
            // Also if there are pending sends, we'll need to suspend ourselves
            // until all the sends are done.
            //
            ARP_WRITELOCK_IF_SEND_LOCK(pIF, pSR);
            pDest->sendinfo.OkToSend = FALSE;

            // There should be no other task waiting for outstanding sends to
            // complete -- only the OFFICIAL CleanupTask (that's us) explicitly
            // waits for sends to complete.
            //
            ASSERTEX(pDest->sendinfo.pSuspendedCleanupCallTask == NULL,
                    pDest->sendinfo.pSuspendedCleanupCallTask);

            if (pDest->sendinfo.NumOutstandingSends != 0)
            {
                DBGMARK(0xea3987f0);
                //
                // Outstanding sends, we need to suspend ourselves until
                // the count goes to zero...
                //

                pDest->sendinfo.pSuspendedCleanupCallTask = pTask;

                // Following association will be cleared when we are resumed
                // after the outstanding sends goes to zero.
                //
                DBG_ADDASSOC(
                    &pDest->Hdr,                        // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_DEST_CLEANUPCALLTASK_WAITING_ON_SENDS,// AssociationID
                    "    Vc tasks 0x%p (%s) waiting on outstanding sends\n",
                    pSR
                    );
                RmSuspendTask(pTask, PEND_OutstandingSendsComplete, pSR);

                Status = NDIS_STATUS_PENDING;
            }
            else
            {
                DBGMARK(0x306bc5c3);
                //
                // If we're here, we're free to go on and close the call.
                //
                fCloseCall = TRUE;
                NdisVcHandle = pDest->VcHdr.NdisVcHandle;
            }
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OtherCleanupTaskComplete:
                {
        
                    //
                    // There was another cleanup-vc task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
    
    
                case  PEND_OutstandingSendsComplete:
                {
                    // We were waiting for outstanding sends to complete, and
                    // the last one to complete has resumed us (after setting
                    // pDest->sendinfo.pSuspendedCleanupCallTask to NULL).
                    //
                    ARP_WRITELOCK_IF_SEND_LOCK(pIF, pSR);
                    ASSERT(pDest->sendinfo.pSuspendedCleanupCallTask == NULL);
                    ASSERT(!ARP_CAN_SEND_ON_DEST(pDest));
                    ASSERT(pDest->sendinfo.NumOutstandingSends==0);
                    NdisVcHandle = pDest->VcHdr.NdisVcHandle;
                    ARP_UNLOCK_IF_SEND_LOCK(pIF, pSR);

                    // There were outstanding sends,  but how there are none.
                    // We should be able to close the call now.
                    //
                    fCloseCall = TRUE;
                    DBGMARK(0xf3b10866);
                    Status = NDIS_STATUS_SUCCESS;
                    break;
                }
                break;

                case PEND_CloseCallComplete:
                {
                    //
                    // The close call is complete...
                    //
                    LOCKOBJ(pDest, pSR);

                    ASSERT(pDest->VcHdr.pCleanupCallTask == pTask);

                    // Delete the association we added when we set
                    // pDest->VcHdr.pCleanupCallTask to pTask.
                    //
                    DBG_DELASSOC(
                        &pDest->Hdr,                        // pObject
                        pTask,                              // Instance1
                        pTask->Hdr.szDescription,           // Instance2
                        ARPASSOC_DEST_CLEANUPCALL_TASK,     // AssociationID
                        pSR
                        );
                    pDest->VcHdr.pCleanupCallTask = NULL;

                    RmUnlockAll(pSR);
                    DBGMARK(0xa590bb4f);
                    arpDeinitializeVc(pIF, &pDest->VcHdr, &pDest->Hdr, pSR);

                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pDest, pSR);


            DBGMARK(0xcfc9dbaf);
            //
            // We're done. There should be no async activities left to do.
            //
            #if DBG
            ARP_READLOCK_IF_SEND_LOCK(pIF, pSR);
            ASSERTEX(pDest->VcHdr.NdisVcHandle == NULL, pDest);
            ASSERTEX(!ARP_CAN_SEND_ON_DEST(pDest), pDest);
            ASSERTEX(pDest->sendinfo.NumOutstandingSends==0, pDest);
            ARP_UNLOCK_IF_SEND_LOCK(pIF, pSR);
            #endif DBG

            Status = NDIS_STATUS_SUCCESS;

        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    if (fCloseCall)
    {
        DBGMARK(0x653b1cc3);

        RmSuspendTask(pTask, PEND_CloseCallComplete, pSR);

    #if ARPDBG_FAKE_CALLS
        Status = arpDbgFakeNdisClCloseCall(
                    NdisVcHandle,
                    NULL,               // No party handle
                    NULL,               // No Buffer
                    0,                  // Size of above
                    &pDest->Hdr,
                    &pDest->VcHdr,
                    pSR
                );
    #else   // !ARPDBG_FAKE_CALLS
        Status = NdisClCloseCall(
                    NdisVcHandle,
                    NULL,               // No party handle
                    NULL,               // No Buffer
                    0                   // Size of above
                );
    #endif  // !ARPDBG_FAKE_CALLS

        if (Status != NDIS_STATUS_PENDING)
        {
            ArpCoCloseCallComplete(
                    Status,
                    (NDIS_HANDLE) &pDest->VcHdr,
                    (NDIS_HANDLE)NULL
                    );
            Status = NDIS_STATUS_PENDING;
        }
    }

    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskMakeRecvFifoCall(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    This task is responsible for making a call to the interface's single
    receive FIFO.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskMakeRecvFifoCall", 0x25108eaa)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARP1394_INTERFACE * pIF     = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pTask);
    TASK_MAKECALL     * pMakeCallTask =  (TASK_MAKECALL*) pTask;

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OtherMakeCallTaskComplete,
        PEND_MakeCallComplete
    };

    ASSERT(sizeof(ARP1394_TASK) >= sizeof(*pMakeCallTask));


    switch(Code)
    {
        case RM_TASKOP_START:
        {
            LOCKOBJ(pIF, pSR);

            DBGMARK(0x6d7d9959);


            // If there is a call cleanup task in progress, we fail right away... 
            //
            if (pIF->recvinfo.VcHdr.pCleanupCallTask != NULL)
            {
                OBJLOG2(
                    pIF,
                    "Failing MakeCall task %p because Cleanup task %p exists.\n",
                    pIF,
                    pIF->recvinfo.VcHdr.pCleanupCallTask
                    );
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            //
            // Now check if there is already a
            // MakeCall task attached to pIF.
            //
            if (pIF->recvinfo.VcHdr.pMakeCallTask != NULL)
            {
                //
                // There is a make-call task. We pend on it.
                //

                PRM_TASK pOtherTask = pIF->recvinfo.VcHdr.pMakeCallTask;
                OBJLOG1(
                    pTask,
                    "MakeCall task %p exists; pending on it.\n",
                    pOtherTask);

                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pIF, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherMakeCallTaskComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no MakeCall task going on. Let's
            // make this task THE MakeCall task.
            // 
            pIF->recvinfo.VcHdr.pMakeCallTask = pTask;

            //
            // Since we're THE MakeCall task, add an association to pIF,
            // which will only get cleared when the  pIF->pMakeCallTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pIF->Hdr,                          // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_IF_MAKECALL_TASK,          // AssociationID
                "    Official makecall task 0x%p (%s)\n", // szFormat
                pSR
                );

            //
            // Make sure we're in the position to make a
            // call -- there should be no VC handle.
            //
            if (pIF->recvinfo.VcHdr.NdisVcHandle != NULL)
            {
                OBJLOG1(
                 pTask,
                 "VcHandle 0x%p already exists!, failing make call attempt.\n",
                 pIF->recvinfo.VcHdr.NdisVcHandle);
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            // Setup call params.
            //
            {
                PNIC1394_MEDIA_PARAMETERS p1394Params =
                            (PNIC1394_MEDIA_PARAMETERS)
                            &pMakeCallTask->MediaParams.Parameters;
                NIC1394_DESTINATION     DestAddr;
                PNIC1394_DESTINATION    pDestAddr;

                ARP_ZEROSTRUCT(&DestAddr);

                // TODO: put real values....
                //
                DestAddr.FifoAddress.UniqueID   = 0;
                DestAddr.FifoAddress.Off_Low    = 0;
                DestAddr.FifoAddress.Off_High   = 0x100;
                DestAddr.AddressType = NIC1394AddressType_FIFO;
                pDestAddr = &DestAddr;

                //No need: ARP_ZEROSTRUCT(&pMakeCallTask->CallParams);
                //No need: ARP_ZEROSTRUCT(&pMakeCallTask->MediaParams);
                pMakeCallTask->CallParams.MediaParameters =
                                (PCO_MEDIA_PARAMETERS) &pMakeCallTask->MediaParams;

                pMakeCallTask->MediaParams.Flags          = RECEIVE_VC;
                pMakeCallTask->MediaParams.ParamType      = NIC1394_MEDIA_SPECIFIC;

                ASSERT(FIELD_OFFSET(ARP1394_CO_MEDIA_PARAMETERS,  Parameters)
                == FIELD_OFFSET(CO_MEDIA_PARAMETERS, MediaSpecific.Parameters));

                p1394Params->Destination        = *pDestAddr; // struct copy.
                p1394Params->Flags              = NIC1394_VCFLAG_FRAMED;
                p1394Params->MaxSendBlockSize   = -1; // (nic should pick)
                p1394Params->MaxSendSpeed       = -1; // (nic should pick)
                p1394Params->MTU                = ARP1394_ADAPTER_MTU;
                                                  // TODO --  make above based on
                                                  // config.
            }
            
            // Now create a vc and make the call...
            // 
            {
                NDIS_HANDLE NdisVcHandle;
                RmUnlockAll(pSR);

                Status = arpInitializeVc(
                            pIF,
                            &g_ArpRecvFifoVcStaticInfo,
                            &pIF->Hdr,
                            &pIF->recvinfo.VcHdr,
                            pSR
                            );
                if (FAIL(Status))
                {
                    break;
                }
                NdisVcHandle = pIF->recvinfo.VcHdr.NdisVcHandle;

                RmSuspendTask(pTask,  PEND_MakeCallComplete, pSR);

                DBGMARK(0xf313a276);

                //
                //  Make the Call now
                //
                RM_ASSERT_NOLOCKS(pSR);
            #if ARPDBG_FAKE_CALLS
                Status = arpDbgFakeNdisClMakeCall(
                                NdisVcHandle,
                                &pMakeCallTask->CallParams,
                                NULL,               // ProtocolPartyContext
                                NULL,               // NdisPartyHandle
                                &pIF->Hdr,
                                &pIF->recvinfo.VcHdr,
                                pSR
                                );
            #else   // !ARPDBG_FAKE_CALLS
                Status = NdisClMakeCall(
                                NdisVcHandle,
                                &pMakeCallTask->CallParams,
                                NULL,               // ProtocolPartyContext
                                NULL                // NdisPartyHandle
                                );
            #endif  // !ARPDBG_FAKE_CALLS

        
                if (!PEND(Status))
                {
                    ArpCoMakeCallComplete(
                                Status,
                                (NDIS_HANDLE) &pIF->recvinfo.VcHdr,
                                NULL,
                                &pMakeCallTask->CallParams
                                );
                    Status = NDIS_STATUS_PENDING;
                }
            }
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case   PEND_OtherMakeCallTaskComplete:
                {
        
                    //
                    // There was another makecall task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    
    
                case PEND_MakeCallComplete:
                {

                    //
                    // The make call is complete. We're done...
                    //
                    Status = (NDIS_STATUS) UserParam;

                #if ARPDBG_FAKE_CALLS
                    //
                    // In the fake case, we give the "user" the opportunity to change
                    // the status to Success if the recv FIFO make call fails,
                    // because otherwise the adapter bind itself is going to fail.
                    //
                    // We do this even in the retail build (if ARPDBG_FAKE_CALLS is
                    // enabled).
                    //
                    if (FAIL(Status))
                    {
                        // To try the failure path of the recv fifo make call, enable
                        // the if 0 code. Currently we change status to success
                        // so that stress tests which include loading/unloading
                        // of the driver will run without breaking here everytime.
                        //
                    #if 0
                        DbgPrint(
                            "A13: FakeRecvMakeCall failed. &Status=%p.\n",
                            &Status
                            );
                        DbgBreakPoint();
                    #else
                        Status = NDIS_STATUS_SUCCESS;
                    #endif
                    }
                #endif  // ARPDBG_FAKE_CALLS

                    LOCKOBJ(pIF, pSR);
                    ASSERT (pIF->recvinfo.VcHdr.pMakeCallTask == pTask);

                    ASSERT(pIF->recvinfo.VcHdr.NdisVcHandle != NULL);

                    // On success, update pIF->recvinfo.offset.
                    //
                    if (!FAIL(Status))
                    {
                        PNIC1394_MEDIA_PARAMETERS p1394Params =
                                    (PNIC1394_MEDIA_PARAMETERS)
                                    &pMakeCallTask->MediaParams.Parameters;
                        pIF->recvinfo.offset.Off_Low =
                                p1394Params->Destination.FifoAddress.Off_Low;
                        pIF->recvinfo.offset.Off_High =
                                p1394Params->Destination.FifoAddress.Off_High;
                    }

                    DBGMARK(0xa3b591b7);

                    RmUnlockAll(pSR);

                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

            LOCKOBJ(pIF, pSR);

            if (pIF->recvinfo.VcHdr.pMakeCallTask == pTask)
            {
                //
                // We're the official pMakeCallTask
                //

                // Delete the association we added when we set
                // pIF->recvinfo.VcHdr.pMakeCallTask to pTask.
                //
                DBG_DELASSOC(
                    &pIF->Hdr,                      // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_IF_MAKECALL_TASK,      // AssociationID
                    pSR
                    );

                // Remove reference to us in pIF.
                //
                pIF->recvinfo.VcHdr.pMakeCallTask = NULL;

                if (FAIL(Status) && pIF->recvinfo.VcHdr.NdisVcHandle != NULL)
                {
                    UNLOCKOBJ(pIF, pSR);

                    // WARNING: the above completely nukes out VcHdr.
                    //
                    arpDeinitializeVc(pIF, &pIF->recvinfo.VcHdr, &pIF->Hdr, pSR);
                }
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskCleanupRecvFifoCall(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        This task is responsible for cleaning up a previously-made call to the
        IF's single recvFIFO VC.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskCleanupRecvFifoCall", 0x6e9581f7)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARP1394_INTERFACE * pIF     = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pTask);
    MYBOOL              fCloseCall   = FALSE;
    NDIS_HANDLE         NdisVcHandle = NULL;

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_MakeCallTaskComplete,
        PEND_OtherCleanupTaskComplete,
        PEND_CloseCallComplete
    };

    DBGMARK(0xa651415b);

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pIF, pSR);

            // First check if pIF is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pIF))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // pIF is allocated. Now check if there is already a
            // CleanupCall task attached to pIF.
            //
            if (pIF->recvinfo.VcHdr.pCleanupCallTask != NULL)
            {
                //
                // There is an existing CleanupCall task. We pend on it.
                //

                PRM_TASK pOtherTask = pIF->recvinfo.VcHdr.pCleanupCallTask;
                OBJLOG1(
                    pTask,
                    "CleanupVc task %p exists; pending on it.\n",
                    pOtherTask
                    );
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pIF, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherCleanupTaskComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no CleanupCall task going on. Let's
            // make this task THE CleanupCall task.
            // 
            pIF->recvinfo.VcHdr.pCleanupCallTask = pTask;

            //
            // Since we're THE CleanupCall task, add an association to pIF,
            // which will only get cleared when the  pIF->recvinfo.VcHdr.pCleanupCallTask
            // field above is cleared.
            //
            DBG_ADDASSOC(
                &pIF->Hdr,                      // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_IF_CLEANUPCALL_TASK,       // AssociationID
                "    Official CleanupCall task 0x%p (%s)\n", // szFormat
                pSR
                );

            if (pIF->recvinfo.VcHdr.pMakeCallTask != NULL)
            {
                // Oops, there is a make call task ongoing.
                // TODO: abort the makecall task.
                // For now, we just wait until it's complete.
                //

                PRM_TASK pOtherTask = pIF->recvinfo.VcHdr.pMakeCallTask;
                OBJLOG1(
                    pTask,
                    "MakeCall task %p exists; pending on it.\n",
                    pOtherTask
                    );
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pIF, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_MakeCallTaskComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
            else
            {
                NdisVcHandle = pIF->recvinfo.VcHdr.NdisVcHandle;
                if (NdisVcHandle != NULL)
                {
                    fCloseCall = TRUE;
                }
                else
                {
                    // Nothing to do.
                    Status = NDIS_STATUS_SUCCESS;
                }
            }
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OtherCleanupTaskComplete:
                {
        
                    //
                    // There was another cleanup-vc task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
    
                case  PEND_MakeCallTaskComplete:
                {
                    //
                    // There was a makecall task going when we started, and
                    // it's now complete. We go on to cleanup the call.
                    // There cannot be another makecall task now, because a
                    // makecall task doesn't start if there is an active
                    // cleanupcall task.
                    //
                    ASSERT(pIF->recvinfo.VcHdr.pMakeCallTask == NULL);
                    
                    NdisVcHandle = pIF->recvinfo.VcHdr.NdisVcHandle;
                    if (NdisVcHandle != NULL)
                    {
                        fCloseCall = TRUE;
                    }
                    else
                    {
                        // Nothing to do.
                        Status = NDIS_STATUS_SUCCESS;
                    }
                }
                break;

                case PEND_CloseCallComplete:
                {
                    //
                    // The close call is complete...
                    //
                    LOCKOBJ(pIF, pSR);

                    ASSERT(pIF->recvinfo.VcHdr.pCleanupCallTask == pTask);

                    // Delete the association we added when we set
                    // pIF->recvinfo.VcHdr.pCleanupCallTask to pTask.
                    //
                    DBG_DELASSOC(
                        &pIF->Hdr,                      // pObject
                        pTask,                              // Instance1
                        pTask->Hdr.szDescription,           // Instance2
                        ARPASSOC_IF_CLEANUPCALL_TASK,       // AssociationID
                        pSR
                        );
                    pIF->recvinfo.VcHdr.pCleanupCallTask = NULL;

                    // Delete the VC...
                    //
                    ASSERT(pIF->recvinfo.VcHdr.NdisVcHandle != NULL);
                    UNLOCKOBJ(pIF, pSR);
                    DBGMARK(0xc6b52f21);
                    arpDeinitializeVc(pIF, &pIF->recvinfo.VcHdr, &pIF->Hdr, pSR);

                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pIF, pSR);

            DBGMARK(0xc65b2f08);
            //
            // We're done. There should be no async activities left to do.
            //
            ASSERTEX(pIF->recvinfo.VcHdr.NdisVcHandle == NULL, pIF);
            Status = NDIS_STATUS_SUCCESS;

        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    if (fCloseCall)
    {
        DBGMARK(0x04d5b2d9);

        RmSuspendTask(pTask, PEND_CloseCallComplete, pSR);

    #if ARPDBG_FAKE_CALLS
        Status = arpDbgFakeNdisClCloseCall(
                    NdisVcHandle,
                    NULL,               // No party handle
                    NULL,               // No Buffer
                    0,                  // Size of above
                    &pIF->Hdr,
                    &pIF->recvinfo.VcHdr,
                    pSR
                );
    #else   // !ARPDBG_FAKE_CALLS
        Status = NdisClCloseCall(
                    NdisVcHandle,
                    NULL,               // No party handle
                    NULL,               // No Buffer
                    0                   // Size of above
                );
    #endif  // !ARPDBG_FAKE_CALLS

        if (Status != NDIS_STATUS_PENDING)
        {
            ArpCoCloseCallComplete(
                    Status,
                    (NDIS_HANDLE) &pIF->recvinfo.VcHdr,
                    (NDIS_HANDLE)NULL
                    );
            Status = NDIS_STATUS_PENDING;
        }
    }

    EXIT()

    return Status;
}

NDIS_STATUS
arpAddOneStaticArpEntry(
    IN PARP1394_INTERFACE       pIF,    // LOCKIN LOCKOUT
    IN IP_ADDRESS               IpAddress,
    IN PNIC1394_FIFO_ADDRESS    pFifoAddr,
    IN PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Create a pRemoteIp and IP address IpAddress and (if not already existing)
    create a pDest object with hw address pFifoAddr and link the two.

Return Value:
    
    NDIS_STATUS_SUCCESS on success. Ndis failure code on failure (could be
    because of a resource allocation failure or because there already exists
    a pRemoteIp with the specified IP address).

--*/
{
    INT fCreated = FALSE;
    ARPCB_REMOTE_IP *pRemoteIp = NULL;
    ARPCB_DEST      *pDest = NULL;
    NDIS_STATUS     Status;
    ARP_DEST_PARAMS DestParams;
    REMOTE_DEST_KEY RemoteDestKey;

    RM_DBG_ASSERT_LOCKED(&pIF->Hdr, pSR);
    ARP_ZEROSTRUCT(&DestParams);
    DestParams.HwAddr.AddressType =  NIC1394AddressType_FIFO;
    DestParams.HwAddr.FifoAddress = *pFifoAddr; // struct copy
    REMOTE_DEST_KEY_INIT(&RemoteDestKey);
    RemoteDestKey.IpAddress = IpAddress;

    do
    {
        Status = RmLookupObjectInGroup(
                        &pIF->RemoteIpGroup,
                        RM_CREATE|RM_NEW,
                        (PVOID) (&RemoteDestKey),
                        (PVOID) (&RemoteDestKey), // pCreateParams
                        (RM_OBJECT_HEADER**) &pRemoteIp,
                        &fCreated,  // pfCreated
                        pSR
                        );
        if (FAIL(Status))
        {
            OBJLOG1(
                pIF,
                "Couldn't add fake static localIp entry with addr 0x%lx\n",
                IpAddress
                );
            break;
        }
    
        // Now create a destination item for this structure.
        //
        Status = RmLookupObjectInGroup(
                        &pIF->DestinationGroup,
                        RM_CREATE,              //NOT RM_NEW (could be existing)
                        &DestParams,
                        &DestParams,    // pParams
                        (RM_OBJECT_HEADER**) &pDest,
                        &fCreated,
                        pSR
                        );
        if (FAIL(Status))
        {
            OBJLOG1(
                pIF,
                "Couldn't add fake dest entry with hw addr 0x%lx\n",
                (UINT) DestParams.HwAddr.FifoAddress.UniqueID // Truncation
                );
        #if 0
            TR_WARN((
                "Couldn't add fake dest entry with hw addr 0x%lx\n",
                (UINT) DestParams.HwAddr.FifoAddress.UniqueID // Truncation
                ));
        #endif // 0
            
            //
            // We'll leave the RemoteIp entry around -- it will be cleaned up later.
            // We do have to deref the tmpref added when looking it up.
            //
            RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
            break;
        }
    
        //
        // We've created both RemoteIp and Destination entries. Now link them.
        // (We still have the IF lock, which is the same as the RemoteIP and 
        //  desination locks for now).
        //
        // TODO: will need to change this when pRemoteIp gets its own lock.
        //
        RM_ASSERT_SAME_LOCK_AS_PARENT(pRemoteIp);
        RM_ASSERT_SAME_LOCK_AS_PARENT(pDest);
    
        arpLinkRemoteIpToDest(
            pRemoteIp,
            pDest,
            pSR
            );
    
        // Now set the pRemoteIp state to reflect that it is STATIC and FIFO
        //
        SET_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_STATIC);
        SET_REMOTEIP_FCTYPE(pRemoteIp, ARPREMOTEIP_FIFO);
    
    
        // Finally, remove the tmprefs added in the lookups.
        //
        RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
        RmTmpDereferenceObject(&pDest->Hdr, pSR);

    } while (FALSE);

    return Status;
}


VOID
arpActivateIf(
    PARP1394_INTERFACE  pIF,
    PRM_TASK            pCallingTask,   // OPTIONAL
    UINT                SuspendCode,    // OPTIONAL
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Initiate the asynchronous activation of pIF.

    NO locks must be held on entrance and none are held on exit.

Arguments:

    pIF             - Interface to activate.
    pCallingTask    - Optional task to suspend and resume when activation completes
                      (possibly async).
    SuspendCode     - SuspendCode for the above task.

--*/
{
    PRM_TASK    pTask;
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

    Status = arpAllocateTask(
                &pIF->Hdr,                  // pParentObject,
                arpTaskActivateInterface,   // pfnHandler,
                0,                          // Timeout,
                "Task: Activate Interface", // szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        OBJLOG0(pIF, ("FATAL: couldn't alloc Activate IF task!\n"));
        ASSERT(FALSE);
        if (pCallingTask != NULL)
        {
            RmSuspendTask(pCallingTask, SuspendCode, pSR);
            RmResumeTask(pCallingTask, Status, pSR);
        }
    }
    else
    {
        if (pCallingTask != NULL)
        {
            RmPendTaskOnOtherTask(
                pCallingTask,
                SuspendCode,
                pTask,
                pSR
                );
        }

        (void)RmStartTask(pTask, 0, pSR);
    }
}


VOID
arpDeinitIf(
    PARP1394_INTERFACE  pIF,
    PRM_TASK            pCallingTask,   // OPTIONAL
    UINT                SuspendCode,    // OPTIONAL
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Initiate the asynchronous unload of pIF. If pIF is currently being loaded
    (initialized), abort the initializeation or wait for it to complete before
    unloading it. If pIF is currently being unloaded and pCallingTask is 
    NULL, return right away, else (pCallingTask is not NULL),
    suspend pCallingTask and make it pend until the unload completes.

    NO locks must be held on entrance and none are held on exit.

Arguments:

    pIF             - Interface to unload.
    pCallingTask    - Optional task to suspend if unload is completing async.
    SuspendCode     - SuspendCode for the above task.

Return Value:

    NDIS_STATUS_SUCCESS -- on synchronous success OR pCallingTask==NULL
    NDIS_STATUS_PENDING -- if pCallingTask is made to pend until the operation
                        completes.

--*/
{
    PRM_TASK    pTask;
    NDIS_STATUS Status;

    //
    // NOTE: We could check to see if pIF can be synchronously unloaded,
    // and if so unload it right here. We don't bother because that's just
    // more code, and with dubious perf benefit.
    //

    RM_ASSERT_NOLOCKS(pSR);

    Status = arpAllocateTask(
                &pIF->Hdr,                  // pParentObject,
                arpTaskDeinitInterface,     // pfnHandler,
                0,                          // Timeout,
                "Task: Deinit Interface",   // szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        OBJLOG0(pIF, ("FATAL: couldn't alloc close IF task!\n"));
        ASSERT(FALSE);
        if (pCallingTask != NULL)
        {
            RmSuspendTask(pCallingTask, SuspendCode, pSR);
            RmResumeTask(pCallingTask, Status, pSR);
        }
    }
    else
    {
        if (pCallingTask != NULL)
        {
            RmPendTaskOnOtherTask(
                pCallingTask,
                SuspendCode,
                pTask,
                pSR
                );
        }

        (void)RmStartTask(pTask, 0, pSR);
    }
}


VOID
arpDeinitDestination(
    PARPCB_DEST             pDest,  // NOLOCKIN NOLOCKOUT
    MYBOOL                  fOnlyIfUnused,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Initate the unload of destination pDest.

    If fOnlyIfUnused is TRUE, then only do this if there are no 
    local or remote IPs pointing to it.

    NOTE: it's possible that some pLocal/pRemoteIps may be linked to
        pDest AFTER we've decided to deinit pDest. Tough luck -- in this
        unlikely event, we'll unload this pDest, and the unlinked
        pLocals/pRemotes will have to re-figure who to link to.

--*/
{
    ENTER("DeinitDestination", 0xc61b8f82)
    PRM_TASK    pTask;
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

    if (fOnlyIfUnused)
    {
        //
        // We don't deinit the destination if there are local or remote ip's 
        // linked to it, OR if it is the broadcast channel.
        //
        LOCKOBJ(pDest, pSR);
        if (    !IsListEmpty(&pDest->listLocalIp)
             || !IsListEmpty(&pDest->listIpToThisDest)
             || pDest == ((PARP1394_INTERFACE) RM_PARENT_OBJECT(pDest))
                         ->pBroadcastDest)
        {
            UNLOCKOBJ(pDest, pSR);
            return;                         // ********* EARLY RETURN **********
        }
        UNLOCKOBJ(pDest, pSR);
    }

#if DBG
    if (pDest->Params.HwAddr.AddressType ==  NIC1394AddressType_FIFO)
    {
        PUCHAR puc = (PUCHAR)  &pDest->Params.HwAddr.FifoAddress;
        TR_WARN(("Deiniting Destination: FIFO %02lx-%02lx-%02lx-%02lx-%02lx-%02lx-%02lx-%02lx.\n",
            puc[0], puc[1], puc[2], puc[3],
            puc[4], puc[5], puc[6], puc[7]));
    }
    else if (pDest->Params.HwAddr.AddressType ==  NIC1394AddressType_Channel)
    {
        TR_WARN(("Deiniting Destination: Channel %lu.\n",
                pDest->Params.HwAddr.Channel));
    }
#endif // DBG


    Status = arpAllocateTask(
                &pDest->Hdr,                // pParentObject,
                arpTaskUnloadDestination,   // pfnHandler,
                0,                          // Timeout,
                "Task: Unload Dest",        // szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        OBJLOG0(pDest, ("FATAL: couldn't alloc unload dest task!\n"));
    }
    else
    {
        (VOID) RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    pSR
                    );
    }
}


VOID
arpDeactivateIf(
    PARP1394_INTERFACE  pIF,
    PRM_TASK            pCallingTask,   // OPTIONAL
    UINT                SuspendCode,    // OPTIONAL
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Initiate the asynchronous deactivation of pIF.
    "Deactivation" consists of tearing down any activity and handles associated
    with this IF. The IF will remain allocated linked to the adapter.

    NO locks must be held on entrance and none are held on exit.

Arguments:

    pIF             - Interface to unload.
    pCallingTask    - Optional task to suspend if deactivation is completing async.
    SuspendCode     - SuspendCode for the above task.

--*/
{
    PRM_TASK    pTask;
    NDIS_STATUS Status;

    //
    // NOTE: We could check to see if pIF can be synchronously deactivated,
    // and if so deactivate it right here. We don't bother because that's just
    // more code, and with dubious perf benefit.
    //

    RM_ASSERT_NOLOCKS(pSR);

    Status = arpAllocateTask(
                &pIF->Hdr,                  // pParentObject,
                arpTaskDeactivateInterface, // pfnHandler,
                0,                          // Timeout,
                "Task: DeactivateInterface",// szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        OBJLOG0(pIF, ("FATAL: couldn't alloc deactivate IF task!\n"));
        ASSERT(FALSE);
        if (pCallingTask != NULL)
        {
            RmSuspendTask(pCallingTask, SuspendCode, pSR);
            RmResumeTask(pCallingTask, Status, pSR);
        }
    }
    else
    {
        if (pCallingTask != NULL)
        {
            RmPendTaskOnOtherTask(
                pCallingTask,
                SuspendCode,
                pTask,
                pSR
                );
        }

        (void)RmStartTask(pTask, 0, pSR);
    }
}




NDIS_STATUS
arpCreateInterface(
        IN  PARP1394_ADAPTER    pAdapter,   // LOCKIN LOCKOUT
        OUT PARP1394_INTERFACE *ppIF,
        IN  PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocates and performs basic initialization of an interface object.
    The interface object subsequently needs to be initialized by the starting
    the initialization task before it is completely initialized.
    
    *ppIF shares the same lock as it's parent, pAdapter.

Arguments:

    pAdapter        - Adapter that will own the interface.
    ppIF            - Place to store the allocated interface.

Return Value:

    NDIS_STATUS_SUCCESS on successful allocation and initialization of the interface.
    NDIS failure code   on failure.
--*/
{
    NDIS_STATUS Status;
    ARP1394_INTERFACE *pIF;
    ENTER("arpCreateInterface", 0x938c36ff)

    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    do
    {

        Status = ARP_ALLOCSTRUCT(pIF, MTAG_INTERFACE);

        if (Status != NDIS_STATUS_SUCCESS || pIF == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        ARP_ZEROSTRUCT(pIF);

        RmInitializeHeader(
            &(pAdapter->Hdr),                   // pParentObject
            &pIF->Hdr,
            MTAG_INTERFACE,
            &pAdapter->Lock,
            &ARP1394_INTERFACE_StaticInfo,
            NULL,                               // szDescription
            pSR
            );

        // Note arpInitializeIfPools expects pIF to be locked. We know it's locked
        // because it shares the same lock as it's parent, and the parent is lozked.
        //
        Status = arpInitializeIfPools(pIF, pSR);

        if (FAIL(Status))
        {
            RmDeallocateObject(
                &(pIF->Hdr),
                pSR
                );
            pIF = NULL;
            break;
        }

        //
        // Intialize the various groups in the interface...
        //

        RmInitializeGroup(
                        &pIF->Hdr,                              // pOwningObject
                        &ArpGlobal_LocalIpStaticInfo,
                        &(pIF->LocalIpGroup),
                        "LocalIp group",                        // szDescription
                        pSR
                        );

        RmInitializeGroup(
                        &pIF->Hdr,                              // pOwningObject
                        &ArpGlobal_RemoteIpStaticInfo,
                        &(pIF->RemoteIpGroup),
                        "RemoteIp group",                       // szDescription
                        pSR
                        );

        RmInitializeGroup(
                        &pIF->Hdr,                              // pOwningObject
                        &ArpGlobal_RemoteEthStaticInfo,
                        &(pIF->RemoteEthGroup),
                        "RemoteEth group",                      // szDescription
                        pSR
                        );

        RmInitializeGroup(
                        &pIF->Hdr,                              // pOwningObject
                        &ArpGlobal_DhcpTableStaticInfo,
                        &(pIF->EthDhcpGroup),
                        "Eth Dhcp group",                      // szDescription
                        pSR
                        );


        RmInitializeGroup(
                        &pIF->Hdr,                              // pOwningObject
                        &ArpGlobal_DestinationStaticInfo,
                        &(pIF->DestinationGroup),
                        "Destination group",                    // szDescription
                        pSR
                        );



        //
        //  Cache the adapter handle.
        //
        pIF->ndis.AdapterHandle = pAdapter->bind.AdapterHandle;
    
        // TODO -- put the real IP MTU (based on adapter info and config info)
        //
        pIF->ip.MTU     = ARP1394_ADAPTER_MTU-16;     // Bytes ('-16' accounts for
                                                  // the encapsulation header.
                                                  // 16 is overkill:  4 should
                                                  // be enough.)

        // Init stuff in pIF->sendinfo (the const header pools were initialized
        // earlier, because their initialization could fail).
        //
        RmInitializeLock(&pIF->sendinfo.Lock, LOCKLEVEL_IF_SEND);
        InitializeListHead(&pIF->sendinfo.listPktsWaitingForHeaders);

        arpResetIfStats(pIF, pSR);

        pIF->ip.ATInstance = INVALID_ENTITY_INSTANCE;
        pIF->ip.IFInstance = INVALID_ENTITY_INSTANCE;

        pIF->ip.BroadcastAddress = 0xFFFFFFFF; // Defaults to all-1's.

        //
        // Do any other non-failure-prone initialization here.
        //

    } while (FALSE);

    *ppIF = pIF;

    EXIT()
    return Status;
}


VOID
arpDeleteInterface(
        IN  PARP1394_INTERFACE  pIF, // LOCKIN LOCKOUT (adapter lock)
        IN  PRM_STACK_RECORD    pSR
        )
{
    ARP1394_ADAPTER *   pAdapter =
                            (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

    
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    // We expect that the adapter has already removed it's reference to pIF.
    //
    ASSERT(pAdapter->pIF != pIF);

    // Deinitialize all the groups in the IF ...
    //
    RmDeinitializeGroup(&(pIF->LocalIpGroup), pSR);
    RmDeinitializeGroup(&(pIF->RemoteIpGroup), pSR);
    RmDeinitializeGroup(&(pIF->RemoteEthGroup), pSR);
    RmDeinitializeGroup(&(pIF->DestinationGroup), pSR);
    RmDeinitializeGroup(&(pIF->EthDhcpGroup),pSR);

    // Deinit the various pools associated with pIF.
    //
    arpDeInitializeIfPools(pIF, pSR);


    // Verify that everything is truly done...
    //
    ASSERTEX(pIF->pPrimaryTask == NULL, pIF);
    ASSERTEX(pIF->pActDeactTask == NULL, pIF);
    ASSERTEX(pIF->ip.Context == NULL, pIF);
    ASSERTEX(pIF->ndis.AfHandle == NULL, pIF);

    // Add any other checks you want here...

    // Deallocate the IF
    //
    RmDeallocateObject(
        &(pIF->Hdr),
        pSR
        );
}

VOID
arpResetIfStats(
        IN  PARP1394_INTERFACE  pIF, // LOCKIN LOCKOUT
        IN  PRM_STACK_RECORD    pSR
        )
{
    ENTER("arpResetIfStats", 0x3eb52cda)
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    // Zero  stats
    //
    //
    ARP_ZEROSTRUCT(&(pIF->stats));

    // Set the timestamp indicating start of stats collection.
    //
    NdisGetCurrentSystemTime(&(pIF->stats.StatsResetTime));

    // Get the perf counter frequency (we don't need to do this each time, but
    // why bother special casing.)
    //
    (VOID) KeQueryPerformanceCounter(&(pIF->stats.PerformanceFrequency));

    EXIT()
}


NDIS_STATUS
arpInitializeVc(
    PARP1394_INTERFACE  pIF,
    PARP_STATIC_VC_INFO pVcInfo,
    PRM_OBJECT_HEADER   pOwner,
    PARP_VC_HEADER      pVcHdr,
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Initialize the Vc Header; Allocate the NdisVcHandle;

Arguments:

    pIF         - Interface this applies to
    pVcInfo     - Static info about this VC
    pOwner      - Owning object (for referencing)
    pVcHdr      - Protocol Vc context to initialize

--*/
{
    NDIS_STATUS Status;
    NDIS_HANDLE NdisVcHandle;
    ENTER("arpInitializeVc", 0x36fe9837)

    // (DEBUG ONLY) Verify that all fields are already zero.
    //  TODO: We don't assert that pVcHdr->pMakeCallTask == NULL, because
    // it's already set on entry -- we should clean up the semantics of
    // arpInitializeVc.
    //
    ASSERT (    pVcHdr->pStaticInfo == NULL
            &&  pVcHdr->NdisVcHandle == NULL
            &&  pVcHdr->pCleanupCallTask == NULL );

    NdisVcHandle = NULL;
    // Try to create Ndis VC
    //
    Status = NdisCoCreateVc(
                    pIF->ndis.AdapterHandle,
                    pIF->ndis.AfHandle,
                    (NDIS_HANDLE) pVcHdr,   // ProtocolVcContext,
                    &NdisVcHandle
                    );
    if (FAIL(Status))
    {
        TR_WARN(("Couldn't create VC handle\n"));
        pVcHdr->NdisVcHandle = NULL;
        
    }
    else
    {
        pVcHdr->pStaticInfo  = pVcInfo;
        pVcHdr->NdisVcHandle = NdisVcHandle;

        // Link-to-external pOwningObject to the ndis-vc handle.
        //
    #if RM_EXTRA_CHECKING

        #define szARPASSOC_EXTLINK_TO_NDISVCHANDLE "    Linked to NdisVcHandle 0x%p\n"
        
        RmLinkToExternalEx(
            pOwner,                                 // pHdr
            0xb57e657b,                             // LUID
            (UINT_PTR) NdisVcHandle,                // External entity
            ARPASSOC_EXTLINK_TO_NDISVCHANDLE,       // AssocID
            szARPASSOC_EXTLINK_TO_NDISVCHANDLE,
            pSR
            );

    #else   // !RM_EXTRA_CHECKING

        RmLinkToExternalFast(pOwner);

    #endif // !RM_EXTRA_CHECKING

    }


    EXIT()

    return Status;
}

VOID
arpDeinitializeVc(
    PARP1394_INTERFACE  pIF,
    PARP_VC_HEADER      pVcHdr,
    PRM_OBJECT_HEADER   pOwner,     // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    DeInitialize the Vc Header; Deallocate the NdisVcHandle;

Arguments:

    pIF         - Interface this applies to
    pOwner      - Owning object (for de-referencing)
    pVcHdr      - Protocol Vc context to de-initialize

--*/
{
    ENTER("arpDeinitializeVc", 0x270b29ac)

    NDIS_HANDLE NdisVcHandle;

    RM_ASSERT_NOLOCKS(pSR);
    
    LOCKHDR(pOwner, pSR);

    // (DEBUG ONLY) Verify that there is no make-call or close-call task.
    //
    ASSERT( pVcHdr->pMakeCallTask == NULL && pVcHdr->pCleanupCallTask == NULL );

    NdisVcHandle = pVcHdr->NdisVcHandle;

    // Zero out the structure.
    //
    ARP_ZEROSTRUCT(pVcHdr);

    UNLOCKHDR(pOwner, pSR);

    RM_ASSERT_NOLOCKS(pSR);

    // Delete the Link-to-external pOwningObject to the ndis-vc handle.
    //
    #if RM_EXTRA_CHECKING

        RmUnlinkFromExternalEx(
            pOwner,                                 // pHdr
            0xee1b4fe3,                             // LUID
            (UINT_PTR) NdisVcHandle,                // External entity
            ARPASSOC_EXTLINK_TO_NDISVCHANDLE,       // AssocID
            pSR
            );

    #else   // !RM_EXTRA_CHECKING

        RmUnlinkFromExternalFast(pOwner);

    #endif // !RM_EXTRA_CHECKING

    // Delete the ndis vc handle.
    //
    NdisCoDeleteVc(NdisVcHandle);

    EXIT()
}


UINT
arpRecvFifoReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
)
/*++
            HOT PATH
--*/
{
    PARP_VC_HEADER          pVcHdr;
    PARP1394_INTERFACE      pIF;

    pVcHdr  = (PARP_VC_HEADER) ProtocolVcContext;
    pIF     =  CONTAINING_RECORD( pVcHdr, ARP1394_INTERFACE, recvinfo.VcHdr);
    ASSERT_VALID_INTERFACE(pIF);

    return arpProcessReceivedPacket(
                pIF,
                pNdisPacket,
                FALSE                   // IsChannel
                );

}


VOID
arpRecvFifoIncomingClose(
    IN  NDIS_STATUS                 CloseStatus,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PVOID                       pCloseData  OPTIONAL,
    IN  UINT                        Size        OPTIONAL
)
{

    PARP_VC_HEADER          pVcHdr;
    PARP1394_INTERFACE      pIF;
    RM_DECLARE_STACK_RECORD(sr)

    pVcHdr  = (PARP_VC_HEADER) ProtocolVcContext;
    pIF     =  CONTAINING_RECORD( pVcHdr, ARP1394_INTERFACE, recvinfo.VcHdr);
    ASSERT_VALID_INTERFACE(pIF);

    //
    // This is the IF receive FIFO VC. For now, geting an incoming close on
    // the receive FIFO vc results in our initiating the deinit of pIF.
    //
    OBJLOG1(pIF,"Got incoming close on recv FIFO!. Status=0x%lx\n", CloseStatus);

    (VOID) arpDeinitIf(
                pIF,
                NULL,           //  pCallingTask
                0,              //  SuspendCode
                &sr
                );
        
    RM_ASSERT_CLEAR(&sr);
}


VOID
arpBroadcastChannelIncomingClose(
    IN  NDIS_STATUS                 CloseStatus,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PVOID                       pCloseData  OPTIONAL,
    IN  UINT                        Size        OPTIONAL
)
{
    PARP_VC_HEADER          pVcHdr;
    PARP1394_INTERFACE      pIF;
    ARPCB_DEST          *   pDest;
    RM_DECLARE_STACK_RECORD(sr)

    pVcHdr  = (PARP_VC_HEADER) ProtocolVcContext;
    pDest   =  CONTAINING_RECORD( pVcHdr, ARPCB_DEST, VcHdr);
    ASSERT_VALID_DEST(pDest);
    pIF     = (ARP1394_INTERFACE*)  RM_PARENT_OBJECT(pDest);

    //
    // Since all our calls are outgoing, getting an IncomingClose means that
    // the call was in the active state. Anyway, what we need to do is update the
    // call state and start the VcCleanupTask for this Vc.
    //

    //
    // This is the broadcast channel VC.
    // FOR NOW: we leave the IF alone, but deinit the dest-VC.
    //
    OBJLOG1(pDest,"Got incoming close!  Status=0x%lx\n", CloseStatus);
    LOGSTATS_IncomingClosesOnChannels(pIF);
    (VOID) arpDeinitDestination(pDest, FALSE, &sr); // FALSE == force deinit

    RM_ASSERT_CLEAR(&sr);
}


UINT
arpProcessReceivedPacket(
    IN  PARP1394_INTERFACE      pIF,
    IN  PNDIS_PACKET            pNdisPacket,
    IN  MYBOOL                  IsChannel
    )
{

    ENTER("arpProcessReceivedPacket", 0xe317990b)
    UINT                    TotalLength;    // Total bytes in packet
    PNDIS_BUFFER            pNdisBuffer;    // Pointer to first buffer
    UINT                    BufferLength;
    UINT                    ReturnCount;
    PVOID                   pvPktHeader;
    PNIC1394_ENCAPSULATION_HEADER
                            pEncapHeader;
    const UINT              MacHeaderLength = sizeof(NIC1394_ENCAPSULATION_HEADER);
    ARP1394_ADAPTER *   pAdapter =
                            (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    BOOLEAN                 fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);

    DBGMARK(0x2361f585);

    ReturnCount = 0;

    NdisQueryPacket(
                    pNdisPacket,
                    NULL,
                    NULL,
                    &pNdisBuffer,
                    &TotalLength
                    );


    if (TotalLength > 0)
    {
        NdisQueryBuffer(
                pNdisBuffer,
                (PVOID *)&pvPktHeader,
                &BufferLength
                );
    }
    else
    {
        pvPktHeader = NULL;
        BufferLength = 0;
    }

    pEncapHeader  = (PNIC1394_ENCAPSULATION_HEADER) pvPktHeader;

    TR_INFO(
("Rcv: NDISpkt 0x%x, NDISbuf 0x%x, Buflen %d, Totlen %d, Pkthdr 0x%x\n",
                pNdisPacket,
                pNdisBuffer,
                BufferLength,
                TotalLength,
                pvPktHeader));

    // TODO -- we include mcap/arp in InOctets below, is this the right thing?
    //
    ARP_IF_STAT_ADD(pIF, InOctets, TotalLength);

    LOGSTATS_TotRecvs(pIF, pNdisPacket);
    if (IsChannel)
    {
        LOGSTATS_RecvChannelCounts(pIF, pNdisPacket);
    }
    else
    {
        LOGSTATS_RecvFifoCounts(pIF, pNdisPacket);
    }
    

    if (BufferLength < MacHeaderLength || pvPktHeader == NULL)
    {
        // Packet is too small, discard.
        //
        ARP_IF_STAT_INCR(pIF, InDiscards);
        return 0;                               // EARLY RETURN
    }

    if (fBridgeMode)
    {
        arpEthReceive1394Packet(
                pIF,
                pNdisPacket,
                pvPktHeader,
                BufferLength,
                IsChannel
                );
        return 0;                       // ********* EARLY RETURN *******
    }


    //
    // Discard the packet if the IP interface is not open
    //
    if (!CHECK_IF_IP_STATE(pIF, ARPIF_IPS_OPEN))
    {
        TR_INFO(("Discardning received pkt because pIF 0x%p IP IF is not open.\n", pIF));

        return 0;                       // ********* EARLY RETURN *******
    }

    //
    // At this point, pEncapHeader contains the IP/1394 unfragmented encapsulation
    // header. We look at the ethertype to decide what to do with it.
    //
    if (pEncapHeader->EtherType ==  H2N_USHORT(NIC1394_ETHERTYPE_IP))
    {
        //
        //  The EtherType is IP, so we pass up this packet to the IP layer.
        // (Also we indicate all packets we receive on the broadcast channel
        // to the ethernet VC).
        //

        TR_INFO(
            ("Rcv: pPkt 0x%x: EtherType is IP, passing up.\n", pNdisPacket));

        if (IsChannel)
        {
            ARP_IF_STAT_INCR(pIF, InNonUnicastPkts);

            //
            // Indicate the packet on the ethernet VC.
            // It will do so synchonously -- it will not hang on to the packet.
            //

        #if MILLEN
            arpEthReceive1394Packet(
                    pIF,
                    pNdisPacket,
                    pvPktHeader,
                    BufferLength,
                    IsChannel
                    );
        #endif // MILLEN

        }
        else
        {
            ARP_IF_STAT_INCR(pIF, InUnicastPkts);
        }

#if !MILLEN
        if (NDIS_GET_PACKET_STATUS(pNdisPacket) != NDIS_STATUS_RESOURCES)
        {
            UINT    DataSize;
            #define ARP_MIN_1ST_RECV_BUFSIZE 512

            //
            // Following are notes taken from atmarpc.sys sources...
            //
            // 2/8/1998 JosephJ
            //      We set DataSize to the total payload size,
            //      unless the first buffer is too small to
            //      hold the IP header. In the latter case,
            //      we set DataSize to be the size of the 1st buffer
            //      (minus the LLS/SNAP header size).
            //
            //      This is to work around a bug in tcpip.
            //
            // 2/25/1998 JosephJ
            //      Unfortunately we have to back out YET AGAIN
            //      because large pings (eg ping -l 4000) doesn't
            //      work -- bug#297784
            //      Hence the "0" in "0 && DataSize" below.
            //      Take out the "0" to put back the per fix.
            //

            //
            // Note: MacHeaderLength is the TOTAL size of the stuff before the
            // start of the IP pkt. This includes the size of the encapsulation
            // header plus (for channels only) the size of the GASP header.
            //

            DataSize = BufferLength - MacHeaderLength;
            if (0 && DataSize >= ARP_MIN_1ST_RECV_BUFSIZE)
            {
                DataSize = TotalLength - MacHeaderLength;
                LOGSTATS_NoCopyRecvs(pIF, pNdisPacket);
            }
            else
            {
                LOGSTATS_CopyRecvs(pIF, pNdisPacket);
            }

            pIF->ip.RcvPktHandler(
                pIF->ip.Context,
                (PVOID)((PUCHAR)pEncapHeader+sizeof(*pEncapHeader)), // start of data
                DataSize,
                TotalLength,
                (NDIS_HANDLE)pNdisPacket,
                MacHeaderLength,
                IsChannel,
                0,
                pNdisBuffer,
                &ReturnCount,
                NULL
                );
        }
        else
        {
            LOGSTATS_ResourceRecvs(pIF, pNdisPacket);

            pIF->ip.RcvHandler(
                pIF->ip.Context,
                (PVOID)((PUCHAR)pEncapHeader+sizeof(*pEncapHeader)),
                BufferLength - MacHeaderLength,
                TotalLength - MacHeaderLength,
                (NDIS_HANDLE)pNdisPacket,
                MacHeaderLength,
                IsChannel,
                NULL
                );
        }
#else // MILLEN
        LOGSTATS_CopyRecvs(pIF, pNdisPacket);

        ASSERT_PASSIVE();
        pIF->ip.RcvHandler(
            pIF->ip.Context,
            (PVOID)((PUCHAR)pEncapHeader+sizeof(*pEncapHeader)),
            BufferLength - MacHeaderLength,
            TotalLength - MacHeaderLength,
            (NDIS_HANDLE)pNdisPacket,
            MacHeaderLength,
            IsChannel,
            NULL
            );
#endif // MILLEN

    }
    else if (pEncapHeader->EtherType ==  H2N_USHORT(NIC1394_ETHERTYPE_ARP))
    {
        PIP1394_ARP_PKT pArpPkt =  (PIP1394_ARP_PKT) pEncapHeader;
        if (TotalLength != BufferLength)
        {
            ASSERT(!"Can't deal with TotalLength != BufferLength");
        }
        else
        {
            arpProcessArpPkt(
                pIF,
                pArpPkt, 
                BufferLength
                );
        }
    }
    else if (pEncapHeader->EtherType ==  H2N_USHORT(NIC1394_ETHERTYPE_MCAP))
    {
        PIP1394_MCAP_PKT pMcapPkt =  (PIP1394_MCAP_PKT) pEncapHeader;
        if (TotalLength != BufferLength)
        {
            ASSERT(!"Can't deal wiht TotalLength != BufferLength");
        }
        else
        {
            arpProcessMcapPkt(
                pIF,
                pMcapPkt, 
                BufferLength
                );
        }
    }
    else
    {
        //
        //  Discard packet -- unknown/bad EtherType
        //
        TR_INFO(("Encap hdr 0x%x, bad EtherType 0x%x\n",
                 pEncapHeader, pEncapHeader->EtherType));
        ARP_IF_STAT_INCR(pIF, UnknownProtos);
    }

    EXIT()
    return ReturnCount;
}

NDIS_STATUS
arpInitializeIfPools(
    IN  PARP1394_INTERFACE pIF,
    IN  PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This routine is called in the context of creating an interface. It
    allocate the various buffer and packet pools associated with the interface.
    It cleans up all pools on failure.

Arguments:

    pIF - Interface to initialize

Return Value:

    NDIS_STATUS_SUCCESS on success
    Ndis failure code otherwise.

--*/
{
    ENTER("arpInitializeIfPools", 0x0a3b1b32)
    MYBOOL fHeaderPoolInitialized = FALSE;
    MYBOOL fPacketPoolInitialized = FALSE;
    MYBOOL fEthernetPoolsInitialized = FALSE;
    NDIS_STATUS Status;

    do
    {
        // TODO: replace 10, 100, by constants, or perhaps global vars.

        Status = arpInitializeConstBufferPool(
                        10,                             //NumBuffersToCache,
                        100,                            //MaxBuffers,
                        &Arp1394_IpEncapHeader,         //pvMem,
                        sizeof(Arp1394_IpEncapHeader),  //cbMem,
                        &pIF->Hdr,
                        &pIF->sendinfo.HeaderPool,
                        pSR
                        );

        if (FAIL(Status))
        {
            OBJLOG1(
                pIF,
                "Couldn't initialize const header pool (Status=0x%lx)!\n",
                Status
                );
            break;
        }

        fHeaderPoolInitialized = TRUE;

        Status =  arpAllocateControlPacketPool(
                                    pIF,
                                    ARP1394_MAX_PROTOCOL_PACKET_SIZE,
                                    pSR
                                    );

        if (FAIL(Status))
        {
            TR_WARN((
                "Couldn't allocate control packet pool (Status=0x%lx)!\n",
                Status
                ));
            break;
        }

        fPacketPoolInitialized = TRUE;

        Status = arpAllocateEthernetPools(
                                pIF,
                                pSR
                                );

        if (FAIL(Status))
        {
            OBJLOG1(
                pIF,
                "Couldn't allocate ethernet packet pool (Status=0x%lx)!\n",
                Status
                );
            break;
        }
        fEthernetPoolsInitialized = TRUE;

    } while (FALSE);

    if (FAIL(Status))
    {
        if (fHeaderPoolInitialized)
        {
            // Deinit the header const buffer pool.
            //
            arpDeinitializeConstBufferPool(&pIF->sendinfo.HeaderPool, pSR);
        }

        if (fPacketPoolInitialized)
        {
            // Deinit the control packet pool
            //
            arpFreeControlPacketPool( pIF,pSR);
        }

        if (fEthernetPoolsInitialized)
        {
            // Deinit the ethernet packet pool
            //
            arpFreeEthernetPools(pIF, pSR);
        }
    }
    else
    {
        ASSERT(fHeaderPoolInitialized && fPacketPoolInitialized);
        ASSERT(fEthernetPoolsInitialized);
    }

    return Status;
}


VOID
arpDeInitializeIfPools(
    IN  PARP1394_INTERFACE pIF,     // LOCKIN LOCKOUT
    IN  PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This routine is called in the context of deleting an interface. It
    cleans up the various buffer and packet pools associated with the interface.

    Should NOT be called with a partially-initialized pIF.

Arguments:

    pIF - Interface to deinit pools


--*/
{
    ENTER("arpDeInitializeIfPools", 0x1a54488d)
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    // Deinit the header const buffer pool.
    //
    arpDeinitializeConstBufferPool(&pIF->sendinfo.HeaderPool, pSR);

    // Deinit the control packet pool
    //
    arpFreeControlPacketPool(pIF,pSR);

    // Deinit the ethernet packet and buffer pool
    //
    arpFreeEthernetPools(pIF,pSR);

}


#if ARP_DEFERIFINIT
MYBOOL
arpIsAdapterConnected(
        IN  PARP1394_ADAPTER    pAdapter,   // NOLOCKIN NOLOCKOUT
        IN  PRM_STACK_RECORD    pSR
        )
{
    ENTER("arpIsAdapterConnected", 0x126b577a)
    // static UINT u = 0;
    MYBOOL  fRet;
    ARP_NDIS_REQUEST            ArpNdisRequest;
    NDIS_MEDIA_STATE            ConnectStatus;
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if 0
    if (u==0)
    {
        fRet = FALSE;
        u=1;
    }
    else
    {
        fRet = TRUE;
    }
#else // !0

    Status =  arpPrepareAndSendNdisRequest(
                pAdapter,
                &ArpNdisRequest,
                NULL,                       // pTask (NULL==BLOCK)
                0,                          // unused
                OID_1394_IP1394_CONNECT_STATUS,
                &ConnectStatus,
                sizeof(ConnectStatus),
                NdisRequestQueryInformation,
                pSR
                );
    ASSERT(!PEND(Status));

    fRet = FALSE;
    if (!FAIL(Status))
    {
        if (ConnectStatus == NdisMediaStateConnected)
        {
            fRet = TRUE;
        }
    }
#endif // !0
    
    
    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
    return fRet;
}

#endif // ARP_DEFERIFINIT


NDIS_STATUS
arpSetupSpecialDest(
    IN  PARP1394_INTERFACE      pIF,
    IN  NIC1394_ADDRESS_TYPE    AddressType,
    IN  PRM_TASK                pParentTask,
    IN  UINT                    PendCode,
    OUT PARPCB_DEST         *   ppSpecialDest,
    IN  PRM_STACK_RECORD        pSR
    )
{
    ENTER("SetupSpecialDest", 0x745a806d)
    ARP_DEST_PARAMS     DestParams;
    PCHAR               szDescription;
    PARPCB_DEST         pDest;
    INT                 fCreated = FALSE;
    PRM_TASK            pMakeCallTask;
    NDIS_STATUS         Status;
    MYBOOL              fBroadcastDest = FALSE;
    ULONG               LookupFlags = 0;
    PARP1394_ADAPTER    pAdapter = (PARP1394_ADAPTER)RM_PARENT_OBJECT(pIF);

    *ppSpecialDest = NULL;

    //
    // Let's create a destination object representing the
    // multichannel, and make a call to it.
    //
    ARP_ZEROSTRUCT(&DestParams);

    DestParams.HwAddr.AddressType =  AddressType;

    switch(AddressType)
    {
    case NIC1394AddressType_Channel:
        DestParams.HwAddr.Channel =  NIC1394_BROADCAST_CHANNEL;
        fBroadcastDest = TRUE;
        szDescription = "Task: Broadcast MakeCall";
    break;

    case NIC1394AddressType_MultiChannel:
        szDescription = "Task: MultiChannel MakeCall";
    break;

    case NIC1394AddressType_Ethernet:
        szDescription = "Task: Ethernet MakeCall";
    break;

    default:
        ASSERT(FALSE);
        return NDIS_STATUS_FAILURE;                 // ****** EARLY RETURN *****
    }

#if RM_EXTRA_CHECKING
    switch(AddressType)
    {
    case NIC1394AddressType_Channel:
        szDescription = "Task: Broadcast MakeCall";
    break;

    case NIC1394AddressType_MultiChannel:
        szDescription = "Task: MultiChannel MakeCall";
    break;

    case NIC1394AddressType_Ethernet:
        szDescription = "Task: Ethernet MakeCall";
    break;

    default:
        ASSERT(FALSE);
        return NDIS_STATUS_FAILURE;                 // ****** EARLY RETURN *****
    }
#endif // RM_EXTRA_CHECKING


    // Now create a destination item for this structure.
    //
    if (CHECK_POWER_STATE(pAdapter,ARPAD_POWER_LOW_POWER) == TRUE)
    {
        // In the resume, the Destination structures are aleady there
        // so don't create a new one.

        LookupFlags = 0;
    }
    else
    {
        //
        // We don't expect it to already exist in the non PM case
        //
        LookupFlags = RM_CREATE | RM_NEW;
    }
    
    Status = RmLookupObjectInGroup(
                    &pIF->DestinationGroup,
                    LookupFlags ,       
                    &DestParams,    // Key
                    &DestParams,    // pParams
                    (RM_OBJECT_HEADER**) &pDest,
                    &fCreated,
                    pSR
                    );
    if (FAIL(Status))
    {
        OBJLOG1( pIF, "FATAL: Couldn't create special dest type %d.\n", AddressType);
    }
    else
    {

        Status = arpAllocateTask(
                    &pDest->Hdr,            // pParentObject
                    arpTaskMakeCallToDest,  // pfnHandler
                    0,                      // Timeout
                    szDescription,
                    &pMakeCallTask,
                    pSR
                    );

        if (FAIL(Status))
        {
            RmTmpDereferenceObject(&pDest->Hdr, pSR);

            // NOTE: Even on failure, we leave the newly-created
            // special dest object. It will get cleaned up when
            // the interface is unloaded.
            //
        }
        else
        {
            *ppSpecialDest = pDest;

            if (fBroadcastDest)
            {
                // pDest contains a valid
                // pDest which has been tmpref'd. 
                // Keep a pointer to the broadcast dest in the IF.
                // and  link the broadcast dest to the IF.
                //
            #if RM_EXTRA_CHECKING
                RmLinkObjectsEx(
                    &pIF->Hdr,
                    &pDest->Hdr,
                    0xacc1dbe9,
                    ARPASSOC_LINK_IF_OF_BCDEST,
                    "    IF of Broadcast Dest 0x%p (%s)\n",
                    ARPASSOC_LINK_BCDEST_OF_IF,
                    "    Broadcast Dest of IF 0x%p (%s)\n",
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmLinkObjects(&pIF->Hdr, &pDest->Hdr,pSR);
            #endif // !RM_EXTRA_CHECKING

                LOCKOBJ(pIF, pSR);
                ASSERT(pIF->pBroadcastDest == NULL);
                pIF->pBroadcastDest = pDest;
                UNLOCKOBJ(pIF, pSR);

                // arpSetupSpecialDest ref'd pDest.
                //
                RmTmpDereferenceObject(&pDest->Hdr, pSR);
            }

            RmPendTaskOnOtherTask(
                pParentTask,
                PendCode,
                pMakeCallTask,
                pSR
                );
    
            (VOID)RmStartTask(
                    pMakeCallTask,
                    0, // UserParam (unused)
                    pSR
                    );
        
            Status = NDIS_STATUS_PENDING;
        }
    }

    return Status;
}



VOID
arpDestSendComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
)
{
    PARP_VC_HEADER pVcHdr       = (PARP_VC_HEADER) ProtocolVcContext;
    PARPCB_DEST         pDest   = CONTAINING_RECORD(pVcHdr, ARPCB_DEST, VcHdr);
    PARP1394_INTERFACE  pIF     = (PARP1394_INTERFACE) RM_PARENT_OBJECT(pDest);

    ASSERT_VALID_DEST(pDest);
    ASSERT_VALID_INTERFACE(pIF);

    // The call to NdisCoSendPacket returns.

    arpCompleteSentPkt(
            Status,
            pIF,
            pDest,
            pNdisPacket
            );
}


UINT
arpDestReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
)
//
// Standard Recv Handler for most Vcs
//
{
    PARP_VC_HEADER          pVcHdr;
    PARPCB_DEST             pDest;
    PARP1394_INTERFACE      pIF;
    PARP1394_ADAPTER        pAdapter ;
    BOOLEAN                 fBridgeMode ;
    
    pVcHdr  = (PARP_VC_HEADER) ProtocolVcContext;
    pDest   =  CONTAINING_RECORD( pVcHdr, ARPCB_DEST, VcHdr);
    ASSERT_VALID_DEST(pDest);
    pIF     = (ARP1394_INTERFACE*)  RM_PARENT_OBJECT(pDest);
    ASSERT_VALID_INTERFACE(pIF);

    pAdapter = (PARP1394_ADAPTER)pIF->Hdr.pParentObject;
        
    fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);

    //
    // if we are in bridge mode, then check to see if 
    // this is a loopback packet
    //
    if (fBridgeMode == TRUE)
    {
        
        PLOOPBACK_RSVD pLoopbackRsvd = (PLOOPBACK_RSVD) pNdisPacket->ProtocolReserved;
        
        BOOLEAN fIsLoopbackPacket = (pLoopbackRsvd->LoopbackTag == NIC_LOOPBACK_TAG);

        if (fIsLoopbackPacket  == TRUE)
        {
            // drop the packet as it is a loopback packet
            return 0;
        }

        // else it is a normal receive. continue to arpProcessReceivedPacket
    }


    //
    // Process the receive packet
    //

    return arpProcessReceivedPacket(
                pIF,
                pNdisPacket,
                TRUE                    // IsChannel
                );

}


VOID
arpDestIncomingClose(
    IN  NDIS_STATUS                 CloseStatus,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PVOID                       pCloseData  OPTIONAL,
    IN  UINT                        Size        OPTIONAL
)
{
    PARP_VC_HEADER          pVcHdr;
    PARP1394_INTERFACE      pIF;
    ARPCB_DEST          *   pDest;
    RM_DECLARE_STACK_RECORD(sr)

    pVcHdr  = (PARP_VC_HEADER) ProtocolVcContext;
    pDest   =  CONTAINING_RECORD( pVcHdr, ARPCB_DEST, VcHdr);
    ASSERT_VALID_DEST(pDest);
    pIF     = (ARP1394_INTERFACE*)  RM_PARENT_OBJECT(pDest);

    //
    // Since all our calls are outgoing, getting an IncomingClose means that
    // the call was in the active state. Anyway, what we need to do is update the
    // call state and start the VcCleanupTask for this Vc.
    //

    //
    // We leave the IF alone, but deinit the dest-VC.
    //
    OBJLOG1(pDest,"Got incoming close!  Status=0x%lx\n", CloseStatus);
    LOGSTATS_IncomingClosesOnChannels(pIF);
    (VOID) arpDeinitDestination(pDest, FALSE, &sr); //  FALSE == forced deinit

    RM_ASSERT_CLEAR(&sr);
}

VOID
arpTryAbortPrimaryIfTask(
    PARP1394_INTERFACE      pIF,    // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD        pSR
    )
{
    ENTER("arpTryAbortPrimaryIfTask", 0x39c51d16)

    RM_ASSERT_NOLOCKS(pSR);
    LOCKOBJ(pIF,pSR);

    if (pIF->pActDeactTask!=NULL)
    {
        //
        // Actually 
        // delayed.
        //
        PRM_TASK pTask = pIF->pActDeactTask;
        RmTmpReferenceObject(&pTask->Hdr, pSR);
        UNLOCKOBJ(pIF,pSR);
        
        if (pTask->pfnHandler ==  arpTaskActivateInterface)
        {
            TASK_ACTIVATE_IF *pActivateIfTask =  (TASK_ACTIVATE_IF *) pTask;
            UINT TaskResumed;
            TR_WARN(("Aborting ActivateIfTask %p\n", pTask));
            RmResumeDelayedTaskNow(
                &pActivateIfTask->TskHdr,
                &pActivateIfTask->Timer,
                &TaskResumed,
                pSR
                );
        }
        RmTmpDereferenceObject(&pTask->Hdr, pSR);
    }
    else
    {
        UNLOCKOBJ(pIF,pSR);
    }

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
}


NDIS_STATUS
arpTaskIfMaintenance(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for periodic IF maintenance.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pTask);
    PTASK_IF_MAINTENANCE    pIfTask;

    enum
    {
        STAGE_Start,
        STAGE_ResumeDelayed,
        STAGE_End

    } Stage;

    ENTER("TaskIfMaintenance", 0x57e523ed)

    pIfTask = (PTASK_IF_MAINTENANCE) pTask;
    ASSERT(sizeof(TASK_IF_MAINTENANCE) <= sizeof(ARP1394_TASK));

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_Start;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    ASSERTEX(!PEND(Status), pTask);
        
    switch(Stage)
    {

        case  STAGE_Start:
        {
            // If there is already a maintenance task, we exit immediately.
            //
            LOCKOBJ(pIF, pSR);
            if (pIF->pMaintenanceTask == NULL)
            {
                pIF->pMaintenanceTask = pTask;
                DBG_ADDASSOC(
                    &pIF->Hdr,                      // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_IF_MAINTENANCE_TASK,       // AssociationID
                    "    Official maintenance task 0x%p (%s)\n", // szFormat
                    pSR
                    );
            }
            else
            {
                // There already is a maintenance task. We're done.
                //
                UNLOCKOBJ(pIF, pSR);
                Status = NDIS_STATUS_SUCCESS;
                break;
            }
            UNLOCKOBJ(pIF, pSR);
        
            //
            // We're now the official maintenance task for this interface.
            //

            
            // We move on to the next stage, after a delay, and to get
            // out of the current context.
            //
            pIfTask->Delay = 5; // Arbitrary initial delay (seconds)

            RmSuspendTask(pTask, STAGE_ResumeDelayed, pSR);
            RmResumeTaskDelayed(
                pTask, 
                0,
                1000 * pIfTask->Delay,
                &pIfTask->Timer,
                pSR
                );
            Status = NDIS_STATUS_PENDING;


         }
         break;

        case STAGE_ResumeDelayed:
        {
            UINT    Time;
            UINT    Delta;
            MYBOOL  fProcessed;
            //
            // If qe're quitting, we get out of here.
            // Otherwise we'll send a packet either on the ethernet VC
            // or via the miniport's connectionless ethernet interface.
            //

            if (pIfTask->Quit)
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            Time = arpGetSystemTime();

            //
            // Process the MCAP database
            //
            Delta =  Time - pIfTask->McapDbMaintenanceTime;
            arpDoMcapDbMaintenance(pIF, Time, Delta, &fProcessed, pSR);
            if (fProcessed)
            {
                //
                // Update the last "McapDbMaintenance" time.
                //
                pIfTask->McapDbMaintenanceTime = Time;
            }

            //
            // Process Remote IPs
            //
            Delta =  Time - pIfTask->RemoteIpMaintenanceTime;
            arpDoRemoteIpMaintenance(pIF, Time, Delta, &fProcessed, pSR);
        
            if (fProcessed)
            {
                //
                // Update the last "RemoteIpMaintenance" time.
                //
                pIfTask->RemoteIpMaintenanceTime = Time;
            }

            //
            // Process Remote Eths
            //
            Delta =  Time - pIfTask->RemoteEthMaintenanceTime;
            arpDoRemoteEthMaintenance(pIF, Time, Delta, &fProcessed, pSR);
        
            if (fProcessed)
            {
                //
                // Update the last "RemoteIpMaintenance" time.
                //
                pIfTask->RemoteEthMaintenanceTime = Time;
            }

            //
            // Process Local IPs
            //
            Delta =  Time - pIfTask->LocalIpMaintenanceTime;
            arpDoLocalIpMaintenance(pIF, Time, Delta, &fProcessed, pSR);
        
            if (fProcessed)
            {
                //
                // Update the last "LocalIpMaintenance" time.
                //
                pIfTask->LocalIpMaintenanceTime = Time;
            }

            //
            // Process DhcpTableEntries
            //
            Delta =  Time - pIfTask->DhcpTableMaintainanceTime;;
            arpDoDhcpTableMaintenance(pIF, Time, Delta, &fProcessed, pSR);
        
            if (fProcessed)
            {
                //
                // Update the last "LocalIpMaintenance" time.
                //
                pIfTask->DhcpTableMaintainanceTime= Time;
            }

            // Now we wait again...
            //
            RmSuspendTask(pTask, STAGE_ResumeDelayed, pSR);
            RmResumeTaskDelayed(
                pTask, 
                0,
                1000 * pIfTask->Delay,
                &pIfTask->Timer,
                pSR
                );
            Status = NDIS_STATUS_PENDING;

        }
        break;

        case STAGE_End:
        {
            NDIS_HANDLE                 BindContext;


            LOCKOBJ(pIF, pSR);
            if (pIF->pMaintenanceTask == pTask)
            {
                // We're the official ics test task, we clear ourselves from
                // the interface object and do any initialization required.
                //
                DBG_DELASSOC(
                    &pIF->Hdr,                      // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_IF_MAINTENANCE_TASK,       // AssociationID
                    pSR
                    );
                pIF->pMaintenanceTask = NULL;
                UNLOCKOBJ(pIF, pSR);
            }
            else
            {
                // We're not the official IF maintenance task.
                // Nothing else to do.
                //
                UNLOCKOBJ(pIF, pSR);
                break;
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


VOID
arpStartIfMaintenanceTask(
    IN  PARP1394_INTERFACE          pIF,  // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD                pSR
    )
{
    PRM_TASK pTask;
    NDIS_STATUS Status;
    ENTER("arpStartIfMaintenanceTask", 0xb987276b)

    RM_ASSERT_NOLOCKS(pSR);

    //
    // Allocate and start an instance of the arpTaskIfMaintenance task.
    //

    Status = arpAllocateTask(
                &pIF->Hdr,          // pParentObject
                arpTaskIfMaintenance,       // pfnHandler
                0,                              // Timeout
                "Task: IF Maintenance", // szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        TR_WARN(("couldn't alloc IF maintenance task!\n"));
    }
    else
    {

        (VOID)RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    pSR
                    );
    }

    EXIT()
}

NDIS_STATUS
arpTryStopIfMaintenanceTask(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  PRM_TASK                    pTask, // task to pend until M task completes
    IN  UINT                        PendCode, // Pend code to suspend task.
    PRM_STACK_RECORD                pSR
    )
/*++
    Status : PENDING means task has been suspended, non PENDING
    means operation has completed synchronously.
--*/
{
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    PTASK_IF_MAINTENANCE    pIfTask;
    ENTER("arpTryStopIfMaintenanceTask", 0xb987276b)


    LOCKOBJ(pIF, pSR);

    pIfTask = (PTASK_IF_MAINTENANCE) pIF->pMaintenanceTask;
    if (pIfTask != NULL)
    {
        pIfTask->Quit = TRUE;
        RmTmpReferenceObject(&pIfTask->TskHdr.Hdr, pSR);
    }
    UNLOCKOBJ(pIF, pSR);

    //
    // Resume the maintenance task if it's waiting  -- it will then quit
    // because we set the Quit field above.
    //
    if (pIfTask != NULL)
    {
        UINT    TaskResumed;

        Status = RmPendTaskOnOtherTask(
                    pTask,
                    PendCode,
                    &pIfTask->TskHdr,
                    pSR
                    );

        if (Status == NDIS_STATUS_SUCCESS)
        {
            RmResumeDelayedTaskNow(
                &pIfTask->TskHdr,
                &pIfTask->Timer,
                &TaskResumed,
                pSR
                );
            Status = NDIS_STATUS_PENDING; // We've GOT to return pending!
        }
        else
        {
            ASSERT(FALSE);
            Status = NDIS_STATUS_FAILURE;
        }

        RmTmpDereferenceObject(&pIfTask->TskHdr.Hdr, pSR);
    }

    RM_ASSERT_NOLOCKS(pSR)
    EXIT()

    return Status;
}

VOID
arpDoLocalIpMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        )
{
    ENTER("LocalIpMaintenance", 0x1a39fc89)

    if (SecondsSinceLastMaintenance < 10)
    {
        TR_INFO(("Skipping Local Ip maintenance (delay=%lu).\n",
                SecondsSinceLastMaintenance
                ));
        *pfProcessed = FALSE;
        return;                             // EARLY RETURN;
    }

    *pfProcessed = TRUE;

    TR_INFO(("Actually doing Local Ip maintenance.\n"));

    RmWeakEnumerateObjectsInGroup(
        &pIF->LocalIpGroup,
        arpMaintainOneLocalIp,
        NULL, // Context
        pSR
        );

    EXIT()
}

VOID
arpDoRemoteIpMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        )
{
    ENTER("RemoteIpMaintenance", 0x1ae00035)

    if (SecondsSinceLastMaintenance < 15)
    {
        TR_INFO(("Skipping Remote Ip maintenance (delay=%lu).\n",
                SecondsSinceLastMaintenance
                ));
        *pfProcessed = FALSE;
        return;                             // EARLY RETURN;
    }

    *pfProcessed = TRUE;

    TR_INFO(("Actually doing Remote Ip maintenance.\n"));

    RmWeakEnumerateObjectsInGroup(
        &pIF->RemoteIpGroup,
        arpMaintainArpCache,
        NULL, // Context
        pSR
        );

    EXIT()
}


VOID
arpDoRemoteEthMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        )
{
    ENTER("RemoteEthMaintenance", 0x6c496b7f)

    if (SecondsSinceLastMaintenance < 15)
    {
        TR_INFO(("Skipping Eth Ip maintenance (delay=%lu).\n",
                SecondsSinceLastMaintenance
                ));
        *pfProcessed = FALSE;
        return;                             // EARLY RETURN;
    }

    *pfProcessed = TRUE;

    TR_INFO(("Actually doing Remote Eth maintenance.\n"));

    RmWeakEnumerateObjectsInGroup(
        &pIF->RemoteEthGroup,
        arpMaintainOneRemoteEth,
        NULL, // Context
        pSR
        );

    EXIT()
}


VOID
arpDoDhcpTableMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        )
{
    ENTER("DhcpMaintenance", 0x1a39fc89)

    if (SecondsSinceLastMaintenance < 120)
    {
        TR_INFO(("Skipping Local Ip maintenance (delay=%lu).\n",
                SecondsSinceLastMaintenance
                ));
        *pfProcessed = FALSE;
        return;                             // EARLY RETURN;
    }

    *pfProcessed = TRUE;

    TR_INFO(("Actually doing Dhcp maintenance.\n"));

    RmWeakEnumerateObjectsInGroup(
        &pIF->EthDhcpGroup,
        arpMaintainOneDhcpEntry,
        NULL, // Context
        pSR
        );

    EXIT()
}


// Enum function
//
INT
arpMaintainOneDhcpEntry(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
{
    ENTER("arpMaintainOneDhcpEntry", 0xc7604372)
    NDIS_STATUS         Status;
    ARP1394_ETH_DHCP_ENTRY *pEntry;
    PARP1394_INTERFACE  pIF;


    pEntry = (ARP1394_ETH_DHCP_ENTRY *) pHdr;

    pIF = (PARP1394_INTERFACE  )RM_PARENT_OBJECT (pEntry);

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        UINT                CurrentTime = arpGetSystemTime();

        #define ARP_PURGE_DHCP_TABLE_TIME 90    // Arp entry timeout.

        //
        // NOTE: we don't bother to get the lock with dealing with
        // sendinfo.TimeLastChecked -- this is ok.
        //
        if (pEntry->TimeLastChecked==0)
        {
            // Set this field to the current time. It will be cleared back to 0
            // when the next packet is sent to this remote Eth.
            //
            pEntry->TimeLastChecked = CurrentTime;
        }
        else if ((CurrentTime - pEntry->TimeLastChecked)
                     >= ARP_PURGE_DHCP_TABLE_TIME )
        {
            // 
            // We should clean up this dhcp entry. this is the only code path 
            // from which an entry is ever deleted.
            //

            RmFreeObjectInGroup(
                &pIF->EthDhcpGroup,
                &(pEntry->Hdr),
                NULL,               // NULL pTask == synchronous.
                pSR
                );

            break;
        }

    } while (FALSE);
    
    RM_ASSERT_NOLOCKS(pSR)

    return TRUE; // Continue to enumerate.
}

    
// Enum function
//
INT
arpMaintainOneLocalIp(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
{
    ENTER("MaintainOneLocalIp", 0x1ae00035)
    PARPCB_LOCAL_IP     pLocalIp;
    IP_ADDRESS          LocalAddr;
    PARP1394_INTERFACE  pIF;
    UINT                Channel;

    pLocalIp    = (PARPCB_LOCAL_IP) pHdr;
    LocalAddr   = pLocalIp->IpAddress;
    pIF         = IF_FROM_LOCALIP(pLocalIp);

    RM_ASSERT_NOLOCKS(pSR);
    do
    {
        ARPCB_DEST  *pDest;
        ARP_DEST_PARAMS DestParams;

        // Skip if we can't do MCAP on this address.
        //
        LOCKOBJ(pLocalIp, pSR);
        if (!CHECK_LOCALIP_MCAP(pLocalIp, ARPLOCALIP_MCAP_CAPABLE))
        {
            UNLOCKOBJ(pLocalIp, pSR);
            break;
        }
        UNLOCKOBJ(pLocalIp, pSR);
    
        //
        // Find a channel mapping to this address, if any.
        //
        Channel = arpFindAssignedChannel(
                        pIF, 
                        LocalAddr,
                        0,          // TODO -- pass in current time.
                        pSR
                        );
        
        //
        // NOTE: Special return value NIC1394_BROADCAST_CHANNEL is returned if
        // this address is mapped to no specific channel.
        //
    
        ARP_ZEROSTRUCT(&DestParams);
        DestParams.HwAddr.AddressType =  NIC1394AddressType_Channel;
        DestParams.HwAddr.Channel =  Channel;
        DestParams.ReceiveOnly =  TRUE;
        DestParams.AcquireChannel =  FALSE;

        arpUpdateLocalIpDest(pIF, pLocalIp, &DestParams, pSR);

    
    } while (FALSE);
    
    RM_ASSERT_NOLOCKS(pSR)

    return TRUE; // Continue to enumerate.
}


// Enum function
//
INT
arpMaintainOneRemoteIp(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
#if 0
    for each RIP send VC
        if !marked dirty
            mark dirty
            if linked to channel pdest
            check if channel is still mapped to group
            if not, unlink.
            if required initiate link to new pdest (possibly channel)
        else
            //expired
            unlink from pdest and get rid of it
#endif // 0
{
    ENTER("MaintainOneRemoteIp", 0x1ae00035)
    NDIS_STATUS         Status;
    PARPCB_REMOTE_IP    pRemoteIp;
    PARP1394_INTERFACE  pIF;


    pRemoteIp   = (PARPCB_REMOTE_IP) pHdr;
    pIF         = IF_FROM_LOCALIP(pRemoteIp);

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        IP_ADDRESS          IpAddr;
        UINT                Channel;
        ARP_DEST_PARAMS     DestParams;
        ARPCB_DEST          *pDest;
        BOOLEAN             AcquireChannel;
        UINT                CurrentTime = arpGetSystemTime();

        IpAddr      = pRemoteIp->Key.IpAddress;

        #define ARP_PURGE_REMOTEIP_TIME 300 // Arp entry timeout.

        //
        // NOTE: we don't bother to get the lock with dealing with
        // sendinfo.TimeLastChecked -- this is ok.
        //
        if (pRemoteIp->sendinfo.TimeLastChecked==0)
        {

            if (CHECK_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_DYNAMIC)
                || CHECK_REMOTEIP_RESOLVE_STATE (pRemoteIp, ARPREMOTEIP_UNRESOLVED))
            {
                // Set this field to the current time. It will be cleared back to 0
                // when the next packet is sent to this remote ip.
                //
                pRemoteIp->sendinfo.TimeLastChecked = CurrentTime;
            }
        }
        else if ((CurrentTime - pRemoteIp->sendinfo.TimeLastChecked)
                     >= ARP_PURGE_REMOTEIP_TIME)
        {
            // 
            // We should clean up this remote ip.
            //
            arpDeinitRemoteIp(pRemoteIp, pSR);
            break;
        }

#if ARP_ENABLE_MCAP_SEND

        //
        // We'll now see if we need to re-set which destination this
        // pRemoteIp points to.
        //

        // Skip if we can't do MCAP on this address.
        //
        LOCKOBJ(pRemoteIp, pSR);
        if (!CHECK_REMOTEIP_MCAP(pRemoteIp, ARPREMOTEIP_MCAP_CAPABLE))
        {
            UNLOCKOBJ(pRemoteIp, pSR);
            break;
        }
        UNLOCKOBJ(pRemoteIp, pSR);

        //
        // Find a channel mapping to this address, if any.
        //
        Channel = arpFindAssignedChannel(
                        pIF, 
                        pRemoteIp->Key.IpAddress,
                        0,
                        pSR
                        );
        
        //
        // NOTE: Special return value NIC1394_BROADCAST_CHANNEL is returned if
        // this address is mapped to no specific channel.
        //

        AcquireChannel = FALSE;

    
    #if 0   // Let's not enable this just yet -- instead 

        if (Channel == NIC1394_BROADCAST_CHANNEL)
        {
            //
            // Hmm... let's get aggressive and try to grab a channel.
            //
            Channel = arpFindFreeChannel(pIF, pSR);
            if (Channel != NIC1394_BROADCAST_CHANNEL)
            {
                //
                // Got one!
                //
                AcquireChannel = TRUE;
            }
        }
        else
        {
            //
            // There is already a channel allocated by someone to be used
            // for this ip address. Let's use it.
            //
        }
    #endif // 0 
    
        ARP_ZEROSTRUCT(&DestParams);
        DestParams.HwAddr.AddressType =  NIC1394AddressType_Channel;
        DestParams.HwAddr.Channel =  Channel;
        DestParams.AcquireChannel =  AcquireChannel;

        arpUpdateRemoteIpDest(pIF, pRemoteIp, &DestParams, pSR);

#endif //  ARP_ENABLE_MCAP_SEND

    } while (FALSE);
    
    RM_ASSERT_NOLOCKS(pSR)

    return TRUE; // Continue to enumerate.
}


// Enum function
//
INT
arpMaintainOneRemoteEth(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
{
    ENTER("MaintainOneRemoteEth", 0x21807796)
    NDIS_STATUS         Status;
    PARPCB_REMOTE_ETH   pRemoteEth;
    PARP1394_INTERFACE  pIF;


    pRemoteEth  = (PARPCB_REMOTE_ETH) pHdr;
    pIF         = IF_FROM_LOCALIP(pRemoteEth);

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        UINT                CurrentTime = arpGetSystemTime();

        #define ARP_PURGE_REMOTEETH_TIME 300    // Arp entry timeout.

        //
        // NOTE: we don't bother to get the lock with dealing with
        // sendinfo.TimeLastChecked -- this is ok.
        //
        if (pRemoteEth->TimeLastChecked==0)
        {
            // Set this field to the current time. It will be cleared back to 0
            // when the next packet is sent to this remote Eth.
            //
            pRemoteEth->TimeLastChecked = CurrentTime;
        }
        else if ((CurrentTime - pRemoteEth->TimeLastChecked)
                     >= ARP_PURGE_REMOTEETH_TIME)
        {
            // 
            // We should clean up this remote eth.
            //
            arpDeinitRemoteEth(pRemoteEth, pSR);
            break;
        }

    } while (FALSE);
    
    RM_ASSERT_NOLOCKS(pSR)

    return TRUE; // Continue to enumerate.
}


UINT
arpFindAssignedChannel(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  IP_ADDRESS                  IpAddress,
    IN  UINT                        CurrentTime, // OPTIONAL
    PRM_STACK_RECORD                pSR
    )
/*++
    NOTE: Special return value NIC1394_BROADCAST_CHANNEL is returned if
    this address is mapped to no specific channel.
--*/
{
    ENTER("FindAssignedChannel", 0xd20a216b)
    UINT Channel = NIC1394_BROADCAST_CHANNEL;
    UINT u;

    LOCKOBJ(pIF, pSR);

    if (CurrentTime == 0)
    {
        CurrentTime = arpGetSystemTime();
    }

    //
    // Run down the channel info array, looking for a matching IP address.
    //
    for (u = 0;  u < ARP_NUM_CHANNELS; u++)
    {
        PMCAP_CHANNEL_INFO pMci;
        pMci = &pIF->mcapinfo.rgChannelInfo[u];

        if (    IpAddress == pMci->GroupAddress
            &&  arpIsActiveMcapChannel(pMci, CurrentTime))
        {
            ASSERT(pMci->Channel == u);
            Channel = u;
            TR_WARN(("Found Matching channel %lu for ip address 0x%lu.\n",
                Channel,
                IpAddress
                ));
            break;
        }
    }

    UNLOCKOBJ(pIF, pSR);

    return Channel;

    EXIT()
}


VOID
arpUpdateLocalIpDest(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  PARPCB_LOCAL_IP             pLocalIp,
    IN  PARP_DEST_PARAMS            pDestParams,
    PRM_STACK_RECORD                pSR
    )
/*++
    Make pLocalIp point to a des with params pDestParams. 
    Create a pDest if required.
    If pLocalIp is pointing to some other pDest, cleanup that other pDest if
    no one else is refering to it.
--*/
{
    ENTER("UpdateLocalIpDest", 0x3f2dcaa7)
    ARPCB_DEST          *pOldDest = NULL;

    RM_ASSERT_NOLOCKS(pSR);

    // pLocalIp uses it's parent's (pIF's) lock.
    //
    RM_ASSERT_SAME_LOCK_AS_PARENT(pLocalIp);

    do
    {
        PCHAR               szDescription;
        INT                 fCreated = FALSE;
        PRM_TASK            pMakeCallTask;
        UINT                Channel;
        NDIS_STATUS         Status;
        ARPCB_DEST          *pDest;

        //
        // Currently, only Channel Dests are supported.
        //
        if (pDestParams->HwAddr.AddressType != NIC1394AddressType_Channel)
        {
            ASSERT(FALSE);
            break;
        }
        else
        {
            Channel =  pDestParams->HwAddr.Channel;
        }

        LOCKOBJ(pIF, pSR);

        RM_DBG_ASSERT_LOCKED(&pLocalIp->Hdr, pSR); // same lock as pIF;
        pDest = pLocalIp->pDest;

        if (pDest != NULL)
        {
            RM_DBG_ASSERT_LOCKED(&pDest->Hdr, pSR); // same lock as pIF;

            if (pDest->Params.HwAddr.AddressType == NIC1394AddressType_Channel)
            {
                if (pDest->Params.HwAddr.Channel == Channel)
                {
                    //
                    // We're already linked to this channel. Nothing more to do.
                    //
                    UNLOCKOBJ(pIF, pSR);
                    break;
                }
            }
            else
            {
                //
                // Shouldn't get here -- MCAP_CAPABLE addresses shouldn't be
                // linked to non-channel destinations (for NOW anyway).
                //
                ASSERT(!"pLocalIp linked to non-channel pDest.");
                UNLOCKOBJ(pIF, pSR);
                break;
            }

            //
            // We're linked to some other pDest currently. We'll have
            // to unlink ourselves from pDest, and get rid of the other
            // pDest if no one is using it.
            //
            RmTmpReferenceObject(&pDest->Hdr, pSR);
    
            arpUnlinkLocalIpFromDest(pLocalIp, pSR);
        }

        pOldDest = pDest;
        pDest = NULL;
    
        ASSERT(pLocalIp->pDest == NULL);
    
    
        //
        // SPECIAL CASE: If the channel is the broadcast channel, we don't
        // need to do anything more, because the broadcast channel is always
        // active.
        //
        if (Channel ==  NIC1394_BROADCAST_CHANNEL)
        {
            UNLOCKOBJ(pIF, pSR);
            break;
        }

        //
        // Now link to a new dest and if required initiate a call on it.
        //


        // Now create a destination item for this structure.
        //
        Status = RmLookupObjectInGroup(
                        &pIF->DestinationGroup,
                        RM_CREATE,      // Create if required
                        pDestParams,    // Key
                        pDestParams,    // pParams
                        (RM_OBJECT_HEADER**) &pDest,
                        &fCreated,
                        pSR
                        );
        if (FAIL(Status))
        {
            UNLOCKOBJ(pIF, pSR);
            OBJLOG1( pIF, "FATAL: Couldn't create local-ip dest type %d.\n",
                            pDestParams->HwAddr.AddressType);
            break;
        }
    

        Status = arpAllocateTask(
                    &pDest->Hdr,            // pParentObject
                    arpTaskMakeCallToDest,  // pfnHandler
                    0,                      // Timeout
                    "Task: MakeCallToDest (local ip)",
                    &pMakeCallTask,
                    pSR
                    );

        if (FAIL(Status))
        {
            UNLOCKOBJ(pIF, pSR);

            // NOTE: Even on failure, we leave the newly-created
            // special dest object. It will get cleaned up when
            // the interface is unloaded.
            //
        }
        else
        {
            arpLinkLocalIpToDest(pLocalIp, pDest, pSR);

            UNLOCKOBJ(pIF, pSR);

            (VOID)RmStartTask(
                    pMakeCallTask,
                    0, // UserParam (unused)
                    pSR
                    );
        }
        RmTmpDereferenceObject(&pDest->Hdr, pSR); // Added by RmLookupObjectIn..

    } while (FALSE);

    //
    // If required, get rid of pOldDest.
    //
    if (pOldDest != NULL)
    {
        arpDeinitDestination(pOldDest, TRUE,  pSR); // TRUE == only if unused.
        RmTmpDereferenceObject(&pOldDest->Hdr, pSR);
    }

    RM_ASSERT_NOLOCKS(pSR);
}


UINT
arpFindFreeChannel(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD                pSR
    )
/*++
    NOTE: Special return value NIC1394_BROADCAST_CHANNEL is returned if
    we couldn't find a free channel.

    Also there's no guarantee that this channel is really free.
--*/
{
    ENTER("FindAssignedChannel", 0xd20a216b)
    UINT Channel = NIC1394_BROADCAST_CHANNEL;
    UINT u;

    LOCKOBJ(pIF, pSR);

    //
    // Run down the channel info array, looking for an empty slot.
    //
    for (u = 0;  u < ARP_NUM_CHANNELS; u++)
    {
        PMCAP_CHANNEL_INFO pMci;
        pMci = &pIF->mcapinfo.rgChannelInfo[u];

        if (pMci->GroupAddress == 0)
        {
            ASSERT(pMci->Channel == 0);
            // pMci->Channel = u;
            Channel = u;
            TR_WARN(("Found Free channel %lu.\n",
                Channel
                ));
            break;
        }
    }

    UNLOCKOBJ(pIF, pSR);

    return Channel;

    EXIT()
}


VOID
arpUpdateRemoteIpDest(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  PARPCB_REMOTE_IP            pRemoteIp,
    IN  PARP_DEST_PARAMS            pDestParams,
    PRM_STACK_RECORD                pSR
    )
{
    ENTER("UpdateRemoteIpDest", 0x3f2dcaa7)
    ARPCB_DEST          *pOldDest = NULL;

    RM_ASSERT_NOLOCKS(pSR);

    // pRemoteIp uses it's parent's (pIF's) lock.
    //
    RM_ASSERT_SAME_LOCK_AS_PARENT(pRemoteIp);

    do
    {
        PCHAR               szDescription;
        INT                 fCreated = FALSE;
        PRM_TASK            pMakeCallTask;
        UINT                Channel;
        NDIS_STATUS         Status;
        ARPCB_DEST          *pDest;

        //
        // Lookup/Create Remote Destination
        // NOTE/WARNING: We'll create a new destination even if one exists for
        // the same uniqueID but different FIFO-address -- this is by design.
        // What should happen is that the old pDest should be eventually removed.
        //
        Status = RmLookupObjectInGroup(
                        &pIF->DestinationGroup,
                        RM_CREATE,              //NOT RM_NEW (could be existing)
                        pDestParams,
                        pDestParams,    // pParams
                        (RM_OBJECT_HEADER**) &pDest,
                        &fCreated,
                        pSR
                        );
        if (FAIL(Status))
        {
            OBJLOG1(
                pIF,
                "Couldn't add dest entry with hw addr 0x%lx\n",
                (UINT) pDestParams->HwAddr.FifoAddress.UniqueID // Truncation
                );
            
            //
            // We'll leave the RemoteIp entry around -- it will be cleaned up later.
            //
        #if 0
            // We do have to deref the tmpref added when looking it up.
            //
            RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
        #endif // 0
            break;
        }

        LOCKOBJ(pIF, pSR);

        if (pRemoteIp->pDest != pDest)
        {
            // If required, unlink any existing destination from pIP.
            //
            if (pRemoteIp->pDest != NULL)
            {
                pOldDest =  pRemoteIp->pDest;
                RmTmpReferenceObject(&pOldDest->Hdr, pSR);

                arpUnlinkRemoteIpFromDest(
                    pRemoteIp,  // LOCKIN LOCKOUT
                    pSR
                    );
                ASSERT(pRemoteIp->pDest == NULL);
            }
    
            // Set the pRemoteIp state to reflect that it is FIFO/Channel
            // and DYNAMIC.
            //
            {

                // (Dbg only) Change lock scope from pIF to pLocalIp, because
                // we're altering pLocalIp's state below...
                //
                RmDbgChangeLockScope(
                    &pIF->Hdr,
                    &pRemoteIp->Hdr,
                    0x1385053b,             // LocID
                    pSR
                    );
    
                if (pDestParams->HwAddr.AddressType ==  NIC1394AddressType_FIFO)
                {
                    SET_REMOTEIP_FCTYPE(pRemoteIp, ARPREMOTEIP_FIFO);
                }
                else
                {
                    SET_REMOTEIP_FCTYPE(pRemoteIp, ARPREMOTEIP_CHANNEL);
                }
                SET_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_DYNAMIC);

                // (Dbg only) Change lock scope back to pIF.
                //
                RmDbgChangeLockScope(
                    &pRemoteIp->Hdr,
                    &pIF->Hdr,
                    0x315d28a1,             // LocID
                    pSR
                    );
            }
    
            // Link pRemoteIp to pDest.
            //
            //
            // We've created both RemoteIp and Destination entries. Now link them.
            // (We still have the IF lock, which is the same as the RemoteIP and 
            //  desination locks for now).
            //
            // TODO: will need to change this when pRemoteIp gets its own lock.
            //
            RM_ASSERT_SAME_LOCK_AS_PARENT(pRemoteIp);
            RM_ASSERT_SAME_LOCK_AS_PARENT(pDest);
        
            arpLinkRemoteIpToDest(
                pRemoteIp,
                pDest,
                pSR
                );
        }
        
        UNLOCKOBJ(pIF, pSR);

        RmTmpDereferenceObject(&pDest->Hdr, pSR);

    } while(FALSE);

    //
    // If required, get rid of pOldDest.
    //
    if (pOldDest != NULL)
    {
        arpDeinitDestination(pOldDest, TRUE,  pSR); // TRUE == only if unused.
        RmTmpDereferenceObject(&pOldDest->Hdr, pSR);
    }

    RM_ASSERT_NOLOCKS(pSR);
}


VOID
arpDeinitRemoteIp(
    PARPCB_REMOTE_IP        pRemoteIp,
    PRM_STACK_RECORD        pSR
    )
/*++
    Unload a remote ip.
--*/
{
    ENTER("arpDeinitRemoteIp", 0xea0a2662)
    PRM_TASK    pTask;
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if DBG
    {
        IP_ADDRESS IpAddress = pRemoteIp->Key.IpAddress;
        TR_WARN(("Deiniting RemoteIp %d.%d.%d.%d\n",
                ((PUCHAR)(&IpAddress))[0],
                ((PUCHAR)(&IpAddress))[1],
                ((PUCHAR)(&IpAddress))[2],
                ((PUCHAR)(&IpAddress))[3]));
    }
#endif // DBG

    Status = arpAllocateTask(
                &pRemoteIp->Hdr,                // pParentObject,
                arpTaskUnloadRemoteIp,      // pfnHandler,
                0,                          // Timeout,
                "Task: Unload Remote Ip",       // szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        OBJLOG0(pRemoteIp, ("FATAL: couldn't alloc unload pRemoteIp task!\n"));
    }
    else
    {
        (VOID) RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    pSR
                    );
    }
}


VOID
arpDeinitRemoteEth(
    PARPCB_REMOTE_ETH       pRemoteEth,
    PRM_STACK_RECORD        pSR
    )
/*++
    Unload a remote ip.
--*/
{
    ENTER("arpDeinitRemoteEth", 0x72dd17e7)
    PRM_TASK    pTask;
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if DBG
    {
        IP_ADDRESS IpAddress = pRemoteEth->IpAddress;
        TR_WARN(("Deiniting RemoteEth %d.%d.%d.%d\n",
                ((PUCHAR)(&IpAddress))[0],
                ((PUCHAR)(&IpAddress))[1],
                ((PUCHAR)(&IpAddress))[2],
                ((PUCHAR)(&IpAddress))[3]));
    }
#endif // DBG

    Status = arpAllocateTask(
                &pRemoteEth->Hdr,               // pParentObject,
                arpTaskUnloadRemoteEth,     // pfnHandler,
                0,                          // Timeout,
                "Task: Unload Remote Eth",      // szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        OBJLOG0(pRemoteEth, ("FATAL: couldn't alloc unload pRemoteIp task!\n"));
    }
    else
    {
        (VOID) RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    pSR
                    );
    }
}


VOID
arpDoMcapDbMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        )
/*++
    Go through the mcap database, zeroing out all entries marked
    "NotRecentlyUpdated", and marking all others "NotRecentlyUpdated."

    Also send out an mcap advertisements for all channels we've locally allocated.
--*/
{
    UINT u;
    UINT NumLocallyAllocated =0;
    PNDIS_PACKET pNdisPacket;
    NDIS_STATUS Status;

    ENTER("McapDbMaintenance", 0x1ae00035)

    if (SecondsSinceLastMaintenance < 10)
    {
        TR_INFO(("Skipping McapDb maintenance (delay=%lu).\n",
                SecondsSinceLastMaintenance
                ));
        *pfProcessed = FALSE;
        return;                             // EARLY RETURN;
    }

    *pfProcessed = TRUE;

    TR_INFO(("Actually doing Mcap Db maintenance.\n"));


    LOCKOBJ(pIF, pSR);

    //
    // Run down the channel info array, looking for and zapping stale channel
    // assignments.
    //
    for (u = 0;  u < ARP_NUM_CHANNELS; u++)
    {
        PMCAP_CHANNEL_INFO pMci;
        MYBOOL fOk;
        pMci = &pIF->mcapinfo.rgChannelInfo[u];

        if (pMci->GroupAddress == 0) continue; // An empty record.
        
        fOk = arpIsActiveMcapChannel(pMci, CurrentTime);

        if (!fOk)
        {
            TR_WARN(("McapDB: clearing stale channel %lu.\n",
                pMci->Channel
                ));
            ASSERT(pMci->Channel == u);
            ARP_ZEROSTRUCT(pMci);
            continue;
        }

        if (pMci->Flags & MCAP_CHANNEL_FLAGS_LOCALLY_ALLOCATED)
        {
            NumLocallyAllocated++;
        }
    }

    // If required, send an mcap advertisement packet.
    //
    do
    {
        IP1394_MCAP_PKT_INFO    PktInfo;
        PIP1394_MCAP_GD_INFO    pGdi;
        UINT                    cb = NumLocallyAllocated * sizeof(*pGdi);
        UINT                    u, v;

        if (NumLocallyAllocated==0) break;

        ASSERT(FALSE);

        if (cb <= sizeof(PktInfo.GdiSpace))
        {
            pGdi = PktInfo.GdiSpace;
        }
        else
        {
            NdisAllocateMemoryWithTag(&pGdi, cb,  MTAG_MCAP_GD);
            if (pGdi == NULL)
            {
                TR_WARN(("Allocation Failure"));
                break;
            }
        }
        PktInfo.pGdis = pGdi;

        // Now go through the mcap list,  picking up locally allocated 
        // channels.
        //
        for (u=0, v=0;  u < ARP_NUM_CHANNELS; u++)
        {
            PMCAP_CHANNEL_INFO pMci;
            pMci = &pIF->mcapinfo.rgChannelInfo[u];
    
            if (pMci->Flags & MCAP_CHANNEL_FLAGS_LOCALLY_ALLOCATED)
            {
                if (v >= NumLocallyAllocated)
                {
                    ASSERT(FALSE);
                    break;
                }
                if (pMci->ExpieryTime > CurrentTime)
                {
                    pGdi->Expiration    = pMci->ExpieryTime - CurrentTime;
                }
                else
                {
                    pGdi->Expiration    = 0;
                }

                pGdi->Channel       = pMci->Channel;
                pGdi->SpeedCode     = pMci->SpeedCode;
                pGdi->GroupAddress  = pMci->GroupAddress;

                v++;  pGdi++;
            }
        }

        UNLOCKOBJ(pIF, pSR);

        PktInfo.NumGroups   =  v;
        PktInfo.SenderNodeID    =  0;           // TODO
        PktInfo.OpCode      =  IP1394_MCAP_OP_ADVERTISE;

        //
        // Now we must actually allocate and send the advertisement.
        //
        Status = arpCreateMcapPkt(
                    pIF,
                    &PktInfo,
                    &pNdisPacket,
                    pSR
                    );

        if (FAIL(Status)) break;

        TR_WARN(("Attempting to send MCAP ADVERTISE PKT."
            "NumGoups=%lu Group0-1 == 0x%08lx->%lu 0x%08lx->%lu.\n",
                PktInfo.NumGroups,
                PktInfo.pGdis[0].GroupAddress,
                PktInfo.pGdis[0].Channel,
                PktInfo.pGdis[1].GroupAddress,
                PktInfo.pGdis[1].Channel
                ));

        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        // Actually send the packet (this will silently fail and free the pkt
        // if we're not in a position to send the pkt.)
        //
        arpSendControlPkt(
                pIF,            // LOCKIN NOLOCKOUT (IF send lk)
                pNdisPacket,
                pIF->pBroadcastDest,
                pSR
                );
        
        RM_ASSERT_NOLOCKS(pSR);
        RmTmpDereferenceObject(&pIF->Hdr, pSR);

    } while (FALSE);

    UNLOCKOBJ(pIF, pSR);

    EXIT()
}


#if DBG
VOID
arpDbgDisplayMapping(
    IP_ADDRESS              IpAddress,
    PNIC1394_DESTINATION    pHwAddr,
    char *                  szPrefix
    )
{
    ENTER("MAP", 0x0)
    if (pHwAddr == NULL)
    {
        TR_WARN(("%s %d.%d.%d.%d --> <no destination>\n",
                szPrefix,
                ((PUCHAR)(&IpAddress))[0],
                ((PUCHAR)(&IpAddress))[1],
                ((PUCHAR)(&IpAddress))[2],
                ((PUCHAR)(&IpAddress))[3]));
    }
    else if (pHwAddr->AddressType ==  NIC1394AddressType_FIFO)
    {
        PUCHAR puc = (PUCHAR)  &pHwAddr->FifoAddress;
        TR_WARN(("%s %d.%d.%d.%d --> FIFO %02lx-%02lx-%02lx-%02lx-%02lx-%02lx-%02lx-%02lx.\n",
                szPrefix,
                ((PUCHAR)(&IpAddress))[0],
                ((PUCHAR)(&IpAddress))[1],
                ((PUCHAR)(&IpAddress))[2],
                ((PUCHAR)(&IpAddress))[3],
            puc[0], puc[1], puc[2], puc[3],
            puc[4], puc[5], puc[6], puc[7]));
    }
    else if (pHwAddr->AddressType ==  NIC1394AddressType_Channel)
    {
        TR_WARN(("%s %d.%d.%d.%d --> CHANNEL %d.\n",
                szPrefix,
                ((PUCHAR)(&IpAddress))[0],
                ((PUCHAR)(&IpAddress))[1],
                ((PUCHAR)(&IpAddress))[2],
                ((PUCHAR)(&IpAddress))[3],
                pHwAddr->Channel));
    }
    else
    {
        TR_WARN(("%s %d.%d.%d.%d --> Special dest 0x%08lx.\n",
                szPrefix,
                ((PUCHAR)(&IpAddress))[0],
                ((PUCHAR)(&IpAddress))[1],
                ((PUCHAR)(&IpAddress))[2],
                ((PUCHAR)(&IpAddress))[3],
                pHwAddr->Channel));
    }
    EXIT()
}
#endif // DBG


PRM_OBJECT_HEADER
arpRemoteDestCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARPCB_REMOTE_IP.

Arguments:

    pParentObject   - Actually a pointer to the interface (ARP1394_INTERFACE)
    pCreateParams   - Actually the IP address (not a pointer to the IP address)
                      to associate with this remote IP object.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ENTER ("arpRemoteDestCreate", 0xa896311a)
    ARPCB_REMOTE_IP *pRemoteIp;
    PRM_OBJECT_HEADER pHdr;
    PREMOTE_DEST_KEY pKey = (PREMOTE_DEST_KEY)pCreateParams;
    NDIS_STATUS Status;

    Status = ARP_ALLOCSTRUCT(pRemoteIp, MTAG_REMOTE_IP);

    if (Status != NDIS_STATUS_SUCCESS || pRemoteIp == NULL)
    {
        return NULL;
    }
    
    ARP_ZEROSTRUCT(pRemoteIp);

    pHdr = (PRM_OBJECT_HEADER) pRemoteIp;
    ASSERT(pHdr == &pRemoteIp->Hdr);

    // We expect the parent object to be the IF object!
    //
    ASSERT(pParentObject->Sig == MTAG_INTERFACE);
    

    if (pHdr)
    {
        RmInitializeHeader(
            pParentObject,
            pHdr,
            MTAG_REMOTE_IP,
            pParentObject->pLock,
            &ArpGlobal_RemoteIpStaticInfo,
            NULL, // szDescription
            pSR
            );

    TR_INFO( ("New RemoteDest Key %x %x %x %x %x %x \n",
                pKey->ENetAddress.addr[0],
                pKey->ENetAddress.addr[1],
                pKey->ENetAddress.addr[2],
                pKey->ENetAddress.addr[3],
                pKey->ENetAddress.addr[4],
                pKey->ENetAddress.addr[5]));
  
        // set up the remote key 
        REMOTE_DEST_KEY_INIT(&pRemoteIp->Key);
        pRemoteIp->Key = *((PREMOTE_DEST_KEY) pCreateParams); 
        pRemoteIp->IpAddress = ((PREMOTE_DEST_KEY) pCreateParams)->IpAddress;
        
        // Initialize  various other stuff...
        InitializeListHead(&pRemoteIp->sendinfo.listSendPkts);

        if ((IS_REMOTE_DEST_IP_ADDRESS(&pRemoteIp->Key) == TRUE) &&
               arpCanTryMcap(pRemoteIp->IpAddress))
        {
            SET_REMOTEIP_MCAP(pRemoteIp,  ARPREMOTEIP_MCAP_CAPABLE);
        }
    }

    EXIT()
    return pHdr;
}




VOID
arpRemoteDestDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        )
/*++

Routine Description:

    Free an object of type ARPCB_REMOTE_IP.

Arguments:

    pHdr    - Actually a pointer to the remote ip object to be freed.

--*/
{
    ARPCB_REMOTE_IP *pRemoteIp = (ARPCB_REMOTE_IP *) pHdr;
    ASSERT(pRemoteIp->Hdr.Sig == MTAG_REMOTE_IP);
    pRemoteIp->Hdr.Sig = MTAG_FREED;

    ARP_FREE(pHdr);

}



// Enum function
//
INT
arpMaintainArpCache(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
#if 0
    for each RIP send VC
        if !marked dirty
            mark dirty
            if linked to channel pdest
            check if channel is still mapped to group
            if not, unlink.
            if required initiate link to new pdest (possibly channel)
        else
            //expired
            unlink from pdest and get rid of it
#endif // 0
{
    ENTER("arpMaintainArpCache", 0xefc55765)
    NDIS_STATUS         Status;
    PARPCB_REMOTE_IP    pRemoteIp;
    PARP1394_INTERFACE  pIF;


    pRemoteIp   = (PARPCB_REMOTE_IP) pHdr;
    pIF         = IF_FROM_LOCALIP(pRemoteIp);

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        IP_ADDRESS          IpAddr;
        UINT                Channel;
        ARP_DEST_PARAMS     DestParams;
        ARPCB_DEST          *pDest;
        BOOLEAN             AcquireChannel;
        UINT                CurrentTime = arpGetSystemTime();
        UINT                TimeSinceLastCheck;  
        IpAddr      = pRemoteIp->Key.IpAddress;

        #define ARP_PURGE_REMOTEIP_TIME 300 // Arp entry timeout.
        #define ARP_REFRESH_REMOTEIP_TIME ARP_PURGE_REMOTEIP_TIME - 60 // Arp Refresh time

        TimeSinceLastCheck = CurrentTime - pRemoteIp->sendinfo.TimeLastChecked ;
        //
        // NOTE: we don't bother to get the lock with dealing with
        // sendinfo.TimeLastChecked -- this is ok.
        //
        if (pRemoteIp->sendinfo.TimeLastChecked==0)
        {

            if (CHECK_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_DYNAMIC)
                || CHECK_REMOTEIP_RESOLVE_STATE (pRemoteIp, ARPREMOTEIP_UNRESOLVED))
            {
                // Set this field to the current time. It will be cleared back to 0
                // when the next packet is sent to this remote ip.
                //
                pRemoteIp->sendinfo.TimeLastChecked = CurrentTime;
            }
        }
        else if (TimeSinceLastCheck >= ARP_REFRESH_REMOTEIP_TIME &&
                TimeSinceLastCheck <= ARP_PURGE_REMOTEIP_TIME)
        {
            arpRefreshArpEntry(pRemoteIp, pSR);
        } 
        else  if (TimeSinceLastCheck >= ARP_PURGE_REMOTEIP_TIME) 
        {
            // 
            // We should clean up this remote ip.
            //
            arpDeinitRemoteIp(pRemoteIp, pSR);
            break;
        }

#if ARP_ENABLE_MCAP_SEND

        //
        // We'll now see if we need to re-set which destination this
        // pRemoteIp points to.
        //

        // Skip if we can't do MCAP on this address.
        //
        LOCKOBJ(pRemoteIp, pSR);
        if (!CHECK_REMOTEIP_MCAP(pRemoteIp, ARPREMOTEIP_MCAP_CAPABLE))
        {
            UNLOCKOBJ(pRemoteIp, pSR);
            break;
        }
        UNLOCKOBJ(pRemoteIp, pSR);

        //
        // Find a channel mapping to this address, if any.
        //
        Channel = arpFindAssignedChannel(
                        pIF, 
                        pRemoteIp->Key.IpAddress,
                        0,
                        pSR
                        );
        
        //
        // NOTE: Special return value NIC1394_BROADCAST_CHANNEL is returned if
        // this address is mapped to no specific channel.
        //

        AcquireChannel = FALSE;

    
    #if 0   // Let's not enable this just yet -- instead 

        if (Channel == NIC1394_BROADCAST_CHANNEL)
        {
            //
            // Hmm... let's get aggressive and try to grab a channel.
            //
            Channel = arpFindFreeChannel(pIF, pSR);
            if (Channel != NIC1394_BROADCAST_CHANNEL)
            {
                //
                // Got one!
                //
                AcquireChannel = TRUE;
            }
        }
        else
        {
            //
            // There is already a channel allocated by someone to be used
            // for this ip address. Let's use it.
            //
        }
    #endif // 0 
    
        ARP_ZEROSTRUCT(&DestParams);
        DestParams.HwAddr.AddressType =  NIC1394AddressType_Channel;
        DestParams.HwAddr.Channel =  Channel;
        DestParams.AcquireChannel =  AcquireChannel;

        arpUpdateRemoteIpDest(pIF, pRemoteIp, &DestParams, pSR);

#endif //  ARP_ENABLE_MCAP_SEND

    } while (FALSE);
    
    RM_ASSERT_NOLOCKS(pSR)

    return TRUE; // Continue to enumerate.
}



VOID 
arpRefreshArpEntry(
    PARPCB_REMOTE_IP pRemoteIp,
    PRM_STACK_RECORD pSR
    )
{
    ENTER("arpRefreshArpEntry",0x2e19af0b)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    PRM_TASK pTask = NULL;

    do
    {
        PUCHAR pIpAddress;
        //
        // We do not refresh Ip addresses ending in 0xff because they are broadcast
        // packets and we are only concernetd with maintaining unicast destinations
        //
        pIpAddress = (PUCHAR)&pRemoteIp->IpAddress;
        
        if (pIpAddress[3] == 0xff)
        {
            break;
        }
        
        //
        // We do not need to hold the lock as we are gauranteed that only one instance 
        // of the original timer function is going to fire. By implication, all calls to 
        // this function are serialized
        //
        if (pRemoteIp->pResolutionTask != NULL)
        {
            // There is already another task trying to resolve this Ip Address
            // so exit
            break;
        }
        
        

        Status = arpAllocateTask(
                    &pRemoteIp->Hdr,               // pParentObject,
                    arpTaskResolveIpAddress,     // pfnHandler,
                    0,                              // Timeout
                    "Task: ResolveIpAddress",       // szDescription
                    &pTask,
                    pSR
                    );

        if (FAIL(Status))
        {
            pTask = NULL;
            break;
        }

        RmStartTask (pTask,0,pSR);

    }while (FALSE);

    EXIT()
}




NDIS_STATUS
arpTaskUnloadEthDhcpEntry(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
    This task is responsible for shuttingdown and eventually deleting a Dhcp Entry

    It goes through the following stages:
        simply calls RmFreeObject in Group as there is no asynchronous unload work to be done.
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskUnloadRemoteEth", 0xf42aaa68)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARP1394_ETH_DHCP_ENTRY *   pDhcpEntry = (ARP1394_ETH_DHCP_ENTRY*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE *pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pDhcpEntry );

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OtherUnloadComplete
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pDhcpEntry, pSR);

            // First check if pDhcpEntry is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pDhcpEntry))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // pDhcpEntry is allocated. Now check if there is already a
            // shutdown task attached to pDhcpEntry.
            //
            if (pDhcpEntry ->pUnloadTask != NULL)
            {
                //
                // There is a shutdown task. We pend on it.
                //

                PRM_TASK pOtherTask = pDhcpEntry->pUnloadTask;
                TR_WARN(("Unload task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pDhcpEntry , pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherUnloadComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no unload task going on. Let's
            // make this task THE unload task.
            // 
            pDhcpEntry->pUnloadTask = pTask;

            //
            // Since we're THE unload task, add an association to pDhcpEntry,
            // which will only get cleared when the  pDhcpEntry->pUnloadTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pDhcpEntry->Hdr,                   // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_ETHDHCP_UNLOAD_TASK,     // AssociationID
                "    Official unload task 0x%p (%s)\n", // szFormat
                pSR
                );

            //
            // We're here because there is no async unload work to be done.
            // We simply return and finish synchronous cleanup in the END
            // handler for this task.
            //
            Status = NDIS_STATUS_SUCCESS;
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OtherUnloadComplete:
                {
        
                    //
                    // There was another unload task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    // TODO need standard way to propagate the error code.
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pDhcpEntry, pSR);

            //
            // We're done. There should be no async activities left to do.
            //

            //
            // If we're THE unload task, we go on and deallocate the object.
            //
            if (pDhcpEntry ->pUnloadTask == pTask)
            {
                //
                // pDhcpEntry had better not be in a zombie state -- THIS task
                // is the one responsible for deallocating the object!
                //
                ASSERTEX(!RM_IS_ZOMBIE(pDhcpEntry ), pDhcpEntry );

                pDhcpEntry ->pUnloadTask = NULL;

                RmFreeObjectInGroup(
                    &pIF->EthDhcpGroup,
                    &(pDhcpEntry ->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );

                ASSERTEX(RM_IS_ZOMBIE(pDhcpEntry ), pDhcpEntry );
                     
                // Delete the association we added when we set
                // pDhcpEntry->pUnloadTask to pTask.
                //
                DBG_DELASSOC(
                    &pDhcpEntry ->Hdr,                   // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_ETHDHCP_UNLOAD_TASK,     // AssociationID
                    pSR
                    );

                UNLOCKOBJ(pDhcpEntry, pSR);

            }
            else
            {
                //
                // We weren't THE unload task, nothing left to do.
                // The object had better be in the zombie state..
                //

                ASSERTEX(
                    pDhcpEntry->pUnloadTask == NULL && RM_IS_ZOMBIE(pDhcpEntry),
                    pDhcpEntry
                    );
                Status = NDIS_STATUS_SUCCESS;
            }

            Status = (NDIS_STATUS) UserParam;
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\kdext\util.h ===
#define  MYASSERT(_cond) \
            ((_cond) ?  0 : MyDbgPrintf("ASSERTION FAILED\n"))


typedef int bool;


//
// Debugger Extension Primitives
//


bool
dbgextReadMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    );

bool
dbgextReadUINT(
    UINT_PTR uOffset,
    UINT *pu,
    char *pszDescription
    );

bool
dbgextReadUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR *pu,
    char *pszDescription
    );

bool
dbgextReadSZ(
    UINT_PTR uOffset,
    char *szBuf,
    UINT	cbMax,
    char *pszDescription
    );

bool
dbgextWriteMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    );

bool
dbgextWriteUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR u,
    char *pszDescription
    );


UINT_PTR
dbgextGetExpression(
    const char *pcszExpression
    );


#if 0   // Not sure what this one is about...
void 
dbgextGetSymbol(
    void *offset,
    UCHAR *pchBuffer,
    UINT  *pDisplacement
    );
#endif // 0

void
dbgextDumpDLlist(
	UINT_PTR uOffset,
	UINT	uContainingOffset,
	char 	*pszDescription
	);


typedef
void
(__cdecl *MYPWINDBG_OUTPUT_ROUTINE)(
    const char * lpFormat,
    ...
    );

extern MYPWINDBG_OUTPUT_ROUTINE g_pfnDbgPrintf;

#define MyDbgPrintf g_pfnDbgPrintf


//
//  User Commands Parsing Support and Structures
//
typedef struct
{
    //TOKEN tokCmd;
    UINT uParam;
    UINT uFlags;

} COMMAND;

struct _TYPE_INFO;

typedef
void
(*PFN_SPECIALIZED_DUMP)(
		struct _TYPE_INFO *pType,
		UINT_PTR uAddr,
		char *szFieldSpec,
		UINT uFlags
		);
#define fDUMP_ONE_LINE_SUMMARY (0x1)

typedef struct
{
	char *szName;
	UINT Mask;
	UINT Value;

} BITFIELD_INFO;


typedef struct _TYPE_INFO
{
    const char *	szName;
    const char *	szShortName;
    UINT 			uTypeID;
    UINT 			uFlags;		// One or more fTYPEINFO_ flags.
    UINT 			cbSize;

    struct _STRUCT_FIELD_INFO *rgFields;

    UINT 			uNextOffset;
					// If this type is a list element, this is the offset
					// in bytes to the next pointer.
					// Only valid if uFlags contains fTYPEINFO_ISLIST
					
    BITFIELD_INFO	*rgBitFieldInfo;
    				//
    				// If this type is a bitfield, this this points
    				// to an array of BITFIELD_INFO structs, giving
    				// the set of valid bitfield constants that can
    				// be held in this bitfield.
    				//
    				// Note -- only one of rgFields and rgBitField info
    				// 		   should be non-null (both can be null).
    				//

	PFN_SPECIALIZED_DUMP		pfnSpecializedDump;
					//
					// If nonzero, use this function instead of the standard
					// structure dumping routine.
					//

	UINT_PTR		uCachedAddress; // Set to the address of this type that
									// was most recently referenced.



} TYPE_INFO;



#define fTYPEINFO_ISLIST     (0x1<<0)
#define fTYPEINFO_ISBITFIELD (0x1<<1)

#define TYPEISLIST(_pType) 		((_pType)->uFlags & fTYPEINFO_ISLIST)
#define TYPEISBITFIELD(_pType) 	((_pType)->uFlags & fTYPEINFO_ISBITFIELD)

//
// STRUCT_FIELD_INFO contains information about a particular field of a struct.
//
typedef struct _STRUCT_FIELD_INFO
{
    const char *szFieldName;
    UINT uFieldOffset; // Offset in bytes from start of containing structure.
    UINT uFieldSize;
    UINT uFlags;  // one or more fFI_* flags define below
    TYPE_INFO *pBaseType;

} STRUCT_FIELD_INFO;


#define fFI_PTR     (0x1<<0)    // Field is a pointer
#define fFI_LIST    (0x1<<1)    // Field is a pointer to 1st element of a list
#define fFI_ARRAY   (0x1<<2)    // Field is an array (pointer to array if 
                                // fFI_PTR is set). 
#define fFI_OPAQUE  (0x1<<3)    // Treat object as opaque, of size uObjectSize.
                                // If set then fLIST must not be set.

#define FIELD_IS_EMBEDDED_TYPE(_pFI)  \
				(   !((_pFI)->uFlags & (fFI_PTR|fFI_OPAQUE|fFI_ARRAY)) \
				 && ((_pFI)->pBaseType))
		//
		//	true iff the field is itself a valid type
		//

#define FIELD_IS_PTR_TO_TYPE(_pFI)  \
				(   ((_pFI)->uFlags & fFI_PTR) \
				 && !((_pFI)->uFlags & (fFI_OPAQUE|fFI_ARRAY)) \
				 && ((_pFI)->pBaseType))
		//
		//	true iff the field is pointer to a valid type
		//

#define FIELD_SIZE(type, field)  sizeof(((type *)0)->field)

//
// Information about a global variable.
//
typedef struct
{
    const char *szName; // of variable.
    const char *szShortName;
    TYPE_INFO  *pBaseType;  // could be null (unspecified).
    UINT       uFlags;
    UINT       cbSize;
    UINT_PTR   uAddr;       // Address in debuggee's address space.
    
} GLOBALVAR_INFO;


typedef
UINT_PTR
(*PFN_RESOLVE_ADDRESS)(
				TYPE_INFO *pType
				);

typedef struct
{
	TYPE_INFO	**pTypes;
	GLOBALVAR_INFO *pGlobals;
	PFN_RESOLVE_ADDRESS pfnResolveAddress;

} NAMESPACE;

void
DumpObjects(TYPE_INFO *pType, UINT_PTR uAddr, UINT cObjects, UINT uFlags);

#define fMATCH_SUBSTRING (0x1<<0)
#define fMATCH_PREFIX    (0x1<<1)
#define fMATCH_SUFFIX    (0x1<<2)

void
DumpStructure(
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    char *szFieldSpec,
    UINT uFlags
    );

bool
DumpMemory(
    UINT_PTR uAddr,
    UINT cb,
    UINT uFlags,
    const char *pszDescription
    );

typedef bool (*PFNMATCHINGFUNCTION) (
                    const char *szPattern,
                    const char *szString
                    );

bool
MatchPrefix(const char *szPattern, const char *szString);

bool
MatchSuffix(const char *szPattern, const char *szString);

bool
MatchSubstring(const char *szPattern, const char *szString);

bool
MatchExactly(const char *szPattern, const char *szString);

bool
MatchAlways(const char *szPattern, const char *szString);

typedef ULONG (*PFNNODEFUNC)(
				UINT_PTR uNodeAddr,
				UINT uIndex,
				void *pvContext
				);
//
//	 PFNNODEFUNC is the prototype of the func passed into WalkList
//


UINT
WalkList(
	UINT_PTR uStartAddress,
	UINT uNextOffset,
	UINT uStartIndex,
	UINT uEndIndex,
	void *pvContext,
	PFNNODEFUNC pFunc,
	char *pszDescription
	);
//
// Visit each node in the list in turn,
// reading just the next pointers. It calls pFunc for each list node
// between uStartIndex and uEndIndex. It terminates under the first of
// the following conditions:
// 	* Null pointer
// 	* ReadMemoryError
// 	* Read past uEndIndex
// 	* pFunc returns FALSE
//

void
WalkDLlist(
	UINT_PTR uOffsetHeadList,
	UINT_PTR uOffsetStartLink,	OPTIONAL
	void *pvContext,
	PFNNODEFUNC pFunc,
	UINT	MaxToWalk,
	char *pszDescription
	);

ULONG
NodeFunc_DumpAddress (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	);
//
//	This is a sample node function -- simply dumps the specfied address.
//


void
DumpBitFields(
		ULONG  			Flags,
    	BITFIELD_INFO	rgBitFieldInfo[]
		);
// Dump bitfield info.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\dbg.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    dbg.c   ARP1394 Debugging Code

Abstract:

    NT System entry points for ARP1394.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     12-02-98    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_DBG

INT   g_DiscardNonUnicastPackets;
INT g_SkipAll;

#if DBG

ULONG g_ulTraceMask = 0xffffffff;

#define DEFAULT_TRACE_LEVEL TL_FATAL    


INT g_ulTraceLevel = DEFAULT_TRACE_LEVEL;

void
DbgMark(UINT Luid)
{
    // do nothing useful, but do something specific, so that the compiler doesn't
    // alias DbgMark to some other function that happens to do nothing.
    //
    static int i;
    i=Luid;
}

LONG g_MaxReentrancy = 5;
LONG g_MaxGlobalReentrancy = 10;
LONG g_ReentrancyCount=1;

VOID
arpDbgIncrementReentrancy(
    PLONG pReentrancyCount
    )
{
    LONG Count;

    Count = NdisInterlockedIncrement(pReentrancyCount);
    if (Count > (g_MaxReentrancy+1))
    {
#if MILLEN
        DbgBreakPoint();
#endif      
        NdisInterlockedIncrement(&g_MaxReentrancy);
    }

    Count = NdisInterlockedIncrement(&g_ReentrancyCount);
    if (Count > (g_MaxGlobalReentrancy+1))
    {
#if MILLEN
        DbgBreakPoint();
#endif
        NdisInterlockedIncrement(&g_MaxGlobalReentrancy);
    }
}

VOID
arpDbgDecrementReentrancy(
    PLONG pReentrancyCount
    )
{
    LONG Count;
    Count = NdisInterlockedDecrement(pReentrancyCount);
    if (Count<0) 
    {
#if MILLEN
        DbgBreakPoint();
#endif
    }

    Count = NdisInterlockedDecrement(&g_ReentrancyCount);
    if (Count<0) 
    {
#if MILLEN  
        DbgBreakPoint();
#endif      
    }
}
    
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\dbg.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    Debug-related definitions for ARP1394

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     11-20-98    created, adapted from L2TP.

--*/



//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

// Memory tags used with NdisAllocateMemoryWithTag to identify allocations
// made by the L2TP driver.  Also, several context blocks define a first field
// of 'ulTag' set to these values for ASSERT sanity checking and eased memory
// dump browsing.  Such tags are set to MTAG_FREED just before NdisFreeMemory
// is called.
//

// Rm/generic tags
// 
#define MTAG_DBGINFO    'd31A'
#define MTAG_TASK       't31A'
#define MTAG_STRING     's31A'
#define MTAG_FREED      'z31A'
#define MTAG_RMINTERNAL 'r31A'

// Arp-sepcific
//
#define MTAG_ADAPTER    'A31A'
#define MTAG_INTERFACE  'I31A'
#define MTAG_LOCAL_IP   'L31A'
#define MTAG_REMOTE_IP  'R31A'
#define MTAG_REMOTE_ETH 'E31A'
#define MTAG_DEST       'D31A'
#define MTAG_PKT        'P31A'
#define MTAG_MCAP_GD    'G31A'
#define MTAG_ICS_BUF    'i31A'
#define MTAG_ARP_GENERIC 'g31A'


// Trace levels.
//
#define TL_FATAL    0x0 // Fatal errors -- always printed in checked build.
#define TL_WARN     0x1 // Warnings
#define TL_INFO     0x2 // Informational (highest level workable for general use)
#define TL_VERB     0x3 // VERBOSE

// Trace mask bits.
//
#define TM_MISC     (0x1<<0)    // Misc.
#define TM_NT       (0x1<<1)    // Driver entry, dispatch, ioctl handling   (nt.c)
#define TM_ND       (0x1<<2)    // Ndis handlers except connection-oriented (nd.c)
#define TM_CO       (0x1<<3)    // Connection-oriented handlers             (co.c)
#define TM_IP       (0x1<<4)    // Interface to IP                          (ip.c)
#define TM_WMI      (0x1<<5)    // WMI                                      (wmi.c)
#define TM_CFG      (0x1<<6)    // Configuration                            (cfg.c)
#define TM_RM       (0x1<<7)    // RM APIs                                  (rm.c)
#define TM_UT       (0x1<<8)    // UTIL APIs                                (util.c)
#define TM_BUF      (0x1<<9)    // Buffer management                        (buf.c)
#define TM_FAKE     (0x1<<10)   // FAKE ndis and ip entrypoints             (fake.c)
#define TM_ARP      (0x1<<11)   // ARP request/response handling code       (arp.c)
#define TM_PKT      (0x1<<12)   // ARP control packet management            (pkt.c)
#define TM_MCAP     (0x1<<13)   // MCAP protocol                            (mcap.c)
#define TM_ETH      (0x1<<14)   // Ethernet-emulation                       (eth.c)

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16


//-----------------------------------------------------------------------------
// Debug global declarations (defined in debug.c)
//-----------------------------------------------------------------------------

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' and from
// any (TM_*) set(s) present in 'g_ulTraceMask' are displayed.
//
extern INT      g_ulTraceLevel;
extern ULONG    g_ulTraceMask;
extern INT      g_SkipAll;
extern INT      g_DiscardNonUnicastPackets;


//-----------------------------------------------------------------------------
// Debug macros
//-----------------------------------------------------------------------------

#if DBG

// TRACE sends printf style output to the kernel debugger.  Caller indicates a
// "verbosity" level with the 'ulLevel' argument and associates the trace with
// one or more trace sets with the 'ulMask' bit mask argument.  Notice that
// the variable count printf arguments 'Args' must be parenthesized.
//
#define TRACE(ulLevel,  Args)                               \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & TM_CURRENT)) \
    {                                                          \
        DbgPrint( "A13: %s:", dbg_func_name);                  \
        DbgPrint Args;                                         \
    }                                                          \
}

// TRACE0 is like TRACE, except that it doesn't print the prefix.
//
#define TRACE0(ulLevel,  Args)                              \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & TM_CURRENT)) \
    {                                                          \
        DbgPrint Args;                                         \
    }                                                          \
}

#define TR_FATAL(Args)                                         \
    TRACE(TL_FATAL, Args)

#define TR_INFO(Args)                                          \
    TRACE(TL_INFO, Args)

#define TR_WARN(Args)                                          \
    TRACE(TL_WARN, Args)

#define TR_VERB(Args)                                          \
    TRACE(TL_VERB, Args)

#define ENTER(_Name, _locid)                                    \
    char *dbg_func_name =  (_Name);                             \
    UINT dbg_func_locid = (_locid);
    
#define EXIT()


// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                               \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "A13: !ASSERT( %s ) L:%d,F:%s\n",             \
            #x, __LINE__, __FILE__ );                           \
        DbgBreakPoint();                                        \
    }                                                           \
}

#define ASSERTEX(x, ctxt)                                       \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "A13: !ASSERT( %s ) C:0x%p L:%d,F:%s\n",      \
            #x, (ctxt), __LINE__, __FILE__ );                   \
        DbgBreakPoint();                                        \
    }                                                           \
}

// DUMP prints to the kernel debugger a hex dump of 'cb' bytes starting at 'p'
// in groups of 'ul'.  If 'f' is set the address of each line in shown before
// the dump.  DUMPB, DUMPW, and DUMPDW are BYTE, WORD, and DWORD dumps
// respectively.  Note that the multi-byte dumps do not reflect little-endian
// (Intel) byte order.  The 'ulLevel' and 'ulMask' are described for TRACE.
//
#define DUMP(ulLevel,ulMask,p,cb,f,ul)                         \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, f, ul );                          \
    }                                                          \
}

#define DUMPB(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 1 );                           \
    }                                                          \
}

#define DUMPW(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 2 );                           \
    }                                                          \
}

#define DUMPDW(ulLevel,ulMask,p,cb)                            \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 4 );                           \
    }                                                          \
}

// DbgMark does nothing useful. But it is convenient to insert DBGMARK in
// places in your code while debugging, and set a breakpoint on DbgMark, so that
// the debugger will stop at the places you inserted DBGMARK. It's a bit more
// flexible than inserting a hardcoded DbgBreakPoint.
//
void DbgMark(UINT Luid);
#define DBGMARK(_Luid) DbgMark(_Luid)


#define DBGSTMT(_stmt)      _stmt

#define RETAILASSERTEX ASSERTEX
#define RETAILASSERT   ASSERT

#define ARP_INIT_REENTRANCY_COUNT() \
    static LONG ReentrancyCount=1;
    
#define ARP_INC_REENTRANCY() \
    arpDbgIncrementReentrancy(&ReentrancyCount)
    
#define ARP_DEC_REENTRANCY() \
    arpDbgDecrementReentrancy(&ReentrancyCount)

#else // !DBG

// Debug macros compile out of non-DBG builds.
//
#define TRACE(ulLevel,ulMask,Args)
#define TR_FATAL(Args)
#define TR_INFO(Args)
#define TR_WARN(Args)
#define TR_VERB(Args)
#undef ASSERT
#define ASSERT(x)
#define ASSERTEX(x, ctxt)
#define DUMP(ulLevel,ulMask,p,cb,f,dw)
#define DUMPB(ulLevel,ulMask,p,cb)
#define DUMPW(ulLevel,ulMask,p,cb)
#define DUMPDW(ulLevel,ulMask,p,cb)
#define ENTER(_Name, _locid)
#define EXIT()
#define DBGMARK(_Luid) (0)
#define DBGSTMT(_stmt)

#if 1
    #define ARP_INIT_REENTRANCY_COUNT()
    #define ARP_INC_REENTRANCY() 0
    #define ARP_DEC_REENTRANCY() 0

#else // !0

    #define ARP_INIT_REENTRANCY_COUNT() \
        static LONG ReentrancyCount=1;
        
    #define ARP_INC_REENTRANCY() \
        arpDbgIncrementReentrancy(&ReentrancyCount)
        
    #define ARP_DEC_REENTRANCY() \
        arpDbgDecrementReentrancy(&ReentrancyCount)
#endif // 0

#define RETAILASSERT(x)                                         \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "A13: !RETAILASSERT( %s ) L:%d,F:%s\n",       \
            #x, __LINE__, __FILE__ );                           \
        DbgBreakPoint();                                        \
    }                                                           \
}

#define RETAILASSERTEX(x, ctxt)                                 \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "A13: !RETAILASSERT( %s ) C:0x%p L:%d,F:%s\n",\
            #x, (ctxt), __LINE__, __FILE__ );                   \
        DbgBreakPoint();                                        \
    }                                                           \
}

#endif



#if BINARY_COMPATIBLE
#define         ASSERT_PASSIVE() (0)
#else // !BINARY_COMPATIBLE
#define     ASSERT_PASSIVE() \
                ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL)
            
#endif // !BINARY_COMPATIBLE
//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\eth.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    eth.c

Abstract:

    ARP1394 Ethernet emulation-related handlers.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     11-22-99    Created
    Adube      10-2000     Added Bridging

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_ETH


UINT Arp1394ToIcs = 0;

//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================


// These are ethernet arp specific  constants
//
#define ARP_ETH_ETYPE_IP    0x800
#define ARP_ETH_ETYPE_ARP   0x806
#define ARP_ETH_REQUEST     1
#define ARP_ETH_RESPONSE    2
#define ARP_ETH_HW_ENET     1
#define ARP_ETH_HW_802      6


//
// Check whether an address is multicast
//
#define ETH_IS_MULTICAST(Address) \
        (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x01))


//
// Check whether an address is broadcast.
//
#define ETH_IS_BROADCAST(Address)               \
    ((((PUCHAR)(Address))[0] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[1] == ((UCHAR)0xff)))


#pragma pack (push, 1)

//* Structure of an Ethernet header (taken from ip\arpdef.h).
typedef struct  ENetHeader {
    ENetAddr    eh_daddr;
    ENetAddr    eh_saddr;
    USHORT      eh_type;
} ENetHeader;

const ENetAddr BroadcastENetAddr = 
{
    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
};

// Following is a template for creating Ethernet Multicast addresses
// from ip multicast addresses.
// The last 3 bytes are the last 3 bytes (network byte order) of the mcast
// address.
//
const ENetAddr MulticastENetAddr =
{
    {0x01,0x00,0x5E,0x00, 0x00, 0x00}
};

//
// This is the Ethernet address to which the bridge sends STA packets.
// STA packets are used by the bridge to detect loops
//

// Size of a basic UDP header
#define SIZE_OF_UDP_HEADER          8       // bytes

// Minimum size of the payload of a BOOTP packet
#define SIZE_OF_BASIC_BOOTP_PACKET  236     // bytes


// The UDP IP protocol type
#define UDP_PROTOCOL          0x11

// Size of Ethernet header
#define ETHERNET_HEADER_SIZE (ETH_LENGTH_OF_ADDRESS * 2 ) + 2



UCHAR gSTAMacAddr[ETH_LENGTH_OF_ADDRESS] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x00 };

#define NIC1394_ETHERTYPE_STA 0x777
const
NIC1394_ENCAPSULATION_HEADER
Arp1394_StaEncapHeader =
{
    0x0000,     // Reserved
    H2N_USHORT(NIC1394_ETHERTYPE_STA)
};

// Structure of an Ethernet ARP packet.
//
typedef struct {
    ENetHeader  header;
    USHORT      hardware_type; 
    USHORT      protocol_type;
    UCHAR       hw_addr_len;
    UCHAR       IP_addr_len; 
    USHORT      opcode;                  // Opcode.
    ENetAddr    sender_hw_address;
    IP_ADDRESS  sender_IP_address;
    ENetAddr    target_hw_address;
    IP_ADDRESS  target_IP_address;

} ETH_ARP_PKT, *PETH_ARP_PKT;

#pragma pack (pop)

// Parsed version of an ethernet ARP packet.
//
typedef struct {

    ENetAddr        SourceEthAddress;   // Ethernet source h/w address.
    ENetAddr        DestEthAddress;     // Ethernet source h/w address.

    UINT            OpCode; // ARP_ETH_REQUEST/RESPONSE

    ENetAddr        SenderEthAddress;   // Ethernet source h/w address.
    IP_ADDRESS      SenderIpAddress;    // IP source address

    ENetAddr        TargetEthAddress;   // Ethernet destination h/w address.
    IP_ADDRESS      TargetIpAddress;    // IP target address

} ETH_ARP_PKT_INFO, *PETH_ARP_PKT_INFO;




#define ARP_FAKE_ETH_ADDRESS(_AdapterNum)                   \
        {                                                   \
            0x02 | (((UCHAR)(_AdapterNum) & 0x3f) << 2),    \
            ((UCHAR)(_AdapterNum) & 0x3f),                  \
            0,0,0,0                                         \
        }

#define ARP_DEF_REMOTE_ETH_ADDRESS \
                ARP_FAKE_ETH_ADDRESS(0xf)


#define  ARP_IS_BOOTP_REQUEST(_pData)  (_pData[0] == 0x1)      // Byte 0 is the operation; 1 for a request, 2 for a reply
#define  ARP_IS_BOOTP_RESPONSE(_pData)  (_pData[0] == 0x2)      // Byte 0 is the operation; 1 for a request, 2 for a reply


typedef struct _ARP_BOOTP_INFO 
{
    
    ULONG Xid;
    
    BOOLEAN bIsRequest;    

    ENetAddr requestorMAC;


} ARP_BOOTP_INFO , *PARP_BOOTP_INFO; 




NDIS_STATUS
arpIcsTranslateIpPkt(
    IN  PARP1394_INTERFACE          pIF,
    IN  PNDIS_PACKET                pOrigPkt, 
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  MYBOOL                      fUnicast,
    OUT PNDIS_PACKET                *ppNewPkt,
    OUT PREMOTE_DEST_KEY            pDestAddress, // OPTIONAL
    PRM_STACK_RECORD                pSR
    );

NDIS_STATUS
arpGetEthHeaderFrom1394IpPkt(
    IN  PARP1394_INTERFACE  pIF,
    IN  PVOID               pvData,
    IN  UINT                cbData,
    IN  MYBOOL              fUnicast,
    OUT ENetHeader          *pEthHdr,
    OUT PIP_ADDRESS         pDestIpAddress, // OPTIONAL
    PRM_STACK_RECORD        pSR
    );

NDIS_STATUS
arpGet1394HeaderFromEthIpPkt(
    IN  PARP1394_INTERFACE  pIF,
    IN  PNDIS_BUFFER        pFirstBuffer,
    IN  PVOID               pvData,
    IN  UINT                cbData,
    IN  MYBOOL              fUnicast,
    OUT NIC1394_ENCAPSULATION_HEADER
                            *p1394Hdr,
    OUT PREMOTE_DEST_KEY     pDestIpAddress, // OPTIONAL
    PRM_STACK_RECORD        pSR
    );

NDIS_STATUS
arpGetEthAddrFromIpAddr(
    IN  PARP1394_INTERFACE  pIF,
    IN  MYBOOL              fUnicast,
    IN  IP_ADDRESS          DestIpAddress,
    OUT ENetAddr            *pEthAddr,
    PRM_STACK_RECORD        pSR
    );

NDIS_STATUS
arpParseEthArpPkt(
    IN   PETH_ARP_PKT     pArpPkt,
    IN   UINT                       cbBufferSize,
    OUT  PETH_ARP_PKT_INFO          pPktInfo
    );

VOID
arpPrepareEthArpPkt(
    IN   PETH_ARP_PKT_INFO          pPktInfo,
    OUT  PETH_ARP_PKT     pArpPkt
    );

MYBOOL
arpIsUnicastEthDest(
    IN   UNALIGNED  ENetHeader   *pEthHdr
    );

VOID
arpEthProcess1394ArpPkt(
    IN  PARP1394_INTERFACE         pIF,
    IN  PIP1394_ARP_PKT pArpPkt,
    IN  UINT                       HeaderSize
    );

VOID
arpEthProcessEthArpPkt(
    IN  PARP1394_INTERFACE      pIF,
    IN  PETH_ARP_PKT  pArpPkt,
    IN  UINT                    HeaderSize
    );

NDIS_STATUS
arpConstructEthArpInfoFrom1394ArpInfo(
    IN  PARP1394_INTERFACE          pIF,
    IN   PIP1394_ARP_PKT_INFO   p1394PktInfo,
    OUT  PETH_ARP_PKT_INFO          pEthPktInfo,
    PRM_STACK_RECORD                pSR
    );

NDIS_STATUS
arpConstruct1394ArpInfoFromEthArpInfo(
    IN  PARP1394_INTERFACE      pIF,
    IN   PETH_ARP_PKT_INFO      pEthPktInfo,
    OUT  PIP1394_ARP_PKT_INFO   p1394PktInfo,
    PRM_STACK_RECORD            pSR
    );

VOID
arpIcsForwardIpPacket(
    IN  PARP1394_INTERFACE  pIF,
    IN  PNDIS_PACKET        pPacket,
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  MYBOOL              fUnicast,
    IN  PRM_STACK_RECORD    pSR
    );

VOID
arpUpdateEthArpCache(
    IN  PARP1394_INTERFACE      pIF,
    IN  IP_ADDRESS              DestIpAddr,
    IN  PARP_REMOTE_ETH_PARAMS  pCreateParams,  // Creation params
    IN  MYBOOL                      fCreateIfRequired,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpGetSourceMacAddressFor1394Pkt (
    IN PARP1394_ADAPTER pAdapter,
    IN UCHAR SourceNodeAddress,
    IN BOOLEAN fIsValidSourceNodeAddress,
    OUT ENetAddr* pSourceMacAddress,
    PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpEthConstructSTAEthHeader(
    IN PUCHAR pvData,
    IN UINT cbData,
    OUT ENetHeader   *pEthHdr
    );

NDIS_STATUS
arpEthModifyBootPPacket(
    IN  PARP1394_INTERFACE          pIF,                // NOLOCKIN NOLOCKOUT
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  PREMOTE_DEST_KEY             pDestAddress, // OPTIONAL
    IN  PUCHAR                       pucNewData,
    IN  ULONG                         PacketLength,
    IN  PRM_STACK_RECORD                pSR
    );

BOOLEAN
arpEthPreprocessBootPPacket(
    IN PARP1394_INTERFACE       pIF,
    IN PUCHAR                   pPacketData,
    IN PUCHAR                   pBootPData,     // Actual BOOTP packet
    OUT PBOOLEAN                pbIsRequest,
    PARP_BOOTP_INFO             pInfoBootP,
    PRM_STACK_RECORD           pSR
    );


VOID
arpIcsForwardIpPacket(
    IN  PARP1394_INTERFACE          pIF,
    IN  PNDIS_PACKET                pPacket,
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  MYBOOL                      fUnicast,
    IN  PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Forward a packet from the ip/1394 side to the ethernet side, or vice-versa.

Arguments:


--*/
{
    NDIS_STATUS         Status;
    PNDIS_PACKET        pNewPkt = NULL;
    ENTER("arpIcsForwardIpPacket", 0x98630e8f)

    do
    {
        PARPCB_DEST pDest = NULL;

        //
        // Create the translated packet.
        //
        Status =  arpIcsTranslateIpPkt(
                    pIF,
                    pPacket,
                    Direction,
                    fUnicast,
                    &pNewPkt,
                    NULL,       // Optional pIpDestAddr
                    pSR
                    );
    
        if (FAIL(Status))
        {
            if (Status == NDIS_STATUS_ALREADY_MAPPED)
            {
                //
                // This is a loop-backed packet.
                //
                arpEthReceivePacket(
                    pIF,
                    pPacket
                    );
            }
            pNewPkt = NULL;
            break;
        }

        // We special case unicast sends to 1394, because that requires
        // special treatment: we need to lookup the destination and if
        // required create a VC to that destination. This
        // is done elsewhere (in arpEthernetReceivePacket), so we assert
        // we never get this this case.
        //
        ASSERT(!(Direction == ARP_ICS_FORWARD_TO_1394 && fUnicast))
        

        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        //
        // Determine destination
        //
        if (Direction ==  ARP_ICS_FORWARD_TO_1394)
        {
            pDest = pIF->pBroadcastDest;
        }
        else    
        {
            ASSERT(Direction ==  ARP_ICS_FORWARD_TO_ETHERNET);
            pDest = pIF->pEthernetDest;
        };

        arpSendControlPkt(
                pIF,            // LOCKIN NOLOCKOUT (IF send lk)
                pNewPkt,
                pDest,
                pSR
                );

    } while (FALSE);

    EXIT()

}


NDIS_STATUS
arpIcsTranslateIpPkt(
    IN  PARP1394_INTERFACE          pIF,                // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET                pOrigPkt, 
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  MYBOOL                      fUnicast,
    OUT PNDIS_PACKET                *ppNewPkt,
    OUT PREMOTE_DEST_KEY             pDestAddress, // OPTIONAL
    PRM_STACK_RECORD                pSR
    )
{

    NDIS_STATUS     Status;
    PNDIS_PACKET    pNewPkt     = NULL;
    PVOID           pvNewData   = NULL;


    do
    {
        PNDIS_BUFFER    pOrigBuf    = NULL;
        PVOID           pvOrigData  = NULL;
        UINT            OrigBufSize;
        PVOID           pvNewHdr    = NULL;
        UINT            OrigHdrSize;
        UINT            NewHdrSize;
        UINT            OrigPktSize;
        UINT            NewPktSize;
        UINT            BytesCopied;
        NIC1394_ENCAPSULATION_HEADER
                        Nic1394Hdr;
        ENetHeader      EthHdr;


        // Get size of 1st buffer and pointer to it's data.
        // (We only bother about the 1st buffer)
        //
        NdisQueryPacket(
                        pOrigPkt,
                        NULL,
                        NULL,
                        &pOrigBuf,
                        &OrigPktSize
                        );
    
    
        if (OrigPktSize > 0)
        {
            NdisQueryBuffer(
                    pOrigBuf,
                    &pvOrigData,
                    &OrigBufSize
                    );
        }
        else
        {
            OrigBufSize = 0;
        }

        if (pvOrigData == NULL)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        // Compute direction-specific information
        //
        if(Direction == ARP_ICS_FORWARD_TO_1394)
        {
            OrigHdrSize = sizeof(EthHdr);
            NewHdrSize  = sizeof(Nic1394Hdr);

            Status = arpGet1394HeaderFromEthIpPkt(
                        pIF,
                        pOrigBuf,
                        pvOrigData,
                        OrigBufSize,
                        fUnicast,
                        &Nic1394Hdr,
                        pDestAddress,
                        pSR
                        );
            pvNewHdr    = (PVOID) &Nic1394Hdr;
        }
        else
        {
            ASSERT(Direction==ARP_ICS_FORWARD_TO_ETHERNET);
            OrigHdrSize = sizeof(Nic1394Hdr);
            NewHdrSize = sizeof(EthHdr);

            Status = arpGetEthHeaderFrom1394IpPkt(
                        pIF,
                        pvOrigData,
                        OrigBufSize,
                        fUnicast,
                        &EthHdr,
                        &pDestAddress->IpAddress,
                        pSR
                        );

            pvNewHdr    = (PVOID) &EthHdr;

        };

        if (FAIL(Status)) break;
    


        // Make sure the 1st buffer contains enough data for the header.
        //
        if (OrigBufSize < OrigHdrSize)
        {
            ASSERT(FALSE);                  // We should check why we're getting
                                            // this kind of tiny 1st buffer.
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        // Compute the new packet size.
        //
        NewPktSize = OrigPktSize - OrigHdrSize + NewHdrSize;

        // Allocate an appropriately sized control packet.
        //
        Status = arpAllocateControlPacket(
                    pIF,
                    NewPktSize,
                    ARP1394_PACKET_FLAGS_ICS,
                    &pNewPkt,
                    &pvNewData,
                    pSR
                    );

        if (FAIL(Status))
        {
            ASSERT(FALSE); // we want to know if we hit this in regular use.
            pNewPkt = NULL;
            break;
        }

        // Copy over the new header.
        //
        NdisMoveMemory(pvNewData, pvNewHdr, NewHdrSize);

        // Copy the rest of the packet contents.
        //
        NdisCopyFromPacketToPacket(
            pNewPkt,                    // Dest pkt
            NewHdrSize,                 // Dest offset
            OrigPktSize - OrigHdrSize,  // BytesToCopy
            pOrigPkt,                   // Source,
            OrigHdrSize,                // SourceOffset
            &BytesCopied
            );
        if (BytesCopied != (OrigPktSize - OrigHdrSize))
        {
            ASSERT(FALSE);                  // Should never get here.
            Status = NDIS_STATUS_FAILURE;
            break;
        }


        // Add the Bootp code here.
        Status = arpEthModifyBootPPacket(pIF,
                                        Direction,
                                        pDestAddress, 
                                        (PUCHAR)pvNewData,
                                        NewPktSize ,
                                        pSR);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERT (!"TempAssert -arpEthModifyBootPPacket FAILED"); 
            break;
        }

    } while (FALSE);

    if (FAIL(Status) && pNewPkt != NULL)
    {
        arpFreeControlPacket(
            pIF,
            pNewPkt,
            pSR
            );

       *ppNewPkt = NULL;
    }
    else
    {
       *ppNewPkt = pNewPkt;
    }

    return Status;
}

NDIS_STATUS
arpGetEthHeaderFrom1394IpPkt(
    IN  PARP1394_INTERFACE  pIF,
    IN  PVOID               pvData,
    IN  UINT                cbData,
    IN  MYBOOL              fUnicast,
    OUT ENetHeader          *pEthHdr,
    OUT PIP_ADDRESS         pDestIpAddress, // OPTIONAL
    PRM_STACK_RECORD        pSR
    )
/*++
    Return a fully filled ethernet header, with source and estination
    MAC addresses and ethertype set to IP.

    The source address is always the local adapter's MAC address.

    The destination address is set by calling arpGetEthAddrFromIpAddr


--*/
{
    ENTER("arpGetEthHeaderFrom1394IpPkt", 0x0)
    static
    ENetHeader
    StaticEthernetHeader =
    {
        {0xff, 0xff, 0xff, 0xff, 0xff, 0xff},               // eh_daddr == BCAST
        ARP_DEF_REMOTE_ETH_ADDRESS,
        H2N_USHORT(NIC1394_ETHERTYPE_IP)                    // eh_type
    };
    
    ARP1394_ADAPTER *       pAdapter;
    BOOLEAN                 fBridgeMode;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;

    PNDIS1394_UNFRAGMENTED_HEADER pHeader = (PNDIS1394_UNFRAGMENTED_HEADER)pvData;

    pAdapter    = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);

    do
    {
        UNALIGNED IPHeader *pIpHdr;
        IP_ADDRESS  IpDest;

        if (cbData < (sizeof(NIC1394_ENCAPSULATION_HEADER) + sizeof(IPHeader)))
        {
            //
            // Packet is too small.
            //
            TR_INFO(("Discarding packet because pkt too small\n"));
            break;
        }
        pIpHdr = (UNALIGNED IPHeader*)
                     (((PUCHAR) pvData)+sizeof(NIC1394_ENCAPSULATION_HEADER));
        IpDest = pIpHdr->iph_dest;

        if (pDestIpAddress != NULL)
        {
            *pDestIpAddress = IpDest;
        }


        if (!fBridgeMode)
        {
            //
            // TODO: we currently return a hardcoded ethernet address.
            // Need to constuct one by looking into the actual IP packet data.
            //
            *pEthHdr = StaticEthernetHeader;
        
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Following is specific to BRIDGE mode
        //


        // Always set the source address according to the sender.
        //
        {
            ENetAddr SourceMacAddress;
            
            Status = \
                arpGetSourceMacAddressFor1394Pkt (pAdapter,
                                                    pHeader->u1.SourceAddress,
                                                    pHeader->u1.fHeaderHasSourceAddress,
                                                    &SourceMacAddress,
                                                    pSR);

            if (FAIL(Status))
            {
                break;
            }

            pEthHdr->eh_saddr = SourceMacAddress ; 

        }

        //
        // If we have a STA packet then construct the STA Header
        // or else construct the sender/destination specific Ethernet
        // Header
        //
        {

            if (pHeader->u1.EtherType  == N2H_USHORT(NIC1394_ETHERTYPE_STA)  )
            {
                arpEthConstructSTAEthHeader(pvData,cbData, pEthHdr);
            }
            else
            {
                
                pEthHdr->eh_type = H2N_USHORT(ARP_ETH_ETYPE_IP);
                Status =  arpGetEthAddrFromIpAddr(
                                pIF,
                                fUnicast,
                                IpDest,
                                &pEthHdr->eh_daddr,
                                pSR
                                );
            }
        }
    } while (FALSE);

    return Status;
}



NDIS_STATUS
arpGet1394HeaderFromEthIpPkt(
    IN  PARP1394_INTERFACE  pIF,
    IN  PNDIS_BUFFER        pFirstBuffer,
    IN  PVOID               pvData,
    IN  UINT                cbData,
    IN  MYBOOL              fUnicast,
    OUT NIC1394_ENCAPSULATION_HEADER
                            *p1394Hdr,
    OUT PREMOTE_DEST_KEY    pDestAddress, // OPTIONAL
    PRM_STACK_RECORD        pSR
    )
{
    MYBOOL  fLoopBack = FALSE;
    ENetHeader *pEthHdr =  (ENetHeader *) pvData;
    ARP1394_ADAPTER *       pAdapter;
    BOOLEAN                 fBridgeMode;

    if (cbData < (sizeof(ENetHeader) ) )
    {
        //
        // Packet is too small.
        //
        return NDIS_STATUS_FAILURE;  // ***** EARLY RETURN ****
    }

    pAdapter    = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);


    if (NdisEqualMemory(&pEthHdr->eh_daddr, 
                        &pAdapter->info.EthernetMacAddress,
                        sizeof(ENetAddr)))
    {
        if (!fBridgeMode)
        {
            // We're not in bridge mode -- so this must be only on MILL
            // This is addressed to our local mac address.
            // We fail with special failure status
            // NDIS_STATUS_ALREADY_MAPPED, indicating "loopback".
            //

            fLoopBack = TRUE;
        }
    }
    else
    {
        //
        // Do nothing ... because we can get unicasts to our fictitious gateway
        //
    }

    if (fLoopBack)
    {
        return NDIS_STATUS_ALREADY_MAPPED;
    }
    else
    {

        BOOLEAN fIsSTAPacket ;
        //
        // We have an STA packet, if the destination is our special 
        // Multicast Destination
        //
        fIsSTAPacket = (TRUE == NdisEqualMemory (&pEthHdr->eh_daddr, 
                                                &gSTAMacAddr, 
                                                ETH_LENGTH_OF_ADDRESS) );

        if (fIsSTAPacket  == TRUE)
        {
            *p1394Hdr = Arp1394_StaEncapHeader;
        }
        else
        {
            *p1394Hdr = Arp1394_IpEncapHeader;
        }

        if (pDestAddress != NULL)
        {
            //
            // Extract the Enet Address to use it as part of the lookup
            //
            UNALIGNED ENetAddr *pENetDest;
            pENetDest = (UNALIGNED ENetAddr *)(pvData);
            pDestAddress->ENetAddress = *pENetDest;
            
        }

        return NDIS_STATUS_SUCCESS;
    }
}


#if TEST_ICS_HACK
VOID
arpDbgStartIcsTest(
    IN  PARP1394_INTERFACE          pIF,  // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD                pSR
    )
{
    PRM_TASK pTask;
    NDIS_STATUS Status;
    ENTER("arpDbgStartIcsTest", 0xb987276b)

    RM_ASSERT_NOLOCKS(pSR);

    //
    // Allocate and start an instance of the arpTaskDoIcsTest task.
    //

    Status = arpAllocateTask(
                &pIF->Hdr,          // pParentObject
                arpTaskDoIcsTest,       // pfnHandler
                0,                              // Timeout
                "Task: Ics Test",   // szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        TR_WARN(("couldn't alloc test ics intf task!\n"));
    }
    else
    {

        (VOID)RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    pSR
                    );
    }

    EXIT()
}

VOID
arpDbgTryStopIcsTest(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD                pSR
    )
{
    PTASK_ICS_TEST  pIcsTask;
    ENTER("arpDbgStartIcsTest", 0xb987276b)


    LOCKOBJ(pIF, pSR);

    pIcsTask = (PTASK_ICS_TEST) pIF->ethernet.pTestIcsTask;
    if (pIcsTask != NULL)
    {
        pIcsTask->Quit = TRUE;
        RmTmpReferenceObject(&pIcsTask->TskHdr.Hdr, pSR);
    }
    UNLOCKOBJ(pIF, pSR);

    //
    // Resume the ICS task if it's waiting  -- it will then quit because we set
    // the Quit field above.
    //
    if (pIcsTask != NULL)
    {
        UINT    TaskResumed;

        RmResumeDelayedTaskNow(
            &pIcsTask->TskHdr,
            &pIcsTask->Timer,
            &TaskResumed,
            pSR
            );

        RmTmpDereferenceObject(&pIcsTask->TskHdr.Hdr, pSR);
    }

    RM_ASSERT_NOLOCKS(pSR)
    EXIT()
}

typedef struct
{
    NIC1394_ENCAPSULATION_HEADER    Hdr;
    UCHAR                           Payload[8];
} SAMPLE_1394_PKT;

typedef struct
{
    ENetHeader                      Hdr;
    UCHAR                           Payload[8];
} SAMPLE_ETH_PKT;

SAMPLE_1394_PKT Sample1394Pkt =
{
    {
        0x0000,     // Reserved
        H2N_USHORT(NIC1394_ETHERTYPE_IP)
    },

    {0x0, 0x1, 0x2, 0x3,
     0x4, 0x5, 0x6, 0x7}
};


SAMPLE_ETH_PKT SampleEthPkt =
{
    {
        ARP_FAKE_ETH_ADDRESS(1),    // dest
        ARP_FAKE_ETH_ADDRESS(2),    // src
        H2N_USHORT(NIC1394_ETHERTYPE_IP)                    // eh_type
    },

    {0x10, 0x11, 0x12, 0x13,
     0x14, 0x15, 0x16, 0x17}
};

// This is to save the location of the test task's op type so we can recover it
// in the debugger.
//
PUINT g_pArpEthTestTaskOpType;

NDIS_STATUS
arpTaskDoIcsTest(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for loading a newly-created IP interface.

    This is a primary task for the interface object.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pTask);
    PTASK_ICS_TEST      pTestTask;

    enum
    {
        STAGE_Start,
        STAGE_ResumeDelayed,
        STAGE_End

    } Stage;

    ENTER("TaskDoIcsTest", 0x57e523ed)

    pTestTask = (PTASK_ICS_TEST) pTask;
    ASSERT(sizeof(TASK_ICS_TEST) <= sizeof(ARP1394_TASK));

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_Start;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    ASSERTEX(!PEND(Status), pTask);
        
    switch(Stage)
    {

        case  STAGE_Start:
        {
            // If there is an ICS test task, we exit immediately.
            //
            LOCKOBJ(pIF, pSR);
            if (pIF->ethernet.pTestIcsTask == NULL)
            {
                pIF->ethernet.pTestIcsTask = pTask;
            }
            else
            {
                // There already is a test task. We're done.
                //
                UNLOCKOBJ(pIF, pSR);
                Status = NDIS_STATUS_SUCCESS;
                break;
            }
            UNLOCKOBJ(pIF, pSR);
        
            //
            // We're now the official ICS test task for this interface.
            //

            //
            // Let's allocate the 1394 and ethernet dummy packets.
            //
            {
                PNDIS_PACKET pPkt;
                PVOID           pvNewData;

                Status = arpAllocateControlPacket(
                            pIF,
                            sizeof(Sample1394Pkt),
                            ARP1394_PACKET_FLAGS_ICS,
                            &pPkt,
                            &pvNewData,
                            pSR
                            );

                if (FAIL(Status))
                {
                    ASSERT(FALSE);
                    break;
                }
                NdisMoveMemory(pvNewData, &Sample1394Pkt, sizeof(Sample1394Pkt));
                pTestTask->p1394Pkt = pPkt;

                Status = arpAllocateControlPacket(
                            pIF,
                            sizeof(SampleEthPkt),
                            ARP1394_PACKET_FLAGS_ICS,
                            &pPkt,
                            &pvNewData,
                            pSR
                            );

                if (FAIL(Status))
                {
                    ASSERT(FALSE);
                    break;
                }
                NdisMoveMemory(pvNewData, &SampleEthPkt, sizeof(SampleEthPkt));
                pTestTask->pEthPkt = pPkt;

                // Set default delay.
                //
                pTestTask->Delay = 5000; // 5 sec.

                TR_WARN(("TEST ICS: pTask=0x%8lx; &OpType=0x%08lx(%lu) &Delay=0x%08lx(%lu)\n",
                            pTestTask,
                            &pTestTask->PktType,
                            pTestTask->PktType,
                            &pTestTask->Delay,
                            pTestTask->Delay
                            ));
                g_pArpEthTestTaskOpType = &pTestTask->PktType;
            }

            
            // We move on to the next stage, after a delay.
            //
            RmSuspendTask(pTask, STAGE_ResumeDelayed, pSR);
            RmResumeTaskDelayed(
                pTask, 
                0,
                1000,
                &pTestTask->Timer,
                pSR
                );
            Status = NDIS_STATUS_PENDING;


         }
         break;

        case STAGE_ResumeDelayed:
        {
            //
            // If qe're quitting, we get out of here.
            // Otherwise we'll send a packet either on the ethernet VC
            // or via the miniport's connectionless ethernet interface.
            //

            if (pTestTask->Quit)
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            switch (pTestTask->PktType)
            {
            default:
            case 0: 
                // Do nothing.
                break;

            case 1:
                pTestTask->PktType = 0; // One shot
                // Fall through...
            case 11:
                // Forward to ethernet (the packet is not held on to).
                //
                arpIcsForwardIpPacket(
                    pIF,
                    pTestTask->p1394Pkt,
                    ARP_ICS_FORWARD_TO_ETHERNET,
                    FALSE,       // FALSE == non unicast
                    pSR
                    );
                break;

            case 2:
                pTestTask->PktType = 0; // One shot
                // Fall through...
            case 12:
                // Send on connectionless ethernet.

            #if RM_EXTRA_CHECKING
        
                RmLinkToExternalEx(
                    &pIF->Hdr,                                  // pHdr
                    0xf4aa69c7,                             // LUID
                    (UINT_PTR) pTestTask->pEthPkt,          // External entity.
                    ARPASSOC_ETH_SEND_PACKET,               // AssociationID
                    "    Outstanding connectionless ethernet pkt 0x%p\n", // szFormat
                    pSR
                    );
        
            #else   // !RM_EXTRA_CHECKING
        
                RmLinkToExternalFast(&pIF->Hdr);
        
            #endif // !RM_EXTRA_CHECKING

                NdisSendPackets(
                    pIF->ndis.AdapterHandle,
                    &(pTestTask->pEthPkt),
                    1
                    );
                break;
            }

            // Now we wait again...
            //
            RmSuspendTask(pTask, STAGE_ResumeDelayed, pSR);
            RmResumeTaskDelayed(
                pTask, 
                0,
                pTestTask->Delay,
                &pTestTask->Timer,
                pSR
                );
            Status = NDIS_STATUS_PENDING;

        }
        break;

        case STAGE_End:
        {
            NDIS_HANDLE                 BindContext;

            // Free the test packets, if we've allocated them.
            //
            if (pTestTask->p1394Pkt != NULL)
            {
                arpFreeControlPacket(pIF, pTestTask->p1394Pkt, pSR);
                pTestTask->p1394Pkt = NULL;
            }
            if (pTestTask->pEthPkt != NULL)
            {
                arpFreeControlPacket(pIF, pTestTask->pEthPkt, pSR);
                pTestTask->pEthPkt = NULL;
            }

            LOCKOBJ(pIF, pSR);
            if (pIF->ethernet.pTestIcsTask == pTask)
            {
                // We're the official ics test task, we clear ourselves from
                // the interface object and do any initialization required.
                //
                pIF->ethernet.pTestIcsTask = NULL;
                UNLOCKOBJ(pIF, pSR);
            }
            else
            {
                // We're note the official ics test task. Nothing else to do.
                //
                UNLOCKOBJ(pIF, pSR);
                break;
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


VOID
arpEthSendComplete(
    IN  ARP1394_ADAPTER *   pAdapter,
    IN  PNDIS_PACKET        pNdisPacket,
    IN  NDIS_STATUS         Status
)
/*++

Routine Description:

    This is the Connection-less Send Complete handler, which signals
    completion of such a Send.

Arguments:

    <Ignored>

Return Value:

    None

--*/
{
    ENTER("arpEthSendComplete", 0x49eafb6d)
    ARP1394_INTERFACE   *   pIF = pAdapter->pIF;
    RM_DECLARE_STACK_RECORD(sr)


    #if RM_EXTRA_CHECKING

        RmUnlinkFromExternalEx(
            &pIF->Hdr,                          // pHdr
            0xde8c8fb4,                         // LUID
            (UINT_PTR) pNdisPacket,             // External entity
            ARPASSOC_ETH_SEND_PACKET,           // AssociationID
            &sr
            );

    #else   // !RM_EXTRA_CHECKING

        RmUnlinkFromExternalFast(&pIF->Hdr);

    #endif // !RM_EXTRA_CHECKING

    

    //
    // We do not free the packet, as it's re-used by the ICS test task..
    //

    RM_ASSERT_CLEAR(&sr);

    EXIT()
}
#endif // TEST_ICS_HACK


VOID
arpEthReceivePacket(
    IN  ARP1394_INTERFACE   *   pIF,
    PNDIS_PACKET            pNdisPacket
    )
/*
    This is the connectionLESS ethernet receive packet handler.
    Following code adapted from the co receive packet handler.
*/
{
    ENTER("arpEthReceivePacket", 0xc8afbabb)
    UINT                    TotalLength;    // Total bytes in packet
    PNDIS_BUFFER            pNdisBuffer;    // Pointer to first buffer
    UINT                    BufferLength;
    UINT                    ReturnCount;
    PVOID                   pvPktHeader;
    ENetHeader          *   pEthHeader;
    const UINT              MacHeaderLength = sizeof(ENetHeader);
    ARP1394_ADAPTER *       pAdapter;
    BOOLEAN                 fBridgeMode;

    pAdapter    = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);

    DBGMARK(0x2425d318);

    ReturnCount = 0;

    //
    // Discard the packet if the IP interface is not activated
    //
    do
    {
        //
        // Discard packet if adapter is in bridge mode.
        //
        if (fBridgeMode)
        {
            break;
        }


        //
        // Discard the packet if the adapter is not active
        //
        if (!CHECK_IF_ACTIVE_STATE(pIF,  ARPAD_AS_ACTIVATED))
        {
            TR_INFO(("Eth:Discardning received Eth pkt because pIF 0x%p is not activated.\n", pIF));
    
            break;
        }

        NdisQueryPacket(
                        pNdisPacket,
                        NULL,
                        NULL,
                        &pNdisBuffer,
                        &TotalLength
                        );
    
        if (TotalLength > 0)
        {
            NdisQueryBuffer(
                    pNdisBuffer,
                    (PVOID *)&pvPktHeader,
                    &BufferLength
                    );
        }
        else
        {
            break;
        }
    
        pEthHeader  =  (ENetHeader*) pvPktHeader;
    
        TR_INFO(
    ("EthRcv: NDISpkt 0x%x, NDISbuf 0x%x, Buflen %d, Totlen %d, Pkthdr 0x%x\n",
                    pNdisPacket,
                    pNdisBuffer,
                    BufferLength,
                    TotalLength,
                    pvPktHeader));
    
        if (BufferLength < MacHeaderLength || pEthHeader   == NULL)
        {
            // Packet is too small, discard.
            //
            break;
        }
    
        //
        // At this point, pEthHeader contains the Ethernet header.
        // We look at the ethertype to decide what to do with it.
        //
        if (pEthHeader->eh_type ==  N2H_USHORT(ARP_ETH_ETYPE_IP))
        {
            //
            //  The EtherType is IP, so we pass up this packet to the IP layer.
            // (Also we indicate all packets we receive on the broadcast channel
            // to the ethernet VC).
            //
    
            TR_INFO(
                ("Rcv: pPkt 0x%x: EtherType is IP, passing up.\n", pNdisPacket));
    
            ARP_IF_STAT_INCR(pIF, InNonUnicastPkts);
    
            LOGSTATS_CopyRecvs(pIF, pNdisPacket);
            #if MILLEN
                ASSERT_PASSIVE();
            #endif // MILLEN
            pIF->ip.RcvHandler(
                pIF->ip.Context,
                (PVOID)((PUCHAR)pEthHeader+sizeof(*pEthHeader)),
                BufferLength - MacHeaderLength,
                TotalLength - MacHeaderLength,
                (NDIS_HANDLE)pNdisPacket,
                MacHeaderLength,
                FALSE,              // FALSE == NOT received via broadcast.
                                    // Important, because we are reflecting directed
                                    // packets up to IP. If we report TRUE here,
                                    // IP assumes it's not a directed packet, and
                                    // handles it differently.
                NULL
                );
        }
        else
        {
            //
            //  Discard packet -- unknown/bad EtherType
            //
            TR_INFO(("Encap hdr 0x%x, bad EtherType 0x%x\n",
                     pEthHeader, pEthHeader->eh_type));
            ARP_IF_STAT_INCR(pIF, UnknownProtos);
        }

    } while (FALSE);

    EXIT()
    return;
}


VOID
arpEthProcess1394ArpPkt(
    IN  PARP1394_INTERFACE         pIF,
    IN  PIP1394_ARP_PKT pArpPkt,
    IN  UINT                       HeaderSize
    )
/*++

    Process an ip/1394 ARP packet. We do the following:
    0. Parse the paket
    1. Update our local RemoteIP cache.
    2. Create and send an equivalent ethernet arp pkt on the ethernet VC.
       (We look up the destination ethernet address in our ethernet cache)

    This function must only be called when the adapter is in "Bridged mode."

--*/
{
    IP1394_ARP_PKT_INFO     Ip1394PktInfo;
    ETH_ARP_PKT_INFO        EthArpInfo;
    NDIS_STATUS                 Status = NDIS_STATUS_FAILURE;
    ARP_DEST_PARAMS             DestParams;
    PARP1394_ADAPTER            pAdapter =(PARP1394_ADAPTER ) RM_PARENT_OBJECT(pIF);
    ENetAddr                    SenderEnetAddress;
    IPAddr                      SenderIpAddress = 0;
    REMOTE_DEST_KEY             RemoteDestKey;
    
    ENTER("arpEthProcess1394ArpPkt", 0x0)
    RM_DECLARE_STACK_RECORD(Sr)

    ARP_ZEROSTRUCT(&DestParams);

    do {

        PNDIS_PACKET    pPkt        = NULL;
        PVOID           pvData  = NULL;

        Status =  arpParseArpPkt(
                        pArpPkt,
                        HeaderSize,
                        &Ip1394PktInfo
                        );
    
        if (FAIL(Status))
        {
            TR_WARN(("Failed parse of received 1394 ARP PKT.\n"));
            break;
        }

        DestParams.HwAddr.AddressType   = NIC1394AddressType_FIFO;
        DestParams.HwAddr.FifoAddress   = Ip1394PktInfo.SenderHwAddr; // Struct copy

        REMOTE_DEST_KEY_INIT(&RemoteDestKey);


        if ((ARP_BRIDGE_ENABLED(pAdapter) == TRUE) &&
            (Ip1394PktInfo.fPktHasNodeAddress == FALSE))
        {
            // We do not have the sender's Node ID -- fail.
            TR_WARN (("Did not Receive Sender's Node ID in Pkt"))
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        
        if (ARP_BRIDGE_ENABLED(pAdapter) == TRUE)
        {
            // Extract the Source Mac address using the Sender Node Address

            Status = arpGetSourceMacAddressFor1394Pkt(pAdapter, 
                                            Ip1394PktInfo.SourceNodeAdddress,
                                            TRUE,
                                            &Ip1394PktInfo.SourceMacAddress,
                                            &Sr);                                

            RemoteDestKey.ENetAddress =  Ip1394PktInfo.SourceMacAddress; 
            
        }
        else
        {
            RemoteDestKey.IpAddress  = Ip1394PktInfo.SenderIpAddress;       
            Status = NDIS_STATUS_SUCCESS;
        }

        if (Status != NDIS_STATUS_SUCCESS)
        {
            TR_WARN (("Unable to get valid Source  MAC Address from Pkt"))
            Status = NDIS_STATUS_SUCCESS; 
            
            break;
        }
    
        // Update our 1394 ARP cache.
        //
        arpUpdateArpCache(
                pIF,
                RemoteDestKey.IpAddress  , // Remote IP Address
                &RemoteDestKey.ENetAddress, 
                &DestParams,    // Remote Destination HW Address
                TRUE,           // Update even if we don't already have an entry
                &Sr
                );

        Status = arpConstructEthArpInfoFrom1394ArpInfo(
                        pIF,
                        &Ip1394PktInfo,
                        &EthArpInfo,
                        &Sr
                        );

        if (FAIL(Status)) break;

        // Allocate an appropriately sized control packet.
        //
        Status = arpAllocateControlPacket(
                    pIF,
                    sizeof(ETH_ARP_PKT),
                    ARP1394_PACKET_FLAGS_ICS,
                    &pPkt,
                    &pvData,
                    &Sr
                    );

        if (FAIL(Status))
        {
            ASSERT(FALSE); // we want to know if we hit this in regular use.
            pPkt = NULL;
            break;
        }

        NdisInterlockedIncrement (&Arp1394ToIcs);

        // Fill it out..
        //
        arpPrepareEthArpPkt(
                &EthArpInfo,
                (PETH_ARP_PKT) pvData
                );
    
        // Send the packet over the ethernet VC...
        //
        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        arpSendControlPkt(
                pIF,            // LOCKIN NOLOCKOUT (IF send lk)
                pPkt,
                pIF->pEthernetDest,
                &Sr
                );

    } while (FALSE);

    RM_ASSERT_CLEAR(&Sr);
}


VOID
arpEthProcessEthArpPkt(
    IN  PARP1394_INTERFACE      pIF,
    IN  PETH_ARP_PKT  pArpPkt,
    IN  UINT                    HeaderSize
    )
/*++

    Process an Ethernet ARP packet. We do the following:
    0. Parse the packet
    1. Update our local ethernet arp cache.
    2. Create and send an equivalent 1394  arp pkt on the broadcast VC.
       (We look up the destination ethernet address in our ethernet cache)

    This function must only be called when the adapter is in "Bridged mode."

--*/
{

    ETH_ARP_PKT_INFO    EthPktInfo;
    IP1394_ARP_PKT_INFO     Ip1394ArpInfo;
    NDIS_STATUS                 Status;
    ARP_REMOTE_ETH_PARAMS   CreateParams;
    ENTER("arpEthProcessEthArpPkt", 0x0)
    RM_DECLARE_STACK_RECORD(Sr)

    ARP_ZEROSTRUCT(&CreateParams);

    do {

        PNDIS_PACKET    pPkt        = NULL;
        PVOID           pvData  = NULL;

        Status =  arpParseEthArpPkt(
                        pArpPkt,
                        HeaderSize,
                        &EthPktInfo
                        );
    
        if (FAIL(Status))
        {
            TR_WARN(("Failed parse of received Ethernet ARP PKT.\n"));
            break;
        }

        Status = arpConstruct1394ArpInfoFromEthArpInfo(
                        pIF,
                        &EthPktInfo,
                        &Ip1394ArpInfo,
                        &Sr
                        );

        if (FAIL(Status)) break;

        // Allocate an appropriately sized control packet.
        //
        Status = arpAllocateControlPacket(
                    pIF,
                    sizeof(IP1394_ARP_PKT),
                    ARP1394_PACKET_FLAGS_ICS,
                    &pPkt,
                    &pvData,
                    &Sr
                    );

        if (FAIL(Status))
        {
            ASSERT(FALSE); // we want to know if we hit this in regular use.
            pPkt = NULL;
            break;
        }

        // Fill it out..
        //
        arpPrepareArpPkt(
                &Ip1394ArpInfo,
                (PIP1394_ARP_PKT) pvData
                );
    
        // Send the packet over the ethernet VC...
        //
        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        arpSendControlPkt(
                pIF,            // LOCKIN NOLOCKOUT (IF send lk)
                pPkt,
                pIF->pBroadcastDest,
                &Sr
                );

    } while (FALSE);

    RM_ASSERT_CLEAR(&Sr);
}



NDIS_STATUS
arpParseEthArpPkt(
    IN   PETH_ARP_PKT     pArpPkt,
    IN   UINT                       cbBufferSize,
    OUT  PETH_ARP_PKT_INFO          pPktInfo
    )
/*++
Routine Description:

    Parse the contents of IP/Ethernet ARP packet data starting at
    pArpPkt. Place the results into pPktInfo.

Arguments:

    pArpPkt - Contains the unaligned contents of an ip/eth ARP Pkt.
    pPktInfo    - Unitialized structure to be filled with the parsed contents of the
                  pkt.

Return Value:

    NDIS_STATUS_FAILURE if the parse failed (typically because of invalid pkt
                        contents.)
    NDIS_STATUS_SUCCESS on successful parsing.
    
--*/
{
    ENTER("arpParseEthArpPkt", 0x359e9bf2)
    NDIS_STATUS                 Status;
    DBGSTMT(CHAR *szError   = "General failure";)

    Status  = NDIS_STATUS_FAILURE;

    do
    {
        UINT OpCode;

        // Verify length.
        //
        if (cbBufferSize < sizeof(*pArpPkt))
        {
            DBGSTMT(szError = "pkt size too small";)
            break;
        }

        // Verify constant fields.
        //

        if (N2H_USHORT(pArpPkt->header.eh_type) != ARP_ETH_ETYPE_ARP)
        {
            DBGSTMT(szError = "header.eh_type!=ARP";)
            break;
        }

    #if 0
        ARP_ETH_HW_ENET OR ARP_ETH_HW_802 
        if (N2H_USHORT(pArpPkt->hardware_type) != IP1394_HARDWARE_TYPE)
        {
            DBGSTMT(szError = "Invalid hardware_type";)
            break;
        }
    #endif // 0

        // ARP_ETH_ETYPE_IP  ARP_ETH_ETYPE_ARP
        if (N2H_USHORT(pArpPkt->protocol_type) != ARP_ETH_ETYPE_IP)
        {
            DBGSTMT(szError = "Invalid protocol_type";)
            break;
        }

        if (pArpPkt->hw_addr_len != ARP_802_ADDR_LENGTH)
        {
            DBGSTMT(szError = "Invalid hw_addr_len";)
            break;
        }


        if (pArpPkt->IP_addr_len != sizeof(ULONG))
        {
            DBGSTMT(szError = "Invalid IP_addr_len";)
            break;
        }


        // Opcode
        //
        {
            OpCode = N2H_USHORT(pArpPkt->opcode);
    
            if (    OpCode != ARP_ETH_REQUEST
                &&  OpCode != ARP_ETH_RESPONSE)
            {
                DBGSTMT(szError = "Invalid opcode";)
                break;
            }
        }

        //
        // Pkt appears valid, let's fill out the parsed information....
        //
    
        ARP_ZEROSTRUCT(pPktInfo);

        pPktInfo->SourceEthAddress  = pArpPkt->header.eh_saddr; // struct copy.
        pPktInfo->DestEthAddress    = pArpPkt->header.eh_daddr; // struct copy.
        pPktInfo->OpCode            =  (USHORT) OpCode;

        // These remain network byte order...
        //
        pPktInfo->SenderIpAddress       = (IP_ADDRESS) pArpPkt->sender_IP_address;
        pPktInfo->TargetIpAddress       = (IP_ADDRESS) pArpPkt->target_IP_address;

        pPktInfo->SenderEthAddress      = pArpPkt->sender_hw_address; // struct copy
        pPktInfo->TargetEthAddress      = pArpPkt->target_hw_address; // struct copy

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    if (FAIL(Status))
    {
        TR_INFO(("Bad arp pkt data at 0x%p (%s)\n",  pArpPkt, szError));
    }
    else
    {
        PUCHAR pSip = (PUCHAR)&pPktInfo->SenderIpAddress;
        PUCHAR pTip = (PUCHAR)&pPktInfo->TargetIpAddress;
        TR_VERB(("Received ETH ARP PKT. OP=%lu SIP=%d.%d.%d.%d TIP=%d.%d.%d.%d.\n",
                pPktInfo->OpCode,
                pSip[0],pSip[1],pSip[2],pSip[3],
                pTip[0],pTip[1],pTip[2],pTip[3]
                ));

    }

    EXIT()

    return Status;
}


VOID
arpPrepareEthArpPkt(
    IN   PETH_ARP_PKT_INFO          pPktInfo,
    OUT  PETH_ARP_PKT     pArpPkt
    )
/*++

Routine Description:

    Use information in pArpPktInfo to prepare an ethernet arp packet starting at
    pvArpPkt.

Arguments:

    pPktInfo        -   Parsed version of the eth arp request/response packet.
    pArpPkt         -   unitialized memory in which to store the packet contents.
                        This memory must have a min size of sizeof(*pArpPkt).
--*/
{
    // UINT SenderMaxRec;
    UINT OpCode;

    ARP_ZEROSTRUCT(pArpPkt);

    pArpPkt->header.eh_type         = H2N_USHORT(ARP_ETH_ETYPE_ARP);
    pArpPkt->header.eh_daddr        = pPktInfo->DestEthAddress;
    pArpPkt->header.eh_saddr        = pPktInfo->SourceEthAddress;
    pArpPkt->hardware_type          = H2N_USHORT(ARP_ETH_HW_ENET); // TODO 
                                            // we always set the type
                                            // to ARP_ETH_HW_ENET -- not sure
                                            // if this a valid assumption or
                                            // if we need to query the NIC.
    pArpPkt->protocol_type          = H2N_USHORT(ARP_ETH_ETYPE_IP);
    pArpPkt->hw_addr_len            = (UCHAR)  ARP_802_ADDR_LENGTH;
    pArpPkt->IP_addr_len            = (UCHAR) sizeof(ULONG);
    pArpPkt->opcode                 = H2N_USHORT(pPktInfo->OpCode);


    // These are already in network byte order...
    //
    pArpPkt->sender_IP_address      =   (ULONG) pPktInfo->SenderIpAddress;
    pArpPkt->target_IP_address      =   (ULONG) pPktInfo->TargetIpAddress;
    pArpPkt->sender_hw_address      =  pPktInfo->SenderEthAddress; // struct copy
    pArpPkt->target_hw_address      =  pPktInfo->TargetEthAddress; // struct copy
}


UINT
arpEthernetReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
)
/*++

    NDIS Co receive packet for the ethernet VC.

    We do the following:

    If it's an ARP packet, we translate it and send it on the bcast channel.
    Else if it was a ethernet unicast packet, we change the header 
        and treat it like an IP unicast packet -- SlowIpTransmit
    Else we change the header and then send it on the bcast desination.

--*/
{
    PARP_VC_HEADER          pVcHdr;
    PARPCB_DEST             pDest;
    PARP1394_INTERFACE      pIF;
    ARP1394_ADAPTER *       pAdapter;
    ENetHeader             *pEthHdr;

    UINT                    TotalLength;    // Total bytes in packet
    PNDIS_BUFFER            pNdisBuffer;    // Pointer to first buffer
    UINT                    BufferLength;
    PVOID                   pvPktHeader;
    const UINT              MacHeaderLength = sizeof(ENetHeader);
    MYBOOL                  fBridgeMode;
    MYBOOL                  fUnicast;
    MYBOOL                  fIsSTAPacket;
    ENTER("arpEthernetReceivePacket", 0x0)
    RM_DECLARE_STACK_RECORD(sr)

    DBGMARK(0x72435b28);

#if TESTPROGRAM
    {
        extern ARP1394_INTERFACE  * g_pIF;
        pIF =  g_pIF;
    }
#else // !TESTPROGRAM
    pVcHdr  = (PARP_VC_HEADER) ProtocolVcContext;
    pDest   =  CONTAINING_RECORD( pVcHdr, ARPCB_DEST, VcHdr);
    ASSERT_VALID_DEST(pDest);
    pIF     = (ARP1394_INTERFACE*)  RM_PARENT_OBJECT(pDest);
#endif // TESTPROGRAM

    ASSERT_VALID_INTERFACE(pIF);
    pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);

    do
    {

        if (!fBridgeMode) // This is really only for MILL
        {
        #if MILLEN
            arpIcsForwardIpPacket(
                pIF,
                pNdisPacket, 
                ARP_ICS_FORWARD_TO_1394,
                FALSE,  // FALSE == NonUnicast
                &sr
                );
        #endif // MILLEN
            break;
        }

        NdisQueryPacket(
                        pNdisPacket,
                        NULL,
                        NULL,
                        &pNdisBuffer,
                        &TotalLength
                        );
    
    
        if (TotalLength > 0)
        {
            NdisQueryBuffer(
                    pNdisBuffer,
                    (PVOID *)&pvPktHeader,
                    &BufferLength
                    );
        }
        else
        {
            break;
        }

        TR_VERB(
    ("Eth Rcv: NDISpkt 0x%x, NDISbuf 0x%x, Buflen %d, Totlen %d, Pkthdr 0x%x\n",
                    pNdisPacket,
                    pNdisBuffer,
                    BufferLength,
                    TotalLength,
                    pvPktHeader));

        if (BufferLength < MacHeaderLength)
        {
            // Packet is too small, discard.
            //
            break;
        }

        if (pvPktHeader == NULL)
        {   
            break;
        }

        pEthHdr  = (ENetHeader*)  pvPktHeader;

        
        fUnicast = arpIsUnicastEthDest(pEthHdr);

        switch(N2H_USHORT(pEthHdr->eh_type))
        {

        case ARP_ETH_ETYPE_ARP:
            {
                PETH_ARP_PKT pArpPkt =  (PETH_ARP_PKT) pEthHdr;
                if (BufferLength < sizeof(*pArpPkt))
                {
                    // discard packet.
                    break;
                }
                arpEthProcessEthArpPkt(pIF, pArpPkt, BufferLength);
            }
            break;

        case ARP_ETH_ETYPE_IP:
            {
                //
                // The EtherType is IP, so we translate the header and
                // send if of on the appropriate 1394 FIFO vc.
                //

                if (fUnicast)
                {
                    PNDIS_PACKET    pNewPkt     = NULL;
                    IP_ADDRESS  IpDest;
                    NDIS_STATUS Status;
                    REMOTE_DEST_KEY Dest;

                    // is this meant for the 1394 net.
                    REMOTE_DEST_KEY_INIT(&Dest);
                    //
                    // Create the translated packet.
                    //
                    Status =  arpIcsTranslateIpPkt(
                                pIF,
                                pNdisPacket,
                                ARP_ICS_FORWARD_TO_1394,
                                TRUE,   // TRUE == fUnicast.
                                &pNewPkt,
                                &Dest,
                                &sr
                                );
                
                    if (FAIL(Status))
                    {
                        break;
                    }

                    Status =  arpSlowIpTransmit(
                                    pIF,
                                    pNewPkt,
                                    Dest,
                                    NULL    // RCE
                                    );
                    if (!PEND(Status))
                    {
                        // We need to deallocate the packet ourselves
                        //
                        arpFreeControlPacket(
                            pIF,
                            pNewPkt,
                            &sr
                            );
                    }
                }
                else
                {
                    // This is a broadcast or multicast IP packet -- swith
                    // the link-layer header and send it over the 1394
                    // broadcast channel.
                    //
                    arpIcsForwardIpPacket(
                        pIF,
                        pNdisPacket,
                        ARP_ICS_FORWARD_TO_1394,
                        FALSE,  // FALSE == NonUnicast
                        &sr
                        );
                }
            }
            break;
            
        default:

            //
            // Last option is that it could be a Bridge STA packet.
            // However the bridge does not use an Ethertype, so we 
            // have to check the destination mac address
            //
            fIsSTAPacket = (TRUE == NdisEqualMemory (&pEthHdr->eh_daddr, 
                                                    &gSTAMacAddr, 
                                                    ETH_LENGTH_OF_ADDRESS) );

            if (fIsSTAPacket == TRUE)
            {
                //
                // switch the link-layer header and send it over the 1394
                // broadcast channel.
                //
                arpIcsForwardIpPacket(
                    pIF,
                    pNdisPacket,
                    ARP_ICS_FORWARD_TO_1394,
                    FALSE,  // FALSE == NonUnicast
                    &sr );

            }
            break;
        }


    } while (FALSE);

    RM_ASSERT_CLEAR(&sr);

    return 0;
}


VOID
arpEthReceive1394Packet(
    IN  PARP1394_INTERFACE      pIF,
    IN  PNDIS_PACKET            pNdisPacket,
    IN  PVOID                   pvHeader,
    IN  UINT                    HeaderSize,
    IN  MYBOOL                  IsChannel
    )
/*++
    Handle an incoming packet from the 1394 side when in bridged mode.

    pEncapHeader -- the 1st buffer in the packet.
--*/
{
    PNIC1394_ENCAPSULATION_HEADER pEncapHeader;
    ENTER("arpEthReceived1394Packet", 0xe317990b)
    RM_DECLARE_STACK_RECORD(sr)

    pEncapHeader =  (PNIC1394_ENCAPSULATION_HEADER) pvHeader;

    do
    {
        //
        // Discard the packet if the adapter is not active
        //
        if (!CHECK_IF_ACTIVE_STATE(pIF,  ARPAD_AS_ACTIVATED))
        {
            TR_INFO(("Eth:Discardning received 1394 pkt because pIF 0x%p is not activated.\n", pIF));
    
            break;
        }
    
        if (pEncapHeader->EtherType ==  H2N_USHORT(NIC1394_ETHERTYPE_IP))
        {
            LOGSTATS_CopyRecvs(pIF, pNdisPacket);

            //
            // The EtherType is IP, so we translate the header and
            // send it off on the ethernet vc.
            //
            arpIcsForwardIpPacket(
                    pIF,
                    pNdisPacket,
                    ARP_ICS_FORWARD_TO_ETHERNET,
                    !IsChannel,
                    &sr
                    );
        }
        else if (pEncapHeader->EtherType ==  H2N_USHORT(NIC1394_ETHERTYPE_ARP))
        {
            PIP1394_ARP_PKT pArpPkt =  (PIP1394_ARP_PKT) pEncapHeader;
            if (HeaderSize < sizeof(*pArpPkt))
            {
                // discard packet.
                break;
            }
            arpEthProcess1394ArpPkt(pIF, pArpPkt, HeaderSize);
        }
        else if (pEncapHeader->EtherType ==  H2N_USHORT(NIC1394_ETHERTYPE_MCAP))
        {
            PIP1394_MCAP_PKT pMcapPkt =  (PIP1394_MCAP_PKT) pEncapHeader;
            arpProcessMcapPkt(
                pIF,
                pMcapPkt, 
                HeaderSize
                );
        }
        else if (pEncapHeader->EtherType == H2N_USHORT(NIC1394_ETHERTYPE_STA))
        {
            //
            // The EtherType is STA, so we translate the header and
            // send it off on the ethernet vc.
            //
            arpIcsForwardIpPacket(
                    pIF,
                    pNdisPacket,
                    ARP_ICS_FORWARD_TO_ETHERNET,
                    IsChannel,
                    &sr
                    );

        }
        else 
        {
            //
            //  Discard packet -- unknown/bad EtherType
            //
            TR_INFO(("Encap hdr 0x%x, bad EtherType 0x%x\n",
                     pEncapHeader, pEncapHeader->EtherType));
        }
    }   while (FALSE);

    EXIT()
    RM_ASSERT_CLEAR(&sr);

    return;
}


MYBOOL
arpIsUnicastEthDest(
    IN   UNALIGNED  ENetHeader   *pEthHdr
)
/*++
    Returns TRUE IFF the packet is either ethernet broadcast or
    multicast.

    //
    // TODO: there's probably a quicker check (single bit?).
    //
--*/
{
    if (NdisEqualMemory(&pEthHdr->eh_daddr, 
                        &BroadcastENetAddr,
                        sizeof(ENetAddr)))
    {
        // Broadcast address
        //
        return FALSE;
    }


    if (NdisEqualMemory(&pEthHdr->eh_daddr,
                        &MulticastENetAddr,
                        3))
    {
        // 1st 3 bytes match our Ethernet multicast address template, so we
        // conclude that this is a multicast address.
        // TODO: verify this check.
        //
        return FALSE;
    }

    return TRUE;
}

NDIS_STATUS
arpGetEthAddrFromIpAddr(
    IN  PARP1394_INTERFACE  pIF,
    IN  MYBOOL              fUnicast,
    IN  IP_ADDRESS          DestIpAddress,
    OUT ENetAddr            *pEthAddr,
    PRM_STACK_RECORD        pSR
    )
/*++
    The destination address is set as follows:
    if (fUnicast)
    {
        We look up our ethernet arp cache (pIF->RemoteEthGroup) and
        if we find an entry there, we use the MAC address in that entry.
        If we don't find, we fail this function.
    }
    else
    {
        if (destination IP address is class D)
        {
            we create the corresponding MAC address (based on the standard
            formula for mapping IPv4 multicast addresses to MAC addresses).
        }
        else
        {
            we set the destination address to broadcast (all 0xff's).
            (NOTE: we easily determine if the IP address is a broadast
             address because we don't have the subnet mask, so instead we
            assume that it's a broadcast destination if it's not class D
            and it came over the broadcast channel (i.e. fUnicast == FALSE))
        }
    }

--*/
{
    ENTER("arpGetEthAddrFromIpAddr", 0x0)
    ARP1394_ADAPTER *       pAdapter;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    pAdapter    = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

    do
    {
        if (fUnicast)
        {
            // Lookup the ethernet MAC address in the MAC arp cache.
            //

            *pEthAddr = pAdapter->info.EthernetMacAddress;
            Status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            //
            // Set the destination address to Multicast if dest IP is
            // class D, else multicast
            //

            if (CLASSD_ADDR(DestIpAddress))
            {
                //
                // Construct the corresponding multicast ethernet address.
                // This code is adapted from tcpip\arp.c
                //
                // Basically we copy over a "template" of the multicast
                // address, and then or-in the LSB 23 bits (in network byte
                // order) of the ip address.
                //

                #define ARP_MCAST_MASK      0xffff7f00
                UINT UNALIGNED *pTmp;

                *pEthAddr = MulticastENetAddr; // struct copy.
                pTmp = (UINT UNALIGNED *) & pEthAddr->addr[2];
                *pTmp |= (DestIpAddress & ARP_MCAST_MASK);
            }
            else
            {
                //
                // We assume DestIpAddress is a broadcast address -- see
                // comments at the head of this function
                //
                *pEthAddr = BroadcastENetAddr; // struct copy
            }
        }

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    return Status;
}


NDIS_STATUS
arpConstructEthArpInfoFrom1394ArpInfo(
    IN  PARP1394_INTERFACE      pIF,
    IN  PIP1394_ARP_PKT_INFO    p1394PktInfo,
    OUT PETH_ARP_PKT_INFO       pEthPktInfo,
    PRM_STACK_RECORD            pSR
    )
/*++
    Translate a parsed version of an Ethernet ARP packet into 
    the parsed version of an equivalent 1394 arp packet.

    We ALWAYS set the source ethernet address AND the target ethernet
    address to OUR ethernet MAC address. So other ethernet nodes think of
    us as a a single ethernet mic which hosts a whole bunch of IP addresses.

    We COULD use our proprietary algorithm to convert from EU64 ID to MAC
    addresses and then use those for the target addresses, but we're not
    sure of the ramifications of that in the bridge mode.

--*/
{
    ENTER("arpConstructEthArpInfoFrom1394ArpInfo", 0x8214aa14)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    ENetAddr    SourceMacAddress; 
    do
    {
        MYBOOL         fUnicast;
        IP_ADDRESS     IpDest;
        ARP1394_ADAPTER *       pAdapter;
        UINT Ip1394OpCode = p1394PktInfo->OpCode;
        UINT EthOpCode;

        pAdapter    = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

        ARP_ZEROSTRUCT(pEthPktInfo);

        if (Ip1394OpCode == IP1394_ARP_REQUEST)
        {
            fUnicast = FALSE;
            IpDest   = 0xFFFFFFFF; // IP broadcast address.
            EthOpCode= ARP_ETH_REQUEST;
        }
        else
        {
            // TODO: We expect TargetIpAddress to contain the address
            // of the arp request that resulted in this reply. This
            // is not per ip/1394 spec, which says that the TargetIpAddress
            // is to be ignored. However Kaz has suggested that we
            // utilize this field in this way -- search for "Kaz" in 
            // arp.c
            //
            // If we can't rely on this, then we must either
            // (a) BROADCAST arp replies over ethernet OR
            // (b) keep track of outstanding arp requests which need replies.
            //
            fUnicast = TRUE;
            IpDest   = p1394PktInfo->TargetIpAddress;
            EthOpCode= ARP_ETH_RESPONSE;
        }
    
        Status =  arpGetSourceMacAddressFor1394Pkt (pAdapter, 
                                                   p1394PktInfo->SourceNodeAdddress, 
                                                   p1394PktInfo->fPktHasNodeAddress,
                                                   &SourceMacAddress,
                                                   pSR ); 
        
        if (FAIL(Status))
        {
            break;
        }

        pEthPktInfo->SourceEthAddress = SourceMacAddress ;
        pEthPktInfo->SenderEthAddress = SourceMacAddress ;
        pEthPktInfo->TargetEthAddress = pAdapter->info.EthernetMacAddress;


        Status =  arpGetEthAddrFromIpAddr(
                        pIF,
                        fUnicast,
                        IpDest,
                        &pEthPktInfo->DestEthAddress,
                        pSR
                        );
        if (FAIL(Status))
        {
            break;
        }

        pEthPktInfo->OpCode = EthOpCode;
        pEthPktInfo->SenderIpAddress  = p1394PktInfo->SenderIpAddress;
        pEthPktInfo->TargetIpAddress  = p1394PktInfo->TargetIpAddress;

        

        Status = NDIS_STATUS_SUCCESS;

        {
            UCHAR pIp[4];

            TR_WARN(("Received Arp - "));

            if (EthOpCode == ARP_ETH_RESPONSE)
            {
                TR_WARN(("Response\n"));
            }
            else
            {
                TR_WARN (("Request\n"));
            }

            NdisMoveMemory (&pIp[0], &pEthPktInfo->SenderIpAddress, sizeof(IPAddr) );

            TR_WARN(("Ethernet Source %x %x %x %x %x %x,IP source  %d %d %d %d \n  ",
                       pEthPktInfo->SourceEthAddress.addr[0],
                       pEthPktInfo->SourceEthAddress.addr[1],
                       pEthPktInfo->SourceEthAddress.addr[2],
                       pEthPktInfo->SourceEthAddress.addr[3],
                       pEthPktInfo->SourceEthAddress.addr[4],
                       pEthPktInfo->SourceEthAddress.addr[5],
                        pIp[0],
                        pIp[1],
                        pIp[2],
                        pIp[3]));
                        
            NdisMoveMemory (&pIp[0], &pEthPktInfo->TargetIpAddress, sizeof(IPAddr) );

            TR_WARN(("Ethernet Target %x %x %x %x %x %x , IP Target %d %d %d %d \n",
                       pEthPktInfo->TargetEthAddress.addr[0],
                       pEthPktInfo->TargetEthAddress.addr[1],
                       pEthPktInfo->TargetEthAddress.addr[2],
                       pEthPktInfo->TargetEthAddress.addr[3],
                       pEthPktInfo->TargetEthAddress.addr[4],
                       pEthPktInfo->TargetEthAddress.addr[5],
                        pIp[0],
                        pIp[1],
                        pIp[2],
                        pIp[3]));

            
            TR_WARN(("Ethernet Dest %x %x %x %x %x %x \n",
                       pEthPktInfo->DestEthAddress.addr[0],
                       pEthPktInfo->DestEthAddress.addr[1],
                       pEthPktInfo->DestEthAddress.addr[2],
                       pEthPktInfo->DestEthAddress.addr[3],
                       pEthPktInfo->DestEthAddress.addr[4],
                       pEthPktInfo->DestEthAddress.addr[5]));                            


            TR_WARN(("Ethernet Sender %x %x %x %x %x %x \n\n",
                       pEthPktInfo->SenderEthAddress.addr[0],
                       pEthPktInfo->SenderEthAddress.addr[1],
                       pEthPktInfo->SenderEthAddress.addr[2],
                       pEthPktInfo->SenderEthAddress.addr[3],
                       pEthPktInfo->SenderEthAddress.addr[4],
                       pEthPktInfo->SenderEthAddress.addr[5]));                            

        }

    } while (FALSE);

    return Status;
}



NDIS_STATUS
arpConstruct1394ArpInfoFromEthArpInfo(
    IN  PARP1394_INTERFACE      pIF,
    IN   PETH_ARP_PKT_INFO      pEthPktInfo,
    OUT  PIP1394_ARP_PKT_INFO   p1394PktInfo,
    PRM_STACK_RECORD            pSR
    )
/*++
    Translate a parsed version of an IP1394 ARP packet into 
    the parsed version of an equivalent Ethernet arp packet.

    We always report our own adapter info as the hw/specific info
    in the arp packet. We do this for both arp requests and responses.

    This means that we look like a single host with multiple ip addresses
    to other ip/1394 nodes.

--*/
{
    ARP1394_ADAPTER *       pAdapter;
    UINT Ip1394OpCode;
    UINT EthOpCode = pEthPktInfo->OpCode;

    pAdapter    = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

    ARP_ZEROSTRUCT(p1394PktInfo);

    if (EthOpCode == ARP_ETH_REQUEST)
    {
        Ip1394OpCode=  IP1394_ARP_REQUEST;
    }
    else
    {
        Ip1394OpCode=  IP1394_ARP_RESPONSE;
    }

    p1394PktInfo->OpCode = Ip1394OpCode;
    p1394PktInfo->SenderIpAddress  = pEthPktInfo->SenderIpAddress;
    p1394PktInfo->TargetIpAddress  = pEthPktInfo->TargetIpAddress;

    // Fill out adapter info..
    //
    p1394PktInfo->SenderHwAddr.UniqueID  = pAdapter->info.LocalUniqueID;
    p1394PktInfo->SenderHwAddr.Off_Low   = pIF->recvinfo.offset.Off_Low;
    p1394PktInfo->SenderHwAddr.Off_High  = pIF->recvinfo.offset.Off_High;
    p1394PktInfo->SenderMaxRec= pAdapter->info.MaxRec;
    p1394PktInfo->SenderMaxSpeedCode= pAdapter->info.MaxSpeedCode;

    return NDIS_STATUS_SUCCESS;
}

VOID
arpUpdateEthArpCache(
    IN  PARP1394_INTERFACE      pIF,
    IN  IP_ADDRESS              DestIpAddr,
    IN  PARP_REMOTE_ETH_PARAMS  pCreateParams,  // Creation params
    IN  MYBOOL                      fCreateIfRequired,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
    Update the IP->EthernetMacAddress mapping maintained in
    pIF->RemoteEthGroup.
--*/
{
    ENTER("arpUpdateEthArpCache", 0x3a18a415)
    LOCKOBJ(pIF, pSR);

    do
    {
        ARPCB_REMOTE_ETH *pRemoteEth = NULL;
        INT             fCreated = FALSE;
        UINT            CreateFlags = 0;
        NDIS_STATUS     Status;

        DBGMARK(0xd3b27d1f);

        if (fCreateIfRequired)
        {
            CreateFlags |= RM_CREATE;
        }


        // Lookup/Create Remote IP Address
        //
        Status = RmLookupObjectInGroup(
                        &pIF->RemoteEthGroup,
                        CreateFlags,
                        (PVOID) ULongToPtr (DestIpAddr),
                        (PVOID) pCreateParams,
                        (RM_OBJECT_HEADER**) &pRemoteEth,
                        &fCreated,  // pfCreated
                        pSR
                        );
        if (FAIL(Status))
        {
            OBJLOG1(
                pIF,
                "Couldn't add remote eth entry with addr 0x%lx\n",
                DestIpAddr
                );
            UNLOCKOBJ(pIF, pSR);
            break;
        }

        UNLOCKOBJ(pIF, pSR);

        RmTmpDereferenceObject(&pRemoteEth->Hdr, pSR);


    } while (FALSE);

    EXIT()
}



NDIS_STATUS
arpGetSourceMacAddressFor1394Pkt (
    IN PARP1394_ADAPTER pAdapter,
    IN UCHAR SourceNodeAddress,
    IN BOOLEAN fIsValidSourceNodeAddress,
    OUT ENetAddr* pSourceMacAddress,
    PRM_STACK_RECORD            pSR
    )
/*++
    If the Packet has a valid Source Node Address then return it or else fail 
    the function
--*/
{
    ENetAddr InvalidMacAddress = {0,0,0,0,0,0};
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    NdisZeroMemory (pSourceMacAddress, sizeof(pSourceMacAddress));

    do
    {
        //
        // Get the Mac Address from the Node Address
        //
        if (fIsValidSourceNodeAddress == TRUE)
        {
            *pSourceMacAddress = (pAdapter->EuidMap.Node[SourceNodeAddress].ENetAddress);

        }
        else
        {
            ASSERT (fIsValidSourceNodeAddress == TRUE);
            break;
        }
        
        //
        // Is the source address all zero's 
        //
        if (NdisEqualMemory (pSourceMacAddress, &InvalidMacAddress, sizeof (ENetAddr) ) == 1)
        {
            //ASSERT (NdisEqualMemory (pSourceMacAddress, &InvalidMacAddress, sizeof (ENetAddr) ) != 1);
            // Get the New Topology
            //
            arpGetEuidTopology (pAdapter,pSR);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // The SourceMacAddress should not be a broadcast or multicast address
        //
        if (ETH_IS_BROADCAST(pSourceMacAddress)  || ETH_IS_MULTICAST(pSourceMacAddress))
        {
            ASSERT (ETH_IS_BROADCAST(pSourceMacAddress)  == FALSE);
            ASSERT (ETH_IS_MULTICAST(pSourceMacAddress) == FALSE);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        Status = NDIS_STATUS_SUCCESS;
        
    }while (FALSE);
    return Status;
    
}


NDIS_STATUS
arpEthConstructSTAEthHeader(
    IN PUCHAR pvData,
    IN UINT cbData,
    OUT ENetHeader   *pEthHdr
    )
/*++
    Constructs the Ethernet header of the STA packet .
    Expects that Source Mac Address has already been filled in

    Arguments:
    pvData - Start of the Data packet
    cbData - Length of the data
    pEthHdr - output value
--*/
    
{
    UINT LenIpData = cbData - sizeof (NIC1394_ENCAPSULATION_HEADER);
    //
    // First set the destination Mac address in the Ethernet Header
    //
    NdisMoveMemory (&pEthHdr->eh_daddr, &gSTAMacAddr, sizeof (gSTAMacAddr)); 


    //
    // Use the length of the packet to store it in the packets. Should be 0x26 or 0x7
    //

    pEthHdr->eh_type = H2N_USHORT(LenIpData);

    return NDIS_STATUS_SUCCESS;
        
}



NDIS_STATUS 
arpAddIpAddressToRemoteIp (
    PARPCB_REMOTE_IP pRemoteIp,  
    PNDIS_PACKET pNdisPacket
    )
/*++

Routine Description:
    Parse the NdisPacket and pick out the IP address. It will 
    store the Destination Ip address in the RemoteIp structure

    Assumes that the bridge is enabled and that it is making a copy
    of the packet and therefore the 
    first buffer contains the IP address

Arguments:


Return Value:
    Success - if parsing succeeded

--*/
{
    PNDIS_BUFFER    pBuffer = NULL;
    PUCHAR          pPacketStart = NULL;
    ULONG           BufferLen = 0;
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    IPAddr TargetIpAddress = 0;

    //
    // Initialize local variables 
    //
    pBuffer = pNdisPacket->Private.Head;

    pPacketStart = NdisBufferVirtualAddressSafe (pBuffer, NormalPagePriority );

    BufferLen = NdisBufferLength (pBuffer);
    
    do
    {
        ENetHeader *pENetHeader = NULL;
    
        if (pPacketStart == NULL) 
        {
            break;
        }

        if (BufferLen < (sizeof (ENetHeader)+sizeof (IPHeader)) )
        {
            // We assume that the packet is contiguous because the bridge has
            // made a copy  of the packet
            //
            ASSERT (BufferLen < (sizeof (ENetHeader)+sizeof (IPHeader)) );
            break;
        }
        pENetHeader = (ENetHeader*)pPacketStart;
        
        switch ( H2N_USHORT(pENetHeader->eh_type))
        {       
            case ARP_ETH_ETYPE_IP:
            {
                IPHeader *pIpHeader = NULL;

                pIpHeader = (IPHeader*)(pPacketStart + sizeof (ENetHeader));
                TargetIpAddress  = pIpHeader->iph_dest;

                pRemoteIp->IpAddress= TargetIpAddress  ;

                Status = NDIS_STATUS_SUCCESS;
                break;
            }
            
            case ARP_ETH_ETYPE_ARP:
            {
                ETH_ARP_PKT* pArpPkt = (ETH_ARP_PKT*)pENetHeader;
                BOOLEAN fIsTarget;
                BOOLEAN fIsSender;

                //
                // This is an arp packet. Which Ip address should we use,
                // the Target or the Sender.
                //
                fIsTarget = NdisEqualMemory (&pArpPkt->target_hw_address,
                                             &pRemoteIp->Key.ENetAddress, 
                                            ETH_LENGTH_OF_ADDRESS 
                                            );

                fIsSender = NdisEqualMemory (&pArpPkt->sender_hw_address, 
                                            &pRemoteIp->Key.ENetAddress,
                                            ETH_LENGTH_OF_ADDRESS );
                

                
                if (fIsTarget  == TRUE)
                {
                    TargetIpAddress  = pArpPkt->target_IP_address;

                }
                else if (fIsSender == TRUE) 
                {
                    TargetIpAddress  = pArpPkt->sender_IP_address;
                }
                else 
                {
                    ASSERT (!"Invalid hw Address in Arp Packet\n");
                    break;
                }

                pRemoteIp->IpAddress= TargetIpAddress;

                Status = NDIS_STATUS_SUCCESS;
                
                break;
            }
            default :
            {
                ASSERT (!"Invalid  EtherType in Packet\n");
                break;
            }
        }
        
    } while (FALSE);

    return Status;            
}
    

//
// the Bootp Code is take heavily from the bridge module
//


BOOLEAN
arpDecodeIPHeader(
    IN PUCHAR                   pHeader,
    OUT PARP_IP_HEADER_INFO    piphi
    )
/*++

Routine Description:

    Decodes basic information from the IP header (no options)

Arguments:

    pHeader                     Pointer to an IP header
    piphi                       Receives the info

Return Value:

    TRUE: header was valid
    FALSE: packet is not an IP packet

--*/
{
    // First nibble of the header encodes the packet version, which must be 4.
    if( (*pHeader >> 4) != 0x04 )
    {
        return FALSE;
    }

    // Next nibble of the header encodes the length of the header in 32-bit words.
    // This length must be at least 20 bytes or something is amiss.
    piphi->headerSize = (*pHeader & 0x0F) * 4;
    if( piphi->headerSize < 20 )
    {
        return FALSE;
    }

    // Retrieve the protocol byte (offset 10)
    piphi->protocol = pHeader[9];

    // The source IP address begins at the 12th byte (most significant byte first)
#if 0    
    piphi->ipSource = 0L;
    piphi->ipSource |= pHeader[12] << 24;
    piphi->ipSource |= pHeader[13] << 16;
    piphi->ipSource |= pHeader[14] << 8;
    piphi->ipSource |= pHeader[15];

    // The destination IP address is next
    piphi->ipTarget = 0L;
    piphi->ipTarget |= pHeader[16] << 24;
    piphi->ipTarget |= pHeader[17] << 16;
    piphi->ipTarget |= pHeader[18] << 8;
    piphi->ipTarget |= pHeader[19];
#endif
    return TRUE;
}



PUCHAR
arpIsEthBootPPacket(
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PARP_IP_HEADER_INFO     piphi
    )
/*++

Routine Description:

    Determines whether a given packet is a BOOTP packet
    Requires a phy length of six

    Different from the Bridge Code, packetLen is length of the Ip Packet

Arguments:

    pPacketData                 Pointer to the packet's data buffer
    packetLen                   Amount of data at pPacketDaa
    piphi                       Info about the IP header of this packet

Return Value:

    A pointer to the BOOTP payload within the packet, or NULL if the packet was not
    a BOOTP Packet.

--*/
{
    ENTER("arpIsEthBootPPacket",0xbcdce2dd);
    // After the IP header, there must be enough room for a UDP header and
    // a basic BOOTP packet
    if( packetLen < (UINT)piphi->headerSize + SIZE_OF_UDP_HEADER +
                    SIZE_OF_BASIC_BOOTP_PACKET)
    {
        return NULL;
    }

    // Protocol must be UDP
    if( piphi->protocol != UDP_PROTOCOL )
    {
        return NULL;
    }

    // Jump to the beginning of the UDP packet by skipping the IP header
    pPacketData += piphi->headerSize;

    // The first two bytes are the source port and should be the
    // BOOTP Client port (0x0044) or the BOOTP Server port (0x0043)
    if( (pPacketData[0] != 00) ||
        ((pPacketData[1] != 0x44) && (pPacketData[1] != 0x43)) )
    {
        return NULL;
    }

    // The next two bytes are the destination port and should be the BOOTP
    // server port (0x0043) or the BOOTP client port (0x44)
    if( (pPacketData[2] != 00) ||
        ((pPacketData[3] != 0x43) && (pPacketData[3] != 0x44)) )
    {
        return NULL;
    }

    // Skip ahead to the beginning of the BOOTP packet
    pPacketData += SIZE_OF_UDP_HEADER;

    // The first byte is the op code and should be 0x01 for a request
    // or 0x02 for a reply
    if( pPacketData[0] > 0x02 )
    {
        return NULL;
    }
    

    // The next byte is the hardware type and should be 0x01 for Ethernet
    // or 0x07 (officially arcnet) for ip1394
    //
    if( pPacketData[1] != 0x01 && pPacketData[1] != 0x07  )
    {
        return NULL;
    }

    // The next byte is the address length and should be 0x06 for Ethernet
    if( pPacketData[2] != 0x06 )
    {
        return NULL;
    }

    // Everything checks out; this looks like a BOOTP request packet.
    TR_INFO ( ("Received Bootp Packet \n"));
    EXIT()
    return pPacketData;
}



//
// The IP and UDP checksums treat the data they are checksumming as a
// sequence of 16-bit words. The checksum is carried as the bitwise
// inverse of the actual checksum (~C). The formula for calculating
// the new checksum as transmitted, ~C', given that a 16-bit word of
// the checksummed data has changed from w to w' is
//
//      ~C' = ~C + w + ~w' (addition in ones-complement)
//
// This function returns the updated checksum given the original checksum
// and the original and new values of a word in the checksummed data.
// RFC 1141
//
USHORT
arpEthCompRecalcChecksum(
    IN USHORT                   oldChecksum,
    IN USHORT                   oldWord,
    IN USHORT                   newWord
    )
{
    ULONG                       sum,XSum;
    ULONG                       RfcSum, RfcXSum;



    sum = oldChecksum + oldWord + ((~(newWord)) & 0xFFFF);
    XSum =  (USHORT)((sum & 0xFFFF) + (sum >> 16));

    RfcSum = oldWord + ((~(newWord)) & 0xffff);
    RfcSum  += oldChecksum;
    RfcSum   = (RfcSum& 0xffff) + (RfcSum  >>16);
    RfcXSum  = (RfcSum + (RfcSum  >>16));

    ASSERT (RfcXSum  == XSum);
    return (USHORT)RfcXSum;
    

}



VOID
arpEthRewriteBootPClientAddress(
    IN PUCHAR                   pPacketData,
    IN PARP_IP_HEADER_INFO      piphi,
    IN PUCHAR                   newMAC
    )
/*++

Routine Description:

    This function writes New MAC to the HW address embedded in the DHCP packet

Arguments:
    
Return Value:


--*/
{
    USHORT                      checkSum;
    PUCHAR                      pBootPData, pCheckSum, pDestMAC, pSrcMAC;
    UINT                        i;

    // The BOOTP packet lives right after the UDP header
    pBootPData = pPacketData + piphi->IpHeaderOffset + piphi->headerSize + SIZE_OF_UDP_HEADER;

    // The checksum lives at offset 7 in the UDP packet.
    pCheckSum = pPacketData + piphi->IpHeaderOffset + piphi->headerSize + 6;
    checkSum = 0;
    checkSum = pCheckSum[0] << 8;
    checkSum |= pCheckSum[1];

    if (checkSum == 0xffff)
    {
        // Tcpip Illustrated - Vol 1 'UDP Checksum'
        checkSum = 0;
    }

    // Replace the client's hardware address, updating the checksum as we go.
    // The client's hardware address lives at offset 29 in the BOOTP packet
    pSrcMAC = newMAC;
    pDestMAC = &pBootPData[28];

    for( i = 0 ; i < ETH_LENGTH_OF_ADDRESS / 2; i++ )
    {
        checkSum = arpEthCompRecalcChecksum( checkSum,
                                           (USHORT)(pDestMAC[0] << 8 | pDestMAC[1]),
                                           (USHORT)(pSrcMAC[0] << 8 | pSrcMAC[1]) );

        pDestMAC[0] = pSrcMAC[0];
        pDestMAC[1] = pSrcMAC[1];

        pDestMAC += 2;
        pSrcMAC += 2;
    }

    // Write the new checksum back out
    pCheckSum[0] = (UCHAR)(checkSum >> 8);
    pCheckSum[1] = (UCHAR)(checkSum & 0xFF);








}





NDIS_STATUS
arpEthBootP1394ToEth(
    IN  PARP1394_INTERFACE          pIF,                // NOLOCKIN NOLOCKOUT
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  PREMOTE_DEST_KEY             pDestAddress, 
    IN  PUCHAR                       pucNewData,
    IN  PUCHAR                       pBootPData,
    IN  PARP_IP_HEADER_INFO          piphi,
    IN  PRM_STACK_RECORD             pSR
    )        
/*++

Routine Description:

    This function handles the translation from 1394 to Eth. Essentially, 
    we look at the SRC MAC address in the Ethernet Packet, make sure the HW 
    Addr embedded is the same as the SRC MAC address.

    We also make an entry in our table - XID, OldHWAddress, NewHWAddress. 
    
    The packet has already been rewritten into Ethernet by this time

Arguments:
    pIF - pInterface
    Direction - Eth To 1394 or  1394-To-Eth
    pDestAddress - the Eth Hw address used in the translation
    pucNewData - the Data in the new packet
    pBootPdata - pointer to the Bootp part of the packet
    piphi - ip header info
    
Return Value:


--*/
{
    BOOLEAN         bIsRequest = FALSE;
    BOOLEAN         bIsResponse;
    ARP_BOOTP_INFO  InfoBootP;
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    ENetHeader*      pEnetHeader = (ENetHeader*)pucNewData;
    ENetAddr         NewMAC;
    BOOLEAN         bIs1394HwAlreadyInDhcpRequest;

    ENTER ("arpEthBootP1394ToEth", 0x66206f0b);
    NdisZeroMemory (&InfoBootP, sizeof(InfoBootP));
    //
    // Is this a DHCP Request 
    //

    do
    {
        bIsResponse = ARP_IS_BOOTP_RESPONSE(pBootPData);

        if (bIsResponse == TRUE)
        {
            //
            // if this is a DHCP Reply , the do not touch the packet - there are no inconsistencies.
            //
            Status = NDIS_STATUS_SUCCESS;
            break;

        }
        
        
        if( FALSE == arpEthPreprocessBootPPacket(pIF,pucNewData, pBootPData, &bIsRequest, &InfoBootP,pSR) )
        {
            // This is an invalid packet
            ASSERT (FALSE);
            break;
        }

        
        //
        // This is a DHCP Request
        //


        //
        // if the HWAddr and the Src Mac address the same.
        // then are job is already done.
        //
        //At this point the 1394 packet is already in Ethernet format

        NewMAC = pEnetHeader->eh_saddr;

        TR_INFO(("DHCP REQUEST target MAC  %x %x %x %x %x %x , SrcMAC %x %x %x %x %x %x \n",
                InfoBootP.requestorMAC.addr[0],InfoBootP.requestorMAC.addr[1],InfoBootP.requestorMAC.addr[2],
                InfoBootP.requestorMAC.addr[3],InfoBootP.requestorMAC.addr[4],InfoBootP.requestorMAC.addr[5],
                NewMAC.addr[0],NewMAC.addr[1],NewMAC.addr[2],
                NewMAC.addr[3],NewMAC.addr[4],NewMAC.addr[5]));

        bIs1394HwAlreadyInDhcpRequest = NdisEqualMemory (&InfoBootP.requestorMAC, &NewMAC , sizeof (ENetAddr)) ;

        
        if (TRUE == bIs1394HwAlreadyInDhcpRequest )
        {
            //
            // Nothing to do , id the HW add and the src MAC are equal
            //
            Status = NDIS_STATUS_SUCCESS;
            break;            
        }

        
        //
        // Make an entry into our table - consisting of the XID. OldHW Address and 
        // New HY address
        // We've already done this. 
        
        //
        // Overwrite the hw address embedded in the DHCP packet. - make sure to rewrite the 
        // checksum.
        //
        arpEthRewriteBootPClientAddress(pucNewData,piphi,&NewMAC.addr[0]);

        TR_VERB (("arpEthBootP1394ToEth  -Dhcp packet Rewriting BootpClient Address\n"));

        
        Status = NDIS_STATUS_SUCCESS;
    }while (FALSE);

    EXIT();
    return Status;;
}





NDIS_STATUS
arpEthBootPEthTo1394(
    IN  PARP1394_INTERFACE          pIF,                // NOLOCKIN NOLOCKOUT
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  PREMOTE_DEST_KEY             pDestAddress, // OPTIONAL
    IN  PUCHAR                       pucNewData,
    IN  PUCHAR                       pBootPData,
    IN PARP_IP_HEADER_INFO           piphi,
    IN  PRM_STACK_RECORD                pSR
    )        
/*++

Routine Description:

    This function translates BootP packet from the Ethernet Net to 1394. if this is a dhcp reply (offer), 
    then we need to rewrite the Hw Addr in the DHCP packlet

Arguments:
    
    pIF - pInterface
    Direction - Eth To 1394 or  1394-To-Eth
    pDestAddress - the Eth Hw address used in the translation
    pucNewData - the Data in the new packet
    
Return Value:


--*/
{
    BOOLEAN         fIsBootpRequest = FALSE;
    ARP_BOOTP_INFO  InfoBootP;
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    ENetHeader*      pEnetHeader = (ENetHeader*)pucNewData;
    ENetAddr         NewMAC;
    PUCHAR          pMACInPkt = NULL;
    BOOLEAN         bIs1394HwAlreadyInDhcpResponse = FALSE;

    ENTER("arpEthBootPEthTo1394", 0x383f9e33);
    NdisZeroMemory (&InfoBootP, sizeof(InfoBootP));
    //
    // Is this a DHCP Request 
    //

    do
    {

        // Do a quick check .
        fIsBootpRequest = ARP_IS_BOOTP_REQUEST(pBootPData);

        if (fIsBootpRequest  == TRUE)
        {
            //
            // if this is a DHCP Request, the do not modify the packet - 
            // there are no inconsistencies in this code path.
            //
            Status = NDIS_STATUS_SUCCESS;
            break;

        }

        
        if( FALSE == arpEthPreprocessBootPPacket(pIF,pucNewData, pBootPData, &fIsBootpRequest, &InfoBootP,pSR) )
        {
            // This is an uninteresting packet
            break;
        }

        //
        // InfoBootP has the original HW addr used in the corresponding Dhcp request.
        // We'll put the hw Addr back into dhcp reply
        

            
        //
        //offset of the chaddr in bootp packet
        //
        pMACInPkt = &pBootPData[28];  

        

        TR_INFO(("DHCP RESPONSE target MAC  %x %x %x %x %x %x , SrcMAC %x %x %x %x %x %x \n",
                InfoBootP.requestorMAC.addr[0],InfoBootP.requestorMAC.addr[1],InfoBootP.requestorMAC.addr[2],
                InfoBootP.requestorMAC.addr[3],InfoBootP.requestorMAC.addr[4],InfoBootP.requestorMAC.addr[5],
                pMACInPkt[0],pMACInPkt[1],pMACInPkt[2],
                pMACInPkt[3],pMACInPkt[4],pMACInPkt[5]));

        //
        // Is the HWAddr in the dhcp packet the correct one.
        //
        
        bIs1394HwAlreadyInDhcpResponse = NdisEqualMemory(&InfoBootP.requestorMAC, pMACInPkt, sizeof (InfoBootP.requestorMAC)) ;
        
        if (TRUE == bIs1394HwAlreadyInDhcpResponse)
        {
            //
            // Yes, they are equal, we do not rewrite the packet
            //
            Status = NDIS_STATUS_SUCCESS;
            break;

        }


                    
        TR_VERB( ("DHCP RESPONSE  Rewriting Bootp Response pBootpData %p Before\n",pBootPData));

        //
        // Replace the CL Addr in the DHCP packet with the original HW addr
        //
        arpEthRewriteBootPClientAddress(pucNewData,piphi,&InfoBootP.requestorMAC.addr[0]);

        
        //
        // recompute the checksum
        //

        Status = NDIS_STATUS_SUCCESS;

        } while (FALSE);

    EXIT();
    return Status;
}



NDIS_STATUS
arpEthModifyBootPPacket(
    IN  PARP1394_INTERFACE          pIF,                // NOLOCKIN NOLOCKOUT
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  PREMOTE_DEST_KEY             pDestAddress, // OPTIONAL
    IN  PUCHAR                       pucNewData,
    IN  ULONG                         PacketLength,
    IN  PRM_STACK_RECORD                pSR
    )        
/*++

Routine Description:

    This function contains the code to process a Bootp Packet. This basically ensures that the 
    MAC address entered in the DHCP packet matches the Src Mac address of the Ethernet Packet 
    (in the 1394 - Eth mode). In the other case (Eth-1394 mode), we replace the Ch address with 
    the correct CH addr (if we have to). 
    

Arguments:
    pIF - pInterface
    Direction - Eth To 1394 or  1394-To-Eth
    pDestAddress - the Eth Hw address used in the translation
    pucNewData - the Data in the new packet
    
Return Value:


--*/
{
    ARP_IP_HEADER_INFO      iphi;
    PUCHAR                  pBootPData = NULL;
    NDIS_STATUS             Status= NDIS_STATUS_FAILURE;
    PARP1394_ADAPTER        pAdapter = (PARP1394_ADAPTER)RM_PARENT_OBJECT(pIF);
    ULONG                   IpHeaderOffset = 0;
    PUCHAR                  pIPHeader = NULL;
    BOOLEAN                 fIsIpPkt;
    NdisZeroMemory(&iphi, sizeof (iphi));
    

    do
    {
        //
        // if we are not in bridge mode - exit.
        //
        if (ARP_BRIDGE_ENABLED(pAdapter) == FALSE)
        {
            break;
        }       

        if (Direction == ARP_ICS_FORWARD_TO_ETHERNET)
        {
            // Packet is in the ethernet format
            IpHeaderOffset = ETHERNET_HEADER_SIZE; 
        
        }
        else
        {
            // Packet is in the IP 1394 format
            IpHeaderOffset = sizeof (NIC1394_UNFRAGMENTED_HEADER); //4
        }

        iphi.IpHeaderOffset = IpHeaderOffset;
        iphi.IpPktLength = PacketLength - IpHeaderOffset;
        pIPHeader = pucNewData + IpHeaderOffset ;

        //
        // if this is not a bootp packet -exit
        //
        fIsIpPkt = arpDecodeIPHeader (pIPHeader , &iphi);

        if (fIsIpPkt == FALSE)
        {
            //
            // not an IP pkt
            //
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
            
        
        pBootPData  = arpIsEthBootPPacket (pIPHeader ,PacketLength-IpHeaderOffset, &iphi);

        if (pBootPData == NULL)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
        //
        // are we doing 1394 - to-  Eth
        //
        if (Direction == ARP_ICS_FORWARD_TO_ETHERNET)
        {

            Status = arpEthBootP1394ToEth(pIF, Direction,pDestAddress,pucNewData,pBootPData,&iphi,  pSR);

        }
        else
        {
            //
            // are we doing Eth to 1394
            //
            Status = arpEthBootPEthTo1394(pIF, Direction,pDestAddress,pucNewData,pBootPData , &iphi,pSR);

        }
        Status = NDIS_STATUS_SUCCESS;
    }while (FALSE);
    
    // else we are doing Eth to 1394
    return Status;
}


//
// This function is taken verbatim from the bridge
//


BOOLEAN
arpEthPreprocessBootPPacket(
    IN PARP1394_INTERFACE       pIF,
    IN PUCHAR                   pPacketData,
    IN PUCHAR                   pBootPData,     // Actual BOOTP packet
    OUT PBOOLEAN                pbIsRequest,
    PARP_BOOTP_INFO             pInfoBootP,
    PRM_STACK_RECORD           pSR
    )
/*++

Routine Description:

    Does preliminary processing of a BOOTP packet common to the inbound and outbound case

Arguments:

    pPacketData                 Pointer to a packet's data buffer
    pBootPData                  Pointer to the BOOTP payload within the packet
    pAdapt                      Receiving adapter (or NULL if this packet is outbound from
                                    the local machine)
    pbIsRequest                 Receives a flag indicating if this is a BOOTP request
    ppTargetAdapt               Receives the target adapter this packet should be relayed to
                                    (only valid if bIsRequest == FALSE and return == TRUE)
    requestorMAC                   The MAC address this packet should be relayed to (valid under
                                    same conditions as ppTargetAdapt)

Return Value:

    TRUE : packet was processed successfully
    FALSE : an error occured or something is wrong with the packet

--*/
{
    PARP1394_ETH_DHCP_ENTRY pEntry= NULL;
    ULONG                       xid;
    NDIS_STATUS                 Status = NDIS_STATUS_FAILURE;
    ENTER ("arpEthPreprocessBootPPacket",0x25427efc);

    // Decode the xid (bytes 5 through 8)
    xid = 0L;
    xid |= pBootPData[4] << 24;
    xid |= pBootPData[5] << 16;
    xid |= pBootPData[6] << 8;
    xid |= pBootPData[7];

    // Byte 0 is the operation; 1 for a request, 2 for a reply
    if( pBootPData[0] == 0x01 )
    {
        ULONG                 bIsNewEntry = FALSE;

        // This is a request. We need to note the correspondence betweeen
        // this client's XID and its adapter and MAC address

        TR_INFO(("DHCP REQUEST XID: %x , HW %x %x %x %x %x %x \n", xid, 
                    pBootPData[28],pBootPData[29],pBootPData[30],pBootPData[31],pBootPData[32],pBootPData[33]));

        Status = RmLookupObjectInGroup(
                    &pIF->EthDhcpGroup,
                    RM_CREATE,
                    (PVOID) &xid,             // pKey
                    (PVOID) &xid,             // pvCreateParams
                    &(PRM_OBJECT_HEADER)pEntry,
                    &bIsNewEntry ,
                    pSR
                    );


        if( pEntry != NULL )
        {
            if( bIsNewEntry )
            {
                // Initialize the entry.
                // The client's hardware address is at offset 29
                ETH_COPY_NETWORK_ADDRESS( &pEntry->requestorMAC.addr[0], &pBootPData[28] );

                pEntry->xid = xid;

            }
            else
            {
                //
                // An entry already existed for this XID. This is fine if the existing information
                // matches what we're trying to record, but it's also possible that two stations
                // decided independently to use the same XID, or that the same station changed
                // apparent MAC address and/or adapter due to topology changes. Our scheme breaks
                // down under these circumstances.
                //
                // Either way, use the most recent information possible; clobber the existing
                // information with the latest.
                //

                LOCKOBJ(pEntry, pSR);

                {
                    UINT            Result;
                    ETH_COMPARE_NETWORK_ADDRESSES_EQ( &pEntry->requestorMAC.addr[0], &pBootPData[28], &Result );

                    // Warn if the data changed, as this probably signals a problem
                    if( Result != 0 )
                    {
                        
                        TR_WARN(("ARP1394 WARNING: Station with MAC address %02x:%02x:%02x:%02x:%02x:%02x is using DHCP XID %x at the same time as station %02x:%02x:%02x:%02x:%02x:%02x!\n",
                                          pBootPData[28], pBootPData[29], pBootPData[30], pBootPData[31], pBootPData[32], pBootPData[33],
                                          xid, pEntry->requestorMAC.addr[0], pEntry->requestorMAC.addr[1], pEntry->requestorMAC.addr[2],
                                          pEntry->requestorMAC.addr[3], pEntry->requestorMAC.addr[4], pEntry->requestorMAC.addr[5] ));
                    }
                }

                ETH_COPY_NETWORK_ADDRESS( &pEntry->requestorMAC.addr[0], &pBootPData[28] );

                UNLOCKOBJ (pEntry, pSR);
            }
        
            RmTmpDereferenceObject (&pEntry->Hdr, pSR);
            
        }
        else
        {
            // This packet could not be processed
            TR_INFO(("Couldn't create table entry for BOOTP packet!\n"));
            return FALSE;
        }

        *pbIsRequest = TRUE;
        pInfoBootP->bIsRequest = TRUE; 

        ETH_COPY_NETWORK_ADDRESS(&pInfoBootP->requestorMAC,&pEntry->requestorMAC);

        return TRUE;
    }
    else if ( pBootPData[0] == 0x02 )
    {
        //
        // NON-CREATE search
        // Look up the xid for this transaction to recover the MAC address of the client
        //

        TR_INFO (("Seeing a DHCP response xid %x mac %x %x %x %x %x %x \n", 
                xid, pBootPData[28],pBootPData[29],pBootPData[30],pBootPData[31],pBootPData[32],pBootPData[33]));
        Status = RmLookupObjectInGroup(
                    &pIF->EthDhcpGroup,
                    0,                        // do not create
                    (PVOID) &xid,             // pKey
                    (PVOID) &xid,             // pvCreateParams
                    &(PRM_OBJECT_HEADER)pEntry,
                    NULL,
                    pSR
                    );


        if( pEntry != NULL )
        {
            LOCKOBJ( pEntry, pSR);
            ETH_COPY_NETWORK_ADDRESS( &pInfoBootP->requestorMAC.addr, pEntry->requestorMAC.addr );
            UNLOCKOBJ( pEntry, pSR );

            //
            // We will use this adapter outside the table lock. NULL is a permissible
            // value that indicates that the local machine is the requestor for
            // this xid.
            //
            RmTmpDereferenceObject(&pEntry->Hdr, pSR);
        }

        if( pEntry != NULL )
        {
            *pbIsRequest = FALSE;
            return TRUE;
        }
        else
        {
            TR_INFO (("DHCP Response:Could not find xid %x in DHCP table \n",xid);)
            return FALSE;
        }
    }
    else
    {
        // Someone passed us a crummy packet
        return FALSE;
    }
}

#if DBG
VOID
Dump(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )

    // Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
    // For example, with 'ulGroup' of 1, 2, and 4:
    //
    // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    // 0000 0000 0000 0000 0000 0000 0000 0000 |................|
    // 00000000 00000000 00000000 00000000 |................|
    //
    // If 'fAddress' is true, the memory address dumped is prepended to each
    // line.
    //
{
    while (cb)
    {
        INT cbLine;

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
        
    }
}
#endif


#if DBG
VOID
DumpLine(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress)
        DbgPrint( "N13: %p: ", p );
    else
        DbgPrint( "N13: " );

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\fake.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    fake.c

Abstract:

    Fake versions of various external calls (ndis, ip...).
    Used for debugging and component testing only.

    To enable, define ARPDBG_FAKE_APIS in ccdefs.h

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     03-22-98    Created

Notes:

--*/
#include <precomp.h>


#if ARPDBG_FAKE_APIS

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_FAKE


//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================



#if RM_EXTRA_CHECKING
    #define LOCKROOTOBJ(_pHdr, _pSR)            \
            RmWriteLockObject(                  \
                    (_pHdr)->pRootObject,       \
                    0,                          \
                    (_pSR)                      \
                    )
#else       // !RM_EXTRA_CHECKING
    #define LOCKROOTOBJ(_pHdr, _pSR)            \
            RmWriteLockObject(                  \
                    (_pHdr)->pRootObject,       \
                    (_pSR)                      \
                    )
#endif      // !RM_EXTRA_CHECKING

#define UNLOCKROOTOBJ(_pHdr, _pSR)          \
        RmUnlockObject(                     \
                (_pHdr)->pRootObject,       \
                (_pSR)                      \
                )

typedef
VOID
(*PFN_FAKE_COMPLETIONCALLBACK)(
    struct _FAKETASK *pFTask
);


// This task structure holds a union of the information required for the completions
// of the various apis that are being faked.
//
typedef struct _FAKETASK
{
    RM_TASK TskHdr;

    //  Client's context to pass back
    //
    PVOID                   pClientContext;

    // Client object the call is associated.
    //
    PRM_OBJECT_HEADER       pOwningObject;

    //  The status to report in the asynchronous completion fn.
    //
    NDIS_STATUS             Status;

    //  Milliseconds to delay before calling the async completion fn.
    //
    UINT                    DelayMs;

    //  Wheather to call the completion fn at DPC or PASSIVE IRQL level.
    //
    INT                     fDpc;

    // This is used solely to switch to DPC level when asynchronously
    // calling the completion callback.
    //
    NDIS_SPIN_LOCK          NdisLock;

    // This is used solely to wait DelayMs ms if required.
    //
    NDIS_TIMER              Timer;

    // This is used solely to switch to a different (and PASSIVE) context.
    //
    NDIS_WORK_ITEM          WorkItem;

    // This is used only for fake NdisClMakeCall
    //
    PCO_CALL_PARAMETERS     CallParameters;

    // This is used only for fake NdisCoSendPackets
    //
    PNDIS_PACKET            pNdisPacket;

    // The actual completion callback function;
    //
    PFN_FAKE_COMPLETIONCALLBACK pfnCompletionCallback;

} FAKETASK;


VOID
arpFakeMakeCallCompletionCallback(
    struct _FAKETASK *pFTask
);


VOID
arpFakeCloseCallCompletionCallback(
    struct _FAKETASK *pFTask
);


VOID
arpFakeSendPacketsCompletionCallback(
    struct _FAKETASK *pFTask
);


NDIS_STATUS
arpDbgAllocateFakeTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
arpDbgFakeTaskDelete(
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

RM_STATIC_OBJECT_INFO
FakeTasks_StaticInfo = 
{
    0,                      // TypeUID
    0,                      // TypeFlags
    "FAKE Task",            // TypeName
    0,                      // Timeout

    NULL,                   // pfnCreate
    arpDbgFakeTaskDelete,   // pfnDelete
    NULL,                   // pfnVerifier

    0,                      // length of resource table
    NULL                    // Resource Table
};


NDIS_STATUS
arpDbgFakeCompletionTask(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );


//=========================================================================
//                  F A K E      N D I S     E N T R Y P O I N T S
//=========================================================================


NDIS_STATUS
arpDbgFakeNdisClMakeCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    OUT PNDIS_HANDLE            NdisPartyHandle,        OPTIONAL
    IN  PRM_OBJECT_HEADER       pOwningObject,
    IN  PVOID                   pClientContext,
    IN  PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Fake version of NdisClMakeCall.

--*/
{
    ENTER("FakeNdisClMakeCall", 0x3d4195ae)
    NDIS_STATUS Status;
    NDIS_STATUS AsyncStatus;
    UINT DelayMs;
    
    DBGMARK(0xced41a61);
    RM_ASSERT_NOLOCKS(pSR);
    ASSERT(NdisPartyHandle==NULL);
    ASSERT(ProtocolPartyContext==NULL);
    ASSERT(NdisVcHandle != NULL);


    do
    {
        static
        OUTCOME_PROBABILITY
        StatusOutcomes[] = 
        {
            {NDIS_STATUS_SUCCESS,   1},     // Return NDIS_STATUS_SUCCESS
            {NDIS_STATUS_FAILURE,   1}      // Return NDIS_STATUS_FAILURE
        };

        static
        OUTCOME_PROBABILITY
        DelayMsOutcomes[] = 
        {
            {0,         5},     // Delay 0ms, etc...
            {10,        5},
            {100,       5},
            {1000,      1},
            {10000,     1}
        };

        static
        OUTCOME_PROBABILITY
        AsyncOutcomes[] = 
        {
            {TRUE,      1},     // Complete Async
            {FALSE,     1}      // Complete Sync
        };
        
        static
        OUTCOME_PROBABILITY
        DpcOutcomes[] = 
        {
            {TRUE,      1},     // Complete at DPC level
            {FALSE,     1}      // Complete at PASSIVE level
        };

        FAKETASK *pMCTask;


        // We serialize calls to arpGenRandomInt by claiming the root object's
        // lock...
        //
        LOCKROOTOBJ(pOwningObject, pSR);

        // Get the status we're supposed to return.
        //
        Status =
        AsyncStatus = (NDIS_STATUS) arpGenRandomInt(
                                     StatusOutcomes,
                                     ARRAY_LENGTH(StatusOutcomes)
                                     );

        // Determine if we're to return synchronously or complete
        // asynchronously...
        //
        if (!arpGenRandomInt(AsyncOutcomes, ARRAY_LENGTH(AsyncOutcomes)))
        {
            // We're to return synchronously.
            //
            UNLOCKROOTOBJ(pOwningObject, pSR);
            break;
        }

        // 
        // We're to complete asynchronously...
        //

        DelayMs             = arpGenRandomInt(
                                        DelayMsOutcomes,
                                        ARRAY_LENGTH(DelayMsOutcomes)
                                        );

        if (DelayMs == 0)
        {
            // We're to immediately indicatie async completion...
            // (we don't mess with IRQ levels if we're returning here..)
            //
            UNLOCKROOTOBJ(pOwningObject, pSR);
            ArpCoMakeCallComplete(
                        AsyncStatus,
                        pClientContext,
                        NULL,
                        CallParameters
                        );
            Status = NDIS_STATUS_PENDING;
            break;
        }

        // We're to indicate status sometime in the future -- in a different context.
        // Start a task to do this...
        //

        Status = arpDbgAllocateFakeTask(
                            pOwningObject,              // pParentObject,
                            arpDbgFakeCompletionTask,   // pfnHandler,
                            0,                          // Timeout,
                            "Task:Fake NdisClMakeCall", // szDescription,
                            &(PRM_TASK) pMCTask,
                            pSR
                            );
        if (FAIL(Status))
        {
            // Couldn't allocate task. Call callback right away...
            //
            UNLOCKROOTOBJ(pOwningObject, pSR);
            ArpCoMakeCallComplete(
                        AsyncStatus,
                        pClientContext,
                        NULL,
                        CallParameters
                        );
            Status = NDIS_STATUS_PENDING;
            break;
        }

        
        // Initialize pMCTask...
        //
        pMCTask->pClientContext     = pClientContext;
        pMCTask->pOwningObject      = pOwningObject;
        pMCTask->Status             = AsyncStatus;
        pMCTask->DelayMs            = DelayMs;
        pMCTask->fDpc               = arpGenRandomInt(
                                            DpcOutcomes,
                                            ARRAY_LENGTH(DpcOutcomes)
                                            );
        pMCTask->CallParameters =  CallParameters;
        pMCTask->pfnCompletionCallback = arpFakeMakeCallCompletionCallback;

        UNLOCKROOTOBJ(pOwningObject, pSR);

        (void) RmStartTask(
                    &pMCTask->TskHdr,
                    0, // UserParam (unused)
                    pSR
                    );

        Status = NDIS_STATUS_PENDING;

    } while (FALSE);


    RM_ASSERT_NOLOCKS(pSR);
    EXIT();

    return Status;
}


NDIS_STATUS
arpDbgFakeNdisClCloseCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle         OPTIONAL,
    IN  PVOID                   Buffer                  OPTIONAL,
    IN  UINT                    Size,                   OPTIONAL
    IN  PRM_OBJECT_HEADER       pOwningObject,
    IN  PVOID                   pClientContext,
    IN  PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Fake version of NdisClCloseCall.

--*/
{
    ENTER("FakeNdisClCloseCall", 0x7d8bbd3c)
    NDIS_STATUS Status;
    NDIS_STATUS AsyncStatus;
    UINT        DelayMs;
    
    DBGMARK(0x228fac3a);
    RM_ASSERT_NOLOCKS(pSR);
    ASSERT(NdisPartyHandle==NULL);
    ASSERT(NdisVcHandle != NULL);


    do
    {

        static
        OUTCOME_PROBABILITY
        DelayMsOutcomes[] = 
        {
            {0,         5},     // Delay 0ms, etc...
            {10,        5},
            {100,       5},
            {1000,      1},
            {10000,     1}
        };

        static
        OUTCOME_PROBABILITY
        AsyncOutcomes[] = 
        {
            {TRUE,      1},     // Complete Async
            {FALSE,     1}      // Complete Sync
        };
        
        static
        OUTCOME_PROBABILITY
        DpcOutcomes[] = 
        {
            {TRUE,      1},     // Complete at DPC level
            {FALSE,     1}      // Complete at PASSIVE level
        };

        FAKETASK *pCCTask;


        // We serialize calls to arpGenRandomInt by claiming the root object's
        // lock...
        //
        LOCKROOTOBJ(pOwningObject, pSR);

        // Get the status we're supposed to return.
        //
        Status =
        AsyncStatus = NDIS_STATUS_SUCCESS; // We never fail this call.

        // Determine if we're to return synchronously or complete
        // asynchronously...
        //
        if (!arpGenRandomInt(AsyncOutcomes, ARRAY_LENGTH(AsyncOutcomes)))
        {
            // We're to return synchronously.
            //
            UNLOCKROOTOBJ(pOwningObject, pSR);
            break;
        }

        // 
        // We're to complete asynchronously...
        //

        DelayMs             = arpGenRandomInt(
                                        DelayMsOutcomes,
                                        ARRAY_LENGTH(DelayMsOutcomes)
                                        );

        if (DelayMs == 0)
        {
            // We're to immediately indicatie async completion...
            // (we don't mess with IRQ levels if we're returning here..)
            //
            UNLOCKROOTOBJ(pOwningObject, pSR);
            ArpCoCloseCallComplete(
                    AsyncStatus,
                    pClientContext,
                    NULL
                    );
            Status = NDIS_STATUS_PENDING;
            break;
        }

        Status = arpDbgAllocateFakeTask(
                            pOwningObject,          // pParentObject,
                            arpDbgFakeCompletionTask,   // pfnHandler,
                            0,                          // Timeout,
                            "Task:Fake NdisClCloseCall", // szDescription,
                            &(PRM_TASK) pCCTask,
                            pSR
                            );
        if (FAIL(Status))
        {
            // Couldn't alloc task; lets call callback right now and return pending.
            //
            UNLOCKROOTOBJ(pOwningObject, pSR);
            ArpCoCloseCallComplete(
                    AsyncStatus,
                    pClientContext,
                    NULL
                    );
            Status = NDIS_STATUS_PENDING;
            break;
        }

        
        // Initialize pCCTask...
        //
        pCCTask->pClientContext     = pClientContext;
        pCCTask->pOwningObject      = pOwningObject;
        pCCTask->Status             = AsyncStatus;
        pCCTask->DelayMs            = DelayMs;
        pCCTask->fDpc               = arpGenRandomInt(
                                            DpcOutcomes,
                                            ARRAY_LENGTH(DpcOutcomes)
                                            );
        pCCTask->pfnCompletionCallback = arpFakeCloseCallCompletionCallback;

        UNLOCKROOTOBJ(pOwningObject, pSR);

        (void) RmStartTask(
                    &pCCTask->TskHdr,
                    0, // UserParam (unused)
                    pSR
                    );

        Status = NDIS_STATUS_PENDING;

    } while (FALSE);


    RM_ASSERT_NOLOCKS(pSR);
    EXIT();

    return Status;
}


VOID
arpDbgFakeNdisCoSendPackets(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets,
    IN  PRM_OBJECT_HEADER       pOwningObject,
    IN  PVOID                   pClientContext
    )
/*++

Routine Description:

    Fake version of NdisCoSendPackets.

--*/
{
    ENTER("FakeNdisCoSendPackets", 0x98c6a8aa)
    NDIS_STATUS Status;
    NDIS_STATUS AsyncStatus;
    UINT        DelayMs;
    RM_DECLARE_STACK_RECORD(sr)
    
    DBGMARK(0x3be1b902);
    ASSERT(NumberOfPackets==1);

    do
    {
        static
        OUTCOME_PROBABILITY
        StatusOutcomes[] = 
        {
            {NDIS_STATUS_SUCCESS,   1},     // Return NDIS_STATUS_SUCCESS
            {NDIS_STATUS_FAILURE,   1}      // Return NDIS_STATUS_FAILURE
        };

        static
        OUTCOME_PROBABILITY
        DelayMsOutcomes[] = 
        {
            {0,         5},     // Delay 0ms, etc...
            {10,        5},
            {100,       5},
            {1000,      1},
            {10000,     1}
        };
        
        static
        OUTCOME_PROBABILITY
        DpcOutcomes[] = 
        {
            {TRUE,      1},     // Complete at DPC level
            {FALSE,     1}      // Complete at PASSIVE level
        };

        FAKETASK *pSPTask;


        // We serialize calls to arpGenRandomInt by claiming the root object's
        // lock...
        //
        LOCKROOTOBJ(pOwningObject, &sr);

        // Get the status we're supposed to return.
        //
        Status =
        AsyncStatus = (NDIS_STATUS) arpGenRandomInt(
                                     StatusOutcomes,
                                     ARRAY_LENGTH(StatusOutcomes)
                                     );

        // Compute the delay amount.
        //
        DelayMs             = arpGenRandomInt(
                                            DelayMsOutcomes,
                                            ARRAY_LENGTH(DelayMsOutcomes)
                                            );
        if (DelayMs == 0)
        {
            UNLOCKROOTOBJ(pOwningObject, &sr);
            // We're to immediately indicatie async completion...
            // (we don't mess with IRQ levels if we're returning here..)
            //
            ArpCoSendComplete(
                AsyncStatus,
                pClientContext,
                *PacketArray
                );
            break;
        }

        //
        // Nonzero delay -- start task to complete this.
        //

        Status = arpDbgAllocateFakeTask(
                            pOwningObject,              // pParentObject,
                            arpDbgFakeCompletionTask,   // pfnHandler,
                            0,                          // Timeout,
                            "Task:Fake NdisCoSendPackets", // szDescription,
                            &(PRM_TASK) pSPTask,
                            &sr
                            );
        if (FAIL(Status))
        {
            UNLOCKROOTOBJ(pOwningObject, &sr);
            // Fail...
            //
            ArpCoSendComplete(
                AsyncStatus,
                pClientContext,
                *PacketArray
                );
            break;
        }

        
        // Initialize pSPTask...
        //
        pSPTask->pClientContext     = pClientContext;
        pSPTask->pOwningObject      = pOwningObject;
        pSPTask->Status             = AsyncStatus;
        pSPTask->DelayMs            = DelayMs;
        pSPTask->fDpc               = arpGenRandomInt(
                                            DpcOutcomes,
                                            ARRAY_LENGTH(DpcOutcomes)
                                            );
        pSPTask->pNdisPacket        = *PacketArray;
        pSPTask->pfnCompletionCallback = arpFakeSendPacketsCompletionCallback;

        UNLOCKROOTOBJ(pOwningObject, &sr);

        (void) RmStartTask(
                    &pSPTask->TskHdr,
                    0, // UserParam (unused)
                    &sr
                    );

        Status = NDIS_STATUS_PENDING;

    } while (FALSE);

    RM_ASSERT_NOLOCKS(&sr);
    EXIT();

}


NDIS_STATUS
arpDbgFakeCompletionTask(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        This task is to complete the fake api asynchronously after the
        specified delay, with the specified status, and at the specified
        IRQL (passive/dpc).

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    FAKETASK          * pFTask =  (FAKETASK *) pTask;
    ENTER("FakeCompletionTask", 0xc319c5c2)

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_ResumedAfterDelay,
        PEND_SwitchedToAsync,
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {

            TR_WARN((
                "START: Delay=%lu; fDpc=%lu; Status=%lu\n",
                    pFTask->DelayMs,
                    pFTask->fDpc,
                    pFTask->Status
                ));

            if (pFTask->DelayMs!=0)
            {
                //  Non-zero delay -- let's resume after the delay...
                //
                RmSuspendTask(pTask, PEND_ResumedAfterDelay, pSR);

                RmResumeTaskDelayed(
                    pTask, 
                    0,
                    pFTask->DelayMs,
                    &pFTask->Timer,
                    pSR
                    );
            }
            else
            {
                // No delay is requested. Switch to async right away...
                //
                RmSuspendTask(pTask, PEND_SwitchedToAsync, pSR);

                RmResumeTaskAsync(
                    pTask,
                    0,
                    &pFTask->WorkItem,
                    pSR
                    );
            }

            RM_ASSERT_NOLOCKS(pSR);
            Status = NDIS_STATUS_PENDING;

        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case PEND_ResumedAfterDelay:
                {
                    // We've waited around for pFTask->DelayMs ms; Now
                    // switch to passive...
                    //
                    RmSuspendTask(pTask, PEND_SwitchedToAsync, pSR);

                    RmResumeTaskAsync(
                        pTask,
                        0,
                        &pFTask->WorkItem,
                        pSR
                        );
                    Status = NDIS_STATUS_PENDING;
                }
                break;

                case PEND_SwitchedToAsync:
                {
                    //
                    // We should now be at PASSIVE IRQL.
                    // Call the completion routine either at DPC or PASSIVE irql.
                    //

                    if (pFTask->fDpc)
                    {
                        //  We need to call the routine at DPC level.
                        //
                        NdisAllocateSpinLock(&pFTask->NdisLock);
                        NdisAcquireSpinLock(&pFTask->NdisLock);
                    }

                    // Call the completion routine.
                    //
                    pFTask->pfnCompletionCallback(pFTask);

                    // If required, release the lock we held earlier.
                    //
                    if (pFTask->fDpc)
                    {
                        NdisReleaseSpinLock(&pFTask->NdisLock);
                    }
                    Status = pFTask->Status;
        
                } // end case  PEND_OnStart
                break;
    

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

        }
        break;

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpDbgAllocateFakeTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Allocates and initializes a task of subtype FAKETASK.

Arguments:

    pParentObject       - Object that is to be the parent of the allocated task.
    pfnHandler          - The task handler for the task.
    Timeout             - Unused.
    szDescription       - Text describing this task.
    ppTask              - Place to store pointer to the new task.

Return Value:

    NDIS_STATUS_SUCCESS if we could allocate and initialize the task.
    NDIS_STATUS_RESOURCES otherwise
--*/
{
    FAKETASK *pFTask;
    NDIS_STATUS Status;
        
    ARP_ALLOCSTRUCT(pFTask, MTAG_DBGINFO);
    Status = NDIS_STATUS_RESOURCES;
    *ppTask = NULL;

    if (pFTask != NULL)
    {

        RmInitializeTask(
                    &(pFTask->TskHdr),
                    pParentObject,
                    pfnHandler,
                    &FakeTasks_StaticInfo,
                    szDescription,
                    Timeout,
                    pSR
                    );
        *ppTask = &(pFTask->TskHdr);
        Status = NDIS_STATUS_SUCCESS;
    }

    return Status;
}


VOID
arpDbgFakeTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Actually free the specified task.

Arguments:

    pObj        - Actually the task to be freed.

--*/
{
    ARP_FREE(pObj);
}


INT
arpGenRandomInt(
    OUTCOME_PROBABILITY *rgOutcomes,
    UINT                cOutcomes
    )
/*++

Routine Description:

    Generate a new sample given the specified probability distribution.


Arguments:

    rgOutcomes      - Array of outcomes from which to select the random
                      sample.
    cOutcomes       - Number of elements in the above array.

Return Value:

    Random integer

--*/
{
    ULONG   u, sum, partsum;
    OUTCOME_PROBABILITY *pOp, *pOpEnd;

    // Get a nicely-random number.
    //
    u = ran1x();

    // Run through weights, computing the sum of weights...
    //
    pOp = pOpEnd = rgOutcomes;
    pOpEnd += cOutcomes;
    sum=0;
    for(; pOp<pOpEnd; pOp++)
    {
        sum += pOp->Weight;
    }

    // It's really meaningless to pass in a pPD with zero sum of weights.
    // We return 0 in this case. 
    //
    if (sum == 0)           return 0;               // EARLY RETURN

    // Make u range from 0..sum-1 inclusive
    //
    u ^= u>>16; // Get more randomness in the lower 16 bits for mod below...
    u %= sum;

    // Now go through the array of outcomes, computing the partial sum (partsum)
    // of weigths, and picking the FIRST outcome at array position X such that
    // u < partsum.
    //
    partsum=0;
    pOp = pOpEnd = rgOutcomes;
    pOpEnd += cOutcomes;
    for(; pOp<pOpEnd; pOp++)
    {
        partsum += pOp->Weight;
        if (u < partsum)
        {
            break;  // Found it!
        }
    }

    ASSERT(pOp<pOpEnd);

    return pOp->Outcome;
}


static long g_idum;

unsigned long ran1x(void)
/*++

Routine Description:

    Closely based on ran1() from "Numerical Recipes in C." ISBN 0 521 43108 5
    (except that it returns unsigned long instead of float, and uses g_idum
     instead of input arg long *idum).

    Pretty uniform and uncorrelated from sample to sample; also individual bits are
    pretty random. We need these properties.

Return Value:

    Random unsigned integer.

--*/
{
    #define IA      16807
    #define IM      RAN1X_MAX
    #define IQ      127773
    #define IR      2836
    #define NTAB    32
    #define NDIV    (1+(IM-1)/NTAB)

    int j;
    long k;
    static long iy=0;
    static long iv[NTAB];

    if (g_idum <= 0 || !iy)
    {
        //
        // Initialization code... (I'm not really sure if iy or g_idum can
        // go to zero in the course of operation, so I'm leaving this
        // initialization code here instead of moving it to sranx1x).
        //

        if (-g_idum < 1)
        {
            g_idum = 1;
        }
        else
        {
            g_idum = -g_idum;
        }
        for (j=NTAB+7;j>=0;j--)
        {
            k = g_idum/IQ;
            g_idum = IA*(g_idum-k*IQ)-IR*k;
            if (g_idum<0)
            {
                g_idum += IM;
            }
            if (j<NTAB)
            {
                iv[j] = g_idum;
            }
        }
        iy=iv[0];
    }

    k=g_idum/IQ;
    g_idum=IA*(g_idum-k*IQ)-IR*k;
    if (g_idum<0)
    {
        g_idum += IM;
    }
    j = iy/NDIV;
    iy = iv[j];
    iv[j] = g_idum;

    // iy ranges from 1 .. (IM-1)
    //
    return (unsigned long) iy;
}

void
sran1x(
    unsigned long seed
    )
/*++

Routine Description:

    Sets the seed used by ran1x.

--*/
{
    g_idum = (long) seed;

    //
    // Make sure the seed is -ve, to trigger ran1x initialization code above.
    //

    if (g_idum > 0)
    {
        g_idum = -g_idum;
    }
    if (g_idum==0)
    {
        g_idum = -1;
    }
}


VOID
arpFakeMakeCallCompletionCallback(
    struct _FAKETASK *pFTask
)
/*++

Routine Description:

    Calls ARP's makecall completion callback.

Arguments:

    pFTask  - Task in whose context this callback is to be made. The task
              contains information used in calling the makecall  completion
              callback.
--*/
{
    // Call the make call completion routine.
    //
    ArpCoMakeCallComplete(
                pFTask->Status,
                (NDIS_HANDLE)  pFTask->pClientContext,
                NULL,
                pFTask->CallParameters
                );
}


VOID
arpFakeCloseCallCompletionCallback(
    struct _FAKETASK *pFTask
)
/*++

Routine Description:

    Calls ARP's closecall completion callback.

Arguments:

    pFTask  - Task in whose context this callback is to be made. The task
              contains information used in calling the closecall  completion
              callback.
--*/
{
        ArpCoCloseCallComplete(
                pFTask->Status,
                (NDIS_HANDLE)  pFTask->pClientContext,
                NULL
                );
}


VOID
arpFakeSendPacketsCompletionCallback(
    struct _FAKETASK *pFTask
)
/*++

Routine Description:

    Calls ARP's cosendpackets completion callback.

Arguments:

    pFTask  - Task in whose context this callback is to be made. The task
              contains information used in calling the cosendpackets  completion
              callback.
--*/
{
        ArpCoSendComplete(
                pFTask->Status,
                (NDIS_HANDLE)  pFTask->pClientContext,
                pFTask->pNdisPacket
                );
}

#endif // ARPDBG_FAKE_APIS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Handler routines for Internal IOCTLs, including IOCTL_ARP1394_REQUEST.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     11-20-97    Created

Notes:

--*/

#include <precomp.h>
// #include "ioctl.h"

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_NT


NTSTATUS
arpDoClientCommand(
        PARP1394_IOCTL_COMMAND              pCmd,
        UINT                                BufLen
        );

NTSTATUS
arpDoEthernetCommand(
        PARP1394_IOCTL_COMMAND              pCmd,
        UINT                                BufLen
        );

NTSTATUS
arpIoctlGetArpCache(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_GET_ARPCACHE         pGetCacheCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlAddArpEntry(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_ADD_ARP_ENTRY        pAddArpEntryCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlDelArpEntry(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_DEL_ARP_ENTRY        pDelArpEntryCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlPurgeArpCache(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_PURGE_ARPCACHE       pPurgeCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlGetPacketStats(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_GET_PACKET_STATS     pStatsCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlGetTaskStats(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_GET_TASK_STATS       pStatsCmd,
        PRM_STACK_RECORD                    pSR
        );


NTSTATUS
arpIoctlGetArpStats(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_GET_ARPCACHE_STATS   pStatsCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlGetCallStats(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_GET_CALL_STATS       pStatsCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlResetStats(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_RESET_STATS          pResetStatsCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlReinitIf(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_REINIT_INTERFACE     pReinitCmd,
        PRM_STACK_RECORD                    pSR
        );

PARP1394_INTERFACE
arpGetIfByIp(
        IN OUT IP_ADDRESS                   *pLocalIpAddress, // OPTIONAL
        PRM_STACK_RECORD                    pSR
        );

UINT
arpGetStatsDuration(
        PARP1394_INTERFACE pIF
        );

NTSTATUS
arpIoctlSendPacket(
        PARP1394_INTERFACE              pIF,
        PARP1394_IOCTL_SEND_PACKET      pSendPacket,
        PRM_STACK_RECORD                pSR
        );

NTSTATUS
arpIoctlRecvPacket(
        PARP1394_INTERFACE              pIF,
        PARP1394_IOCTL_RECV_PACKET      pRecvPacket,
        PRM_STACK_RECORD                pSR
        );

NTSTATUS
arpIoctlGetNicInfo(
        PARP1394_INTERFACE              pIF,
        PARP1394_IOCTL_NICINFO          pIoctlNicInfo,
        PRM_STACK_RECORD                pSR
        );

NTSTATUS
arpIoctlGetEuidNodeMacInfo(
        PARP1394_INTERFACE          pIF,
        PARP1394_IOCTL_EUID_NODE_MAC_INFO   pEuidInfo,
        PRM_STACK_RECORD            pSR
        );


NTSTATUS
ArpHandleIoctlRequest(
    IN  PIRP                    pIrp,
    IN  PIO_STACK_LOCATION      pIrpSp
    )
/*++

Routine Description:

    Private IOCTL interface to the ARP1394 administration utility.

--*/
{
    NTSTATUS                NtStatus = STATUS_UNSUCCESSFUL;
    PUCHAR                  pBuf;  
    UINT                    BufLen;
    ULONG                   Code;

    ENTER("Ioctl", 0x4e96d522)

    pIrp->IoStatus.Information = 0;
    pBuf    = pIrp->AssociatedIrp.SystemBuffer;
    BufLen  = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    Code    = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

    TR_WARN(("Code = 0x%p\n", Code));
    
    if (Code ==  ARP_IOCTL_CLIENT_OPERATION && pBuf != NULL)
    {
        PARP1394_IOCTL_COMMAND          pCmd;
        pCmd = (PARP1394_IOCTL_COMMAND) pBuf;

        if (   (pCmd->Hdr.Op >= ARP1394_IOCTL_OP_ETHERNET_FIRST)
            && (pCmd->Hdr.Op <= ARP1394_IOCTL_OP_ETHERNET_LAST))
        {
            // This is an ethernet-emulation related ioctl request (from
            // NIC1394.SYS). We handle these differently.
            //
            NtStatus = arpDoEthernetCommand(pCmd, BufLen);
        }
        else
        {
            NtStatus = arpDoClientCommand(pCmd, BufLen);
        }

        //
        // All commands return stuff in pCmd itself...
        //
        if (NtStatus == STATUS_SUCCESS)
        {
            pIrp->IoStatus.Information = BufLen;
        }
    }
    else
    {
        TR_WARN(("Unrecognized code.\n"));
    }

    EXIT()
    return NtStatus;
}

NTSTATUS
arpDoClientCommand(
    PARP1394_IOCTL_COMMAND  pCmd,
    UINT                    BufLen
    )
{
    ENTER("arpDoClientCommand", 0xd7985f1b)
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PARP1394_INTERFACE  pIF;
    RM_DECLARE_STACK_RECORD(sr)

    do
    {
        IP_ADDRESS          IpAddress;

        pIF = NULL;

        if (pCmd == NULL)
        {
            TR_WARN(("Invalid buffer %p\n", pCmd));
            break;

        }

        if (BufLen<sizeof(pCmd->Hdr))
        {
            TR_WARN(("Buffer too small (%lu)\n", BufLen));
            break;
        }

        if (pCmd->Hdr.Version != ARP1394_IOCTL_VERSION)
        {
            TR_WARN(("Incorrect version 0x%08lx\n", pCmd->Hdr.Version));
            break;
        }

        
        IpAddress = (IP_ADDRESS)  pCmd->Hdr.IfIpAddress;

        // IpAddress could be all-zeros, in which case we'll get the first IF,
        // and IpAddress will be set to one of the local IP addresses of this IF.
        // NOTE: pIF is tmpref'd.
        //
        pIF = arpGetIfByIp(&IpAddress, &sr);

        if (pIF == NULL)
        {
            TR_WARN(("Couldn't find IF with IP 0x%0x8lx\n", IpAddress));
            break;
        }

        pCmd->Hdr.IfIpAddress        = IpAddress;

        switch(pCmd->Hdr.Op)
        {
        case ARP1394_IOCTL_OP_GET_ARPCACHE:
            {
                PARP1394_IOCTL_GET_ARPCACHE pGetArpCache =  &pCmd->GetArpCache;
                if (BufLen >= sizeof(*pGetArpCache))
                {
                    //
                    // Check if there is enough space for all the arp entries.
                    //
                    ULONG EntrySpace;
                    EntrySpace = BufLen - FIELD_OFFSET(
                                                ARP1394_IOCTL_GET_ARPCACHE,
                                                Entries
                                                );
                    if ((EntrySpace/sizeof(pGetArpCache->Entries[0])) >
                        pGetArpCache->NumEntriesAvailable)
                    {
                        //
                        // Yes, there is enough space.
                        //
                        NtStatus = arpIoctlGetArpCache(pIF, pGetArpCache, &sr);
                    }
                }
            }
            break;
    
        case ARP1394_IOCTL_OP_ADD_STATIC_ENTRY:
            {
                PARP1394_IOCTL_ADD_ARP_ENTRY pAddCmd =  &pCmd->AddArpEntry;
                if (BufLen >= sizeof(*pAddCmd))
                {
                    NtStatus = arpIoctlAddArpEntry(pIF, pAddCmd, &sr);
                }
            }
            break;
    
        case ARP1394_IOCTL_OP_DEL_STATIC_ENTRY:
            {
                PARP1394_IOCTL_DEL_ARP_ENTRY pDelCmd =  &pCmd->DelArpEntry;
                if (BufLen >= sizeof(*pDelCmd))
                {
                    NtStatus = arpIoctlDelArpEntry(pIF, pDelCmd, &sr);
                }
            }
            break;
    
        case ARP1394_IOCTL_OP_PURGE_ARPCACHE:
            {
                PARP1394_IOCTL_PURGE_ARPCACHE pPurge =  &pCmd->PurgeArpCache;
                if (BufLen >= sizeof(*pPurge))
                {
                    NtStatus = arpIoctlPurgeArpCache(pIF, pPurge, &sr);
                }
            }
            break;
    
        case ARP1394_IOCTL_OP_GET_PACKET_STATS:
            {
                PARP1394_IOCTL_GET_PACKET_STATS pStats =  &pCmd->GetPktStats;
                if (BufLen >= sizeof(*pStats))
                {
                    NtStatus = arpIoctlGetPacketStats(pIF, pStats, &sr);
                }
            }
            break;
    
        case ARP1394_IOCTL_OP_GET_TASK_STATS:
            {
                PARP1394_IOCTL_GET_TASK_STATS pStats =  &pCmd->GetTaskStats;
                if (BufLen >= sizeof(*pStats))
                {
                    NtStatus = arpIoctlGetTaskStats(pIF, pStats, &sr);
                }
            }
            break;
    
        case ARP1394_IOCTL_OP_GET_ARPCACHE_STATS:
            {
                PARP1394_IOCTL_GET_ARPCACHE_STATS pStats =  &pCmd->GetArpStats;
                if (BufLen >= sizeof(*pStats))
                {
                    NtStatus = arpIoctlGetArpStats(pIF, pStats, &sr);
                }
            }
            break;
    
        case ARP1394_IOCTL_OP_GET_CALL_STATS:
            {
                PARP1394_IOCTL_GET_CALL_STATS pStats =  &pCmd->GetCallStats;
                if (BufLen >= sizeof(*pStats))
                {
                    NtStatus = arpIoctlGetCallStats(pIF, pStats, &sr);
                }
            }
            break;
    
        case ARP1394_IOCTL_OP_RESET_STATS:
            {
                PARP1394_IOCTL_RESET_STATS pResetStats =  &pCmd->ResetStats;
                if (BufLen >= sizeof(*pResetStats))
                {
                    NtStatus = arpIoctlResetStats(pIF, pResetStats, &sr);
                }
            }
            break;

        case ARP1394_IOCTL_OP_REINIT_INTERFACE:
            {
                PARP1394_IOCTL_REINIT_INTERFACE pReinitIf =  &pCmd->ReinitInterface;
                if (BufLen >= sizeof(*pReinitIf))
                {
                    NtStatus = arpIoctlReinitIf(pIF, pReinitIf, &sr);
                }
            }
            break;
    
        case  ARP1394_IOCTL_OP_SEND_PACKET:
            {
                ARP1394_IOCTL_SEND_PACKET *pSendPacket = &pCmd->SendPacket;
                if (BufLen >= sizeof(*pSendPacket))
                {
                    NtStatus = arpIoctlSendPacket(pIF, pSendPacket, &sr);
                }
            }
            break;
    
        case  ARP1394_IOCTL_OP_RECV_PACKET:
            {
                ARP1394_IOCTL_RECV_PACKET *pRecvPacket = &pCmd->RecvPacket;
                if (BufLen >= sizeof(*pRecvPacket))
                {
                    NtStatus = arpIoctlRecvPacket(pIF, pRecvPacket, &sr);
                }
            }
            break;
    
        case  ARP1394_IOCTL_OP_GET_NICINFO:
            {
                ARP1394_IOCTL_NICINFO *pIoctlNicInfo = &pCmd->IoctlNicInfo;
                if (BufLen >= sizeof(*pIoctlNicInfo))
                {
                    NtStatus = arpIoctlGetNicInfo(pIF, pIoctlNicInfo, &sr);
                }
            }
            break;
        case ARP1394_IOCTL_OP_GET_EUID_NODE_MAC_TABLE:
            {
                PARP1394_IOCTL_EUID_NODE_MAC_INFO pIoctlEuidInfo = &pCmd->EuidNodeMacInfo;
                if (BufLen >= sizeof(*pIoctlEuidInfo))
                {
                    NtStatus = arpIoctlGetEuidNodeMacInfo(pIF, pIoctlEuidInfo, &sr);
                }

            }
            break;

        default:
            TR_WARN(("Unknown op %lu\n",  pCmd->Hdr.Op));
            break;
    
        }
    } while (FALSE);

    if (NtStatus != STATUS_SUCCESS)
    {
        TR_WARN(("Command unsuccessful. NtStatus = 0x%lx\n", NtStatus));
    }

    if (pIF != NULL)
    {
        RmTmpDereferenceObject(&pIF->Hdr, &sr);
    }

    RM_ASSERT_CLEAR(&sr);
    EXIT()

    return NtStatus;
}


NTSTATUS
arpDoEthernetCommand(
    PARP1394_IOCTL_COMMAND  pCmd,
    UINT                    BufLen
    )
{
    ENTER("arpDoEthernetCommand", 0xa723f233)
    PARP1394_IOCTL_ETHERNET_NOTIFICATION pNotif;
    PARP1394_ADAPTER pAdapter = NULL;
    RM_DECLARE_STACK_RECORD(sr)

    pNotif = (PARP1394_IOCTL_ETHERNET_NOTIFICATION) pCmd;

    do
    {
        NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
        NDIS_STRING DeviceName;

        if (BufLen<sizeof(*pNotif))
        {
            TR_WARN(("Buffer too small (%lu)\n", BufLen));
            break;
        }

        if (pNotif->Hdr.Version != ARP1394_IOCTL_VERSION)
        {
            TR_WARN(("Incorrect version 0x%08lx\n", pCmd->Hdr.Version));
            break;
        }

        NdisInitUnicodeString(&DeviceName, pNotif->AdapterName);

        if (pNotif->Hdr.Op == ARP1394_IOCTL_OP_ETHERNET_START_EMULATION)
        {
            //
            // ArpNdBindAdapter will try to create the adapter in "Bridge
            // mode" if it passed in a NULL bind context.
            // It will of course fail if the adapter exists.
            //
            ArpNdBindAdapter(
                &NdisStatus,
                NULL,           // BindContext
                &DeviceName,    // pDeviceName
                NULL,           // SystemSpecific1
                NULL            // SystemSpecific2
                );
            break;
        }

        //
        // The remaining operations concern an existing adapter which has been
        // created in "bridge" mode. Let's look up this adapter based on it's
        // name.
        //

        NdisStatus = RmLookupObjectInGroup(
                            &ArpGlobals.adapters.Group,
                            0,                              // Flags
                            (PVOID) &DeviceName,            // pKey
                            NULL,                           // pvCreateParams
                            &(PRM_OBJECT_HEADER) pAdapter,  // pObj
                            NULL,                           // pfCreated
                            &sr
                            );
        if (FAIL(NdisStatus))
        {
            TR_WARN(("Couldn't find adapter object\n"));
            pAdapter = NULL;
            break;
        }

        if (!ARP_BRIDGE_ENABLED(pAdapter))
        {
            TR_WARN((
            "Ignoring Ethernet Emulation Ioctl Op 0x%x"
            " because adapter 0x%p is not in bridge mode.\n",
            pNotif->Hdr.Op,
            pAdapter));
            break;
        }

        //
        // OK -- we've found the adapter and the adapter is in bridged mode.
        // Let's look at the specific command.
        //

        switch(pNotif->Hdr.Op)
        {

        case  ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION:
            {
                // Calling ArpNdUnbindAdapter with NULL UnbindContext prevents
                // it from trying to call NdisCompleteUnbindAdapter.
                //
                ArpNdUnbindAdapter(
                    &NdisStatus,
                    (NDIS_HANDLE) pAdapter,
                    NULL // UnbindContext
                    );
            }
            break;

        case ARP1394_IOCTL_OP_ETHERNET_ADD_MULTICAST_ADDRESS:
            {
                // TODO: unimplemented.
            }
            break;

        case ARP1394_IOCTL_OP_ETHERNET_DEL_MULTICAST_ADDRESS:
            {
                // TODO: unimplemented.
            }
            break;

        case ARP1394_IOCTL_OP_ETHERNET_ENABLE_PROMISCUOUS_MODE:
            {
                // TODO: unimplemented.
            }
            break;

        case ARP1394_IOCTL_OP_ETHERNET_DISABLE_PROMISCUOUS_MODE:
            {
                // TODO: unimplemented.
            }
            break;
    
        default:
            TR_WARN(("Unknown op %lu\n",  pCmd->Hdr.Op));
            break;
    
        }

    } while (FALSE);

    if (pAdapter != NULL)
    {
        RmTmpDereferenceObject(&pAdapter->Hdr, &sr);
    }

    RM_ASSERT_CLEAR(&sr);
    EXIT()

    return STATUS_SUCCESS;
}


NTSTATUS
arpIoctlGetArpCache(
        PARP1394_INTERFACE           pIF,
        PARP1394_IOCTL_GET_ARPCACHE pGetCacheCmd,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("GetArpCache", 0xa64453c7)
    NTSTATUS            NtStatus;
    TR_WARN(("GET ARP CACHE\n"));

    pGetCacheCmd->NumEntriesUsed    = 0;
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        PARP1394_ADAPTER pAdapter;
        PARP1394_ARP_ENTRY  pEntry;
        ARPCB_REMOTE_IP *   pRemoteIp;
        NDIS_STATUS         Status;
        UINT                EntriesAvailable;
        UINT                EntriesUsed;
        UINT                CurIndex;
        UINT                Index;


        LOCKOBJ(pIF, pSR);

        pAdapter =  (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
        pGetCacheCmd->NumEntriesInArpCache   = pIF->RemoteIpGroup.HashTable.NumItems;
        pGetCacheCmd->LocalHwAddress.UniqueID= pAdapter->info.LocalUniqueID;
        pGetCacheCmd->LocalHwAddress.Off_Low = pIF->recvinfo.offset.Off_Low;
        pGetCacheCmd->LocalHwAddress.Off_High= pIF->recvinfo.offset.Off_High;

        //
        // Pick up pGetCacheCmd->NumEntriesAvailable arp entries starting
        // from the (pGetCacheCmd->Index)'th one.
        //
    
        pRemoteIp       = NULL;
        EntriesAvailable = pGetCacheCmd->NumEntriesAvailable;
        EntriesUsed = 0;
        Index = pGetCacheCmd->Index;
        pEntry = pGetCacheCmd->Entries;
        CurIndex = 0;
    
        // Get the 1st entry...
        //
        Status = RmGetNextObjectInGroup(
                    &pIF->RemoteIpGroup,
                    NULL,
                    &(PRM_OBJECT_HEADER)pRemoteIp,
                    pSR
                    );
        if (FAIL(Status))
        {
            // Presumably there are no entries.
            pRemoteIp = NULL;
        }
    
        while (pRemoteIp != NULL)
        {
            ARPCB_REMOTE_IP *   pNextRemoteIp = NULL;
    
            if (EntriesUsed >= EntriesAvailable)
            {
                //
                // out of space; Update the context, and set special return value.
                //
                RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
                pRemoteIp = NULL;
                break;
            }
    
            // If this entry is within the range asked for, we copy the IP and
            // HW address over onto pEntry...
            //
            if (CurIndex >= Index)
            {
                ARP_ZEROSTRUCT(pEntry);
                pEntry->IpAddress = pRemoteIp->Key.IpAddress;
                if (CHECK_REMOTEIP_RESOLVE_STATE(pRemoteIp, ARPREMOTEIP_RESOLVED))
                {
                    ARPCB_DEST *pDest = pRemoteIp->pDest;
    
                    TR_INFO(("ReadNext: found Remote IP Entry 0x%x, Addr %d.%d.%d.%d\n",
                                pRemoteIp,
                                ((PUCHAR)(&(pRemoteIp->IpAddress)))[0],
                                ((PUCHAR)(&(pRemoteIp->IpAddress)))[1],
                                ((PUCHAR)(&(pRemoteIp->IpAddress)))[2],
                                ((PUCHAR)(&(pRemoteIp->IpAddress)))[3]
                            ));
            
                    // We assert that
                    // IF lock is the same as pRemoteIp's and pDest's lock,
                    // and that lock is locked.
                    // We implicitly assert that pDest is non-NULl as well.
                    //
                    ASSERTEX(pRemoteIp->Hdr.pLock == pDest->Hdr.pLock, pRemoteIp);
                    RM_DBG_ASSERT_LOCKED(&pRemoteIp->Hdr, pSR);
    
                    pEntry->HwAddress.UniqueID  = pDest->Params.HwAddr.FifoAddress.UniqueID;
                    pEntry->HwAddress.Off_Low   = pDest->Params.HwAddr.FifoAddress.Off_Low;
                    pEntry->HwAddress.Off_High  = pDest->Params.HwAddr.FifoAddress.Off_High;
    
                    if (CHECK_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_STATIC))
                    {
                        // TODO
                    }
                    else
                    {
                        // TODO
                    }
                }
                else
                {
                    // TODO
                }
    
                pEntry++;
                EntriesUsed++;
            }
    
            // Lookup next entry's IP address and save it in our context.
            //
            Status = RmGetNextObjectInGroup(
                            &pIF->RemoteIpGroup,
                            &pRemoteIp->Hdr,
                            &(PRM_OBJECT_HEADER)pNextRemoteIp,
                            pSR
                            );
    
            if (FAIL(Status))
            {
                //
                // we're presumably done. 
                //
                pNextRemoteIp = NULL;
            }
    
            // TmpDeref pRemoteIp and move on to the next one.
            //
            RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
            pRemoteIp = pNextRemoteIp;
    
        }
    
        ASSERT(pRemoteIp == NULL);
        UNLOCKOBJ(pIF, pSR);

        ASSERT(EntriesUsed <= pGetCacheCmd->NumEntriesAvailable);
        pGetCacheCmd->NumEntriesUsed = EntriesUsed;
        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    EXIT()
    return NtStatus;
}


NTSTATUS
arpIoctlAddArpEntry(
        PARP1394_INTERFACE           pIF,
        PARP1394_IOCTL_ADD_ARP_ENTRY pAddArpEntryCmd,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("AddArpEntry", 0xcda56c6f)
    NTSTATUS            NtStatus;

    TR_WARN(("ADD ARP ENTRY\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS         Status;
        NIC1394_FIFO_ADDRESS    FifoAddress;

        LOCKOBJ(pIF, pSR);

        FifoAddress.UniqueID    = pAddArpEntryCmd->HwAddress.UniqueID;
        FifoAddress.Off_Low     = pAddArpEntryCmd->HwAddress.Off_Low;
        FifoAddress.Off_High    = pAddArpEntryCmd->HwAddress.Off_High;

        // 
        // TODO -- we hardcode the Off_Low and Off_High values for now...
        //
        FifoAddress.Off_Low     = 0x0;
        FifoAddress.Off_High    = 0x100;

        // Actually add the entry...
        //
        Status = arpAddOneStaticArpEntry(
                    pIF,
                    pAddArpEntryCmd->IpAddress,
                    &FifoAddress,
                    pSR
                    );
    
        UNLOCKOBJ(pIF, pSR);

        if (!FAIL(Status))
        {
            NtStatus = STATUS_SUCCESS;
        }

    } while (FALSE);


    EXIT()
    return NtStatus;
}

NTSTATUS
arpIoctlDelArpEntry(
        PARP1394_INTERFACE           pIF,
        PARP1394_IOCTL_DEL_ARP_ENTRY pDelArpEntryCmd,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("DelArpEntry", 0x3427306a)
    NTSTATUS            NtStatus;

    TR_WARN(("DEL ARP ENTRY\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    NtStatus = arpDelArpEntry(pIF,pDelArpEntryCmd->IpAddress,pSR);
    EXIT()
    return NtStatus;
}



NTSTATUS
arpIoctlPurgeArpCache(
        PARP1394_INTERFACE           pIF,
        PARP1394_IOCTL_PURGE_ARPCACHE pPurgeCmd,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("PurgeArpCache", 0x2bebb833)
    TR_WARN(("PURGE ARP CACHE\n"));
    return 0;
}

NTSTATUS
arpIoctlGetPacketStats(
    PARP1394_INTERFACE           pIF,
    PARP1394_IOCTL_GET_PACKET_STATS pStatsCmd,
    PRM_STACK_RECORD            pSR
    )
{
    ENTER("GetPacketStats", 0xe7c75fdb)
    NTSTATUS            NtStatus;

    TR_WARN(("GET PACKET STATS\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS             Status;

        pStatsCmd->StatsDuration        = arpGetStatsDuration(pIF);
    
        pStatsCmd->TotSends             = pIF->stats.sendpkts.TotSends;
        pStatsCmd->FastSends            = pIF->stats.sendpkts.FastSends;
        pStatsCmd->MediumSends          = pIF->stats.sendpkts.MediumSends;
        pStatsCmd->SlowSends            = pIF->stats.sendpkts.SlowSends;
        pStatsCmd->BackFills            = pIF->stats.sendpkts.BackFills;
        // TODO: report  pIF->sendinfo.HeaderPool.stats.TotAllocFails
        pStatsCmd->HeaderBufUses        = 
                                    pIF->sendinfo.HeaderPool.stats.TotBufAllocs
                                 + pIF->sendinfo.HeaderPool.stats.TotCacheAllocs;
        pStatsCmd->HeaderBufCacheHits   =
                                 pIF->sendinfo.HeaderPool.stats.TotCacheAllocs;
    
        pStatsCmd->TotRecvs             = pIF->stats.recvpkts.TotRecvs;
        pStatsCmd->NoCopyRecvs          = pIF->stats.recvpkts.NoCopyRecvs;
        pStatsCmd->CopyRecvs            = pIF->stats.recvpkts.CopyRecvs;
        pStatsCmd->ResourceRecvs        = pIF->stats.recvpkts.ResourceRecvs;
    
        pStatsCmd->SendFifoCounts       = pIF->stats.sendpkts.SendFifoCounts;
        pStatsCmd->RecvFifoCounts       = pIF->stats.recvpkts.RecvFifoCounts;

        pStatsCmd->SendChannelCounts    = pIF->stats.sendpkts.SendChannelCounts;
        pStatsCmd->RecvChannelCounts    = pIF->stats.recvpkts.RecvChannelCounts;

        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    EXIT()
    return NtStatus;
}



NTSTATUS
arpIoctlGetTaskStats(
    PARP1394_INTERFACE           pIF,
    PARP1394_IOCTL_GET_TASK_STATS pStatsCmd,
    PRM_STACK_RECORD            pSR
    )
{
    ENTER("GetTaskStats", 0x4abc46b5)
    TR_WARN(("GET TASK STATS\n"));
    return 0;
}


NTSTATUS
arpIoctlGetArpStats(
    PARP1394_INTERFACE           pIF,
    PARP1394_IOCTL_GET_ARPCACHE_STATS pStatsCmd,
    PRM_STACK_RECORD            pSR
    )
{
    ENTER("GetArpStats", 0x5482de10)
    TR_WARN(("GET ARP STATS\n"));

    pStatsCmd->StatsDuration        = arpGetStatsDuration(pIF);
    pStatsCmd->TotalQueries         = pIF->stats.arpcache.TotalQueries;
    pStatsCmd->SuccessfulQueries    = pIF->stats.arpcache.SuccessfulQueries;
    pStatsCmd->FailedQueries        = pIF->stats.arpcache.FailedQueries;
    pStatsCmd->TotalResponses       = pIF->stats.arpcache.TotalResponses;
    pStatsCmd->TotalLookups         = pIF->stats.arpcache.TotalLookups;
    pStatsCmd->TraverseRatio        = RM_HASH_TABLE_TRAVERSE_RATIO(
                                                &(pIF->RemoteIpGroup.HashTable)
                                                );

    EXIT()
    return  STATUS_SUCCESS;
}

NTSTATUS
arpIoctlGetCallStats(
    PARP1394_INTERFACE           pIF,
    PARP1394_IOCTL_GET_CALL_STATS pStatsCmd,
    PRM_STACK_RECORD            pSR
    )
{
    ENTER("GetCallStats", 0xf81ed4cf)
    TR_WARN(("GET CALL STATS\n"));

    //
    // FIFO-related call stats.
    //
    pStatsCmd->TotalSendFifoMakeCalls   =
                                pIF->stats.calls.TotalSendFifoMakeCalls;
    pStatsCmd->SuccessfulSendFifoMakeCalls =
                                pIF->stats.calls.SuccessfulSendFifoMakeCalls;
    pStatsCmd->FailedSendFifoMakeCalls =
                                pIF->stats.calls.FailedSendFifoMakeCalls;
    pStatsCmd->IncomingClosesOnSendFifos =
                                pIF->stats.calls.IncomingClosesOnSendFifos;

    //
    // Channel-related call stats.
    //
    pStatsCmd->TotalChannelMakeCalls =
                                pIF->stats.calls.TotalChannelMakeCalls;
    pStatsCmd->SuccessfulChannelMakeCalls =
                                pIF->stats.calls.SuccessfulChannelMakeCalls;
    pStatsCmd->FailedChannelMakeCalls =
                                pIF->stats.calls.FailedChannelMakeCalls;
    pStatsCmd->IncomingClosesOnChannels =
                                pIF->stats.calls.IncomingClosesOnChannels;

    return STATUS_SUCCESS;
}

NTSTATUS
arpIoctlResetStats(
        PARP1394_INTERFACE           pIF,
        PARP1394_IOCTL_RESET_STATS pResetStatsCmd,
        PRM_STACK_RECORD            pSR
        )
{
    NTSTATUS            NtStatus;
    ENTER("ResetStats", 0xfa50cfc9)
    TR_WARN(("RESET STATS\n"));

    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS         Status;
        NIC1394_FIFO_ADDRESS    FifoAddress;


        LOCKOBJ(pIF, pSR);
        arpResetIfStats(pIF, pSR);
        UNLOCKOBJ(pIF, pSR);
        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    EXIT()
    return NtStatus;
}

NTSTATUS
arpIoctlReinitIf(
        PARP1394_INTERFACE           pIF,
        PARP1394_IOCTL_REINIT_INTERFACE pReinitIfCmd,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("ReinitIf", 0xed00187a)
    NTSTATUS            NtStatus;

    TR_WARN(("REINIT IF\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS         Status;
        NIC1394_FIFO_ADDRESS    FifoAddress;


        Status = arpTryReconfigureIf(pIF, NULL, pSR);

        if (PEND(Status) || !FAIL(Status))
        {
            NtStatus = STATUS_SUCCESS;
        }

    } while (FALSE);

    EXIT()
    return NtStatus;
}


PARP1394_INTERFACE
arpGetIfByIp(
    IN OUT IP_ADDRESS *pLocalIpAddress, // OPTIONAL
    PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    Find and return the 1st (and usually only) interface which has
    *pLocalIpAddress as a local IP address.

    If pLocalIpAddress is NULL, or *pLocalIpAddress is 0, return the
    first interface.

    Tmpref the interface before returning it.

--*/
{
    ENTER("arpGetIfByIp", 0xe9667c54)
    PARP1394_ADAPTER   pAdapter      = NULL;
    PARP1394_INTERFACE pIF = NULL;
    PARP1394_INTERFACE pFirstIF = NULL;
    NDIS_STATUS        Status;
    IP_ADDRESS         LocalIpAddress = 0;

    if (pLocalIpAddress != NULL)
    {
        LocalIpAddress = *pLocalIpAddress;
    }

    //
    // We iterate through all adapters, and for each adapter we look
    // for the specified ip address in the IF's LocalIp group.
    //

    // Get the 1st adapter...
    //
    Status = RmGetNextObjectInGroup(
                    &ArpGlobals.adapters.Group,
                    NULL,
                    &(PRM_OBJECT_HEADER)pAdapter,
                    pSR
                    );

    if (FAIL(Status))
    {
        pAdapter = NULL;
    }

    while (pAdapter != NULL)
    {
        ARP1394_ADAPTER *   pNextAdapter = NULL;


        // Check if this adapter's interface has the local ip address.
        //
        LOCKOBJ(pAdapter, pSR);
        ASSERT(pIF==NULL);
        pIF = pAdapter->pIF;
        if (pIF != NULL)
        {
            RmTmpReferenceObject(&pIF->Hdr, pSR);
            if (pFirstIF == NULL)
            {
                pFirstIF = pIF;
                RmTmpReferenceObject(&pFirstIF->Hdr, pSR);
            }
        }
        UNLOCKOBJ(pAdapter, pSR);

        if (pIF != NULL)
        {
            PARPCB_LOCAL_IP pLocalIp;
            LOCKOBJ(pIF, pSR);

            if (LocalIpAddress != 0)
            {
                Status = RmLookupObjectInGroup(
                                    &pIF->LocalIpGroup,
                                    0,                      // Flags
                                    (PVOID) ULongToPtr (LocalIpAddress),    // pKey
                                    NULL,                   // pvCreateParams
                                    &(PRM_OBJECT_HEADER)pLocalIp,
                                    NULL, // pfCreated
                                    pSR
                                    );
            }
            else
            {
                PARPCB_LOCAL_IP pPrevLocalIp = NULL;

                do
                {
                    Status = RmGetNextObjectInGroup(
                                    &pIF->LocalIpGroup,
                                    &(pPrevLocalIp)->Hdr,
                                    &(PRM_OBJECT_HEADER)pLocalIp,
                                    pSR
                                    );
                    if (pPrevLocalIp != NULL)
                    {
                        RmTmpDereferenceObject(&pPrevLocalIp->Hdr, pSR);
                    }
                    pPrevLocalIp = pLocalIp;

                    //
                    // we need to keep looking until we find a UNICAST
                    // local ip address!
                    //

                } while (!FAIL(Status) && pLocalIp->IpAddressType!=LLIP_ADDR_LOCAL);
            }

            UNLOCKOBJ(pIF, pSR);

            if (FAIL(Status))
            {
                // This IF is not the one, sorry...
                //
                RmTmpDereferenceObject(&pIF->Hdr, pSR);
                pIF = NULL;
            }
            else
            {
                // Found a local IP address (either matching or first one).
                // Let's get out of here...
                //
                if (pLocalIpAddress != NULL)
                {
                    *pLocalIpAddress = pLocalIp->IpAddress;
                }
                RmTmpDereferenceObject(&pLocalIp->Hdr, pSR);
                RmTmpDereferenceObject(&pAdapter->Hdr, pSR);
                pLocalIp = NULL;
                pAdapter = NULL;
                //
                // Note: we keep the reference on pIF, which we return.
                //
                break; // break out of the enclosing while(adapters-left) loop.
            }
        }

        // Lookup next adapter.
        //
        Status = RmGetNextObjectInGroup(
                        &ArpGlobals.adapters.Group,
                        &pAdapter->Hdr,
                        &(PRM_OBJECT_HEADER)pNextAdapter,
                        pSR
                        );

        if (FAIL(Status))
        {
            //
            // we're presumably done. 
            //
            pNextAdapter = NULL;
        }


        // TmpDeref pAdapter and move on to the next one.
        //
        RmTmpDereferenceObject(&pAdapter->Hdr, pSR);
        pAdapter = pNextAdapter;

    }

    //
    // If LocalipAddress ==0 AND
    // if we couldn't find any IF with any local IP address
    // (this would be because we haven't started an IF as yet)
    // we return the first IF we find.
    //
    if (LocalIpAddress == 0 && pIF == NULL)
    {
        pIF = pFirstIF;
        pFirstIF = NULL;
    }

    if (pFirstIF != NULL)
    {
        RmTmpDereferenceObject(&pFirstIF->Hdr, pSR);
    }

    return pIF;
}

UINT
arpGetStatsDuration(
        PARP1394_INTERFACE pIF
        )
/*++
    Return duration in seconds since start of statistics gathering.
--*/
{
    LARGE_INTEGER liCurrent;

    // Get the current time (in 100-nanosecond units).
    //
    NdisGetCurrentSystemTime(&liCurrent);

    // Compute the difference since the start of stats collection.
    //
    liCurrent.QuadPart -=  pIF->stats.StatsResetTime.QuadPart;

    // Convert to seconds.
    //
    liCurrent.QuadPart /= 10000000;

    // return low part.
    //
    return liCurrent.LowPart;
}

NTSTATUS
arpIoctlSendPacket(
        PARP1394_INTERFACE              pIF,
        PARP1394_IOCTL_SEND_PACKET      pSendPacket,
        PRM_STACK_RECORD                pSR
        )
/*++
    Send the pSendPacket->PacketSize bytes of data in pSendPacket->Data as
    a single packet on the broadcast channel. The encap header is expected
    to be already in the packet.
--*/
{
    ENTER("IoctlSendPacket", 0x59746279)
    NTSTATUS            NtStatus;

    RM_ASSERT_NOLOCKS(pSR);

    TR_WARN(("SEND PACKET\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS         Status;
        PNDIS_PACKET        pNdisPacket;
        PVOID               pPktData;
        UINT                Size = pSendPacket->PacketSize;

        //
        // Validate contents of pSendPacket.
        //
        if (Size > sizeof(pSendPacket->Data))
        {
            TR_WARN(("PacketSize value %lu is too large.\n", Size));
            break;
        }

        //
        // Allocate a control packet and copy over the contents.
        //
        Status = arpAllocateControlPacket(
                    pIF,
                    Size,
                    ARP1394_PACKET_FLAGS_IOCTL,
                    &pNdisPacket,
                    &pPktData,
                    pSR
                    );

        if (FAIL(Status))
        {
            TR_WARN(("Couldn't allocate send packet.\n"));
            break;
        }

        NdisMoveMemory(pPktData, pSendPacket->Data, Size);

        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        // Actually send the packet (this will silently fail and free the pkt
        // if we're not in a position to send the pkt.)
        //
        arpSendControlPkt(
                pIF,            // LOCKIN NOLOCKOUT (IF send lk)
                pNdisPacket,
                pIF->pBroadcastDest,
                pSR
                );

        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
    return NtStatus;
}


NTSTATUS
arpIoctlRecvPacket(
        PARP1394_INTERFACE              pIF,
        PARP1394_IOCTL_RECV_PACKET      pRecvPacket,
        PRM_STACK_RECORD                pSR
        )
{
    ENTER("IoctlRecvPacket", 0x59746279)
    NTSTATUS            NtStatus;

    RM_ASSERT_NOLOCKS(pSR);

    TR_WARN(("RECV PACKET\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS         Status;
        PNDIS_PACKET        pNdisPacket;
        PVOID               pPktData;
        UINT                Size = pRecvPacket->PacketSize;

        //
        // Validate contents of pRecvPacket.
        //
        if (Size > sizeof(pRecvPacket->Data))
        {
            TR_WARN(("PacketSize value %lu is too large.\n", Size));
            break;
        }

        //
        // Allocate a control packet and copy over the contents.
        //
        Status = arpAllocateControlPacket(
                    pIF,
                    Size,
                    ARP1394_PACKET_FLAGS_IOCTL,
                    &pNdisPacket,
                    &pPktData,
                    pSR
                    );

        if (FAIL(Status))
        {
            TR_WARN(("Couldn't allocate recv packet.\n"));
            break;
        }

        NdisMoveMemory(pPktData, pRecvPacket->Data, Size);

        //
        // Set the packet flags to STATUS_RESOURCES, so that our receive-
        // indicate handler will return synchronously.
        //
        NDIS_SET_PACKET_STATUS (pNdisPacket,  NDIS_STATUS_RESOURCES);

        //
        // Call our internal common receive packet handler.
        //
        arpProcessReceivedPacket(
                    pIF,
                    pNdisPacket,
                    TRUE                    // IsChannel
                    );

        //
        // Now we free the packet.
        //
        arpFreeControlPacket(
            pIF,
            pNdisPacket,
            pSR
            );

        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
    return NtStatus;
}


NTSTATUS
arpIoctlGetNicInfo(
        PARP1394_INTERFACE          pIF,
        PARP1394_IOCTL_NICINFO      pIoctlNicInfo,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("IoctlGetNicInfo", 0x637c44e0)
    NTSTATUS            NtStatus = STATUS_UNSUCCESSFUL;
    ARP_NDIS_REQUEST    ArpNdisRequest;
    PARP1394_ADAPTER    pAdapter;

    pAdapter =  (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

    do
    {
        NDIS_STATUS Status;

        if (pIoctlNicInfo->Info.Hdr.Version != NIC1394_NICINFO_VERSION)
        {
            TR_WARN(("NicInfo version mismatch. Want 0x%lx, got 0x%lx.\n",
                    NIC1394_NICINFO_VERSION, pIoctlNicInfo->Info.Hdr.Version));
            break;
        }

        //
        // Copy over all the fields.
        //

        Status =  arpPrepareAndSendNdisRequest(
                    pAdapter,
                    &ArpNdisRequest,
                    NULL,                   // pTask (NULL==BLOCK)
                    0,                      // unused
                    OID_1394_NICINFO,
                    &pIoctlNicInfo->Info,
                    sizeof(pIoctlNicInfo->Info),
                    NdisRequestQueryInformation,
                    pSR
                    );

        if (FAIL(Status))
        {
            TR_WARN(("NdisRequest failed with error 0x%08lx.\n", Status));
            break;
        }

        if (pIoctlNicInfo->Info.Hdr.Version !=  NIC1394_NICINFO_VERSION)
        {
            TR_WARN(("Unexpected NIC NicInfo version 0x%lx returned.\n",
                    pIoctlNicInfo->Info.Hdr.Version));
            break;
        }

        NtStatus = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    return NtStatus;
}





NTSTATUS
arpIoctlGetEuidNodeMacInfo(
        PARP1394_INTERFACE          pIF,
        PARP1394_IOCTL_EUID_NODE_MAC_INFO   pEuidInfo,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("IoctlGetNicInfo", 0x34db9cf4)
    NTSTATUS            NtStatus = STATUS_UNSUCCESSFUL;
    ARP_NDIS_REQUEST    ArpNdisRequest;
    PARP1394_ADAPTER    pAdapter;

    pAdapter =  (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

    do
    {
        NDIS_STATUS Status;


        //
        // Copy over all the fields.
        //

        Status =  arpPrepareAndSendNdisRequest(
                    pAdapter,
                    &ArpNdisRequest,
                    NULL,                   // pTask (NULL==BLOCK)
                    0,                      // unused
                    OID_1394_QUERY_EUID_NODE_MAP,
                    &pEuidInfo->Map,
                    sizeof(pEuidInfo->Map),
                    NdisRequestQueryInformation,
                    pSR
                    );

        if (FAIL(Status))
        {
            TR_WARN(("NdisRequest failed with error 0x%08lx.\n", Status));
            break;
        }

        NtStatus = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\fake.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ccdefs.h

Abstract:

    Header file for fake versions of various external calls (ndis, ip...).
    Used for debugging and component testing only.

    To enable, define ARPDBG_FAKE_APIS in ccdefs.h

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     03-24-99    created

--*/


NDIS_STATUS
arpDbgFakeNdisClMakeCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    OUT PNDIS_HANDLE            NdisPartyHandle,        OPTIONAL
    IN  PRM_OBJECT_HEADER       pOwningObject,
    IN  PVOID                   pClientContext,
    IN  PRM_STACK_RECORD        pSR
    );

NDIS_STATUS
arpDbgFakeNdisClCloseCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle         OPTIONAL,
    IN  PVOID                   Buffer                  OPTIONAL,
    IN  UINT                    Size,                   OPTIONAL
    IN  PRM_OBJECT_HEADER       pOwningObject,
    IN  PVOID                   pClientContext,
    IN  PRM_STACK_RECORD        pSR
    );


VOID
arpDbgFakeNdisCoSendPackets(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets,
    IN  PRM_OBJECT_HEADER       pOwningObject,
    IN  PVOID                   pClientContext
    );


//
// The following defines and prototypes are exposed here just so that they
// are accessable to the component tests under .\tests.
//

#define RAN1X_MAX 2147483647

// ran1x returns randum unsigned longs in the range  0..RAN1X_MAX exclusive
// (i.e., 1..(RAN1X_MAX-1) inclusive).
//
unsigned long ran1x(
    void
    );

// like "srand" -- sets the seed.
//
void
sran1x(
    unsigned long seed
    );

typedef struct
{
    INT     Outcome;        // Value of this outcome
    UINT    Weight;         // Relative weight of this outcome

} OUTCOME_PROBABILITY;

INT
arpGenRandomInt(
    OUTCOME_PROBABILITY *rgOPs,
    UINT cOutcomes
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\ip.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ip.c

Abstract:

    ARP1394 IP-related handlers.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     01-06-98    Created (adapted from atmarpc.sys, arpif.c)

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_IP

#define CLASSA_MASK     0x000000ff
#define CLASSB_MASK     0x0000ffff
#define CLASSC_MASK     0x00ffffff
#define CLASSD_MASK     0x000000e0
#define CLASSE_MASK     0xffffffff




//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================
  
ULONG ArpSendCompletes = 0;
ULONG ArpSends = 0;
ULONG ArpSendFailure = 0;


#define LOGSTATS_SendFifoCounts(_pIF, _pNdisPacket, _Status) \
            arpLogSendFifoCounts(_pIF, _pNdisPacket, _Status)
#define LOGSTATS_SendChannelCounts(_pIF, _pNdisPacket, _Status) \
            arpLogSendChannelCounts(_pIF, _pNdisPacket, _Status)
#define LOGSTATS_TotalArpCacheLookups(_pIF, _Status)        \
    NdisInterlockedIncrement(&((_pIF)->stats.arpcache.TotalLookups))

const
NIC1394_ENCAPSULATION_HEADER
Arp1394_IpEncapHeader =
{
    0x0000,     // Reserved
    H2N_USHORT(NIC1394_ETHERTYPE_IP)
};

//
// ZZZ This is a little-endian specific check.
//
#define ETH_IS_MULTICAST(Address) \
    (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x01))


//
// Check whether an address is broadcast.
//
#define ETH_IS_BROADCAST(Address)               \
    ((((PUCHAR)(Address))[0] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[1] == ((UCHAR)0xff)))

VOID
arpReStartInterface(
    IN  PNDIS_WORK_ITEM             pWorkItem,
    IN  PVOID                       IfContext
);

VOID
arpInitializeLocalIp(
    IN  ARPCB_LOCAL_IP * pLocalIp,  // LOCKIN NOLOCKOUT
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
arpUnloadLocalIp(
    IN  ARPCB_LOCAL_IP * pLocalIp,  // LOCKIN NOLOCKOUT
    IN  PRM_STACK_RECORD            pSR
    );

INT
arpQueryIpEntityId(
    ARP1394_INTERFACE *             pIF,
    IN      UINT                    EntityType,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    PRM_STACK_RECORD                pSR
    );

VOID
nicGetMacAddressFromEuid (
    UINT64 *pEuid, 
    ENetAddr *pMacAddr
    );

INT
arpQueryIpAddrXlatInfo(
    ARP1394_INTERFACE *             pIF,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    PRM_STACK_RECORD                pSR
    );

INT
arpQueryIpAddrXlatEntries(
    ARP1394_INTERFACE *             pIF,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    IN      PVOID                   QueryContext,
    PRM_STACK_RECORD                pSR
    );

INT
arpQueryIpMibStats(
    ARP1394_INTERFACE *             pIF,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    PRM_STACK_RECORD                pSR
    );

PNDIS_BUFFER
arpCopyToNdisBuffer(
    IN  PNDIS_BUFFER                pDestBuffer,
    IN  PUCHAR                      pDataSrc,
    IN  UINT                        LenToCopy,
    IN OUT  PUINT                   pOffsetInBuffer
    );

VOID
arpSendIpPkt(
    IN  ARP1394_INTERFACE       *   pIF,            // LOCKIN NOLOCKOUT (IF send lk)
    IN  PARPCB_DEST                 pDest,
    IN  PNDIS_PACKET                pNdisPacket
    );

VOID
arpAddRce(
    IN  ARPCB_REMOTE_IP *pRemoteIp,
    IN  RouteCacheEntry *pRCE,
    IN  PRM_STACK_RECORD pSR
    );

VOID
arpDelRce(
    IN  RouteCacheEntry *pRce,  // IF send lock WRITELOCKIN WRITELOCKOUTD
    IN  PRM_STACK_RECORD pSR
    );

NDIS_STATUS
arpTaskSendPktsOnRemoteIp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

VOID
arpTryResumeSuspendedCleanupTask(
    IN  ARP1394_INTERFACE   *   pIF,
    IN  ARPCB_DEST          *   pDest
    );

VOID
arpQueuePktOnRemoteIp(
    IN  ARPCB_REMOTE_IP     *   pRemoteIp,      // LOCKIN LOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    IN  PRM_STACK_RECORD    pSR
    );

VOID
arpSendPktsQueuedOnRemoteIp(
    IN  ARP1394_INTERFACE   *   pIF,            // NOLOCKIN NOLOCKOUT
    IN  ARPCB_REMOTE_IP     *   pRemoteIp,      // NOLOCKIN NOLOCKOUT
    IN  PRM_STACK_RECORD    pSR
    );

MYBOOL
arpIsNonUnicastIpAddress(
    IN  PARP1394_INTERFACE          pIF,        // LOCKIN LOCKOUT
    IN  IP_ADDRESS                  Addr,
    IN  PRM_STACK_RECORD            pSR
    );

MYBOOL
arpIsNonUnicastEthAddress (
    IN  PARP1394_INTERFACE          pIF,        // LOCKIN LOCKOUT
    IN  ENetAddr*                   pAddr,
    IN  PRM_STACK_RECORD            pSR
);

VOID
arpLoopbackNdisPacket(
    IN PARP1394_INTERFACE pIF,
    IN PARPCB_DEST pBroadcastDest,
    IN PNDIS_PACKET pOldPacket
    );



//=========================================================================
//                  I P     H A N D L E R S
//=========================================================================


INT
ArpIpDynRegister(
    IN  PNDIS_STRING                pAdapterString,
    IN  PVOID                       IpContext,
    IN  struct _IP_HANDLERS *       pIpHandlers,
    IN  struct LLIPBindInfo *       pBindInfo,
    IN  UINT                        InterfaceNumber
)
/*++

Routine Description:

    This routine is called from the IP layer when it wants to tell us,
    the ARP module, about its handlers for an Interface.

Arguments:

    pAdapterString      - Name of the logical adapter for this interface
    IpContext           - IP's context for this interface
    pIpHandlers         - Points to struct containing the IP handlers
    pBindInfo           - Pointer to bind info with our information
    InterfaceNumber     - ID for this interface

Return Value:

    TRUE always.

--*/
{
    ENTER("IfDynRegister", 0xc1b569b9)
    ARP1394_INTERFACE*          pIF;
    RM_DECLARE_STACK_RECORD(sr)
    pIF = (ARP1394_INTERFACE*)(pBindInfo->lip_context);

    TR_INFO(("pIF 0x%p\n", pIF));
    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);

    LOCKOBJ(pIF, &sr);

    //
    // TODO: fail if we're not in a position to do this -- such as when shutting
    // down.
    //

    pIF->ip.Context         = IpContext;
    pIF->ip.RcvHandler      = pIpHandlers->IpRcvHandler;
    pIF->ip.TxCmpltHandler  = pIpHandlers->IpTxCompleteHandler;
    pIF->ip.StatusHandler   = pIpHandlers->IpStatusHandler;
    pIF->ip.TDCmpltHandler  = pIpHandlers->IpTransferCompleteHandler;
    pIF->ip.RcvCmpltHandler = pIpHandlers->IpRcvCompleteHandler;
    pIF->ip.PnPEventHandler = pIpHandlers->IpPnPHandler;
    pIF->ip.RcvPktHandler   = pIpHandlers->IpRcvPktHandler;
    pIF->ip.IFIndex         = InterfaceNumber;

    UNLOCKOBJ(pIF, &sr);
    //
    RM_ASSERT_CLEAR(&sr);
    EXIT()

    return TRUE;
}


VOID
ArpIpOpen(
    IN  PVOID                       Context
)
/*++

Routine Description:

    This routine is called when IP is ready to use this interface.

Arguments:

    Context     - Actually a pointer to our ARP394_INTERFACE structure

--*/
{
    ARP1394_INTERFACE*          pIF;
    ENTER("ArpIpOpen", 0x7cae1e55)
    RM_DECLARE_STACK_RECORD(sr)

    TR_INFO(("Enter. pContext = 0x%p\n", Context));

    pIF = (ARP1394_INTERFACE*) Context;

    // Validate context.
    //
    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);

    LOCKOBJ(pIF, &sr);

    // Get the local HW address if we don't have it yet
    //
    {
        // TODO (this is from ip/atm -- I think in our case we can assume we have
        // it?)
    }
    
    //  Mark interface as open.
    //
    {
        ASSERT(CHECK_IF_IP_STATE(pIF, ARPIF_IPS_CLOSED));
        SET_IF_IP_STATE(pIF, ARPIF_IPS_OPEN);
        pIF->stats.LastChangeTime = GetTimeTicks();

    }

#if ARP_WMI
    //
    // Register interface with WMI
    //
    // TODO
#endif // ARP_WMI

    // Record the fact that we're open, to verify that the IF is closed before
    // the IF block is deallocated.
    //
    DBG_ADDASSOC(&pIF->Hdr, NULL, NULL, ARPASSOC_IP_OPEN, "    IP IF Open\n", &sr);

    UNLOCKOBJ(pIF, &sr);

    RM_ASSERT_CLEAR(&sr);
    EXIT()
}



VOID
ArpIpClose(
    IN  PVOID                       Context
)
/*++

Routine Description:

    IP wants to stop using this Interface.

Arguments:

    Context     - Actually a pointer to our ARP1394_INTERFACE structure

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    PRM_TASK pTask;
    BOOLEAN fResumeTask = FALSE;
    ENTER("ArpIpClose", 0xdb8c8216)
    RM_DECLARE_STACK_RECORD(sr)

    TR_INFO(("Enter. pContext = 0x%p\n", Context));
    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);

    LOCKOBJ(pIF, &sr);

    //
    //Set state to closed.
    //

    SET_IF_IP_STATE(pIF, ARPIF_IPS_CLOSED);
    pIF->stats.LastChangeTime= GetTimeTicks();


    // (delete "ARPASSOC_IP_OPEN" association added in arpIpOpen)
    //
    DBG_DELASSOC(&pIF->Hdr, NULL, NULL, ARPASSOC_IP_OPEN, &sr);

    // If there is a shutdown task pending, we notify it
    // Note: a task is protected by it's parent object's lock, which is
    // pIF in the case of the init and shutdown-interface tasks.
    //
    pTask = pIF->pActDeactTask;
    if (pTask && pTask->pfnHandler  ==  arpTaskDeactivateInterface)
    {
        TASK_DEACTIVATE_IF  *pShutdownTask = 
                                 (TASK_DEACTIVATE_IF    *) pTask;
        if (pShutdownTask->fPendingOnIpClose)
        {
            ASSERT(pIF->ip.Context == NULL);
            RmTmpReferenceObject(&pTask->Hdr, &sr);
            fResumeTask = TRUE;
        }
        else
        {
            // Hmm... unsolicited IpClose. We don't expect this currently.
            //
            ASSERT(FALSE);
            pIF->ip.Context = NULL;
        }
    }

    UNLOCKOBJ(pIF, &sr);

    if (fResumeTask)
    {
        RmResumeTask(pTask, (UINT_PTR) 0, &sr);
        RmTmpDereferenceObject(&pTask->Hdr, &sr);
    }

    RM_ASSERT_CLEAR(&sr);
    EXIT()
}


UINT
ArpIpAddAddress(
    IN  PVOID                       Context,
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask,
    IN  PVOID                       Context2
)
/*++

Routine Description:

    The IP layer calls this when a new IP address (or block of IP addresses,
    as determined by AddressType) needs to be added to an Interface.

    We could see any of four address types: Local, Multicast, Broadcast
    and Proxy ARP. In the case of Proxy ARP, the address along with the mask
    can specify a block of contiguous IP addresses for which this host acts
    as a proxy. Currently, we only support the "Local", "Broadcast", and
    "Multicast" types.

Arguments:

    Context         - Actually a pointer to our structure
    AddressType     - Type of address(es) being added.
    IpAddress       - Address to be added.
    Mask            - For the above.
    Context2        - Additional context (We ignore this)

Return Value:

    TRUE if successful, FALSE otherwise.

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    ENTER("ArpIpAddAddress", 0xd6630961)
    INT fCreated = FALSE;
    ARPCB_LOCAL_IP *pLocalIp = NULL;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    RM_DECLARE_STACK_RECORD(sr)

    TR_INFO(("Enter. pIF = 0x%p\n", pIF));
    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);

#if OBSOLETE // Instead, we grab IF lock and don't specify the RM_LOCK flag.
             // See notes.txt  entry "03/05/1999  More corny locking problems"
    //
    // WARNING: We SHOULD NOT grab the IF lock, because we request that
    // the pLocalIp's lock be grabbed in RmLookupObjectInGroup below,
    // AND the pLocalIp's lock is actually the same as the IF lock.
    // (This is asserted later on below).
    // So obviously we can't get the IF lock here! (And we don't need to either).
    //
#endif
    LOCKOBJ(pIF, &sr);

    // We're not yet in the open state -- we're "opening", so we don't assert...
    // ASSERT(!CHECK_IF_OPEN_STATE(pIF, ARPIF_CLOSED));

    do
    {
        //
        // Note: we could just as well have done the initialiation as part of
        // the creation of the LocalIpObject itself, by passing in all the
        // required initialization params in the pvCreateParams arg to
        // RmLookupObjectInGroup. Instead we choose to do the initialization
        // ourselves. Things are more explicit this way.
        //

        // Unfortunately, to do this we must first validate the args...
        //
        if (AddressType != LLIP_ADDR_BCAST &&
            AddressType != LLIP_ADDR_MCAST &&
            AddressType != LLIP_ADDR_LOCAL)
        {
            break;
        }

        Status = RmLookupObjectInGroup(
                            &pIF->LocalIpGroup,
                            RM_CREATE,
                            (PVOID) ULongToPtr (IpAddress),             // pKey
                            (PVOID) ULongToPtr (IpAddress),             // pvCreateParams
                            &(PRM_OBJECT_HEADER)pLocalIp,
                            &fCreated,
                            &sr
                            );
        if (FAIL(Status)) break;

        //
        // NOTE: we already have claimed the pIF lock, which
        // which is the same as the pIF lock.
        //
        RM_ASSERT_SAME_LOCK_AS_PARENT(pLocalIp);

        // (Dbg only) Change lock scope from pIF to pLocalIp.
        //
        RmDbgChangeLockScope(
            &pIF->Hdr,
            &pLocalIp->Hdr,
            0x9cbc0b52,             // LocID
            &sr
            );

        if (fCreated)
        {

            if (AddressType == LLIP_ADDR_BCAST)
            {
                // Update the interface's broadcast address...
                //
                pIF->ip.BroadcastAddress = IpAddress;
            }
            else if (AddressType == LLIP_ADDR_LOCAL)
            {
                // Update the interface's default local IP address.
                // TODO: need to find another one if this address is removed.
                //
                pIF->ip.DefaultLocalAddress = IpAddress;
            }



            arpInitializeLocalIp(
                    pLocalIp,
                    AddressType,
                    IpAddress,
                    Mask,
                    &sr
                    );
            //
            // pLocalIp's lock is released above (which is actually the IF lock).
            //
            RM_ASSERT_NOLOCKS(&sr);
        }
        else
        {
            //
            // Hmm... this IP address already existed. Apparently it's possible for
            // MCAST addreses (IP/ATM arp module dealt with this for the MCAST case).
            // We don't special-case LOCAL/BCAST/MCAST addresses at this stage,
            // so we support multiple adds for all types of local IP addresses.
            //
            ASSERTEX(pLocalIp->AddAddressCount>0, pLocalIp);
            pLocalIp->AddAddressCount++;
        }

        RmTmpDereferenceObject(&pLocalIp->Hdr, &sr);

    } while (FALSE);

    TR_INFO((
            "IF 0x%p, Type %d, Addr %d.%d.%d.%d, Mask 0x%p, pLocIp 0x%p, Ret %d\n",
            pIF,
            AddressType,
            ((PUCHAR)(&IpAddress))[0],
            ((PUCHAR)(&IpAddress))[1],
            ((PUCHAR)(&IpAddress))[2],
            ((PUCHAR)(&IpAddress))[3],
            Mask, pLocalIp, !FAIL(Status)));

    RmUnlockAll(&sr);

    RM_ASSERT_CLEAR(&sr);
    EXIT()

    return !FAIL(Status);

}


UINT
ArpIpDelAddress(
    IN  PVOID                       Context,
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask
)
/*++

Routine Description:

    This is called from the IP layer when an address added via ArpIpAddAddress
    is to be deleted.

    Assumption: the given address was successfully added earlier.

Arguments:

    Context         - Actually a pointer to our Interface structure
    AddressType     - Type of address(es) being deleted.
    IpAddress       - Address to be deleted.
    Mask            - For the above.

Return Value:

    TRUE if successful, FALSE otherwise.

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    ENTER("ArpIpDelAddress", 0xd6630961)
    ARPCB_LOCAL_IP *pLocalIp = NULL;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    RM_DECLARE_STACK_RECORD(sr)

    TR_INFO(("Enter. pIF = 0x%p\n", Context));
    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);

#if OBSOLETE // See ArpIpAddAddress
    //
    // WARNING: We SHOULD NOT grab the IF lock, because we request that
    // the pLocalIp's lock be grabbed in RmLookupObjectInGroup below,
    // AND the pLocalIp's lock is actually the same as the IF lock.
    // (This is asserted later on below).
    // So obviously we can't get the IF lock here! (And we don't need to either).
    //
#endif // OBSOLETE

    LOCKOBJ(pIF, &sr);

    ASSERT(!CHECK_IF_IP_STATE(pIF, ARPIF_IPS_CLOSED));

    do
    {

        Status = RmLookupObjectInGroup(
                            &pIF->LocalIpGroup,
                            0,                   // Flags
                            (PVOID) ULongToPtr (IpAddress),  // pKey
                            NULL,                // pvCreateParams
                            &(PRM_OBJECT_HEADER)pLocalIp,
                            NULL, // pfCreated
                            &sr
                            );
        if (FAIL(Status))
        {
            UNLOCKOBJ(pIF, &sr);
            break;
        }

        //
        // NOTE: we have the pLocalIp lock, which is the same as the pIF lock.
        //
        RM_ASSERT_SAME_LOCK_AS_PARENT(pLocalIp);

        // (Dbg only) Change lock scope from pIF to pLocalIp.
        //
        RmDbgChangeLockScope(
            &pIF->Hdr,
            &pLocalIp->Hdr,
            0x188ed5b3,         // LocID
            &sr
            );

        if (pLocalIp->AddAddressCount <= 1)
        {
            ASSERTEX(pLocalIp->AddAddressCount == 1, pLocalIp);

            arpUnloadLocalIp(
                    pLocalIp,
                    &sr
                    );
            //
            // pLocalIp's lock is released above.
            //
            RM_ASSERT_NOLOCKS(&sr);
        }
        else
        {
            pLocalIp->AddAddressCount--;
            UNLOCKOBJ(pLocalIp, &sr);
        }

        RmTmpDereferenceObject(&pLocalIp->Hdr, &sr);

    } while (FALSE);

    TR_INFO((
            "IF 0x%p, Type %d, Addr %d.%d.%d.%d, Mask 0x%p, pLocIp 0x%p, Ret %d\n",
            pIF,
            AddressType,
            ((PUCHAR)(&IpAddress))[0],
            ((PUCHAR)(&IpAddress))[1],
            ((PUCHAR)(&IpAddress))[2],
            ((PUCHAR)(&IpAddress))[3],
            Mask, pLocalIp, !FAIL(Status)));

    RM_ASSERT_CLEAR(&sr);
    EXIT()
    return !FAIL(Status);
}


NDIS_STATUS
ArpIpMultiTransmit(
    IN  PVOID                       Context,
    IN  PNDIS_PACKET *              pNdisPacketArray,
    IN  UINT                        NumberOfPackets,
    IN  IP_ADDRESS                  Destination,
    IN  RouteCacheEntry *           pRCE        OPTIONAL,
    IN  void *                  ArpCtxt
)
/*++

    TODO: implement send array-of-packets. Currenty we just call
    ArpIpTransmit multiple times. We'll gain a few cycles by processing
    all at once, although it's not going to be a big gain, because we're pretty
    fast with the single-packet case, provided the RCE is valid.

Routine Description:

    This is called from the IP layer when it has a sequence of datagrams,
    each in the form of an NDIS buffer chain, to send over an Interface.

Arguments:

    Context             - Actually a pointer to our Interface structure
    pNdisPacketArray    - Array of Packets to be sent on this Interface
    NumberOfPackets     - Length of array
    Destination         - IP address of next hop for this packet
    pRCE                - Optional pointer to Route Cache Entry structure.

Return Value:

    NDIS_STATUS_PENDING if all packets were queued for transmission.
    If one or more packets "failed", we set the packet status to reflect
    what happened to each, and return NDIS_STATUS_FAILURE.

--*/
{
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    PNDIS_PACKET *      ppNdisPacket;

    for (ppNdisPacket = pNdisPacketArray;
         NumberOfPackets > 0;
         NumberOfPackets--, ppNdisPacket++)
    {
        PNDIS_PACKET            pNdisPacket;

        pNdisPacket = *ppNdisPacket;
        NDIS_SET_PACKET_STATUS(pNdisPacket, NDIS_STATUS_PENDING);
        ASSERTEX(pNdisPacket->Private.Head != NULL, pNdisPacket);

        Status = ArpIpTransmit(
                        Context,
                        *ppNdisPacket,
                        Destination,
                        pRCE
                        ,NULL
                        );

        if (Status != NDIS_STATUS_PENDING)
        {
            NDIS_SET_PACKET_STATUS(*ppNdisPacket, Status);
            break;
        }
    }

    return Status;
}


NDIS_STATUS
ArpIpTransmit(
    IN  PVOID                       Context,
    IN  PNDIS_PACKET                pNdisPacket,
    IN  IP_ADDRESS                  Destination,
    IN  RouteCacheEntry *           pRCE        OPTIONAL,
    IN  void *                  ArpCtxt
)
/*++

    HOT PATH
    
Routine Description:

    This is called from the IP layer when it has a datagram (in the form of
    an NDIS buffer chain) to send over an Interface.

    The destination IP address is passed to us in this routine, which may
    or may not be the final destination for the packet. 

    The Route Cache Entry is created by the IP layer, and is used to speed
    up our lookups. An RCE, if specified, uniquely identifies atleast the
    IP destination for this packet. The RCE contains space for the ARP layer
    to keep context information about this destination. When the first packet
    goes out to a Destination, our context info in the RCE will be NULL, and
    we search the ARP Table for the matching IP Entry. However, we then fill
    our context info (pointer to IP Entry) in the RCE, so that subsequent
    transmits aren't slowed down by an IP address lookup.

Arguments:

    Context             - Actually a pointer to our Interface structure
    pNdisPacket         - Packet to be sent on this Interface
    Destination         - IP address of next hop for this packet
    pRCE                - Optional pointer to Route Cache Entry structure.

Return Value:

    Status of the transmit: NDIS_STATUS_SUCCESS, NDIS_STATUS_PENDING, or
    a failure.

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    ARP1394_ADAPTER * pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF );
    NDIS_STATUS Status;
    REMOTE_DEST_KEY        DestinationKey;
    ARP_INIT_REENTRANCY_COUNT()
    ENTER("IfTransmit", 0x46f1973e)

    ARP_INC_REENTRANCY();
    ASSERT_VALID_INTERFACE(pIF);

    // IP does sometimes call this function before we set our state to OPEN,
    // so this is an incorrect assert...
    // ASSERT(!CHECK_IF_IP_STATE(pIF, ARPIF_IPS_CLOSED));

    TR_INFO((
        "pIf 0x%p, Pkt 0x%p, Dst 0x%p, pRCE 0x%p\n",
        pIF, pNdisPacket, Destination, pRCE));

    DBGMARK(0xf87d7fff);
    NdisInterlockedIncrement (&ArpSends);

    // Since we don't hold any locks, this check is approximate, but it should
    // prevent lots of useless activity while we're trying to shutdown.
    //
    // Check for not Inited Or Low Power
    if (!CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_INITED) || 
        (! CHECK_POWER_STATE(pAdapter, ARPAD_POWER_NORMAL) ))

    {
        TR_INFO(("Failing ArpIpTransmit because pIF 0x%p is closing.\n", pIF));

        ARP_DEC_REENTRANCY();
        NdisInterlockedIncrement (&ArpSendCompletes);
        NdisInterlockedIncrement (&ArpSendFailure);
        return NDIS_STATUS_FAILURE;                             // EARLY_RETURN
    }

#define LOGSTATS_TotSends(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.sendpkts.TotSends))

#define LOGSTATS_SetPktTimestamp(_pIF, _pNdisPacket)                    \
    {                                                                   \
        LARGE_INTEGER liTemp = KeQueryPerformanceCounter(NULL);         \
        *(PULONG) ((_pNdisPacket)->WrapperReservedEx) = liTemp.LowPart; \
    }

    LOGSTATS_TotSends(pIF, pNdisPacket);
    LOGSTATS_SetPktTimestamp(pIF, pNdisPacket);

    //
    // If there is a RCE, we'll try to quickly get all the information we need
    // and send off the packet. If we can't do this, we resort to the 
    //  "slow send path" (call arpIpSlowtransmit)...
    //
    if (pRCE != NULL)
    {
        ARP_RCE_CONTEXT *   pArpRceContext;
        ARPCB_REMOTE_IP *   pRemoteIp;
        
        pArpRceContext =  ARP_OUR_CTXT_FROM_RCE(pRCE);

        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        pRemoteIp =  pArpRceContext->pRemoteIp;

        //
        // Validate the Remote Ip. If it not meant for this packet
        // fall back to the slow path
        //
        if (pRemoteIp != NULL && pRemoteIp->IpAddress == Destination)
        {
            ARPCB_DEST      *   pDest;

            pDest = pRemoteIp->pDest;
            if (pDest != NULL )
            {
                //
                // Note: pDest->sendinfo is protected by the IF send lock.
                //
                if (ARP_CAN_SEND_ON_DEST(pDest))
                {

#define LOGSTATS_FastSends(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.sendpkts.FastSends))

                    LOGSTATS_FastSends(pIF, pNdisPacket);

                    arpSendIpPkt(pIF, pDest, pNdisPacket);
                    //
                    // IF Send lock released above.

                    ARP_DEC_REENTRANCY();
                    return NDIS_STATUS_PENDING;                 // EARLY RETURN
                }
            }
        }
        else
        {
            // if we have a mismatched RCE , then the RCE should be ignored
            // i,e. not be propagated to the SlowIpTransmit.
            //
            if (pRemoteIp != NULL && pRemoteIp->IpAddress != Destination)
            {
                pRCE = NULL;
            }
            
        }

        //
        // If we get here, it's on to slow path...
        //
        ARP_FASTUNLOCK_IF_SEND_LOCK(pIF);

    }

    // The slow path...
    //
    REMOTE_DEST_KEY_INIT(&DestinationKey);
    DestinationKey.IpAddress = Destination;
    Status = arpSlowIpTransmit(
                    pIF,
                    pNdisPacket,
                    DestinationKey,
                    pRCE
                    );

    if (Status != NDIS_STATUS_PENDING)
    {
        LOGSTATS_SendFifoCounts(pIF, pNdisPacket, Status);
    }

    ARP_DEC_REENTRANCY();
    EXIT()

    return Status;
}


NDIS_STATUS
ArpIpTransfer(
    IN  PVOID                       Context,
    IN  NDIS_HANDLE                 Context1,
    IN  UINT                        ArpHdrOffset,
    IN  UINT                        ProtoOffset,
    IN  UINT                        BytesWanted,
    IN  PNDIS_PACKET                pNdisPacket,
    OUT PUINT                       pTransferCount
)
/*++

Routine Description:

    This routine is called from the IP layer in order to copy in the
    contents of a received packet that we indicated up earlier. The
    context we had passed up in the receive indication is given back to
    us, so that we can identify what it was that we passed up.

    We simply call NDIS to do the transfer.

Arguments:

    Context             - Actually a pointer to our Interface structure
    Context1            - Packet context we had passed up (pointer to NDIS packet)
    ArpHdrOffset        - Offset we had passed up in the receive indicate
    ProtoOffset         - The offset into higher layer protocol data to start copy from
    BytesWanted         - The amount of data to be copied
    pNdisPacket         - The packet to be copied into
    pTransferCount      - Where we return the actual #bytes copied

Return Value:

    NDIS_STATUS_SUCCESS always.

--*/
{
    ENTER("IfTransfer", 0xa084562c)

    TR_INFO((
     "Ctx 0x%p, Ctx1 0x%p, HdrOff %d, ProtOff %d, Wanted %d, Pkt 0x%p\n",
            Context,
            Context1,
            ArpHdrOffset,
            ProtoOffset,
            BytesWanted,
            pNdisPacket));

    NdisCopyFromPacketToPacket(
            pNdisPacket,
            0,
            BytesWanted,
            (PNDIS_PACKET)Context1,
            ArpHdrOffset+ProtoOffset,
            pTransferCount
            );

    EXIT()
    return NDIS_STATUS_SUCCESS;
}


VOID
ArpIpInvalidate(
    IN  PVOID                       Context,
    IN  RouteCacheEntry *           pRCE
)
/*++

Routine Description:

    This routine is called from the IP layer to invalidate a Route Cache
    Entry. If this RCE is associated with one of our IP Entries, unlink
    it from the list of RCE's pointing to that IP entry.

Arguments:

    Context             - Actually a pointer to our Interface structure
    pRCE                - Pointer to Route Cache Entry being invalidated.

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    ENTER("ArpIpInvalidate", 0xee77fb09)
    RM_DECLARE_STACK_RECORD(sr)

    TR_INFO(("Enter. pIF = 0x%p pRCE=0x%p\n", pIF, pRCE));

    ASSERT_VALID_INTERFACE(pIF);
    ASSERT(pRCE != NULL);

    DBGMARK(0xe35c780d);

    ARP_WRITELOCK_IF_SEND_LOCK(pIF, &sr);
    arpDelRce(pRCE, &sr);
    ARP_UNLOCK_IF_SEND_LOCK(pIF, &sr);

    RM_ASSERT_CLEAR(&sr);
    EXIT()


}


INT
ArpIpQueryInfo(
    IN      PVOID                   Context,
    IN      TDIObjectID *           pID,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    IN      PVOID                   QueryContext
)
/*++

Routine Description:

    This is called from the IP layer to query for statistics or other
    information about an interface.

Arguments:

    Context                 - Actually a pointer to our Interface
    pID                     - Describes the object being queried
    pNdisBuffer             - Space for returning information
    pBufferSize             - Pointer to size of above. On return, we fill
                              it with the actual bytes copied.
    QueryContext            - Context value pertaining to the query.

Return Value:

    TDI Status code.

--*/
{
    UINT                    EntityType;
    UINT                    Instance;
    INT                     ReturnStatus;
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    ENTER("ArpIpQueryInfo", 0x15059be1)
    RM_DECLARE_STACK_RECORD(sr)


    EntityType = pID->toi_entity.tei_entity;
    Instance = pID->toi_entity.tei_instance;


    TR_VERB((
        "IfQueryInfo: pIf 0x%p, pID 0x%p, pBuf 0x%p, Size %d, Ent %d, Inst %d\n",
            pIF, pID, pNdisBuffer, *pBufferSize, EntityType, Instance));
    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);

    //
    //  Initialize
    //
    ReturnStatus = TDI_INVALID_PARAMETER;

    LOCKOBJ(pIF, &sr);

    do
    {
        if (!CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_INITED))
        {
            if (!CHECK_IF_ACTIVE_STATE(pIF, ARPIF_AS_ACTIVATING))
            {
                ReturnStatus = TDI_INVALID_REQUEST;
                break;
            }
        }

        //
        //  Check the Entity and Instance values.
        //

        if ((EntityType != AT_ENTITY || Instance != pIF->ip.ATInstance) &&
            (EntityType != IF_ENTITY || Instance != pIF->ip.IFInstance))
        {
            TR_INFO(
                ("Mismatch: Entity %d, AT_ENTITY %d, Inst %d, IF AT Inst %d, IF_ENTITY %d, IF IF Inst %d\n",
                    EntityType,
                    AT_ENTITY,
                    Instance,
                    pIF->ip.ATInstance,
                    IF_ENTITY,
                    pIF->ip.IFInstance
                ));

            ReturnStatus = TDI_INVALID_REQUEST;
            break;
        }


        TR_VERB(("QueryInfo: pID 0x%p, toi_type %d, toi_class %d, toi_id %d\n",
            pID, pID->toi_type, pID->toi_class, pID->toi_id));


        if (pID->toi_type != INFO_TYPE_PROVIDER)
        {
            TR_INFO(("toi_type %d != PROVIDER (%d)\n",
                    pID->toi_type,
                    INFO_TYPE_PROVIDER));

            break;
        }

        if (pID->toi_class == INFO_CLASS_GENERIC)
        {
            if (pID->toi_id == ENTITY_TYPE_ID)
            {
                ReturnStatus = arpQueryIpEntityId(
                                        pIF,
                                        EntityType,
                                        pNdisBuffer,
                                        pBufferSize,
                                        &sr
                                        );
            }
            break;
        }

        if (EntityType == AT_ENTITY)
        {
            //
            //  This query is for an Address Translation Object.
            //
            if (pID->toi_id == AT_MIB_ADDRXLAT_INFO_ID)
            {
                ReturnStatus = arpQueryIpAddrXlatInfo(
                                        pIF,
                                        pNdisBuffer,
                                        pBufferSize,
                                        &sr
                                        );
            }
            else if (pID->toi_id == AT_MIB_ADDRXLAT_ENTRY_ID)
            {
                ReturnStatus = arpQueryIpAddrXlatEntries(
                                        pIF,
                                        pNdisBuffer,
                                        pBufferSize,
                                        QueryContext,
                                        &sr
                                        );
            }
            else
            {
                ReturnStatus = TDI_INVALID_PARAMETER;
            }
            break;
        }

        if (    pID->toi_class == INFO_CLASS_PROTOCOL
            &&  pID->toi_id == IF_MIB_STATS_ID)
        {
            ReturnStatus = arpQueryIpMibStats(
                                        pIF,
                                        pNdisBuffer,
                                        pBufferSize,
                                        &sr
                                        );
        }
    }
    while (FALSE);

    if (    ReturnStatus != TDI_SUCCESS
         && ReturnStatus != TDI_BUFFER_OVERFLOW
         && ReturnStatus != TDI_INVALID_REQUEST)
    {
        //
        // This again preserves the semantics of QueryInfo from atmarpc.sys...
        //
        *pBufferSize = 0;
    }

    TR_VERB(("Returning 0x%p (%s), BufferSize %d\n",
                    ReturnStatus,
                    ((ReturnStatus == TDI_SUCCESS)? "SUCCESS": "FAILURE"),
                    *pBufferSize
            ));

    UNLOCKOBJ(pIF, &sr);
    RM_ASSERT_CLEAR(&sr);
    EXIT()

    return (ReturnStatus);
}


INT
ArpIpSetInfo(
    IN      PVOID                   Context,
    IN      TDIObjectID *           pID,
    IN      PVOID                   pBuffer,
    IN      UINT                    BufferSize
)
/*++

Routine Description:

    This is called from the IP layer to set the value of an object
    for an interface.

Arguments:
    Context                 - Actually a pointer to our Interface
    pID                     - Describes the object being set
    pBuffer                 - Value for the object
    BufferSize              - Size of above

Return Value:

    TDI Status code.

--*/
{
    ARP1394_INTERFACE *pIF = (ARP1394_INTERFACE*) Context;
    UINT Entity, Instance;
    IFEntry *pIFE = (IFEntry *) pBuffer;
    NTSTATUS ReturnStatus = TDI_INVALID_REQUEST;
    IPNetToMediaEntry *IPNME = NULL;

    ENTER("IpSetInfo", 0x05dabea3)
    RM_DECLARE_STACK_RECORD(sr)

    //
    // This code is taken from the tcpip Arp module with some changes to adjust 
    // it to arp1394's internal structures
    //
    // This code only supports deleting Arp Entries
    //

    Entity = pID->toi_entity.tei_entity;
    Instance = pID->toi_entity.tei_instance;


    do
    {

        // First, make sure it's possibly an ID we can handle.
        if (Entity != AT_ENTITY || Instance != pIF->ip.ATInstance) 
        {
            TR_INFO(
                ("Mismatch: Entity %d, AT_ENTITY %d, Inst %d, IF AT Inst %d, IF_ENTITY %d, IF IF Inst %d\n",
                    Entity,
                    AT_ENTITY,
                    Instance,
                    pIF->ip.ATInstance,
                    IF_ENTITY,
                    pIF->ip.IFInstance
                ));

            ReturnStatus = TDI_INVALID_REQUEST;
            break;
        }

                
        if (pID->toi_type != INFO_TYPE_PROVIDER) {
            ReturnStatus = TDI_INVALID_REQUEST;
            break;

        }

    
        if (pID->toi_id != AT_MIB_ADDRXLAT_ENTRY_ID ||
            BufferSize < sizeof(IPNetToMediaEntry)) 
        {
            ReturnStatus = TDI_INVALID_REQUEST;
            break;
        }            

        // He does want to set an ARP table entry. See if he's trying to
        // create or delete one.

        IPNME = (IPNetToMediaEntry *) pBuffer;

        if (IPNME->inme_type != INME_TYPE_INVALID) 
        {
        
            ReturnStatus = TDI_INVALID_REQUEST;
            break;

        }

        // We need to delete the IP address passed in the ipnme struct                        
        
        ReturnStatus = arpDelArpEntry (pIF, IPNME->inme_addr, &sr);
        

    }while (FALSE);            


    
    return ReturnStatus;   // TBD: support Sets.
    EXIT();
    
}



INT
ArpIpGetEList(
    IN      PVOID                   Context,
    IN      TDIEntityID *           pEntityList,
    IN OUT  PUINT                   pEntityListSize
)
/*++

Routine Description:

    This routine is called when the interface starts up, in order to
    assign all relevant Entity Instance numbers for an interface.
    The ARP1394 module belongs to the "AT" and "IF" types. The entity
    list is a list of <Entity type, Instance number> tuples that have
    been filled in by other modules.

    For each of the entity types we support, we find the largest
    instance number in use (by walking thru the Entity list), and
    assign to ourselves the next larger number in each case. Using
    these numbers, we append our tuples to the end of the Entity list,
    if there is enough space.

    W2K: we may find that our entries are already present, in which
    case we don't create new entries.


Arguments:

    Context                 - Actually a pointer to our ARP1394_INTERFACE
    pEntityList             - Pointer to TDI Entity list
    pEntityListSize         - Pointer to length of above list. We update
                              this if we add our entries to the list.

Return Value:

    TRUE if successful, FALSE otherwise.

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    UINT                EntityCount;    // Total elements in Entity list
    UINT                i;              // Iteration counter
    UINT                MyATInstance;   // "AT" Instance number we assign to ourselves
    UINT                MyIFInstance;   // "IF" Instance number we assign to ourselves
    INT                 ReturnValue;
    TDIEntityID *       pATEntity;      // Points to our AT entry
    TDIEntityID *       pIFEntity;      // Points to our IF entry
    ENTER("ArpIpGetEList", 0x8b5190e5)
    RM_DECLARE_STACK_RECORD(sr)

    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);
    EntityCount = *pEntityListSize;
    pATEntity = NULL;
    pIFEntity = NULL;
    MyATInstance = MyIFInstance = 0;

    TR_INFO(("IfGetEList: pIf 0x%p, &pIF.ip 0x%p pList 0x%p, Cnt %d\n",
            pIF, &pIF->ip, pEntityList, EntityCount));

    LOCKOBJ(pIF, &sr);

    do
    {
        //
        //  Walk down the list, looking for AT/IF entries matching our
        //  instance values. Also remember the largest AT and IF instance
        //  values we see, so that we can allocate the next larger values
        //  for ourselves, in case we don't have instance values assigned.
        //
        for (i = 0; i < EntityCount; i++, pEntityList++)
        {
            //
            //  Skip invalid entries.
            //
            if (pEntityList->tei_instance == INVALID_ENTITY_INSTANCE)
            {
                continue;
            }

            if (pEntityList->tei_entity == AT_ENTITY)
            {
                if (pEntityList->tei_instance == pIF->ip.ATInstance)
                {
                    //
                    //  This is our AT entry.
                    //
                    pATEntity = pEntityList;
                }
                else
                {
                    if (MyATInstance < (pEntityList->tei_instance + 1))
                    {
                        MyATInstance = pEntityList->tei_instance + 1;
                    }
                }
            }
            else if (pEntityList->tei_entity == IF_ENTITY)
            {
                if (pEntityList->tei_instance == pIF->ip.IFInstance)
                {
                    //
                    //  This is our IF entry.
                    //
                    pIFEntity = pEntityList;
                }
                else
                {
                    if (MyIFInstance < (pEntityList->tei_instance + 1))
                    {
                        MyIFInstance = pEntityList->tei_instance + 1;
                    }
                }
            }
        }


        ReturnValue = TRUE;

        // WARNING: The following check is subtle -- we MUST set the instance
        // values to INVALID_ENTITY_INSTANCE when the interface is being
        // deactivated, but we MUST NOT do this if the interface is just opened
        // (ArpIpOpen called)  -- otherwise we could mess up the caller's state
        // to such an extent that a reboot is required. Basically our behaviour
        // here is what results in the proper acquiring AND release of instance IDs.
        //
        // So don't replace the following check by checking for
        // ARPIF_PS_INITED or ARPIF_IPS_OPEN or even ARPIF_PS_DEINITING.
        // The latter check (ARPIF_PS_DEINITING) would have been ok except for the
        // fact that the IF is deactivated/reactivated during ARPIF_PS_REINITING
        // as well, so the correct check is basically the one below...
        //
        //
        if(CHECK_IF_ACTIVE_STATE(pIF, ARPIF_AS_DEACTIVATING))
        {
            //
            // We're deactivating the interface, set values to invalid and
            // get out of here...
            //

            if (pATEntity)
            {
                pATEntity->tei_instance = INVALID_ENTITY_INSTANCE;
            }

            if (pIFEntity)
            {
                pIFEntity->tei_instance = INVALID_ENTITY_INSTANCE;
            }
            break;
        }

        //
        //  Update or create our Address Translation entry.
        //
        if (pATEntity)
        {
            //
            //  We found our entry, nothing to do...
            //
            TR_INFO(("YOWZA: Found existing AT entry.\n"));
        }
        else
        {
            //
            //  Grab an entry for ourselves...
            //
            TR_INFO(("YOWZA: Grabbing new AT entry 0x%lu.\n", MyATInstance));

            if (EntityCount >= MAX_TDI_ENTITIES)
            {
                ReturnValue = FALSE;
                break;
            }

            pEntityList->tei_entity = AT_ENTITY;
            pEntityList->tei_instance = MyATInstance;
            pIF->ip.ATInstance = MyATInstance;

            pEntityList++;
            (*pEntityListSize)++;
            EntityCount++;
        }

        //
        //  Update or create or IF entry.
        //
        if (pIFEntity)
        {
            //
            //  We found our entry, nothing to do...
            //
            TR_INFO(("YOWZA: Found existing IF entry.\n"));
        }
        else
        {
            //
            //  Grab an entry for ourselves.
            //
            TR_INFO(("YOWZA: Grabbing new IF entry 0x%lu.\n", MyIFInstance));

            if (EntityCount >= MAX_TDI_ENTITIES)
            {
                ReturnValue = FALSE;
                break;
            }

            pEntityList->tei_entity = IF_ENTITY;
            pEntityList->tei_instance = MyIFInstance;
            pIF->ip.IFInstance = MyIFInstance;

            pEntityList++;
            (*pEntityListSize)++;
            EntityCount++;
        }
    }
    while (FALSE);


    TR_INFO(
     ("IfGetEList: returning %d, MyAT %d, MyIF %d, pList 0x%p, Size %d\n",
        ReturnValue, MyATInstance, MyIFInstance, pEntityList, *pEntityListSize));

    UNLOCKOBJ(pIF, &sr);
    RM_ASSERT_CLEAR(&sr);
    EXIT()
    return (ReturnValue);
}



VOID
ArpIpPnPComplete(
    IN  PVOID                       Context,
    IN  NDIS_STATUS                 Status,
    IN  PNET_PNP_EVENT              pNetPnPEvent
)
/*++

Routine Description:

    This routine is called by IP when it completes a previous call
    we made to its PnP event handler. We complete the
    NDIS PNP notification that lead to this.

Arguments:

    Context                 - Actually a pointer to our ATMARP Interface
    Status                  - Completion status from IP
    pNetPnPEvent            - The PNP event

Return Value:

    None

--*/
{
    ENTER("ArpIpPnPComplete", 0x23b1941e)
    PARP1394_INTERFACE          pIF;

    pIF = (PARP1394_INTERFACE) Context;

    TR_INFO(("IfPnPComplete: IF 0x%p, Status 0x%p, Event 0x%p\n",
                    pIF, Status, pNetPnPEvent));

    if (pIF == NULL)
    {
        NdisCompletePnPEvent(
                    Status,
                    NULL,
                    pNetPnPEvent
                    );
    }
    else
    {
        PARP1394_ADAPTER pAdapter;
        ASSERT_VALID_INTERFACE(pIF);
        pAdapter = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);
        NdisCompletePnPEvent(
                Status,
                pAdapter->bind.AdapterHandle,
                pNetPnPEvent
                );
    }

    EXIT()
    return;
}



#ifdef PROMIS
EXTERN
NDIS_STATUS
ArpIpSetNdisRequest(
    IN  PVOID                       Context,
    IN  NDIS_OID                    Oid,
    IN  UINT                        On
)
/*++

Routine Description:

    ARP Ndisrequest handler.
    Called by the upper driver to set the packet filter for the interface.

Arguments:

       Context     - Actually a pointer to our ATMARP Interface
       OID         - Object ID to set/unset
       On          - Set_if, clear_if or clear_card

Return Value:

    Status

--*/
{
    return NDIS_STATUS_FAILURE;
#if 0
    NDIS_STATUS         Status      = NDIS_STATUS_SUCCESS;
    PATMARP_INTERFACE   pInterface  =  (PATMARP_INTERFACE)Context;

    AADEBUGP(AAD_INFO,("IfSetNdisRequest: pIF =0x%p; Oid=0x%p; On=%u\n",
                pInterface,
                Oid,
                On
                ));

    do
    {
        //
        //  We set IPAddress and mask to span the entire mcast address range...
        //
        IP_ADDRESS                  IPAddress   = IP_CLASSD_MIN; 
        IP_MASK                     Mask        = IP_CLASSD_MASK;
        UINT                        ReturnStatus = TRUE;
        NDIS_OID                    PrevOidValue;

        if (Oid != NDIS_PACKET_TYPE_ALL_MULTICAST)
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        AA_STRUCT_ASSERT(pInterface, aai);
        AA_ACQUIRE_IF_LOCK(pInterface);

        PrevOidValue = pInterface->EnabledIPFilters & NDIS_PACKET_TYPE_ALL_MULTICAST;

        if (On)
        {
            if (PrevOidValue == 0)
            {
                pInterface->EnabledIPFilters |= NDIS_PACKET_TYPE_ALL_MULTICAST;

                ReturnStatus = AtmArpMcAddAddress(pInterface, IPAddress, Mask);
                //
                // IF lock released above
                //
            }
            else
            {
                AA_RELEASE_IF_LOCK(pInterface);
            }
        }
        else
        {
            if (PrevOidValue != 0)
            {
                pInterface->EnabledIPFilters &= ~NDIS_PACKET_TYPE_ALL_MULTICAST;

                ReturnStatus = AtmArpMcDelAddress(pInterface, IPAddress, Mask);
                //
                // IF lock released above
                //
            }
            else
            {
                AA_RELEASE_IF_LOCK(pInterface);
            }
        }

        if (ReturnStatus != TRUE)
        {
            //
            // We've got to restore EnabledIPFilters to it's original value.
            //
            AA_ACQUIRE_IF_LOCK(pInterface);
            pInterface->EnabledIPFilters &= ~NDIS_PACKET_TYPE_ALL_MULTICAST;
            pInterface->EnabledIPFilters |= PrevOidValue;
            AA_RELEASE_IF_LOCK(pInterface);

            
            Status = NDIS_STATUS_FAILURE;
        }

    }
    while (FALSE);

    AADEBUGP(AAD_INFO, ("IfSetNdisRequest(pIF =0x%p) returns 0x%p\n",
            pInterface,
            Status
            ));

    return Status;
#endif // 0
}
#endif // PROMIS


VOID
arpInitializeLocalIp(
    IN  ARPCB_LOCAL_IP * pLocalIp,  // LOCKIN NOLOCKOUT
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize the specified local ip object. This includines starting 
    address registration for the object.

Arguments:

    pLocalIp        - The object to be initialized.
    AddressType     - One of the LLIP_ADDR_* constants.
    IpAddress       - The IP address of the object.
    Mask            - The mask associated with the IP address.

--*/
{
    ENTER("InitailizeLocalIp", 0x8a0ff47c)
        

    RM_DBG_ASSERT_LOCKED(&pLocalIp->Hdr, pSR);

    pLocalIp->IpAddress         = IpAddress;
    pLocalIp->IpMask            = Mask;
    pLocalIp->IpAddressType     = AddressType;
    pLocalIp->AddAddressCount   = 1;

    if (arpCanTryMcap(IpAddress))
    {
        SET_LOCALIP_MCAP(pLocalIp,  ARPLOCALIP_MCAP_CAPABLE);
    }

    UNLOCKOBJ(pLocalIp, pSR);

    EXIT()
}


VOID
arpUnloadLocalIp(
    IN  ARPCB_LOCAL_IP * pLocalIp,  // LOCKIN NOLOCKOUT
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Starts a task to unload pLocalIp.
    The actual unload could happen asynchronously.

Arguments:

    pLocalIp        - The object to be unloaded.

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) pLocalIp->Hdr.pParentObject;
    ENTER("arpDeinitializeLocalIp", 0x1db1015e)
    PRM_TASK pTask;
    NDIS_STATUS Status;

    TR_INFO(("Enter. pLocalIp = 0x%p\n", pLocalIp));

    RM_DBG_ASSERT_LOCKED(&pLocalIp->Hdr, pSR);

#if TODO // if it can be synchronously unloaded, no need to start a task
        // (on the other hand, I'm not sure we should bother)
    if (arpLocalIpReadyForSyncDeinit(pLocalIp, pSR))
    {
        arpSyncDeinitLocalIp(pLocalIp, pSR);    // Lock released on exit.
    }
#endif // TODO

    UNLOCKOBJ(pLocalIp, pSR);

    //
    // Allocate and start a task to unload pLocalIp;
    //

    Status = arpAllocateTask(
                &pLocalIp->Hdr,             // pParentObject
                arpTaskUnloadLocalIp,       // pfnHandler
                0,                              // Timeout
                "Task: unload LocalIp", // szDescription
                &pTask,
                pSR
                );


    if (FAIL(Status))
    {
        // TODO Need special allocation mechanism for unload-related tasks
        // that will block until a free task becomes available.
        // See notes.txt 03/09/1999 entry   "Special allocator for unload-related
        // tasks
        //
        TR_FATAL(("FATAL: couldn't alloc unload-local-ip task!\n"));
    }
    else
    {
        (void)RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    pSR
                    );
    }

    EXIT()
}


INT
arpQueryIpEntityId(
    ARP1394_INTERFACE *             pIF,                // LOCKIN LOCKOUT
    IN      UINT                    EntityType,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Return  the entity ID for the specified EntityType.

Arguments:

    pIF                     - Interface
    EntityType              - QueryInfo entity type (AT_*)
    pNdisBuffer             - Space for returning information
    pBufferSize             - Pointer to size of above. On return, we fill
                              it with the actual bytes copied.
Return Value:

    TDI Status code.

--*/
{
    ENTER("arpQueryIpEntityId", 0x1ada17cb)
    UINT ReturnStatus;

    RM_DBG_ASSERT_LOCKED(&pIF->Hdr, pSR);

    if (*pBufferSize >= sizeof(UINT))
    {
        UINT EntityId;
        UINT ByteOffset = 0;
        TR_VERB(
            ("INFO GENERIC, ENTITY TYPE, BufferSize %d\n", *pBufferSize));

        EntityId = ((EntityType == AT_ENTITY) ? AT_ARP: IF_MIB);
        arpCopyToNdisBuffer(
                pNdisBuffer,
                (PUCHAR)&EntityId,
                sizeof(EntityId),
                &ByteOffset);

        // *pBufferSize = sizeof(UINT); << This was commented-out in atmarpc.sys
        *pBufferSize = 0; // To keep the same behavior as atmarpc.sys
        ReturnStatus = TDI_SUCCESS;
    }
    else
    {
        ReturnStatus = TDI_BUFFER_TOO_SMALL;
    }

    return ReturnStatus;
}


INT
arpQueryIpAddrXlatInfo(
    ARP1394_INTERFACE *             pIF,                // LOCKIN LOCKOUT
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Request for the number of entries in the address translation
    table, and the IF index.

Arguments:

    pIF                     - Interface
    pNdisBuffer             - Space for returning information
    pBufferSize             - Pointer to size of above. On return, we fill
                              it with the actual bytes copied.
    QueryContext            - Context value pertaining to the query.

Return Value:

    TDI Status code.

--*/
{
    UINT ReturnStatus;
    AddrXlatInfo    Info;
    ENTER("arpQueryIpXlatInfo", 0xd320b55a)

    RM_DBG_ASSERT_LOCKED(&pIF->Hdr, pSR);

    TR_INFO(("QueryInfo: AT Entity, for IF index, ATE size\n"));

    if (*pBufferSize >= sizeof(Info))
    {
        UINT ByteOffset = 0;

        ARP_ZEROSTRUCT(&Info);
        *pBufferSize = sizeof(Info);

        Info.axi_count =  RM_NUM_ITEMS_IN_GROUP(&pIF->RemoteIpGroup);
        Info.axi_index = pIF->ip.IFIndex;

        arpCopyToNdisBuffer(
                pNdisBuffer,
                (PUCHAR)&Info,
                sizeof(Info),
                &ByteOffset);

        ReturnStatus = TDI_SUCCESS;
    }
    else
    {
        ReturnStatus = TDI_BUFFER_TOO_SMALL;
    }

    EXIT()
    return ReturnStatus;
}


VOID
arpCopyDestInfoIntoInmeInfo (
    PUCHAR pinme_physaddr,
    PARPCB_DEST pDest
    )
/*++

Routine Description:

Copy the correct destination address to the location provided 
In the Fifo Send case, we need to report the Fake Mac Address
In all other cases, we'll report the first six bytes of the destination

Arguments:
    pinme_physaddr  - Location we need to fill up.
    pdest

Return Value:

    TDI Status code.

--*/

{
    PNIC1394_DESTINATION pNicDest = &pDest->Params.HwAddr;
    ENetAddr               FakeEnetAddress = {0,0,0,0,0,0};
    PUCHAR              pDestAddr = NULL;


    //
    // This assertion is important for this function to work. 
    // If it is changed, then we can no longer use FakeMac Addresses 
    // to identify remote nodes. We will have to revert back to using Unique IDs
    //
    ASSERT (sizeof(ENetAddr) == ARP1394_IP_PHYSADDR_LEN);

            
    if (NIC1394AddressType_FIFO == pNicDest->AddressType &&
        pDest->Params.ReceiveOnly== FALSE)
    {

        //
        // We are translating an entry that describes a SendFifo Destination
        //

        
        //
        // Use the same algorithm as nic1394 uses to get a 
        // MAC address to report back to IP
        //
        if (pNicDest->FifoAddress.UniqueID != 0)
        {
            nicGetMacAddressFromEuid(&pNicDest->FifoAddress.UniqueID, &FakeEnetAddress);
        }

        pDestAddr = (PUCHAR) &FakeEnetAddress;

    }   
    else
    {
        // We'll use the first six bytes of the NIC1394_DESTINATION
        //

        
        // We copy the 1st ARP1394_IP_PHYSADDR_LEN bytes of the address...
        // (In the case of a channel, only the 1st 4 bytes (UINT Channel)
        // are significant; The rest will be all zeros.)
        //
        pDestAddr = (PUCHAR)pNicDest;

    }


    NdisMoveMemory (pinme_physaddr, pDestAddr, ARP1394_IP_PHYSADDR_LEN);

}



arpQueryIpAddrXlatEntries(
    ARP1394_INTERFACE *             pIF,                // LOCKIN LOCKOUT
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    IN      PVOID                   QueryContext,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Return as many AddrXlat entries (aka arp entries) as will fit
    into the specified buffer.


Arguments:

    pIF                     - Interface
    pNdisBuffer             - Space for returning information
    pBufferSize             - Pointer to size of above. On return, we fill
                              it with the actual bytes copied.
    QueryContext            - Context value pertaining to the query.

Return Value:

    TDI Status code.

--*/
{
    //
    // Our context structure is laid out as follows
    //
    typedef struct
    {
        IP_ADDRESS IpAddr;

        // UINT TableSize; << TODO To deal with dynamic changes in table-size.

    } OUR_QUERY_CONTEXT;

    OUR_QUERY_CONTEXT * pOurCtxt;
    UINT                ReturnStatus;
    UINT                ByteOffset;
    UINT                BytesCopied;
    UINT                BufferSize;
    ARPCB_REMOTE_IP *   pRemoteIp;
    NDIS_STATUS         Status;
    ENTER("arpQueryIpXlatEntries", 0x61c86684)

    TR_INFO(("QueryInfo: AT Entity, for reading ATE\n"));
    RM_DBG_ASSERT_LOCKED(&pIF->Hdr, pSR);

    // See notes.txt entry ..
    //   03/04/1999   JosephJ  Size of the context passed in ArpIpQueryInfo.
    //
    ASSERT(sizeof(OUR_QUERY_CONTEXT) <= 16);

    BufferSize      = *pBufferSize;
    *pBufferSize    = 0;
    BytesCopied     = 0;
    ByteOffset      = 0;
    pOurCtxt        = (OUR_QUERY_CONTEXT*) QueryContext;
    pRemoteIp       = NULL;

    ReturnStatus = TDI_SUCCESS;

    //
    // Our context structure is supposed to be initialized with Zeros the 1st time
    // it's called.
    //
    if (pOurCtxt->IpAddr == 0)
    {
        //
        // This is a brand new context. So we get the 1st entry.
        //
        Status = RmGetNextObjectInGroup(
                    &pIF->RemoteIpGroup,
                    NULL,
                    &(PRM_OBJECT_HEADER)pRemoteIp,
                    pSR
                    );
        if (FAIL(Status))
        {
            // Presumably there are no entries.
            pRemoteIp = NULL;
        }
    }
    else
    {
        //
        // This is an ongoing context. Let's look up this IP address, which is
        // supposed to be the IP address of the next item in the arp table.
        //
        Status = RmLookupObjectInGroup(
                        &pIF->RemoteIpGroup,
                        0,                              // Flags
                        (PVOID) ULongToPtr (pOurCtxt->IpAddr),      // pKey
                        NULL,                           // pvCreateParams
                        &(PRM_OBJECT_HEADER)pRemoteIp,
                        NULL, // pfCreated
                        pSR
                        );
        if (FAIL(Status))
        {
            //
            // Ah well, things have changed since the last time we were called,
            // and now this entry is no longer around.
            //
            pRemoteIp = NULL;
        }
    }

    while (pRemoteIp != NULL)
    {
        ARPCB_REMOTE_IP *   pNextRemoteIp = NULL;
        IPNetToMediaEntry   ArpEntry;

        if (((INT)BufferSize - (INT)BytesCopied) < sizeof(ArpEntry))
        {
            //
            // out of space; Update the context, and set special return value.
            //
            ARP_ZEROSTRUCT(pOurCtxt);
            pOurCtxt->IpAddr = pRemoteIp->IpAddress;


            ReturnStatus = TDI_BUFFER_OVERFLOW;
            RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
            pRemoteIp = NULL;
            break;
        }

        // Prepare the XlatEntry in ArpEntry.
        //
        {
            ARP_ZEROSTRUCT(&ArpEntry);

            ArpEntry.inme_index = pIF->ip.IFIndex;
            ArpEntry.inme_addr  = pRemoteIp->IpAddress;
            if (CHECK_REMOTEIP_RESOLVE_STATE(pRemoteIp, ARPREMOTEIP_RESOLVED))
            {
                ARPCB_DEST *pDest = pRemoteIp->pDest;

                TR_INFO(("ReadNext: found Remote IP Entry 0x%x, Addr %d.%d.%d.%d\n",
                            pRemoteIp,
                            ((PUCHAR)(&(pRemoteIp->IpAddress)))[0],
                            ((PUCHAR)(&(pRemoteIp->IpAddress)))[1],
                            ((PUCHAR)(&(pRemoteIp->IpAddress)))[2],
                            ((PUCHAR)(&(pRemoteIp->IpAddress)))[3]
                        ));
        
                // We assert that
                // IF lock is the same as pRemoteIp's and pDest's lock,
                // and that lock is locked.
                // We implicitly assert that pDest is non-NULl as well.
                //
                ASSERTEX(pRemoteIp->Hdr.pLock == pDest->Hdr.pLock, pRemoteIp);
                RM_DBG_ASSERT_LOCKED(&pRemoteIp->Hdr, pSR);

                ArpEntry.inme_physaddrlen =  ARP1394_IP_PHYSADDR_LEN;

                // We copy the 1st ARP1394_IP_PHYSADDR_LEN bytes of the address...
                // (In the case of a channel, only the 1st 4 bytes (UINT Channel)
                // are significant; The rest will be all zeros.)
                //
                ASSERT(sizeof(pDest->Params.HwAddr)>=ARP1394_IP_PHYSADDR_LEN);

                arpCopyDestInfoIntoInmeInfo (ArpEntry.inme_physaddr,pDest);
        
                if (CHECK_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_STATIC))
                {
                    ArpEntry.inme_type = INME_TYPE_STATIC;
                }
                else
                {
                    ArpEntry.inme_type = INME_TYPE_DYNAMIC;
                }
            }
            else
            {
                ArpEntry.inme_physaddrlen   = 0;
                ArpEntry.inme_type          = INME_TYPE_INVALID;
            }
        }

        // Copy into the supplied ndis buffer.
        //
        BytesCopied += sizeof(ArpEntry);
        pNdisBuffer = arpCopyToNdisBuffer(
                        pNdisBuffer,
                        (PUCHAR)&ArpEntry,
                        sizeof(ArpEntry),
                        &ByteOffset
                        );

        // Lookup next entry's IP address and save it in our context.
        //
        Status = RmGetNextObjectInGroup(
                        &pIF->RemoteIpGroup,
                        &pRemoteIp->Hdr,
                        &(PRM_OBJECT_HEADER)pNextRemoteIp,
                        pSR
                        );

        if (FAIL(Status))
        {
            //
            // we're presumably done. 
            //
            pNextRemoteIp = NULL;
        }

        // TmpDeref pRemoteIp and move on to the next one.
        //
        RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
        pRemoteIp = pNextRemoteIp;

    }

    ASSERT(pRemoteIp == NULL);

    *pBufferSize = BytesCopied;


    EXIT()
    return ReturnStatus;
}


arpQueryIpMibStats(
    ARP1394_INTERFACE *             pIF,                // LOCKIN LOCKOUT
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Fill out Interface-level statistics.

Arguments:

    pIF                     - Interface
    pNdisBuffer             - Space for returning information
    pBufferSize             - Pointer to size of above. On return, we fill
                              it with the actual bytes copied.

Return Value:

    TDI Status code.

--*/
{
    ENTER("arpQueryIpMibStatus", 0xc5bc364f)
    UINT    ReturnStatus;
    UINT    BufferSize;
    
    TR_VERB(("QueryInfo: MIB statistics\n"));
    RM_DBG_ASSERT_LOCKED(&pIF->Hdr, pSR);

    BufferSize      = *pBufferSize;
    *pBufferSize    = 0;

    do
    {
        IFEntry             ife;
        ARP1394_ADAPTER *   pAdapter;
        UINT                ByteOffset;
        UINT                BytesCopied;
    
        //
        //  Check if we have enough space.
        //
        if (BufferSize < IFE_FIXED_SIZE)
        {
            ReturnStatus = TDI_BUFFER_TOO_SMALL;
            break;
        }
    
        ARP_ZEROSTRUCT(&ife);
        pAdapter        = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
        BytesCopied     = 0;
        ByteOffset      = 0;

        //
        // Fill out mib info...
        //

        ife.if_index    = pIF->ip.IFIndex;
        ife.if_mtu      = pIF->ip.MTU;
        ife.if_type     = IF_TYPE_IEEE1394;
        ife.if_speed    = pAdapter->info.Speed;
    
        // Set adminstatus and operstatus (computed from pIF->Hdr.State)
        //
        ife.if_adminstatus = IF_STATUS_UP;
        ife.if_operstatus = IF_OPER_STATUS_OPERATIONAL;
        
        if (CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_DEINITING))
        {
            ife.if_adminstatus = IF_STATUS_DOWN;
        }
        if (!CHECK_IF_IP_STATE(pIF, ARPIF_IPS_OPEN))
        {
            ife.if_operstatus = IF_OPER_STATUS_NON_OPERATIONAL;
        }

        // Stats...
        //
        ife.if_lastchange       = pIF->stats.LastChangeTime;
        ife.if_inoctets         = pIF->stats.InOctets;
        ife.if_inucastpkts      = pIF->stats.InUnicastPkts;
        ife.if_innucastpkts     = pIF->stats.InNonUnicastPkts;
        ife.if_indiscards       = pIF->stats.InDiscards;
        ife.if_inerrors         = pIF->stats.InErrors;
        ife.if_inunknownprotos  = pIF->stats.UnknownProtos;
        ife.if_outoctets        = pIF->stats.OutOctets;
        ife.if_outucastpkts     = pIF->stats.OutUnicastPkts;
        ife.if_outnucastpkts    = pIF->stats.OutNonUnicastPkts;
        ife.if_outdiscards      = pIF->stats.OutDiscards;
        ife.if_outerrors        = pIF->stats.OutErrors;
        ife.if_outqlen          = pIF->stats.OutQlen;

        ife.if_descrlen         = pAdapter->info.DescriptionLength;

    
        ASSERT(ARP1394_IP_PHYSADDR_LEN <= sizeof(pAdapter->info.EthernetMacAddress));
        ife.if_physaddrlen = ARP1394_IP_PHYSADDR_LEN;

    #if 1 // MILLEN
        //
        //  Win98: winipcfg doesn't like more than 6 bytes repored here.
        //
        if (ife.if_physaddrlen > 6)
        {
            ife.if_physaddrlen = 6;
        }
    #endif// MILLEN


        //
        // Tell TCPIP that the Ethernet Address is the real physical address.
        // This helps us because now we have the same 'MAC' address whether 
        // we are in a network which is bridged to Ethernet or not.
        //
        NdisMoveMemory(
                ife.if_physaddr,
                &(pAdapter->info.EthernetMacAddress),
                ife.if_physaddrlen
                );
    
        arpCopyToNdisBuffer(
                pNdisBuffer,
                (PUCHAR)&ife,
                IFE_FIXED_SIZE,
                &ByteOffset);
    
        if (BufferSize >= (IFE_FIXED_SIZE + ife.if_descrlen))
        {
            if (ife.if_descrlen != 0)
            {
                arpCopyToNdisBuffer(
                        pNdisBuffer,
                        pAdapter->info.szDescription,
                        ife.if_descrlen,
                        &ByteOffset);
            }
            *pBufferSize = IFE_FIXED_SIZE + ife.if_descrlen;
            ReturnStatus = TDI_SUCCESS;
        }
        else
        {
            *pBufferSize = IFE_FIXED_SIZE;
            ReturnStatus = TDI_BUFFER_OVERFLOW;
        }

    } while (FALSE);

    EXIT()
    return ReturnStatus;
}


PNDIS_BUFFER
arpCopyToNdisBuffer(
    IN  PNDIS_BUFFER                pDestBuffer,
    IN  PUCHAR                      pDataSrc,
    IN  UINT                        LenToCopy,
    IN OUT  PUINT                   pOffsetInBuffer
)
/*++

Routine Description:

    Copy data into an NDIS buffer chain. Use up as much of the given
    NDIS chain as needed for "LenToCopy" bytes. After copying is over,
    return a pointer to the first NDIS buffer that has space for writing
    into (for the next Copy operation), and the offset within this from
    which to start writing.

Arguments:

    pDestBuffer     - First NDIS buffer in a chain of buffers
    pDataSrc        - Where to copy data from
    LenToCopy       - How much data to copy
    pOffsetInBuffer - Offset in pDestBuffer where we can start copying into.

Return Value:

    The NDIS buffer in the chain where the next Copy can be done. We also
    set *pOffsetInBuffer to the write offset in the returned NDIS buffer.

--*/
{
    //
    //  Size and destination for individual (contiguous) copy operations
    //
    UINT            CopySize;
    PUCHAR          pDataDst;

    //
    //  Start Virtual address for each NDIS buffer in chain.
    //
    PUCHAR          VirtualAddress;

    //
    //  Offset within pDestBuffer
    //
    UINT            OffsetInBuffer = *pOffsetInBuffer;

    //
    //  Bytes remaining in current buffer
    //
    UINT            DestSize;

    //
    //  Total Buffer Length
    //
    UINT            BufferLength;


    ASSERT(pDestBuffer != (PNDIS_BUFFER)NULL);
    ASSERT(pDataSrc != NULL);

#if MILLEN
    NdisQueryBuffer(
            pDestBuffer,
            &VirtualAddress,
            &BufferLength
            );
#else
    NdisQueryBufferSafe(
            pDestBuffer,
            &VirtualAddress,
            &BufferLength,
            NormalPagePriority
            );

    if (VirtualAddress == NULL)
    {
        return (NULL);
    }
#endif
    
    ASSERT(BufferLength >= OffsetInBuffer);

    pDataDst = VirtualAddress + OffsetInBuffer;
    DestSize = BufferLength - OffsetInBuffer;

    for (;;)
    {
        CopySize = LenToCopy;
        if (CopySize > DestSize)
        {
            CopySize = DestSize;
        }

        NdisMoveMemory(pDataDst, pDataSrc, CopySize);

        pDataDst += CopySize;
        pDataSrc += CopySize;

        LenToCopy -= CopySize;
        if (LenToCopy == 0)
        {
            break;
        }

        DestSize -= CopySize;

        if (DestSize == 0)
        {
            //
            //  Out of space in the current buffer. Move to the next.
            //
            pDestBuffer = NDIS_BUFFER_LINKAGE(pDestBuffer);

            if (pDestBuffer == NULL)
            {
                ASSERT(FALSE);
                return NULL;
            }
            else
            {
            #if MILLEN
                NdisQueryBuffer(
                        pDestBuffer,
                        &VirtualAddress,
                        &BufferLength
                        );
            #else // !MILLEN
                NdisQueryBufferSafe(
                        pDestBuffer,
                        &VirtualAddress,
                        &BufferLength,
                        NormalPagePriority
                        );
    
                if (VirtualAddress == NULL)
                {
                    return NULL;
                }
            #endif // !MILLEN
                pDataDst = VirtualAddress;
                DestSize = BufferLength;
            }
        }
    }

    *pOffsetInBuffer = (UINT) (pDataDst - VirtualAddress);

    return (pDestBuffer);
}


VOID
arpSendIpPkt(
    IN  ARP1394_INTERFACE       *   pIF,            // LOCKIN NOLOCKOUT (IF send lk)
    IN  PARPCB_DEST                 pDest,
    IN  PNDIS_PACKET                pNdisPacket
    )
/*++

    HOT PATH

Routine Description:

    Send a packet to the FIFO/channel associated with destination object pDest.

Arguments:

    pIF             - Our interface object
    pDest           - Destination object on which to send packet
    pNdisPacket     - Packet to send

--*/
{
    NDIS_STATUS Status;
    MYBOOL      fRet;
    ARP1394_ADAPTER *   pAdapter =
                            (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    MYBOOL      fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);

    DBGMARK(0xdaab68c3);

    //
    // If we can't send now, we immediately call IP's send complete handler.
    //
    if (!ARP_CAN_SEND_ON_DEST(pDest))
    {
        ARP_FASTUNLOCK_IF_SEND_LOCK(pIF);

        if (ARP_DEST_IS_FIFO(pDest))
        {
            LOGSTATS_SendFifoCounts(pIF, pNdisPacket, NDIS_STATUS_FAILURE);
        }
        else
        {
            LOGSTATS_SendChannelCounts(pIF, pNdisPacket, NDIS_STATUS_FAILURE);
        }
        #if MILLEN
            ASSERT_PASSIVE();
        #endif // MILLEN
        NdisInterlockedIncrement (&ArpSendCompletes);
        NdisInterlockedIncrement (&ArpSendFailure);


        if (fBridgeMode)
        {
            // In bridge (ethernet emulation) mode, we created the
            // packets ourselves, so we delete them here, instead
            // of calling Ip's completion handler, which in fact
            // is NULL.
            //
            RM_DECLARE_STACK_RECORD(sr)
            arpFreeControlPacket(
                    pIF,
                    pNdisPacket,
                    &sr
                    );
        }
        else
        {
            (*(pIF->ip.TxCmpltHandler))(
                        pIF->ip.Context,
                        pNdisPacket,
                        NDIS_STATUS_FAILURE
                        );
        }
        return;                                         // EARLY RETURN
    }

    arpRefSendPkt( pNdisPacket, pDest);

    // Release the IF send lock.
    //
    ARP_FASTUNLOCK_IF_SEND_LOCK(pIF);


    // NOW (with IF send lock released), we prepare the IP packet for sending....
    //
    // We do this only if not in ethernet emulation (bridge) mode,
    // because all IP packets in bridge mode already have the
    // proper 1394 header on them.
    //
    if (!fBridgeMode)
    {
        PNDIS_BUFFER            pNdisBuffer;    // First buffer in the IP packet
    
    // TODO: is this safe? How about a check for the size by which this is possible!
    #if !MILLEN
        #define ARP_BACK_FILL_POSSIBLE(_pBuf) \
                    (((_pBuf)->MdlFlags & MDL_NETWORK_HEADER) != 0)
    #else // MILLEN
        #define ARP_BACK_FILL_POSSIBLE(_pBuf)   (0)
    #endif // MILLEN
    
        //
        //  We look at the first buffer in the IP packet, to see whether
        //  it has space reserved for low-layer headers. If so, we just
        //  use it up. Otherwise, we allocate a header buffer of our own.
        //
        NdisQueryPacket(pNdisPacket, NULL, NULL, &pNdisBuffer, NULL);
        ASSERTEX(pNdisBuffer != NULL, pNdisPacket);
        if (ARP_BACK_FILL_POSSIBLE(pNdisBuffer))
        {
            const ULONG EncapLength = sizeof(Arp1394_IpEncapHeader);
    
        #if MILLEN
    
            ASSERT(!"We shouldn't be here -- check ARP_BACK_FILL_POSSIBLE()");
    
        #else   // !MILLEN
    
            (PUCHAR)pNdisBuffer->MappedSystemVa -= EncapLength;
            pNdisBuffer->ByteOffset             -= EncapLength;
            pNdisBuffer->ByteCount              += EncapLength;
            NdisMoveMemory(
                pNdisBuffer->MappedSystemVa,
                &Arp1394_IpEncapHeader,
                EncapLength
                );


#define LOGSTATS_BackFills(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.sendpkts.BackFills))

            LOGSTATS_BackFills(pIF, pNdisPacket);
    
        #endif  // !MILLEN
        }
        else
        {
            //
            // Backfill wasn't possible for this packet. Let's try to allocate
            // an encapsulation header buffer from the IF pool...
            //
    
            pNdisBuffer =  arpAllocateConstBuffer(&pIF->sendinfo.HeaderPool);
    
            if (pNdisBuffer != (PNDIS_BUFFER)NULL)
            {
                // Our send complete handler relies on this assertion to decide
                // whether backfill happened or not.
                //
                ASSERT(!ARP_BACK_FILL_POSSIBLE(pNdisBuffer));

                NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
            }
            else
            {
                //
                // Oops, we couldn't allocate an encapsulation buffer!
                // We've already referenced the destination for sends.
                //

                //
                // Cop out for now (we haven't implemented all the  queuing
                // code for now) by calling our own send complete handler with
                // status failure.
                //
                // We use the special return value NDIS_STATUS_NOT_RESETTABLE
                // to indicate that we haven't inserted our own buffer,
                // (and so the packet shouldn't be "reset"). Ok this is a bit
                // hacky, but it works.
                //
                arpCompleteSentPkt(
                        NDIS_STATUS_NOT_RESETTABLE,
                        pIF,
                        pDest,
                        pNdisPacket
                        );

                return;                                 // EARLY RETURN
            }
        }
    }

    

    
    // Actually send the packet
    //
#if ARPDBG_FAKE_SEND
    arpDbgFakeNdisCoSendPackets(
            pDest->VcHdr.NdisVcHandle,
            &pNdisPacket,
            1,
            &pDest->Hdr,
            &pDest->VcHdr
        );
#else   // !ARPDBG_FAKE_SEND
    NdisCoSendPackets(
            pDest->VcHdr.NdisVcHandle,
            &pNdisPacket,
            1
        );
#endif  // !ARPDBG_FAKE_SEND

}



NDIS_STATUS
arpSlowIpTransmit(
    IN  ARP1394_INTERFACE       *   pIF,
    IN  PNDIS_PACKET                pNdisPacket,
    IN  REMOTE_DEST_KEY             Destination,
    IN  RouteCacheEntry *           pRCE        OPTIONAL
    )
/*++

Routine Description:

    This is the path taken (hopefully only for a small fraction of the packets)
    when something has prevented the packet from being immediately sent down to
    the miniport. Typically we're here for one of the following reasons:
    1. IP Address is not resolved yet.
    2. RCE entry has not been initialized yet.
    3. Couldn't allocate an encapsulation-header buffer.
    4. The Vc to the destination doesn't exist or is not ready for sending yet.


Arguments:

    pIF             - Our interface object
    pNdisPacket     - Packet to send
    Destination     - IP address of destination
    pRCE            - (OPTIONAL) Route Cache Entry associated with this
                      destination

Return Value:
    
    NDIS_STATUS_SUCCESS         on synchronous success.
    NDIS_STATUS_PENDING         if completion is asynchronous
    Other ndis status code      on other kinds of failure.

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    ENTER("arpSlowIpTransmit", 0xe635299c)
    BOOLEAN fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);
    ULONG   LookupFlags = 0;
    UINT fRemoteIpCreated = FALSE;
    RM_DECLARE_STACK_RECORD(sr)

    DBGMARK(0x30b6f7e2);

    do
    {
        ARP_RCE_CONTEXT *   pArpRceContext  = NULL;
        ARPCB_REMOTE_IP *   pRemoteIp       = NULL;
        ARPCB_DEST      *   pDest           = NULL;

#define LOGSTATS_SlowSends(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.sendpkts.SlowSends))
#define LOGSTATS_MediumSends(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.sendpkts.MediumSends))

        //
        // If there is a RCE, we try to get the pRemoteIp from it  If not
        // successful, we'll need to actually lookup/create the pRemoteIp from the
        // IF RemoteIpGroup.
        //

        if (pRCE != NULL)
        {
            pArpRceContext  = ARP_OUR_CTXT_FROM_RCE(pRCE);

            // All RCE linkages are protected by the IF send lock.
            //
            ARP_READLOCK_IF_SEND_LOCK(pIF, &sr);
            pRemoteIp       = pArpRceContext->pRemoteIp;
            if (pRemoteIp != NULL)
            {
                RmTmpReferenceObject(&pRemoteIp->Hdr, &sr);
            }
            ARP_UNLOCK_IF_SEND_LOCK(pIF, &sr);
        }

        if (pRemoteIp == NULL)
        {
            //
            // Either there was no RCE or it was uninitialized.
            // We'll lookup/create the pRemoteIp based on the destination
            // IP address...
            //

            RM_ASSERT_NOLOCKS(&sr);

            //
            // Create the destination, this will cause us to resolve IP Addresses, etc/
            //                                        
            LookupFlags  = RM_CREATE; 


            if (fBridgeMode == TRUE)
            {
                //
                // do not create a remote IP struct, only look it up
                //
                LookupFlags = 0;
            }
            // if in bridge mode
            // set flags to zero , else RM_CREATE

            Status = RmLookupObjectInGroup(
                            &pIF->RemoteIpGroup,
                            LookupFlags,
                            (PVOID) &Destination,
                            (PVOID) (&Destination),   // pCreateParams
                            (RM_OBJECT_HEADER**) &pRemoteIp,
                            &fRemoteIpCreated,                   // pfCreated  (unused)
                            &sr
                            );
            LOGSTATS_TotalArpCacheLookups(pIF, Status);
            if (FAIL(Status))
            {
                OBJLOG1(
                    pIF,
                    "Couldn't lookup/create localIp entry with addr 0x%lx\n",
                    Destination.IpAddress
                    );
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            //
            // if we are in bridge mode, then we add the Destination Ip address to 
            // the RemoteIP structure.
            // 
            if (fBridgeMode && fRemoteIpCreated)
            {
                Status  = arpAddIpAddressToRemoteIp (pRemoteIp, pNdisPacket);

                if (FAIL(Status))
                {
                    OBJLOG1(
                        pIF,
                        "Couldn't Add Dest Ip addr to Remote Ip addr 0x%lx\n",
                        Destination.IpAddress
                        );
                    Status = NDIS_STATUS_FAILURE;
                    break;
                }

            }
           
            //
            // If there is a RCE, we make it point to pRemoteIp.
            //
            if (pRCE != NULL)
            {

                // All RCE linkages are protected by the IF send lock.
                //
                ARP_WRITELOCK_IF_SEND_LOCK(pIF, &sr);

                if (pArpRceContext->pRemoteIp != NULL)
                {
                    if (pArpRceContext->pRemoteIp != pRemoteIp)
                    {
                        ARPCB_REMOTE_IP *   pStaleRemoteIp;
                        //
                        // We've got a wierd situation here: initially
                        // pRCE didn't point to any pRemoteIp, so we looked up
                        // a pRemoteIp ourselves. Now that we've got the IF send
                        // lock, we find that pRCE is pointing to a different
                        // pRemoteIp than the one we looked up!
                        //
                        // What to do? We ignore pRemoteIp (the one we looked up)
                        // and instead use pArpRceContext->pRemoteIp...
                        //
                        ASSERTEX(!"RCE pRemoteIp mismatch", pArpRceContext);
                        pStaleRemoteIp = pRemoteIp;
                        pRemoteIp = pArpRceContext->pRemoteIp;
                        RmTmpReferenceObject(&pRemoteIp->Hdr, &sr);
                        ARP_UNLOCK_IF_SEND_LOCK(pIF, &sr);
                        RM_ASSERT_NOLOCKS(&sr);
                        RmTmpDereferenceObject(&pStaleRemoteIp->Hdr, &sr);
                        ARP_WRITELOCK_IF_SEND_LOCK(pIF, &sr);
                    }
                }
                else
                {
                    // Add the association between pRCE and pRemoteIp...
                    //
                    arpAddRce(pRemoteIp, pRCE, &sr);   // LOCKIN LOCKOUT (IF send lk)
                }

                ARP_UNLOCK_IF_SEND_LOCK(pIF, &sr);
            }
        }

        //
        // At this point, we should have a pRemoteIp, with a tmpref on it,
        // and no locks held.
        //
        ASSERT_VALID_REMOTE_IP(pRemoteIp);
        RM_ASSERT_NOLOCKS(&sr);

        //
        // Queue the packet on pRemoteIp's send pkt queue, and start the 
        // SendPkts task on this pRemoteIp if required.
        //
        {
        
            LOCKOBJ(pRemoteIp, &sr);

            // NOTE: This field is not always modified with the lock held -- in
            // the fast send path, it's simply set to true.
            // This field is used in garbage collecting pRemoteIps.
            //
            pRemoteIp->sendinfo.TimeLastChecked = 0;

            //
            // Stats.
            // TODO -- we need to directly deal with "medium sends"
            // instead of starting up a task just because the RCEs are NULL
            // -- mcast and udp pkts have null RCEs, it turns out.
            //

            if (    pRemoteIp->pDest != NULL
                 && ARP_CAN_SEND_ON_DEST(pRemoteIp->pDest))
            {
                LOGSTATS_MediumSends(pIF, pNdisPacket);
            }
            else
            {
                LOGSTATS_SlowSends(pIF, pNdisPacket);
            }

            
            if (pRemoteIp->pSendPktsTask == NULL)
            {
                PRM_TASK pTask;

                // There is no send-pkts task. Let's try to alloc and start one..
                Status = arpAllocateTask(
                            &pRemoteIp->Hdr,            // pParentObject
                            arpTaskSendPktsOnRemoteIp,      // pfnHandler
                            0,                              // Timeout
                            "Task: SendPktsOnRemoteIp", // szDescription
                            &pTask,
                            &sr
                            );
                if (FAIL(Status))
                {
                    // Oops, couldn't allocate task. We fail with STATUS_RESOURCES
                    UNLOCKOBJ(pRemoteIp, &sr);
                    Status = NDIS_STATUS_RESOURCES;
                    break;
                }

                //
                // Queue the pkt first, THEN start the task. This makes sure that
                // the packet WILL be taken care of.
                // TODO: Currently, it's possible that the RemoteIp's unload
                // task will not wait for send pkts to be cleared up IF it checks
                // BEFORE the task before is started. This hole needs
                // to be fixed.
                //
                arpQueuePktOnRemoteIp(
                    pRemoteIp,      // LOCKIN LOCKOUT
                    pNdisPacket,
                    &sr
                    );

                UNLOCKOBJ(pRemoteIp, &sr);

                (VOID) RmStartTask( pTask, 0, &sr);
            }
            else
            {
                //
                // There is already a send-pkts task. Simply queue the pkt.
                //
                arpQueuePktOnRemoteIp(
                    pRemoteIp,      // LOCKIN LOCKOUT
                    pNdisPacket,
                    &sr
                    );
                UNLOCKOBJ(pRemoteIp, &sr);
            }

            // We're done!
            // Remove the tmp reference on pRemoteIp, and set status to PENDING.
            //
            RM_ASSERT_NOLOCKS(&sr);
            RmTmpDereferenceObject(&pRemoteIp->Hdr, &sr);
            Status = NDIS_STATUS_PENDING;
        }

    } while (FALSE);
    
    RM_ASSERT_CLEAR(&sr)

    EXIT()
    return Status;
}



VOID
arpAddRce(
    IN  ARPCB_REMOTE_IP *pRemoteIp, // IF send lock WRITELOCKIN WRITELOCKOUT
    IN  RouteCacheEntry *pRce,
    IN  PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

        Link the RCE pRce with the remote ip object pRemoteIp.
--*/
{
    ARP_RCE_CONTEXT *   pArpRceContext;
    MYBOOL              fDoRef;

    pArpRceContext  = ARP_OUR_CTXT_FROM_RCE(pRce);
    fDoRef          = (pRemoteIp->sendinfo.pRceList == NULL);

    ASSERT(pArpRceContext->pRemoteIp == NULL);

    // Add pRce to pRemoteIP's list of RCEs.
    //
    pArpRceContext->pNextRce = pRemoteIp->sendinfo.pRceList;
    pRemoteIp->sendinfo.pRceList = pRce;

    // Add pointer from pRce to pRemoteIp
    //
    pArpRceContext->pRemoteIp = pRemoteIp;


    // The following macros are just so that we can make the proper debug association
    // depending on how closely we are tracking outstanding send packets.
    //
#if ARPDBG_REF_EVERY_RCE
    fDoRef = TRUE;
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pRce)
    #define szARPSSOC_EXTLINK_RIP_TO_RCE_FORMAT "    Linked to pRce 0x%p\n"
#else // !ARPDBG_REF_EVERY_RCE
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR)  &pRemoteIp->sendinfo)
    #define szARPSSOC_EXTLINK_RIP_TO_RCE_FORMAT "    Outstanding RCEs exist. &si=0x%p\n"
#endif // !ARPDBG_REF_EVERY_RCE


    if (fDoRef)
    {
        //
        // If ARPDBG_REF_EVERY_RCE
        //      We add an "external" link for EVERY RCE. We'll later remove this
        //      reference when the RCE is invalidated.
        // else
        //      Only a transition from zero to non-zero RCEs, we
        //      add an "external" link. We'll later remove this link when the
        //      transition from non-zero to zero happens.
        //

    #if RM_EXTRA_CHECKING

        RM_DECLARE_STACK_RECORD(sr)

        RmLinkToExternalEx(
            &pRemoteIp->Hdr,                            // pHdr
            0x22224c96,                             // LUID
            OUR_EXTERNAL_ENTITY,                    // External entity
            ARPASSOC_EXTLINK_RIP_TO_RCE,            // AssocID
            szARPSSOC_EXTLINK_RIP_TO_RCE_FORMAT,
            &sr
            );

    #else   // !RM_EXTRA_CHECKING

        RmLinkToExternalFast(&pRemoteIp->Hdr);

    #endif // !RM_EXTRA_CHECKING

    }

    #undef  OUR_EXTERNAL_ENTITY
    #undef  szARPSSOC_EXTLINK_RIP_TO_RCE
}


VOID
arpDelRce(
    IN  RouteCacheEntry *pRce,  // IF send lock WRITELOCKIN WRITELOCKOUTD
    IN  PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

        Unlink RCE pRce from remote ip object pRemoteIp.

--*/
{
    ARPCB_REMOTE_IP *   pRemoteIp;
    ARP_RCE_CONTEXT *   pArpRceContext;
    MYBOOL              fDoDeref;
    RouteCacheEntry **  ppRce;

    pArpRceContext  = ARP_OUR_CTXT_FROM_RCE(pRce);
    pRemoteIp       = pArpRceContext->pRemoteIp;

    if (pRemoteIp == NULL)
    {
        // We haven't initialized this RCE yet. Nothing to do...
        //
        return;                                                 // EARLY RETURN
    }


    if (VALID_REMOTE_IP(pRemoteIp)== FALSE)
    {
        return;
    }

    // Remove pRce from pRemoteIP's list of RCEs.
    //
    for(
        ppRce = &pRemoteIp->sendinfo.pRceList;
        *ppRce != NULL;
        ppRce = &(ARP_OUR_CTXT_FROM_RCE(*ppRce)->pNextRce))
    {
        if (*ppRce == pRce) break;

    }
    if (*ppRce == pRce)
    {
        *ppRce =  pArpRceContext->pNextRce;
    }
    else
    {
        ASSERTEX(!"RCE Not in pRemoteIp's list!", pRce);
    }
    ARP_ZEROSTRUCT(pArpRceContext);

    fDoDeref        = (pRemoteIp->sendinfo.pRceList == NULL);

    // The following macros are just so that we can make the proper debug association
    // depending on how closely we are tracking outstanding send packets.
    //
#if ARPDBG_REF_EVERY_RCE
    fDoDeref = TRUE;
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pRce)
#else // !ARPDBG_REF_EVERY_RCE
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR)  &pRemoteIp->sendinfo)
#endif // !ARPDBG_REF_EVERY_RCE

    if (fDoDeref)
    {
        //
        // If ARPDBG_REF_EVERY_RCE
        //      We add an "external" link for EVERY RCE. We'll later remove this
        //      reference when the RCE is invalidated.
        // else
        //      Only a transition from zero to non-zero RCEs, we
        //      add an "external" link. We'll later remove this link when the
        //      transition from non-zero to zero happens.
        //

    #if RM_EXTRA_CHECKING

        RM_DECLARE_STACK_RECORD(sr)

        RmUnlinkFromExternalEx(
            &pRemoteIp->Hdr,                        // pHdr
            0x940df668,                             // LUID
            OUR_EXTERNAL_ENTITY,                    // External entity
            ARPASSOC_EXTLINK_RIP_TO_RCE,            // AssocID
            &sr
            );

    #else   // !RM_EXTRA_CHECKING

        RmUnlinkFromExternalFast(&pRemoteIp->Hdr);

    #endif // !RM_EXTRA_CHECKING

    }

    #undef  OUR_EXTERNAL_ENTITY
}


VOID
arpDelRceList(
    IN  PARPCB_REMOTE_IP  pRemoteIp,    // IF send lock WRITELOCKIN WRITELOCKOUTD
    IN  PRM_STACK_RECORD pSR
    )
/*++

Routine Description:
    Walks the RCE List, deleting each RoutCache Entry


--*/
{

    RouteCacheEntry *   pRce = pRemoteIp->sendinfo.pRceList;

    //
    // Delete all the Rce present on this remote Ip
    //

    while (pRce!= NULL)
    {
        //
        // Delete the Rce and reduce the Ref
        //
        arpDelRce (pRce, pSR);

        //
        // Get the next RCE
        //
        pRce = pRemoteIp->sendinfo.pRceList;
    }


}


NDIS_STATUS
arpTaskSendPktsOnRemoteIp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for  sending queued packets on the pRemoteIp which
    is its parent object. If required it must start the registration task and/or
    the make-call task on the destination object.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskSendPktsOnRemoteIp", 0xbc285d98)
    NDIS_STATUS         Status;
    ARPCB_REMOTE_IP*    pRemoteIp;
    ARP1394_INTERFACE * pIF;
    ARPCB_DEST        * pDest;
    MYBOOL              fMakeCallIfRequired;
    PARP1394_ADAPTER    pAdapter;
    MYBOOL              fBridgeMode;

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_AddressResolutionComplete,
        PEND_MakeCallComplete
    };

    Status              = NDIS_STATUS_FAILURE;
    pRemoteIp           = (ARPCB_REMOTE_IP*) RM_PARENT_OBJECT(pTask);
    pIF                 = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pRemoteIp);
    pAdapter            = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);
    pDest               = NULL;
    fMakeCallIfRequired = FALSE;
    fBridgeMode         = ARP_BRIDGE_ENABLED(pAdapter);
            


    ASSERT_VALID_INTERFACE(pIF);
    ASSERT_VALID_REMOTE_IP(pRemoteIp);

    DBGMARK(0x6f31a739);

    switch(Code)
    {
        case RM_TASKOP_START:
        {
            LOCKOBJ(pRemoteIp, pSR);

            // First check if pRemoteIp is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pRemoteIp))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            // pRemoteIp is allocated. Now check if there is already a
            // send-pkts task attached to pRemoteIp.
            //
            if (pRemoteIp->pSendPktsTask != NULL)
            {
                //
                // There is a sendpkts task. Nothing for us to do -- simply return.
                //
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            // Now we check if there is an UnloadTask bound to pRemoteIP. This
            // is an IMPORTANT check -- because the unload task expects that
            // once it is bound to pRemoteIp, no new pSendPktsTasks will bind
            // themselves to pRemoteIp -- see arpTaskUnloadRemoteIp.
            //
            if (pRemoteIp->pUnloadTask != NULL)
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // There is no sendpkts task going on. Let's
            // make this task THE sendpkts task.
            // 
            pRemoteIp->pSendPktsTask = pTask;

            //
            // Since we're THE sendpks task, add an association to pRemoteIp,
            // which will only get cleared when the  pRemoteIp->pSendPktsTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pRemoteIp->Hdr,                    // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_REMOTEIP_SENDPKTS_TASK,    // AssociationID
                "    Official sendpkts task 0x%p (%s)\n", // szFormat
                pSR
                );

            if (pRemoteIp->pDest == NULL)
            {   
                MYBOOL bIsDestNonUnicastAddr = FALSE;
                //
                // There is no pDest associated with pRemoteIp.
                // If this is an on-unicast address, we link the local ip
                // object to the broadcast object and proceed.
                // NOTE: arpIsNonUnicastIpAddress is not a trivial operation -- it
                // actually enumerates all local IP addresses. Fortunately we only
                // call it for the FIRST packet sent out to an unresolved address.
                //
                if (fBridgeMode)
                {
                    bIsDestNonUnicastAddr  = arpIsNonUnicastEthAddress (pIF,&pRemoteIp->Key.ENetAddress,pSR);
                }
                else
                {
                    ASSERT(IS_REMOTE_DEST_IP_ADDRESS(&pRemoteIp->Key) == TRUE);

                    bIsDestNonUnicastAddr  = arpIsNonUnicastIpAddress(pIF, pRemoteIp->IpAddress, pSR);
                }
                
                if (bIsDestNonUnicastAddr == TRUE)
                {
                    ASSERT(pIF->pBroadcastDest != NULL); // Don't really expect it.

                    if (pIF->pBroadcastDest != NULL)
                    {
                        //
                        // Note: arpLinkRemoteIpToDest expects the locks
                        // on both pRemoteIp and pIF->pBroadcastDest to be
                        // held. We know that this is the case because both
                        // share the same lock, which is the IF lock.
                        //
                        RM_DBG_ASSERT_LOCKED(&pIF->pBroadcastDest->Hdr, pSR);
                        arpLinkRemoteIpToDest(
                                pRemoteIp,
                                pIF->pBroadcastDest,
                                pSR
                                );
                        SET_REMOTEIP_FCTYPE(pRemoteIp, ARPREMOTEIP_CHANNEL);
                        SET_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_DYNAMIC);
                #if 0
                        if (CHECK_REMOTEIP_MCAP(pRemoteIp,  ARPREMOTEIP_MCAP_CAPABLE))
                        {
                            SET_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_DYNAMIC);
                        }
                        else
                        {
                            //
                            // We don't age out broadcast addresses.
                            //
                            SET_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_STATIC);
                        }
                #endif // 0
                    }
                }
            }


            //
            // If there is a resolution task going, we  wait for it to complete.
            //
            if (pRemoteIp->pResolutionTask != NULL)
            {
                PRM_TASK pOtherTask = pRemoteIp->pResolutionTask;
                TR_WARN(("Resolution task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);

                UNLOCKOBJ(pRemoteIp, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_AddressResolutionComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no address resolution task. Let's see if the
            // address has been resolved. If not, we need to start the address
            // resolution task.
            //
            if (pRemoteIp->pDest == NULL)
            {
                //
                // Let's start the address resolution task!
                //
                PRM_TASK pResolutionTask;
    
                DBGMARK(0xd0da6726);

                //
                // Let's start a resolution task and pend on it.
                //
                Status = arpAllocateTask(
                            &pRemoteIp->Hdr,                    // pParentObject
                            arpTaskResolveIpAddress,        // pfnHandler
                            0,                              // Timeout
                            "Task: ResolveIpAddress",       // szDescription
                            &pResolutionTask,
                            pSR
                            );
                if (FAIL(Status))
                {
                    // Couldn't allocate task. We fail with STATUS_RESOURCES
                    //
                    Status = NDIS_STATUS_RESOURCES;
                }
                else
                {
                    UNLOCKOBJ(pRemoteIp, pSR);
                    RmPendTaskOnOtherTask(
                        pTask,
                        PEND_AddressResolutionComplete,
                        pResolutionTask,
                        pSR
                        );
    
                    (VOID)RmStartTask(
                            pResolutionTask,
                            0, // UserParam unused
                            pSR
                            );
                
                    Status = NDIS_STATUS_PENDING;
                }
                break;
            }

            pDest = pRemoteIp->pDest;

            //
            // We do have a pDest. Now see if there is a make call task on that
            // pDest, and if so, we pend on it.
            fMakeCallIfRequired = TRUE;


            //
            // We're here because there is no more async work to be done.
            // We simply return and finish synchronous work in the END
            // handler for this task.
            //
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_AddressResolutionComplete:
                {
                    //
                    // There was address-resolution going on, but how it's
                    // complete. We should be go on to try to make a call now...
                    //
                    // If we're here, that means we're THE official SendPkts
                    // task. Let's assert that fact.
                    // (no need to get the lock on the object).
                    //
                    LOCKOBJ(pRemoteIp, pSR);
                    ASSERT(pRemoteIp->pSendPktsTask == pTask);

                    // We ignore the status of address resolution -- instead
                    // we just check if there is a destination associated with
                    // pRemoteIp.
                    //
                    pDest = pRemoteIp->pDest;
                    if (pDest == NULL)
                    {
                        // Nope -- no pDest. We fail the packets.
                        Status = NDIS_STATUS_FAILURE;
                    }
                    else
                    {
                        // Yup,  there is a destination. Now check if we need
                        // to make a call, etc...
                        //
                        fMakeCallIfRequired = TRUE;
                    }
                }
                break;

                case  PEND_MakeCallComplete:
                {
                    LOCKOBJ(pRemoteIp, pSR);
                    //
                    // If we're here, that means we're THE official SendPkts
                    // task. Let's assert that fact.
                    // (no need to get the lock on the object).
                    //
                    ASSERT(pRemoteIp->pSendPktsTask == pTask);

                    //
                    // There was a make-call task going on, but how it's
                    // complete. We're done with async processing.
                    // We actually send/fail queued packets in our END handler...
                    //
                    Status      = (NDIS_STATUS) UserParam;
                    ASSERT(!PEND(Status));
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pRemoteIp, pSR);

            //
            // We're done. There should be no async activities left to do.
            // At this point, if we can't immediately send packets on the FIFO,
            // we simply fail all the packets.
            //

            //
            // We don't bother to look at the Status. Instead we go ahead and
            // try to send any queued packets.
            //

            //
            // If we're THE sentpkts task, we go on actually send the packets.
            //
            if (pRemoteIp->pSendPktsTask == pTask)
            {
                DBGMARK(0xc627713c);

                UNLOCKOBJ(pRemoteIp, pSR);
                arpSendPktsQueuedOnRemoteIp(
                        pIF,
                        pRemoteIp,
                        pSR
                        );

                LOCKOBJ(pRemoteIp, pSR);
                // Delete the association we added when we set
                // pRemoteIp->pSendPktsTask to pTask.
                //
                ASSERT(pRemoteIp->pSendPktsTask == pTask);
                DBG_DELASSOC(
                    &pRemoteIp->Hdr,                    // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_REMOTEIP_SENDPKTS_TASK,    // AssociationID
                    pSR
                    );
                pRemoteIp->pSendPktsTask = NULL;
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                //
                // We weren't THE unload task, nothing left to do.
                //
                Status = NDIS_STATUS_SUCCESS;
            }
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    if (fMakeCallIfRequired)
    {
        //
        // If necessary, make a call. If a make-call is already in process, pend
        // on it.
        //

        // We rely on the fact that
        // we share the same lock as pDest, and therefore is locked...
        //
        RM_DBG_ASSERT_LOCKED(&pDest->Hdr, pSR);

        Status = arpMakeCallOnDest(pRemoteIp,
                                    pDest, 
                                    pTask, 
                                    PEND_MakeCallComplete, 
                                    pSR);

    }

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}


VOID
arpCompleteSentPkt(
    IN  NDIS_STATUS             Status,
    IN  ARP1394_INTERFACE   *   pIF,
    IN  ARPCB_DEST          *   pDest,
    IN  PNDIS_PACKET            pNdisPacket
)
/*++

Routine Description:

    Handle the completion (by the miniport) of a packet sent on a FIFO or Channel VC.
    We strip out the encapsulation header we had tacked on prior to sending the
    packet. If the packet belongs to IP, we call IP's send complete handler, else
    we return it to our packet pool.

Arguments:

    Status      - Status of the completed send.
    pIF         - Interface object
    pDest       - Destination object on which packet was sent
    pNdisPacket - Ndis packet that was sent.

--*/
{
    PacketContext                   *PC;            // IP/ARP Info about this packet
    PNDIS_BUFFER                    pNdisBuffer;    // First Buffer in this packet
    ENTER("CompleteSentPkt", 0xc2b623b6)
    UINT                            TotalLength;
    MYBOOL                          IsFifo;
    MYBOOL                          IsControlPacket;


    ASSERT(pNdisPacket->Private.Head != NULL);

    NdisQueryPacket(
            pNdisPacket,
            NULL,           // we don't need PhysicalBufferCount
            NULL,           // we don't need BufferCount
            NULL,           // we don't need FirstBuffer (yet)
            &TotalLength
            );

    IsFifo = pDest->sendinfo.IsFifo;

    // Update stats...
    //
    {
        if (IsFifo)
        {
            LOGSTATS_SendFifoCounts(pIF, pNdisPacket, Status);
        }
        else
        {
            LOGSTATS_SendChannelCounts(pIF, pNdisPacket, Status);
        }

        if (Status == NDIS_STATUS_SUCCESS)
        {
            ARP_IF_STAT_ADD(pIF, OutOctets, TotalLength);

            if (IsFifo)
            {
                ARP_IF_STAT_INCR(pIF, OutUnicastPkts);
            }
            else
            {
                ARP_IF_STAT_INCR(pIF, OutNonUnicastPkts);
            }
        }
        else if (Status == NDIS_STATUS_RESOURCES)
        {
            ARP_IF_STAT_INCR(pIF, OutDiscards);
        }
        else
        {
            ARP_IF_STAT_INCR(pIF, OutErrors);
        }
    }

    PC = (PacketContext *)pNdisPacket->ProtocolReserved;

    TR_INFO(
        ("[%s]: pDest 0x%x, Pkt 0x%x, Status 0x%x:\n",
                ((PC->pc_common.pc_owner != PACKET_OWNER_LINK)? "IP": "ARP"),
                pDest, pNdisPacket, Status));

    NdisQueryPacket(pNdisPacket, NULL, NULL, &pNdisBuffer, NULL);
    ASSERT(pNdisBuffer != NULL);

    // Delete association added when sending packets.
    //
    {
        MYBOOL      DoDeref;
    
        DoDeref =(InterlockedDecrement(&pDest->sendinfo.NumOutstandingSends)==0);

        if (DoDeref)
        {
            MYBOOL TryResumeSuspendedCleanupTask = FALSE;

            // The count of outstanding sends has touched zero. Let's
            // check if there is a CleanupCall task waiting for all outstanding
            // sends to complete, and if it makes sense to do so, we
            // will resume it.
            //
            ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);
            if (pDest->sendinfo.pSuspendedCleanupCallTask!=NULL)
            {
                // It's likely that we'll need to resume this task.
                //
                TryResumeSuspendedCleanupTask = TRUE;
            }
            else
            {
                // We do not need to resume any task. Nothing more to do...
                //
            }
            ARP_FASTUNLOCK_IF_SEND_LOCK(pIF);

            if (TryResumeSuspendedCleanupTask)
            {
                arpTryResumeSuspendedCleanupTask(pIF, pDest);
            }
        }
    
        // The following macros are just so that we can make the proper debug
        // association depending on how closely we are tracking outstanding send
        // packets.
        //
    #if ARPDBG_REF_EVERY_PACKET
        DoDeref = TRUE;
        #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pNdisPacket)
    #else // !ARPDBG_REF_EVERY_PACKET
        #define OUR_EXTERNAL_ENTITY ((UINT_PTR)  &pDest->sendinfo)
    #endif // !ARPDBG_REF_EVERY_PACKET
    
    
        if (DoDeref)
        {
            //
            // If ARPDBG_REF_EVERY_PKT
            //      We remove the "external" link added for EVERY packet.
            // else
            //      Only a transition from non-zero to zero outstanding sends, we
            //      remove the "external" link.
            //
    
        #if RM_EXTRA_CHECKING
    
            RM_DECLARE_STACK_RECORD(sr)
    
            RmUnlinkFromExternalEx(
                &pDest->Hdr,                            // pHdr
                0x753db96f,                             // LUID
                OUR_EXTERNAL_ENTITY,                    // External entity
                ARPASSOC_EXTLINK_DEST_TO_PKT,           // AssocID
                &sr
                );
    
        #else   // !RM_EXTRA_CHECKING
    
            RmUnlinkFromExternalFast(&pDest->Hdr);
    
        #endif // !RM_EXTRA_CHECKING
    
        }
        #undef  OUR_EXTERNAL_ENTITY
    
    }

    //
    //  Check who generated this packet.
    //
    IsControlPacket = FALSE;

    if (PC->pc_common.pc_owner == PACKET_OWNER_LINK)
    {
        IsControlPacket = TRUE;
    }

    if (IsControlPacket)
    {
        arpHandleControlPktSendCompletion(pIF, pNdisPacket);
    }
    else
    {
        //
        //  Belongs to IP.
        //

        DBGMARK(0x2c48c626);

        //
        //  Now check if we had attached a header buffer or not.
        //  NOTE: We rely on the fact that if we DID attach a header buffer,
        //  ARP_BACK_FILL_POSSIBLE will be false for this buffer.
        //
        DBGMARK(0x2f3b96f3);
        if (ARP_BACK_FILL_POSSIBLE(pNdisBuffer))
        {
            const UINT  HeaderLength =  sizeof(Arp1394_IpEncapHeader);

            //
            //  We would have back-filled IP's buffer with the Ip encapsulation
            //  header.
            //  Remove the back-fill.
            //
            (PUCHAR)pNdisBuffer->MappedSystemVa += HeaderLength;
            pNdisBuffer->ByteOffset += HeaderLength;
            pNdisBuffer->ByteCount -= HeaderLength;
        }
        else if (Status != NDIS_STATUS_NOT_RESETTABLE)
        {
            //
            //  The first buffer is our header buffer. Remove
            //  it from the packet and return to our pool.
            //
            NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
            arpDeallocateConstBuffer(
                &pIF->sendinfo.HeaderPool,
                pNdisBuffer
                );
        }

        //  Inform IP of send completion.
        //  NOTE: we don't get here in bridge mode because we only use
        //  control packets in bridge mode.
        //
        #if MILLEN
            ASSERT_PASSIVE();
        #endif // MILLEN
        (*(pIF->ip.TxCmpltHandler))(
                    pIF->ip.Context,
                    pNdisPacket,
                    Status
                    );
    }

    EXIT()
}


VOID
arpTryResumeSuspendedCleanupTask(
    IN  ARP1394_INTERFACE   *   pIF,        // NOLOCKIN NOLOCKOUT
    IN  ARPCB_DEST          *   pDest       // NOLOCKIN NOLOCKOUT
    )
/*++

Routine Description:

    If there is a cleanup task associated with destination oject pDest that
    is suspended waiting for the outstanding send count to go to zero, AND
    if the outstanding send count has gone to zero, we resume the task. Otherwise
    we do nothing.

Arguments:

    pIF         - Interface object
    pDest       - Destination object.

--*/
{
    PRM_TASK pTask;
    ENTER("TryResumeSuspendedCleanupTask", 0x1eccb1aa)
    RM_DECLARE_STACK_RECORD(sr)

    ARP_WRITELOCK_IF_SEND_LOCK(pIF, &sr);
    pTask = pDest->sendinfo.pSuspendedCleanupCallTask;
    if (pTask != NULL)
    {
        ASSERT(!ARP_CAN_SEND_ON_DEST(pDest));
        if (pDest->sendinfo.NumOutstandingSends==0)
        {
            // We need to resume this task...
            //
            pDest->sendinfo.pSuspendedCleanupCallTask = NULL;

            // Clear the association added when pTask started waiting for
            // outstanding sends to complete.
            //
            DBG_DELASSOC(
                &pDest->Hdr,                        // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_DEST_CLEANUPCALLTASK_WAITING_ON_SENDS,
                &sr
                );
            RmTmpReferenceObject(&pTask->Hdr, &sr);
        }
        else
        {
            // There are other outstanding sends now. No need to do anything...
            //
            pTask = NULL;
        }
    }
    ARP_UNLOCK_IF_SEND_LOCK(pIF, &sr);


    if (pTask != NULL)
    {
        // Resume the CleanupCall task...
        //
        RmResumeTask(pTask, NDIS_STATUS_SUCCESS, &sr);
        RmTmpDereferenceObject(&pTask->Hdr, &sr);
    }

    RM_ASSERT_CLEAR(&sr);
    EXIT()
}


VOID
arpQueuePktOnRemoteIp(
    IN  PARPCB_REMOTE_IP    pRemoteIp,      // LOCKIN LOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    IN  PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Appends pkt pNdisPacket on remote object pRemoteIp's queue.

--*/
{
    ARP_SEND_PKT_MPR_INFO *pOurPktInfo =
                        ARP_OUR_CTXT_FROM_SEND_PACKET(pNdisPacket);
    

    RM_DBG_ASSERT_LOCKED(&pRemoteIp->Hdr, pSR);

#if RM_EXTRA_CHECKING
    {
        //
        // If ARPDBG_REF_EVERY_PKT
        //      We add an dbgassociation for EVERY packet. We'll later remove
        //      this association when the send completes for this packet.
        // else
        //      Only a transition from zero to non-zero queued pkts, we
        //      add an dbg association. We'll later remove this association when
        //      the transition from non-zero to zero happens.
        //
        MYBOOL DoAssoc;

    #if ARPDBG_REF_EVERY_PACKET
        DoAssoc = TRUE;
        #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pNdisPacket)
        #define szARPSSOC_QUEUED_PKT_FORMAT "    Queued pkt 0x%p\n"
    #else // !ARPDBG_REF_EVERY_PACKET
        #define OUR_EXTERNAL_ENTITY ((UINT_PTR)  &pDest->)
        #define szARPSSOC_QUEUED_PKT_FORMAT "    Outstanding pkts. &si=0x%p\n"
        DoAssoc =  IsListEmpty(&pRemoteIp->sendinfo.listSendPkts);
    #endif // !ARPDBG_REF_EVERY_PACKET
    
        if (DoAssoc)
        {
    
            RM_DECLARE_STACK_RECORD(sr)
    
            RmDbgAddAssociation(
                0x3c08a7f5,                             // LOCID
                &pRemoteIp->Hdr,                        // pHdr
                (UINT_PTR) OUR_EXTERNAL_ENTITY,         // Entity1
                0,                                      // Entity2
                ARPASSOC_PKTS_QUEUED_ON_REMOTEIP,       // AssocID
                szARPSSOC_QUEUED_PKT_FORMAT,
                &sr
                );
        }
    #undef  OUR_EXTERNAL_ENTITY
    #undef  szARPSSOC_EXTLINK_DEST_TO_PKT_FORMAT
    }
#endif // !RM_EXTRA_CHECKING
    DBGMARK(0x007a0585);

    InsertHeadList(
        &pRemoteIp->sendinfo.listSendPkts,
        &pOurPktInfo->linkQueue
        );
}

    
VOID
arpSendPktsQueuedOnRemoteIp(
    IN  ARP1394_INTERFACE   *   pIF,            // NOLOCKIN NOLOCKOUT
    IN  ARPCB_REMOTE_IP     *   pRemoteIp,      // NOLOCKIN NOLOCKOUT
    IN  PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Send all packets queued on remote ip object pRemoteIp. If packets can't
    be sent at this time for any reason, fail the sends.

    ASSUMPTION: We expect pIF and pRemoteIp to be around while we're in this
                function.

--*/

{
    ENTER("SendPktsQueuedOnRemoteIp", 0x2b125d7f)
    RM_ASSERT_NOLOCKS(pSR);

    LOCKOBJ(pRemoteIp, pSR);

    DBGMARK(0xe4950c47);
    do
    {
        PARPCB_DEST pDest = NULL;

        if(RM_IS_ZOMBIE(pRemoteIp))
        {
            break;
        }


        pDest = pRemoteIp->pDest;

        if (pDest != NULL)
        {
            RmTmpReferenceObject(&pDest->Hdr, pSR);
        }

        //
        // Send or fail all packets in our queue.
        // TODO: Implement send multiple pkts.
        //
        while (!IsListEmpty(&pRemoteIp->sendinfo.listSendPkts))
        {
            PLIST_ENTRY                 plinkPkt;
            PNDIS_PACKET                pNdisPacket;
            ARP_SEND_PKT_MPR_INFO *     pOurPktCtxt;

            //
            // Extract pkt from tail and send it on it's merry way...
            //

            plinkPkt = RemoveTailList(&pRemoteIp->sendinfo.listSendPkts);

            // From link to our pkt context...
            //
            pOurPktCtxt = CONTAINING_RECORD(
                            plinkPkt,
                            ARP_SEND_PKT_MPR_INFO, 
                            linkQueue
                            );

            // From our pkt context to the ndis pkt.
            //
            pNdisPacket = ARP_SEND_PKT_FROM_OUR_CTXT(pOurPktCtxt);
    

        #if RM_EXTRA_CHECKING
            {
                //
                // If ARPDBG_REF_EVERY_PKT
                //      We delete thhe dbgassociation added for EVERY packet.
                // else
                //      Only a transition from non-zero zero queued pkts, we
                //      delete the dbg association added when the
                //      transition from zero to non-zero happened.
                //
                MYBOOL DoDelAssoc;
        
            #if ARPDBG_REF_EVERY_PACKET
                DoDelAssoc = TRUE;
                #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pNdisPacket)
            #else // !ARPDBG_REF_EVERY_PACKET
                #define OUR_EXTERNAL_ENTITY ((UINT_PTR)  &pDest->)
                DoDelAssoc =  IsListEmpty(&pRemoteIp->sendinfo.listSendPkts);
            #endif // !ARPDBG_REF_EVERY_PACKET
            
                if (DoDelAssoc)
                {
            
                    RM_DECLARE_STACK_RECORD(sr)
            
                    RmDbgDeleteAssociation(
                        0x3c08a7f5,                             // LOCID
                        &pRemoteIp->Hdr,                        // pHdr
                        (UINT_PTR) OUR_EXTERNAL_ENTITY,         // Entity1
                        0,                                      // Entity2
                        ARPASSOC_PKTS_QUEUED_ON_REMOTEIP,       // AssocID
                        &sr
                        );
                }
            #undef  OUR_EXTERNAL_ENTITY
            }
        #endif // !RM_EXTRA_CHECKING

            UNLOCKOBJ(pRemoteIp, pSR);
            RM_ASSERT_NOLOCKS(pSR);
    
            if (pDest == NULL
                || (   g_DiscardNonUnicastPackets
                    &&  CHECK_REMOTEIP_FCTYPE( pRemoteIp, ARPREMOTEIP_CHANNEL)))

            {
                ARP1394_ADAPTER *   pAdapter =
                                    (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
                MYBOOL      fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);
            
                // Fail the packet right here...
                //
                // TODO: we current update the SendFifoCounts here, because
                // all non-unicast bcasts resolve to the already existing
                // broadcast channel. Once we have MCAP going, we need to keep
                // a flag in pRemoteIp indicating whether or not this is a
                // unicast address.
                //
                LOGSTATS_SendFifoCounts(pIF, pNdisPacket, NDIS_STATUS_FAILURE);
                  
                if (fBridgeMode)
                {
                    // In bridge (ethernet emulation) mode, we created the
                    // packets ourselves, so we delete them here, instead
                    // of calling Ip's completion handler, which in fact
                    // is NULL.
                    //
                    arpFreeControlPacket(
                            pIF,
                            pNdisPacket,
                            pSR
                            );
                }
                else
                {
                #if MILLEN
                    ASSERT_PASSIVE();
                #endif // MILLEN

                    NdisInterlockedIncrement (&ArpSendCompletes);
                    NdisInterlockedIncrement (&ArpSendFailure);


                    (*(pIF->ip.TxCmpltHandler))(
                                pIF->ip.Context,
                                pNdisPacket,
                                NDIS_STATUS_FAILURE
                                );
                }
            }
            else
            {
                // Get IF send lock (fast version)
                //
                ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);
        
                arpSendIpPkt(
                    pIF,                // IF send lock: LOCKING NOLOCKOUT
                    pDest,
                    pNdisPacket
                    );
        
                // Note that we're locking pRemoteIp's lock, not the IF send lock
                // here. pRemoteIp->sendinfo.listSendPkts is protected by the
                // the following lock, not the IF send lock.
                //
            }
            LOCKOBJ(pRemoteIp, pSR);
        }

        if (pDest != NULL)
        {
            RmTmpDereferenceObject(&pDest->Hdr, pSR);
        }

    } while (FALSE);

    UNLOCKOBJ(pRemoteIp, pSR);

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
}


VOID
arpLogSendFifoCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    IN  NDIS_STATUS         Status
    )
/*++
    TODO:  Very similar to arpLogSendChannelCounts, consider merging these two 
            functions.
--*/
{
    PULONG  pCount;
    ULONG   SizeBin, TimeBin;

    arpGetPktCountBins(pIF, pNdisPacket, &SizeBin, &TimeBin);

    //
    // Increment the count
    if (Status == NDIS_STATUS_SUCCESS)
    {
        pCount = &(pIF->stats.sendpkts.SendFifoCounts.GoodCounts[SizeBin][TimeBin]);
    }
    else
    {
        pCount = &(pIF->stats.sendpkts.SendFifoCounts.BadCounts[SizeBin][TimeBin]);
    }
    NdisInterlockedIncrement(pCount);
}


VOID
arpLogRecvFifoCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket
    )
{
    PULONG  pCount;
    ULONG   SizeBin;

    arpGetPktCountBins(pIF, pNdisPacket, &SizeBin, NULL);

    //
    // Increment the count
    pCount = &(pIF->stats.recvpkts.RecvFifoCounts.GoodCounts[SizeBin][0]);
    NdisInterlockedIncrement(pCount);
}


VOID
arpLogSendChannelCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    IN  NDIS_STATUS         Status
    )
{
    PULONG  pCount;
    ULONG   SizeBin, TimeBin;

    arpGetPktCountBins(pIF, pNdisPacket, &SizeBin, &TimeBin);

    //
    // Increment the count
    if (Status == NDIS_STATUS_SUCCESS)
    {
        pCount =&(pIF->stats.sendpkts.SendChannelCounts.GoodCounts[SizeBin][TimeBin]);
    }
    else
    {
        pCount =&(pIF->stats.sendpkts.SendChannelCounts.BadCounts[SizeBin][TimeBin]);
    }
    NdisInterlockedIncrement(pCount);
}


VOID
arpLogRecvChannelCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket
    )
{
    PULONG  pCount;
    ULONG   SizeBin;

    arpGetPktCountBins(pIF, pNdisPacket, &SizeBin, NULL);

    //
    // Increment the count
    pCount = &(pIF->stats.recvpkts.RecvChannelCounts.GoodCounts[SizeBin][0]);
    NdisInterlockedIncrement(pCount);
}

VOID
arpGetPktCountBins(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    OUT PULONG              pSizeBin,       
    OUT PULONG              pTimeBin        // OPTIONAL
    )
{
    ULONG   Size;
    ULONG   SizeBin;

    if (pTimeBin != NULL)
    {
        //
        // Compute the packet send duration
        //
    
        ULONG           StartSendTick, EndSendTick;
        LARGE_INTEGER   liTemp;
        ULONG           TimeDelta;
        ULONG           TimeBin;

        liTemp = KeQueryPerformanceCounter(NULL);
        EndSendTick = liTemp.LowPart;
        StartSendTick =  *(PULONG) ((pNdisPacket)->WrapperReservedEx);
        if (EndSendTick > StartSendTick)
        {
            TimeDelta = EndSendTick - StartSendTick;
        }
        else
        {
            TimeDelta = (ULONG) (((ULONG) -1) - (StartSendTick - EndSendTick));
        }

        // Convert from ticks to microseconds.
        // (Check that the frequence is non zero -- we could be in the middle
        // of a stats-reset, and don't want to cause a devide-by-zero exception).
        //
        liTemp =  pIF->stats.PerformanceFrequency;
        if (liTemp.QuadPart != 0)
        {
            ULONGLONG ll;
            ll = TimeDelta;
            ll *= 1000000;
            ll /=  liTemp.QuadPart;
            ASSERT(ll == (ULONG)ll);
            TimeDelta = (ULONG) ll;
        }
        else
        {
            TimeDelta = 0; // bogus value.
        }

        //
        // Compute the time bin based on the send duration
        //
        if (TimeDelta <= 100)
        {
            TimeBin = ARP1394_PKTTIME_100US;
        }
        else if (TimeDelta <= 1000)
        {
            TimeBin = ARP1394_PKTTIME_1MS;
        }
        else if (TimeDelta <= 10000)
        {
            TimeBin =   ARP1394_PKTTIME_10MS;
        }
        else if (TimeDelta <= 100000)
        {
            TimeBin =   ARP1394_PKTTIME_100MS;
        }
        else // (TimeDelta > 100000)
        {
            TimeBin = ARP1394_PKTTIME_G100MS;
        }

        *pTimeBin = TimeBin;
    }

    //
    // Compute the packet size
    NdisQueryPacket(
            pNdisPacket,
            NULL,
            NULL,
            NULL,
            &Size
            );

    //
    // Compute the size bin based on the packet size
    if (Size <= 128)
    {
        SizeBin =  ARP1394_PKTSIZE_128;
    }
    else if (Size <= 256)
    {
        SizeBin = ARP1394_PKTSIZE_256;
    }
    else if (Size <= 1024)
    {
        SizeBin = ARP1394_PKTSIZE_1K;
    }
    else if (Size <= 2048)
    {
        SizeBin = ARP1394_PKTSIZE_2K;
    }
    else // Size > 2048
    {
        SizeBin = ARP1394_PKTSIZE_G2K;
    }

    *pSizeBin = SizeBin;

}

// This table is used in the calculations to determine if a particular address is
// non-unicast.
// TODO: Make this and all other static data into const.
//
IP_MASK  g_ArpIPMaskTable[] =
{
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSB_MASK,
    CLASSB_MASK,
    CLASSB_MASK,
    CLASSB_MASK,
    CLASSC_MASK,
    CLASSC_MASK,
    CLASSD_MASK,
    CLASSE_MASK
};


#define ARP_IPNETMASK(a)    g_ArpIPMaskTable[(*(uchar *)&(a)) >> 4]


// Context passed to the enum function for checking if a particular
// address is non-unicast.
//
typedef struct
{
    IP_ADDRESS IpAddress;
    IP_ADDRESS BroadcastAddress;
    MYBOOL     IsNonUnicast;
    

} ARP_NONUNICAST_CTXT, *PARP_NONUNICAST_CTXT;


// The enum function for the above operation.
//
INT
arpCheckForNonUnicastAddress(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        )
{
    PARPCB_LOCAL_IP         pLocalIp;
    PARP_NONUNICAST_CTXT    pOurCtxt;
    IP_ADDRESS              Addr;
    IP_ADDRESS              BCast;
    IP_ADDRESS              LocalAddr;
    IP_MASK                 Mask;

    pLocalIp =  (PARPCB_LOCAL_IP) pHdr;

    // If this local ip address is non-unicast, skip it.
    //
    if (pLocalIp->IpAddressType != LLIP_ADDR_LOCAL)
    {
        return TRUE;                // *** EARLY RETURN *** (continue to enumerate)
    }

    pOurCtxt =   (PARP_NONUNICAST_CTXT) pvContext;
    Addr     =  pOurCtxt->IpAddress;
    LocalAddr=  pLocalIp->IpAddress;
    BCast    =  pOurCtxt->BroadcastAddress;

    // First check for subnet bcast.
    //
    Mask = pLocalIp->IpMask;
    if (IP_ADDR_EQUAL((LocalAddr & Mask) | (BCast & ~Mask), Addr))
    {
        pOurCtxt->IsNonUnicast = TRUE;
        return  FALSE;                  // Stop enumerating
    }

    // Now check all nets broadcast.
    Mask = ARP_IPNETMASK(LocalAddr);
    if (IP_ADDR_EQUAL((LocalAddr & Mask) | (BCast & ~Mask), Addr))
    {
        pOurCtxt->IsNonUnicast = TRUE;
        return FALSE;                   // Stop enumerating
    }

    return TRUE; // Continue to enumerate.
}


MYBOOL
arpIsNonUnicastEthAddress (
    IN  PARP1394_INTERFACE          pIF,        // LOCKIN LOCKOUT
    IN  ENetAddr*                   pAddr,
    IN  PRM_STACK_RECORD            pSR
)
/*++

Routine Description:

    Check if the given IP address is a non-unicast (broadcast or multicast) address
    for the interface.

    Copied from IP/ATM module (atmarpc.sys)

Arguments:

    Addr            - The Eth Address to be checked
    pInterface      - Pointer to our Interface structure

Return Value:

    TRUE if the address is a non-unicast address, FALSE otherwise.

--*/
{
    MYBOOL fIsNonUnicastEthAddress = FALSE;
    MYBOOL fIsMulticast  = FALSE; 
    MYBOOL fIsBroadcast = FALSE;
    
    fIsMulticast = ETH_IS_MULTICAST (pAddr);

    fIsBroadcast = ETH_IS_BROADCAST (pAddr);

    //
    // if it is either a Multicast or a Unicast address than 
    // it is a non-unicast address
    //
    fIsNonUnicastEthAddress  = (fIsMulticast  || fIsBroadcast );

    return (fIsNonUnicastEthAddress  );
}

MYBOOL
arpIsNonUnicastIpAddress(
    IN  PARP1394_INTERFACE          pIF,        // LOCKIN LOCKOUT
    IN  IP_ADDRESS                  Addr,
    IN  PRM_STACK_RECORD            pSR
)
/*++

Routine Description:

    Check if the given IP address is a non-unicast (broadcast or multicast) address
    for the interface.

    Copied from IP/ATM module (atmarpc.sys)

Arguments:

    Addr            - The IP Address to be checked
    pInterface      - Pointer to our Interface structure

Return Value:

    TRUE if the address is a non-unicast address, FALSE otherwise.

--*/
{
    IP_ADDRESS              BCast;
    IP_MASK                 Mask;
    // PIP_ADDRESS_ENTRY        pIpAddressEntry;
    IP_ADDRESS              LocalAddr;

    // Get the interface broadcast address.
    BCast = pIF->ip.BroadcastAddress;

    // Check for global broadcast and multicast.
    if (IP_ADDR_EQUAL(BCast, Addr) || CLASSD_ADDR(Addr))
        return TRUE;

    // Look through all our local ip addresses, checking for subnet and net
    // broadcast addresses.
    //
    {
        ARP_NONUNICAST_CTXT Ctxt;
        Ctxt.IsNonUnicast = FALSE;
        Ctxt.IpAddress  =   Addr;
        Ctxt.BroadcastAddress = BCast;

        RmEnumerateObjectsInGroup(
            &pIF->LocalIpGroup,
            arpCheckForNonUnicastAddress,
            &Ctxt,
            TRUE,                           // Choose strong enumeration
            pSR
            );

        return Ctxt.IsNonUnicast;
    }
}


VOID
arpRefSendPkt(
    PNDIS_PACKET    pNdisPacket,
    PARPCB_DEST     pDest               // LOCKIN LOCKOUT (readlock, IF Send lock)
    )
{
    MYBOOL      DoRef;
        
    // Note, we just have a READ lock on the IF send lock. So the following
    // needs to be an interlocked operation ...
    //
    DoRef =  (InterlockedIncrement(&pDest->sendinfo.NumOutstandingSends) == 1);

    // The following macros are just so that we can make the proper debug association
    // depending on how closely we are tracking outstanding send packets.
    //
#if ARPDBG_REF_EVERY_PACKET
    DoRef = TRUE;
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pNdisPacket)
    #define szARPSSOC_EXTLINK_DEST_TO_PKT_FORMAT "    Outstanding send pkt 0x%p\n"
#else // !ARPDBG_REF_EVERY_PACKET
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR)  &pDest->sendinfo)
    #define szARPSSOC_EXTLINK_DEST_TO_PKT_FORMAT "    Outstanding pkts. &si=0x%p\n"
#endif // !ARPDBG_REF_EVERY_PACKET


    if (DoRef)
    {
        //
        // If ARPDBG_REF_EVERY_PKT
        //      We add an "external" link for EVERY packet. We'll later remove this
        //      reference when the send completes for this packet.
        // else
        //      Only a transition from zero to non-zero outstanding sends, we
        //      add an "external" link. We'll later remove this link when the
        //      transition from non-zero to zero happens.
        //

    #if RM_EXTRA_CHECKING

        RM_DECLARE_STACK_RECORD(sr)

        RmLinkToExternalEx(
            &pDest->Hdr,                            // pHdr
            0x13f839b4,                             // LUID
            OUR_EXTERNAL_ENTITY,                    // External entity
            ARPASSOC_EXTLINK_DEST_TO_PKT,           // AssocID
            szARPSSOC_EXTLINK_DEST_TO_PKT_FORMAT,
            &sr
            );

    #else   // !RM_EXTRA_CHECKING

        RmLinkToExternalFast(&pDest->Hdr);

    #endif // !RM_EXTRA_CHECKING

    }
    #undef  OUR_EXTERNAL_ENTITY
    #undef  szARPSSOC_EXTLINK_DEST_TO_PKT_FORMAT
}

VOID
arpHandleControlPktSendCompletion(
    IN  ARP1394_INTERFACE   *   pIF,
    IN  PNDIS_PACKET            pNdisPacket
    )
{
    RM_DECLARE_STACK_RECORD(sr)

    arpFreeControlPacket(
            pIF,
            pNdisPacket,
            &sr
            );
}



BOOLEAN
arpCanTryMcap(
    IP_ADDRESS  IpAddress
    )
/*++
    Return TRUE IFF this is an MCAP compatible address.

    For now that means that it's a class D address, but not
    224.0.0.1 or 224.0.0.2

--*/
{
    // 1st check if it's a multicast address.
    //
    if ( (IpAddress & 0xf0) == 0xe0)
    {
        //
        // Then check for special multicast addresses 224.0.0.1 and 224.0.0.2
        // The ip/1395 rfc states that these two addresses must be
        // send on the broadcast channel.
        //
        if ( (IpAddress != 0x010000e0) && (IpAddress != 0x020000e0))
        {
            return TRUE;
        }
    }

    return FALSE;
}



VOID
arpLoopbackNdisPacket(
    PARP1394_INTERFACE pIF,
    PARPCB_DEST pBroadcastDest,
    PNDIS_PACKET pOldPacket
    )
/*++

Routine Description:
    if this is being sent to a broadcast destination, then allocate a new
    packet and loop it back up to the protocols.

Arguments:

    pIF - Pointer to the Interface on which the packet is sent
    pBroadcastDest - The Destination to which the packet is being sent.

Return Value:

    TRUE if the address is a non-unicast address, FALSE otherwise.

--*/
{
    PNDIS_PACKET    pNewPkt = NULL;
    const UINT      MacHeaderLength = sizeof(NIC1394_ENCAPSULATION_HEADER);
    PUCHAR          pPayloadDataVa = NULL;
    UINT            TotalLength  = 0;
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    UINT            HeadBufferLength  = 0;
    PUCHAR          pHeadBufferVa = NULL;  
    
    do
    {
        //Allocate the packet


        NdisAllocatePacket(
                &Status,
                &pNewPkt,
                pIF->arp.PacketPool
            );

        if (Status != NDIS_STATUS_SUCCESS || pNewPkt == NULL)
        {
            pNewPkt = NULL;
            break;

        }

        
        // set up the head and tail

        pNewPkt->Private.Head = pOldPacket->Private.Head;
        pNewPkt->Private.Tail = pOldPacket->Private.Tail;

        pNewPkt->Private.ValidCounts = FALSE;

        
        // indicate the packet with a status of resources

        NDIS_SET_PACKET_STATUS (pNewPkt,  NDIS_STATUS_RESOURCES);

        HeadBufferLength = NdisBufferLength (pNewPkt->Private.Head);
        pHeadBufferVa = NdisBufferVirtualAddressSafe (pNewPkt->Private.Head, NormalPagePriority );

        if (pHeadBufferVa ==NULL)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (HeadBufferLength <= MacHeaderLength)
        {
            // we need to go the next NdisBuffer to get the Start of data
            // 
            pPayloadDataVa = NdisBufferVirtualAddressSafe (pNewPkt->Private.Head->Next, NormalPagePriority );

            if (pPayloadDataVa == NULL)
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }
            if (HeadBufferLength != MacHeaderLength)
            {
                pPayloadDataVa += (MacHeaderLength - HeadBufferLength);            
            }
        }
        else
        {
            // The payload is within the Buffer
            pPayloadDataVa += MacHeaderLength ;

        }

        if (pOldPacket->Private.ValidCounts == TRUE)
        {
            TotalLength = pOldPacket->Private.TotalLength;

        }
        else
        {
            NdisQueryPacket(pOldPacket, NULL, NULL, NULL, &TotalLength);

        }

        
        pIF->ip.RcvHandler(
                pIF->ip.Context,
                (PVOID)(pPayloadDataVa),
                HeadBufferLength - MacHeaderLength,
                TotalLength - MacHeaderLength,
                (NDIS_HANDLE)pNewPkt,
                MacHeaderLength,
                TRUE, //IsChannel
                NULL
                );


    }while (FALSE);

    if (pNewPkt != NULL)
    {
        NdisFreePacket (pNewPkt);
        pNewPkt = NULL;            
    }



}



REMOTE_DEST_KEY
RemoteIPKeyFromIPAddress (
    IPAddr IpAddress
    )
/*++

Routine Description:
    Creates a RemoteIPKey structure from an IP Address
    by tagging two constant bytes

Arguments:


Return Value:
    New Remote Ip Key

--*/
{
    REMOTE_DEST_KEY RemoteIpKey ={0,0,0,0,0,0} ;

    ASSERT (sizeof (REMOTE_DEST_KEY)==sizeof(ENetAddr));
    
    RemoteIpKey.IpAddress = IpAddress;
    
    return RemoteIpKey;
}



NTSTATUS
arpDelArpEntry(
        PARP1394_INTERFACE           pIF,
        IPAddr                       IpAddress,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("DelArpEntry", 0x3427306a)
    NTSTATUS            NtStatus;

    TR_WARN(("DEL ARP ENTRY\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS             Status;
        NIC1394_FIFO_ADDRESS    FifoAddress;
        PARPCB_REMOTE_IP        pRemoteIp;
        PRM_TASK                pUnloadObjectTask;
        REMOTE_DEST_KEY        RemoteDestKey;

        // If this is a Subnet broadcast IP address, then skip the delete
        //
#define ARP1394_SUBNET_BROADCAST_IP  0xffff0000      

        if ((IpAddress & ARP1394_SUBNET_BROADCAST_IP  ) == ARP1394_SUBNET_BROADCAST_IP  )
        {
            break;
        }
            
        LOCKOBJ(pIF, pSR);

        //
        // Initialize the RemoteDestKey
        //
        REMOTE_DEST_KEY_INIT(&RemoteDestKey);

        RemoteDestKey.IpAddress  = IpAddress;                 
        // 
        // Lookup the RemoteIp entry corresponding to this entry and unload
        // it.
        //
        Status = RmLookupObjectInGroup(
                        &pIF->RemoteIpGroup,
                        0,                                      // Flags
                        (PVOID) &RemoteDestKey,     // pKey
                        NULL,                                   // pvCreateParams
                        &(PRM_OBJECT_HEADER)pRemoteIp,
                        NULL, // pfCreated
                        pSR
                        );

        UNLOCKOBJ(pIF, pSR);

        if (FAIL(Status))
        {
            break;
        }

        //
        // Found pRemoteIp. Let's initiate the unload of pRemoteIp. We won't wait
        // around for it to complete.
        //
        Status =  arpAllocateTask(
                    &pRemoteIp->Hdr,        // pParentObject,
                    arpTaskUnloadRemoteIp,  // pfnHandler,
                    0,                      // Timeout,
                    "Task:Unload RemoteIp (DelArpEntry)",
                    &pUnloadObjectTask,
                    pSR
                    );
        RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);

        if (FAIL(Status))
        {
            TR_WARN(("Couldn't allocate unload remoteip task."));
            break;
        }
        
        RmStartTask(
            pUnloadObjectTask,
            0, // UserParam (unused)
            pSR
            );

        NtStatus = STATUS_SUCCESS; // always succeed

    } while (FALSE);

    EXIT()
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\md5.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// md5.c
//
// IEEE1394 ARP module
//
//
// 08/08/2000 ADube created.  
// 
// Purpose: Create a unique MAC address from 1394 EUID 
// 
//This file should use the same algorithm as nic1394 uses. 
//
// Derived from derived from the RSA Data  Security, 
// Inc. MD5 Message-Digest Algorithm 
//

#include <precomp.h>
#pragma hdrstop

/*
  been defined with C compiler flags.
 */
#ifndef PROTOTYPES
#define PROTOTYPES 1
#endif

/* POINTER defines a generic pointer type */
typedef unsigned char *POINTER;

/* UINT2 defines a two byte word */
typedef unsigned short int UINT2;

/* UINT4 defines a four byte word */
typedef unsigned long int UINT4;

/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.
If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
  returns an empty list.
 */
#if PROTOTYPES
#define PROTO_LIST(list) list
#else
#define PROTO_LIST(list) ()
#endif


/* MD5 context. */

typedef struct _MD5_CTX{
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
} MD5_CTX, MD_CTX;

typedef ENetAddr MAC_ADDRESS, *PMAC_ADDRESS;

void MD5Init PROTO_LIST ((MD5_CTX *));
void MD5Update PROTO_LIST
  ((MD5_CTX *, unsigned char *, unsigned int));
void MD5Final PROTO_LIST ((unsigned char [16], MD5_CTX *));


// Constants for MD5Transform routine.

#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void MD5Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));
static void Encode PROTO_LIST
  ((unsigned char *, UINT4 *, unsigned int));
static void Decode PROTO_LIST
  ((UINT4 *, unsigned char *, unsigned int));
static void MD5_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));
static void MD5_memset PROTO_LIST ((POINTER, int, unsigned int));

static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// F, G, H and I are basic MD5 functions.
 
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

// ROTATE_LEFT rotates x left n bits.
 
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

// FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
// Rotation is separate from addition to prevent recomputation.
 
#define FF(a, b, c, d, x, s, ac) { \
 (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) { \
 (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) { \
 (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) { \
 (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }

// MD5 initialization. Begins an MD5 operation, writing a new context.
 
void 
MD5Init (
    MD5_CTX *context// context 
    )
{
  context->count[0] = context->count[1] = 0;
  // Load magic initialization constants.

  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}

// MD5 block update operation. Continues an MD5 message-digest
//  operation, processing another message block, and updating the
//  context.
 
void 
MD5Update (
    MD5_CTX *context,   // context 
    unsigned char *input,   // input block 
    unsigned int inputLen   // length of input block 
    )
{
    unsigned int i, index, partLen;

    // Compute number of bytes mod 64 
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);

    // Update number of bits 
    if ((context->count[0] += ((UINT4)inputLen << 3))
        < ((UINT4)inputLen << 3))
    {        
        context->count[1]++;
    }
    
    context->count[1] += ((UINT4)inputLen >> 29);

    partLen = 64 - index;

    // Transform as many times as possible.

    if (inputLen >= partLen) 
    {
        MD5_memcpy   ((POINTER)&context->buffer[index], 
                        (POINTER)input, 
                        partLen);

        MD5Transform (context->state, context->buffer);

        for (i = partLen; i + 63 < inputLen; i += 64)
        {
            MD5Transform (context->state, &input[i]);
        }

        index = 0;
    }
    else
    {
        i = 0;
    }
    // Buffer remaining input 
    MD5_memcpy
    ((POINTER)&context->buffer[index], (POINTER)&input[i],
    inputLen-i);
}

// MD5 finalization. Ends an MD5 message-digest operation, writing the
// the message digest and zeroizing the context.
 
void 
MD5Final (
    unsigned char digest[16],                         // message digest 
    MD5_CTX *context
    )                                       // context 
{
  unsigned char bits[8];
  unsigned int index, padLen;

  // Save number of bits 
  Encode (bits, context->count, 8);

  // Pad out to 56 mod 64.

  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);

  // Append length (before padding) 
  MD5Update (context, bits, 8);

  // Store state in digest 
  Encode (digest, context->state, 6);

  // Zeroize sensitive information.

  MD5_memset ((POINTER)context, 0, sizeof (*context));
}

// MD5 basic transformation. Transforms state based on block.
 
static 
void 
MD5Transform (
    UINT4 state[4],
    unsigned char block[64]
    )
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];

  Decode (x, block, 64);

  // Round 1 
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); // 1 
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); // 2 
  FF (c, d, a, b, x[ 2], S13, 0x242070db); // 3 
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); // 4 
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); // 5 
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); // 6 
  FF (c, d, a, b, x[ 6], S13, 0xa8304613); // 7 
  FF (b, c, d, a, x[ 7], S14, 0xfd469501); // 8 
  FF (a, b, c, d, x[ 8], S11, 0x698098d8); // 9 
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); // 10 
  FF (c, d, a, b, x[10], S13, 0xffff5bb1); // 11 
  FF (b, c, d, a, x[11], S14, 0x895cd7be); // 12 
  FF (a, b, c, d, x[12], S11, 0x6b901122); // 13 
  FF (d, a, b, c, x[13], S12, 0xfd987193); // 14 
  FF (c, d, a, b, x[14], S13, 0xa679438e); // 15 
  FF (b, c, d, a, x[15], S14, 0x49b40821); // 16 

 // Round 2 
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); // 17 
  GG (d, a, b, c, x[ 6], S22, 0xc040b340); // 18 
  GG (c, d, a, b, x[11], S23, 0x265e5a51); // 19 
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); // 20 
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); // 21 
  GG (d, a, b, c, x[10], S22,  0x2441453); // 22 
  GG (c, d, a, b, x[15], S23, 0xd8a1e681); // 23 
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); // 24 
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); // 25 
  GG (d, a, b, c, x[14], S22, 0xc33707d6); // 26 
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); // 27 
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); // 28 
  GG (a, b, c, d, x[13], S21, 0xa9e3e905); // 29 
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); // 30 
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); // 31 
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); // 32 

  // Round 3 
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); // 33 
  HH (d, a, b, c, x[ 8], S32, 0x8771f681); // 34 
  HH (c, d, a, b, x[11], S33, 0x6d9d6122); // 35 
  HH (b, c, d, a, x[14], S34, 0xfde5380c); // 36 
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); // 37 
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); // 38 
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); // 39 
  HH (b, c, d, a, x[10], S34, 0xbebfbc70); // 40 
  HH (a, b, c, d, x[13], S31, 0x289b7ec6); // 41 
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); // 42 
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); // 43 
  HH (b, c, d, a, x[ 6], S34,  0x4881d05); // 44 
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); // 45 
  HH (d, a, b, c, x[12], S32, 0xe6db99e5); // 46 
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); // 47 
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); // 48 

  // Round 4 
  II (a, b, c, d, x[ 0], S41, 0xf4292244); // 49 
  II (d, a, b, c, x[ 7], S42, 0x432aff97); // 50 
  II (c, d, a, b, x[14], S43, 0xab9423a7); // 51 
  II (b, c, d, a, x[ 5], S44, 0xfc93a039); // 52 
  II (a, b, c, d, x[12], S41, 0x655b59c3); // 53 
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); // 54 
  II (c, d, a, b, x[10], S43, 0xffeff47d); // 55 
  II (b, c, d, a, x[ 1], S44, 0x85845dd1); // 56 
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); // 57 
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); // 58 
  II (c, d, a, b, x[ 6], S43, 0xa3014314); // 59 
  II (b, c, d, a, x[13], S44, 0x4e0811a1); // 60 
  II (a, b, c, d, x[ 4], S41, 0xf7537e82); // 61 
  II (d, a, b, c, x[11], S42, 0xbd3af235); // 62 
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); // 63 
  II (b, c, d, a, x[ 9], S44, 0xeb86d391); // 64 

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;

  // Zeroize sensitive information.

  MD5_memset ((POINTER)x, 0, sizeof (x));
}

// Encodes input (UINT4) into output (unsigned char). Assumes len is
// a multiple of 4.
 
static 
void 
Encode (
    unsigned char *output,
    UINT4 *input,
    unsigned int len
    )
{
    unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4) 
    {
        output[j] = (unsigned char)(input[i] & 0xff);
        output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
        output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
        output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
    }
}

// Decodes input (unsigned char) into output (UINT4). Assumes len is
// a multiple of 4.
 
static 
void 
Decode (
    UINT4 *output,
    unsigned char *input,
    unsigned int len
    )
{
  unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4)
    {
    output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
                (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
    }
}

// Note: Replace "for loop" with standard memcpy if possible.
 

static 
void 
MD5_memcpy (
    POINTER output,
    POINTER input,
    unsigned int len
    )
{
    unsigned int i;

    for (i = 0; i < len; i++)
    { 
        output[i] = input[i];
    }
}

// Note: Replace "for loop" with standard memset if possible.
 
static 
void 
MD5_memset (
    POINTER output,
    int value,
    unsigned int len
    )
{
    unsigned int i;

    for (i = 0; i < len; i++)
    {   
        ((char *)output)[i] = (char)value;
    }
}


#define ETH_IS_MULTICAST(Address) \
        (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x01))


VOID
nicGetMacAddressFromEuid (
    UINT64 *pEuid,
    MAC_ADDRESS *pMacAddr
    )
/*
Taken directly from nic1394 and is intended to produce the same output as nic1394.

This is used to create display Correct HW addr in the arp -a output. 

We take the Unique ID and run it through the MD5 algorithm because this is what
nic1394 would have done to get the MAC address that it reports to us

I have the name as nicGet.. to imply that this should be the same alogorithm as nic1394's md5
algorithm

*/
{

    MD_CTX context;
    unsigned char digest[6];
    unsigned int len = 8;

    MD5Init (&context);
    MD5Update (&context, (unsigned char*)pEuid, len);
    MD5Final (digest, &context);

    NdisMoveMemory (pMacAddr, digest, 6);

    // Set the locally administered bit 
    // and clear the multicast bit.

    //
    // randomize the returned Mac Address
    // by xor ing the address with a random 
    // 0xf22f617c91e0 (a random number)
    //
    //pMacAddr->addr[0] ^= 0x00;
    pMacAddr->addr[0] |= 0x2;
    pMacAddr->addr[0] &= 0xf2;
    pMacAddr->addr[1] ^= 0x2f;
    pMacAddr->addr[2] ^= 0x61;
    pMacAddr->addr[3] ^= 0x7c;
    pMacAddr->addr[4] ^= 0x91;
    pMacAddr->addr[5] ^= 0x30;

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\n13cfg.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    n13cfg.c

Abstract:

    This code is NOT part of ARP1394. Rather it is sample code that creates
    the config ROM unit directory for IP/1394-capable devices.

    It is here simply for safekeeping.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     03-19-99    Created

Notes:

--*/
#include <precomp.h>

#ifdef TESTPROGRAM

ULONG
Bus1394Crc16(
    IN ULONG data,
    IN ULONG check
    );


ULONG
Bus1394CalculateCrc(
    IN PULONG Quadlet,
    IN ULONG length
    );


// From \nt\private\ntos\dd\wdm\1394\bus\busdef.h

//SPEC_ID_KEY_SIGNITURE
//SOFTWARE_VERSION_KEY_SIGNITURE
//MODEL_KEY_SIGNITURE
#define SPEC_ID_KEY_SIGNATURE                   0x12
#define SOFTWARE_VERSION_KEY_SIGNATURE          0x13
// #define MODEL_ID_KEY_SIGNATURE                  0x17
//#define VENDOR_KEY_SIGNATURE                    0x81
#define TEXTUAL_LEAF_INDIRECT_KEY_SIGNATURE     0x81
#define MODEL_KEY_SIGNATURE                     0x82
//#define UNIT_DIRECTORY_KEY_SIGNATURE            0xd1
//#define UNIT_DEP_DIR_KEY_SIGNATURE              0xd4

    //
    // IEEE 1212 Offset entry definition
    //
    typedef struct _OFFSET_ENTRY {
        ULONG               OE_Offset:24;
        ULONG               OE_Key:8;
    } OFFSET_ENTRY, *POFFSET_ENTRY;
    
    //
    // IEEE 1212 Immediate entry definition
    //
    typedef struct _IMMEDIATE_ENTRY {
        ULONG               IE_Value:24;
        ULONG               IE_Key:8;
    } IMMEDIATE_ENTRY, *PIMMEDIATE_ENTRY;
    
    //
    // IEEE 1212 Directory definition
    //
    typedef struct _DIRECTORY_INFO {
        union {
            USHORT          DI_CRC;
            USHORT          DI_Saved_Length;
        } u;
        USHORT              DI_Length;
    } DIRECTORY_INFO, *PDIRECTORY_INFO;

#define bswap(_val)  SWAPBYTES_ULONG(_val)


// Some NIC1394-specific constants
//
#define NIC1394_UnitSpecIdValue         0x5E            // For "IANA"
#define NIC1394_UnitSwVersionValue      0x1             // IP/1394 Spec
#define NIC1394_ModelSpecIdValue        0x7bb0cf        // Random (TBD by Microsoft)
#define NIC1394_ModelName               L"NIC1394"

    
typedef struct _NIC1394_CONFIG_ROM
{
    // The Unit Directory
    //
    struct
    {
        DIRECTORY_INFO      Info;
        struct
        {
            IMMEDIATE_ENTRY     SpecId;
            IMMEDIATE_ENTRY     SwVersion;
            IMMEDIATE_ENTRY     ModelId;
            OFFSET_ENTRY        ModelIdTextOffset;
        } contents;

    } unit_dir;

    // The ModelId Text Leaf Directory
    //
    struct
    {
        DIRECTORY_INFO      Info;
        struct
        {
            IMMEDIATE_ENTRY     SpecId;
            ULONG               LanguageId;
            ULONG               Text[4]; // L"NIC1394"
        } contents;

    } model_text_dir;

} NIC1394_CONFIG_ROM, *PNIC1394_CONFIG_ROM;


VOID
InitializeNic1394ConfigRom(
    IN PNIC1394_CONFIG_ROM Nic1394ConfigRom
    )
/*++
    
Routine Description:

    This routine initializes the configuration ROM unit directory (and the
    leaf directories it references) for NIC1394, the IP/1394-capable device.

Arguments:

    Nic1394ConfigRom - Pointer to the unitialized config ROM structure.

Return Value:

    None

--*/
{
    PNIC1394_CONFIG_ROM pCR = Nic1394ConfigRom;
    INT i;

    RtlZeroMemory(pCR, sizeof(*pCR));

    //
    // Initialize the unit directory header.
    //
    pCR->unit_dir.Info.DI_Length =              sizeof(pCR->unit_dir.contents)/
                                                sizeof(ULONG);

    //
    // Initialize the entries of the unit directory.
    //
    pCR->unit_dir.contents.SpecId.IE_Key        = SPEC_ID_KEY_SIGNATURE;
    pCR->unit_dir.contents.SpecId.IE_Value      = NIC1394_UnitSpecIdValue;
    pCR->unit_dir.contents.SwVersion.IE_Key     = SOFTWARE_VERSION_KEY_SIGNATURE;
    pCR->unit_dir.contents.SwVersion.IE_Value   = NIC1394_UnitSwVersionValue;
    pCR->unit_dir.contents.ModelId.IE_Key       = MODEL_KEY_SIGNATURE;
    pCR->unit_dir.contents.ModelId.IE_Value     = NIC1394_ModelSpecIdValue;
    pCR->unit_dir.contents.ModelIdTextOffset.OE_Key
        = TEXTUAL_LEAF_INDIRECT_KEY_SIGNATURE;
    pCR->unit_dir.contents.ModelIdTextOffset.OE_Offset
        = ( FIELD_OFFSET(NIC1394_CONFIG_ROM, model_text_dir)
           -FIELD_OFFSET(NIC1394_CONFIG_ROM, unit_dir.contents.ModelIdTextOffset))
          / sizeof (ULONG);

    // Initialize the model text directory header.
    //
    pCR->model_text_dir.Info.DI_Length =    sizeof(pCR->model_text_dir.contents)/
                                            sizeof(ULONG);

    //
    // Initialize the model text directory contents
    //
    pCR->model_text_dir.contents.SpecId.IE_Key  = 0x80;     // For "text leaf"
    pCR->model_text_dir.contents.SpecId.IE_Value= 0x0;      // For "text leaf"
    pCR->model_text_dir.contents.LanguageId     = 0x409;    // For "unicode"
    ASSERT(sizeof(pCR->model_text_dir.contents.Text)>=sizeof(NIC1394_ModelName));
    RtlCopyMemory(
            pCR->model_text_dir.contents.Text,
            NIC1394_ModelName,
            sizeof(NIC1394_ModelName)
            );

    //
    // Now convert into over-the-wire format (watch out for the unicode string in
    // pCR->model_test_dir.contents.Text.
    //

    //
    // Byte swap the unicode strings here, cuz we're gonna byte swap
    // everything down below - so it'll come out a wash.
    //

    for (i=0; i < sizeof(pCR->model_text_dir.contents.Text)/sizeof(ULONG); i++)
    {
        pCR->model_text_dir.contents.Text[i] = 
            bswap(pCR->model_text_dir.contents.Text[i]);
    
    }

    //
    // Now we've got to byte swap the entire config rom so other
    // nodes can read it correctly from accross the bus.
    // We need to do this BEFORE computing the CRC.
    //

    for (i=0; i < (sizeof(*pCR)/sizeof(ULONG)); i++)
    {
        ((PULONG) pCR)[i] =  bswap(((PULONG) pCR)[i]);
    }

    //
    // Compute the following CRC:
    //
    //  pCR->unit_dir.Info.DI_CRC
    //  pCR->model_text_dir.Info.DI_CRC
    //
    // NOTE: we have bswapped all cfg rom, so we need to temporarily "unbswap"
    // the two DIRECTORY_INFOs to set the CRC.
    //
    {
        DIRECTORY_INFO Info;


        Info =  pCR->unit_dir.Info; // Struct copy.
        *(PULONG)&Info = bswap(*(PULONG)&Info);     // "unbswap"
        Info.u.DI_CRC =  (USHORT) Bus1394CalculateCrc(
                                        (PULONG)&(pCR->unit_dir.contents),
                                        Info.DI_Length
                                        );
        *(PULONG)(&pCR->unit_dir.Info) = bswap (*(PULONG)&Info); // "re-bswap"


        Info =  pCR->model_text_dir.Info; // Struct copy.
        *(PULONG)&Info = bswap(*(PULONG)&Info);             // "unbeswap"
        Info.u.DI_CRC =  (USHORT) Bus1394CalculateCrc(
                                        (PULONG)&(pCR->model_text_dir.contents),
                                        Info.DI_Length
                                        );
        *(PULONG)(&pCR->model_text_dir.Info) = bswap (*(PULONG)&Info); // "re-bswap"
    }
}

//
//  From bus\buspnp.c
//

ULONG
Bus1394CalculateCrc(
    IN PULONG Quadlet,
    IN ULONG length
    )

/*++

Routine Description:

    This routine calculates a CRC for the pointer to the Quadlet data.

Arguments:

    Quadlet - Pointer to data to CRC

    length - length of data to CRC

Return Value:

    returns the CRC

--*/

{
    
    LONG temp;
    ULONG index;

    temp = index = 0;

    while (index < length) {

        temp = Bus1394Crc16(Quadlet[index++], temp);

    }

    return (temp);

} 


ULONG
Bus1394Crc16(
    IN ULONG data,
    IN ULONG check
    )

/*++

Routine Description:

    This routine derives the 16 bit CRC as defined by IEEE 1212
    clause 8.1.5.  (ISO/IEC 13213) First edition 1994-10-05.

Arguments:

    data - ULONG data to derive CRC from

    check - check value

Return Value:

    Returns CRC.

--*/

{

    LONG shift, sum, next;


    for (next=check, shift=28; shift >= 0; shift -=4) {

        sum = ((next >> 12) ^ (data >> shift)) & 0xf;
        next = (next << 4) ^ (sum << 12) ^ (sum << 5) ^ (sum);

    }

    return (next & 0xFFFF);

}

void DumpCfgRomCRC(void)
{
    NIC1394_CONFIG_ROM Net1394ConfigRom;
    unsigned char *pb = (unsigned char*) &Net1394ConfigRom;
    INT i;

    InitializeNic1394ConfigRom(&Net1394ConfigRom);

    printf("unsigned char Net1394ConfigRom[%lu] = {", sizeof(Net1394ConfigRom));
    for (i=0; i<(sizeof(Net1394ConfigRom)-1); i++)
    {
        if ((i%8) == 0)
        {
            printf("\n\t");
        }
        printf("0x%02lx, ", pb[i]);
    }
    printf("0x%02lx\n};\n", pb[i]);
}
#endif // TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\mcap.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    mcap.c

Abstract:

    ARP1394 MCAP protocol code.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     10-01-99    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_MCAP


//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================
NDIS_STATUS
arpParseMcapPkt(
    IN   PIP1394_MCAP_PKT pMcapPkt,
    IN   UINT                       cbBufferSize,
    OUT  PIP1394_MCAP_PKT_INFO      pPktInfo
    );


VOID
arpProcessMcapAdvertise(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_MCAP_PKT_INFO   pPktInfo,
    PRM_STACK_RECORD            pSR
    );

VOID
arpProcessMcapSolicit(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_MCAP_PKT_INFO   pPktInfo,
    PRM_STACK_RECORD            pSR
    );

VOID
arpUpdateMcapInfo(
    IN  PARP1394_INTERFACE          pIF,        // NOLOCKIN NOLOCKOUT
    IN  PIP1394_MCAP_PKT_INFO       pPktInfo,
    PRM_STACK_RECORD                pSR
    );

NDIS_STATUS
arpParseMcapPkt(
    IN   PIP1394_MCAP_PKT pMcapPkt,
    IN   UINT                       cbBufferSize,
    OUT  PIP1394_MCAP_PKT_INFO      pPktInfo
    );

NDIS_STATUS
arpParseMcapPkt(
    IN   PIP1394_MCAP_PKT pMcapPkt,
    IN   UINT                       cbBufferSize,
    OUT  PIP1394_MCAP_PKT_INFO      pPktInfo
    )
/*++
Routine Description:

    Parse the contents of IP/1394 MCAP packet data starting at
    pMcapPkt. Place the results into pPktInfo.

Arguments:

    pMcapPkt    - Contains the unaligned contents of an ip/1394 MCAP Pkt.
    pPktInfo    - Unitialized structure to be filled with the parsed contents of the
                  pkt.

Return Value:

    NDIS_STATUS_FAILURE if the parse failed (typically because of invalid pkt
                        contents.)
    NDIS_STATUS_SUCCESS on successful parsing.
    
--*/
{
    ENTER("arpParseMcapPkt", 0x95175d5a)
    NDIS_STATUS                 Status;
    DBGSTMT(CHAR *szError   = "General failure";)

    Status  = NDIS_STATUS_FAILURE;

    do
    {
        UINT OpCode; // MCAP op code (solicit/advertise)
        UINT Length; // Length of valid part of packet, including the encap header.
        UINT NumGds; // Number of group_descriptors;

        // Minimum size.
        //
        if (cbBufferSize < FIELD_OFFSET(IP1394_MCAP_PKT, group_descriptors))
        {
            DBGSTMT(szError = "Packet too small";)
            break;
        }

        // Ethertype
        //
        if (pMcapPkt->header.EtherType != H2N_USHORT(NIC1394_ETHERTYPE_MCAP))
        {
            DBGSTMT(szError = "header.EtherType!=MCAP";)
            break;
        }


        // length
        //
        {
            // pMcapPkt->length is the length of packet excluding the unfragmented
            // header.
            //
            Length =  (ULONG) N2H_USHORT(pMcapPkt->length) + sizeof(pMcapPkt->header);
            if (Length > cbBufferSize)
            {
                DBGSTMT(szError = "Length field too large";)
                break;
            }
            // Note: it's valid to have zero group descriptors.
            //
            if (Length < FIELD_OFFSET(IP1394_MCAP_PKT, group_descriptors))
            {
                DBGSTMT(szError = "Length field too small";)
                break;
            }
        }

        // reserved field
        //
        if (pMcapPkt->reserved != 0)
        {
            DBGSTMT(szError = "reserved != 0";)
            break;
        }

        // Opcode
        //
        {
            OpCode = N2H_USHORT(pMcapPkt->opcode);
    
            if (    OpCode !=  IP1394_MCAP_OP_ADVERTISE
                &&  OpCode !=  IP1394_MCAP_OP_SOLICIT)
            {
                DBGSTMT(szError = "Invalid opcode";)
                break;
            }
        }


        // Now we check the descriptors
        //
        {
            PIP1394_MCAP_GD pGd;
            DBGSTMT(PIP1394_MCAP_GD pGdEnd;)
            UINT u;
            
            // Note: we've already verified that Length is large enough.
            //
            NumGds = (Length - FIELD_OFFSET(IP1394_MCAP_PKT, group_descriptors))
                     / sizeof(IP1394_MCAP_GD);
            pGd = pMcapPkt->group_descriptors;
            DBGSTMT(pGdEnd = (PIP1394_MCAP_GD) (((PUCHAR) pMcapPkt) + cbBufferSize);)

            for (u=NumGds; u>0; u--, pGd++)
            {
                IP1394_MCAP_GD Gd;
                ASSERT(pGd < pGdEnd);
                Gd = *pGd;              // Unaligned struct copy.

                if (Gd.length != sizeof(Gd))
                {
                    // bad length
                    //
                    DBGSTMT(szError = "Bad GD: bad length";)
                    break;
                }

                if (Gd.type != IP1394_MCAP_GD_TYPE_V1)
                {
                    // bad type
                    //
                    DBGSTMT(szError = "Bad GD: bad type";)
                    break;
                }

                if (Gd.reserved != 0)
                {
                    // bad reserved
                    //
                    DBGSTMT(szError = "Bad GD: bad reserved";)
                    break;
                }

                if (Gd.channel > 63)
                {
                    // bad channel
                    //
                    DBGSTMT(szError = "Bad GD: bad channel";)
                    break;
                }

                // We don't check speed code to interop with unknown speeds.
                // (we map unknown speeds to the highest speed code we know about.

                if (Gd.reserved2 != 0)
                {
                    // bad reserved2
                    //
                    DBGSTMT(szError = "Bad GD: bad reserved2";)
                    break;
                }

                if (Gd.bandwidth != 0)
                {
                    // bad bandwidth
                    //
                    DBGSTMT(szError = "Bad GD: bad bandwidth";)
                    break;
                }


                {
                    UINT Addr = H2N_ULONG(Gd.group_address);
                    if ( (Addr & 0xf0000000) != 0xe0000000)
                    {
                        // Address is not class D
                        //
                        DBGSTMT(szError = "Bad GD: address not class D";)
                        break;
                    }
                    if (Addr == 0xe0000001 || Addr == 0xe0000002)
                    {
                        // 224.0.0.1 and 224.0.0.2 must be sent on the broadcast
                        // channel
                        //
                        DBGSTMT(szError = "Bad GD: Address 224.0.0.1 or 2";)
                        break;
                    }
                }
            }

            if (u!=0)
            {
                break;
            }
            
        }

        //
        // Pkt appears valid, let's fill out the parsed information....
        //
    
        ARP_ZEROSTRUCT(pPktInfo);

        pPktInfo->NumGroups     =  NumGds;
        pPktInfo->SenderNodeID  =  N2H_USHORT(pMcapPkt->header.NodeId);
        pPktInfo->OpCode        =  OpCode;

        // Parse the group descriptors...
        // If required, dynamically allocate space for the descriptors,
        // otherwise we use pPktInfo->GdSpace;
        //
        {
            PIP1394_MCAP_GD pGd;
            PIP1394_MCAP_GD_INFO    pGdi;
            UINT                    cb = NumGds * sizeof(*pGdi);
            UINT                    u;

            if (cb <= sizeof(pPktInfo->GdiSpace))
            {
                pGdi = pPktInfo->GdiSpace;
            }
            else
            {
                NdisAllocateMemoryWithTag(&pGdi, cb,  MTAG_MCAP_GD);
                if (pGdi == NULL)
                {
                    DBGSTMT(szError = "Allocation Failure";)
                    Status = NDIS_STATUS_RESOURCES;
                    break;
                }
            }
            pPktInfo->pGdis = pGdi;

            // Now parse...
            //
            pGd = pMcapPkt->group_descriptors;

            for (u=NumGds; u>0; u--, pGd++, pGdi++)
            {
                pGdi->Expiration    = pGd->expiration;
                pGdi->Channel       = pGd->channel;
                pGdi->SpeedCode     = pGd->speed;
                pGdi->GroupAddress  = pGd->group_address; // Leave in Network order

                if (pGdi->Channel >=  ARP_NUM_CHANNELS)
                {
                    TR_INFO(("Bad channel in GD 0x%p\n",  pGdi));
                    continue;
                }

                //
                // Although RFC doesn't stipulate a max expiry time, we
                // cap it ourselves, in case this is a rogue packet.
                //
                #define MAX_EXPIRATION 120
                if (pGdi->Expiration >=  MAX_EXPIRATION)
                {
                    TR_INFO(("Capping expiry time to %d sec\n",  MAX_EXPIRATION));
                    pGdi->Expiration =  MAX_EXPIRATION;
                    continue;
                }

                if (pGdi->SpeedCode >  SCODE_3200_RATE)
                {
                    //
                    // This is either a bad value, or a rate higher than we know
                    // about. We can't distinguish between the two, so we just set
                    // the speed to the highest we know about.
                    //
                    pGdi->SpeedCode = SCODE_3200_RATE;
                }
            }
        }

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    if (FAIL(Status))
    {
        TR_WARN(("Bad mcap pkt data at 0x%p (%s)\n",  pMcapPkt, szError));
    }
    else
    {
    #if DBG
        UINT    Addr    = 0;
        UINT    Channel = 0;
        UINT    Exp     = 0;
        PUCHAR  pc      = (PUCHAR) &Addr;

        if (pPktInfo->NumGroups!=0)
        {
            Addr    = pPktInfo->pGdis[0].GroupAddress;
            Channel = pPktInfo->pGdis[0].Channel;
            Exp     = pPktInfo->pGdis[0].Expiration;
        }
    #endif // DBG

        TR_WARN(("Received MCAP PKT. NodeId=0x%04lx NumGrps=%lu."
                 " 1st=(Grp=%lu.%lu.%lu.%lu, Ch=%lu, TTL=%lu)\n",
                pPktInfo->SenderNodeID,
                pPktInfo->NumGroups,
                pc[0], pc[1], pc[2], pc[3],
                Channel,
                Exp
                ));
    }

    EXIT()

    return Status;
}


NDIS_STATUS
arpCreateMcapPkt(
    IN  PARP1394_INTERFACE          pIF,
    IN  PIP1394_MCAP_PKT_INFO       pPktInfo,
    OUT PNDIS_PACKET               *ppNdisPacket,
    PRM_STACK_RECORD                pSR
    )
/*++

Routine Description:

    Use information in pPktInfo to allocate and initialize an mcap packet.

Arguments:

    pPktInfo        -   Parsed version of the arp request/response packet.
    ppNdisPacket    -   Points to a place to store a pointer to the allocated packet.
                    

Return Value:

    NDIS_STATUS_RESOURCES  - If we couldn't allocate the packet.
    NDIS_STATUS_SUCCESS    - on success.
    
--*/
{
    UINT                NumGroups;              
    UINT                Length;
    NDIS_STATUS         Status;
    PIP1394_MCAP_PKT    pPktData;
    PIP1394_MCAP_GD     pGd;

    NumGroups                   = pPktInfo->NumGroups;
    Length                      = FIELD_OFFSET(IP1394_MCAP_PKT, group_descriptors);
    Length                     += NumGroups * sizeof(IP1394_MCAP_GD);

    Status = arpAllocateControlPacket(
                pIF,
                Length,
                ARP1394_PACKET_FLAGS_MCAP,
                ppNdisPacket,
                &pPktData,
                pSR
                );

    if (FAIL(Status)) return Status;                // ***** EARLY RETURN ******


    // Can't use ARP_ZEROSTRUCT because NumGroups may be zero.
    //
    NdisZeroMemory(pPktData, Length);
    
    pPktData->header.EtherType  = H2N_USHORT(NIC1394_ETHERTYPE_MCAP);
    pPktData->opcode            = (UCHAR)pPktInfo->OpCode;
    Length                     -= sizeof(pPktData->header); // Skip the header.
    pPktData->length            = H2N_USHORT(Length);


    // Construct the group descriptors.
    //  
    if (NumGroups)
    {
        PIP1394_MCAP_GD_INFO    pGdi = pPktInfo->pGdis;
        PIP1394_MCAP_GD         pGd  = pPktData->group_descriptors;

        for(;NumGroups; pGdi++, pGd++, NumGroups--)
        {
            ARP_ZEROSTRUCT(pGd);
            pGd->length         = (UCHAR) sizeof(*pGd);
            pGd->expiration     = (UCHAR) pGdi->Expiration;
            pGd->channel        = (UCHAR) pGdi->Channel;
            pGd->speed          = (UCHAR) pGdi->SpeedCode;
            pGd->group_address  = pGdi->GroupAddress;
        }
    }

    return NDIS_STATUS_SUCCESS;
}


#if 0
// Parsed version of the IP/1394 MCAP Group Descriptor 
//
typedef struct
{
    UINT                    Expiration;
    UINT                    Channel;
    UINT                    SpeedCode;
    IP_ADDRESS              GroupAddress;

}  IP1394_MCAP_GD_INFO, * PIP1394_MCAP_GD_INFO;


// Parsed version of an IP/1394 MCAP packet.
//
typedef struct
{
    UINT                    SenderNodeID;
    UINT                    OpCode;
    UINT                    NumGroups;
    PIP1394_MCAP_GD_INFO    pGdis;

    // Space for storing up-to 4 GD_INFOs
    //
    IP1394_MCAP_GD_INFO     GdiSpace[4];

} IP1394_MCAP_PKT_INFO, *PIP1394_MCAP_PKT_INFO;
#endif // 0



VOID
arpUpdateMcapInfo(
    IN  PARP1394_INTERFACE          pIF,        // NOLOCKIN NOLOCKOUT
    IN  PIP1394_MCAP_PKT_INFO       pPktInfo,
    PRM_STACK_RECORD                pSR
)
{
    ENTER("arpUpdateMcapInfo", 0xcac15343)
    PIP1394_MCAP_GD_INFO    pGdi;
    UINT                    NumGroups;
    UINT                    Current;
    UINT                    NodeId;
    RM_DECLARE_STACK_RECORD(sr)


    RM_ASSERT_OBJUNLOCKED(&pIF->Hdr, pSR);

    // Get the current time (in seconds).
    //
    Current = arpGetSystemTime();

    //
    //  Go through the group discriptors, updating our database.
    //
    NumGroups = pPktInfo->NumGroups;
    pGdi      = pPktInfo->pGdis;
    NodeId    = pPktInfo->SenderNodeID;

    for(;NumGroups; pGdi++, NumGroups--)
    {
        UINT        Expiration      =  pGdi->Expiration;
        UINT        Channel         =  pGdi->Channel;
        IP_ADDRESS  GroupAddress    = pGdi->GroupAddress;
        PMCAP_CHANNEL_INFO pMci;

        //
        // Process this group descriptor.
        //

        if (Channel >= ARP_NUM_CHANNELS)
        {
            ASSERT(FALSE); // we should have already screened this value.
            continue;
        }

        LOCKOBJ(pIF, &sr);
        
        pMci = &pIF->mcapinfo.rgChannelInfo[Channel];
        pMci->Channel = Channel;
        pMci->GroupAddress = GroupAddress;
        pMci->UpdateTime = Current;
        pMci->ExpieryTime = Current + Expiration; // Expiration is in seconds.
        pMci->Flags = 0;       // Reset flags.
        pMci->NodeId = NodeId; // TODO: check if existing node id is higher?

        UNLOCKOBJ(pIF, &sr);

    }

    RM_ASSERT_OBJUNLOCKED(&pIF->Hdr, pSR);
}


VOID
arpProcessMcapPkt(
    PARP1394_INTERFACE  pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_MCAP_PKT    pMcapPkt,
    UINT                cbBufferSize
    )
{
    NDIS_STATUS Status;
    IP1394_MCAP_PKT_INFO    PktInfo;
    ENTER("arpProcessMcapPkt", 0xc5ba8005)
    RM_DECLARE_STACK_RECORD(sr)

    DBGMARK(0x3cfaf454);

    Status = arpParseMcapPkt(
                pMcapPkt,
                cbBufferSize,
                &PktInfo
                );


    if (!FAIL(Status))
    {
        if (PktInfo.OpCode == IP1394_MCAP_OP_ADVERTISE)
        {
            arpProcessMcapAdvertise(pIF, &PktInfo, &sr);
        }
        else
        {
            ASSERT(PktInfo.OpCode ==  IP1394_MCAP_OP_SOLICIT);
            arpProcessMcapSolicit(pIF, &PktInfo, &sr);
        }
    }

    RM_ASSERT_CLEAR(&sr);

    EXIT()

}

VOID
arpProcessMcapAdvertise(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_MCAP_PKT_INFO   pPktInfo,
    PRM_STACK_RECORD            pSR
    )
{
    //
    // Update our database.
    //
    arpUpdateMcapInfo(
            pIF,        // NOLOCKIN NOLOCKOUT
            pPktInfo,
            pSR
            );
}

VOID
arpProcessMcapSolicit(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_MCAP_PKT_INFO   pPktInfo,
    PRM_STACK_RECORD            pSR
    )
{
    //
    // We ignore solicit messages.
    //
    //

}


MYBOOL
arpIsActiveMcapChannel(
        PMCAP_CHANNEL_INFO pMci,
        UINT CurrentTime
        )
{
    ENTER("IsActiveMcapChannel", 0x0)
    MYBOOL fOk = TRUE;
    
    // Check update time.
    //
    #define  ARP_MAX_MCAP_UPDATE_INTERVAL 60
    if ((pMci->UpdateTime+ARP_MAX_MCAP_UPDATE_INTERVAL) < CurrentTime)
    {
        TR_WARN(("McapDB: channel %lu update time crossed.\n",
                pMci->Channel
                ));
        fOk = FALSE;
    }

    // Check expire time.
    //
    if (pMci->ExpieryTime <= CurrentTime)
    {
        TR_WARN(("McapDB: channel %lu time expired.\n",
                pMci->Channel
                ));
        fOk = FALSE;
    }

    return fOk;
}

VOID
arpLocallyUpdateMcapInfo(
        PARP1394_INTERFACE pIF,
        UINT Channel,
        UINT GroupAddress,
        UINT CurrentTime,
        PRM_STACK_RECORD pSR
        )
{
    ENTER("arpLocallyUpdateMcapInfo", 0x0)
    PMCAP_CHANNEL_INFO pMci;

    LOCKOBJ(pIF, pSR);
    
    pMci = &pIF->mcapinfo.rgChannelInfo[Channel];
    pMci->Channel = Channel;
    pMci->GroupAddress = GroupAddress;
    pMci->UpdateTime = CurrentTime;
    pMci->ExpieryTime = CurrentTime + 60; // Expiration is in seconds.
    pMci->Flags = 0;       // Reset flags.
    pMci->NodeId = 0;  // NodeId; // TODO: get real node id.

    UNLOCKOBJ(pIF, pSR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\nd.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    nd.c

Abstract:

    ARP1394 ndis handlers (excluding connection-oriented handlers).

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     12-01-98    Created, adapting code from atmarpc.sys

Notes:

--*/
#include <precomp.h>


//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_ND



//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

// ARP1394_BIND_PARAMS is used when creating an adapter object.
//
typedef struct
{
    PNDIS_STRING pDeviceName;
    PNDIS_STRING pArpConfigName;
    PVOID       IpConfigHandle;
    NDIS_HANDLE BindContext;

} ARP1394_BIND_PARAMS;


NDIS_STATUS
arpPnPReconfigHandler(
    IN ARP1394_ADAPTER  *   pAdapter,
    IN PNET_PNP_EVENT               pNetPnPEvent
    );

ENetAddr 
arpGetSecondaryMacAddress (
    IN ENetAddr  EthernetMacAddress
    );

NDIS_STATUS
arpGetEuidTopologyWorkItem(
    struct _ARP1394_WORK_ITEM* pWorkItem, 
    PRM_OBJECT_HEADER pObj ,
    PRM_STACK_RECORD pSR
    );


VOID
arpAddBackupTasks (
    IN ARP1394_GLOBALS* pGlobals,
    UINT Num
    );

VOID
arpRemoveBackupTasks (
    IN ARP1394_GLOBALS* pGlobals,
    UINT Num
     );

NDIS_STATUS
arpNdSetPower (
    ARP1394_ADAPTER *pAdapter,
    PNET_DEVICE_POWER_STATE   pPowerState,
    PRM_STACK_RECORD pSR
    );

NDIS_STATUS
arpResume (
    IN ARP1394_ADAPTER* pAdapter,
    IN ARP_RESUME_CAUSE Cause,
    IN PRM_STACK_RECORD pSR
);

const ENetAddr DummyENet = {0xba,0xdb,0xad,0xba,0xdb,0xad};
//=========================================================================
//      N D I S   H A N D L E R S
//=========================================================================

INT
ArpNdBindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 BindContext,
    IN  PNDIS_STRING                pDeviceName,
    IN  PVOID                       SystemSpecific1,
    IN  PVOID                       SystemSpecific2
)
/*++

Routine Description:

    This is called by NDIS when it has an adapter for which there is a
    binding to the ARP client.

    We first allocate an Adapter structure. Then we open our configuration
    section for this adapter and save the handle in the Adapter structure.
    Finally, we open the adapter.

    We don't do anything more for this adapter until NDIS notifies us of
    the presence of a Call manager (via our AfRegisterNotify handler).

Arguments:

    pStatus             - Place to return status of this call
    BindContext         - NDIS-supplied Bind context. IF this is NULL,
                            we are calling ourselves to open an adapter in
                            Ethernet emulation (bridge) mode.
    pDeviceName         - The name of the adapter we are requested to bind to
    SystemSpecific1     - Opaque to us; to be used to access configuration info
    SystemSpecific2     - Opaque to us; not used.

Return Value:

    Always TRUE. We set *pStatus to an error code if something goes wrong before we
    call NdisOpenAdapter, otherwise NDIS_STATUS_PENDING.

--*/
{
    NDIS_STATUS         Status;
    ARP1394_ADAPTER *   pAdapter;
#if DBG
    KIRQL EntryIrql =  KeGetCurrentIrql();
#endif // DBG

    ENTER("BindAdapter", 0x5460887b)
    RM_DECLARE_STACK_RECORD(sr)
    TIMESTAMP("==>BindAdapter");

    if (g_SkipAll)
    {
        TR_WARN(("aborting\n"));
        *pStatus = NDIS_STATUS_NOT_RECOGNIZED;
        TIMESTAMP("<==BindAdapter");
        return TRUE;
    }

    do 
    {
        PRM_TASK            pTask;
        ARP1394_BIND_PARAMS BindParams;

        // Setup initialization parameters
        //
        BindParams.pDeviceName          = pDeviceName;
        BindParams.pArpConfigName       = (PNDIS_STRING) SystemSpecific1;
        BindParams.IpConfigHandle       = SystemSpecific2;
        BindParams.BindContext          = BindContext;


        // Allocate and initialize adapter object.
        // This also sets up ref counts for all linkages, plus one
        // tempref for us, which we must deref when done.
        //
        Status =  RM_CREATE_AND_LOCK_OBJECT_IN_GROUP(
                            &ArpGlobals.adapters.Group,
                            pDeviceName,                // Key
                            &BindParams,                // Init params
                            &((PRM_OBJECT_HEADER)pAdapter),
                            NULL,   // pfCreated
                            &sr
                            );
        if (FAIL(Status))
        {
            TR_WARN(("FATAL: Couldn't create adapter object\n"));
            pAdapter = NULL;
            break;
        }

        // Allocate task to  complete the initialization.
        // The task is tmp ref'd for us, and we must deref it when we're done here.
        // We implicitly do this by calling RmStartTask below.
        //
        Status = arpAllocateTask(
                    &pAdapter->Hdr,             // pParentObject,
                    arpTaskInitializeAdapter,   // pfnHandler,
                    0,                          // Timeout,
                    "Task: Initialize Adapter", // szDescription
                    &pTask,
                    &sr
                    );

        if (FAIL(Status))
        {
            pTask = NULL;
            break;
        }

        UNLOCKOBJ(pAdapter, &sr);

        // Start the task to complete this initialization.
        // NO locks must be held at this time.
        // RmStartTask expect's a tempref on the task, which it deref's when done.
        // RmStartTask will free the task automatically, whether it completes
        // synchronously or asynchronously.
        //
        Status = RmStartTask(pTask, 0, &sr);

        LOCKOBJ(pAdapter, &sr);

    } while(FALSE);

    if (pAdapter)
    {
        UNLOCKOBJ(pAdapter, &sr);

        if (!PEND(Status) && FAIL(Status))
        {
            #if 0
            RmFreeObjectInGroup(
                &ArpGlobals.adapters.Group,
                &(pAdapter->Hdr),
                NULL,               // NULL pTask == synchronous.
                &sr
                );
            #endif // 0
            // At this point the adapter should be a "zombie object."
            //
            ASSERTEX(RM_IS_ZOMBIE(pAdapter), pAdapter);
        }

        RmTmpDereferenceObject(&pAdapter->Hdr, &sr);
    }

    *pStatus = Status;

#if DBG
    {
        KIRQL ExitIrql =  KeGetCurrentIrql();
        TR_INFO(("Exiting. EntryIrql=%lu, ExitIrql = %lu\n", EntryIrql, ExitIrql));
    }
#endif //DBG

    RM_ASSERT_CLEAR(&sr);
    EXIT()
    TIMESTAMP("<==BindAdapter");
    return 0;
}


VOID
ArpNdUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 UnbindContext
)
/*++

Routine Description:

    This routine is called by NDIS when it wants us to unbind
    from an adapter. Or, this may be called from within our Unload
    handler. We undo the sequence of operations we performed
    in our BindAdapter handler.

Arguments:

    pStatus                 - Place to return status of this operation
    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ATMARP Adapter structure.
    UnbindContext           - This is NULL if this routine is called from
                              within our Unload handler. Otherwise (i.e.
                              NDIS called us), we retain this for later use
                              when calling NdisCompleteUnbindAdapter.

Return Value:

    None. We set *pStatus to NDIS_STATUS_PENDING always.

--*/
{
    ENTER("UnbindAdapter", 0x6bff4ab5)
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>UnbindAdapter");
    // Get adapter lock and tmpref it.
    LOCKOBJ(pAdapter, &sr);
    RmTmpReferenceObject(&pAdapter->Hdr, &sr);

    do
    {
        NDIS_STATUS Status;
        PRM_TASK    pTask;

        if (CHECK_POWER_STATE(pAdapter,ARPAD_POWER_LOW_POWER)== TRUE)
        {
            pAdapter->PoMgmt.bReceivedUnbind = TRUE;;
        }


        // Allocate task to  complete the unbind.
        //
        Status = arpAllocateTask(
                    &pAdapter->Hdr,             // pParentObject,
                    arpTaskShutdownAdapter,     // pfnHandler,
                    0,                          // Timeout,
                    "Task: Shutdown Adapter",   // szDescription
                    &pTask,
                    &sr
                    );
    
        if (FAIL(Status))
        {
            // Ugly situation. We'll just leave things as they are...
            //
            pTask = NULL;
            TR_WARN(("FATAL: couldn't allocate unbind task!\n"));
            break;
        }

        
        // Start the task to complete the unbind.
        // No locks must be held. RmStartTask uses up the tmpref on the task
        // which was added by arpAllocateTask.
        //
        
        UNLOCKOBJ(pAdapter, &sr);
        Status = RmStartTask(pTask, (UINT_PTR) UnbindContext, &sr);
        LOCKOBJ(pAdapter, &sr);
    
    } while(FALSE);

    UNLOCKOBJ(pAdapter, &sr);
    RmTmpDereferenceObject(&pAdapter->Hdr, &sr);
    *pStatus = NDIS_STATUS_PENDING;

    RM_ASSERT_CLEAR(&sr);
    TIMESTAMP("<==UnbindAdapter");
    EXIT()
}


VOID
ArpNdOpenAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status,
    IN  NDIS_STATUS                 OpenErrorStatus
)
/*++

Routine Description:

    This is called by NDIS when a previous call to NdisOpenAdapter
    that had pended has completed. We now complete the BindAdapter
    that lead to this.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ARP1394_ADAPTER structure.
    Status                  - Status of OpenAdapter
    OpenErrorStatus         - Error code in case of failure.

--*/
{
    ENTER("OpenAdapterComplete", 0x06d9342c)
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>OpenAdapterComplete");
    // We expect a nonzero task here (the bind task), which we unpend.
    // No need to grab locks or anything at this stage.
    //
    {
        TR_INFO((
            "BindCtxt=0x%p, status=0x%p, OpenErrStatus=0x%p",
            ProtocolBindingContext,
            Status,
            OpenErrorStatus
            ));

        // We don't pass on OpenErrorStatus, so we have just the status
        // to pass on, which we do directly as the UINT_PTR "Param".
        //
        RmResumeTask(pAdapter->bind.pSecondaryTask, (UINT_PTR) Status, &sr);
    }

    RM_ASSERT_CLEAR(&sr)
    EXIT()
    TIMESTAMP("<==OpenAdapterComplete");
}

VOID
ArpNdCloseAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status
)
/*++

Routine Description:

    This is called by NDIS when a previous call to NdisCloseAdapter
    that had pended has completed. The task that called NdisCloseAdapter
    would have suspended itself, so we simply resume it now.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ARP1394_ADAPTER structure.
    Status                  - Status of CloseAdapter

Return Value:

    None

--*/
{
    ENTER("CloseAdapterComplete", 0x889d22eb)
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>CloseAdapterComplete");
    // We expect a nonzero task here (UNbind task), which we unpend.
    // No need to grab locks or anything at this stage.
    //
    RmResumeTask(pAdapter->bind.pSecondaryTask, (UINT_PTR) Status, &sr);

    TIMESTAMP("<==CloseAdapterComplete");

    RM_ASSERT_CLEAR(&sr)
    EXIT()
}

VOID
ArpNdResetComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status
)
/*++

Routine Description:

    This routine is called when the miniport indicates that a Reset
    operation has just completed. We ignore this event.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to our Adapter structure.
    Status                  - Status of the reset operation.

Return Value:

    None

--*/
{
    TIMESTAMP("===ResetComplete");
}

VOID
ArpNdReceiveComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext
)
/*++

Routine Description:

    This is called by NDIS when the miniport is done with receiving
    a bunch of packets, meaning that it is now time to start processing
    them. We simply pass this on to IP.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ARP1394_ADAPTER structure.

Return Value:

    None

--*/
{
    PARP1394_ADAPTER            pAdapter;
    PARP1394_INTERFACE          pIF;

    pAdapter = (PARP1394_ADAPTER)ProtocolBindingContext;
    pIF =  pAdapter->pIF;

    //
    // WARNING: for perf reasons, we don't do the clean thing of
    // locking the adapter, refing pIF, unlocking the adapter,
    // calling pIF->ip.RcvCmpltHandler, then derefing pIF.
    //
    if ((pIF != NULL) && (pIF->ip.Context != NULL))
    {
        #if MILLEN
            ASSERT_PASSIVE();
        #endif // MILLEN
        pIF->ip.RcvCmpltHandler();
    }
}


VOID
ArpNdRequestComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNDIS_REQUEST               pNdisRequest,
    IN  NDIS_STATUS                 Status
)
/*++

Routine Description:

    This is called by NDIS when a previous call we made to NdisRequest() has
    completed.

Arguments:

    ProtocolBindingContext  - Pointer to our Adapter structure
    pNdisRequest            - The request that completed
    Status                  - Status of the request.

Return Value:

    None

--*/
{
    PARP_NDIS_REQUEST   pArpNdisRequest;
    PRM_TASK            pTask;
    ENTER("ArpNdRequestComplete", 0x8cdf7a6d)
    RM_DECLARE_STACK_RECORD(sr)

    pArpNdisRequest = CONTAINING_RECORD(pNdisRequest, ARP_NDIS_REQUEST, Request);
    pTask = pArpNdisRequest->pTask;
    pArpNdisRequest->Status = Status;

    if (pTask == NULL)
    {
        NdisSetEvent(&pArpNdisRequest->Event);
    }
    else
    {
        RmResumeTask(pTask, (UINT_PTR) Status, &sr);
    }

    EXIT()
}


VOID
ArpNdStatus(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 GeneralStatus,
    IN  PVOID                       pStatusBuffer,
    IN  UINT                        StatusBufferSize
)
/*++

Routine Description:

    This routine is called when the miniport indicates an adapter-wide
    status change. We ignore this.

Arguments:

    <Ignored>

--*/
{
}

VOID
ArpNdStatusComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext
)
/*++

Routine Description:

    This routine is called when the miniport wants to tell us about
    completion of a status change (?). Ignore this.

Arguments:

    <Ignored>

Return Value:

    None

--*/
{
}


VOID
ArpNdSendComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNDIS_PACKET                pNdisPacket,
    IN  NDIS_STATUS                 Status
)
/*++

Routine Description:

    This is the Connection-less Send Complete handler, which signals
    completion of such a Send. Since we don't ever use this feature,
    we don't expect this routine to be called.

Arguments:

    <Ignored>

Return Value:

    None

--*/
{
#if TEST_ICS_HACK
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) ProtocolBindingContext;
    arpEthSendComplete(
        pAdapter,
        pNdisPacket,
        Status
        );
#else // TEST_ICS_HACK
    ASSERT(FALSE);
#endif // TEST_ICS_HACK
}


NDIS_STATUS
ArpNdReceive (
    NDIS_HANDLE  ProtocolBindingContext,
    NDIS_HANDLE Context,
    VOID *Header,
    UINT HeaderSize,
    VOID *Data,
    UINT Size,
    UINT TotalSize
    )
/*++
    TODO: We need to support this for ICS, because MILL NDIS calls this
    handler to indicate packets which have the STATUS_RESOURCES bit set.
--*/
{
    return NDIS_STATUS_NOT_RECOGNIZED;  
}

INT
ArpNdReceivePacket (
        NDIS_HANDLE  ProtocolBindingContext,
        PNDIS_PACKET Packet
        )
{
#if TEST_ICS_HACK
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) ProtocolBindingContext;

    arpEthReceivePacket(
        pAdapter->pIF,
        Packet
        );
#endif // TEST_ICS_HACK

    return 0; // We return 0 because no one hangs on to this packet.
}


NDIS_STATUS
ArpNdPnPEvent(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNET_PNP_EVENT              pNetPnPEvent
)
/*++

Routine Description:

    This is the NDIS entry point called when NDIS wants to inform
    us about a PNP/PM event happening on an adapter. If the event
    is for us, we consume it. Otherwise, we pass this event along
    to IP along the first Interface on this adapter.

    When IP is done with it, it will call our IfPnPEventComplete
    routine.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ARP1394_ADAPTER structure.

    pNetPnPEvent            - Pointer to the event.

Return Value:

    None

--*/
{
    ENTER("PnPEvent", 0x2a517a8c)
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) ProtocolBindingContext;
    ARP1394_INTERFACE * pIF =  NULL;
    NDIS_STATUS                     Status;
    PIP_PNP_RECONFIG_REQUEST        pIpReconfigReq;
    ULONG                           Length;

    RM_DECLARE_STACK_RECORD(sr)

#ifdef NT
    do
    {
        pIpReconfigReq = (PIP_PNP_RECONFIG_REQUEST)pNetPnPEvent->Buffer;
        Length = pNetPnPEvent->BufferLength;

        TIMESTAMP1("==>PnPEvent 0x%lx", pNetPnPEvent->NetEvent);
        //
        //  Do we have a binding context?
        //
        if (pAdapter == NULL)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        //  Is this directed to us?
        //
        if (pNetPnPEvent->NetEvent == NetEventReconfigure)
        {

        #if MILLEN
            DbgPrint("Arp1394: This should never be called on Millen\n");   
            //DbgBreakPoint();      // Never called on Millen.
        #endif // MILLEN

            if (Length < sizeof(IP_PNP_RECONFIG_REQUEST))
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            if (pIpReconfigReq->arpConfigOffset != 0)
            {
                Status = arpPnPReconfigHandler(pAdapter, pNetPnPEvent);
                break;
            }
        }

        //
        // 01/21/2000  JosephJ: The NIC1394 MCM doesn't close AF's when it's shut
        //              down by NDIS during a powering down event. So
        //              we work around this by claiming not to support
        //              PnP Power so that NDIS closes US as well.
        //
        if (pNetPnPEvent->NetEvent == NetEventSetPower)
        {
            PNET_DEVICE_POWER_STATE         pPowerState;
            pPowerState = (PNET_DEVICE_POWER_STATE) pNetPnPEvent->Buffer;

            Status = arpNdSetPower (pAdapter, pPowerState,&sr );

            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }

        }
        else
        {
                TIMESTAMPX("===PnPEvent (not SetPower)");
        }

        //
        //  This belongs to IP....
        //
        {
            LOCKOBJ(pAdapter, &sr);
            pIF =  pAdapter->pIF;
    
            if ((pIF != NULL) && (pIF->ip.Context != NULL))
            {
                RmTmpReferenceObject(&pIF->Hdr, &sr);
                UNLOCKOBJ(pAdapter, &sr);
            #if MILLEN
                ASSERT_PASSIVE();
            #endif // MILLEN
                Status = pIF->ip.PnPEventHandler(
                            pIF->ip.Context,
                            pNetPnPEvent
                            );
                RmTmpDereferenceObject(&pIF->Hdr, &sr);
            }
            else
            {
                UNLOCKOBJ(pAdapter, &sr);
                Status = NDIS_STATUS_SUCCESS;
            }
        }
    }
    while (FALSE);
#else
    Status = NDIS_STATUS_SUCCESS;
#endif // NT

    TR_INFO((" pIF 0x%x, pEvent 0x%x, Evt 0x%x, Status 0x%x\n",
                 pIF, pNetPnPEvent, pNetPnPEvent->NetEvent, Status));


    RM_ASSERT_CLEAR(&sr)
    EXIT()

    TIMESTAMP("<==PnPEvent");
    return Status;
}

VOID
ArpNdUnloadProtocol(
    VOID
)
/*++

Routine Description:

    Unloads our  protocol module. We unbind from all adapters,
    and deregister from NDIS as a protocol.

Arguments:

    None.

Return Value:

    None

--*/
{
    ENTER("UnloadProtocol", 0x8143fec5)
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>UnloadProtocol");
    RmUnloadAllGenericResources(&ArpGlobals.Hdr, &sr);

    RM_ASSERT_CLEAR(&sr)
    TIMESTAMP("<==UnloadProtocol");
    EXIT()
    return;
}


NDIS_STATUS
arpTaskInitializeAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for initializing an adapter.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pTask);
    PTASK_ADAPTERINIT pAdapterInitTask;

    enum
    {
        STAGE_BecomePrimaryTask,
        STAGE_ActivateAdapterComplete,
        STAGE_DeactivateAdapterComplete,
        STAGE_End

    } Stage;

    ENTER("TaskInitializeAdapter", 0xb6ada31d)

    pAdapterInitTask = (PTASK_ADAPTERINIT) pTask;
    ASSERT(sizeof(TASK_ADAPTERINIT) <= sizeof(ARP1394_TASK));

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_BecomePrimaryTask;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    ASSERTEX(!PEND(Status), pTask);
        
    switch(Stage)
    {

        case  STAGE_BecomePrimaryTask:
        {
            // If there is a primary task, pend on it, else make ourselves
            // the primary task.
            //
            LOCKOBJ(pAdapter, pSR);
            if (pAdapter->bind.pPrimaryTask == NULL)
            {
                arpSetPrimaryAdapterTask(pAdapter, pTask, ARPAD_PS_INITING, pSR);
                UNLOCKOBJ(pAdapter, pSR);
            }
            else
            {
                PRM_TASK pOtherTask =  pAdapter->bind.pPrimaryTask;
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    STAGE_BecomePrimaryTask, // we'll try again...
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
        
            //
            // We're now the  primary task. Since we're starting out,
            // there should be NO activate/deactivate task.
            // (Note: we don't bother getting the adapter lock for these asserts).
            //
            ASSERT(pAdapter->bind.pPrimaryTask == pTask);
            ASSERT(pAdapter->bind.pSecondaryTask == NULL);

            //
            // Allocate and start the activate adapter task.
            //
            {
                PRM_TASK pActivateTask;

                Status = arpAllocateTask(
                            &pAdapter->Hdr,             // pParentObject,
                            arpTaskActivateAdapter,     // pfnHandler,
                            0,                          // Timeout,
                            "Task: Activate Adapter(init)", // szDescription
                            &pActivateTask,
                            pSR
                            );
            
                if (FAIL(Status))
                {
                    pActivateTask = NULL;
                    TR_WARN(("FATAL: couldn't alloc activate task!\n"));
                }
                else
                {
                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_ActivateAdapterComplete,
                        pActivateTask,              // task to pend on
                        pSR
                        );
            
                    // RmStartTask uses up the tmpref on the task
                    // which was added by arpAllocateTask.
                    //
                    Status = RmStartTask(
                                pActivateTask,
                                0, // UserParam (unused)
                                pSR
                                );
                }
            }
         }


        if (PEND(Status)) break;
        
        // FALL THROUGH TO NEXT STAGE

        case STAGE_ActivateAdapterComplete:
        {
            //
            // We've run the active-adapter task. On failure, we need to
            // cleanup state by calling the deactivate-adapter task.
            //

            // Save away the failure code for later...
            //
            pAdapterInitTask->ReturnStatus = Status;

            if (FAIL(Status))
            {
                PRM_TASK pDeactivateTask;

                Status = arpAllocateTask(
                                &pAdapter->Hdr,             // pParentObject,
                                arpTaskDeactivateAdapter,       // pfnHandler,
                                0,                          // Timeout,
                                "Task: Deactivate Adapter(init)", // szDescription
                                &pDeactivateTask,
                                pSR
                                );
            
                if (FAIL(Status))
                {
                    pDeactivateTask = NULL;
                    ASSERT(FALSE); // TODO: use special dealloc task pool for this.
                    TR_WARN(("FATAL: couldn't alloc deactivate task!\n"));
                }
                else
                {

                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_DeactivateAdapterComplete,
                        pDeactivateTask,                // task to pend on
                        pSR
                        );
            
                    // RmStartTask uses up the tmpref on the task
                    // which was added by arpAllocateTask.
                    //
                    Status = RmStartTask(
                                pDeactivateTask,
                                0, // UserParam (unused)
                                pSR
                                );
                }
            }
        }
        break;

        case STAGE_DeactivateAdapterComplete:
        {
            //
            // We've completed the deactivate adapter task which we started
            // because of some init-adapter failure.
            //

            // In general, we don't expect the deactivate task to return failure.
            //
            ASSERT(!FAIL(Status));

            // We expect the original status of the init to be a failure (that's
            // why we started the deinit in the first place!
            //
            ASSERT(FAIL(pAdapterInitTask->ReturnStatus));
            Status = pAdapterInitTask->ReturnStatus;

        }
        break;

        case STAGE_End:
        {
            NDIS_HANDLE                 BindContext;
            BOOLEAN                     BridgeEnabled = ARP_BRIDGE_ENABLED(pAdapter);

            //
            // We HAVE to be the primary task at this point, becase we simply
            // wait and retry until we become one.
            //

            // Clear the primary task in the adapter object.
            //
            LOCKOBJ(pAdapter, pSR);
            {
                ULONG InitState;
                InitState = FAIL(Status) ? ARPAD_PS_FAILEDINIT : ARPAD_PS_INITED;
                arpClearPrimaryAdapterTask(pAdapter, pTask, InitState, pSR);
            }
            BindContext = pAdapter->bind.BindContext;
            UNLOCKOBJ(pAdapter, pSR);


            // On failure, pAdapter should be deallocated.
            //
            if (FAIL(Status))
            {
                if(RM_IS_ZOMBIE(pAdapter))
                {
                    TR_WARN(("END: pAdapter is already deallocated.\n"));
                }
                else
                {
                    //
                    // On failure, free the adapter here itself, because we're
                    // not going to call the shutdown task.
                    //
                    RmFreeObjectInGroup(
                        &ArpGlobals.adapters.Group,
                        &(pAdapter->Hdr),
                        NULL,               // NULL pTask == synchronous.
                        pSR
                        );
                }
            }

            if (!BridgeEnabled)
            {
                // Signal IP that the bind is complete.
                //
                TIMESTAMP("===Calling IP's BindComplete routine");
                RM_ASSERT_NOLOCKS(pSR);
                ArpGlobals.ip.pBindCompleteRtn(
                                Status,
                                BindContext
                                );
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskShutdownAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for shutting down an IP interface.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pTask);
    TASK_ADAPTERSHUTDOWN *pMyTask = (TASK_ADAPTERSHUTDOWN*) pTask;
    enum
    {
        STAGE_BecomePrimaryTask,
        STAGE_DeactivateAdapterComplete,
        STAGE_End
    } Stage;

    ENTER("TaskShutdownAdapter", 0xe262e828)

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_BecomePrimaryTask;

            // Save away the UnbindContext (which we get as UserParam) in
            // the task's private context, for use later.
            //
            pMyTask->pUnbindContext = (NDIS_HANDLE) UserParam;

            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **
    }

    ASSERTEX(!PEND(Status), pTask);

    switch(Stage)
    {

        case  STAGE_BecomePrimaryTask:
        {
            // If there is a primary task, pend on it, else make ourselves
            // the primary task.
            // We could get in this situation if someone does a
            // "net stop arp1394" while we're in the middle of initializing or
            // shutting down the adapter.
            //
            //
            LOCKOBJ(pAdapter, pSR);
            if (pAdapter->bind.pPrimaryTask == NULL)
            {
                arpSetPrimaryAdapterTask(pAdapter, pTask, ARPAD_PS_DEINITING, pSR);
                UNLOCKOBJ(pAdapter, pSR);
            }
            else
            {
                PRM_TASK pOtherTask =  pAdapter->bind.pPrimaryTask;
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    STAGE_BecomePrimaryTask, // we'll try again...
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
        
            //
            // We're now the  primary task. Since we're starting out,
            // there should be NO activate/deactivate task.
            // (Note: we don't bother getting the adapter lock for these asserts).
            //
            ASSERT(pAdapter->bind.pPrimaryTask == pTask);
            ASSERT(pAdapter->bind.pSecondaryTask == NULL);

            //
            // Allocate and start the deactivate adapter task.
            //
            {
                PRM_TASK pDeactivateTask;

                Status = arpAllocateTask(
                            &pAdapter->Hdr,             // pParentObject,
                            arpTaskDeactivateAdapter,       // pfnHandler,
                            0,                          // Timeout,
                            "Task: Deactivate Adapter(shutdown)",   // szDescription
                            &pDeactivateTask,
                            pSR
                            );
            
                if (FAIL(Status))
                {
                    pDeactivateTask = NULL;
                    TR_WARN(("FATAL: couldn't alloc deactivate task!\n"));
                }
                else
                {
                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_DeactivateAdapterComplete,
                        pDeactivateTask,                // task to pend on
                        pSR
                        );
            
                    // RmStartTask uses up the tmpref on the task
                    // which was added by arpAllocateTask.
                    //
                    Status = RmStartTask(
                                pDeactivateTask,
                                0, // UserParam (unused)
                                pSR
                                );
                }
            }
         }
         break;

        case STAGE_DeactivateAdapterComplete:
        {
            // Nothing to do here -- we clean  up in STAGE_End.
            //
            break;
        }

        case STAGE_End:
        {
            //
            // We HAVE to be the primary task at this point, becase we simply
            // wait and retry until we become one.
            //
            ASSERT(pAdapter->bind.pPrimaryTask == pTask);

            // Clear the primary task in the adapter object.
            //
            LOCKOBJ(pAdapter, pSR);
            arpClearPrimaryAdapterTask(pAdapter, pTask, ARPAD_PS_DEINITED, pSR);
            UNLOCKOBJ(pAdapter, pSR);


            if(RM_IS_ZOMBIE(pAdapter))
            {
                TR_WARN(("END: pAdapter is already deallocated.\n"));
            }
            else
            {
                // Free the adapter.
                // (pAdapter will be allocated, but it will be in a "zombie" state).
                //
                RmFreeObjectInGroup(
                    &ArpGlobals.adapters.Group,
                    &(pAdapter->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );
            }
            // If there is an unbind-context, signal NDIS that the unbind is
            //  complete.
            //
            if (pMyTask->pUnbindContext)
            {
                TR_WARN(("END: Calling NdisCompleteUnbindAdapter. Status= 0x%lx\n",
                            Status));
                RM_ASSERT_NOLOCKS(pSR);
                TIMESTAMP("===Calling NdisCompleteUnbindAdapter");
                NdisCompleteUnbindAdapter(
                                pMyTask->pUnbindContext,
                                Status
                            );
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskActivateAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for initializing an adapter.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pTask);
    enum
    {
        PEND_OpenAdapter,
        PEND_GetAdapterInfo
    };
    ENTER("arpTaskActivateAdapter", 0xb6ada31d)

    switch(Code)
    {

        case RM_TASKOP_START:
        {
        
        #if MILLEN
            NDIS_MEDIUM                 Medium =  NdisMedium802_3;
        #else // !MILLEN
            NDIS_MEDIUM                 Medium = NdisMedium802_3;
        #endif // !MILLEN
            UINT                        SelMediumIndex = 0;
            NDIS_STATUS                 OpenStatus;

            //
            // Allocate Backup Tasks
            //
            arpAddBackupTasks (&ArpGlobals,ARP1394_BACKUP_TASKS);

            // Set ourselves as the secondary task.
            //
            LOCKOBJ(pAdapter, pSR);
            arpSetSecondaryAdapterTask(pAdapter, pTask, ARPAD_AS_ACTIVATING, pSR);
            UNLOCKOBJ(pAdapter, pSR);

            //
            // Suspend task and call NdisOpenAdapter...
            //

            RmSuspendTask(pTask, PEND_OpenAdapter, pSR);
            RM_ASSERT_NOLOCKS(pSR);
            NdisOpenAdapter(
                &Status,
                &OpenStatus,
                &pAdapter->bind.AdapterHandle,
                &SelMediumIndex,                    // selected medium index
                &Medium,                            // Array of medium types
                1,                                  // Size of Media list
                ArpGlobals.ndis.ProtocolHandle,
                (NDIS_HANDLE)pAdapter,              // our adapter bind context
                &pAdapter->bind.DeviceName,         // pDeviceName
                0,                                  // Open options
                (PSTRING)NULL                       // Addressing Info...
                );
    
            if (Status != NDIS_STATUS_PENDING)
            {
                ArpNdOpenAdapterComplete(
                        (NDIS_HANDLE)pAdapter,
                        Status,
                        OpenStatus
                        );
            }
            Status = NDIS_STATUS_PENDING;
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            PTASK_ADAPTERACTIVATE pAdapterInitTask;
            pAdapterInitTask = (PTASK_ADAPTERACTIVATE) pTask;
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            ASSERT(sizeof(TASK_ADAPTERACTIVATE) <= sizeof(ARP1394_TASK));

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OpenAdapter:
        
                    //
                    // The open adapter operation is complete. Get adapter
                    // information and notify IP on success. On failure,
                    // shutdown the adapter if required, and notify IP of
                    // the failure.
                    //
        
                    if (FAIL(Status))
                    {
                        // Set adapter handle to null -- it may not be hull.
                        // even though the open adapter has succeeded.
                        //
                        pAdapter->bind.AdapterHandle = NULL;
                        break;
                    }

                    // Successfully opened the adapter.
                    // Now get adapter information from miniport.
                    // (We use the TASK_ADAPTERINIT.ArpNdisRequest field,
                    // which is defined specifically for this use).
                    //
                    Status =  arpPrepareAndSendNdisRequest(
                                pAdapter,
                                &pAdapterInitTask->ArpNdisRequest,
                                NULL,  // pTask - Finish the request synchronously
                                PEND_GetAdapterInfo,
                                OID_1394_LOCAL_NODE_INFO,
                                &pAdapterInitTask->LocalNodeInfo,
                                sizeof(pAdapterInitTask->LocalNodeInfo),
                                NdisRequestQueryInformation,
                                pSR
                                );
                    ASSERT(!PEND(Status));
                    if (PEND(Status)) break;

                    // FALL THROUGH on synchronous completion of arpGetAdapterInfo...

                case PEND_GetAdapterInfo:

                    //
                    // Done with getting adapter info.
                    // We need to switch to passive before going further
                    //
                    if (!ARP_ATPASSIVE())
                    {

                        // We're not at passive level, but we need to be when we
                        // call IP's add interface. So we switch to passive...
                        // NOTE: we specify completion code PEND_GetAdapterInfo
                        //       because we want to get back here (except
                        //       we'll be at passive).
                        //
                        RmSuspendTask(pTask, PEND_GetAdapterInfo, pSR);
                        RmResumeTaskAsync(
                            pTask,
                            Status,
                            &pAdapterInitTask->WorkItem,
                            pSR
                            );
                        Status = NDIS_STATUS_PENDING;
                        break;
                    }
            
                    if (Status == NDIS_STATUS_SUCCESS)
                    {
                    

                        //
                        // Copy over adapter info into pAdapter->info...
                        // Then read configuration information.
                        //

                        LOCKOBJ(pAdapter, pSR);
                        ARP_ZEROSTRUCT(&pAdapter->info);

                        // OID_GEN_CO_VENDOR_DESCRIPTION
                        //
                        pAdapter->info.szDescription = "NIC1394";
                        pAdapter->info.DescriptionLength = sizeof("NIC1394");
                        // TODO -- when you do the real stuff, remember to free it.
                    
                        // Max Frame size
                        // TODO: fill in the real adapter's MTU.
                        //
                        pAdapter->info.MTU =  ARP1394_ADAPTER_MTU;
                    
                        
                        pAdapter->info.LocalUniqueID    = 
                                            pAdapterInitTask->LocalNodeInfo.UniqueID;

                        {
                            UINT MaxRec;
                            UINT MaxSpeedCode;
                            MaxSpeedCode =
                                    pAdapterInitTask->LocalNodeInfo.MaxRecvSpeed;
                            MaxRec = 
                                    pAdapterInitTask->LocalNodeInfo.MaxRecvBlockSize;

                        #if DBG
                            while (   !IP1394_IS_VALID_MAXREC(MaxRec)
                                || !IP1394_IS_VALID_SSPD(MaxSpeedCode)
                                || MaxSpeedCode == 0)
                            {
                                TR_WARN(("FATAL: Invalid maxrec(0x%x) or sspd(0x%x)!\n",
                                        MaxRec,
                                        MaxSpeedCode
                                        ));
                                TR_WARN(("        &maxrec=0x%p, &sspd=0x%p\n",
                                        &MaxRec,
                                        &MaxSpeedCode
                                        ));
                                DbgBreakPoint();
                            }

                            TR_WARN(("Selected maxrec=0x%x and sspd=0x%x.\n",
                                        MaxRec,
                                        MaxSpeedCode
                                        ));
                        #endif // DBG

                            pAdapter->info.MaxRec = MaxRec;
                            pAdapter->info.MaxSpeedCode = MaxSpeedCode;
                        }

                        // B TODO: we should get this from the NIC -- add
                        // to the IOCTL OR query the adapter for its 
                        // MAC address.
                        // For now we put a hardcoded MAC address.
                        //
                #define ARP_FAKE_ETH_ADDRESS(_AdapterNum)                   \
                        {                                                   \
                            0x02 | (((UCHAR)(_AdapterNum) & 0x3f) << 2),    \
                            ((UCHAR)(_AdapterNum) & 0x3f),                  \
                            0,0,0,0                                         \
                        }
                
                #define ARP_DEF_LOCAL_ETH_ADDRESS \
                                ARP_FAKE_ETH_ADDRESS(0x1)

        

                        UNLOCKOBJ(pAdapter, pSR);


                        //
                        // Query the adapter for its Mac Addrees
                        //
                        {
                            ENetAddr    LocalEthAddr;
                            ARP_NDIS_REQUEST ArpNdisRequest;
                            ARP_ZEROSTRUCT (&ArpNdisRequest);
                            
                            Status =  arpPrepareAndSendNdisRequest(
                                        pAdapter,
                                        &ArpNdisRequest,
                                        NULL,                   // pTask (NULL==BLOCK)
                                        0,                      // unused
                                        OID_802_3_CURRENT_ADDRESS,
                                        &LocalEthAddr,
                                        sizeof(LocalEthAddr),
                                        NdisRequestQueryInformation,
                                        pSR
                                        );
     
                            LOCKOBJ(pAdapter, pSR);
                            
                            if (Status == NDIS_STATUS_SUCCESS)
                            {
                            
                                pAdapter->info.EthernetMacAddress = LocalEthAddr;
                            }
                            else
                            {
                                //
                                // we'll make one up if the miniport isn't responding
                                //
                                static ENetAddr LocalEthAddr =
                                                     ARP_DEF_LOCAL_ETH_ADDRESS;
                                pAdapter->info.EthernetMacAddress = 
                                                LocalEthAddr;

                                //Do not fail because of a bad request
                                ASSERT (Status == NDIS_STATUS_SUCCESS);
                                
                                Status = NDIS_STATUS_SUCCESS;

                            }
                            

                            UNLOCKOBJ(pAdapter, pSR);

                        }

                        //
                        // Query the adapter for its Speed
                        //
                        {
                            NDIS_CO_LINK_SPEED CoLinkSpeed;
                            ARP_NDIS_REQUEST ArpNdisRequest;
                            ARP_ZEROSTRUCT (&ArpNdisRequest);
                            
                            Status =  arpPrepareAndSendNdisRequest(
                                        pAdapter,
                                        &ArpNdisRequest,
                                        NULL,                   // pTask (NULL==BLOCK)
                                        0,                      // unused
                                        OID_GEN_CO_LINK_SPEED,
                                        &CoLinkSpeed,
                                        sizeof(CoLinkSpeed),
                                        NdisRequestQueryInformation,
                                        pSR
                                        );
     
                            LOCKOBJ(pAdapter, pSR);
                            
                            if (Status == NDIS_STATUS_SUCCESS)
                            {

                                //
                                // if nic1394 is in ethernet mode- it will fill in only one ULONG
                                // therefore rchoose outbound because it is the first ulong
                                // Multiply by 100 - thats what ethArp does.
                                //
                                pAdapter->info.Speed= (CoLinkSpeed.Outbound *100); 
                            }
                            else
                            {
                                //
                                // we'll make one up if the miniport isn't responding
                                //
                                pAdapter->info.Speed = 2000000; // Bytes/sec
  
                                //Do not fail because of a bad request
                                ASSERT (Status == NDIS_STATUS_SUCCESS);
                                
                                Status = NDIS_STATUS_SUCCESS;

                            }
                            

                            UNLOCKOBJ(pAdapter, pSR);

                        }
                        // Query the adapter for its Table of RemoteNodes
                        //
                        Status = arpGetEuidTopologyWorkItem(NULL, &pAdapter->Hdr, pSR);

                        
                        // Read Adapter Configuration Information
                        //
                        Status =  arpCfgReadAdapterConfiguration(pAdapter, pSR);
                    }

                    //
                    // NOTE: if we fail, a higher level task is responsible
                    // for "running the compensating transaction", i.e., running
                    // arpTaskDeactivateAdapter.
                    //

                // end case  PEND_OpenAdapter, PEND_GetAdapterInfo
                break;
    
                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))


        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

            // We're done -- the status had better not be pending!
            //
            ASSERTEX(!PEND(Status), pTask);

            
            // Clear ourselves as the secondary task in the adapter object.
            //
            {
                ULONG InitState;
                LOCKOBJ(pAdapter, pSR);
                InitState = FAIL(Status)
                             ? ARPAD_AS_FAILEDACTIVATE
                             : ARPAD_AS_ACTIVATED;
                arpClearSecondaryAdapterTask(pAdapter, pTask, InitState, pSR);
                UNLOCKOBJ(pAdapter, pSR);
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskDeactivateAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for shutting down an IP interface.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/

{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pTask);
    BOOLEAN             fContinueShutdown = FALSE;
    enum
    {
        PEND_ShutdownIF,
        PEND_CloseAdapter
    };
    ENTER("arpTaskDeactivateAdapter", 0xe262e828)


    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pAdapter, pSR);
            arpSetSecondaryAdapterTask(pAdapter, pTask, ARPAD_AS_DEACTIVATING, pSR);
            UNLOCKOBJ(pAdapter, pSR);
            fContinueShutdown = TRUE;

        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case PEND_CloseAdapter:
                {

                    //
                    // The close adapter operation is complete. Free the the
                    // adapter and if there is an unbind context, notify NDIS
                    // of unbind completion.
                    //
                    ASSERTEX(pAdapter->bind.AdapterHandle == NULL, pAdapter);
        
                    Status = (NDIS_STATUS) UserParam;

                    //
                    // free the back up tasks allocated in Task Activate Adapter
                    //
                    
                    arpRemoveBackupTasks (&ArpGlobals,ARP1394_BACKUP_TASKS);

                    // Status of the completed operation can't itself be pending!
                    //
                    
                    ASSERT(Status != NDIS_STATUS_PENDING);
                }
                break;

                case PEND_ShutdownIF:
                {
                    //
                    // Closing the IF is complete, continue with the rest
                    // of the shutdown procedure..
                    //
                    ASSERTEX(pAdapter->pIF == NULL, pAdapter);
                    fContinueShutdown = TRUE;
                }
                break;
            }
        }
        break;


        case  RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

            // Clear the secondary task in the adapter object.
            //
            LOCKOBJ(pAdapter, pSR);
            arpClearSecondaryAdapterTask(pAdapter, pTask, ARPAD_AS_DEACTIVATED, pSR);
            UNLOCKOBJ(pAdapter, pSR);
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)


    if (fContinueShutdown)
    {
        do {
            NDIS_HANDLE NdisAdapterHandle;
    
            LOCKOBJ(pAdapter, pSR);
    
            // If required, shutdown interface...
            //
            if (pAdapter->pIF)
            {
                PARP1394_INTERFACE pIF =  pAdapter->pIF;
                RmTmpReferenceObject(&pIF->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                arpDeinitIf(
                    pIF,
                    pTask,
                    PEND_ShutdownIF,
                    pSR
                    );
                RmTmpDereferenceObject(&pIF->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
    
            ASSERT(pAdapter->pIF == NULL);
    
            NdisAdapterHandle = pAdapter->bind.AdapterHandle;
            pAdapter->bind.AdapterHandle = NULL;
            UNLOCKOBJ(pAdapter, pSR);

            if (NdisAdapterHandle != NULL)
            {
                //
                // Suspend task and call NdisCloseAdapter...
                //
            
                RmSuspendTask(pTask, PEND_CloseAdapter, pSR);
                RM_ASSERT_NOLOCKS(pSR);
                NdisCloseAdapter(
                    &Status,
                    NdisAdapterHandle
                    );
            
                if (Status != NDIS_STATUS_PENDING)
                {
                    ArpNdCloseAdapterComplete(
                            (NDIS_HANDLE)pAdapter,
                            Status
                            );
                }
                Status = NDIS_STATUS_PENDING;
            }
    
        } while (FALSE);
    }

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpPnPReconfigHandler(
    IN PARP1394_ADAPTER             pAdapter,
    IN PNET_PNP_EVENT               pNetPnPEvent
    )
/*++

Routine Description:

    Handle a reconfig message on the specified adapter. If no adapter
    is specified, it is a global parameter that has changed.

Arguments:

    pAdapter        -  Pointer to our adapter structure
    pNetPnPEvent    -  Pointer to reconfig event

Return Value:

    NDIS_STATUS_SUCCESS always, for now.

--*/
{
    ENTER("PnPReconfig", 0x39bae883)
    NDIS_STATUS                             Status;
    RM_DECLARE_STACK_RECORD(sr)

    Status = NDIS_STATUS_FAILURE;
    
    do
    {
        PIP_PNP_RECONFIG_REQUEST        pIpReconfigReq;
        PARP1394_INTERFACE              pIF;
        pIpReconfigReq = (PIP_PNP_RECONFIG_REQUEST)pNetPnPEvent->Buffer;

        OBJLOG2(
            pAdapter,
            "AtmArpPnPReconfig: pIpReconfig 0x%x, arpConfigOffset 0x%x\n",
            pIpReconfigReq,
            pIpReconfigReq->arpConfigOffset
            );

        if(pIpReconfigReq->arpConfigOffset == 0)
        {
            // Invalid structure.
            //
            ASSERT(!"Invalid pIpReconfigReq");
            break;
        }

    #if 0

        //
        //  Enable this code if we want to validate the passed in config
        //  Information. This code is currently DISABLED. Instead
        //  we simply start reconfiguration on the SINGLE interface of
        //  the specified adapter.
        //

        //
        // TODO: define stucture for IP/1394 -- we're using the ATMARP structure
        // here!
        //
        ATMARPC_PNP_RECONFIG_REQUEST UNALIGNED *    pArpReconfigReq;
        ULONG uOffset;
        PWCH pwc;
        NDIS_STRING                     IPReconfigString;

        pArpReconfigReq = (ATMARPC_PNP_RECONFIG_REQUEST UNALIGNED *)
                        ((PUCHAR)pIpReconfigReq + pIpReconfigReq->arpConfigOffset);
        //
        // Locate the IP interface string passed in...
        //
        uOffset = pArpReconfigReq->IfKeyOffset;

        if (uOffset == 0)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        pwc = (PWCH) ((PUCHAR)pArpReconfigReq + uOffset);
        //
        //  ((PUCHAR)pArpReconfigReq + uOffset) points to a
        // "counted unicode string", which means that it's an array
        // of words, with the 1st word being the length in characters of
        // the string (there is no terminating null) and the following
        // <length> words being the string itself.

        //
        // Probe the string -- the passed-in structure could be bogus.
        //
        try
        {
            ProbeForRead(
                pwc,            // start of buffer, including count
                pwc[0]+1,       // length, including count. 
                sizeof(*pwc)    // sizeof(WCHAR) alignment required.
                );
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            OBJLOG0(pAdapter, "AtmArpPnPReconfig: Bogus buffer passed in\n");
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        // Lookup the IF based on the specified name.
        //
        IPReconfigString.Length = sizeof(pwc[0])*pwc[0];
        IPReconfigString.MaximumLength = IPReconfigString.Length;
        IPReconfigString.Buffer = pwc+1;

        // TODO: arpGetIfByName is not yet implemented!
        //
        pIF = arpGetIfByName(
                    pAdapter,
                    &sr
                    );
    #else // !0

        //
        // Since we support only one IF per adapter, and it's extra work
        // to verify the string, we completely ignore the contents
        // of the pnp event, and instead just start reconfiguration on the 
        // SINGLE IF associated with pAdapter.
        //
        LOCKOBJ(pAdapter, &sr);
        pIF = pAdapter->pIF;
        if (pIF != NULL)
        {
            RmTmpReferenceObject(&pIF->Hdr, &sr);
        }
        UNLOCKOBJ(pAdapter, &sr);

    #endif // !0
                

        if (pIF == NULL) break;
    

        //
        // We've found the IF this reconfig request applies to. Let's
        // start reconfiguration on this IF...
        //

        Status = arpTryReconfigureIf(pIF, pNetPnPEvent, &sr);

        RmTmpDereferenceObject(&pIF->Hdr, &sr);

    } while (FALSE);


    return Status;
}


PRM_OBJECT_HEADER
arpAdapterCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARP1394_ADAPTER.

Arguments:

    pParentObject   - Object that is to be the parent of the adapter.
    pCreateParams   - Actually a pointer to a ARP1394_BIND_PARAMS structure,
                      which contains information required to create the adapter.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ARP1394_ADAPTER * pA;
    ARP1394_BIND_PARAMS *pBindParams = (ARP1394_BIND_PARAMS*) pCreateParams;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    ENTER("arpAdapterCreate", 0xaa25c606)

    ARP_ALLOCSTRUCT(pA, MTAG_ADAPTER);

    do
    {


        if (pA == NULL)
        {
            break;
        }

        ARP_ZEROSTRUCT(pA);

        // Create up-cased version of the DeviceName and save it.
        //
        // WARNING: On MILLEN, this is actually an ANSI string. However,
        // arpCopyUnicodeString works fine even if it's an ANSI string.
        //
        Status = arpCopyUnicodeString(
                            &(pA->bind.DeviceName),
                            pBindParams->pDeviceName,
                            TRUE                        // Upcase
                            );

        if (FAIL(Status))
        {
            pA->bind.DeviceName.Buffer=NULL; // so we don't try to free it later
            break;
        }

        //
        // Determine if we're being created in Ethernet Emulation ("Bridge") mode
        //  We're created in bridge mode if the BindContext is NULL.
        //
        if (pBindParams->BindContext != NULL)
        {
            //
            // NOTE: We ONLY  read configuration if we're operation in
            // normal (Not BRIDGE) mode.
            //

            Status = arpCopyUnicodeString(
                                &(pA->bind.ConfigName),
                                pBindParams->pArpConfigName,
                                FALSE                       // Don't upcase
                                );
    
            if (FAIL(Status))
            {
                pA->bind.ConfigName.Buffer=NULL; // so we don't try to free it later
                break;
            }
        }

        pA->bind.BindContext = pBindParams->BindContext;
        pA->bind.IpConfigHandle = pBindParams->IpConfigHandle;

        RmInitializeLock(
            &pA->Lock,
            LOCKLEVEL_ADAPTER
            );

        RmInitializeHeader(
            pParentObject,
            &pA->Hdr,
            MTAG_ADAPTER,
            &pA->Lock,
            &ArpGlobals_AdapterStaticInfo,
            NULL,
            psr
            );

        if (pBindParams->BindContext == NULL)
        {
            TR_WARN(("pAdapter 0x%p created in BRIDGE mode!\n", pA));
            ARP_ENABLE_BRIDGE(pA);
        }

    }
    while(FALSE);

    if (FAIL(Status))
    {
        if (pA != NULL)
        {
            arpAdapterDelete ((PRM_OBJECT_HEADER) pA, psr);
            pA = NULL;
        }
    }

    EXIT()
    return (PRM_OBJECT_HEADER) pA;
}


NDIS_STATUS
arpTryReconfigureIf(
    PARP1394_INTERFACE pIF,             // NOLOCKIN NOLOCKOUT
    PNET_PNP_EVENT pNetPnPEvent,        // OPTIONAL
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Try to start reconfiguration of the specified IF.

    Some special cases:
    - If the IF is currently being shutdown, we will synchronously succeed. Why?
      Because we don't need to do anything more and it's not an error condition.
    - If the IF is currently being started, we (asychronously) wait until
      the starting is complete, then shut it down and restart it.
    - If the IF is currently UP, we shut it down and restart it.

Arguments:

    pIF             - The interface to be shutdown/restarted. 
    pNetPnPEvent    - OPTIONAL Ndis pnp event to be completed when the
                      reconfiguration operation is over. This is optional because
                      this function can also be called from elsewhere, in particular,
                      from the ioctl admin utility.

Return Value:

    NDIS_STATUS_SUCCESS -- on synchronous success.
    NDIS_STATUS_FAILURE -- on synchronous failure.
    NDIS_STATUS_PENDING -- if completion is going to happen asynchronously.

--*/
{
    NDIS_STATUS Status;
    PRM_TASK    pTask;
    ENTER("arpTryReconfigureIf", 0x65a0bb61)
    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        if (CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_DEINITING)
            || CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_DEINITED))
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        LOCKOBJ(pIF, pSR);
    
        UNLOCKOBJ(pIF, pSR);
    
        Status = arpAllocateTask(
                    &pIF->Hdr,                  // pParentObject,
                    arpTaskReinitInterface, // pfnHandler,
                    0,                          // Timeout,
                    "Task: DeactivateInterface(reconfig)",// szDescription
                    &pTask,
                    pSR
                    );
    
        if (FAIL(Status))
        {
            OBJLOG0(pIF, ("Couldn't alloc reinit IF task!\n"));
        }
        else
        {
            // Save away pNetPnPEvent in the task structure and start the task.
            //
            PTASK_REINIT_IF pReinitTask =  (PTASK_REINIT_IF) pTask;
            ASSERT(sizeof(*pReinitTask)<=sizeof(ARP1394_TASK));
            pReinitTask->pNetPnPEvent = pNetPnPEvent;

            (void)RmStartTask(pTask, 0, pSR);
            Status = NDIS_STATUS_PENDING;
        }

    } while (FALSE);

    EXIT()
    return Status;
}


NDIS_STATUS
arpPrepareAndSendNdisRequest(
    IN  PARP1394_ADAPTER            pAdapter,
    IN  PARP_NDIS_REQUEST           pArpNdisRequest,
    IN  PRM_TASK                    pTask,              // OPTIONAL
    IN  UINT                        PendCode,
    IN  NDIS_OID                    Oid,
    IN  PVOID                       pBuffer,
    IN  ULONG                       BufferLength,
    IN  NDIS_REQUEST_TYPE           RequestType,
    IN  PRM_STACK_RECORD            pSR
)
/*++

Routine Description:

    Send an NDIS Request to query an adapter for information.
    If the request pends, block on the ATMARP Adapter structure
    till it completes.

Arguments:

    pAdapter                - Points to ATMARP Adapter structure
    pNdisRequest            - Pointer to UNITIALIZED NDIS request structure
    pTask                   - OPTIONAL Task. If NULL, we block until the operation
                              completes.
    PendCode                - PendCode to suspend pTask
    Oid                     - OID to be passed in the request
    pBuffer                 - place for value(s)
    BufferLength            - length of above

Return Value:

    The NDIS status of the request.

--*/
{
    NDIS_STATUS         Status;
    PNDIS_REQUEST       pNdisRequest = &pArpNdisRequest->Request;

    ARP_ZEROSTRUCT(pArpNdisRequest);

    //
    //  Fill in the NDIS Request structure
    //
    if (RequestType == NdisRequestQueryInformation)
    {
        pNdisRequest->RequestType = NdisRequestQueryInformation;
        pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
        pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
        pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
        pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
        pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
    }
    else
    {
        ASSERT(RequestType == NdisRequestSetInformation);
        pNdisRequest->RequestType = NdisRequestSetInformation;
        pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
        pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
        pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
        pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
        pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = BufferLength;
    }

    if (pTask == NULL)
    {
        // We might potentially wait.
        //
        ASSERT_PASSIVE();

        NdisInitializeEvent(&pArpNdisRequest->Event);
        NdisRequest(
            &Status,
            pAdapter->bind.AdapterHandle,
            pNdisRequest
            );
        if (PEND(Status))
        {
            NdisWaitEvent(&pArpNdisRequest->Event, 0);
            Status = pArpNdisRequest->Status;
        }

    }
    else
    {
        pArpNdisRequest->pTask = pTask;
        RmSuspendTask(pTask, PendCode, pSR);
        NdisRequest(
            &Status,
            pAdapter->bind.AdapterHandle,
            pNdisRequest
            );
        if (!PEND(Status))
        {
            RmUnsuspendTask(pTask, pSR);
        }
    }

    return Status;
}


ENetAddr 
arpGetSecondaryMacAddress (
    IN ENetAddr  EthernetMacAddress
    )
/*++

    When we are in the bridge mode, we pretend that there is 
    only one other Ethernet Card out there on the net. Therefore
    only one Ethernet Address needs to be generated.

    For now we simply add one to the Local Adapter's Ethernet 
    address and generate it
 
--*/
{
    ENetAddr NewAddress = EthernetMacAddress; // copy

    //
    // randomize the returned Mac Address
    // by xor ing the address with a random 
    // 0x0d3070b17715 (a random number)
    //
    NewAddress.addr[0] ^= 0x00;
    NewAddress.addr[1] ^= 0x2f;
    NewAddress.addr[2] ^= 0x61;
    NewAddress.addr[3] ^= 0x7c;
    NewAddress.addr[4] ^= 0x91;
    NewAddress.addr[5] ^= 0x30;
    

    // Set the locally administered bit 
    // and clear the multicast bit.

    NewAddress.addr[0] &= 0x20;

    
    return NewAddress;

}


NDIS_STATUS
arpGetEuidTopology (
    IN PARP1394_ADAPTER pAdapter,
    IN PRM_STACK_RECORD pSR
    )
/*++

	Queues A workitem to get the EuidTopology
 
--*/
{
    ENTER ("arpGetEuidTopology ",0x97a0abcb)
    PARP1394_WORK_ITEM pWorkItem = NULL;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fQueueWorkItem = FALSE;


    do
    {
        if (pAdapter->fQueryAddress == TRUE)
        {
            break;
        }


        LOCKOBJ (pAdapter, pSR);
        
        if (pAdapter->fQueryAddress == FALSE)
        {
            pAdapter->fQueryAddress = TRUE; 
            fQueueWorkItem  = TRUE;
        }
        else
        {
            fQueueWorkItem  = FALSE;
        }
        
        UNLOCKOBJ(pAdapter, pSR);

        if (fQueueWorkItem == FALSE)
        {
            break;
        }
        
        Status   = ARP_ALLOCSTRUCT(pWorkItem, MTAG_ARP_GENERIC); 

        if (Status != NDIS_STATUS_SUCCESS || pWorkItem == NULL)
        {
            pWorkItem = NULL;
            break;
        }

        arpQueueWorkItem (pWorkItem,
                            arpGetEuidTopologyWorkItem,
                            &pAdapter->Hdr,
                            pSR);

    } while (FALSE); 


    EXIT()
    return Status;

}


VOID
arpQueueWorkItem (
    PARP1394_WORK_ITEM pWorkItem,
    ARP_WORK_ITEM_PROC pFunc,
    PRM_OBJECT_HEADER pHdr,
    PRM_STACK_RECORD pSR
    )
/*++

    Sends a request to get the bus topology . Only used in bridge mode
    For now only Adapter's are passed in as pHdr

--*/
{
    ENTER("arpQueueWorkItem",0xa1de6752)
    PNDIS_WORK_ITEM         pNdisWorkItem = &pWorkItem->u.NdisWorkItem;
    PARP1394_ADAPTER        pAdapter = (PARP1394_ADAPTER)pHdr;
    BOOLEAN                 fStartWorkItem = FALSE;

    LOCKOBJ(pAdapter, pSR);
    
    if (CHECK_AD_PRIMARY_STATE(pAdapter, ARPAD_PS_INITED ) == TRUE)
    {

        
        #if RM_EXTRA_CHECKING

            RM_DECLARE_STACK_RECORD(sr)

            RmLinkToExternalEx(
                pHdr,                            // pHdr
                0x5a2fd7ca,                             // LUID
                (UINT_PTR)pWorkItem,                    // External entity
                ARPASSOC_WORK_ITEM,           // AssocID
                "		Outstanding WorkItem",
                &sr
                );

        #else   // !RM_EXTRA_CHECKING

            RmLinkToExternalFast(pHdr);

        #endif // !RM_EXTRA_CHECKING

        fStartWorkItem  = TRUE;
        
    }

    UNLOCKOBJ(pAdapter, pSR);

    if (fStartWorkItem == TRUE)
    {
        NdisInitializeWorkItem ( pNdisWorkItem ,arpGenericWorkItem, pHdr);

        pWorkItem->pFunc = pFunc;

        NdisScheduleWorkItem(pNdisWorkItem );
    }

    EXIT()
}

VOID    
arpGenericWorkItem(
    struct _NDIS_WORK_ITEM * pWorkItem, 
    PVOID pContext
    )
/*++

    Generic workitem finction. Takes care of the reference on the pObj
     
--*/
{
    PARP1394_WORK_ITEM pArpWorkItem = (ARP1394_WORK_ITEM*)pWorkItem;
    PRM_OBJECT_HEADER pObj = (PRM_OBJECT_HEADER)pContext;
    RM_DECLARE_STACK_RECORD(sr)

    pArpWorkItem->pFunc (pArpWorkItem, pObj, &sr);

#if RM_EXTRA_CHECKING
    {

        RmUnlinkFromExternalEx(pObj,
                                0x548c9d54,
                                (UINT_PTR)pWorkItem,
                                ARPASSOC_WORK_ITEM,
                                &sr
                                );
    }
#else

    RmUnlinkFromExternalFast(pObj);

#endif

}


NDIS_STATUS
arpGetEuidTopologyWorkItem(
    struct _ARP1394_WORK_ITEM* pWorkItem, 
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD pSR
    )
    
/*++

    workitem to get the topology of the bus .. The WorkItem structure can be null;

--*/
{
    PARP1394_ADAPTER    pAdapter = (PARP1394_ADAPTER)pObj;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    ARP_NDIS_REQUEST    ArpRequest;
    EUID_TOPOLOGY       EuidTopology;
    

    //
    // Return if the adapter is not active
    //
    if (CHECK_AD_PRIMARY_STATE(pAdapter, ARPAD_PS_DEINITING ) ==TRUE)
    {
        ASSERT (CHECK_AD_PRIMARY_STATE(pAdapter, ARPAD_PS_DEINITING ) ==FALSE);
        return NDIS_STATUS_FAILURE; // early return
    }

    //
    // Initialize the structures
    // 
    ARP_ZEROSTRUCT(&ArpRequest);
    ARP_ZEROSTRUCT(&EuidTopology);

    
    //Send the request down
    //
    Status  = \
        arpPrepareAndSendNdisRequest(pAdapter, 
                                    &ArpRequest,  
                                    NULL, //IN PRM_TASK pTask, 
                                    0,   //IN UINT PendCode, 
                                    OID_1394_QUERY_EUID_NODE_MAP,
                                    &EuidTopology,
                                    sizeof (EuidTopology),
                                    NdisRequestQueryInformation ,
                                    pSR
                                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        NdisMoveMemory (&pAdapter->EuidMap, &EuidTopology, sizeof (pAdapter->EuidMap));
    }

    pAdapter->fQueryAddress = FALSE; 

    return Status;
}


VOID
arpNdProcessBusReset(
    IN   PARP1394_ADAPTER pAdapter
    )
/*++

    If the adapter is in the Bridge mode, it will query the 
    adapter for the bus topology	 

--*/
{
    ENTER("arpNdProcessBusReset ",0x48e7659a)
    BOOLEAN BridgeEnabled = ARP_BRIDGE_ENABLED(pAdapter);
    RM_DECLARE_STACK_RECORD(SR)

    if (BridgeEnabled == TRUE)
    {
        arpGetEuidTopology (pAdapter, &SR);
    }


    EXIT()
}


VOID
arpRemoveBackupTasks (
    IN ARP1394_GLOBALS* pGlobals,
    UINT Num
     )
/*++

Removes Num tasks to be used as a backup. However, the number is only a 
approximate value as the back up tasks could be in use

--*/
{
    PSLIST_HEADER pListHead = &pGlobals->BackupTasks;
    PNDIS_SPIN_LOCK  pLock = &pGlobals->BackupTaskLock; 

    UINT i=0;

    for (i = 0;i <Num;i++)
    {
        PSINGLE_LIST_ENTRY pEntry;
        pEntry = NdisInterlockedPopEntrySList(pListHead, pLock );
        
        if (pEntry != NULL)
        {
            TASK_BACKUP* pTask;
            ARP1394_TASK *pATask;

            pTask = CONTAINING_RECORD (pEntry, TASK_BACKUP,  List);

            pATask = (ARP1394_TASK*)pTask;

            ARP_FREE (pATask);
            
            pGlobals->NumTasks --;
        }

        
    }  
    
}


VOID
arpAddBackupTasks (
    IN ARP1394_GLOBALS* pGlobals,
    UINT Num
    )
/*++

Adds Num tasks to be used as a backup.
We are modifying pGlobals without holding the lock

--*/
{
    PSLIST_HEADER pListHead = &pGlobals->BackupTasks;
    PNDIS_SPIN_LOCK  pLock = &pGlobals->BackupTaskLock; 

    UINT i=0;
    
    for (i = 0;i <Num;i++)
    {
        ARP1394_TASK *pATask=NULL;
        
        ARP_ALLOCSTRUCT(pATask, MTAG_TASK); // TODO use lookaside lists.


        if (pATask != NULL)
        {
            NdisInterlockedPushEntrySList(pListHead,&pATask->Backup.List, pLock);
            pGlobals->NumTasks ++;
        }
    }



}


VOID
arpAllocateBackupTasks (
    ARP1394_GLOBALS*                pGlobals 
    )
/*++

    Allocates 4 Tasks to be used as a backup in lowmem conditions

--*/

{
    PSLIST_HEADER pListHead = &pGlobals->BackupTasks;
    PNDIS_SPIN_LOCK  pLock = &pGlobals->BackupTaskLock; 
    
    NdisInitializeSListHead (pListHead);
    NdisAllocateSpinLock(pLock);

    arpAddBackupTasks (pGlobals, 4);

}    


VOID
arpFreeBackupTasks (
    ARP1394_GLOBALS*                pGlobals 
    )

/*++

    Free all the backup tasks hanging off the adapter object

    Since this is only called from the Unload handler, the code 
    presumes that all tasks are complete

    We are modifying pGlobals without holding a lock

--*/

{
    PSLIST_HEADER pListHead = &pGlobals->BackupTasks;
    PNDIS_SPIN_LOCK pLock = &pGlobals->BackupTaskLock; 

    PSINGLE_LIST_ENTRY pEntry = NULL; 

    
    do 
    {
       
        pEntry = NdisInterlockedPopEntrySList(pListHead, pLock );
        
        if (pEntry != NULL)
        {
            TASK_BACKUP* pTask;
            ARP1394_TASK *pATask;

            pTask = CONTAINING_RECORD (pEntry, TASK_BACKUP,  List);

            pATask = (ARP1394_TASK*)pTask;

            ARP_FREE (pATask);
            
            pGlobals->NumTasks --;
        }

    }  while (pEntry != NULL);

    
    ASSERT (pGlobals->NumTasks == 0);
        
}


ARP1394_TASK *
arpGetBackupTask (
    ARP1394_GLOBALS*                pGlobals 
    )
/*++

    Removes a task from the Back up task list and returns it
    
--*/
    
{
    PSLIST_HEADER pListHead = &pGlobals->BackupTasks;
    PNDIS_SPIN_LOCK pLock = &pGlobals->BackupTaskLock; 
    PSINGLE_LIST_ENTRY pEntry = NULL; 
    TASK_BACKUP* pTask = NULL;

    pEntry = NdisInterlockedPopEntrySList(pListHead, pLock);

    if (pEntry != NULL)
    {
        pTask = CONTAINING_RECORD (pEntry, TASK_BACKUP,  List);

        NdisZeroMemory ( pTask, sizeof (ARP1394_TASK));
        
        MARK_TASK_AS_BACKUP(&pTask->Hdr);
    }

    return  (ARP1394_TASK*)pTask;       


}




VOID
arpReturnBackupTask (
    IN ARP1394_TASK* pTask
    )
//
// We can always return the task to the Slist because we are gauranteed that it 
// will be present until all the interfaces are unloaded.
//
{

    // re-insert the task
    PSLIST_HEADER pListHead = &ArpGlobals.BackupTasks;
    PNDIS_SPIN_LOCK pLock = &ArpGlobals.BackupTaskLock; 
    PTASK_BACKUP pBkTask = (PTASK_BACKUP ) pTask;

    NdisInterlockedPushEntrySList(pListHead, &pBkTask->List, pLock);
    

}



NDIS_STATUS
arpTaskCloseCallLowPower(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    This function will close all the open VCs. 
    This will allow the 1394 miniport to power down without any problem

    It will also have to close the Address Families. 

    This function will also have to return synchronously. 

--*/
{
    ENTER("arpTaskLowPower", 0x922f875b)

    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    PARPCB_DEST         pDest = (ARPCB_DEST*)RM_PARENT_OBJECT(pTask);
    TASK_SET_POWER_CALL *pCloseCallTask =  (TASK_SET_POWER_CALL *) pTask;

    enum
    {
        PEND_CleanupVcComplete,
    };
    switch(Code)
    {
        case RM_TASKOP_START:
        {
            
            LOCKOBJ(pDest,pSR);
            if (arpNeedToCleanupDestVc(pDest))
            {
                PRM_TASK pCleanupCallTask = pDest->VcHdr.pCleanupCallTask;

                // If there is already an official cleanup-vc task, we pend on it.
                // Other wise we allocate our own, pend on it, and start it.
                //
                if (pCleanupCallTask != NULL)
                {
                    TR_WARN((
                        "Cleanup-vc task %p exists; pending on it.\n",
                         pCleanupCallTask));
                    RmTmpReferenceObject(&pCleanupCallTask->Hdr, pSR);
    
                    UNLOCKOBJ(pDest, pSR);
                    RmPendTaskOnOtherTask(
                        pTask,
                        PEND_CleanupVcComplete,
                        pCleanupCallTask,
                        pSR
                        );

                    RmTmpDereferenceObject(&pCleanupCallTask->Hdr, pSR);
                    Status = NDIS_STATUS_PENDING;
                    break;
                }
                else
                {
                    //
                    // Start the call cleanup task and pend on int.
                    //

                    UNLOCKOBJ(pDest, pSR);
                    RM_ASSERT_NOLOCKS(pSR);

                    Status = arpAllocateTask(
                                &pDest->Hdr,                // pParentObject,
                                arpTaskCleanupCallToDest,   // pfnHandler,
                                0,                          // Timeout,
                                "Task: CleanupCall on UnloadDest",  // szDescription
                                &pCleanupCallTask,
                                pSR
                                );
                
                    if (FAIL(Status))
                    {
                        TR_WARN(("FATAL: couldn't alloc cleanup call task!\n"));
                    }
                    else
                    {
                        RmPendTaskOnOtherTask(
                            pTask,
                            PEND_CleanupVcComplete,
                            pCleanupCallTask,               // task to pend on
                            pSR
                            );
                
                        // RmStartTask uses up the tmpref on the task
                        // which was added by arpAllocateTask.
                        //
                        Status = RmStartTask(
                                    pCleanupCallTask,
                                    0, // UserParam (unused)
                                    pSR
                                    );
                    }
                    break;
                }
            }

            //
            // We're here because there is no async unload work to be done.
            // We simply return and finish synchronous cleanup in the END
            // handler for this task.
            //
            Status = NDIS_STATUS_SUCCESS;
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case PEND_CleanupVcComplete:
                {
                    //
                    // There was vc-cleanup to be done, but how it's
                    // complete. We should be able to synchronously clean up
                    // this task now
                    //

                #if DBG
                    LOCKOBJ(pDest, pSR);

                    ASSERTEX(!arpNeedToCleanupDestVc(pDest), pDest);

                    UNLOCKOBJ(pDest, pSR);
                #endif DBG

                    Status      = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;


            }
        }
        break;

        case RM_TASKOP_END:
        {
            ULONG DestRemaining;
            PCALL_COUNT  pCount = pCloseCallTask->pCount;

            ASSERT (pCount != NULL);
            
            if (SetLowPower == pCloseCallTask->Cause )
            {
                DestRemaining = NdisInterlockedDecrement (&pCount->DestCount);
            
                if ( 0 == DestRemaining )
                {
                    NdisSetEvent (&pCount ->VcEvent);    
                }
            }            
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()


    return Status;

}







INT
arpCloseAllVcOnDest(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
/*++


--*/
{
    ENTER ("arpCloseAllVcOnDest", 0xf19a83d5)

    PARPCB_DEST             pDest = (PARPCB_DEST) pHdr;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    PTASK_SET_POWER_CALL    pTask = NULL;
    PCALL_COUNT             pCloseCall = (PCALL_COUNT) pvContext;

    
    do
    {
        NdisInterlockedIncrement(&pCloseCall->DestCount);
        
        Status = arpAllocateTask(
                    &pDest->Hdr,                  // pParentObject,
                    arpTaskCloseCallLowPower, // pfnHandler,
                    0,                          // Timeout,
                    "Task: Set Power Cleanup VC", // szDescrip.
                    &(PRM_TASK)pTask,
                    pSR
                    );

        if (Status != NDIS_STATUS_SUCCESS || pTask == NULL)
        {
            pTask = NULL;              
            break;
        }

        pTask->Cause = SetLowPower;

        pTask->pCount = pCloseCall;

        
        RmStartTask((PRM_TASK)pTask, 0,pSR);
                    
    
    } while (FALSE);    

    if (Status != NDIS_STATUS_SUCCESS)
    {
        ULONG DestRemaining;
        
        DestRemaining = NdisInterlockedDecrement (&pCloseCall->DestCount);
        
        if ( 0 == DestRemaining )
        {
            NdisSetEvent (&pCloseCall->VcEvent);    
        }
            
    }

    return TRUE; // continue to enumerate
}


VOID
arpLowPowerCloseAllCalls (
    ARP1394_INTERFACE *pIF,
    PRM_STACK_RECORD pSR
    )
{

    CALL_COUNT CloseCallCount;

    //
    // The Dest Count will be used to make sure that this thread waits for 
    // all the Close Calls to complete.
    //
    NdisInitializeEvent (&CloseCallCount.VcEvent);
    CloseCallCount.DestCount= 0;

    //
    // First we go through all the Dests and close calls on them
    //
    RmWeakEnumerateObjectsInGroup(&pIF->DestinationGroup,
                                  arpCloseAllVcOnDest,
                                  &CloseCallCount,
                                  pSR);

    if (CloseCallCount.DestCount != 0)
    {
        NdisWaitEvent (&CloseCallCount.VcEvent, 0);
    }
    return;

}



NDIS_STATUS
arpTaskCloseVcAndAF (
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    This task does the work that is common between SetLowPower and and 
    the Resume failure case

    As its name suggests, it simply closes all the VCs and Af.

    Its parent task is either a shutdown task or a Set Power task. 
    As the 2 parents of this task are serialized w.r.t each other, 
    there is no need for any serialization within this task.


Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused
--*/
{

    ENTER("arpTaskCloseVcAndAF ", 0xc7c9ad6b)

    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER*    pAdapter = (ARP1394_ADAPTER*)RM_PARENT_OBJECT(pTask);
    TASK_POWER        * pTaskPower =  (TASK_POWER*) pTask;
    ARP1394_INTERFACE * pIF = pAdapter->pIF;
    ULONG               Stage;

    enum
    {
        STAGE_Start,            
        STAGE_StopMaintenanceTask,
        STAGE_CleanupVcComplete,
        STAGE_CloseDestinationGroup,
        STAGE_SwitchedToPassive,
        STAGE_CloseAF,
        STAGE_End
    };
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_Start;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    switch(Stage)
    {
        case STAGE_Start:
        {

            //
            // Stop the IF maintenance task if it's running.
            //
            Status =  arpTryStopIfMaintenanceTask(
                            pIF,
                            pTask,
                            STAGE_StopMaintenanceTask,
                            pSR
                            );

            if (PEND(Status)) break;

        }
        // FALL THROUGH 
        
        case STAGE_StopMaintenanceTask:
        {
            LOCKOBJ(pIF, pSR);

            TIMESTAMP("===CloseVC and AF:MaintenanceTask stopped");
            // Unlink the explicit reference of the broadcast channel destination
            // from the interface.
            //
            if (pIF->pBroadcastDest != NULL)
            {
                PARPCB_DEST pBroadcastDest = pIF->pBroadcastDest;
                pIF->pBroadcastDest = NULL;
    
                // NOTE: We're unlinking the two with the IF lock (which is
                // is the same as the pBroadcastDest's lock) held.
                // This is OK to do.
                //
    
            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pIF->Hdr,
                    &pBroadcastDest->Hdr,
                    0x66bda49b,
                    ARPASSOC_LINK_IF_OF_BCDEST,
                    ARPASSOC_LINK_BCDEST_OF_IF,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pIF->Hdr, &pBroadcastDest->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING
    
            }

            //
            // If the VC state needs cleaning up, we need to get a task
            // going to clean it up. Other wise we fake the completion of this
            // stage so that we move on to the next...
            //
            if (pIF->recvinfo.VcHdr.NdisVcHandle == NULL)
            {
                UNLOCKOBJ(pIF, pSR);
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                PRM_TASK pCleanupCallTask = pIF->recvinfo.VcHdr.pCleanupCallTask;


                // If there is already an official cleanup-vc task, we pend on it.
                // Other wise we allocate our own, pend on it, and start it.
                //
                if (pCleanupCallTask != NULL)
                {
                    TR_WARN((
                        "IF %p Cleanup-vc task %p exists; pending on it.\n",
                         pIF,
                         pCleanupCallTask));
                    RmTmpReferenceObject(&pCleanupCallTask->Hdr, pSR);
    
                    UNLOCKOBJ(pIF, pSR);
                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_CleanupVcComplete,
                        pCleanupCallTask,
                        pSR
                        );

                    RmTmpDereferenceObject(&pCleanupCallTask->Hdr, pSR);
                    Status = NDIS_STATUS_PENDING;
                }
                else
                {
                    //
                    // Start the call cleanup task and pend on int.
                    //
                    UNLOCKOBJ(pIF, pSR);

                    Status = arpAllocateTask(
                                &pIF->Hdr,                  // pParentObject,
                                arpTaskCleanupRecvFifoCall, // pfnHandler,
                                0,                          // Timeout,
                                "Task: CleanupRecvFifo on Set LowPower ", // szDescrip.
                                &pCleanupCallTask,
                                pSR
                                );
                

                    if (FAIL(Status))
                    {
                        // Couldn't allocate task.
                        //
                        TR_WARN(("FATAL: couldn't alloc cleanup call task!\n"));
                    }
                    else
                    {
                        Status = RmPendTaskOnOtherTask(
                                    pTask,
                                    STAGE_CleanupVcComplete,
                                    pCleanupCallTask,
                                    pSR
                                    );
                        ASSERT(!FAIL(Status));
                
                        // RmStartTask uses up the tmpref on the task
                        // which was added by arpAllocateTask.
                        //
                        Status = RmStartTask(
                                    pCleanupCallTask,
                                    0, // UserParam (unused)
                                    pSR
                                    );
                        // We rely on pending status to decide whether
                        // or not to fall through to the next stage.
                        //
                        Status = NDIS_STATUS_PENDING;
                    }
                }
            }
        }

        if (PEND(Status)) break;

        // FALL THROUGH 

        case STAGE_CleanupVcComplete:
        {
            TIMESTAMP("===Set LowPower:RecvFifo cleanup complete");
            // Initiate unload of all the items in the DestinationGroup.
            //
            // If we are going to low power state, then close all the VC's 
            // on these Destinations
            //
            
            arpLowPowerCloseAllCalls (pIF, pSR);

            //
            // Unlink the special "destination VCs". This is executed on both 
            // Low power and unbind.
            //
            LOCKOBJ(pIF, pSR);

            TIMESTAMP("===Set LowPower:Destination objects cleaned up.");
            if (pIF->pMultiChannelDest != NULL)
            {
                PARPCB_DEST pMultiChannelDest = pIF->pMultiChannelDest;
                pIF->pMultiChannelDest = NULL;
    
                // NOTE: We're unlinking the two with the IF lock (which is
                // is the same as the pBroadcastDest's lock) held.
                // This is OK to do.
                //
    
            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pIF->Hdr,
                    &pMultiChannelDest->Hdr,
                    0xf28090bd,
                    ARPASSOC_LINK_IF_OF_MCDEST,
                    ARPASSOC_LINK_MCDEST_OF_IF,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pIF->Hdr, &pMultiChannelDest->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING
    
            }

            if (pIF->pEthernetDest != NULL)
            {
                PARPCB_DEST pEthernetDest = pIF->pEthernetDest;
                pIF->pEthernetDest = NULL;
    
                // NOTE: We're unlinking the two with the IF lock (which is
                // is the same as the pBroadcastDest's lock) held.
                // This is OK to do.
                //
    
            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pIF->Hdr,
                    &pEthernetDest->Hdr,
                    0xf8eedcd1,
                    ARPASSOC_LINK_IF_OF_ETHDEST,
                    ARPASSOC_LINK_ETHDEST_OF_IF,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pIF->Hdr, &pEthernetDest->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING
    
            }

            UNLOCKOBJ(pIF, pSR);

            // If required, switch to passive. This check should obviously be done
            // without any locks held!
            if (!ARP_ATPASSIVE())
            {
                // We're not at passive level, but we need to be.. 
                // . So we switch to passive...
                //
                RmSuspendTask(pTask, STAGE_SwitchedToPassive, pSR);
                RmResumeTaskAsync(pTask, 0, &pTaskPower->WorkItem, pSR);
                Status = NDIS_STATUS_PENDING;
            }
            else
            {
                Status = NDIS_STATUS_SUCCESS;
            }
        }

        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_SwitchedToPassive:
        {
            NDIS_HANDLE NdisAfHandle;

            // We're now switched to passive
            //
            ASSERT(ARP_ATPASSIVE());

            //
            // We're done with all VCs, etc. Time to close the AF, if it's open.
            //

            LOCKOBJ(pTask, pSR);
            NdisAfHandle = pIF->ndis.AfHandle;
            pIF->ndis.AfHandle = NULL;
            pAdapter->PoMgmt.bReceivedAf = FALSE;
            UNLOCKOBJ(pTask, pSR);
    
            if (NdisAfHandle == NULL)
            {
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                //
                // (Debug) Delete the association we added when the
                // address family was opened.
                //
                DBG_DELASSOC(
                    &pIF->Hdr,                  // pObject
                    NdisAfHandle,               // Instance1
                    NULL,                       // Instance2
                    ARPASSOC_IF_OPENAF,         // AssociationID
                    pSR
                    );

                //
                // Suspend task and call NdisCloseAdapter...
                //
                pIF->PoMgmt.pAfPendingTask = pTask;
                RmSuspendTask(pTask, STAGE_CloseAF, pSR);
                RM_ASSERT_NOLOCKS(pSR);
                TIMESTAMP("===DeinitIF: Calling NdisClCloseAddressFamily");
                Status = NdisClCloseAddressFamily(
                            NdisAfHandle
                            );
        
                if (Status != NDIS_STATUS_PENDING)
                {
                    ArpCoCloseAfComplete(
                            Status,
                            (NDIS_HANDLE)pIF
                            );
                    Status = NDIS_STATUS_PENDING;
                }
            }
        }
        
        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_CloseAF:
        {

            //
            // The close AF operation is complete.
            // We've not got anything else to do.
            //
            TIMESTAMP("===Set Low Power: Done with CloseAF");

            // Recover the last status ...
            //
            pIF->PoMgmt.pAfPendingTask =NULL;
            
            Status = (NDIS_STATUS) UserParam;

            // Status of the completed operation can't itself be pending!
            //
            ASSERT(Status != NDIS_STATUS_PENDING);

            //
            // By returning Status != pending, we implicitly complete
            // this task.
            //
        }
        break;

        case STAGE_End:
        {
  
            TIMESTAMP("===Set Low Power done: All done!");

            // Force status to be success as a transition to LowPower
            // cannot fail
            //
            Status = NDIS_STATUS_SUCCESS;
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Stage)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()


    return Status;


}

NDIS_STATUS
arpTaskLowPower(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    Task handler responsible for setting an adapter to low power state 
    (but leaving it allocated and linked to the adapter).

    This task will close all the VCs, AF. However it will leave the Interface 
    registered with IP and will not delete either the RemoteIP or DEST structures.

    This task is a primary Interface task. This task is serialized with the Bind
    , Unbind tasks
    
Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused
--*/
{
    NDIS_STATUS         Status;
    PARP1394_INTERFACE  pIF;
    PTASK_POWER         pTaskPower;
    UINT                Stage;
    PARP1394_ADAPTER    pAdapter;
    enum
    {
        STAGE_Start,
        STAGE_BecomePrimaryTask,
        STAGE_ExistingPrimaryTaskComplete,
        STAGE_CleanupVcAfComplete,
        STAGE_End
    };
    ENTER("arpTaskLowPower", 0x1a34699e)

    Status              = NDIS_STATUS_FAILURE;
    pAdapter            = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pTask);
    pIF                 = pAdapter->pIF;
    pTaskPower          = (PTASK_POWER) pTask;


    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_Start;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    switch(Stage)
    {
        case STAGE_Start:
        {

            // There should NOT be another activate/deactivate task running
            // on this interface. We fail the SetPower if we receive it in 
            // while we are activating or deactivating the task
            //
            TIMESTAMP("===Set Power Low Starting");

            if (pIF->pActDeactTask != NULL || 
                (CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_INITED) != TRUE))
            {
                UNLOCKOBJ(pIF, pSR);
                *pTaskPower->pStatus = NDIS_STATUS_NOT_SUPPORTED;
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            
            // FALL THROUGH            
        }
        
        case STAGE_BecomePrimaryTask:
        {
            //
            // Next, we try and set ourselves as the primary Adapter Task.
            // This ensures that bind,unbind, and Set Power Tasks are all serialized.
            //
            LOCKOBJ(pAdapter, pSR);

            if (pAdapter->bind.pPrimaryTask == NULL)
            {   
                ULONG CurrentInitState = GET_AD_PRIMARY_STATE(pAdapter);

                // Do not change the Init state of the Adapter. However, 
                // mark the adapter as transitioning to a low power state
                //
                pTaskPower->PrevState = CurrentInitState;

                arpSetPrimaryAdapterTask(pAdapter, pTask, CurrentInitState, pSR);

                //
                // Set the Power State to Low Power. This will block all 
                // outstanding sends
                //
                SET_POWER_STATE (pAdapter, ARPAD_POWER_LOW_POWER);
        
                UNLOCKOBJ(pAdapter, pSR);
            }
            else
            {
                PRM_TASK pOtherTask =  pAdapter->bind.pPrimaryTask;
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    STAGE_BecomePrimaryTask, // we'll try again...
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

        }        
        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_ExistingPrimaryTaskComplete:
        {
            PRM_TASK pCloseVCAndAfTask = NULL;
            //
            // Stop the IF maintenance task if it's running.
            //

            Status = arpAllocateTask(
                        &pAdapter->Hdr,                  // pParentObject,
                        arpTaskCloseVcAndAF , // pfnHandler,
                        0,                          // Timeout,
                        "Task: Close VC and AF on SetPower", // szDescrip.
                        &pCloseVCAndAfTask ,
                        pSR
                        );
        

            if (FAIL(Status))
            {
                // Couldn't allocate task.
                //
                TR_WARN(("FATAL: couldn't alloc cleanup call task!\n"));
                break;
            }
            else
            {
                Status = RmPendTaskOnOtherTask(
                            pTask,
                            STAGE_CleanupVcAfComplete,
                            pCloseVCAndAfTask,
                            pSR
                            );
                
                ASSERT(!FAIL(Status));
        
                // RmStartTask uses up the tmpref on the task
                // which was added by arpAllocateTask.
                //
                Status = RmStartTask(
                            pCloseVCAndAfTask,
                            0, // UserParam (unused)
                            pSR
                            );

            }
            if (PEND(Status)) break;

        }
        break;
        
        case STAGE_CleanupVcAfComplete:
        {
        
            //
            // The close AF operation is complete.
            // We've not got anything else to do.
            //
            TIMESTAMP("===Set LowPower: Done with CloseAF");

            // Recover the last status ...
            //
            Status = (NDIS_STATUS) UserParam;

            //
            // Status of the completed operation can't itself be pending!
            //
            ASSERT(Status == NDIS_STATUS_SUCCESS);

            //
            // By returning Status != pending, we implicitly complete
            // this task.
            //
        }
        break;

        case STAGE_End:
        {
            //
            // We are done with all async aspects of setting the Low Power state
            // Set the event so that the original Low Power thread can return.
            //
  
            TIMESTAMP("===Set Low Power done: All done!");

            // Recover the last status ...
            //
            Status = (NDIS_STATUS) UserParam;

            *pTaskPower->pStatus  = Status;


            LOCKOBJ (pAdapter, pSR);
            arpClearPrimaryAdapterTask(pAdapter, pTask, pTaskPower->PrevState ,pSR);
            UNLOCKOBJ (pAdapter, pSR);


            NdisSetEvent (&pAdapter->PoMgmt.Complete);
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Stage)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}





NDIS_STATUS
arpMakeCallOnDest(
    IN  PARPCB_REMOTE_IP            pRemoteIp,
    IN  PARPCB_DEST                 pDest,
    IN  PRM_TASK                    pTaskToPend,
    IN  ULONG                       PEND_StageMakeCallComplete,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    This function will do a make call on a particular task.
    It will also pend pTaskToPend on that make call

--*/
{
    ENTER("arpTaskLowPower", 0x922f875b)

    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;


    do
    {
        if (pRemoteIp->pDest != pDest)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        
            
        if (pDest->VcHdr.pMakeCallTask != NULL )
        {
            //
            // There is an existing task. Pend on it.
            //
            PRM_TASK pOtherTask = pDest->VcHdr.pMakeCallTask;

            RM_DBG_ASSERT_LOCKED(&pRemoteIp->Hdr, pSR);
        
            TR_WARN(("MakeCall task %p exists; pending on it.\n", pOtherTask));
            RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
            DBGMARK(0x0c387a9f);
            UNLOCKOBJ(pRemoteIp, pSR);
            RmPendTaskOnOtherTask(
                pTaskToPend,
                PEND_StageMakeCallComplete,
                pOtherTask,
                pSR
                );
            RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
            Status = NDIS_STATUS_PENDING;
        }
        else
        {
            DBGMARK(0xe9f37ba9);

            //
            // There is no pMakeCallTask. If it makes sense to start one, we do...
            // Note that checking ARP_CAN_SEND_ON_DEST strictly-speaking requires
            // at-least a read-lock on the IF send lock. However, we don't need
            // precision here -- as long as we don't miss making a call when we
            // should (which we won't) we are ok.
            //
            if (!ARP_CAN_SEND_ON_DEST(pDest) && pDest->VcHdr.pCleanupCallTask==NULL)
            {
                PRM_TASK pMakeCallTask;

                //
                // Let's start a MakeCall task and pend on it.
                //
                Status = arpAllocateTask(
                            &pDest->Hdr,                    // pParentObject
                            arpTaskMakeCallToDest,      // pfnHandler
                            0,                              // Timeout
                            "Task: SendFifoMakeCall",       // szDescription
                            &pMakeCallTask,
                            pSR
                            );
                if (FAIL(Status))
                {
                    // Couldn't allocate task. We fail with STATUS_RESOURCES
                    //
                    Status = NDIS_STATUS_RESOURCES;
                }
                else
                {
                    UNLOCKOBJ(pRemoteIp, pSR);

                    RmPendTaskOnOtherTask(
                        pTaskToPend,
                        PEND_StageMakeCallComplete,
                        pMakeCallTask,
                        pSR
                        );
                    
                    (VOID)RmStartTask(
                            pMakeCallTask,
                            0, // UserParam (unused)
                            pSR
                            );
                
                    Status = NDIS_STATUS_PENDING;
                }
            }
            else
            {
                // Calls is ready to do. We finish sending off the packets in
                // the END handler.
                //
                Status = NDIS_STATUS_SUCCESS;
            }
        }
        
    } while (FALSE);
    RmUnlockAll(pSR);


    EXIT()
    return Status;

}






NDIS_STATUS
arpTaskStartGenericVCs (
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    This function will close all the open VCs. 
    This will allow the 1394 miniport to power down without any problem

    It will also have to close the Address Families. 

    This function will also have to return synchronously. 

--*/
{
    ENTER("arpTaskStartGenericVCs", 0x75780ca6)

    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER*    pAdapter = (ARP1394_ADAPTER*)RM_PARENT_OBJECT(pTask);
    TASK_POWER        * pTaskPower =  (TASK_POWER*) pTask;
    ARP1394_INTERFACE * pIF = pAdapter->pIF;

    enum
    {
        PEND_OpenAF,
        PEND_SetupBroadcastChannel,
        PEND_SetupReceiveVc,
        PEND_SetupMultiChannel,
        PEND_SetupEthernetVc,
        PEND_StartedVC            
    };

    
    switch(Code)
    {
        case RM_TASKOP_START:
        {
            CO_ADDRESS_FAMILY AddressFamily;
            //
            // This task is inherently serialized as its parent task is serialized.
            //
            LOCKOBJ (pIF, pSR);

            if (pIF->pActDeactTask != NULL)
            {
                // This should never happen, because the Activate task is
                // always started by an active primary task, and at most one primary
                // task is active at any point of time.
                //
                ASSERTEX(!"start: activate/deactivate task exists!", pIF);
                Status = NDIS_STATUS_FAILURE;
                UNLOCKOBJ(pIF, pSR);
                break;
            }

            UNLOCKOBJ (pIF,pSR);

            //
            // Now Open the Address Family.
            //
            
            NdisZeroMemory(&AddressFamily, sizeof(AddressFamily));
    
            AddressFamily.AddressFamily = CO_ADDRESS_FAMILY_1394;
            AddressFamily.MajorVersion = NIC1394_AF_CURRENT_MAJOR_VERSION;
            AddressFamily.MinorVersion = NIC1394_AF_CURRENT_MINOR_VERSION;

            pIF->PoMgmt.pAfPendingTask = pTask;
            RmSuspendTask(pTask, PEND_OpenAF, pSR);
            RM_ASSERT_NOLOCKS(pSR);
    
            TIMESTAMP("===ActivateIF: Calling NdisClOpenAddressFamily");
            Status = NdisClOpenAddressFamily(
                            pIF->ndis.AdapterHandle,
                            &AddressFamily,
                            (NDIS_HANDLE)pIF,
                            &ArpGlobals.ndis.CC,
                            sizeof(ArpGlobals.ndis.CC),
                            &(pIF->ndis.AfHandle)
                            );
            if (Status != NDIS_STATUS_PENDING)
            {
                ArpCoOpenAfComplete(
                        Status,
                        (NDIS_HANDLE)pIF,
                        pIF->ndis.AfHandle
                        );
            }
            Status = NDIS_STATUS_PENDING;
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            
            pTaskPower->LastStage = (RM_PEND_CODE(pTask));
            Status = (NDIS_STATUS) UserParam;

            switch(RM_PEND_CODE(pTask))
            {
                case PEND_OpenAF:
                {
                    PARPCB_DEST pBroadcastDest;

                    pIF->PoMgmt.pAfPendingTask = NULL;

                    if (FAIL(Status))
                    {
                        // 
                        // OpenAF failed...
                        //
                        break;
                    }

                    //
                    // Successfully opened the address family and waited for
                    // connect status.
                    // Now setup the broadcast channel VC.
                    // 
                    //

                    TR_INFO(("Interface: 0x%p, Got NdisAfHandle: 0x%p\n",
                                    pIF, pIF->ndis.AfHandle));
                    //
                    // Let's create a destination object representing the
                    // broadcast channel, and make a call to it.
                    //
                    Status =  arpSetupSpecialDest(
                                pIF,
                                NIC1394AddressType_Channel, // This means bcast channel.
                                pTask,                      // pParentTask
                                PEND_SetupBroadcastChannel, //  PendCode
                                &pBroadcastDest,
                                pSR
                                );
                    // Should either fail or pend -- never return success.
                    //
                    ASSERT(Status != NDIS_STATUS_SUCCESS);

                    if (!PEND(Status))
                    {
                        OBJLOG0( pIF, "FATAL: Couldn't create BC dest entry.\n");
                    }
                }
                break;

                case PEND_SetupBroadcastChannel:
                {
                    PRM_TASK pMakeCallTask;

                    if (FAIL(Status))
                    {
                        // 
                        // Couldn't setup the broadcast channel...
                        //
                        break;
                    }

                    //
                    // Successfully opened the address family.
                    // Now setup the receive FIFO VC.
                    // 
                    //

                    // TR_INFO(("Interface: 0x%p, Got NdisAfHandle: 0x%p\n",
                    //              pIF, pIF->ndis.AfHandle));
    
                    //
                    // Let's start a MakeCall task and pend on it.
                    //
                    Status = arpAllocateTask(
                                &pIF->Hdr,                  // pParentObject
                                arpTaskMakeRecvFifoCall,        // pfnHandler
                                0,                              // Timeout
                                "Task: MakeRecvFifoCall",       // szDescription
                                &pMakeCallTask,
                                pSR
                                );
                    if (FAIL(Status))
                    {
                        // Couldn't allocate task. Let's do a fake completion of
                        // this stage...
                        //
                        RmSuspendTask(pTask, PEND_SetupReceiveVc, pSR);
                        RmResumeTask(pTask, (UINT_PTR) Status, pSR);
                        Status = NDIS_STATUS_PENDING;
                        break;
                    }
                    else
                    {
                        RmPendTaskOnOtherTask(
                            pTask,
                            PEND_SetupReceiveVc,
                            pMakeCallTask,
                            pSR
                            );
        
                        (VOID)RmStartTask(
                                pMakeCallTask,
                                0, // UserParam (unused)
                                pSR
                                );
                    
                        Status = NDIS_STATUS_PENDING;
                    }
                }
                break;

                case PEND_SetupReceiveVc:
                {
                    PARPCB_DEST pMultiChannelDest;

                    if (FAIL(Status))
                    {
                        TR_WARN(("FATAL: COULDN'T SETUP RECEIVE FIFO VC!\n"));
                        break;
                    }
    
                    //
                    // Let's create a destination object representing the
                    // multichannel vc, and make a call to it.
                    //

                    Status =  arpSetupSpecialDest(
                                pIF,
                                NIC1394AddressType_MultiChannel,
                                pTask,                      // pParentTask
                                PEND_SetupMultiChannel, //  PendCode
                                &pMultiChannelDest,
                                pSR
                                );
                    // Should either fail or pend -- never return success.
                    //
                    ASSERT(Status != NDIS_STATUS_SUCCESS);

                    if (!PEND(Status))
                    {
                        OBJLOG0( pIF, "FATAL: Couldn't create BC dest entry.\n");
                    }
                    else
                    {
                        //
                        // On pending, pMultiChannelDest contains a valid
                        // pDest which has been tmpref'd. 
                        // Keep a pointer to the broadcast dest in the IF.
                        // and  link the broadcast dest to the IF.
                        //
                        {
                        #if RM_EXTRA_CHECKING
                            RmLinkObjectsEx(
                                &pIF->Hdr,
                                &pMultiChannelDest->Hdr,
                                0x34639a4c,
                                ARPASSOC_LINK_IF_OF_MCDEST,
                                "    IF of MultiChannel Dest 0x%p (%s)\n",
                                ARPASSOC_LINK_MCDEST_OF_IF,
                                "    MultiChannel Dest of IF 0x%p (%s)\n",
                                pSR
                                );
                        #else // !RM_EXTRA_CHECKING
                            RmLinkObjects(&pIF->Hdr, &pMultiChannelDest->Hdr,pSR);
                        #endif // !RM_EXTRA_CHECKING

                            LOCKOBJ(pIF, pSR);
                            ASSERT(pIF->pMultiChannelDest == NULL);
                            pIF->pMultiChannelDest = pMultiChannelDest;
                            UNLOCKOBJ(pIF, pSR);

                            // arpSetupSpecialDest ref'd pBroadcastDest.
                            //
                            RmTmpDereferenceObject(&pMultiChannelDest->Hdr, pSR);
                        }
                    }
                }
                break;

                case PEND_SetupMultiChannel:
                {
                    PARPCB_DEST pEthernetDest;

                    if (FAIL(Status))
                    {
                        TR_WARN(("COULDN'T SETUP MULTI-CHANNEL VC (IGNORING FAILURE)!\n"));
                        break;
                    }
    
                    //
                    // Let's create a destination object representing the
                    // ethernet, and make a call to it.
                    //
                    Status =  arpSetupSpecialDest(
                                pIF,
                                NIC1394AddressType_Ethernet,
                                pTask,                      // pParentTask
                                PEND_SetupEthernetVc, //  PendCode
                                &pEthernetDest,
                                pSR
                                );

                    // Should either fail or pend -- never return success.
                    //
                    ASSERT(Status != NDIS_STATUS_SUCCESS);

                    if (!PEND(Status))
                    {
                        OBJLOG0( pIF, "FATAL: Couldn't create BC dest entry.\n");
                    }
                    else
                    {
                        //
                        // On pending, pEthernetDest contains a valid
                        // pDest which has been tmpref'd. 
                        // Keep a pointer to the broadcast dest in the IF.
                        // and  link the broadcast dest to the IF.
                        //
                        {
                        #if RM_EXTRA_CHECKING
                            RmLinkObjectsEx(
                                &pIF->Hdr,
                                &pEthernetDest->Hdr,
                                0xcea46d67,
                                ARPASSOC_LINK_IF_OF_ETHDEST,
                                "    IF of Ethernet Dest 0x%p (%s)\n",
                                ARPASSOC_LINK_ETHDEST_OF_IF,
                                "    Ethernet Dest of IF 0x%p (%s)\n",
                                pSR
                                );
                        #else // !RM_EXTRA_CHECKING
                            RmLinkObjects(&pIF->Hdr, &pEthernetDest->Hdr,pSR);
                        #endif // !RM_EXTRA_CHECKING

                            LOCKOBJ(pIF, pSR);
                            ASSERT(pIF->pEthernetDest == NULL);
                            pIF->pEthernetDest = pEthernetDest;
                            UNLOCKOBJ(pIF, pSR);

                            // arpSetupSpecialDest ref'd pBroadcastDest.
                            //
                            RmTmpDereferenceObject(&pEthernetDest->Hdr, pSR);
                        }
                    }
                }
                break;

                case PEND_SetupEthernetVc:
                {

                    if (FAIL(Status))
                    {
                        TR_WARN(("COULDN'T SETUP ETHERNET VC (IGNORING FAILURE)!\n"));
                        break;
                    }
        
                    if (!ARP_ATPASSIVE())
                    {
                        ASSERT(sizeof(TASK_ACTIVATE_IF)<=sizeof(ARP1394_TASK));

                        // We're not at passive level, but we need to be when we
                        // call IP's add interface. So we switch to passive...
                        // NOTE: we specify completion code PEND_SetupReceiveVc
                        //       because we want to get back here (except
                        //       we'll be at passive).
                        //
                        RmSuspendTask(pTask, PEND_SetupEthernetVc, pSR);
                        RmResumeTaskAsync(
                            pTask,
                            Status,
                            &((TASK_ACTIVATE_IF*)pTask)->WorkItem,
                            pSR
                            );
                        Status = NDIS_STATUS_PENDING;
                        break;
                    }
                        
                    ASSERT(Status == NDIS_STATUS_SUCCESS);

                    //
                    // Successfully opened the address family and setup
                    // the recv VC.

                    if (!FAIL(Status))
                    {
                        //
                        // Start the maintenance task on this IF.
                        //
                        arpStartIfMaintenanceTask(pIF, pSR);
                    }
    
                } // end  case PEND_SetupEthernetVc
                break;

    
                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))
        }
        break;

        case RM_TASKOP_END:
        {
            //
            // Recover the last status ...
            //
            Status = (NDIS_STATUS) UserParam;

            //
            // Status of the completed operation can't itself be pending!
            //
            ASSERT(Status != NDIS_STATUS_PENDING);

        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;
    }

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()


    return Status;

}




NDIS_STATUS
arpTaskOnPower (
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    Validates the event and passes it off to the correct function.

    This presumes that the LowPowerTask has already run

    It then waits for that function to finish its work.
    

--*/
{
    ENTER("arpTaskOnPower", 0xccaf09cd)

    NDIS_STATUS         Status  = NDIS_STATUS_SUCCESS;
    ARP1394_ADAPTER*    pAdapter = (ARP1394_ADAPTER*)RM_PARENT_OBJECT(pTask);
    TASK_POWER        * pTaskPower =  (TASK_POWER*) pTask;
    ARP1394_INTERFACE * pIF = pAdapter->pIF;
    ULONG               Stage = 0;

    enum
    {
        STAGE_Start,
        STAGE_BecomePrimaryTask,
        STAGE_ExistingPrimaryTaskComplete,
        STAGE_StartGenericVCs,
        PEND_DeinitIF,
        STAGE_End
    };

    
    pTaskPower          = (PTASK_POWER) pTask;

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_Start;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    switch(Stage)
    {
        case STAGE_Start:
        {

            // There should NOT be another activate/deactivate task running
            // on this interface. We fail the SetPower if we receive it in 
            // while we are activating or deactivating the task
            //
            TIMESTAMP("===Set Power ON Starting");

            LOCKOBJ(pAdapter, pSR);

            if (CHECK_AD_PRIMARY_STATE(pAdapter,ARPAD_PS_INITED) == FALSE)
            {
                break;
            }
            //
            // Now, make this task the primary task on the adapter
            //
            if (pAdapter->bind.pPrimaryTask == NULL)
            {
                // Don't change the Init State of this adapter
                // 
                ULONG CurrentInitState = GET_AD_PRIMARY_STATE(pAdapter);
                arpSetPrimaryAdapterTask(pAdapter, pTask, CurrentInitState , pSR);
                pAdapter->PoMgmt.bResuming = TRUE;
                UNLOCKOBJ(pAdapter, pSR);
            }
            else
            {
                PRM_TASK pOtherTask =  pAdapter->bind.pPrimaryTask;
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    STAGE_BecomePrimaryTask, // we'll try again...
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }



        }        
        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_ExistingPrimaryTaskComplete:
        {
            PRM_TASK pStartGenericVCs = NULL;

            if (pIF->pActDeactTask != NULL)
            {
                // This should never happen, because the Activate task is
                // always started by an active primary task, and at most one primary
                // task is active at any point of time.
                //
                ASSERTEX(!"start: activate/deactivate task exists!", pIF);
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            //
            // Stop the IF maintenance task if it's running.
            //

            Status = arpAllocateTask(
                        &pAdapter->Hdr,                  // pParentObject,
                        arpTaskStartGenericVCs , // pfnHandler,
                        0,                          // Timeout,
                        "Task: arpTaskStartGenericVCs", // szDescrip.
                        &pStartGenericVCs,
                        pSR
                        );
        

            if (FAIL(Status))
            {
                // Couldn't allocate task.
                //
                TR_WARN(("FATAL: couldn't alloc start call task!\n"));
                break;
            }
            else
            {
                Status = RmPendTaskOnOtherTask(
                            pTask,
                            STAGE_StartGenericVCs,
                            pStartGenericVCs,
                            pSR
                            );
                
                ASSERT(!FAIL(Status));
        
                // RmStartTask uses up the tmpref on the task
                // which was added by arpAllocateTask.
                //
                Status = RmStartTask(
                            pStartGenericVCs,
                            0, // UserParam (unused)
                            pSR
                            );

            }
            if (PEND(Status)) break;

        }
        break;
        
        case STAGE_StartGenericVCs:
        {
        
            //
            // The close AF operation is complete.
            // We've not got anything else to do.
            //
            TIMESTAMP("===Set PowerOn: Created VCs");

            // Recover the last status ...
            //
            Status = (NDIS_STATUS) UserParam;

            if (Status != NDIS_STATUS_SUCCESS)
            {
                //
                // Undo all the VCs, AFs and Task that 
                //have been created in arpTaskStartGenericVCs 
                //
                pAdapter->PoMgmt.bFailedResume = TRUE;
                arpDeinitIf(pIF, pTask,PEND_DeinitIF, pSR);
                Status = NDIS_STATUS_PENDING;                
            }
        }
        break;

        case PEND_DeinitIF:
        {
            //
            // Set the Failure state on the adapter object here
            //

            //
            // return Failure, so we can inform NDIS of the failure
            //
            Status = NDIS_STATUS_SUCCESS;
        }
        break;
        case STAGE_End:
        {
            //
            // We are done with all async aspects of setting the Low Power state
            // Set the event so that the original Low Power thread can return.
            //
  
            TIMESTAMP("===Set Power On done: All done!");

            LOCKOBJ (pAdapter, pSR);
            if (Status== NDIS_STATUS_SUCCESS)
            {
                arpClearPrimaryAdapterTask (pAdapter, pTask, ARPAD_PS_INITED,pSR);
            }
            else
            {
                arpClearPrimaryAdapterTask (pAdapter, pTask, ARPAD_PS_FAILEDINIT,pSR);
            }

            SET_POWER_STATE(pAdapter, ARPAD_POWER_NORMAL);;

            UNLOCKOBJ (pAdapter, pSR);

            *pTaskPower->pStatus = Status;

            NdisSetEvent (&pAdapter->PoMgmt.Complete);
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Stage)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}






NDIS_STATUS
arpStandby (
    IN ARP1394_ADAPTER *pAdapter,
    IN NET_DEVICE_POWER_STATE DeviceState,
    IN PRM_STACK_RECORD pSR
    )
/*++

    arpStandby does the work for putting the adapter into standby.

    It synchronously return Success, Failure or Not Supported.

    If the Adapter structure has not inited, then this function returns
    Not supported

--*/
{
    PARP1394_INTERFACE pIF  = pAdapter->pIF;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    PTASK_POWER pSetPowerTask = NULL;
    NDIS_STATUS TaskStatus = NDIS_STATUS_FAILURE;
    
    ENTER ("arpStandby  ", 0x2087f71a)

    do
    {
        //
        // If we have been asked to standby before the Interface has initialized
        // then we return NOT_SUPPORTED. This will cause NDIS to unbind the the ARP 
        // from the miniport . 
        //
        if (pIF == NULL) 
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
        
        if(!CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_INITED)) 
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        
        Status = arpAllocateTask(
                &pAdapter->Hdr,                  // pParentObject
                arpTaskLowPower,        // pfnHandler
                0,                              // Timeout
                "Task: Set Power Low",       // szDescription
                &(PRM_TASK)pSetPowerTask,
                pSR
                );

        if (NDIS_STATUS_SUCCESS != Status || NULL == pSetPowerTask)
        {
            pSetPowerTask = NULL;
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        pSetPowerTask->pStatus = &TaskStatus;
        pSetPowerTask ->PowerState = DeviceState;

        NdisInitializeEvent(&pAdapter->PoMgmt.Complete);

        RmStartTask((PRM_TASK)pSetPowerTask,0,pSR);

        NdisWaitEvent (&pAdapter->PoMgmt.Complete, 0);

        //
        // Set the variable for the wakeup
        //
        pAdapter->PoMgmt.bReceivedSetPowerD0= FALSE;



        Status = NDIS_STATUS_SUCCESS;                
        break;

    } while (FALSE);




    EXIT();
    return Status;        
}




NDIS_STATUS
arpResume (
    IN ARP1394_ADAPTER* pAdapter,
    IN ARP_RESUME_CAUSE Cause,
    IN PRM_STACK_RECORD pSR
)
/*++

    This function manages the starting of the Resume Task. 

    The resume task can only be started once after receiving an AfNotify 
    and a Set Power. 

    However, an Unbind can come in and unbind the adapter in the middle of this.
    
    This function does not start the resume if the adapter is already unbinding    

--*/
{
    BOOLEAN bSetPowerOnTask = FALSE;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PTASK_POWER pSetPowerTask = NULL;
    NDIS_STATUS TaskStatus;
    
    ENTER ("arpResume", 0x3dddc538)
        

    do
    {
        if (CHECK_POWER_STATE(pAdapter, ARPAD_POWER_NORMAL)== TRUE)
        {
            break;
        }

        LOCKOBJ (pAdapter, pSR);

        if (Cause == Cause_SetPowerD0)
        {
            pAdapter->PoMgmt.bReceivedSetPowerD0 = TRUE;
        }
        //
        // If we have already received an Unbind, then don't do anything.
        //
        if ( pAdapter->PoMgmt.bReceivedUnbind == FALSE)
        {
            //
            // If we have not received an unbind,
            // then this thread needs to all the work to 
            // reactivate the arp module.
            //
            bSetPowerOnTask = TRUE;

        }

        UNLOCKOBJ(pAdapter,pSR);

        if (bSetPowerOnTask  == FALSE)
        {
            break;
        }

        //
        // Start the Set Power Task
        //

        Status = arpAllocateTask(
            &pAdapter->Hdr,                  // pParentObject
            arpTaskOnPower,        // pfnHandler
            0,                              // Timeout
            "Task: SetPower On",       // szDescription
            &(PRM_TASK)pSetPowerTask,
            pSR
            );

        if (Status != NDIS_STATUS_SUCCESS || NULL == pSetPowerTask)
        {
            break;
        }

        pSetPowerTask->pStatus = &TaskStatus;

        NdisResetEvent (&pAdapter->PoMgmt.Complete);

        RmStartTask ((PRM_TASK)pSetPowerTask,0,pSR);

        NdisWaitEvent (&pAdapter->PoMgmt.Complete, 0);

        Status = TaskStatus;


    } while (FALSE);



    EXIT()

    return Status;
}



NDIS_STATUS
arpNdSetPower (
    ARP1394_ADAPTER *pAdapter,
    PNET_DEVICE_POWER_STATE   pPowerState,
    PRM_STACK_RECORD pSR
    )
/*++

    Validates the event and passes it off to the correct function

--*/
{
    ENTER("arpNdSetPower ", 0x21c4013a)
    TASK_POWER          *pSetPowerTask = NULL;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    NDIS_STATUS         TaskStatus = NDIS_STATUS_NOT_SUPPORTED;
    
    
    //
    // The bridge is present.Close all the VCs if we are going to
    // a low power or re-create all the VC if we are going to D0
    //
    if (NetDeviceStateD0 == (*pPowerState))
    {
        Status = arpResume(pAdapter, Cause_SetPowerD0, pSR);
    }
    else
    {
        Status = arpStandby(pAdapter, *pPowerState, pSR);
    }
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\pkt.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    pkt.c

Abstract:

    ARP1394 ARP control packet management.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     07-01-99    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_PKT

//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

NDIS_STATUS
arpAllocateControlPacketPool(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    UINT                MaxBufferSize,
    PRM_STACK_RECORD    pSR
    )
/*++
Routine Description:

    Allocate & initialize the packet pool used for allocating control packets.
    Control packets are used for ARP and MCAP. This routine MUST be called
    BEFORE the first call to arpAllocateControlPacket.

Arguments:

    pIF             - The interface in which to allocate the pool. Only one such pool
                      is allocated per interface and it occupies a specific field of
                      pIF.
    MaxBufferSize   - Maximum data size of packets to be allocated using this
                      pool. Attempts to allocate a packet
                      (using arpAllocateControlPacket) with a size larger than
                      MaxBufferSize will fail.

Return Value:

    NDIS_STATUS_SUCCESS on success.
    Ndis error code on failure.
    
--*/
{
    NDIS_STATUS Status;
    NDIS_HANDLE PacketPool=NULL;
    NDIS_HANDLE BufferPool=NULL;
    ENTER("arpAllocateControlPacketPool", 0x71579254)

    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);
    ASSERT(pIF->arp.PacketPool == NULL);
    ASSERT(pIF->arp.BufferPool == NULL);
    ASSERT(pIF->arp.NumOutstandingPackets == 0);

    do
    {
        // Allocate the NDIS Packet Pool
        //
        NdisAllocatePacketPool(
                &Status,
                &PacketPool,
                ARP1394_MAX_PROTOCOL_PKTS,
                sizeof(struct PCCommon)
                );
    
        if (FAIL(Status))
        {
            PacketPool = NULL;
            break;
        }
    
        // Allocate the NDIS Buffer Pool
        //
        NdisAllocateBufferPool(
                &Status,
                &BufferPool,
                ARP1394_MAX_PROTOCOL_PKTS
                );
    
        if (FAIL(Status))
        {
            BufferPool = NULL;
            break;
        }
    
        //
        // We could allocate a lookaside list for the Protocol data, but we
        // choose to use NdisAllocateMemoryWithTag on demand instead. Protocol pkts
        // are not high-frequency things; plus we don't have support for lookaside
        // lists on win98 (although we could easily implement our own for 
        // win98, so that's not really an excuse).
        //
        pIF->arp.MaxBufferSize = MaxBufferSize;
    
        //  (DBG only) Add associations for the packet pool and buffer pool.
        //  These associations must be removed before the interface is deallocated.
        //
        DBG_ADDASSOC(
            &pIF->Hdr,                  // pObject
            PacketPool,                 // Instance1
            NULL,                       // Instance2
            ARPASSOC_IF_PROTOPKTPOOL,   // AssociationID
            "    Proto Packet Pool 0x%p\n",// szFormat
            pSR
            );
        DBG_ADDASSOC(
            &pIF->Hdr,                  // pObject
            BufferPool,                 // Instance1
            NULL,                       // Instance2
            ARPASSOC_IF_PROTOBUFPOOL,   // AssociationID
            "    Proto Buffer Pool 0x%p\n",// szFormat
            pSR
            );

        pIF->arp.PacketPool = PacketPool;
        pIF->arp.BufferPool = BufferPool;
        PacketPool = NULL;
        BufferPool = NULL;

    } while (FALSE);

    if (FAIL(Status))
    {
        if (PacketPool != NULL)
        {
            NdisFreePacketPool(PacketPool);
        }
    
        if (BufferPool != NULL)
        {
            NdisFreeBufferPool(BufferPool);
        }
    }
    else
    {
        ASSERT(PacketPool == NULL && BufferPool == NULL);
    }

    return Status;
}


VOID
arpFreeControlPacketPool(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++
Routine Description:

    Free the previously allocated control packet pool. MUST be called AFTER the last
    call to arpFreeControlPacket. See arpAllocateControlPacketPool for more details.

Arguments:

    pIF     - The interface in which to free the pool.

--*/
{
    NDIS_HANDLE PacketPool;
    NDIS_HANDLE BufferPool;
    ENTER("arpFreeControlPacketPool", 0x3c3acf47)

    // Make sure the IF is locked.
    //
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    // Make sure that there are no outstanding allocated packets.
    //
    ASSERT(pIF->arp.NumOutstandingPackets == 0);

    PacketPool = pIF->arp.PacketPool;
    BufferPool = pIF->arp.BufferPool;
    pIF->arp.PacketPool = NULL;
    pIF->arp.BufferPool = NULL;
    
    // (DBG only) Remove associations for the control and packet pools.
    //
    DBG_DELASSOC(
        &pIF->Hdr,                  // pObject
        PacketPool,                 // Instance1
        NULL,                       // Instance2
        ARPASSOC_IF_PROTOPKTPOOL,   // AssociationID
        pSR
        );
    DBG_DELASSOC(
        &pIF->Hdr,                  // pObject
        BufferPool,                 // Instance1
        NULL,                       // Instance2
        ARPASSOC_IF_PROTOBUFPOOL,   // AssociationID
        pSR
        );

    // Free the buffer and packet pools
    // 
    NdisFreeBufferPool(BufferPool);
    NdisFreePacketPool(PacketPool);
}


NDIS_STATUS
arpAllocateControlPacket(
    IN  PARP1394_INTERFACE  pIF,
    IN  UINT                cbBufferSize,
    IN  UINT                PktFlags,
    OUT PNDIS_PACKET        *ppNdisPacket,
    OUT PVOID               *ppvData,
        PRM_STACK_RECORD    pSR
    )
/*++
Routine Description:

    Allocate a control packet from the interfaces control packet pool. Also
    allocate and chain a SINGLE buffer of size cbBufferSize and return a pointer to
    this buffer in *ppvData.

    NOTE1: The packet and associated buffer MUST be freed
    by a subsequent call to arpFreeControlPacket -- do not free the packet & buffer
    by directly calling ndis apis.

    NOTE2: cbBufferSize must be <= the max-buffer-size specified when
    creating the pool (see arpAllocateControlPacketPool for details).

Arguments:

    pIF             - Interface whose control packet pool to use.
    cbBufferSize    - size of the control packet.
    ppNdisPacket    - Location to set to point to the allocated pkt.
    ppvData         - Location to set to point to the packet data (single buffer).

Return Value:

    NDIS_STATUS_SUCCESS     on success.
    NDIS_STATUS_RESOURCES   if buffers or pkts are currently not available.
    Other ndis error         on other kinds of failures.
--*/
{
    NDIS_STATUS             Status;
    PNDIS_PACKET            pNdisPacket = NULL;
    PNDIS_BUFFER            pNdisBuffer = NULL;
    PVOID                   pvData = NULL;
    ENTER("arpAllocateControlPacket", 0x8ccce6ea)

    //
    // NOTE: we don't care if pIF is locked or not.
    //


    pNdisPacket = NULL;
    pvData      = NULL;

    do
    {

        // Allocate space for the packet data.
        // TODO: here is where we could use a lookaside list instead
        // of NdisAllocateMemoryWithTag.
        //
        {
            if (cbBufferSize > pIF->arp.MaxBufferSize)
            {
                ASSERT(FALSE);
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
            NdisAllocateMemoryWithTag(
                &pvData,
                cbBufferSize,
                MTAG_PKT
                );
            if (pvData == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        }

        // Allocate a buffer.
        //
        NdisAllocateBuffer(
                &Status,
                &pNdisBuffer,
                pIF->arp.BufferPool,
                pvData,
                cbBufferSize
            );

        if (FAIL(Status))
        {
            pNdisBuffer = NULL;
            break;
        }
        
        // Allocate a packet
        //
        NdisAllocatePacket(
                &Status,
                &pNdisPacket,
                pIF->arp.PacketPool
            );
    
        if (FAIL(Status))
        {
            pNdisPacket = NULL;
            break;
        }

        // Identify the packet as belonging to us (ARP).
        //
        {
            struct PacketContext    *PC;
            PC = (struct PacketContext *)pNdisPacket->ProtocolReserved;
            PC->pc_common.pc_owner = PACKET_OWNER_LINK;
            PC->pc_common.pc_flags = (UCHAR)PktFlags; // ARP1394_PACKET_FLAGS_CONTROL;
        }

        // Link the packet and buffer.
        //
        NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

        InterlockedIncrement(&pIF->arp.NumOutstandingPackets);
        *ppNdisPacket   = pNdisPacket;
        *ppvData        = pvData;

        pNdisPacket = NULL;
        pNdisBuffer = NULL;
        pvData      = NULL;

    } while (FALSE);

    if (FAIL(Status))
    {
        if (pNdisPacket != NULL)
        {
            NdisFreePacket(pNdisPacket);
        }
        if (pNdisBuffer != NULL)
        {
            NdisFreeBuffer(pNdisBuffer);
        }
        if (pvData != NULL)
        {
            NdisFreeMemory(pvData, 0, 0);
        }
    }
    else
    {
        ASSERT(pNdisPacket == NULL
                && pNdisBuffer == NULL
                && pvData == NULL);
    }

    return Status;
}

VOID
arpFreeControlPacket(
    PARP1394_INTERFACE  pIF,
    PNDIS_PACKET        pNdisPacket,
    PRM_STACK_RECORD    pSR
    )
/*++
Routine Description:

    Free a packet previously allocated using arpAllocateControlPacket.

Arguments:

    pIF             - Interface whose control packet pool to use.
--*/
{
    PNDIS_BUFFER pNdisBuffer = NULL;
    PVOID        pvData = NULL;

    ENTER("arpFreeControlPacket", 0x01e7fbc7)

    // (DBG only) Verify that this packet belongs to us. 
    //
    #if DBG
    {
        struct PacketContext    *PC;
        PC = (struct PacketContext *)pNdisPacket->ProtocolReserved;
        ASSERT(PC->pc_common.pc_owner == PACKET_OWNER_LINK);
    }
    #endif // DBG

    // Decrement the allocated packet count.
    //
    {
        LONG Count;
        Count = InterlockedDecrement(&pIF->arp.NumOutstandingPackets);
        ASSERT(Count >= 0);
    }

    // Extract the buffer and data
    //
    {
        UINT TotalLength;
        UINT BufferLength;

        NdisQueryPacket(
                    pNdisPacket,
                    NULL,
                    NULL,
                    &pNdisBuffer,
                    &TotalLength
                    );
    
        if (TotalLength > 0)
        {
            NdisQueryBuffer(
                    pNdisBuffer,
                    &pvData,
                    &BufferLength
                    );
        }
        else
        {
            BufferLength = 0;
        }
    
        // There should only be a single buffer!
        //
        ASSERT(TotalLength!=0 && TotalLength == BufferLength);
    }

    // Free the data
    //
    if (pvData != NULL)
    {
        NdisFreeMemory(pvData, 0, 0);
    }
    // Free the buffer
    //
    if (pNdisBuffer != NULL)
    {
        NdisFreeBuffer(pNdisBuffer);
    }
    // Free the packet
    //
    if (pNdisPacket != NULL)
    {
        NdisFreePacket(pNdisPacket);
    }
}


NDIS_STATUS
arpAllocateEthernetPools(
    IN  PARP1394_INTERFACE  pIF,
    IN  PRM_STACK_RECORD    pSR
    )
{
    NDIS_STATUS Status;
    NDIS_HANDLE PacketPool=NULL;
    NDIS_HANDLE BufferPool=NULL;
    ENTER("arpAllocateEthernetPools", 0x9dc1d759)

    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);
    ASSERT(pIF->ethernet.PacketPool == NULL);
    ASSERT(pIF->ethernet.BufferPool == NULL);

    do
    {
        // Allocate the NDIS Packet Pool
        //
        NdisAllocatePacketPool(
                &Status,
                &PacketPool,
                ARP1394_MAX_ETHERNET_PKTS,
                sizeof(struct PCCommon)
                );
    
        if (FAIL(Status))
        {
            PacketPool = NULL;
            break;
        }
    
        // Allocate the NDIS Buffer Pool
        //
        NdisAllocateBufferPool(
                &Status,
                &BufferPool,
                2*ARP1394_MAX_ETHERNET_PKTS // two buffers per packet.
                );
    
        if (FAIL(Status))
        {
            BufferPool = NULL;
            break;
        }
    
        //  (DBG only) Add associations for the ethernet packet pool and buffer pool.
        //  These associations must be removed before the interface is deallocated.
        //
        DBG_ADDASSOC(
            &pIF->Hdr,                  // pObject
            PacketPool,                 // Instance1
            NULL,                       // Instance2
            ARPASSOC_IF_ETHPKTPOOL, // AssociationID
            "    Eth Packet Pool 0x%p\n",// szFormat
            pSR
            );
        DBG_ADDASSOC(
            &pIF->Hdr,                  // pObject
            BufferPool,                 // Instance1
            NULL,                       // Instance2
            ARPASSOC_IF_ETHBUFPOOL, // AssociationID
            "    Eth Buffer Pool 0x%p\n",// szFormat
            pSR
            );

        pIF->ethernet.PacketPool = PacketPool;
        pIF->ethernet.BufferPool = BufferPool;
        PacketPool = NULL;
        BufferPool = NULL;

    } while (FALSE);

    if (FAIL(Status))
    {
        if (PacketPool != NULL)
        {
            NdisFreePacketPool(PacketPool);
        }
    
        if (BufferPool != NULL)
        {
            NdisFreeBufferPool(BufferPool);
        }
    }
    else
    {
        ASSERT(PacketPool == NULL && BufferPool == NULL);
    }

    return Status;
}


VOID
arpFreeEthernetPools(
    IN  PARP1394_INTERFACE  pIF,
    IN  PRM_STACK_RECORD    pSR
    )
{
    NDIS_HANDLE PacketPool;
    NDIS_HANDLE BufferPool;
    ENTER("arpFreeEthernetPools", 0x3e780760)

    // Make sure the IF is locked.
    //
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    PacketPool = pIF->ethernet.PacketPool;
    BufferPool = pIF->ethernet.BufferPool;
    pIF->ethernet.PacketPool = NULL;
    pIF->ethernet.BufferPool = NULL;
    
    // (DBG only) Remove associations for the control and packet pools.
    //
    DBG_DELASSOC(
        &pIF->Hdr,                  // pObject
        PacketPool,                 // Instance1
        NULL,                       // Instance2
        ARPASSOC_IF_ETHPKTPOOL, // AssociationID
        pSR
        );
    DBG_DELASSOC(
        &pIF->Hdr,                  // pObject
        BufferPool,                 // Instance1
        NULL,                       // Instance2
        ARPASSOC_IF_ETHBUFPOOL, // AssociationID
        pSR
        );

    // Free the buffer and packet pools
    // 
    NdisFreeBufferPool(BufferPool);
    NdisFreePacketPool(PacketPool);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\precomp.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

	Precompiled header file for ARP1394.SYS

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     11-10-98    created (adapted from atmarpc.sys precomp.h)

--*/
#include "ccdefs.h"

#ifdef TESTPROGRAM
	#include "rmtest.h"
#else // !TESTPROGRAM

#include <ndis.h>
#include <1394.h>
#include <nic1394.h>
#include <cxport.h>
#include <ip.h>
#include <arpinfo.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <basetsd.h>

// TODO: following is included
// if we  use the 
// ATMARPC_PNP_RECONFIG_REQUEST
// defined for atmarp. We currently
// don't use this structure
// (see arpPnPReconfigHandler).
//
// #include <atmarpif.h>

#include <tdistat.h>
#include <ipifcons.h>
#include <ntddip.h>
#include <llipif.h>
#include "nicarp.h"
#include <rfc2734.h>
#include <a13ioctl.h>
#include <xfilter.h>
//#include <ntddip.h> <- was in atmarpc, but I don't think it's needed here
#include "dbg.h"
#include "rm.h"
#include "priv.h"
#include "fake.h"


#endif // !TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\nt.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    nt.c

Abstract:

    NT System entry points for ARP1394.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     11-05-98    Created

Notes:

--*/
#include <precomp.h>


// File-specific debugging defaults.
//
#define TM_CURRENT   TM_NT

// Global variables for this module.
//
ARP1394_GLOBALS  ArpGlobals;

// List of fixed resources used by ArpGlobals
//
enum
{
    RTYPE_GLOBAL_BACKUP_TASKS,
    RTYPE_GLOBAL_DEVICE_OBJECT,
    RTYPE_GLOBAL_NDIS_BINDING,
    RTYPE_GLOBAL_ADAPTER_LIST,
    RTYPE_GLOBAL_IP_BINDING
    
}; // ARP_GLOBAL_RESOURCES;

//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT              pDriverObject,
    IN  PUNICODE_STRING             pRegistryPath
);

VOID
ArpUnload(
    IN  PDRIVER_OBJECT              pDriverObject
);

NTSTATUS
ArpDispatch(
    IN  PDEVICE_OBJECT              pDeviceObject,
    IN  PIRP                        pIrp
);

RM_STATUS
arpResHandleGlobalDeviceObject(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
);

RM_STATUS
arpResHandleGlobalNdisBinding(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
);

RM_STATUS
arpResHandleGlobalIpBinding(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
);

RM_STATUS
arpResHandleGlobalAdapterList(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
);

RM_STATUS
arpResHandleGlobalBackupTasks(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
);

//
// Identifies information pertaining to the use of the above resources.
// Following table MUST be in strict increasing order of the RTYPE_GLOBAL
// enum.
//
RM_RESOURCE_TABLE_ENTRY 
ArpGlobals_ResourceTable[] =
{
    {RTYPE_GLOBAL_BACKUP_TASKS,    arpResHandleGlobalBackupTasks},
    {RTYPE_GLOBAL_DEVICE_OBJECT,    arpResHandleGlobalDeviceObject},
    {RTYPE_GLOBAL_NDIS_BINDING,     arpResHandleGlobalNdisBinding},
    {RTYPE_GLOBAL_ADAPTER_LIST,     arpResHandleGlobalAdapterList},
    {RTYPE_GLOBAL_IP_BINDING,       arpResHandleGlobalIpBinding}
    
};

// Static informatiou about ArpGlobals.
//
RM_STATIC_OBJECT_INFO
ArpGlobals_StaticInfo = 
{
    0, // TypeUID
    0, // TypeFlags
    "ArpGlobals",   // TypeName
    0, // Timeout

    NULL, // pfnCreate
    NULL, // pfnDelete
    NULL, // pfnVerifyLock

    sizeof(ArpGlobals_ResourceTable)/sizeof(ArpGlobals_ResourceTable[1]),
    ArpGlobals_ResourceTable
};

BOOLEAN
arpAdapterCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for ARP1394_ADAPTER.

Arguments:

    pKey        - Points to an NDIS_STRING containing  an adapter name.
    pItem       - Points to ARP1394_ADAPTER.Hdr.HashLink.

Return Value:

    TRUE IFF the key (adapter name) exactly matches the key of the specified 
    adapter object.

--*/
{
    ARP1394_ADAPTER *pA = CONTAINING_RECORD(pItem, ARP1394_ADAPTER, Hdr.HashLink);
    PNDIS_STRING pName = (PNDIS_STRING) pKey;

    //
    // TODO: maybe case-insensitive compare?
    //

    if (   (pA->bind.DeviceName.Length == pName->Length)
        && NdisEqualMemory(pA->bind.DeviceName.Buffer, pName->Buffer, pName->Length))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}


ULONG
arpAdapterHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash function responsible for returning a hash of pKey, which
    we expect to be a pointer to an NDIS_STRING.

Return Value:

    ULONG-sized hash of the string.

--*/
{
    PNDIS_STRING pName = (PNDIS_STRING) pKey;
    WCHAR *pwch = pName->Buffer;
    WCHAR *pwchEnd = pName->Buffer + pName->Length/sizeof(*pwch);
    ULONG Hash  = 0;

    for (;pwch < pwchEnd; pwch++)
    {
        Hash ^= (Hash<<1) ^ *pwch;
    }

    return Hash;
}


// arpAdapter_HashInfo contains information required maintain a hashtable
// of ARP1394_ADAPTER objects.
//
RM_HASH_INFO
arpAdapter_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpAdapterCompareKey,   // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpAdapterHash      // pfnHash

};


// ArpGlobals_AdapterStaticInfo contains static information about
// objects of type ARP1394_ADAPTER.
//
RM_STATIC_OBJECT_INFO
ArpGlobals_AdapterStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "Adapter",  // TypeName
    0, // Timeout

    arpAdapterCreate,   // pfnCreate
    arpAdapterDelete,       // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpAdapter_HashInfo
};


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT              pDriverObject,
    IN  PUNICODE_STRING             pRegistryPath
)
/*++

Routine Description:

    This is the "init" routine, called by the system when the ARP
    module is loaded. We initialize all our global objects, fill in our
    Dispatch and Unload routine addresses in the driver object, and create
    a device object for receiving I/O requests on (IOCTLs).

Arguments:

    pDriverObject   - Pointer to the driver object created by the system.
    pRegistryPath   - Pointer to our global registry path. This is ignored.

Return Value:

    NT Status code: STATUS_SUCCESS if successful, error code otherwise.

--*/
{
    NTSTATUS    Status;
    BOOLEAN     AllocatedGlobals = FALSE;
    ENTER("DriverEntry", 0xbfcb7eb1)
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMPX("==>DriverEntry");

    do
    {
        // Must be done before any RM apis are used.
        //
        RmInitializeRm();

        RmInitializeLock(
                    &ArpGlobals.Lock,
                    LOCKLEVEL_GLOBAL
                    );

        RmInitializeHeader(
                NULL,                   // pParentObject,
                &ArpGlobals.Hdr,
                ARP1394_GLOBALS_SIG,
                &ArpGlobals.Lock,
                &ArpGlobals_StaticInfo,
                NULL,                   // szDescription
                &sr
                );


        AllocatedGlobals = TRUE;

        //
        //  Initialize the Driver Object.
        //
        {
            INT i;

            pDriverObject->DriverUnload = ArpUnload;
            pDriverObject->FastIoDispatch = NULL;
            for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
            {
                pDriverObject->MajorFunction[i] = ArpDispatch;
            }
    
            pDriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = ArpWmiDispatch;
        
            ArpGlobals.driver.pDriverObject = pDriverObject;
        }

    #if 0 //  MILLEN
        TR_WARN((
            "&g_SkipAll =0x%p; &g_ulTracelevel=0x%p; &g_DiscardNonUnicastPackets=0x%p\n",
             &g_SkipAll,
             &g_ulTraceLevel,
             &g_DiscardNonUnicastPackets));
      #if DBG
        DbgBreakPoint();
      #endif // DBG
    #endif // 0

        Status = RmLoadGenericResource(
                    &ArpGlobals.Hdr,
                    RTYPE_GLOBAL_BACKUP_TASKS,
                    &sr
                    );

        if (FAIL(Status)) break;

        //
        // Create a device object for the driver.
        //
        Status = RmLoadGenericResource(
                    &ArpGlobals.Hdr,
                    RTYPE_GLOBAL_DEVICE_OBJECT,
                    &sr
                    );

        if (FAIL(Status)) break;

        //
        // Register ourselves with NDIS.
        //
        Status = RmLoadGenericResource(
                    &ArpGlobals.Hdr,
                    RTYPE_GLOBAL_NDIS_BINDING,
                    &sr
                    );

        if (FAIL(Status)) break;
    
        //
        // Create the Adapter List
        //
        Status = RmLoadGenericResource(
                    &ArpGlobals.Hdr,
                    RTYPE_GLOBAL_ADAPTER_LIST,
                    &sr);

        if (FAIL(Status)) break;

        
        //
        // Register ourselves with IP.
        //
        Status = RmLoadGenericResource(
                    &ArpGlobals.Hdr,
                    RTYPE_GLOBAL_IP_BINDING,
                    &sr
                    );



    } while (FALSE);

    
    if (FAIL(Status))
    {
        if (AllocatedGlobals)
        {
            RmUnloadAllGenericResources(
                    &ArpGlobals.Hdr,
                    &sr
                    );
            RmDeallocateObject(
                    &ArpGlobals.Hdr,
                    &sr
                    );
        }

        // Must be done after any RM apis are used and async activity complete.
        //
        RmDeinitializeRm();
    }

    RM_ASSERT_CLEAR(&sr)
    EXIT()

    TIMESTAMP("<==DriverEntry");

    return Status;
}


VOID
ArpUnload(
    IN  PDRIVER_OBJECT              pDriverObject
)
/*++

Routine Description:

    This routine is called by the system prior to unloading us.
    Currently, we just undo everything we did in DriverEntry,
    that is, de-register ourselves as an NDIS protocol, and delete
    the device object we had created.

Arguments:

    pDriverObject   - Pointer to the driver object created by the system.

Return Value:

    None

--*/
{
    ENTER("Unload", 0xc8482549)
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>Unload");
    RmUnloadAllGenericResources(&ArpGlobals.Hdr, &sr);

    RmDeallocateObject(&ArpGlobals.Hdr, &sr);

    // Must be done after any RM apis are used and async activity complete.
    //
    RmDeinitializeRm();

    // TODO? Block(250);

    RM_ASSERT_CLEAR(&sr)

    EXIT()
    TIMESTAMP("<==Unload");
    return;
}


NTSTATUS
ArpDispatch(
    IN  PDEVICE_OBJECT              pDeviceObject,
    IN  PIRP                        pIrp
)
/*++

Routine Description:

    This routine is called by the system when there is an IRP
    to be processed.

Arguments:

    pDeviceObject       - Pointer to device object we created for ourselves.
    pIrp                - Pointer to IRP to be processed.

Return Value:

    NT Status code.

--*/
{
    NTSTATUS                NtStatus;               // Return value
    PIO_STACK_LOCATION      pIrpStack;
    PVOID                   pIoBuffer;          // Values in/out
    ULONG                   InputBufferLength;  // Length of input parameters
    ULONG                   OutputBufferLength; // Space for output values

    ENTER("Dispatch", 0x1dcf2679)

    //
    //  Initialize
    //
    NtStatus = STATUS_SUCCESS;

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;

    //
    //  Get all information in the IRP
    //
    pIoBuffer = pIrp->AssociatedIrp.SystemBuffer;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    InputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    switch (pIrpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            TR_INFO(("IRP_MJ_CREATE\n"));
            break;

        case IRP_MJ_CLOSE:
            TR_INFO(("IRP_MJ_CLOSE\n"));
            break;

        case IRP_MJ_CLEANUP:
            TR_INFO(("IRP_MJ_CLEANUP\n"));
            break;

        case IRP_MJ_DEVICE_CONTROL:
            TR_INFO(("IRP_MJ_DEVICE_CONTROL\n"));

            NtStatus =  ArpHandleIoctlRequest(pIrp, pIrpStack);
            break;

        default:
            TR_WARN(("IRP: Unknown major function 0x%p\n",
                        pIrpStack->MajorFunction));
            break;
    }

    if (NtStatus != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = NtStatus;
        IoMarkIrpPending(pIrp);
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    EXIT()

    return STATUS_PENDING;

}

RM_STATUS
arpResHandleGlobalDeviceObject(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Responsible for loading and unloading of the RTYPE_GLOBAL_DEVICE_OBJECT resource.

Arguments:

    pObj            - Actually a pointer to an object of type ARP1394_GLOBALS.
    Op              - Operation (load/unload)
    pvUserParams    - (unused)

Return Value:

    NDIS_STATUS_SUCCESS on success
    NDIS failure code   otherwise.

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_GLOBALS     *pGlobals   = CONTAINING_RECORD(pObj, ARP1394_GLOBALS, Hdr);
    BOOLEAN             fCreatedSymbolicLink = FALSE;
    PDRIVER_OBJECT      pDriverObject = (PDRIVER_OBJECT) pGlobals->driver.pDriverObject;
    UNICODE_STRING  SymbolicName;

    ENTER("GlobalDeviceObject", 0x335f5f57)

    RtlInitUnicodeString(&SymbolicName, ARP1394_SYMBOLIC_NAME);

    if (Op == RM_RESOURCE_OP_LOAD)
    {
        TR_WARN(("LOADING"));

        do
        {
            PDEVICE_OBJECT      pDeviceObject;
            UNICODE_STRING          DeviceName;

            RtlInitUnicodeString(&DeviceName, ARP1394_DEVICE_NAME);
            pGlobals->driver.pDeviceObject = NULL;

            //
            //  Create a device object for the ARP1394 module.
            //
            Status = IoCreateDevice(
                        pDriverObject,
                        0,
                        &DeviceName,
                        FILE_DEVICE_NETWORK,
                        FILE_DEVICE_SECURE_OPEN,
                        FALSE,
                        &pDeviceObject
                        );
            
            if (FAIL(Status)) break;
        
            //
            //  Retain the device object pointer -- we'll need this
            //  if/when we are asked to unload ourselves.
            //
            pGlobals->driver.pDeviceObject = pDeviceObject;

            //
            // Set up a symbolic name for interaction with the user-mode
            // admin application.
            //
            {
        
                Status = IoCreateSymbolicLink(&SymbolicName, &DeviceName);
                if (FAIL(Status)) break;

                fCreatedSymbolicLink = TRUE;
            }

            //
            //  Initialize the Device Object.
            //
            pDeviceObject->Flags |= DO_DIRECT_IO;

        } while (FALSE);
    }
    else if (Op == RM_RESOURCE_OP_UNLOAD)
    {
        TR_WARN(("UNLOADING"));
        //
        // Were unloading this "resource" -- we expect
        // that pGlobals->driver.pDeviceObject contains a valid
        // device object and that we have created a symbolic
        // link which we need to tear down.
        //
        ASSERTEX(pGlobals->driver.pDeviceObject != NULL, pGlobals);
        fCreatedSymbolicLink = TRUE;

        // Always return success on unload.
        //
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        // Unexpected op code.
        //
        ASSERTEX(FALSE, pObj);
    }

    //
    // Release all resources either on unload or on failed load.
    //
    if (Op == RM_RESOURCE_OP_UNLOAD || FAIL(Status))
    {
        // If we've created a symbolic link, delete it.
        if (fCreatedSymbolicLink)
        {
            IoDeleteSymbolicLink(&SymbolicName);
        }

        // If we've created a device object, free it.
        if (pGlobals->driver.pDeviceObject)
        {
            IoDeleteDevice(pGlobals->driver.pDeviceObject);
            pGlobals->driver.pDeviceObject = NULL;
        }
    }

    EXIT()

    return Status;
}


RM_STATUS
arpResHandleGlobalNdisBinding(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Responsible for loading and unloading of the  RTYPE_GLOBAL_NDIS_BINDING resource.

Arguments:

    pObj            - Actually a pointer to an object of type ARP1394_GLOBALS.
    Op              - Operation (load/unload)
    pvUserParams    - (unused)

Return Value:

    NDIS_STATUS_SUCCESS on success
    NDIS failure code   otherwise.

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    ARP1394_GLOBALS                 *pGlobals   = CONTAINING_RECORD(
                                                        pObj,
                                                        ARP1394_GLOBALS,
                                                        Hdr);
    PNDIS_PROTOCOL_CHARACTERISTICS  pNdisPC     = &(pGlobals->ndis.PC);
    PNDIS_CLIENT_CHARACTERISTICS    pNdisCC     = &(pGlobals->ndis.CC);
    ENTER("GlobalNdisBinding", 0x62b1181e)

    if (Op == RM_RESOURCE_OP_LOAD)
    {
        TR_WARN(("LOADING"));
        //
        //  Fill in our Protocol and Client characteristics structures.
        //

        NdisZeroMemory(pNdisPC, sizeof(*pNdisPC));
        pNdisPC->MajorNdisVersion               = ARP1394_NDIS_MAJOR_VERSION;
        pNdisPC->MinorNdisVersion               = ARP1394_NDIS_MINOR_VERSION;
        pNdisPC->OpenAdapterCompleteHandler     = ArpNdOpenAdapterComplete;
        pNdisPC->CloseAdapterCompleteHandler    = ArpNdCloseAdapterComplete;
        pNdisPC->ResetCompleteHandler           = ArpNdResetComplete;
        pNdisPC->RequestCompleteHandler         = ArpNdRequestComplete;
        pNdisPC->StatusHandler                  = ArpNdStatus;
        pNdisPC->StatusCompleteHandler          = ArpNdStatusComplete;

        pNdisPC->SendCompleteHandler            = ArpNdSendComplete;

    #if ARP_ICS_HACK
        //
        // Add basic connectionless handlers.
        //
        // pNdisPC->SendCompleteHandler             = ArpNdSendComplete;
        pNdisPC->ReceiveCompleteHandler         = ArpNdReceiveComplete;
        pNdisPC->ReceiveHandler                 = ArpNdReceive;
        pNdisPC->ReceivePacketHandler           = ArpNdReceivePacket;
    #endif // ARP_ICS_HACK

        NdisInitUnicodeString(
            &pNdisPC->Name,
            ARP1394_LL_NAME
        );


        //
        // Following protocol context handlers are unused and set to NULL.
        //
        //  pNdisPC->TransferDataCompleteHandler
        //  pNdisPC->ReceiveHandler
        //  pNdisPC->ReceiveCompleteHandler
        //  pNdisPC->ReceivePacketHandler
        //
        pNdisPC->ReceiveCompleteHandler         = ArpNdReceiveComplete;
        pNdisPC->BindAdapterHandler             = ArpNdBindAdapter;

        pNdisPC->UnbindAdapterHandler           = ArpNdUnbindAdapter;
        pNdisPC->UnloadHandler                  = (UNLOAD_PROTOCOL_HANDLER)
                                                    ArpNdUnloadProtocol;
        pNdisPC->PnPEventHandler                = ArpNdPnPEvent;

        pNdisPC->CoSendCompleteHandler          = ArpCoSendComplete;
        pNdisPC->CoStatusHandler                = ArpCoStatus;
        pNdisPC->CoReceivePacketHandler         = ArpCoReceivePacket;
        pNdisPC->CoAfRegisterNotifyHandler      = ArpCoAfRegisterNotify;
    
        NdisZeroMemory(pNdisCC, sizeof(*pNdisCC));
        pNdisCC->MajorVersion                   = ARP1394_NDIS_MAJOR_VERSION;
        pNdisCC->MinorVersion                   = ARP1394_NDIS_MINOR_VERSION;
        pNdisCC->ClCreateVcHandler              = ArpCoCreateVc;
        pNdisCC->ClDeleteVcHandler              = ArpCoDeleteVc;
        pNdisCC->ClRequestHandler               = ArpCoRequest;
        pNdisCC->ClRequestCompleteHandler       = ArpCoRequestComplete;
        pNdisCC->ClOpenAfCompleteHandler        = ArpCoOpenAfComplete;
        pNdisCC->ClCloseAfCompleteHandler       = ArpCoCloseAfComplete;
        pNdisCC->ClMakeCallCompleteHandler      = ArpCoMakeCallComplete;
        pNdisCC->ClModifyCallQoSCompleteHandler = ArpCoModifyQosComplete;
        pNdisCC->ClIncomingCloseCallHandler     = ArpCoIncomingClose;
        pNdisCC->ClCallConnectedHandler         = ArpCoCallConnected;
        pNdisCC->ClCloseCallCompleteHandler     = ArpCoCloseCallComplete;

        //
        // Following client context handlers are unused and set to NULL.
        //
        //  pNdisCC->ClRegisterSapCompleteHandler
        //  pNdisCC->ClDeregisterSapCompleteHandler
        //  pNdisCC->ClAddPartyCompleteHandler
        //  pNdisCC->ClDropPartyCompleteHandler
        //  pNdisCC->ClIncomingCallHandler
        //  pNdisCC->ClIncomingCallQoSChangeHandler
        //  pNdisCC->ClIncomingDropPartyHandler
        //
        
        //
        //  Register ourselves as a protocol with NDIS.
        //
        NdisRegisterProtocol(
                    &Status,
                    &(pGlobals->ndis.ProtocolHandle),
                    pNdisPC,
                    sizeof(*pNdisPC)
                    );

        if (FAIL(Status))
        {
            NdisZeroMemory(&(pGlobals->ndis), sizeof(pGlobals->ndis));
        }
    }
    else if (Op == RM_RESOURCE_OP_UNLOAD)
    {
        //
        // Were unloading this "resource", i.e., cleaning up and
        // unregistering with NDIS.
        //
        TR_WARN(("UNLOADING"));

        ASSERTEX(pGlobals->ndis.ProtocolHandle != NULL, pGlobals);

        // Unregister ourselves from ndis
        //
        NdisDeregisterProtocol(
                        &Status,
                        pGlobals->ndis.ProtocolHandle
                        );

        NdisZeroMemory(&(pGlobals->ndis), sizeof(pGlobals->ndis));

    }
    else
    {
        // Unexpected op code.
        //
        ASSERT(FALSE);
    }
    

    EXIT()
    return Status;
}


RM_STATUS
arpResHandleGlobalIpBinding(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Responsible for loading and unloading of the  RTYPE_GLOBAL_IP_BINDING resource.

Arguments:

    pObj            - Actually a pointer to an object of type ARP1394_GLOBALS.
    Op              - Operation (load/unload)
    pvUserParams    - (unused)

Return Value:

    NDIS_STATUS_SUCCESS on success
    NDIS failure code   otherwise.

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    ARP1394_GLOBALS                 *pGlobals   = CONTAINING_RECORD(
                                                        pObj,
                                                        ARP1394_GLOBALS,
                                                        Hdr);
    ENTER("GlobalIpBinding", 0xf9d36d49)

    if (Op == RM_RESOURCE_OP_LOAD)
    {
        //
        //  Register ourselves as an ARP Module with IP.
        //
        NDIS_STRING     ArpName;
        IP_CHANGE_INDEX        IpChangeIndex;
        IP_RESERVE_INDEX       IpReserveIndex;
        IP_DERESERVE_INDEX     IpDereserveIndex;
        TR_WARN(("LOADING"));

        NdisInitUnicodeString(&ArpName, ARP1394_UL_NAME);

        Status = IPRegisterARP(
                    &ArpName,
                    IP_ARP_BIND_VERSION,
                    ArpNdBindAdapter,
                    &(pGlobals->ip.pAddInterfaceRtn),
                    &(pGlobals->ip.pDelInterfaceRtn),
                    &(pGlobals->ip.pBindCompleteRtn),
                    &(pGlobals->ip.pAddLinkRtn),
                    &(pGlobals->ip.pDeleteLinkRtn),
                    //
                    // Following 3 are placeholders -- we don't use this information.
                    // See 10/14/1998 entry in ipatmc\notes.txt
                    //
                    &IpChangeIndex,
                    &IpReserveIndex,
                    &IpDereserveIndex,
                    &(pGlobals->ip.ARPRegisterHandle)
                    );

        if (FAIL(Status))
        {
            TR_WARN(("IPRegisterARP FAILS. Status = 0x%p", Status));
            NdisZeroMemory(&(pGlobals->ip), sizeof(pGlobals->ip));
        }
        else
        {
            TR_WARN(("IPRegisterARP Succeeds"));
        }
    }
    else if (Op == RM_RESOURCE_OP_UNLOAD)
    {
        //
        // Were unloading this "resource", i.e., unregistering with IP.
        //
        TR_WARN(("UNLOADING"));
        ASSERTEX(pGlobals->ip.ARPRegisterHandle != NULL, pGlobals);

        //
        // Unload all adapters (and disallow new adapter from being added)
        // *before calling IPDerigesterARP.
        //
        RmUnloadAllObjectsInGroup(
                    &pGlobals->adapters.Group,
                    arpAllocateTask,
                    arpTaskShutdownAdapter,
                    NULL,   // userParam
                    NULL, // pTask
                    0,    // uTaskPendCode
                    pSR
                    );
        
        Status = IPDeregisterARP(pGlobals->ip.ARPRegisterHandle);
        ASSERTEX(!FAIL(Status), pGlobals);
        NdisZeroMemory(&(pGlobals->ip), sizeof(pGlobals->ip));
    }
    else
    {
        // Unexpected op code.
        //
        ASSERT(FALSE);
    }

    EXIT()
    return Status;
}


RM_STATUS
arpResHandleGlobalAdapterList(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Responsible for loading and unloading of the RTYPE_GLOBAL_ADAPTER_LIST resource.

Arguments:

    pObj            - Actually a pointer to an object of type ARP1394_GLOBALS.
    Op              - Operation (load/unload)
    pvUserParams    - (unused)

Return Value:

    NDIS_STATUS_SUCCESS on success
    NDIS failure code   otherwise.

--*/
{
    ARP1394_GLOBALS                 *pGlobals   = CONTAINING_RECORD(
                                                        pObj,
                                                        ARP1394_GLOBALS,
                                                        Hdr);
    ENTER("GlobalAdapterList", 0xb407e79e)

    if (Op == RM_RESOURCE_OP_LOAD)
    {
        //
        //  Allocate adapter list.
        //
        TR_WARN(("LOADING"));

        RmInitializeGroup(
                        pObj,                                   // pParentObject
                        &ArpGlobals_AdapterStaticInfo,          // pStaticInfo
                        &(pGlobals->adapters.Group),            // pGroup
                        "Adapter group",                        // szDescription
                        pSR                                     // pStackRecord
                        );
    }
    else if (Op == RM_RESOURCE_OP_UNLOAD)
    {
        //
        // We're unloading this "resource", i.e., unloading and deallocating the 
        // global adapter list. We first unload and free all the adapters
        // in the list, and then free the list itself.
        //
        TR_WARN(("UNLOADING"));
        
        //
        // We expect there to be no adapter objects at this point.
        //
        ASSERT(pGlobals->adapters.Group.HashTable.NumItems == 0);

        if (0)
        {
            RmUnloadAllObjectsInGroup(
                        &pGlobals->adapters.Group,
                        arpAllocateTask,
                        arpTaskShutdownAdapter,
                        NULL,   // userParam
                        NULL, // pTask
                        0,    // uTaskPendCode
                        pSR
                        );
        }

        RmDeinitializeGroup(&pGlobals->adapters.Group, pSR);
        NdisZeroMemory(&(pGlobals->adapters), sizeof(pGlobals->adapters));
    }
    else
    {
        // Unexpected op code.
        //
        ASSERT(FALSE);
    }

    EXIT()

    return NDIS_STATUS_SUCCESS;
}



RM_STATUS
arpResHandleGlobalBackupTasks(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Allocates 4 Tasks for each adapter to be used as a backup in case of a low mem
    condition.

Arguments:

    pObj            - Actually a pointer to an object of type ARP1394_GLOBALS.
    Op              - Operation (load/unload)
    pvUserParams    - (unused)

Return Value:

    NDIS_STATUS_SUCCESS on success
    NDIS failure code   otherwise.

--*/
{
    ARP1394_GLOBALS                 *pGlobals   = CONTAINING_RECORD(
                                                        pObj,
                                                        ARP1394_GLOBALS,
                                                        Hdr);
    ENTER("GlobalBackupTasks", 0xb64e5007)

    if (Op == RM_RESOURCE_OP_LOAD)
    {
        //
        //  Allocate adapter list.
        //
        TR_WARN(("LOADING"));

        arpAllocateBackupTasks(pGlobals); 
    }
    else if (Op == RM_RESOURCE_OP_UNLOAD)
    {
        //
        // We're unloading this "resource", i.e., unloading and deallocating the 
        // global adapter list. We first unload and free all the adapters
        // in the list, and then free the list itself.
        //
        TR_WARN(("UNLOADING"));
        
        //
        // We expect there to be no adapter objects at this point.
        //
        arpFreeBackupTasks(pGlobals); 
    
    }
    else
    {
        // Unexpected op code.
        //
        ASSERT(FALSE);
    }

    EXIT()

    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\componentdef\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\rm.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    rm.c

Abstract:

    Implementation of the "Resource Manager" APIs.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     11-18-98    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_RM

//=========================================================================
//                  U T I L I T Y     M A C R O S
//=========================================================================

#define RM_ALLOC(_pp, _size, _tag) \
                NdisAllocateMemoryWithTag((_pp), (_size), (_tag))

#define RM_ALLOCSTRUCT(_p, _tag) \
                NdisAllocateMemoryWithTag(&(_p), sizeof(*(_p)), (_tag))

#define RM_FREE(_p)         NdisFreeMemory((_p), 0, 0)

#define RM_ZEROSTRUCT(_p) \
                NdisZeroMemory((_p), sizeof(*(_p)))

#define RM_PRIVATE_UNLINK_NEXT_HASH(_pHashTable, _ppLink) \
            ((*(_ppLink) = (*(_ppLink))->pNext), ((_pHashTable)->NumItems--))

#define SET_RM_STATE(_pHdr, _Mask, _Val)    \
            (((_pHdr)->RmState) = (((_pHdr)->RmState) & ~(_Mask)) | (_Val))

#define CHECK_RM_STATE(_pHdr, _Mask, _Val)  \
            ((((_pHdr)->RmState) & (_Mask)) == (_Val))

#define RMISALLOCATED(_pHdr) \
                CHECK_RM_STATE((_pHdr), RMOBJSTATE_ALLOCMASK, RMOBJSTATE_ALLOCATED)

#define SET_RM_TASK_STATE(_pTask, _pState) \
    SET_RM_STATE(&(_pTask)->Hdr, RMTSKSTATE_MASK, (_pState))

#define CHECK_RM_TASK_STATE(_pTask, _pState) \
    CHECK_RM_STATE(&(_pTask)->Hdr, RMTSKSTATE_MASK, (_pState))

#define GET_RM_TASK_STATE(_pTask) \
        ((_pTask)->Hdr.RmState &  RMTSKSTATE_MASK)

#if RM_EXTRA_CHECKING
    #define RMPRIVATELOCK(_pobj, _psr) \
         rmLock(&(_pobj)->RmPrivateLock, 0, rmPrivateLockVerifier, (_pobj), (_psr))
#else // !RM_EXTRA_CHECKING
    #define RMPRIVATELOCK(_pobj, _psr) \
        rmLock(&(_pobj)->RmPrivateLock, (_psr))
#endif // !RM_EXTRA_CHECKING

#define RMPRIVATEUNLOCK(_pobj, _psr) \
        rmUnlock(&(_pobj)->RmPrivateLock, (_psr))
        

#if 0
    #define RM_TEST_SIG          0x59dcfd36
    #define RM_TEST_DEALLOC_SIG  0x21392147
    #define RM_OBJECT_IS_ALLOCATED(_pobj) \
                    ((_pobj)->Sig == RM_TEST_SIG)
    #define RM_MARK_OBJECT_AS_DEALLOCATED(_pobj) \
                    ((_pobj)->Sig = RM_TEST_DEALLOC_SIG)
#else
    #define RM_OBJECT_IS_ALLOCATED(_pobj)  0x1
    #define RM_MARK_OBJECT_AS_DEALLOCATED(_pobj)  (0)
#endif

//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

#if RM_EXTRA_CHECKING

// The lowest AssociationID used internal to the RM API implementation.
//
#define RM_PRIVATE_ASSOC_BASE (0x1<<31)

// Association types internal to RM API impmenentation.
//
enum
{
    RM_PRIVATE_ASSOC_LINK =  RM_PRIVATE_ASSOC_BASE,
    RM_PRIVATE_ASSOC_LINK_CHILDOF,
    RM_PRIVATE_ASSOC_LINK_PARENTOF,
    RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
    RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
    RM_PRIVATE_ASSOC_INITGROUP,
    RM_PRIVATE_ASSOC_RESUME_TASK_ASYNC,
    RM_PRIVATE_ASSOC_RESUME_TASK_DELAYED
};


const char *szASSOCFORMAT_LINK                  = "    Linked  to 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_CHILDOF          = "    Child   of 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_PARENTOF         = "    Parent  of 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_TASKPENDINGON    = "    Pending on 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_TASKBLOCKS       = "    Blocks     0x%p (%s)\n";
const char *szASSOCFORMAT_INITGROUP             = "    Owns group 0x%p (%s)\n";
const char *szASSOCFORMAT_RESUME_TASK_ASYNC     = "    Resume async (param=0x%p)\n";
const char *szASSOCFORMAT_RESUME_TASK_DELAYED   = "    Resume delayed (param=0x%p)\n";

//  Linked to 0x098889(LocalIP)
//  Parent of 0x098889(InitIPTask)
//  Child  of 0x098889(Interface)

#endif // RM_EXTRA_CHECKING

// Private RM task to unload all objects in a group.
//
typedef struct
{
    RM_TASK             TskHdr;             // Common task header
    PRM_GROUP           pGroup;         // Group being unloaded
    UINT                uIndex;             // Index of hash-table currently being
                                            // unloaded.
    NDIS_EVENT          BlockEvent;         // Event to optionally signal when done.
    BOOLEAN             fUseEvent;          // TRUE IFF event is to be signaled.
    PFN_RM_TASK_HANDLER             pfnTaskUnloadObjectHandler; // ...
                                             // Object's unload task.
    PFN_RM_TASK_ALLOCATOR   pfnUnloadTaskAllocator;

} TASK_UNLOADGROUP;


//
// RM_PRIVATE_TASK is the union of all tasks structures used intenally in rm.c.
// rmAllocateTask allocates memory of sizeof(RM_PRIVATE_TASK), which is guaranteed
// to be large enough to hold any task internal to rm.c
// 
typedef union
{
    RM_TASK                 TskHdr;
    TASK_UNLOADGROUP        UnloadGroup;

}  RM_PRIVATE_TASK;


#if RM_EXTRA_CHECKING

VOID
rmDbgInitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    );

VOID
rmDbgDeinitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    );

VOID
rmDbgPrintOneAssociation (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    );

VOID
_cdecl
rmDefaultDumpEntry (
    char *szFormatString,
    UINT_PTR Param1,
    UINT_PTR Param2,
    UINT_PTR Param3,
    UINT_PTR Param4
);

UINT
rmSafeAppend(
    char *szBuf,
    const char *szAppend,
    UINT cbBuf
);

#endif // RM_EXTRA_CHECKING


NDIS_STATUS
rmTaskUnloadGroup(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );


NDIS_STATUS
rmAllocatePrivateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,      OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
rmWorkItemHandler_ResumeTaskAsync(
    IN  PNDIS_WORK_ITEM             pWorkItem,
    IN  PVOID                       pTaskToResume
    );


VOID
rmTimerHandler_ResumeTaskDelayed(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );

VOID
rmPrivateTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

VOID
rmDerefObject(
    PRM_OBJECT_HEADER       pObject,
    PRM_STACK_RECORD        pSR
    );

VOID
rmLock(
    PRM_LOCK                pLock,
#if RM_EXTRA_CHECKING
    UINT                    uLocID,
    PFNLOCKVERIFIER         pfnVerifier,
    PVOID                   pVerifierContext,
#endif //RM_EXTRA_CHECKING
    PRM_STACK_RECORD        pSR
    );

VOID
rmUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    );

#if RM_EXTRA_CHECKING
ULONG
rmPrivateLockVerifier(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        );

ULONG
rmVerifyObjectState(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        );

RM_DBG_LOG_ENTRY *
rmDbgAllocateLogEntry(VOID);

VOID
rmDbgDeallocateLogEntry(
        RM_DBG_LOG_ENTRY *pLogEntry
        );

#endif // RM_EXTRA_CHECKING

VOID
rmEndTask(
    PRM_TASK            pTask,
    NDIS_STATUS         Status,
    PRM_STACK_RECORD    pSR
    );


VOID
rmUpdateHashTableStats(
    PULONG pStats,
    ULONG   LinksTraversed
    );

typedef struct
{
    PFN_RM_GROUP_ENUMERATOR pfnObjEnumerator;
    PVOID pvCallerContext;
    INT   fContinue;

} RM_STRONG_ENUMERATION_CONTEXT, *PRM_STRONG_ENUMERATION_CONTEXT;


typedef struct
{
    PRM_OBJECT_HEADER *ppCurrent;
    PRM_OBJECT_HEADER *ppEnd;

} RM_WEAK_ENUMERATION_CONTEXT, *PRM_WEAK_ENUMERATION_CONTEXT;


VOID
rmEnumObjectInGroupHashTable (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    );

VOID
rmConstructGroupSnapshot (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    );

//=========================================================================
//                  L O C A L       D A T A
//=========================================================================

// Global struture for the RM apis.
//
struct
{
    // Accessed via interlocked operation.
    //
    ULONG           Initialized;

    RM_OS_LOCK          GlobalOsLock;
    LIST_ENTRY      listGlobalLog;
    UINT            NumGlobalLogEntries;

}   RmGlobals;


RM_STATIC_OBJECT_INFO
RmPrivateTasks_StaticInfo = 
{
    0, // TypeUID
    0, // TypeFlags
    "RM Private Task",  // TypeName
    0, // Timeout

    NULL, // pfnCreate
    rmPrivateTaskDelete, // pfnDelete
    NULL,   // LockVerifier

    0,   // length of resource table
    NULL // Resource Table
};


// TODO: make constant
static
RM_STATIC_OBJECT_INFO
RmTask_StaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "Task", // TypeName
    0, // Timeout

    NULL, // Create
    NULL, // Delete
    NULL, // LockVerifier

    0,   // ResourceTable size
    NULL // ResourceTable
};


//=========================================================================
//                  R M         A P I S
//=========================================================================


#define RM_INITIALIZATION_STARTING 1
#define RM_INITIALIZATION_COMPLETE 2

VOID
RmInitializeRm(VOID)
/*++
    Must be called before any RM APIs are called.
    TODO: replace by registration mechanism.
          See notes.txt  03/07/1999  entry "Registering root objects with RM".
--*/
{
    ENTER("RmInitializeRm", 0x29f5d167)

    if (InterlockedCompareExchange(
            &RmGlobals.Initialized, RM_INITIALIZATION_STARTING, 0)==0)
    {
        TR_INFO(("Initializing RM APIs Global Info\n"));
        NdisAllocateSpinLock(&RmGlobals.GlobalOsLock);
        InitializeListHead(&RmGlobals.listGlobalLog);

        InterlockedExchange(&RmGlobals.Initialized, RM_INITIALIZATION_COMPLETE);
    }
    else
    {
        // Spin waiting for it to get to RM_INITIALIZATION_COMPLETE (allocated).
        TR_INFO(("Spinning, waiting for initialization to complete.\n"));
        while (RmGlobals.Initialized != RM_INITIALIZATION_COMPLETE)
        {
            // spin
        }
    }

    EXIT()
}


VOID
RmDeinitializeRm(VOID)
/*++
    Must be called to deinitialze, after last RM api is called and all async
    activity is over.
    TODO: replace by deregistration mechanism.
          See notes.txt  03/07/1999  entry "Registering root objects with RM".
--*/
{
    ENTER("RmDeinitializeRm", 0x9a8407e9)

    ASSERT(RmGlobals.Initialized == RM_INITIALIZATION_COMPLETE);
    TR_INFO(("Deinitializing RM APIs Global Info\n"));

    // Make sure global log list is empty. Acquiring the GLobalOsLock is
    // not necessary here because all activity has stopped by now.
    //
    ASSERT(IsListEmpty(&RmGlobals.listGlobalLog));

    EXIT()
}


VOID
RmInitializeHeader(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  UINT                        Sig,
    IN  PRM_LOCK                    pLock,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  const char *                szDescription,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize the RM_OBJECT_HEADER portion of an object.

Arguments:

    pParentObject       - NULL for a root object.
    pObject             - Object to be initialized.
    Sig                 - Signature of the object.
    pLock               - Lock used to serialize access to the object.
    pStaticInfo         - Static informatation about the object.
    szDescription       - A discriptive string (for debugging only) to be associated
                          with this object.
--*/
{
    ENTER("RmInitializeHeader", 0x47dea382)

    NdisZeroMemory(pObject, sizeof(*pObject));

    if (szDescription == NULL)
    {
        szDescription = pStaticInfo->szTypeName;
    }

    TR_VERB(("Initializing header 0x%p (%s)\n", pObject, szDescription));

    pObject->Sig = Sig;
    pObject->pLock = pLock;
    pObject->pStaticInfo = pStaticInfo;
    pObject->szDescription = szDescription;
    SET_RM_STATE(pObject, RMOBJSTATE_ALLOCMASK, RMOBJSTATE_ALLOCATED);

    // The private lock is set to level (UINT)-1, which is the highest
    // possible level.
    //
    RmInitializeLock(&pObject->RmPrivateLock, (UINT)-1);

#if RM_EXTRA_CHECKING
    rmDbgInitializeDiagnosticInfo(pObject, pSR);
#endif //RM_EXTRA_CHECKING

    // Link to parent if non NULL.
    //

    if (pParentObject != NULL)
    {
        pObject->pParentObject = pParentObject;
        pObject->pRootObject =  pParentObject->pRootObject;

    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            pObject,
            pParentObject,
            0x11f25620,
            RM_PRIVATE_ASSOC_LINK_CHILDOF,
            szASSOCFORMAT_LINK_CHILDOF,
            RM_PRIVATE_ASSOC_LINK_PARENTOF,
            szASSOCFORMAT_LINK_PARENTOF,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(pObject, pParentObject, pSR);
    #endif // !RM_EXTRA_CHECKING


    }
    else
    {
        pObject->pRootObject = pObject;
    }


    // We increment the total-ref count once for the allocation. This
    // reference is removed in the call to RmDeallocateObject.
    // Note that this reference is in addition to the reference implicitly
    // added by the call to RmLinkObjects above.
    //
    NdisInterlockedIncrement(&pObject->TotRefs);

#if RM_TRACK_OBJECT_TREE

    // Initialize our list of children.
    //
    InitializeListHead(&pObject->listChildren);

    if (pParentObject != NULL)
    {
        // Insert ourselves into our parent's list of children.
        //
        RMPRIVATELOCK(pParentObject, pSR);
        InsertHeadList(&pParentObject->listChildren, &pObject->linkSiblings);
        RMPRIVATEUNLOCK(pParentObject, pSR);
    }
#endif //  RM_TRACK_OBJECT_TREE

    EXIT()
    return;
}


VOID
RmDeallocateObject(
    IN  PRM_OBJECT_HEADER           pObject,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Logically deallocate the object pObject. We don't actually unlink it from
    its parent or deallocate if there are non zero references to it.

--*/
{
    UINT Refs;
    ENTER("RmDeallocateObject", 0xa87fdf4a)
    TR_INFO(("0x%p (%s)\n", pObject, pObject->szDescription));

    RMPRIVATELOCK(pObject, pSR);

    RETAILASSERTEX(RMISALLOCATED(pObject), pObject);


    // Set state to deallocated.
    //
    SET_RM_STATE(pObject, RMOBJSTATE_ALLOCMASK, RMOBJSTATE_DEALLOCATED);

    RMPRIVATEUNLOCK(pObject, pSR);

    // Remove the ref explicitly added in RmInitializeAllocateObject.
    // rmDerefObject will remove the link to the parent, if any, if the
    // ref count drop to 1.
    //
    rmDerefObject(pObject, pSR);

    EXIT()
}


VOID
RmInitializeLock(
    IN PRM_LOCK pLock,
    IN UINT     Level
    )
/*++

Routine Description:

    Initialize a lock.

Arguments:

    pLock       - Unitialized memory to hold a struct of type RM_LOCK.
    Level       - Level to be associated with this lock. Locks must be acquired
                  in strictly increasing order of the locks' "Level" values.
--*/
{
    ASSERT(Level > 0);
    NdisAllocateSpinLock(&pLock->OsLock);
    pLock->Level = Level;
    
#if RM_EXTRA_CHECKING
    pLock->pDbgInfo = &pLock->DbgInfo;
    NdisZeroMemory(&pLock->DbgInfo, sizeof(pLock->DbgInfo));
#endif //  RM_EXTRA_CHECKING
}


VOID
RmDoWriteLock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Acquire (write lock) lock pLock.

--*/
{
    rmLock(
        pLock,
    #if RM_EXTRA_CHECKING
        0x16323980, // uLocID,
        NULL,
        NULL,
    #endif //RM_EXTRA_CHECKING
        pSR
        );
}


VOID
RmDoUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Unlock lock pLock.

--*/
{
    rmUnlock(
        pLock,
        pSR
        );
}

#if TODO // Currently RmReadLockObject is a macro defined to be RmWriteLockObject.
         // TODO: Verifier need to to also make sure that object hasn't changed state
         //       *while* the object has been read-locked.
VOID
RmReadLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Acquire (read lock)  lock pLock.

--*/
{
    ASSERT(!"Unimplemented");
}
#endif //TODO


VOID
RmWriteLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Acquire (write lock) the lock associated with object pObj.

Arguments:

    pObj        --      Object whose lock to acquire.
    uLocID      --      Arbitrary UINT identifying static location from which this
                        call is made.

--*/
{
    ENTER("RmWriteLockObject", 0x590ed543)
    TR_VERB(("Locking 0x%p (%s)\n", pObj, pObj->szDescription));

    rmLock(
        pObj->pLock,
    #if RM_EXTRA_CHECKING
        uLocID,
        // pObj->pStaticInfo->pfnLockVerifier,
        rmVerifyObjectState,
        pObj,
    #endif //RM_EXTRA_CHECKING
        pSR
        );
    EXIT()
}


VOID
RmUnlockObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Release the lock associated with object pObj.

--*/
{
    ENTER("RmUnLockObject", 0x0307dd84)
    TR_VERB(("Unlocking 0x%p (%s)\n", pObj, pObj->szDescription));

#if RM_EXTRA_CHECKING
    //
    // Make sure that pObject is the object that is *supposed* to be freed.
    //
    ASSERT(pSR->LockInfo.pNextFree[-1].pVerifierContext  == (PVOID) pObj);
#endif // RM_EXTRA_CHECKING

    rmUnlock(
        pObj->pLock,
        pSR
        );

    EXIT()
}


VOID
RmUnlockAll(
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Unlocks all currently held locks as recorded in pSR.
    If the locks are associated with objects, RmUnlockObject is called for
    each of the held locks. Otherwise the raw unlock is performed.

--*/
{
    ENTER("RmUnLockObject", 0x9878be96)
    TR_VERB(("Unlocking all\n"));

    while (pSR->LockInfo.CurrentLevel != 0)
    {
        rmUnlock(
            pSR->LockInfo.pNextFree[-1].pLock,
            pSR
            );
    }

    EXIT()
}


VOID
RmDbgChangeLockScope(
    IN  PRM_OBJECT_HEADER           pPreviouslyLockedObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG                       LocID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    (Debug only)

    Munge things so that the following sequence works:
    Rm[Read|Write]LockObject(pPreviouslyLockedObject, pSR);
    RmChangeLockScope(pPreviouslyLockedObject, pSR);
    RmUnlockObject(pObject, pSR);

    Of course, we require that the two objects have the same lock!

    NOTE: We only support changing scope of the MOST RECENTLY 
    acquired lock.


Arguments:

    pPreviouslyLockedObject     - Currently locked object.
    pObject                     - Object to transfer lock scope to.
    LocID                       - Arbitrary UINT identifying static location from
                                  which this call is made.
--*/
{
    //
    // This is a NOOP unless extra-checking is enabled.
    // TODO: make this inline in the fre build.
    //
#if RM_EXTRA_CHECKING
    RM_LOCKING_INFO * pLI = pSR->LockInfo.pNextFree-1;
    PRM_LOCK        pLock =  pPreviouslyLockedObject->pLock;
    ASSERT(
            pLock->Level == pSR->LockInfo.CurrentLevel
        &&  pLock == pObject->pLock
        &&  pLock == pLI->pLock
        &&  pLI->pVerifierContext == (PVOID) pPreviouslyLockedObject);

    ASSERT(pLI->pfnVerifier == rmVerifyObjectState);

    rmVerifyObjectState(pLock, FALSE, pLI->pVerifierContext, pSR);
    pLI->pVerifierContext   =  pObject;
    pLock->DbgInfo.uLocID   =  LocID;
    rmVerifyObjectState(pLock, TRUE, pLI->pVerifierContext, pSR);
    
#endif // RM_EXTRA_CHECING

}


VOID
RmLinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSr
    )
/*++

Routine Description:

        Link object pObj1 to object pObj2. Basically, this function refs both
        objects.

        OK to call with some locks held, including RmPrivateLock.
        TODO: remove arp pSr above -- we don't need it.
--*/
{
    ENTER("RmLinkObjects", 0xfe2832dd)

    // Maybe we're being too harsh here -- if required, remove this...
    // This could happen where a task is linked at the point where the object
    // is being deallocated, so I'm changing the following  to debug asserts
    // (used to be retail asserts).
    //
    ASSERT(RMISALLOCATED(pObj1));
    ASSERT(RMISALLOCATED(pObj2));

    TR_INFO(("0x%p (%s) linked to 0x%p (%s)\n",
                 pObj1,
                 pObj1->szDescription,
                 pObj2,
                 pObj2->szDescription
                ));

    NdisInterlockedIncrement(&pObj1->TotRefs);
    NdisInterlockedIncrement(&pObj2->TotRefs);

}


VOID
RmLinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  ULONG                       InvAssocID,
    IN  const char *                szInvAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        Same as RmLinkObjects, execpt that (debug only) it also sets up  association
          (pObj2, pObj2->szDescription, AssocID)
        on pObj1, and association
            (pObj1, pObj1->szDescription, InvAssocID)
        on object pObj2

Arguments:

    pObj1                   - Object whose lock to acquire.
    pObj2                   - Object whose lock to acquire.
    LocID                   - Arbitrary UINT identifying static location from which
                              this call is made.
    AssocID                 - ID of the association (see RmDbgAddAssociation) that
                              represents the link from pObj1 to pObj2.
    szAssociationFormat     - Format of the association (see RmDbgAddAssociation)
    InvAssocId              - ID of the inverse association (i.e., represents
                              link from pObj2 to pObj1).
    szInvAssociationFormat  - Format of the inverse association.

--*/
{
    ENTER("RmLinkObjectsEx", 0xef50263b)

#if RM_EXTRA_CHECKING

    RmDbgAddAssociation(
        LocID,                              // Location ID
        pObj1,                              // pObject
        (UINT_PTR) pObj2,                   // Instance1
        (UINT_PTR) (pObj2->szDescription),  // Instance2
        AssocID,                            // AssociationID
        szAssociationFormat,
        pSR
        );

    RmDbgAddAssociation(
        LocID,                              // Location ID
        pObj2,                              // pObject
        (UINT_PTR) pObj1,                   // Instance1
        (UINT_PTR) (pObj1->szDescription),  // Instance2
        InvAssocID,                         // AssociationID
        szInvAssociationFormat,
        pSR
        );
    
#endif // RM_EXTRA_CHECKING

    RmLinkObjects(
        pObj1,
        pObj2,
        pSR
        );
}


VOID
RmUnlinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:
    
    Unlink objects pObj1 and pObj2 (i.e., undo the effect of
    RmLinkObjects(pObj1, pObj2, pSR)).

--*/
{
    ENTER("RmUnlinkObjects", 0x7c64356a)
    TR_INFO(("0x%p (%s) unlinked from 0x%p (%s)\n",
                 pObj1,
                 pObj1->szDescription,
                 pObj2,
                 pObj2->szDescription
                ));
#if RM_EXTRA_CHECKING
    //
    // TODO: remove explict link
    //
#endif // RM_EXTRA_CHECKING

    // Remove link refs.
    //
    rmDerefObject(pObj1, pSR);
    rmDerefObject(pObj2, pSR);
}


VOID
RmUnlinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  ULONG                       InvAssocID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        Same as RmUnlinkObjects, execpt that it also removes the  association
          (pObj2, pObj2->szDescription, AssocID)
        on pObj1, and association
            (pObj1, pObj1->szDescription, InvAssocID)
        object pObj2

Arguments:

        See RmLinkObjectsEx.

--*/
{
    ENTER("RmUnlinkObjectsEx", 0x65d3536c)

#if RM_EXTRA_CHECKING

    RmDbgDeleteAssociation(
        LocID,                              // Location ID
        pObj1,                              // pObject
        (UINT_PTR) pObj2,                   // Instance1
        (UINT_PTR) (pObj2->szDescription),  // Instance2
        AssocID,                            // AssociationID
        pSR
        );

    RmDbgDeleteAssociation(
        LocID,                              // Location ID
        pObj2,                              // pObject
        (UINT_PTR) pObj1,                   // Instance1
        (UINT_PTR) (pObj1->szDescription),  // Instance2
        InvAssocID,                         // AssociationID
        pSR
        );
    
#endif // RM_EXTRA_CHECKING

    RmUnlinkObjects(
        pObj1,
        pObj2,
        pSR
        );
}


VOID
RmLinkToExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Links object pObj to external entity ExternalEntity. Basically, this function
    adds a reference to pObj. In addition (debug only) this function sets up
    an association on pObj that links the external entity to pObj. pObj can be
    linked to ExternalEntity with the specified association ID AssocID only ONCE
    at any particular point of time.

    Once this link is setup, an attempt to deallocate pObj without removing the
    link results in an assertion failure.

    RmUnlinkFromExternalEx is the inverse function.

Arguments:

    pObj                        - Object to be linked to an external entity.

    (following are for debug only...)

    LocID                       - Arbitrary UINT identifying static location from
                                  which this call is made.
    ExternalEntity              - Opaque value representing the external entity.
    AssocID                     - Association ID representing the linkage.
    szAssociationFormat         - Association format for the linkage.

--*/
{
    ENTER("RmLinkToExternalEx", 0x9aeaca74)

#if RM_EXTRA_CHECKING

    RmDbgAddAssociation(
        LocID,                              // Location ID
        pObj,                               // pObject
        (UINT_PTR) ExternalEntity,          // Instance1
        (UINT_PTR) 0,                       // Instance2 (unused)
        AssocID,                            // AssociationID
        szAssociationFormat,
        pSR
        );

#endif // RM_EXTRA_CHECKING

    RmLinkToExternalFast(pObj);

    EXIT()
}


VOID
RmUnlinkFromExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Inverse of RmUnlinkFromExternalEx -- removes the link set up between
    pObj and ExternalEntity.

Arguments:

    See RmLinkToExternalEx.

--*/
{
    ENTER("RmUnlinkFromExternalEx", 0x9fb084c3)

#if RM_EXTRA_CHECKING

    RmDbgDeleteAssociation(
        LocID,                              // Location ID
        pObj,                               // pObject
        (UINT_PTR) ExternalEntity,          // Instance1
        (UINT_PTR) 0,                       // Instance2 (unused)
        AssocID,                            // AssociationID
        pSR
        );

#endif // RM_EXTRA_CHECKING

    RmUnlinkFromExternalFast(pObj);

    EXIT()
}


VOID
RmLinkToExternalFast( // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    )
/*++

Routine Description:

    Fast version of RmLinkToExternalEx -- same behavior in retail. No associations
    are setup.

Arguments:

    See RmLinkToExternalEx.

--*/
{
    NdisInterlockedIncrement(&pObj->TotRefs);
}


VOID
RmUnlinkFromExternalFast(   // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    )
/*++
Routine Description:

    Inverse of RmUnlinkFromExternalFast -- removes the link set up between
    pObj and ExternalEntity.

    TODO -- we need a fast implementation for the case that the object is
    not going to go away. For now we actually declare a stack record here each
    time, becaues rmDerefObject wants one! Bad bad.

Arguments:

    See RmLinkToExternalFast.

--*/
{
    RM_DECLARE_STACK_RECORD(sr)
    rmDerefObject(pObj, &sr);
}


VOID
RmTmpReferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Add a temporary reference to object pObj.
    (Debug only) Increments the count of tmprefs maintained in pSR.

--*/
{
    ENTER("RmTmpReferenceObject", 0xdd981024)
    TR_VERB(("0x%p (%s)\n", pObj, pObj->szDescription));

    ASSERT(RM_OBJECT_IS_ALLOCATED(pObj));

    pSR->TmpRefs++;

    NdisInterlockedIncrement(&pObj->TotRefs);
}


VOID
RmTmpDereferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Remove a temporary reference to object pObj.
    (Debug only) Decrements the count of tmprefs maintained in pSR.

--*/
{
    ENTER("RmTmpDereferenceObject", 0xd1630c11)
    TR_VERB(("0x%p (%s)\n", pObj, pObj->szDescription));

    RETAILASSERTEX(pSR->TmpRefs>0, pSR);
    pSR->TmpRefs--;

    rmDerefObject(pObj, pSR);
}


VOID
RmDbgAddAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Entity1,
    IN  ULONG_PTR                   Entity2,
    IN  ULONG                       AssociationID,
    IN  const char *                szFormatString, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    )
/*++


Routine Description:

        Add an arbitrary association, for debugging purposes, under
        object pObject. The association is defined by the triple
        (Entity1, Entity2, AssociationID) -- only ONE such tuple may
        be registered at any time with object pParentObject.
        Note: It is valid for both of the following to be registered at the same
        time: (a, b, 1) and (a, b, 2)

        No association should exist at the point the object is deleted.

Arguments:

        LocID           -   Arbitrary ID, typically representing the source location
                        -   from which this function is called.
        pObject         -   Object to add the association.
        Entity1         -   The 1st entity making up the association. May be NULL.
        Entity2         -   The 2nd entity making up the association. May be NULL.
        AssociationID   -   ID defining the association. 
                            NOTE: AssociationID must not have the high-bit set.
                            Associations with the high bit set are reserved for
                            internal use of the Rm API implementation.

--*/
{
#if RM_EXTRA_CHECKING
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;
    ENTER("RmDbgAddAssociation", 0x512192eb)

    if (pDiagInfo)
    {

        //
        // Allocate an association and  enter it into the hash table.
        // Assert if it already exists.
        //

        RM_PRIVATE_DBG_ASSOCIATION *pA;
        RM_ALLOCSTRUCT(pA, MTAG_DBGINFO); // TODO use lookaside lists.
    
        if (pA == NULL)
        {
            //
            // Allocation failed. Record this fact, so that
            // RmDbgDeleteAssociation doesn't assert
            // if an attempt is made to remove an assertion which doesn't exist.
            //
            NdisAcquireSpinLock(&pDiagInfo->OsLock);
            pDiagInfo->AssociationTableAllocationFailure = TRUE;
            NdisReleaseSpinLock(&pDiagInfo->OsLock);
        }
        else
        {
            BOOLEAN fFound;
            PRM_HASH_LINK *ppLink;
            RM_ZEROSTRUCT(pA);

            pA->Entity1 = Entity1;
            pA->Entity2 = Entity2;
            pA->AssociationID = AssociationID;

            if (szFormatString == NULL)
            {
                // Put in the default description format string.
                //
                szFormatString = "    Association (E1=0x%x, E2=0x%x, T=0x%x)\n";
            }

            TR_VERB((" Obj:0x%p (%s)...\n", pObject, pObject->szDescription));
            TRACE0(TL_INFO,((char*)szFormatString, Entity1, Entity2, AssociationID));

            pA->szFormatString = szFormatString;

            NdisAcquireSpinLock(&pDiagInfo->OsLock);
    
            fFound = RmLookupHashTable(
                            &pDiagInfo->AssociationTable,
                            &ppLink,
                            pA      // We use pA as the key.
                            );
    
            if (fFound)
            {
                ASSERTEX(
                    !"Association already exists:",
                    CONTAINING_RECORD(*ppLink, RM_PRIVATE_DBG_ASSOCIATION, HashLink)
                    );
                RM_FREE(pA);
                pA = NULL;
            }
            else
            {
                //
                // Enter the association into the hash table.
                //
    
                RmAddHashItem(
                    &pDiagInfo->AssociationTable,
                    ppLink,
                    &pA->HashLink,
                    pA      // We use pA as the key
                    );
            }
            NdisReleaseSpinLock(&pDiagInfo->OsLock);

            // Now, just for grins, make a note of this in the object's log.
            // WARNING: Although pEntity1/2 may contain pointers, 
            // we expect the the format string is such that if there are any
            // references to regular or unicode strings, those strings will
            // be valid for the life of the object (typically these strings
            // are statically-allocated strings).
            //
            // We  COULD use the more conservative format string to display the
            // log entry, but it's useful to have the information displayed
            // properly.
            //
            // Note-- we could also do different things depending on the type
            // of association.
            //
            #if 0 // conservative format
            RmDbgLogToObject(
                    pObject,
            "    Add association (E1=0x%x, E2=0x%x, T=0x%x)\n",
                    Entity1,
                    Entity2,
                    AssociationID,
                    0, // Param4  // (UINT_PTR) szFormatString,
                    NULL,
                    NULL
                    );
            #else // aggresive format
            {
                #define szADDASSOC "    Add assoc:"

#if OBSOLETE        //  This doesn't work because rgMungedFormat is on the stack!
                char rgMungedFormat[128];
                UINT uLength;
                rgMungedFormat[0]=0;
                rmSafeAppend(rgMungedFormat, szADDASSOC, sizeof(rgMungedFormat));
                uLength = rmSafeAppend(
                            rgMungedFormat,
                            szFormatString,
                            sizeof(rgMungedFormat)
                            );
                if (uLength && rgMungedFormat[uLength-1] != '\n')
                {
                    rgMungedFormat[uLength-1] = '\n';
                }
                RmDbgLogToObject(
                        pObject,
                        rgMungedFormat,
                        Entity1,
                        Entity2,
                        AssociationID,
                        0,
                        NULL,
                        NULL
                        );
#endif // OBSOLETE

                RmDbgLogToObject(
                        pObject,
                        szADDASSOC,
                        (char*)szFormatString,
                        Entity1,
                        Entity2,
                        AssociationID,
                        0,
                        NULL,
                        NULL
                        );
            }
            #endif // aggressive format
        }
    }

    EXIT()
#endif // RM_EXTRA_CHECKING
}


VOID
RmDbgDeleteAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Entity1,
    IN  ULONG_PTR                   Entity2,
    IN  ULONG                       AssociationID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        Removes the previously-added association (Entity1, Entity2, Association)
        from object pObject. See the description of RmDbgAddAssociation for
        details.

Arguments:

        See RmDbgAddAssociation.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmDbgDelAssociation", 0x8354559f)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    if (pDiagInfo)
    {
        BOOLEAN fFound;
        PRM_HASH_LINK *ppLink;
        RM_PRIVATE_DBG_ASSOCIATION TrueKey;

        // Only the following 3 fields of TrueKey make up the key
        //
        TrueKey.Entity1 = Entity1;
        TrueKey.Entity2 = Entity2;
        TrueKey.AssociationID = AssociationID;

        NdisAcquireSpinLock(&pDiagInfo->OsLock);

        fFound = RmLookupHashTable(
                        &pDiagInfo->AssociationTable,
                        &ppLink,
                        &TrueKey
                        );

        if (fFound)
        {
            RM_PRIVATE_DBG_ASSOCIATION *pA =
                    CONTAINING_RECORD(*ppLink, RM_PRIVATE_DBG_ASSOCIATION, HashLink);

            TR_VERB((" Obj:0x%p (%s)...\n", pObject, pObject->szDescription));
            TRACE0(TL_INFO,
                ((char*)pA->szFormatString,
                 pA->Entity1,
                 pA->Entity2,
                 pA->AssociationID));

            //
            // Now, just for grins, make a note of this in the oject's log.
            // Note that of pEntity1/2 contain pointers, we can't expect them
            // to be valid for as long as the object is alive, so we use
            // the more conservative format string to display the log entry.
            //
            //  TODO/BUGUG -- see comments under RmDbgAddAssociation
            //                  about the risk of directly passing szFormat
            //
            
        #if 0 // conservative
                RmDbgLogToObject(
                        pObject,
                        NULL,
                "    Deleted Association (E1=0x%x, E2=0x%x, T=0x%x)\n",
                        pA->Entity1,
                        pA->Entity2,
                        pA->AssociationID,
                        0,
                        NULL,
                        NULL
                        );
        #else // aggressive
                #define szDELASSOC "    Del assoc:"
                RmDbgLogToObject(
                        pObject,
                        szDELASSOC,
                        (char*) pA->szFormatString,
                        pA->Entity1,
                        pA->Entity2,
                        pA->AssociationID,
                        0, // Param4  // (UINT_PTR) szFormatString,
                        NULL,
                        NULL
                        );
        #endif // aggressive

            //
            // Remove the association and free it.
            //

            RM_PRIVATE_UNLINK_NEXT_HASH( &pDiagInfo->AssociationTable, ppLink );

            RM_FREE(pA);
        }
        else
        {
            if  (!pDiagInfo->AssociationTableAllocationFailure)
            {
                ASSERT(!"Association doesn't exist");
            }
        }
        NdisReleaseSpinLock(&pDiagInfo->OsLock);


    }
    EXIT()
#endif // RM_EXTRA_CHECKING
}


VOID
RmDbgPrintAssociations(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    (Debug only) Dumps the associations on object pObject.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmPrintAssociations", 0x8354559f)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    if (pDiagInfo)
    {
        TR_INFO((
            "Obj 0x%p (%s):\n",
            pObject,
            pObject->szDescription
            ));

        NdisAcquireSpinLock(&pDiagInfo->OsLock);

        RmEnumHashTable(
                    &pDiagInfo->AssociationTable,
                    rmDbgPrintOneAssociation,   // pfnEnumerator
                    pObject,        // context
                    pSR
                    );

        NdisReleaseSpinLock(&pDiagInfo->OsLock);
    }
    EXIT()
#endif // RM_EXTRA_CHECKING
}


//
// Diagnostic per-object logging.
//

VOID
RmDbgLogToObject(
    IN  PRM_OBJECT_HEADER       pObject,
    IN  char *                  szPrefix,       OPTIONAL
    IN  char *                  szFormatString,
    IN  UINT_PTR                Param1,
    IN  UINT_PTR                Param2,
    IN  UINT_PTR                Param3,
    IN  UINT_PTR                Param4,
    IN  PFN_DBG_DUMP_LOG_ENTRY  pfnDumpEntry,   OPTIONAL
    IN  PVOID                   pvBuf           OPTIONAL
    )
/*++

Routine Description:

    Make one log entry in pObject's log.

    TODO: See notes.txt  entry "03/07/1999 ... Registering root objects with RM"
    on how we will find the deallocator function fo pvBuf. For now we simply
    use NdisFreeMemory.

    TODO: need to implement trimming of log when we reach a maximum. Currently we
    just stop logging. 

Arguments:
        pfnDumpEntry    - Function to be used for dumping the log.
                          If NULL, a default function is used, which interprets
                          szFormatString as the standard printf format string.

        szFormatString  - Format string for log display -- 1st arg to pfnDumpEntry

        Param1-4        - Remaining args to pfnDumpEntry;

        pvBuf           - If non-NULL, piece of memory to be freed when the log entry
                          is freed.

        NOTE:   If Param1-4 contain pointers, the memory they refer to is assumed
        to be valid for as long as the object is alive. If the entities being logged
        may go away before the object is deallocated, the caller should
        allocate a buffer to hold a copy of the entities, and pass the pointer to
        that buffer as pvBuf.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmDbgLogToObject", 0x2b2015b5)

    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    if (pDiagInfo && RmGlobals.NumGlobalLogEntries < 4000)
    {
        RM_DBG_LOG_ENTRY *pLogEntry;

        NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);

        pLogEntry = rmDbgAllocateLogEntry();

        if (pLogEntry != NULL)
        {
            if (pfnDumpEntry == NULL)
            {
                pfnDumpEntry = rmDefaultDumpEntry;
            }

            pLogEntry->pObject      = pObject;
            pLogEntry->pfnDumpEntry = pfnDumpEntry;
            pLogEntry->szPrefix = szPrefix;
            pLogEntry->szFormatString = szFormatString;
            pLogEntry->Param1 = Param1;
            pLogEntry->Param2 = Param2;
            pLogEntry->Param3 = Param3;
            pLogEntry->Param4 = Param4;
            pLogEntry->pvBuf  = pvBuf;

            // Insert item at head of object log.
            //
            InsertHeadList(&pDiagInfo->listObjectLog, &pLogEntry->linkObjectLog);

            // Insert item at head of global log.
            //
            InsertHeadList(&RmGlobals.listGlobalLog, &pLogEntry->linkGlobalLog);


            pDiagInfo->NumObjectLogEntries++;
            RmGlobals.NumGlobalLogEntries++;
        }

        NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);

    #if 0
        pfnDumpEntry(
                szFormatString,
                Param1,
                Param2,
                Param3,
                Param4
                );
    #endif // 0
    }
    else
    {
        // TODO -- free pvBuf if NON NULL.
    }
    EXIT()
#endif // RM_EXTRA_CHECKING

}


VOID
RmDbgPrintObjectLog(
    IN PRM_OBJECT_HEADER pObject
    )
/*++

Routine Description:

    (Debug only) Dumps object pObject's log.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmPrintObjectLog", 0xe06507e5)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    TR_INFO((" pObj=0x%p (%s)\n", pObject, pObject->szDescription));


    if (pDiagInfo != NULL)
    {
        LIST_ENTRY          *pLink=NULL;
        LIST_ENTRY *        pObjectLog =  &pDiagInfo->listObjectLog;
        
        NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);
    
        for(
            pLink =  pObjectLog->Flink;
            pLink != pObjectLog;
            pLink = pLink->Flink)
        {
            RM_DBG_LOG_ENTRY    *pLE;
    
            pLE = CONTAINING_RECORD(pLink,  RM_DBG_LOG_ENTRY,  linkObjectLog);

            if (pLE->szPrefix != NULL)
            {
                // Print the prefix.
                DbgPrint(pLE->szPrefix);
            }
    
            // Call the dump function for this entry.
            //
            // 
            pLE->pfnDumpEntry(
                            pLE->szFormatString,
                            pLE->Param1,
                            pLE->Param2,
                            pLE->Param3,
                            pLE->Param4
                            );
    
        }
        NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);
    }
    EXIT()

#endif // RM_EXTRA_CHECKING
}


VOID
RmDbgPrintGlobalLog(VOID)
/*++

Routine Description:

    (Debug only) Dumps the global log (which contains entries from all object's
    logs.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmPrintGlobalLog", 0xe9915066)
    LIST_ENTRY          *pLink=NULL;
    LIST_ENTRY          *pGlobalLog =  &RmGlobals.listGlobalLog;

    TR_INFO(("Enter\n"));

    NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);

    for(
        pLink =  pGlobalLog->Flink;
        pLink != pGlobalLog;
        pLink = pLink->Flink)
    {
        RM_DBG_LOG_ENTRY    *pLE;

        pLE = CONTAINING_RECORD(pLink,  RM_DBG_LOG_ENTRY,  linkGlobalLog);

        // Print the ptr and name of the object whose entry this is...
        //
        DbgPrint(
            "Entry for 0x%p (%s):\n",
            pLE->pObject,
            pLE->pObject->szDescription
            );

        if (pLE->szPrefix != NULL)
        {
            // Print the prefix.
            DbgPrint(pLE->szPrefix);
        }

        // Call the dump function for this entry.
        //
        // 
        pLE->pfnDumpEntry(
                        pLE->szFormatString,
                        pLE->Param1,
                        pLE->Param2,
                        pLE->Param3,
                        pLE->Param4
                        );

    }
    NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);

    EXIT()

#endif // RM_EXTRA_CHECKING
}


RM_STATUS
RmLoadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    TODO This function is going away...

--*/
{
    PRM_STATIC_OBJECT_INFO pSI = pObj->pStaticInfo;
    RM_STATUS              Status;

    // The resource ID should be less than number of bits in the ResourceMap
    //
    ASSERT(GenericResourceID < 8*sizeof(pObj->ResourceMap));


    RMPRIVATELOCK(pObj, pSR);

    do
    {
        UINT ResFlag = 1<<GenericResourceID;

        if (!RMISALLOCATED(pObj))
        {
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        if (pSI->NumResourceTableEntries <= GenericResourceID)
        {
            ASSERTEX(!"Invalid GenericResourceID", pObj);
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        // The resource entry indexed must have its ID == GenericResourceID
        //
        //
        if (pSI->pResourceTable[GenericResourceID].ID != GenericResourceID)
        {
            ASSERTEX(!"Resource ID doesn't match table entry", pObj);
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        if ( ResFlag & pObj->ResourceMap)
        {
            ASSERTEX(!"Resource already allocated", pObj);
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        pObj->ResourceMap |= ResFlag;

        RMPRIVATEUNLOCK(pObj, pSR);

        Status = pSI->pResourceTable[GenericResourceID].pfnHandler(
                            pObj,
                            RM_RESOURCE_OP_LOAD,
                            NULL, // pvUserParams (unused)
                            pSR
                            );

        if (FAIL(Status))
        {
            // Clear the resource map bit on failure.
            //
            RMPRIVATELOCK(pObj, pSR);
            ASSERTEX(ResFlag & pObj->ResourceMap, pObj);
            pObj->ResourceMap &= ~ResFlag;
            RMPRIVATEUNLOCK(pObj, pSR);
        }

    } while (FALSE);

    return Status;
}


VOID
RmUnloadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    TODO This function is going away...

--*/
{
    PRM_STATIC_OBJECT_INFO pSI = pObj->pStaticInfo;
    RM_STATUS              Status;

    // The resource ID should be less than number of bits in the ResourceMap
    //
    ASSERT(GenericResourceID < 8*sizeof(pObj->ResourceMap));

    RMPRIVATELOCK(pObj, pSR);

    do
    {
        UINT ResFlag = 1<<GenericResourceID;

        if (pSI->NumResourceTableEntries <= GenericResourceID)
        {
            ASSERTEX(!"Invalid GenericResourceID", pObj);
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        if ( !(ResFlag & pObj->ResourceMap))
        {
            ASSERTEX(!"Resource not allocated", pObj);
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        // Clear the resource flag.
        //
        pObj->ResourceMap &= ~ResFlag;

        RMPRIVATEUNLOCK(pObj, pSR);

        pSI->pResourceTable[GenericResourceID].pfnHandler(
                            pObj,
                            RM_RESOURCE_OP_UNLOAD,
                            NULL, // pvUserParams (unused)
                            pSR
                            );

    } while (FALSE);

}


VOID
RmUnloadAllGenericResources(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
    Synchronously unload all previously loaded resources for this object,
    in reverse order to which they were loaded.

    TODO this function is going away...
--*/
{
    PRM_STATIC_OBJECT_INFO pSI = pObj->pStaticInfo;
    RM_STATUS              Status;
    UINT                   u;

    RMPRIVATELOCK(pObj, pSR);

    for(u = pSI->NumResourceTableEntries;
        u && pObj->ResourceMap;
        u--)
    {
        UINT  ResID = u-1;
        UINT ResFlag = 1<<ResID;
        if ( !(ResFlag & pObj->ResourceMap))
        {
            continue;
        }

        if (pSI->NumResourceTableEntries <= ResID)
        {
            ASSERTEX(!"Corrupt ResourceMap", pObj);
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }


        // Clear the resource flag.
        //
        pObj->ResourceMap &= ~ResFlag;

        RMPRIVATEUNLOCK(pObj, pSR);

        pSI->pResourceTable[ResID].pfnHandler(
                            pObj,
                            RM_RESOURCE_OP_UNLOAD,
                            NULL, // pvUserParams (unused)
                            pSR
                            );

        RMPRIVATELOCK(pObj, pSR);

    }

    ASSERTEX(!pObj->ResourceMap, pObj);

    RMPRIVATEUNLOCK(pObj, pSR);

}


VOID
RmInitializeGroup(
    IN  PRM_OBJECT_HEADER           pOwningObject,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  PRM_GROUP                   pGroup,
    IN  const char*                 szDescription,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize a group structure.

Arguments:

    pOwningObject   - Object that will own the group.
    pStaticInfo     - Static information about objects IN the group.
    pGroup          - Uninitialized memory that is to hold the group structure. It
                      will be initialized on return from this function.
    szDescription   - (Debug only) descriptive name for this group.

    TODO: make pStaticInfo const.

--*/
{
    NdisZeroMemory(pGroup, sizeof(*pGroup));

    RMPRIVATELOCK(pOwningObject, pSR);

    do
    {
        if (!RMISALLOCATED(pOwningObject))
        {
            ASSERT(!"pObject not allocated");
            break;
        }

        if (pStaticInfo->pHashInfo == NULL)
        {
            ASSERT(!"NULL pHashInfo");
            // Static info MUST have non-NULL pHashInfo in order
            // for it to be used for groups.
            //
            break;
        }

    
        RmInitializeHashTable(
            pStaticInfo->pHashInfo,
            pOwningObject,  // pAllocationContext
            &pGroup->HashTable
            );


        pGroup->pOwningObject = pOwningObject;
        pGroup->pStaticInfo = pStaticInfo;
        pGroup->szDescription = szDescription;

        NdisAllocateSpinLock(&pGroup->OsLock);
        pGroup->fEnabled = TRUE;

    #if RM_EXTRA_CHECKING
        RmDbgAddAssociation(
            0xc0e5362f,                         // Location ID
            pOwningObject,                      // pObject
            (UINT_PTR) pGroup,                  // Instance1
            (UINT_PTR) (pGroup->szDescription), // Instance2
            RM_PRIVATE_ASSOC_INITGROUP,         // AssociationID
            szASSOCFORMAT_INITGROUP,            // szAssociationFormat
            pSR
            );
    #endif // RM_EXTRA_CHECKING

    } while (FALSE);

    RMPRIVATEUNLOCK(pOwningObject, pSR);

}


VOID
RmDeinitializeGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Deinitialize group structure pGroup. Must only be called when there are no
    members in the group.

--*/
{

#if RM_EXTRA_CHECKING
    RmDbgDeleteAssociation(
        0x1486def9,                         // Location ID
        pGroup->pOwningObject,              // pObject
        (UINT_PTR) pGroup,                  // Instance1
        (UINT_PTR) (pGroup->szDescription), // Instance2
        RM_PRIVATE_ASSOC_INITGROUP,         // AssociationID
        pSR
        );
#endif // RM_EXTRA_CHECKING

    NdisAcquireSpinLock(&pGroup->OsLock);

    RmDeinitializeHashTable(&pGroup->HashTable);

    NdisReleaseSpinLock(&pGroup->OsLock);
    NdisFreeSpinLock(&pGroup->OsLock);
    NdisZeroMemory(pGroup, sizeof(*pGroup));

}


RM_STATUS
RmLookupObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  ULONG                       Flags, // create, remove, lock
    IN  PVOID                       pvKey,
    IN  PVOID                       pvCreateParams,
    OUT PRM_OBJECT_HEADER *         ppObject,
    OUT INT *                       pfCreated, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    TODO: split this into a pure lookup and a lookupand/orcreate function..

    Lookup and/or create an object in the specified group.


#if OBSOLETE // Must allow fCreate w/o locking -- see notes.txt  entry:
               //   03/04/1999   JosephJ  Problems with deadlock when using Groups.
        MUST ONLY be NON-NULL if the fLOCKED flag is specified.
        Why? Because if the lock is not held on exit, it would be possible
        for someone else to pick up the object in the freshly-created state.
        We want to discourage that situation.
#endif // OBSOLETE

         Typically the caller specifes the
        fRM_LOCKED|fRM_CREATE flags as well as non-null pfCreated. On return, if
        *pfCreated is TRUE, the caller then would go on to do some more
        initialization before releasing the lock.

        A new important point is that if the user requests that the object be 
        created and locked, then the RM no longer guranteees that the create and 
        lock will happen in the context of holding the GroupLock
        

        FUNDAMENTAL ASSUMPTION: The key of an object doesn't change once
        it's in the group. Based on this assumption, we don't try to claim
        the object's lock when looking for the object with a matching key.

Arguments:

    pGroup          - Group in which to lookup/create object.
    Flags           - One or more of fRM_LOCKED, fRM_CREATE, fRM_NEW
    pvKey           - Key used to lookup object.
    pvCreateParams  - If object is to be created, parameters to be passed to the
                      object's creation function.
    ppObject        - Place to store pointer to the found/created object.
    pfCreated       - If non-NULL, *pfCreated is set to TRUE IFF the object was
                      created.

Return Value:

    NDIS_STATUS_SUCCESS     If the operation succeeded.
    NDIS_STATUS_RESOURCES   If a new object could not be created.
    NDIS_STATUS_RFAILURE    If the object was not found.

--*/
{
    RM_STATUS           Status          = NDIS_STATUS_FAILURE;
    BOOLEAN             fUnlockOutOfOrder = FALSE;
    PRM_OBJECT_HEADER   pOwningObject   = pGroup->pOwningObject;
    PRM_OBJECT_HEADER   pObject;

#if DBG
    KIRQL EntryIrql =  KeGetCurrentIrql();
#endif // DBG
    ENTER("RmLookupObjectInGroup",  0xd2cd6379)

    ASSERT(pOwningObject!=NULL);
    // OBSOLETE -- see comments above: ASSERT(pfCreated==NULL || (Flags&RM_LOCKED));

    if (pfCreated != NULL) *pfCreated = FALSE;

    NdisAcquireSpinLock(&pGroup->OsLock); 
    
    do
    {
        BOOLEAN fFound;
        PRM_HASH_LINK *ppLink = NULL;

        if (!RMISALLOCATED(pGroup->pOwningObject)) break;

        if (pGroup->fEnabled != TRUE)   break;

        fFound = RmLookupHashTable(
                        &pGroup->HashTable,
                        &ppLink,
                        pvKey
                        );

        if (fFound)
        {
            if (Flags & RM_NEW)
            {
                // Caller wanted us to created a new object, but the object already
                // exists, so we fail...
                //
                // TODO: return appropriate error code.
                //
                break;
            }

            // Go from hash-link to object.
            //  TODO: once HashLink goes away, need some other way to get
            //       to the object.
            //
            pObject = CONTAINING_RECORD(*ppLink, RM_OBJECT_HEADER, HashLink);
            ASSERT(pObject->pStaticInfo == pGroup->pStaticInfo);

        }
        else
        {
            if (!(Flags & RM_CREATE))
            {
                // Couldn't find it, and caller doesn't want us to create one, so
                // we fail...
                break;
            }
            
            // Create object...
            //
            ASSERTEX(pGroup->pStaticInfo->pfnCreate!=NULL, pGroup);
            pObject = pGroup->pStaticInfo->pfnCreate(
                                                pOwningObject,
                                                pvCreateParams,
                                                pSR
                                                );
            
            if (pObject == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            TR_INFO((
                "Created 0x%p (%s) in Group 0x%p (%s)\n",
                pObject,
                pObject->szDescription,
                pGroup,
                pGroup->szDescription
                ));

            ASSERTEX(RMISALLOCATED(pObject), pObject);

            // Now enter it into the hash table.
            //
            RmAddHashItem(
                &pGroup->HashTable,
                ppLink,
                &pObject->HashLink,
                pvKey
                );
            if (pfCreated != NULL)
            {
                *pfCreated = TRUE;
            }

        }

        RmTmpReferenceObject(pObject, pSR);

        Status = NDIS_STATUS_SUCCESS;

    } while(FALSE);

    NdisReleaseSpinLock(&pGroup->OsLock);

    // Do we need to look the object before returning it
    // to the user
    if ((!FAIL(Status)) && (Flags & RM_LOCKED))
    {
        RmWriteLockObject(
                pObject,   
            #if RM_EXTRA_CHECKING
                0x6197fdda,
            #endif //RM_EXTRA_CHECKING
                pSR
                );

        if  (!RMISALLOCATED(pObject))
        {
            // We don't allow this...
            RmUnlockObject(
                pObject,
                pSR
                );
        }
    }
    
    if (FAIL(Status))
    {
        *ppObject = NULL;
    }
    else
    {
        *ppObject = pObject;
    }

#if DBG
    {
        KIRQL ExitIrql =  KeGetCurrentIrql();
        TR_VERB(("Exiting. EntryIrql=%lu, ExitIrql = %lu\n", EntryIrql, ExitIrql));
    }
#endif //DBG

    return Status;
}


RM_STATUS
RmGetNextObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pCurrentObject, // OPTIONAL
    OUT PRM_OBJECT_HEADER *         ppNextObject,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Get the 1st object in group (if pCurrentObject == NULL), or the object
    "after" pCurrentObject (if pCurrentObject != NULL).
    
    The definition of "after" is hidden -- the only guarantee is if this
    function is 1st called with NULL pCurrentObject and subsequently with
    pCurrentObject set to the value previously returned in ppNextObject, until
    the function returns NDIS_STATUS_FAILURE, all objects in the group will
    be returned once and only once. This guarantee is only valid if no objects
    are added or removed during the enumeration process.

    On success, the "next" object is tmpref'd a pointer to it is saved in
    *ppNextObject.

Arguments:

    pGroup          - The group
    pCurrentObject  - (OPTIONAL) An object in the group.
    ppNextObject    - Place to return the the object  "after" pCurrentObject
                      (see RoutineDescription for details.)
                     

Return Value:

    NDIS_STATUS_SUCCESS if we could find a "next" object.
    NDIS_STATUS_FAILURE otherwise

--*/
{
    RM_STATUS           Status          = NDIS_STATUS_FAILURE;
    PRM_OBJECT_HEADER   pOwningObject   = pGroup->pOwningObject;
    PRM_OBJECT_HEADER   pObject;

    ENTER("RmGetNextObjectInGroup",  0x11523db7)

    ASSERT(pOwningObject!=NULL);

    NdisAcquireSpinLock(&pGroup->OsLock);

    do
    {
        BOOLEAN fFound;
        PRM_HASH_LINK pLink = NULL;
        PRM_HASH_LINK pCurrentLink = NULL;

        if (!RMISALLOCATED(pGroup->pOwningObject)) break;

        if (pGroup->fEnabled != TRUE)   break;

        if (pCurrentObject != NULL)
        {
            pCurrentLink = &pCurrentObject->HashLink;
        }

        fFound =  RmNextHashTableItem(
                        &pGroup->HashTable,
                        pCurrentLink,   // pCurrentLink
                        &pLink  // pNextLink
                        );

        if (fFound)
        {

            // Go from hash-link to object.
            //  TODO: once HashLink goes away, need some other way to get
            //       to the object.
            //
            pObject = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
            ASSERT(pObject->pStaticInfo == pGroup->pStaticInfo);

        }
        else
        {
            // Couldn't find one.
            // we fail...
            break;
        }

        RmTmpReferenceObject(pObject, pSR);

        Status = NDIS_STATUS_SUCCESS;

    } while(FALSE);

    NdisReleaseSpinLock(&pGroup->OsLock);

    if (FAIL(Status))
    {
        *ppNextObject = NULL;
    }
    else
    {
        *ppNextObject = pObject;
    }

    return Status;
}


VOID
RmFreeObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  struct _RM_TASK             *pTask, OPTIONAL  // Unused. TODO: remove this.
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Remove object pObject from group pGroup and deallocate pObject.

--*/
{
    ENTER("RmFreeObjectInGroup",  0xd2cd6379)
    PRM_OBJECT_HEADER pOwningObject = pGroup->pOwningObject;

    ASSERTEX(pOwningObject!=NULL, pGroup);
    ASSERTEX(pTask==NULL, pGroup);

    NdisAcquireSpinLock(&pGroup->OsLock);

    // TODO: what if at this time, someone else is doing FreeAllObjects in Group?
    //
    TR_INFO((
        "Freeing 0x%p (%s) in Group 0x%p (%s)\n",
        pObject,
        pObject->szDescription,
        pGroup,
        pGroup->szDescription
        ));

    ASSERTEX(RMISALLOCATED(pObject), pObject);

    RmRemoveHashItem(
            &pGroup->HashTable,
            &pObject->HashLink
            );

    NdisReleaseSpinLock(&pGroup->OsLock);

    // Deallocate the object.
    //
    RmDeallocateObject(
                pObject,
                pSR
                );

    EXIT()
}


VOID
RmFreeAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  struct _RM_TASK             *pTask, OPTIONAL // Unused. TODO: remove this.
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Remove and deallocate all object in pGroup.

--*/
{
    PRM_HASH_LINK *ppLink, *ppLinkEnd;
    NdisAcquireSpinLock(&pGroup->OsLock);
    if (pGroup->fEnabled)
    {
        pGroup->fEnabled = FALSE;
    }
    else
    {
        NdisReleaseSpinLock(&pGroup->OsLock);
        return;                                 // EARLY RETURN
    }

    //
    // With fEnabled set to FALSE by us, we expect the following:
    // (a) pHashTable->pTable is going to stay the same size.
    // (b) No items are going to be added or removed by anyone else.
    //

    ppLink      = pGroup->HashTable.pTable;
    ppLinkEnd   = ppLink + pGroup->HashTable.TableLength;

    for ( ; ppLink < ppLinkEnd; ppLink++)
    {
        while (*ppLink != NULL)
        {
            PRM_HASH_LINK pLink =  *ppLink;
            PRM_OBJECT_HEADER pObj;
    
            // Remove it from the bucket list.
            //
            *ppLink = pLink->pNext;
            pLink->pNext = NULL;
            pGroup->HashTable.NumItems--;
    
            NdisReleaseSpinLock(&pGroup->OsLock);
    
            pObj = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
            ASSERT(pObj->pStaticInfo == pGroup->pStaticInfo);
    
            // Deallocate the object.
            //
            RmDeallocateObject(
                        pObj,
                        pSR
                        );
        
            NdisAcquireSpinLock(&pGroup->OsLock);
        }
    }

    NdisReleaseSpinLock(&pGroup->OsLock);
}


VOID
RmUnloadAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    PFN_RM_TASK_ALLOCATOR           pfnUnloadTaskAllocator,
    PFN_RM_TASK_HANDLER             pfnUnloadTaskHandler,
    PVOID                           pvUserParam,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  UINT                        uTaskPendCode,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Stops new objects from being added and unloads(see below) all objects
    currently in the group.

    "Unload" consists of allocating and starting a pfnUnloadTaskHask task
    on each object. The unload task is responsible for
    removing and deallocating the object from the group.

    If pTask if non-NULL, it will be resumed on completion of the unload.
    Otherwise, this function will BLOCK until the unload is complete.

Arguments:

    pGroup                  - Group to unload.
    pfnUnloadTaskAllocator  - Use to allocate the object-unload tasks.
    pfnTaskAllocator        - Function used to allocate the unload task.
    pfnUnloadTaskHandler    - The handler of the unload task
    pvUserParam             - Task creation user-param. 
                            WARNING: this param must be valid for the duration
                            of the unload process, not just until this
                            function returns. Of course, if pTask is NULL,
                            the two cases are equivalent.
    pTask                   - (OPTIONAL) Task to resume when unload is complete.
                            If NULL, this function will block until the
                            unload is complete.
    uTaskPendCode           - (OPTIONAL) PendCode to use when resuming pTask.
        
--*/
{
    PRM_TASK    pUnloadTask;
    NDIS_STATUS Status;

    NdisAcquireSpinLock(&pGroup->OsLock);

    //
    // We don't check if there is already an unload task active for this group.
    // Instead we go ahead and allocate and start an unload task. This latter
    // task will pend on the already running unload task if there is on.
    //

    // Allocate a private task to coordinate the unloading of all the objects.
    //
    Status =    rmAllocatePrivateTask(
                            pGroup->pOwningObject,
                            rmTaskUnloadGroup,
                            0,
                            "Task:UnloadAllObjectsInGroup",
                            &pUnloadTask,
                            pSR
                            );

    if (FAIL(Status))
    {
        //
        // Ouch -- ugly failure...
        //
        ASSERT(FALSE);

        NdisReleaseSpinLock(&pGroup->OsLock);

    }
    else
    {
        TASK_UNLOADGROUP *pUGTask =  (TASK_UNLOADGROUP *) pUnloadTask;

        pUGTask->pGroup                     = pGroup;
        pUGTask->pfnTaskUnloadObjectHandler =    pfnUnloadTaskHandler;
        pUGTask->pfnUnloadTaskAllocator     =   pfnUnloadTaskAllocator;

        if (pTask == NULL)
        {

            // Set up an event which we'll wait on. The event will be signaled
            // by pUnloadTask when it completes.
            //
            NdisInitializeEvent(&pUGTask->BlockEvent);
            pUGTask->fUseEvent = TRUE;

            // Tmpref it so pUnloadTask will stay around even afer it's
            // completed -- because we wait on the event that's actually
            // located in the task memory.
            //
            RmTmpReferenceObject(&pUnloadTask->Hdr, pSR);
        }

        NdisReleaseSpinLock(&pGroup->OsLock);

        if (pTask != NULL)
        {
            RmPendTaskOnOtherTask(
                    pTask,
                    uTaskPendCode,
                    pUnloadTask,
                    pSR
                    );
        }

        Status = RmStartTask(pUnloadTask, 0, pSR);

        if (pTask == NULL)
        {
            NdisWaitEvent(&pUGTask->BlockEvent, 0);
            RmTmpDereferenceObject(&pUnloadTask->Hdr, pSR);
        }
    }
}

VOID
RmEnableGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    TODO: need better name for this.

Routine Description:

    Enables items to be added to a group.
    This function is typically called with a group which has completed
    RmUnloadAllObjectsFromGroup or RmFreeAllObjectsInGroup.
    On return from this call items may once more be added to this group.

    This call must only be called after UnloadAllObjectsInGroup or
    RmFreeAllObjectsInGroup have completed (synchronously or asynchronously).

    If there are items in in group or there is an unload
    task associated with the group at the time this function is called,
    the group is NOT reinited and the DBG version will assert.

    This function and may be called with an already enabled group, provided
    the condition above is met (no items in group, no unload task).

--*/
{
    NdisAcquireSpinLock(&pGroup->OsLock);
    if (    pGroup->pUnloadTask == NULL 
        &&  pGroup->HashTable.NumItems == 0)
    {
        pGroup->fEnabled = TRUE;
    }
    else
    {
        ASSERT("invalid state.");
    }
    NdisReleaseSpinLock(&pGroup->OsLock);
}


VOID
RmInitializeTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,    OPTIONAL
    IN  const char *                szDescription,  OPTIONAL
    IN  UINT                        Timeout,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize the specified task.

    The task is tempref'd. It is the responsibility of the caller to
    de-ref it when done. Typically this is implicitly done by calling
    RmStartTask.

Arguments:

    pTask           -   points to unitialized memory to hold the task.
    pParentObject   -   will be the parent of the task.
    pfnHandler      -   task's handler function.
    pStaticInfo     -   (OPTIONAL) Static information about the task.
    szDescription   -   (debug only, OPTIONAL) description of the task
    Timeout         -   unused
        
--*/
{
    ASSERT(!Timeout); // TODO: Timeouts unimplemented.

    NdisZeroMemory(pTask, sizeof(*pTask));

    RmInitializeHeader(
            pParentObject,
            &pTask->Hdr,
            MTAG_TASK,
            pParentObject->pLock,
            (pStaticInfo) ? pStaticInfo : &RmTask_StaticInfo,
            szDescription,
            pSR
            );
    pTask->pfnHandler = pfnHandler;
    SET_RM_TASK_STATE(pTask, RMTSKSTATE_IDLE);
    InitializeListHead(&pTask->listTasksPendingOnMe);

    RmTmpReferenceObject(&pTask->Hdr, pSR);

}


VOID
RmAbortTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
    )
{
    ASSERT(!"Unimplemented");
}



RM_STATUS
RmStartTask(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Start the specified task.

    NO locks should be held on entry and none are held on exit.
    pTask is expected to have a tmp-ref which is deref'd here.
    The task is automatically deallocated on completion (either  synchronous
    or asynchronous completion, either successful or failed completion).
    Unless the caller is explicitly added a reference to pTask before calling
    this function, the caller should not assume that pTask is still valid
    on return from this function.

Arguments:

    pTask           -   points to the task to be started.
    UserParam       -   opaque value passed to the task handler with the
                        RM_TASKOP_START message.
        
--*/
{
    ENTER("RmStartTask", 0xf80502d5)
    NDIS_STATUS Status;
    RM_ASSERT_NOLOCKS(pSR);

    RMPRIVATELOCK(&pTask->Hdr, pSR);
    if (!CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_IDLE))
    {
        ASSERTEX(!"Invalid state", pTask);
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        if (!RMISALLOCATED(pTask->Hdr.pParentObject))
        {
            //
            // TODO: consider not calling the handler if the parent object is
            // deallocated, but that may be confusing.
            // Consider not allowing children to be linked to an object
            // (RmInitializeHeader returns failure) if the parent object is
            // deallocated.
            //
            TR_WARN((
                "Starting task 0x%p (%s) with DEALLOCATED parent 0x%p (%s).\n",
                pTask,
                pTask->Hdr.szDescription,
                pTask->Hdr.pParentObject,
                pTask->Hdr.pParentObject->szDescription
                ));
        }

        SET_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING);
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

        TR_INFO((
            "STARTING Task 0x%p (%s); UserParam = 0x%lx\n",
            pTask,
            pTask->Hdr.szDescription,
            UserParam
            ));

        Status = pTask->pfnHandler(
                            pTask,
                            RM_TASKOP_START,
                            UserParam,
                            pSR
                            );

        RM_ASSERT_NOLOCKS(pSR);

        RMPRIVATELOCK(&pTask->Hdr, pSR);
        switch(GET_RM_TASK_STATE(pTask))
        {
        case RMTSKSTATE_STARTING:

            // This task is completing synchronously.
            //
            ASSERT(Status != NDIS_STATUS_PENDING);
            SET_RM_TASK_STATE(pTask, RMTSKSTATE_ENDING);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            rmEndTask(pTask, Status, pSR);
            RmDeallocateObject(&pTask->Hdr, pSR);
            break;

        case RMTSKSTATE_PENDING:
            ASSERTEX(Status == NDIS_STATUS_PENDING, pTask);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;

        case RMTSKSTATE_ENDING:
            // This task is completing synchronously and the RM_TASKOP_END
            // notification has already been sent.
            //
            // ??? ASSERT(Status != NDIS_STATUS_PENDING);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            // ??? RmDeallocateObject(&pTask->Hdr, pSR);
            break;

        default:
            ASSERTEX(FALSE, pTask);
            // Fall through ...

        case RMTSKSTATE_ACTIVE:
            // This can happen if the task is in the process of being resumed
            // in the context of some other thread. Nothing to do here...
            // (This actually happens sometimes on a MP machine).
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;
        }
        
    }

    // Remove the tmp ref added when the task was allocated.
    //
    RmTmpDereferenceObject(
                &pTask->Hdr,
                pSR
                );

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()

    return Status;
}


VOID
RmDbgDumpTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
)
{
}


RM_STATUS
RmSuspendTask(
    IN  PRM_TASK                    pTask,
    IN  UINT                        SuspendContext,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Suspends the specified task.

    RmSuspendTask is always called in the context of a task handler.
    pTask is may be locked on entry -- we don't care.

Arguments:

    pTask           -   task to be suspended.
    SuspendContext  -   context to be presented to the task's handler when
                        the task is subsequently resumed. Specifically, this 
                        context may be accessed using the RM_PEND_CODE macro,
                        when the task's handler is called with code
                        RM_TASKOP_PENDCOMPLETE.
        
--*/
{
    ENTER("RmSuspendTask", 0xd80fdc00)
    NDIS_STATUS Status;
    // RM_ASSERT_NOLOCKS(pSR);

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    TR_INFO((
        "SUSPENDING Task 0x%p (%s); SuspendContext = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        SuspendContext
        ));

    if (    !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING)
        &&  !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE))
    {
        ASSERTEX(!"Invalid state", pTask);
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        SET_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING);
        pTask->SuspendContext = SuspendContext;
        Status = NDIS_STATUS_SUCCESS;
    }

    RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

    // RM_ASSERT_NOLOCKS(pSR);

    EXIT()

    return Status;
}


VOID
RmUnsuspendTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Undoes the effect of a previous call to RmSuspendTask.

    Task MUST be in the pending state and MUST NOT be pending on another task.
    Debug version will ASSERT if above conditions are not met.

    RmUnsuspendTask is always called in the context of a task handler.
    pTask is may be locked on entry -- we don't care.

Arguments:

    pTask           -   task to be suspended.
        
--*/
{
    ENTER("RmUnsuspendTask", 0xcf713639)

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    TR_INFO((
        "UN-SUSPENDING Task 0x%p (%s). SuspendContext = 0x%x\n",
        pTask,
        pTask->Hdr.szDescription,
        pTask->SuspendContext
        ));

    ASSERT(CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING));
    ASSERT(pTask->pTaskIAmPendingOn == NULL);
    SET_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE);
    pTask->SuspendContext = 0;

    RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

    EXIT()
}


VOID
RmResumeTask(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    SuspendCompletionParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Resume a previously-suspended task.

    No locks held on entry or exit.
    
    SuspendCompletionParam is user-defined, and must be agreed upon between
    the caller of RmUnpendTask and the task that's being unpended.
    The Task's handler is ALWAYS called in the context of the caller of RmUnpendTask.
    So it is ok for the caller to declare a structure on the stack and pass
    a pointer to it as SuspendCompletionParam.

    WARNING: pTask could well be invalid (deallocate) by the time we return
    from this function. The caller is responsible for tmprefing pTask if it needs
    to access after return from this function.

Arguments:

    pTask                   -   task to be resumed.
    SuspendCompletionParam  -   arbitrary value that is passed on to the task's
                                handler as "UserParan" when the handler is called
                                with code RM_TASKOP_PENDCOMPLETE.
--*/
{
    ENTER("RmResumeTask", 0xd261f3c6)
    NDIS_STATUS Status;
    RM_ASSERT_NOLOCKS(pSR);

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    TR_INFO((
        "RESUMING Task 0x%p (%s); SuspendCompletionParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        SuspendCompletionParam
        ));

    if (!CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING))
    {
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        ASSERTEX(!"Invalid state", pTask);
    }
    else
    {
        // Add tmp ref, because we need to look at pTask after the return
        // from calling pfnHandler.
        //
        RmTmpReferenceObject(&pTask->Hdr, pSR);

        SET_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE);
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        Status = pTask->pfnHandler(
                            pTask,
                            RM_TASKOP_PENDCOMPLETE,
                            SuspendCompletionParam,
                            pSR
                            );

        RM_ASSERT_NOLOCKS(pSR);

        RMPRIVATELOCK(&pTask->Hdr, pSR);
        switch(GET_RM_TASK_STATE(pTask))
        {
        case RMTSKSTATE_ACTIVE:

            // This task is completing here (maybe)
            //
            if (Status != NDIS_STATUS_PENDING)
            {
                SET_RM_TASK_STATE(pTask, RMTSKSTATE_ENDING);
                RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
                rmEndTask(pTask, Status, pSR);
                RmDeallocateObject(&pTask->Hdr, pSR);
            }
            else
            {
                // It could be returning pending, but the state could
                // by now be active because it was completed elsewhere.
                // ASSERT(Status != NDIS_STATUS_PENDING);
                RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            }
            break;

        case RMTSKSTATE_PENDING:
            ASSERTEX(Status == NDIS_STATUS_PENDING, pTask);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;

        case RMTSKSTATE_ENDING:
            // This task is completing synchronously and the RM_TASKOP_END
            // notification has already been sent.
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;

        default:
            ASSERTEX(FALSE, pTask);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        }
        
        // Remove tmpref added above. pTask may well go away now...
        //
        RmTmpDereferenceObject(&pTask->Hdr, pSR);
    }

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
}


VOID
RmResumeTaskAsync(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    SuspendCompletionParam,
    IN  OS_WORK_ITEM            *   pOsWorkItem,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Similar to RmResumeTask, except that the task is resumed in the context
    of a work-item thread.

Arguments:
    pTask                   - see RmResumeTask
    SuspendCompletionParam  - see RmResumeTask
    pOsWorkItem             - caller supplied UNitialized work item (must stay
                              around until the task is resumed). Typically this
                              will be located within the user-specific portion
                              of pTask
--*/
{
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if RM_EXTRA_CHECKING
    //  This may seem paranoid, but is such a powerful check that it's worth it.
    //
    RmDbgAddAssociation(
        0x33d63ece,                         // Location ID
        &pTask->Hdr,                        // pObject
        (UINT_PTR) SuspendCompletionParam,  // Instance1
        (UINT_PTR) pOsWorkItem,             // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_ASYNC, // AssociationID
        szASSOCFORMAT_RESUME_TASK_ASYNC,    // szAssociationFormat
        pSR
        );
#endif // RM_EXTRA_CHECKING

    // We don't need to grab the private lock to set this, because only one
    // entity can call RmResumeTaskAsync. Note that we also ensure things are clean
    // (in the debug case) by the association added above.
    //
    pTask->AsyncCompletionParam = SuspendCompletionParam;

    NdisInitializeWorkItem(
        pOsWorkItem,
        rmWorkItemHandler_ResumeTaskAsync,
        pTask
        );

    Status = NdisScheduleWorkItem(pOsWorkItem);
    if (FAIL(Status))
    {
        ASSERT(!"NdisStatusWorkItem failed.");

        // It so happens that NdisScheudleWorkItem (current implementation
        // doesn't fail. Nevertheless, we do the best we can and actually
        // resume the task. If the caller was at dpc level and was expecting
        // the task to resume at passive, they're out of luck.
        //
        RmResumeTask(pTask, SuspendCompletionParam, pSR);
    }
}


VOID
RmResumeTaskDelayed(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    SuspendCompletionParam,
    IN  ULONG                       MsDelay,
    IN  OS_TIMER                *   pOsTimer,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Similar to RmResumeTask, except that the task is resumed in the context
    of a os timer handler which is set to fire after MsDelay milliseconds
    from the time RmResumeTaskDelayed is called.

    EXCEPTION: if someone has previously called RmResumeDelayedTaskNow, this
    task could be resumed in the context of this function call itself.

    Abort implementation notes: see notes.txt  07/14/1999 entry.

Arguments:

    pTask                   - see RmResumeTask
    SuspendCompletionParam  - see RmResumeTask
    pOsTimer                - caller supplied UNitialized timer
                              (must stay around until the task is resumed).
                              Typically this will be located within the
                              user-specific portion of pTask.
--*/
{
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if RM_EXTRA_CHECKING
    //  This may seem paranoid, but is such a powerful check that it's worth it.
    //
    RmDbgAddAssociation(
        0x33d63ece,                             // Location ID
        &pTask->Hdr,                            // pObject
        (UINT_PTR) SuspendCompletionParam,      // Instance1
        (UINT_PTR) NULL,                        // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_DELAYED,   // AssociationID
        szASSOCFORMAT_RESUME_TASK_DELAYED,      // szAssociationFormat
        pSR
        );
#endif // RM_EXTRA_CHECKING

    // Ddk states that it's best to call this function at passive level.
    //
    NdisInitializeTimer(
        pOsTimer,
        rmTimerHandler_ResumeTaskDelayed,
        pTask
        );

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    // The task-del state should NOT be "delayed"
    //
    ASSERT(RM_CHECK_STATE(pTask, RMTSKDELSTATE_MASK, 0));
    pTask->AsyncCompletionParam = SuspendCompletionParam;
    RM_SET_STATE(pTask, RMTSKDELSTATE_MASK, RMTSKDELSTATE_DELAYED);

    if (RM_CHECK_STATE(pTask, RMTSKABORTSTATE_MASK, RMTSKABORTSTATE_ABORT_DELAY))
    {
        // Oops, the delay has been aborted -- we call the tick handler now!
        //
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

        rmTimerHandler_ResumeTaskDelayed(
                NULL, // SystemSpecific1,
                pTask, // FunctionContext,
                NULL,  // SystemSpecific2,
                NULL   // SystemSpecific3
                );

    }
    else
    {
        //
        // Not currently aborting, let's set the timer.
        //
        NdisSetTimer(pOsTimer, MsDelay);

        // Very important to unlock the private lock AFTER calling set timer,
        // other wise someone could call RmResumeDelayedTaskNow BEFORE we call
        // NdisSetTimer, in which we would not end up aborting the delayed task.
        //
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
    }

}


VOID
RmResumeDelayedTaskNow(
    IN  PRM_TASK                    pTask,
    IN  OS_TIMER                *   pOsTimer,
    OUT PUINT                       pTaskResumed,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Cut's short the delay and resumes the task immediately.

    Implementation notes:  see notes.txt  07/14/1999 entry.

Arguments:

    pTask                   - see RmResumeTask
    pOsTimer                - caller supplied initialized timer
                              (must stay around until the task is resumed).
                              Typically this will be located within the
                              user-specific portion of pTask.
    pTaskResumed            - Points to a caller-supplied variable.
                              RmResumeDelayedTask sets this variable to TRUE if the
                              task was resumed as a consequence of this call, or to
                              FALSE if the task was resumed due to some other reason.
--*/
{
    UINT_PTR    CompletionParam = pTask->AsyncCompletionParam;

    *pTaskResumed = FALSE;
    ASSERTEX(RMISALLOCATED(&pTask->Hdr), pTask);

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    RM_SET_STATE(pTask, RMTSKABORTSTATE_MASK, RMTSKABORTSTATE_ABORT_DELAY);

    if (RM_CHECK_STATE(pTask, RMTSKDELSTATE_MASK, RMTSKDELSTATE_DELAYED))
    {
        BOOLEAN     TimerCanceled = FALSE;

        //
        // The task is actually delayed. Let's go ahead and cancel the timer
        // and resume the task now (which we do indirectly by calling
        // the timer handler ourselves).
        //
        NdisCancelTimer(pOsTimer, &TimerCanceled);
        if (TimerCanceled)
        {
            //
            // The timer was actually canceled -- so we call the timer handler
            // ourselves.
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
    
            rmTimerHandler_ResumeTaskDelayed(
                    NULL, // SystemSpecific1,
                    pTask, // FunctionContext,
                    NULL,  // SystemSpecific2,
                    NULL   // SystemSpecific3
                    );
            *pTaskResumed = TRUE;
        }
        else
        {
            //
            // Hmm -- the timer is not enabled. This is either because
            // the timer handler has just been called (and not yet cleared
            // the "DELAY" state) OR someone has previously called
            // RmResumeDelayedTaskNow.
            //
            //
            // Nothing to do.
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        }
    }
    else
    {
        //
        // The task state is not delayed -- so we just set the abort state
        // and go away.
        //
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
    }
}


RM_STATUS
RmPendTaskOnOtherTask(
    IN  PRM_TASK                    pTask,
    IN  UINT                        SuspendContext,
    IN  PRM_TASK                    pOtherTask,
    IN  PRM_STACK_RECORD            pSR
    )

/*++

Routine Description:

    Pend task pTask on task pOtherTask.

    Note: RmPendTaskOnOtherTask will cause pTask's pend operation to be
    completed in the context of this call itself, if pOtherTask is already
    in the completed state.
    03/26/1999 -- see RmPendTaskOnOtherTaskV2, and also
    03/26/1999 notes.txt entry "Some proposed ..."

Arguments:

    pTask           -   task to be suspended.
    SuspendContext  -   Context associated with the suspend (see
                        RmSuspendTask for details).
    pOtherTask      -   task that pTask is to pend on.

Return Value:

    NDIS_STATUS_SUCCESS on success.
    NDIS_STATUS_FAILURE on failure (typically because pTask is not in as
                        position to be suspended.)
--*/
{
    ENTER("RmPendTaskOnOtherTask", 0x0416873e)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fResumeTask = FALSE;
    RM_ASSERT_NOLOCKS(pSR);

    TR_INFO((
        "PENDING Task 0x%p (%s) on Task 0x%p (%s). SuspendCompletionParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        pOtherTask,
        pOtherTask->Hdr.szDescription,
        SuspendContext
        ));
    //
    // WARNING: we break the locking rules here  by getting the lock on
    // both pTask and pOtherTask.
    // TODO: consider acquiring them in order of increasing numerical value.
    //
    ASSERT(pTask != pOtherTask);
    NdisAcquireSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));

    do
    {
        // Break if we can't pend pTask on pOtherTask.
        //
        {
            if (    !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING)
                &&  !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE))
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }

            // Non-NULL pTaskIAmPendingOn implies that pTask is already pending on
            // some other task!
            //
            if (pTask->pTaskIAmPendingOn != NULL)
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }
        }

        Status = NDIS_STATUS_SUCCESS;

        SET_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING);
        pTask->SuspendContext = SuspendContext;

        if (CHECK_RM_TASK_STATE(pOtherTask, RMTSKSTATE_ENDING))
        {
            //
            // Other task is done -- so we resume pTask before returning...
            //
            fResumeTask = TRUE;
            break;
        }

        //
        // pOtherTask is not ended -- add pTask to the list of tasks pending
        // on pOtherTask.
        //
        pTask->pTaskIAmPendingOn  = pOtherTask;

    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            &pTask->Hdr,
            &pOtherTask->Hdr,
            0x77c488ca,
            RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
            szASSOCFORMAT_LINK_TASKPENDINGON,
            RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
            szASSOCFORMAT_LINK_TASKBLOCKS,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(&pTask->Hdr, &pOtherTask->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        ASSERTEX(pTask->linkFellowPendingTasks.Blink == NULL, pTask);
        ASSERTEX(pTask->linkFellowPendingTasks.Flink == NULL, pTask);
        InsertHeadList(
                &pOtherTask->listTasksPendingOnMe,
                &pTask->linkFellowPendingTasks
                );

    } while(FALSE);

    NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    NdisReleaseSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    
    if (fResumeTask)
    {
            RmResumeTask(
                pTask,
                NDIS_STATUS_SUCCESS, // SuspendCompletionParam. TODO: put real code.
                pSR
                );
    }

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
    return Status;
}


RM_STATUS
RmPendOnOtherTaskV2(
    IN  PRM_TASK                    pTask,
    IN  UINT                        SuspendContext,
    IN  PRM_TASK                    pOtherTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    if pOtherTask is not complete, Pend task pTask on task pOtherTask and return
    NDIS_STATUS_PENDING. However, if pOtherTask is already complete,
    then don't pend and instead return NDIS_STATUS_SUCCESS.

    See  03/26/1999 notes.txt entry "Some proposed ...". This function
    is currently used only by rmTaskUnloadGroup, to avoid the problem describted
    in the above-referenced notes.txt entry.

    TODO: Eventually get rid of RmPendTaskOnOtherTask.

Arguments:

    See RmPendTaskOnOtherTask
    
Return Value:

    NDIS_STATUS_PENDING if pTask is pending on pOtherTask
    NDIS_STATUS_SUCCESS if pOtherTask is complete.
    NDIS_STATUS_FAILURE if there was some failure (typically pTask is not
                        in a position to be pended.)
--*/
{
    ENTER("RmPendTaskOnOtherTaskV2", 0x0e7d1b89)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    RM_ASSERT_NOLOCKS(pSR);

    TR_INFO((
        "PENDING(V2) Task 0x%p (%s) on Task 0x%p (%s). SuspendCompletionParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        pOtherTask,
        pOtherTask->Hdr.szDescription,
        SuspendContext
        ));

    // This is not a useless assert -- I'e had a bug elsewhere which caused this
    // assert to get hit.
    //
    ASSERT(pTask != pOtherTask);
    //
    // WARNING: we break the locking rules here  by getting the lock on
    // both pTask and pOtherTask.
    // TODO: consider acquiring them in order of increasing numerical value.
    //
    NdisAcquireSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));

    do
    {
        // Break if we can't pend pTask on pOtherTask.
        //
        {
            if (    !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING)
                &&  !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE))
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }

            // Non-NULL pTaskIAmPendingOn implies that pTask is already pending on
            // some other task!
            //
            if (pTask->pTaskIAmPendingOn != NULL)
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }
        }


        if (CHECK_RM_TASK_STATE(pOtherTask, RMTSKSTATE_ENDING))
        {
            //
            // Other task is done -- so we simply return success...
            //
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // pOtherTask is not ended -- set pTask state to pending, and
        // add it to the list of tasks pending on pOtherTask.
        //
        SET_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING);
        pTask->SuspendContext       = SuspendContext;
        pTask->pTaskIAmPendingOn    = pOtherTask;

    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            &pTask->Hdr,
            &pOtherTask->Hdr,
            0x77c488ca,
            RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
            szASSOCFORMAT_LINK_TASKPENDINGON,
            RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
            szASSOCFORMAT_LINK_TASKBLOCKS,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(&pTask->Hdr, &pOtherTask->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        ASSERTEX(pTask->linkFellowPendingTasks.Blink == NULL, pTask);
        ASSERTEX(pTask->linkFellowPendingTasks.Flink == NULL, pTask);
        InsertHeadList(
                &pOtherTask->listTasksPendingOnMe,
                &pTask->linkFellowPendingTasks
                );
        Status = NDIS_STATUS_PENDING;

    } while(FALSE);

    NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    NdisReleaseSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    
    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
    return Status;
}


VOID
RmCancelPendOnOtherTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_TASK                    pOtherTask,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Resume task pTask which is currently pending on pOtherTask.

    Since no locks are held, pOtherTask needs to be specified, to make sure
    that pTask is indeed pending on pOtherTask before canceling the pend.

    If pTask is indeed pending on pOtherTask, this function will cause the
    completion of the pend status with the specified user param.

    Has no effect if the task is not pending.

Arguments:

    pTask       - Task to be "unpended"
    pOtherTask  - Task pTask is currently pending on.
    UserParam   - Passed to pTask's handler if and when pTask is resumed.

--*/
{
    ENTER("RmCancelPendOnOtherTask", 0x6e113266)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fResumeTask = FALSE;
    RM_ASSERT_NOLOCKS(pSR);

    //
    // WARNING: we break the locking rules here  by getting the lock on
    // both pTask and pOtherTask.
    // TODO: consider acquiring them in order of increasing numerical value.
    //

    TR_INFO((
        "CANCEL PEND of Task 0x%p (%s) on other Task 0x%p (%s); UserParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        pOtherTask,
        pOtherTask->Hdr.szDescription,
        UserParam
        ));

    // With pTask locked, tmp ref the task it is pending on, if any...
    //
    {
        NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
        if (pOtherTask == pTask->pTaskIAmPendingOn)
        {
            RmTmpReferenceObject(&(pOtherTask->Hdr), pSR);
        }
        else
        {
            // Oops -- pTask is not pending on pOtherTask ...
            //
            pOtherTask = NULL;
        }
        NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    }

    if (pOtherTask == NULL) return;                 // EARLY RETURN


    NdisAcquireSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));

    do
    {
        // Now that we have both task's locks, check again if pTask is pending
        // on pOtherTask
        //
        if (pTask->pTaskIAmPendingOn != pOtherTask)
        {
            // Oops -- the situation is different than when we started -- quietly
            // get out of here...
            //
            break;
        }

        pTask->pTaskIAmPendingOn = NULL;

    #if RM_EXTRA_CHECKING
        RmUnlinkObjectsEx(
            &pTask->Hdr,
            &pOtherTask->Hdr,
            0x6992b7a1,
            RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
            RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmUnlinkObjects(&pTask->Hdr, &pOtherTask->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        RemoveEntryList(&pTask->linkFellowPendingTasks);
        pTask->linkFellowPendingTasks.Flink = NULL;
        pTask->linkFellowPendingTasks.Blink = NULL;

        if (CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING))
        {
            fResumeTask = TRUE;
        }
        else
        {
            //
            // We shouldn't get here -- after we are pending on another task...
            //
            ASSERTEX(!"Invalid state", pTask);
            break;
        }

    } while (FALSE);

    NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    NdisReleaseSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    RmTmpDereferenceObject(&(pOtherTask->Hdr), pSR);
    
    if (fResumeTask)
    {
            RmResumeTask(
                pTask,
                UserParam, // SuspendCompletionParam
                pSR
                );
    }

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
}



VOID
RmInitializeHashTable(
    PRM_HASH_INFO pHashInfo,
    PVOID         pAllocationContext,
    PRM_HASH_TABLE pHashTable
    )
/*++

Routine Description:

    Initialize a hash table data structure.
    Caller is responsible for serializing access to the hash table structure.

Arguments:

    pHashInfo           - Points to static information about the hash table
    pAllocationContext  - Passed to the allocation and deallocation functions
                          (pHashInfo->pfnTableAllocator and
                          pHashInfo0->pfnTableDeallocator) which are used to
                          dynamically grow /shrink the hash table.
    pHashTable          - Points to uninitialized memory that is to contain the
                          hash table.
--*/
{

    NdisZeroMemory(pHashTable, sizeof(*pHashTable));

    pHashTable->pHashInfo = pHashInfo;
    pHashTable->pAllocationContext = pAllocationContext;
    pHashTable->pTable =  pHashTable->InitialTable;
    pHashTable->TableLength = sizeof(pHashTable->InitialTable)
                                /sizeof(pHashTable->InitialTable[0]);
}

VOID
RmDeinitializeHashTable(
    PRM_HASH_TABLE pHashTable
    )
/*++

Routine Description:

    Deinitialize a previously-initialized a hash table data structure.
    There must be no items in the hash table when this function is called.

    Caller is responsible for serializing access to the hash table structure.

Arguments:

    pHashTable          - Hash table to be deinitialized.

--*/
{
    PRM_HASH_LINK *pTable = pHashTable->pTable;
    
    ASSERTEX(pHashTable->NumItems == 0, pHashTable);

    if (pTable != pHashTable->InitialTable)
    {
        NdisZeroMemory(pTable, pHashTable->TableLength*sizeof(*pTable));

        pHashTable->pHashInfo->pfnTableDeallocator(
                                    pTable,
                                    pHashTable->pAllocationContext
                                    );
    }

    NdisZeroMemory(pHashTable, sizeof(*pHashTable));

}


BOOLEAN
RmLookupHashTable(
    PRM_HASH_TABLE      pHashTable,
    PRM_HASH_LINK **    pppLink,
    PVOID               pvRealKey
    )
/*++

Routine Description:

    Lookup an item in the hash table and/or find the place where the item
    is to be inserted.

    Caller is expected to serialize access to the hash table.
    OK to use read-locks to serialize access.

    Return value: TRUE if item found; false otherwise.
    On return, *pppLink is set to a the location containing a pointer to
    a RM_HASH_LINK. If the return value is TRUE, the latter pointer points
    to the found RM_HASH_LINK. If the return value is FALSE, the location
    is where the item is to be inserted, if required.

Arguments:

    pHashTable          - Hash table to look up
    pppLink             - place to store a pointer to a link which points
                          to an item (see above for details).
    pvRealKey           - Key used to lookup item.

Return Value:
    
    TRUE    if item is found
    FALSE   otherwise.

--*/
{
    PRM_HASH_LINK *ppLink, pLink;
    UINT LinksTraversed = 0;
    UINT TableLength = pHashTable->TableLength;
    PFN_RM_COMPARISON_FUNCTION pfnCompare =  pHashTable->pHashInfo->pfnCompare;
    BOOLEAN fRet = FALSE;
    ULONG               uHash = pHashTable->pHashInfo->pfnHash(pvRealKey);

    for (
        ppLink = pHashTable->pTable + (uHash%TableLength);
        (pLink = *ppLink) != NULL;
        ppLink = &(pLink->pNext), LinksTraversed++)
    {
        if (pLink->uHash == uHash
            && pfnCompare(pvRealKey, pLink))
        {
            // found it
            //
            fRet = TRUE;
            break;
        }
    }

    // Update stats
    //
    rmUpdateHashTableStats(&pHashTable->Stats, LinksTraversed);
    
    *pppLink = ppLink;

    return fRet;
}


BOOLEAN
RmNextHashTableItem(
    PRM_HASH_TABLE      pHashTable,
    PRM_HASH_LINK       pCurrentLink,   // OPTIONAL
    PRM_HASH_LINK *    ppNextLink
    )
/*++

Routine Description:

    Find the first (if pCurrentLink is NULL) or "next" (if pCurrentLink is not NULL)
    item in the hash table.

    Caller is expected to serialize access to the hash table.
    OK to use read-locks to serialize access.

    NOTE: The "next" item returned is in no particular order.

Arguments:

    pHashTable          - Hash table to look up
    pCurrentLink        - if non-NULL, points to an existing hash link in the
                          hash table.
    ppLinkLink          - place to store a pointer to the link "after"
                          pCurrentLink, or the first link (if pCurrentLink is NULL).

Return Value:
    
    TRUE    if there is a "next" item.
    FALSE   otherwise.

--*/
{
    PRM_HASH_LINK pLink, *ppLink, *ppLinkEnd;
    UINT TableLength;

    ppLink      = pHashTable->pTable;
    TableLength = pHashTable->TableLength;
    ppLinkEnd   = ppLink + TableLength;

    if (pCurrentLink != NULL)
    {

    #if DBG
        {
            // Make sure this link is valid!
            pLink =  *(ppLink + (pCurrentLink->uHash % TableLength));
            while (pLink != NULL && pLink != pCurrentLink)
            {
                pLink = pLink->pNext;
            }
            if (pLink != pCurrentLink)
            {
                ASSERTEX(!"Invalid pCurrentLink", pCurrentLink);
                *ppNextLink = NULL;
                return FALSE;                           // EARLY RETURN
            }
        }
    #endif // DBG

        if (pCurrentLink->pNext != NULL)
        {
            // Found a next link.
            //
            *ppNextLink = pCurrentLink->pNext;
            return TRUE;                            // EARLY RETURN
        }
        else
        {
            // End of current bucket, move to next one.
            // We check later if we've gone past the end of the table.
            //
            ppLink +=  (pCurrentLink->uHash % TableLength) + 1;
        }
    }


    // Look for next non-null item.
    //
    for ( ; ppLink < ppLinkEnd; ppLink++)
    {
        pLink =  *ppLink;
        if (pLink != NULL)
        {
            *ppNextLink = pLink;
            return TRUE;                        // EARLY RETURN
        }
    }

    *ppNextLink = NULL;
    return FALSE;
}


VOID
RmAddHashItem(
    PRM_HASH_TABLE  pHashTable,
    PRM_HASH_LINK * ppLink,
    PRM_HASH_LINK   pLink,
    PVOID           pvKey
    )
/*++

Routine Description:

    Add an item to the hash table at the specified location.
    Caller is expected to serialize access to the hash table.

Arguments:

    pHashTable      - Hash table in which to add item.
    ppLink          - Points to place within table to add new item.
    pLink           - New item to add.
    pvKey           - key associated with the item.

    TODO: pvKey is only used to compute uHash -- consider passing in uHash directly.

--*/
{
    pLink->uHash = pHashTable->pHashInfo->pfnHash(pvKey);
    pLink->pNext = *ppLink;
    *ppLink = pLink;

    pHashTable->NumItems++;

    // TODO: if required, resize
}

VOID
RmRemoveHashItem(
    PRM_HASH_TABLE  pHashTable,
    PRM_HASH_LINK   pLinkToRemove
    )
/*++

Routine Description:

    Remove an item from the hash table.
    Caller is expected to serialize access to the hash table.

    (debug only): Asserts if pLinkToRemove is no in the hash table.

Arguments:

    pHashTable      - Hash table in which to add item.
    pLinkToRemove   - Link to remove.

--*/
{
    PRM_HASH_LINK *ppLink, pLink;
    UINT TableLength = pHashTable->TableLength;
    ULONG uHash = pLinkToRemove->uHash;
    BOOLEAN     fFound = FALSE;

    for (
        ppLink = pHashTable->pTable + (uHash%TableLength);
        (pLink = *ppLink) != NULL;
        ppLink = &(pLink->pNext))
    {
        if (pLink == pLinkToRemove)
        {
            // found it -- remove it and get out.
            //
            RM_PRIVATE_UNLINK_NEXT_HASH(pHashTable, ppLink);
            pLink->pNext = NULL; // Important, so that enumeration works.
            fFound=TRUE;
            break;
        }
    }

    // TODO: if required, resize

    ASSERT(fFound);
}


VOID
RmEnumHashTable(
    PRM_HASH_TABLE          pHashTable,
    PFN_ENUM_HASH_TABLE     pfnEnumerator,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Calls function pfnEnumerator for each item in the hash table.
    Caller is expected to serialize access to the hash table.

Arguments:

    pHashTable      - Hash table to enumerate.
    pfnEnumerator   - Enumerator function.
    pvContext       - Opaque context passed to enumerator function.

--*/
{
    PRM_HASH_LINK *ppLink, *ppLinkEnd;

    ppLink      = pHashTable->pTable;
    ppLinkEnd   = ppLink + pHashTable->TableLength;

    for ( ; ppLink < ppLinkEnd; ppLink++)
    {
        PRM_HASH_LINK pLink =  *ppLink;
        while (pLink != NULL)
        {

            pfnEnumerator(
                pLink,
                pvContext,
                pSR 
                );
    
            pLink = pLink->pNext;
        }
    }
}


VOID
RmEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnEnumerator,
    PVOID                   pvContext,
    INT                     fStrong,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Calls function pfnEnumerator for each item in the group, until
    the funcition return FALSE.

    WARNING: Enumeration is "STRONG" -- the group lock
    is held during the whole enumeration process. The
    enumerator function is therefore called at DPR level, and more importantly,
    the enumerator function avoid locking anything to avoid risk of deadlock.
    Specifically, the enumerator function MUST NOT lock the object -- if any other
    thread has called a group-related RM function with the object's lock held,
    we WILL deadlock.

    This function should only be used to access parts of the object that do
    not need to be protected by the objects lock.

    If locking needs to be performed, use RmWeakEnumerateObjectsInGroup.

Arguments:

    pGroup          - Hash table to enumerate.
    pfnEnumerator   - Enumerator function.
    pvContext       - Opaque context passed to enumerator function.
    fStrong         - MUST be TRUE.
--*/
{

    if (fStrong)
    {
        RM_STRONG_ENUMERATION_CONTEXT Ctxt;
        Ctxt.pfnObjEnumerator = pfnEnumerator;
        Ctxt.pvCallerContext = pvContext;
        Ctxt.fContinue           = TRUE;

        NdisAcquireSpinLock(&pGroup->OsLock);

        RmEnumHashTable(
                    &pGroup->HashTable,
                    rmEnumObjectInGroupHashTable,   // pfnEnumerator
                    &Ctxt,                          // context
                    pSR
                    );

        NdisReleaseSpinLock(&pGroup->OsLock);
    }
    else
    {
        ASSERT(!"Unimplemented");
    }

}


VOID
RmWeakEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnEnumerator,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Calls function pfnEnumerator for each item in the group, until
    the funcition return FALSE.

    Enumeration is "WEAK" -- the group lock is
    NOT held the whole time, and is not held when the enumerator
    function is called.

    A snapshot of the entire group is first taken with the group lock held,
    and each object is tempref'd. The group lock is then released and the
    enumerator function is called for each object in the snapshot. 
    The objects are then derefd.

    NOTE: It is possible that when the enumeration function is called for an
    object, the object is no longer in the group. The enumeration function can
    lock the object and check its internal state to determine if it is still
    relevant to process the object.

Arguments:

    pGroup          - Hash table to enumerate.
    pfnEnumerator   - Enumerator function.
    pvContext       - Opaque context passed to enumerator function.


--*/
{
    #define RM_SMALL_GROUP_SIZE         10
    #define RM_MAX_ENUM_GROUP_SIZE      100000
    PRM_OBJECT_HEADER *ppSnapshot;
    PRM_OBJECT_HEADER SmallSnapshot[RM_SMALL_GROUP_SIZE];
    UINT NumItems = pGroup->HashTable.NumItems;

    do
    {
        RM_WEAK_ENUMERATION_CONTEXT Ctxt;

        if (NumItems <= RM_SMALL_GROUP_SIZE)
        {
            if (NumItems == 0) break;
            ppSnapshot = SmallSnapshot;
        }
        else if (NumItems > RM_MAX_ENUM_GROUP_SIZE)
        {
            // TODO: LOG_RETAIL_ERROR
            ASSERT(FALSE);
            break;
        }
        else
        {
            RM_ALLOC(
                    &(void* )ppSnapshot,
                    NumItems*sizeof(PRM_OBJECT_HEADER),
                    MTAG_RMINTERNAL
                    );

            if (ppSnapshot == NULL)
            {
                ASSERT(FALSE);
                break;
            }
        }

        Ctxt.ppCurrent = ppSnapshot;
        Ctxt.ppEnd     = ppSnapshot+NumItems;

        NdisAcquireSpinLock(&pGroup->OsLock);
    
        RmEnumHashTable(
                    &pGroup->HashTable,
                    rmConstructGroupSnapshot,   // pfnEnumerator
                    &Ctxt,                      // context
                    pSR
                    );
    
        NdisReleaseSpinLock(&pGroup->OsLock);

        ASSERT(Ctxt.ppCurrent >= ppSnapshot);
        ASSERT(Ctxt.ppCurrent <= Ctxt.ppEnd);

        // Fix up ppEnd to point to the last actually-filled pointer.
        //
        Ctxt.ppEnd = Ctxt.ppCurrent;
        Ctxt.ppCurrent = ppSnapshot;

        for  (;Ctxt.ppCurrent < Ctxt.ppEnd; Ctxt.ppCurrent++)
        {
            pfnEnumerator(
                    *Ctxt.ppCurrent,
                    pvContext,
                    pSR
                    );
            RmTmpDereferenceObject(*Ctxt.ppCurrent, pSR);
        }

        if (ppSnapshot != SmallSnapshot)
        {
            RM_FREE(ppSnapshot);
            ppSnapshot = NULL;
        }

    } while (FALSE);
}


//=========================================================================
//                  L O C A L   F U N C T I O N S
//=========================================================================


VOID
rmDerefObject(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Dereference object pObject. Deallocate it if the reference count goes to zero.

--*/
{
    ULONG Refs;
    ENTER("rmDerefObject", 0x5f9d81dd)

    ASSERT(RM_OBJECT_IS_ALLOCATED(pObject));

    //
    // On entry, the ref count should be at-least 2 -- one the
    // explicit ref added in RmAllocateObject, and the 2nd the ref due to
    // the link to the parent.
    //
    // Exception to the above: if the object has no parent, the refcount should be
    // at-least 1.
    //

    // Deref the ref added in RmAllocateObject, and if the ref count is now <=1, 
    // we actually unlink and free the object.
    //
    Refs = NdisInterlockedDecrement(&pObject->TotRefs);

    if (Refs <= 1)
    {
        PRM_OBJECT_HEADER pParentObject;
        RMPRIVATELOCK(pObject, pSR);

        //
        // Unlink from parent, if there is one...
        //
    
        pParentObject =  pObject->pParentObject;
        pObject->pParentObject = NULL;

    #if RM_TRACK_OBJECT_TREE
        // Verify that there are no siblings...
        //
        RETAILASSERTEX(IsListEmpty(&pObject->listChildren), pObject);
    #endif // RM_TRACK_OBJECT_TREE

        RMPRIVATEUNLOCK(pObject, pSR);

        if (pParentObject != NULL)
        {
            ASSERTEX(!RMISALLOCATED(pObject), pObject);

            ASSERTEX(Refs == 1, pObject);

        #if RM_TRACK_OBJECT_TREE
            RMPRIVATELOCK(pParentObject, pSR);

            // Remove object from parent's list of children.
            //
            RETAILASSERTEX(
                !IsListEmpty(&pParentObject->listChildren),
                pObject);
            RemoveEntryList(&pObject->linkSiblings);

            RMPRIVATEUNLOCK(pParentObject, pSR);
        #endif // RM_TRACK_OBJECT_TREE

    #if RM_EXTRA_CHECKING
        RmUnlinkObjectsEx(
            pObject,
            pParentObject,
            0xac73e169,
            RM_PRIVATE_ASSOC_LINK_CHILDOF,
            RM_PRIVATE_ASSOC_LINK_PARENTOF,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
            RmUnlinkObjects(pObject, pParentObject, pSR);
    #endif // !RM_EXTRA_CHECKING

        }
        else if (Refs == 0)
        {
            //
            // Free to deallocate this thing...
            //

            ASSERTEX(!RMISALLOCATED(pObject), pObject);

            #if RM_EXTRA_CHECKING
            rmDbgDeinitializeDiagnosticInfo(pObject, pSR);
            #endif // RM_EXTRA_CHECKING

            RM_MARK_OBJECT_AS_DEALLOCATED(pObject);

            if (pObject->pStaticInfo->pfnDelete!= NULL)
            {

                TR_INFO((
                    "Actually freeing 0x%p (%s)\n",
                    pObject,
                    pObject->szDescription
                    ));

                pObject->pStaticInfo->pfnDelete(pObject, pSR);
            }
        }
    }

    EXIT()
}

VOID
rmLock(
    PRM_LOCK                pLock,
#if RM_EXTRA_CHECKING
    UINT                    uLocID,
    PFNLOCKVERIFIER         pfnVerifier,
    PVOID                   pVerifierContext,
#endif //RM_EXTRA_CHECKING
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Lock pLock.

Arguments:

    pLock               - Lock to lock.
    LocID               - Arbitrary ID, typically representing the source location
                          from which this function is called.
    
    Following are for debug only:

    pfnVerifier         - Optional function that is called just after locking
    pfnVerifierContext  - Passed in call to pfnVerifier

--*/
{
    //UINT Level  = pSR->LockInfo.CurrentLevel;
    RM_LOCKING_INFO li;

    RETAILASSERTEX(pLock->Level > pSR->LockInfo.CurrentLevel, pLock);
    RETAILASSERTEX(pSR->LockInfo.pNextFree < pSR->LockInfo.pLast, pLock);

    pSR->LockInfo.CurrentLevel = pLock->Level;

    // Save information about this lock in the stack record.
    //
    li.pLock = pLock;
#if RM_EXTRA_CHECKING
    li.pfnVerifier = pfnVerifier;
    li.pVerifierContext = pVerifierContext;
#endif //RM_EXTRA_CHECKING
    *(pSR->LockInfo.pNextFree++) = li; // struct copy.

    // Get the lock.
    // TODO: uncomment the following optimization...
    //if (Level)
    //{
    //  NdisDprAcquireSpinLock(&pLock->OsLock);
    //}
    //else
    //{
    NdisAcquireSpinLock(&pLock->OsLock);
    //}

#if RM_EXTRA_CHECKING

    ASSERTEX(pLock->DbgInfo.uLocID == 0, pLock);
    ASSERTEX(pLock->DbgInfo.pSR == NULL, pLock);
    pLock->DbgInfo.uLocID = uLocID;
    pLock->DbgInfo.pSR = pSR;
    // Call the verifier routine if there is one.
    //
    if (pfnVerifier)
    {
        pfnVerifier(pLock, TRUE, pVerifierContext, pSR);
    }
#endif //RM_EXTRA_CHECKING

}


VOID
rmUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Unlock pLock.

    Debug only: if there is a verifier function associated with this lock
    we call it just before unlocking pLock.

Arguments:

    pLock               - Lock to unlock.

--*/
{
    RM_LOCKING_INFO * pLI;
    pSR->LockInfo.pNextFree--;
    pLI = pSR->LockInfo.pNextFree;
    RETAILASSERTEX(pLI->pLock == pLock, pLock);

    ASSERTEX(pLock->DbgInfo.pSR == pSR, pLock);
    ASSERTEX(pLock->Level == pSR->LockInfo.CurrentLevel, pLock);

    pLI->pLock = NULL;

    if (pLI > pSR->LockInfo.pFirst)
    {
        PRM_LOCK pPrevLock =  (pLI-1)->pLock;
        pSR->LockInfo.CurrentLevel = pPrevLock->Level;
        ASSERTEX(pPrevLock->DbgInfo.pSR == pSR, pPrevLock);
    }
    else
    {
        pSR->LockInfo.CurrentLevel = 0;
    }


#if RM_EXTRA_CHECKING

    // Call the verifier routine if there is one.
    //
    if (pLI->pfnVerifier)
    {
        pLI->pfnVerifier(pLock, FALSE, pLI->pVerifierContext, pSR);
        pLI->pfnVerifier = NULL;
        pLI->pVerifierContext = NULL;
    }
    pLock->DbgInfo.uLocID = 0;
    pLock->DbgInfo.pSR = NULL;

#endif //RM_EXTRA_CHECKING


    // Release the lock.
    //
    NdisReleaseSpinLock(&pLock->OsLock);
}


#if RM_EXTRA_CHECKING
ULONG
rmPrivateLockVerifier(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    (Debug only)

    The Verifier function for an object's RmPrivateLock.

Arguments:

    pLock               - Lock being locked/unlocked
    fLock               - TRUE if lock has just been locked.
                          FALSE if lock is about to be unlocked.
Return Value:

    Unused: TODO make return value VOID.

--*/
{
    ENTER("rmPrivateLockVerifier", 0xc3b63ac5)
    TR_VERB(("Called with pLock=0x%p, fLock=%lu, pContext=%p\n",
                pLock, fLock, pContext, pSR));
    EXIT()

    return 0;
}

ULONG
rmVerifyObjectState(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    (Debug only)

    Uses the object's verification function (if there is one) to
    compute a signature that is checked each time the object is locked,
    and is updated each time the object is unlocked. Assert if this signature
    has changed while the object was supposedly unlocked.

    Also: Update RM_OBJECT_HEADER.pDiagInfo->PrevState if there is been a
    change of state while the object was locked.

Arguments:

    pLock               - Lock being locked/unlocked
    fLock               - TRUE if lock has just been locked.
                          FALSE if lock is about to be unlocked.
    pContext            - Actually pointer to object being locked.

Return Value:

    Unused: TODO make return value VOID.

--*/
{
    PRM_OBJECT_HEADER pObj = (PRM_OBJECT_HEADER) pContext;
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObj->pDiagInfo;
    ULONG NewChecksum;
    ENTER("rmVerifyObjectState", 0xb8ff7a67)
    TR_VERB(("Called with pLock=0x%p, fLock=%lu, pObj=%p\n",
                pLock, fLock, pObj, pSR));

    if (pDiagInfo != NULL
        && !(pDiagInfo->DiagState & fRM_PRIVATE_DISABLE_LOCK_CHECKING))

    {
        
        // Compute the new checksum and as part of that call the
        // object-specific verifier if there is one....
        //
        {
            PFNLOCKVERIFIER         pfnVerifier;

            // We verify that the objset-specific state was not modified
            // without the lock held. This is done by including the object-specific
            // state in the checksum computation.
            //
            NewChecksum = pObj->State;
    
            // Then, if the object has a verifier function, we call it, and 
            // fold in the return value into the checkum.
            //
            pfnVerifier = pObj->pStaticInfo->pfnLockVerifier;
            if (pfnVerifier != NULL)
            {
                NewChecksum ^= pfnVerifier(pLock, fLock, pObj, pSR);
    
            }
        }

        if (fLock)  // We've just locked the object.
        {

            // First thing we do is to save the current value of pObj->State in
            // the TmpState location -- we'll look at it again on unlocking.
            //
            pDiagInfo->TmpState = pObj->State;


            // Now we compare the new checksum value with the value that wase
            // saved the last time this object was locked...
            // Special case: old Checksum was 0 -- as it is on initialization.
            //
            if (NewChecksum != pDiagInfo->Checksum && pDiagInfo->Checksum)
            {
                TR_WARN((
                    "Object 0x%p (%s) possibly modified without lock held!\n",
                    pObj,
                    pObj->szDescription
                    ));

            // Unfortunately we hit this assert because there are places where
            // the same lock is shared by many objects and 
            #if 0
                // Give users the option to ignore further validation on this 
                // object.
                //
                TR_FATAL((
                    "To skip this assert, type \"ed 0x%p %lx; g\"\n",
                    &pDiagInfo->DiagState,
                    pDiagInfo->DiagState | fRM_PRIVATE_DISABLE_LOCK_CHECKING
                    ));
                ASSERTEX(!"Object was modified without lock held!", pObj);
            #endif // 0
            }
        }
        else    // We're just about to unlock the object....
        {
            // Update the signature...
            //
            pDiagInfo->Checksum = NewChecksum;

            // If there has been a change in state between locking and unlockng
            // this object, save the previous state.
            //
            if (pDiagInfo->TmpState != pObj->State)
            {
                pDiagInfo->PrevState = pDiagInfo->TmpState;
            }
        }
    }


    EXIT()

    return 0;
}
#endif // RM_EXTRA_CHECKING

VOID
rmEndTask(
    PRM_TASK            pTask,
    NDIS_STATUS         Status,
    PRM_STACK_RECORD    pSR
)
/*++

Routine Description:

    Send the RM_TASKOP_END to the task handler, and resume any tasks pending on
    pTask.

Arguments:

    pTask       - Task to end.
    Status      - Completion status -- passed on to the task handler.

--*/
{
    ENTER("rmEndtask", 0x5060d952)
    PRM_TASK pPendingTask;
    RM_ASSERT_NOLOCKS(pSR);

    TR_INFO((
        "ENDING Task 0x%p (%s); Status = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        Status
        ));

    // TODO: could change behavior so that we use the return value, but
    // currently we ignore it...
    //
    pTask->pfnHandler(
                pTask,
                RM_TASKOP_END,
                Status, // UserParam is overloaded here.
                pSR
                );

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        pPendingTask = NULL;
    
        RMPRIVATELOCK(&pTask->Hdr, pSR);
        if (!IsListEmpty(&pTask->listTasksPendingOnMe))
        {
            pPendingTask = CONTAINING_RECORD(
                                (pTask->listTasksPendingOnMe.Flink),
                                RM_TASK,
                                linkFellowPendingTasks
                                );
            RmTmpReferenceObject(&pPendingTask->Hdr, pSR);
        }
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

        if (pPendingTask != NULL)
        {

            RmCancelPendOnOtherTask(
                pPendingTask,
                pTask,
                Status,
                pSR
                );
            RmTmpDereferenceObject(&pPendingTask->Hdr, pSR);
        }
    
    }
    while(pPendingTask != NULL);

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
}


NDIS_STATUS
rmAllocatePrivateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,      OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Allocate and initialize a task of subtype RM_PRIVATE_TASK.

Arguments:

    pParentObject       - Object that is to be the parent of the allocated task.
    pfnHandler          - The task handler for the task.
    Timeout             - Unused.
    szDescription       - Text describing this task.
    ppTask              - Place to store pointer to the new task.

Return Value:

    NDIS_STATUS_SUCCESS if we could allocate and initialize the task.
    NDIS_STATUS_RESOURCES otherwise

--*/
{
    RM_PRIVATE_TASK *pRmTask;
    NDIS_STATUS Status;

    RM_ALLOCSTRUCT(pRmTask, MTAG_TASK); // TODO use lookaside lists.
        
    *ppTask = NULL;

    if (pRmTask != NULL)
    {
        RM_ZEROSTRUCT(pRmTask);

        RmInitializeTask(
                &(pRmTask->TskHdr),
                pParentObject,
                pfnHandler,
                &RmPrivateTasks_StaticInfo,
                szDescription,
                Timeout,
                pSR
                );
        *ppTask = &(pRmTask->TskHdr);
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    return Status;
}


NDIS_STATUS
rmTaskUnloadGroup(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    This task is responsible for unloading all the objects in the group.

    pTask is a pointer to TASK_UNLOADGROUP, and that structure is expected
    to be initialized, including containing the  pGroup to unload.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    TASK_UNLOADGROUP    *pMyTask = (TASK_UNLOADGROUP*) pTask;
    PRM_GROUP           pGroup = pMyTask->pGroup;
    BOOLEAN             fContinueUnload = FALSE;
    ENTER("TaskUnloadGroup", 0x964ee422)


    enum
    {
        PEND_WaitOnOtherTask,
        PEND_UnloadObject
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            // If there is already an unload task bound to pGroup, we
            // pend on it.
            //
            NdisAcquireSpinLock(&pGroup->OsLock);
            if (pGroup->pUnloadTask != NULL)
            {
                PRM_TASK pOtherTask = pGroup->pUnloadTask;
                TR_WARN(("unload task 0x%p already bound to pGroup 0x%p; pending on it.\n",
                pOtherTask, pGroup));

                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                NdisReleaseSpinLock(&pGroup->OsLock);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_WaitOnOtherTask,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
            else if (!pGroup->fEnabled)
            {
                //
                // Presumably this group has already been unloaded of all objects
                // and is simply sitting around. We complete right away.
                //
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                //
                // We're the 1st ones here -- continue on to unloading objects, if
                // any...
                //
                pGroup->pUnloadTask = pTask;
                pGroup->fEnabled = FALSE; // This will prevent new objects from
                                        // being added and from the hash table
                                        // itself from changing size.
                pMyTask->uIndex = 0;    // This keeps track of where we are in the
                                    // hash table.
                                            
                fContinueUnload = TRUE;
            }
            NdisReleaseSpinLock(&pGroup->OsLock);
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_WaitOnOtherTask:
                {
                    //
                    // Nothing to do -- finish task.
                    //
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

                case  PEND_UnloadObject:
                {
                    //
                    // Just done unloading an object; unload another if required.
                    //
                    fContinueUnload = TRUE;
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                ASSERTEX(!"Unknown pend code!", pTask);
                break;
            }

        }
        break;


        case  RM_TASKOP_END:
        {
            BOOLEAN fSignal;
            NdisAcquireSpinLock(&pGroup->OsLock);

            // Clear ourselves from pGroup, if we're there.
            //
            if (pGroup->pUnloadTask == pTask)
            {
                pGroup->pUnloadTask = NULL;
            }
            fSignal = pMyTask->fUseEvent;
            pMyTask->fUseEvent = FALSE;
            NdisReleaseSpinLock(&pGroup->OsLock);

            if (fSignal)
            {
                NdisSetEvent(&pMyTask->BlockEvent);
            }
            Status = NDIS_STATUS_SUCCESS;
        }
        break;

        default:
        ASSERTEX(!"Unknown task op", pTask);
        break;

    } // switch (Code)


    if (fContinueUnload)
    {
        do {
            PRM_HASH_LINK *ppLink, *ppLinkEnd;
            UINT uIndex;
            PRM_HASH_LINK pLink;
            PRM_OBJECT_HEADER pObj;
            PRM_TASK pUnloadObjectTask;

            NdisAcquireSpinLock(&pGroup->OsLock);
    
            uIndex = pMyTask->uIndex;

            //
            // With fEnabled set to FALSE by us, we expect the following:
            // (a) pHashTable->pTable is going to stay the same size.
            // (b) No items are going to be added or removed by anyone else.
            //

            // Find the next non-empty hash table entry, starting at
            // offset pMyTask->uIndex.
            //
            ASSERTEX(!pGroup->fEnabled, pGroup);
            ASSERTEX(uIndex <= pGroup->HashTable.TableLength, pGroup);
            ppLinkEnd = ppLink      = pGroup->HashTable.pTable;
            ppLink      += uIndex;
            ppLinkEnd   += pGroup->HashTable.TableLength;
            while (ppLink < ppLinkEnd && *ppLink == NULL)
            {
                ppLink++;
            }

            // Update index to our current position in the hash table.
            //
            pMyTask->uIndex =  (UINT)(ppLink - pGroup->HashTable.pTable);

            if (ppLink >= ppLinkEnd)
            {
                //
                // We're done...
                //
                NdisReleaseSpinLock(&pGroup->OsLock);
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // Found another object to unload...
            // We'll allocate a task (pUnloadObjectTask) to unload that object,
            // pend ourselves on it, and then start it.
            //
            //

            pLink =  *ppLink;
            pObj = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
            RmTmpReferenceObject(pObj, pSR);
            ASSERT(pObj->pStaticInfo == pGroup->pStaticInfo);
            NdisReleaseSpinLock(&pGroup->OsLock);

            Status = pMyTask->pfnUnloadTaskAllocator(
                        pObj,                                   // pParentObject,
                        pMyTask->pfnTaskUnloadObjectHandler,    // pfnHandler,
                        0,                                      // Timeout,
                        "Task:Unload Object",
                        &pUnloadObjectTask,
                        pSR
                        );
            if (FAIL(Status))
            {
                // Aargh... we couldn't allocate a task to unload this object.
                // We'll return quietly, leaving the other objects intact...
                //
                ASSERTEX(!"Couldn't allocat unload task for object.", pObj);
                RmTmpDereferenceObject(pObj, pSR);
                break;
            }

            RmTmpDereferenceObject(pObj, pSR);
    
    #if OBSOLETE // See  03/26/1999 notes.txt entry "Some proposed ..."

            RmPendTaskOnOtherTask(
                pTask,
                PEND_UnloadObject,
                pUnloadObjectTask,              // task to pend on
                pSR
                );
    
            (void)RmStartTask(
                        pUnloadObjectTask,
                        0, // UserParam (unused)
                        pSR
                        );

            Status = NDIS_STATUS_PENDING;

    #else   // !OBSOLETE
            RmTmpReferenceObject(&pUnloadObjectTask->Hdr, pSR);
            RmStartTask(
                pUnloadObjectTask,
                0, // UserParam (unused)
                pSR
                );
            Status = RmPendOnOtherTaskV2(
                        pTask,
                        PEND_UnloadObject,
                        pUnloadObjectTask,
                        pSR
                        );
            RmTmpDereferenceObject(&pUnloadObjectTask->Hdr, pSR);
            if (PEND(Status))
            {
                break;
            }
    #endif  // !OBSOLETE
    
        }
    #if OBSOLETE // See  03/26/1999 notes.txt entry "Some proposed ..."
        while (FALSE);
    #else   // !OBSOLETE
        while (TRUE);
    #endif  // !OBSOLETE

    }   // if(fContinueUnload)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}

#if RM_EXTRA_CHECKING

BOOLEAN
rmDbgAssociationCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Comparison function used to test for exact equality of items
    in the debug association table.

Arguments:

    pKey        - Actually  a pointer to an RM_PRIVATE_DBG_ASSOCIATION structure.
    pItem       - Points to RM_PRIVATE_DBG_ASSOCIATION.HashLink.

Return Value:

    TRUE IFF the (Entity1, Entity2 and AssociationID) fields of the key
    exactly match the corresponding fields of 
    CONTAINING_RECORD(pItem, RM_PRIVATE_DBG_ASSOCIATION, HashLink);

--*/
{
    RM_PRIVATE_DBG_ASSOCIATION *pA =
             CONTAINING_RECORD(pItem, RM_PRIVATE_DBG_ASSOCIATION, HashLink);

    // pKey is actually a RM_PRIVATE_DBG_ASSOCIATION structure.
    //
    RM_PRIVATE_DBG_ASSOCIATION *pTrueKey = (RM_PRIVATE_DBG_ASSOCIATION *) pKey;


    if (    pA->Entity1 == pTrueKey->Entity1
        &&  pA->Entity2 == pTrueKey->Entity2
        &&  pA->AssociationID == pTrueKey->AssociationID)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}


ULONG
rmDbgAssociationHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash generating function used to compute a ULONG-sized hash from
    key, which is actually  a pointer to an RM_PRIVATE_DBG_ASSOCIATION structure.

Arguments:

    pKey        - Actually  a pointer to an RM_PRIVATE_DBG_ASSOCIATION structure.

Return Value:

    ULONG-sized hash generated from the (Entity1, Entity2 and AssociationID)
    fields of the key.

--*/
{
    // pKey is actually a RM_PRIVATE_DBG_ASSOCIATION structure.
    //
    RM_PRIVATE_DBG_ASSOCIATION *pTrueKey = (RM_PRIVATE_DBG_ASSOCIATION *) pKey;
    ULONG_PTR big_hash;

    big_hash =   pTrueKey->Entity1;
    big_hash ^=  pTrueKey->Entity2;
    big_hash ^=  pTrueKey->AssociationID;

    // Warning: Below, the return value would be truncated in 64-bit.
    // That tolerable because after all this is just a hash.
    // TODO: for 64-bit, consider  xoring hi- and lo- DWORD instead of truncationg.
    //

    return (ULONG) big_hash;
}


// Static hash information use for the hash table (in the diagnostic information
// of each object) that keeps track of associations.
//
RM_HASH_INFO
rmDbgAssociation_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    rmDbgAssociationCompareKey, // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    rmDbgAssociationHash        // pfnHash

};


VOID
rmDbgInitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Allocate and initialize the diagnostic information associated with
    object pObject. This includes initializing the hash table used to keep
    track of arbitrary associations.

--*/
{
    ENTER("InitializeDiagnosticInfo",  0x55db57a2)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo;

    TR_VERB(("   pObj=0x%p\n", pObject));
    // TODO: use lookaside lists for the allocation of these objects.
    //
    RM_ALLOCSTRUCT(pDiagInfo,   MTAG_DBGINFO);
    if (pDiagInfo != NULL)
    {
        RM_ZEROSTRUCT(pDiagInfo);

        NdisAllocateSpinLock(&pDiagInfo->OsLock);
        RmInitializeHashTable(
            &rmDbgAssociation_HashInfo,
            NULL,   // pAllocationContext
            &pDiagInfo->AssociationTable
            );
        pObject->pDiagInfo  = pDiagInfo;
        pDiagInfo->pOwningObject = pObject;

        // Initialize the per-object log list.
        //
        InitializeListHead(&pDiagInfo->listObjectLog);
    }
}


VOID
rmDbgFreeObjectLogEntries(
        LIST_ENTRY *pObjectLog
)
/*++

Routine Description:

    Remove and free all items from the object log pObjectLog.
    It is assumed that no one is trying  to add items to this log at this time.

--*/
{
    LIST_ENTRY          *pLink=NULL, *pNextLink=NULL;
    
    if (IsListEmpty(pObjectLog))    return;             // EARLY RETURN 

    NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);

    for(
        pLink = pObjectLog->Flink;
        pLink != pObjectLog;
        pLink = pNextLink)
    {
        RM_DBG_LOG_ENTRY    *pLogEntry;
        LIST_ENTRY          *pLinkGlobalLog;

        pLogEntry = CONTAINING_RECORD(pLink,  RM_DBG_LOG_ENTRY,  linkObjectLog);
        pLinkGlobalLog =  &pLogEntry->linkGlobalLog;

        // Remove entry from global log.
        // We don't bother removing the entry from the local log list, because
        //  it's going away anyway.
        //
        RemoveEntryList(pLinkGlobalLog);

        // Move to next entry in object's log (which may not be the next entry
        // in the global log).
        //
        pNextLink = pLink->Flink;

        // Free the buffer in the log entry, if any.
        // TODO: need to use log buffer deallocation function --
        //      See notes.txt  03/07/1999  entry "Registering root objects with RM".
        // For now we assume the this memory was allocated using
        // NdisAllocateMemory[WithTag].
        //
        if (pLogEntry->pvBuf != NULL)
        {
            NdisFreeMemory(pLogEntry->pvBuf, 0, 0);
        }

        // Free the log entry itself.
        //
        rmDbgDeallocateLogEntry(pLogEntry);
        
    }
    NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);
}


VOID
rmDbgDeinitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

        (Debug only)

        Deinitialize and free  the diagnostic information associated with
        object pObject. This includes verifying that there are no remaining
        associations and links.
--*/
{
    ENTER("DeinitializeDiagnosticInfo", 0xa969291f)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    TR_VERB((" pObj=0x%p\n", pObject));
    if (pDiagInfo != NULL)
    {

        // Free all the per-object log entries.
        // Note: no one should be trying to add items to this log at this time
        // because we're aboute to deallocate this object.
        //
        {
            rmDbgFreeObjectLogEntries(&pDiagInfo->listObjectLog);
            RM_ZEROSTRUCT(&pDiagInfo->listObjectLog);
        }


        if (pDiagInfo->AssociationTable.NumItems != 0)
        {
            //
            // Ouch! Associations still left. We print out the associations and then
            // DebugBreak.
            //

            TR_FATAL((
                "FATAL: Object 0x%p still has some associations left!\n",
                pObject
                ));
            RmDbgPrintAssociations(pObject, pSR);
            ASSERT(!"Object has associations left at deallocation time.");
        }

        pObject->pDiagInfo = NULL;

        RmDeinitializeHashTable(
            &pDiagInfo->AssociationTable
            );

        //
        // Add any other checks here...
        //

        NdisFreeSpinLock(&pDiagInfo->OsLock);
        RM_FREE(pDiagInfo);
    }
}


VOID
rmDbgPrintOneAssociation (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Dump a single association.

Arguments:

    pLink       -  Points to RM_PRIVATE_DBG_ASSOCIATION.HashLink.
    pvContext   -  Unused

--*/
{
    RM_PRIVATE_DBG_ASSOCIATION *pA =
                    CONTAINING_RECORD(pLink, RM_PRIVATE_DBG_ASSOCIATION, HashLink);
    DbgPrint(
        (char*) (pA->szFormatString),
        pA->Entity1,
        pA->Entity2,
        pA->AssociationID
        );
}


VOID
_cdecl
rmDefaultDumpEntry (
    char *szFormatString,
    UINT_PTR Param1,
    UINT_PTR Param2,
    UINT_PTR Param3,
    UINT_PTR Param4
)
/*++

Routine Description:

    Default function to dump the contents of an association.

--*/
{
    DbgPrint(
        szFormatString,
        Param1,
        Param2,
        Param3,
        Param4
        );
}

UINT
rmSafeAppend(
    char *szBuf,
    const char *szAppend,
    UINT cbBuf
)
/*++

Routine Description:

    Append szAppend to szBuf, but don't exceed cbBuf, and make sure the 
    resulting string is null-terminated.

Return Value:

    Total length of string (excluding null termination) after append.

--*/
{
    UINT uRet;
    char *pc = szBuf;
    char *pcEnd = szBuf+cbBuf-1;    // possible overflow, but we check below.
    const char *pcFrom = szAppend;

    if (cbBuf==0) return 0;             // EARLY RETURN;

    // Skip to end of szBuf
    //
    while (pc < pcEnd && *pc!=0)
    {
        pc++;
    }

    // Append szAppend
    while (pc < pcEnd && *pcFrom!=0)
    {
        *pc++ = *pcFrom++;  
    }

    // Append final zero 
    //
    *pc=0;

    return (UINT) (UINT_PTR) (pc-szBuf);
}

#endif //RM_EXTRA_CHECKING

VOID
rmWorkItemHandler_ResumeTaskAsync(
    IN  PNDIS_WORK_ITEM             pWorkItem,
    IN  PVOID                       pTaskToResume
    )
/*++

Routine Description:

    NDIS work item handler which resumes the give task.

Arguments:

    pWorkItem           - Work item associated with the handler.
    pTaskToResume       - Actually a pointer to the task to resume.

--*/
{
    PRM_TASK pTask  = pTaskToResume;
    UINT_PTR CompletionParam = pTask->AsyncCompletionParam;
    RM_DECLARE_STACK_RECORD(sr)

    ASSERTEX(RMISALLOCATED(&pTask->Hdr), pTask);

#if RM_EXTRA_CHECKING
    //  Undo the association added in RmResumeTasyAsync...
    //
    RmDbgDeleteAssociation(
        0xfc39a878,                             // Location ID
        &pTask->Hdr,                            // pObject
        CompletionParam,                        // Instance1
        (UINT_PTR) pWorkItem,                   // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_ASYNC,     // AssociationID
        &sr
        );
#endif // RM_EXTRA_CHECKING

    // Actually resume the task.
    //
    RmResumeTask(pTask, CompletionParam, &sr);

    RM_ASSERT_CLEAR(&sr)
}


VOID
rmTimerHandler_ResumeTaskDelayed(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )
/*++

Routine Description:

    NDIS timer handler which resumes the give task.

    WARNING: This handler is also called internally by the RM APIs.
    Implementation notes: -- see notes.txt  07/14/1999 entry.

Arguments:

    SystemSpecific1     - Unused
    FunctionContext     - Actually a pointer to the task to be resumed.
    SystemSpecific2     - Unused
    SystemSpecific3     - Unused

--*/
{
    PRM_TASK pTask  = FunctionContext;
    UINT_PTR CompletionParam = pTask->AsyncCompletionParam;
    RM_DECLARE_STACK_RECORD(sr)

    ASSERTEX(RMISALLOCATED(&pTask->Hdr), pTask);

#if RM_EXTRA_CHECKING
    //  Undo the association added in RmResumeTasyDelayed...
    //
    RmDbgDeleteAssociation(
        0xfc39a878,                             // Location ID
        &pTask->Hdr,                            // pObject
        CompletionParam,                        // Instance1
        (UINT_PTR) NULL,                        // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_DELAYED,   // AssociationID
        &sr
        );
#endif // RM_EXTRA_CHECKING

    RMPRIVATELOCK(&pTask->Hdr, &sr);
    ASSERT(RM_CHECK_STATE(pTask, RMTSKDELSTATE_MASK, RMTSKDELSTATE_DELAYED));
    RM_SET_STATE(pTask, RMTSKDELSTATE_MASK, 0);
    RM_SET_STATE(pTask, RMTSKABORTSTATE_MASK, 0);
    RMPRIVATEUNLOCK(&pTask->Hdr, &sr);

    // Actually resume the task.
    //
    RmResumeTask(pTask, CompletionParam, &sr);

    RM_ASSERT_CLEAR(&sr)
}


VOID
rmPrivateTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free a private task (which was allocated using  rmAllocatePrivateTask.

Arguments:

    pObj    - Actually a pointer to a task of subtype RM_PRIVATE_TASK.

--*/
{
    RM_FREE(pObj);
}


#if RM_EXTRA_CHECKING


RM_DBG_LOG_ENTRY *
rmDbgAllocateLogEntry(VOID)
/*++

Routine Description:

    Allocate an object log entry.

    TODO use lookaside lists, and implement per-component global logs.
    See notes.txt  03/07/1999  entry "Registering root objects with RM".

--*/
{
    RM_DBG_LOG_ENTRY *pLE;
    RM_ALLOCSTRUCT(pLE, MTAG_DBGINFO);
    return  pLE;
}

VOID
rmDbgDeallocateLogEntry(
        RM_DBG_LOG_ENTRY *pLogEntry
        )
/*++

Routine Description:

    Free an object log entry.

    TODO use lookaside lists, and implement per-component global logs.
    See notes.txt  03/07/1999  entry "Registering root objects with RM".

--*/
{
    RM_FREE(pLogEntry);
}
#endif // RM_EXTRA_CHECKING


VOID
rmUpdateHashTableStats(
    PULONG pStats,
    ULONG   LinksTraversed
    )
/*++

Routine Description:

    Update the stats (loword == links traversed, hiword == num accesses)

--*/
{
    ULONG OldStats;
    ULONG Stats;
    
    // Clip LinksTraversed to 2^13, or 8192 
    //
    if (LinksTraversed > (1<<13))
    {
        LinksTraversed = 1<<13;
    }
    
    Stats = OldStats = *pStats;
    
    // If either the loword or hiword of Stats is greater-than 2^13, we
    // intiger-devide both by 2. We're really only interested in the ratio
    // of the two, which is preserved by the division.
    //
    #define rmSTATS_MASK (0x11<<30|0x11<<14)
    if (OldStats & rmSTATS_MASK)
    {
        Stats >>= 1;
        Stats &= ~rmSTATS_MASK;
    }

    // Compute the updated value of stats..
    //  "1<<16" below means "one access"
    //
    Stats += LinksTraversed | (1<<16);

    // Update the stats, but only if they haven't already been updated by
    // someone else. Note that if they HAVE been updated, we will lose this
    // update. Not a big deal as we are not looking for 100% exact statistics here.
    //
    InterlockedCompareExchange(pStats, Stats, OldStats);
}


VOID
rmEnumObjectInGroupHashTable (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    )
/*++
    Hash table enumerator to implement "STRONG" enumeration -- see
    RmEnumerateObjectsInGroup.
--*/
{
    PRM_STRONG_ENUMERATION_CONTEXT pCtxt = (PRM_STRONG_ENUMERATION_CONTEXT)pvContext;

    if (pCtxt->fContinue)
    {
        PRM_OBJECT_HEADER pHdr;
        pHdr = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
        pCtxt->fContinue = pCtxt->pfnObjEnumerator(
                                    pHdr,
                                    pCtxt->pvCallerContext,
                                    pSR
                                    );
    }
}


VOID
rmConstructGroupSnapshot (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    )
/*++
    Hash table enumerator to construct a snapshot of a group for weak enumeration.
    See RmWeakEnumerateObjectsInGroup.
--*/
{
    PRM_WEAK_ENUMERATION_CONTEXT pCtxt = (PRM_WEAK_ENUMERATION_CONTEXT)pvContext;

    if (pCtxt->ppCurrent < pCtxt->ppEnd)
    {
        PRM_OBJECT_HEADER pHdr;
        pHdr = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
        RmTmpReferenceObject(pHdr, pSR);
        *pCtxt->ppCurrent = pHdr;
        pCtxt->ppCurrent++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\rm.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    rm.h

Abstract:

    "Resource Manager" structures and APIs

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     11-10-98    created

--*/

//=================================================================================
//                  O S - S P E C I F I C   T Y P E S
//=================================================================================

#define RM_OS_LOCK                          NDIS_SPIN_LOCK
#define OS_WORK_ITEM                        NDIS_WORK_ITEM
#define OS_TIMER                            NDIS_TIMER

#define RM_STATUS                            NDIS_STATUS

#define RM_OS_FILL_MEMORY(_dest, _len, _fill) NdisFillMemory(_dest, _len, _fill)
#define RM_OS_ZERO_MEMORY(_dest, _len)        NdisZeroMemory(_dest, _len)
#define RM_OS_GET_CURRENT_THREAD_HANDLE()     NULL

// If set, the object tree is explicitly maintained.
//
#define RM_TRACK_OBJECT_TREE 1

//=================================================================================
//                  F O R W A R D       R E F E R E N C E S
//=================================================================================

typedef struct _RM_STACK_RECORD     RM_STACK_RECORD,        *PRM_STACK_RECORD;
typedef struct _RM_OBJECT_HEADER    RM_OBJECT_HEADER,       *PRM_OBJECT_HEADER;
typedef struct _RM_TASK             RM_TASK,                *PRM_TASK;
typedef struct _RM_RESOURCE_TABLE_ENTRY
                                RM_RESOURCE_TABLE_ENTRY, *PRM_RESOURCE_TABLE_ENTRY;


//=================================================================================
//                  T Y P E D E F S
//=================================================================================

//
// RM_DBG_LOCK_INFO Keeps debugging information specific to an instance of a RM_LOCK.
//
typedef struct _RM_DBG_LOCK_INFO
{
    //
    // If nonzero, LocID is a magic number which uniquely identifies the source
    // location where the lock was aquired.
    //
    ULONG uLocID;

    //
    // pSR points to the stack record of the currently owning thread, if there
    // is one. If a function F expects an object pObj to be locked on entry,
    // it can  ASSERT(pObj->pLock->pDbgInfo->pSR == pSR);
    //
    struct _RM_STACK_RECORD *pSR;


} RM_DBG_LOCK_INFO, *PRM_DBG_LOCK_INFO;

//
// RM_LOCK keeps information about a lock.
//
typedef struct _RM_LOCK
{
    //
    // Native, os-provided lock structure.
    //
    RM_OS_LOCK OsLock;

    //
    // Level of this lock. Multiple locks can only be acquired in increasing order
    // of this value.
    //
    ULONG Level;

    //
    // Pointer to debugging info for this lock. Could be NULL.
    //
    PRM_DBG_LOCK_INFO pDbgInfo;

#if RM_EXTRA_CHECKING
    RM_DBG_LOCK_INFO DbgInfo;
#endif // RM_EXTRA_CHECKING

} RM_LOCK, *PRM_LOCK;


typedef
ULONG
(*PFNLOCKVERIFIER) (
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
    );

// RM_LOCKING_INFO keeps information about a particular lock being held.
// In non-checking mode, this is just the pointer to the lock.
// In checking mode, this additionally contains information that can be used
// to verify that the entity being protected by the lock is not changed when
// the lock is not being held.
//
typedef struct
{
    PRM_LOCK pLock;

#if RM_EXTRA_CHECKING
    PFNLOCKVERIFIER pfnVerifier;
    PVOID           pVerifierContext;
#endif // RM_EXTRA_CHECKING

}  RM_LOCKING_INFO, PRM_LOCKING_INFO;

//
// RM_STACK_RECORD keeps information relevant to the current call tree.
//
typedef struct _RM_STACK_RECORD
{
    //
    // LockInfo contains information about currently-held locks.
    //
    struct
    {
        //
        // Level of the currently held lock. Locks must be claimed in
        // order of increasing Level values. The lowest level value is 1. Level
        // 0 indicates no locks held.
        //
        UINT    CurrentLevel;

        //
        // Pointer to the first location to store a pointers to a locks.
        //
        PRM_LOCKING_INFO *pFirst;

        //
        // Pointer to the next free location to store a pointer to a lock
        // that has been claimed in this call tree.
        //
        PRM_LOCKING_INFO *pNextFree;

        //
        // Pointer to the last valid location to store a lock pointer.
        //
        PRM_LOCKING_INFO *pLast;

    } LockInfo;


    //
    // Count of tmp refs taken with this stack record.
    //
    ULONG TmpRefs;

#if DBG

    //
    // DbgInfo contains diagnostic information relevant to this call tree.
    //
    struct
    {
        //
        // Verbosity level
        //
        ULONG Level;

        //
        //  Points to the os-provided thread handle of the current thread.
        //  if there is one.
        //
        PVOID pvThread;


    } DbgInfo;

#endif // DBG

} RM_STACK_RECORD, *PRM_STACK_RECORD;

#if DBG
    #define RM_INIT_DBG_STACK_RECORD(_sr, _dbglevel)                \
        _sr.DbgInfo.Level           = _dbglevel;                    \
        _sr.DbgInfo.pvThread        = RM_OS_GET_CURRENT_THREAD_HANDLE();
#else
    #define RM_INIT_DBG_STACK_RECORD(_sr, _dbglevel)
#endif 

//
// RM_DECLARE_STACK_RECORD_EX is a macro to reserve some stack space for
// a stack record.
//
#define RM_DECLARE_STACK_RECORD_EX(_sr, _max_locks, _dbglevel)      \
    RM_LOCKING_INFO rm_lock_array[_max_locks];                      \
    RM_STACK_RECORD _sr;                                            \
    RM_OS_ZERO_MEMORY(rm_lock_array, sizeof(rm_lock_array));        \
    _sr.TmpRefs                 = 0;                                \
    _sr.LockInfo.CurrentLevel   = 0;                                \
    _sr.LockInfo.pFirst     = rm_lock_array;                    \
    _sr.LockInfo.pNextFree  = rm_lock_array;                    \
    _sr.LockInfo.pLast      = rm_lock_array+(_max_locks)-1;     \
    RM_INIT_DBG_STACK_RECORD(_sr, _dbglevel);


//
// RM_DECLARE_STACK_RECORD is a macro to reserve default stack space for
// a stack record.
//
#define RM_DECLARE_STACK_RECORD(_sr)                                \
    RM_DECLARE_STACK_RECORD_EX(_sr, 4, 0)



//
// Generic memory allocator prototype
//
typedef
PVOID
(*PFN_RM_MEMORY_ALLOCATOR)(
    PVOID pAllocationContext,
    UINT  Size                  // in bytes
    );

//
// Generic memory deallocator prototype
//
typedef
PVOID
(*PFN_RM_MEMORY_DEALLOCATOR)(
    PVOID pMem,
    PVOID pAllocationContext
    );


//  RM_HASH_LINK is the field in the structures being hashed that is
//  used to link all items in the same bucket. It also contains the
//  "HashKey", which is a potentially-nonunique UINT-sized hash of the
//  real key.
//
typedef struct _RM_HASH_LINK
{
    struct _RM_HASH_LINK *pNext;
    UINT                  uHash;
} RM_HASH_LINK, *PRM_HASH_LINK;


//
// Hash table comparison function.
//
typedef
BOOLEAN
(*PFN_RM_COMPARISON_FUNCTION)(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    );


//
// Hash computation function.
//
typedef
ULONG
(*PFN_RM_HASH_FUNCTION)(
    PVOID           pKey
    );


//
// RM_HASH_INFO specifies customizing information about a hash table.
//
typedef struct
{
    // Allocator used to allocate the hash table if it needs to grow.
    //
    PFN_RM_MEMORY_ALLOCATOR pfnTableAllocator;

    // Free function for the above allocator.
    PFN_RM_MEMORY_DEALLOCATOR pfnTableDeallocator;

    // Comparison function for strict equality.
    //
    PFN_RM_COMPARISON_FUNCTION pfnCompare;

    // Function to generate a ULONG-sized hash.
    //
    PFN_RM_HASH_FUNCTION pfnHash;

#if OBSOLETE
    // Offset in sizeof(UINT) to location of the place to keep
    // the next pointer for the bucket list.
    //
    UINT    OffsetNext;

    // Offset in sizeof(UINT) to location of UINT-sized Temp ref
    //
    UINT    OffsetTmpRef;

    // Offset in sizeof(UINT) to location of UINT-sized Tot ref
    //
    UINT    OffsetTotRef;

    // Offset in sizeof(UINT) to location of ULONG-sized hash key.
    //
    UINT    OffsetHashKey;
#endif // OBSOLETE

} RM_HASH_INFO, *PRM_HASH_INFO;

#define RM_MIN_HASH_TABLE_SIZE 4

//
// RM_HASH_TABLE is a hash table.
//
typedef struct
{
    //  Number of items currently in hash table.
    //
    UINT NumItems;

    //  Stats is a 32-bit quantity keeps a running total of number of accesses
    //  (add+search+remove) in the HIWORD and the total number of list nodes
    //  traversed in the LOWORD. This field gets updated even on searches, but
    //  it is not protected by the hash table lock -- instead it is
    //  updated using  an interlocked operation. This allows us to use
    //  a read lock for searches while still updating this statistic value.
    //  The Stats field is re-scaled when the counts get too high, to avoid
    //  overflow and also to favor more recent stats in preference to older
    //  stats.
    //
    //  NumItems, Stats and TableLength are used to decide whether to
    //  dynamically resize the hash table.
    //
    ULONG Stats;

    //  Length of hash table in units of PVOID
    //
    ULONG TableLength;

    // Pointer to TableLength-sized array of PVOIDs -- this is the actual hash table
    //
    PRM_HASH_LINK *pTable;


    // The hash table
    //
    PRM_HASH_LINK InitialTable[RM_MIN_HASH_TABLE_SIZE];

    // Static information about this hash table.
    //
    PRM_HASH_INFO pHashInfo;

    // Passed into the allocate/deallocate functions.
    //
    PVOID pAllocationContext;

} RM_HASH_TABLE, *PRM_HASH_TABLE;

// Returns approximate value of (num-nodes-traversed)/(num-accesses)
//
#define RM_HASH_TABLE_TRAVERSE_RATIO(_pHash_Table) \
            (((_pHash_Table)->Stats & 0xffff) / (1+((_pHash_Table)->Stats >> 16)))
            //
            // NOTE: the "1+" above is simply to guard against devide-by-zero.


//
// RM_OBJECT_DIAGNOSTIC_INFO keeps diagnostic info specific to an instance of
// an object.
//
// This structure is for private use of the RM APIs.
// The only field of general interest is PrevState.
//
typedef struct
{
    // Back pointer to owning object.
    //
    RM_OBJECT_HEADER *pOwningObject;

    // Each time the object-specific State field is updated, it's previous
    // value is saved here.
    //
    ULONG               PrevState;

    // Used for correctly updating PrevState.
    //
    ULONG               TmpState;

    // Diagnostic-related state.
    //
    ULONG               DiagState;
    #define fRM_PRIVATE_DISABLE_LOCK_CHECKING (0x1<<0)

    // This is an object-specific checksum that is computed and 
    // saved just before the object is unlocked. It is  checked
    // just after the object is locked.
    //
    ULONG               Checksum;

    // Native OS lock to be *only* to serialize access to the information
    // in this structure.
    //
    RM_OS_LOCK          OsLock;

    // Keeps an associative list of all entities which have been registered
    // (using RmDbgAddAssociation) with this object. Ths includes objects which
    // have been linked to this object using the RmLinkObjects call, as well
    // as childen and parents of this object.
    //
    RM_HASH_TABLE       AssociationTable;

    // Following is set to TRUE IFF  there was an allocation failure when trying to
    // add an association. If there'e been an allocation failure, we don't complain
    // (i.e. ASSERT) if an attempt is made to remove an assertion that doesn't
    // exist. In this way we gracefully deal with allocation failures of the
    // association table entries.
    //
    INT                 AssociationTableAllocationFailure;

    // The per-object list of log entries.
    // This is serialized by the global rm lock, not the local rm-private lock!
    //
    LIST_ENTRY          listObjectLog;

    // Count of entries in this object's log.
    // This is serialized by the global rm lock, not the local rm-private lock!
    //
    UINT                NumObjectLogEntries;

#if TODO    // We haven't implemented the following yet...

    // Future:
    // RM_STATE_HISTORY -- generalization of PrevState.

#endif //  TODO


} RM_OBJECT_DIAGNOSTIC_INFO, *PRM_OBJECT_DIAGNOSTIC_INFO;

typedef
PRM_OBJECT_HEADER
(*PFN_CREATE_OBJECT)(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        );

typedef
VOID
(*PFN_DELETE_OBJECT)(PRM_OBJECT_HEADER, PRM_STACK_RECORD psr);


//
// RM_STATIC_OBJECT_INFO keeps information that is common to all instances of
// a particular type of object.
//
typedef struct
{
    ULONG   TypeUID;
    ULONG   TypeFlags;
    char*   szTypeName;
    UINT    Timeout;

    //
    // Various Handlers
    //
    PFN_CREATE_OBJECT           pfnCreate;
    PFN_DELETE_OBJECT           pfnDelete;
    PFNLOCKVERIFIER             pfnLockVerifier;

    //
    // Resource Information
    //
    UINT    NumResourceTableEntries;
    struct  _RM_RESOURCE_TABLE_ENTRY *  pResourceTable;

    //
    // Hash-table info, if this object is part of a group.
    //
    PRM_HASH_INFO pHashInfo;

} RM_STATIC_OBJECT_INFO, *PRM_STATIC_OBJECT_INFO;

//
// RM_OBJECT_HEADER is the common header for all objects.
//
typedef struct _RM_OBJECT_HEADER
{
    //
    // Object-type-specific signature.
    //
    ULONG Sig;

    //
    // Description of this object (could be the same as pStaticInfo->szTypeName,
    // but may be something more specific).
    // Used only for debugging purposes.
    // TODO: consider moving this into the pDiagInfo struct. For now, leave it
    // here because it's useful when debugging.
    //
    const char *szDescription;

    //
    // Object-specific state.
    //
    ULONG State;

    ULONG RmState; // One or more RMOBJSTATE_* or RMTSKSTATE_* flags below...

    //
    // RM state flags....
    //
    
    // Object allocation state...
    //
    #define RMOBJSTATE_ALLOCMASK        0x00f
    #define RMOBJSTATE_ALLOCATED        0x001
    #define RMOBJSTATE_DEALLOCATED      0x000

    // Task state ...
    //
    #define RMTSKSTATE_MASK             0x0f0
    #define RMTSKSTATE_IDLE             0x000
    #define RMTSKSTATE_STARTING         0x010
    #define RMTSKSTATE_ACTIVE           0x020
    #define RMTSKSTATE_PENDING          0x030
    #define RMTSKSTATE_ENDING           0x040

    //  Task delay state
    //
    #define RMTSKDELSTATE_MASK          0x100
    #define RMTSKDELSTATE_DELAYED       0x100

    //  Task abort state
    //
    #define RMTSKABORTSTATE_MASK        0x200
    #define RMTSKABORTSTATE_ABORT_DELAY 0x200

    //
    // Bitmap identifying resources used by this object.
    //
    ULONG ResourceMap;

    // Total reference count.
    //
    //
    ULONG TotRefs;

    //

    // Pointer to a RM_LOCK object used to serialize access to this object.
    //
    PRM_LOCK pLock;

    //
    // Pointer to information common to all instances of this object type.
    //
    PRM_STATIC_OBJECT_INFO    pStaticInfo;

    //
    // Points to diagnostic information about this object.  Could be NULL.
    //
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo;


    //
    //  Points to the parent object.
    //
    struct _RM_OBJECT_HEADER *pParentObject;

    //
    //  Points to the root (ancestor of all object) -- could be the same
    //  as pParentObject;
    //
    struct _RM_OBJECT_HEADER *pRootObject;

    //
    // This is a private lock used exclusively by the RM apis. It is
    // never left unlocked by the RM apis.
    // TODO: maybe make this a native-os lock.
    //
    RM_LOCK RmPrivateLock;

    // Used to create groups of objects.
    // TODO: make this a private field, present only if the object is
    // meant to be in a group.
    //
    RM_HASH_LINK HashLink;

#if RM_TRACK_OBJECT_TREE
    LIST_ENTRY          listChildren; // Protected by this object's RmPrivateLock.
    LIST_ENTRY          linkSiblings; // Protected by parent object's RmPrivateLock.
    
#endif // RM_TRACK_OBJECT_TREE

} RM_OBJECT_HEADER, *PRM_OBJECT_HEADER;


//
// Diagnostic resource tracking.
//
typedef struct
{
    ULONG_PTR               Instance;
    ULONG                   TypeUID;
    PRM_OBJECT_HEADER       pParentObject;
    ULONG                   CallersUID;
    ULONG                   CallersSrUID;

} RM_DBG_RESOURCE_ENTRY;


typedef enum
{
    RM_RESOURCE_OP_LOAD,
    RM_RESOURCE_OP_UNLOAD

} RM_RESOURCE_OPERATION;

typedef
RM_STATUS
(*PFN_RM_RESOURCE_HANDLER)(
    PRM_OBJECT_HEADER       pObj,
    RM_RESOURCE_OPERATION   Op,
    PVOID                   pvUserParams,
    PRM_STACK_RECORD        psr
);

typedef struct _RM_RESOURCE_TABLE_ENTRY
{
    UINT                    ID;
    PFN_RM_RESOURCE_HANDLER pfnHandler;
    
} RM_RESOURCE_TABLE_ENTRY, *PRM_RESOURCE_TABLE_ENTRY;


typedef struct
{
    UINT u;

} RM_OBJECT_INDEX,  *PRM_OBJECT_INDEX;


typedef struct
{
    PRM_OBJECT_HEADER           pOwningObject;
    const char *                szDescription;
    PRM_STATIC_OBJECT_INFO      pStaticInfo;
    RM_HASH_TABLE               HashTable;


    // Private lock used ONLY by group access functions.
    //
    RM_OS_LOCK                      OsLock;

    // When non-NULL, points to the task responsible for unloading all objects
    // in this group.
    //
    PRM_TASK                    pUnloadTask;

    BOOLEAN fEnabled;

} RM_GROUP,  *PRM_GROUP;


typedef enum
{
    RM_TASKOP_START,
    RM_TASKOP_PENDCOMPLETE,
    RM_TASKOP_END,
    RM_TASKOP_PRIVATE,
    RM_TASKOP_ABORT,
    RM_TASKOP_TIMEOUT

} RM_TASK_OPERATION;


typedef
RM_STATUS
(*PFN_RM_TASK_HANDLER)(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Op,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );
//
// For START and PENDCOMPLETE, a return value other than PENDING causes
// the task to end. Of course, it is illegal to return non-pending when
// the task is in a pending state.
//


// Task allocator prototype
//
typedef
RM_STATUS
(*PFN_RM_TASK_ALLOCATOR)(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );

typedef struct _RM_TASK
{
    RM_OBJECT_HEADER                Hdr;

    PFN_RM_TASK_HANDLER             pfnHandler;
    LIST_ENTRY                      linkFellowPendingTasks;
    LIST_ENTRY                      listTasksPendingOnMe;
    struct _RM_TASK *               pTaskIAmPendingOn;


    // In the case that we need to asynchronously notify the completion of a
    // pending operation, we can save the completion param here.
    //
    UINT_PTR                        AsyncCompletionParam;

    UINT                            SuspendContext;

} RM_TASK, *PRM_TASK;

typedef
VOID
(_cdecl *PFN_DBG_DUMP_LOG_ENTRY) (
    char *szFormatString,
    UINT_PTR Param1,
    UINT_PTR Param2,
    UINT_PTR Param3,
    UINT_PTR Param4
);


#if RM_EXTRA_CHECKING

// (For debugging only)
// Keeps track of a single association (See RmDbgAddAssociation)
// This is a PRIVATE data structure, and is only here because
// the kd extension refers to it.
//
typedef struct
{
    ULONG           LocID;
    ULONG_PTR       Entity1;
    ULONG_PTR       Entity2;
    ULONG           AssociationID;
    const char *    szFormatString;
    RM_HASH_LINK    HashLink;

} RM_PRIVATE_DBG_ASSOCIATION;

// (For debugging only)
// Keeps track of a single per-object log entry.
// This is a PRIVATE data structure, and is only here because
// the kd extension refers to it.
//
typedef struct
{
    // Link to other entries for this object
    //
    LIST_ENTRY linkObjectLog;

    // Link to other entries in the global list.
    //
    LIST_ENTRY linkGlobalLog;

    // Object this entry belongs to
    //
    PRM_OBJECT_HEADER   pObject;

    // Function to be used for dumping the log.
    //
    PFN_DBG_DUMP_LOG_ENTRY pfnDumpEntry;

    // Prefix string to be dumped *before* the log display.
    // This was added so we could log associations properly, otherwise it's
    // extra baggage. Can be null.
    //
    char *szPrefix;

    // Format string for log display -- 1st arg to pfnDumpEntry
    //
    char *szFormatString;

    // Remaining args to pfnDumpEntry;
    //
    //
    UINT_PTR Param1;
    UINT_PTR Param2;
    UINT_PTR Param3;
    UINT_PTR Param4;

    // If non-NULL, piece of memory to be freed when the log entry is freed.
    // TODO: See notes.txt  entry "03/07/1999 ... Registering root objects with RM"
    // on how we will find the deallocator function. For now we simply
    // use NdisFreeMemory.
    //
    PVOID pvBuf;

} RM_DBG_LOG_ENTRY;

#endif RM_EXTRA_CHECKING

//=================================================================================
//                      U T I L I T Y       M A C R O S
//=================================================================================

#define RM_PARENT_OBJECT(_pObj)             \
            ((_pObj)->Hdr.pParentObject)

#define RM_PEND_CODE(_pTask)                \
            ((_pTask)->SuspendContext)

#define RM_ASSERT_SAME_LOCK_AS_PARENT(_pObj)                                        \
                ASSERTEX(                                                       \
                    ((_pObj)->Hdr.pLock == (_pObj)->Hdr.pParentObject->pLock),  \
                    (_pObj))

#define RM_SET_STATE(_pObj, _Mask, _Val)    \
            (((_pObj)->Hdr.State) = (((_pObj)->Hdr.State) & ~(_Mask)) | (_Val))

#define RM_CHECK_STATE(_pObj, _Mask, _Val)  \
            ((((_pObj)->Hdr.State) & (_Mask)) == (_Val))

#define RM_GET_STATE(_pObj, _Mask)  \
            (((_pObj)->Hdr.State) & (_Mask))

// Asserts that the object is in the "zombie" state, i.e., it
// lives on just because of references.
// WARNING: It is upto the caller to synchronize access to this -- for example
// if they're going to do thing's like if (!RM_IS_ZOMBIE(pObj)) {do-stuff}, they
// had better make sure that only one of them goes on to "does-stuff".
//
#define RM_IS_ZOMBIE(_pobj) \
            (((_pobj)->Hdr.RmState&RMOBJSTATE_ALLOCMASK)==RMOBJSTATE_DEALLOCATED)

// Asserts that no locks are held.
//
#define RM_ASSERT_NOLOCKS(_psr) \
        ASSERTEX((_psr)->LockInfo.CurrentLevel == 0, (_psr))

// Assert that no locks or tmprefs are held.
//
#define RM_ASSERT_CLEAR(_psr) \
        ASSERTEX(((_psr)->LockInfo.CurrentLevel==0) && (_psr)->TmpRefs==0, (_psr))
        

#if RM_EXTRA_CHECKING

//
// TODO: rename the following to something better...
//

#define RM_DBG_ASSERT_LOCKED0(_pLk, _pSR)   \
    ASSERTEX((_pLk)->DbgInfo.pSR == (_pSR), (_pHdr))

// TODO -- replace calls to this by calls to RM_ASSERT_OBJLOCKED
#define RM_DBG_ASSERT_LOCKED(_pHdr, _pSR)   \
    ASSERTEX((_pHdr)->pLock->DbgInfo.pSR == (_pSR), (_pHdr))

#define RM_ASSERT_OBJLOCKED(_pHdr, _pSR)    \
    ASSERTEX((_pHdr)->pLock->DbgInfo.pSR == (_pSR), (_pHdr))

// Note that we can't assume DbgInfo.pSR is NULL below (it could be locked
// by some other thread), but we CAN assert that DbgInfo.pSR is not equal to the
// current pSR!
//
#define RM_ASSERT_OBJUNLOCKED(_pHdr, _pSR)  \
    ASSERTEX((_pHdr)->pLock->DbgInfo.pSR != (_pSR), (_pHdr))

#else // !RM_EXTRA_CHECKING

#define RM_DBG_ASSERT_LOCKED0(_pLk, _pSR)   (0)
#define RM_DBG_ASSERT_LOCKED(_pHdr, _pSR)   (0)
#define RM_ASSERT_OBJLOCKED(_pHdr, _pSR)    (0)
#define RM_ASSERT_OBJUNLOCKED(_pHdr, _pSR)  (0)


#endif // !RM_EXTRA_CHECKING

#define RM_NUM_ITEMS_IN_GROUP(_pGroup) \
            ((_pGroup)->HashTable.NumItems)

//=================================================================================
//                  F U N C T I O N     P R O T O T Y P E S
//=================================================================================

VOID
RmInitializeRm(VOID);

VOID
RmDeinitializeRm(VOID);

VOID
RmInitializeHeader(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  UINT                        Sig,
    IN  PRM_LOCK                    pLock,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  const char *                szDescription,
    IN  PRM_STACK_RECORD            pSR
    );
//
// Object allocation and deallocation APIs
//

VOID
RmDeallocateObject(
    IN  PRM_OBJECT_HEADER           pObject,
    IN  PRM_STACK_RECORD            pSR
    );


//
// locking
//

VOID
RmInitializeLock(
    IN PRM_LOCK pLock,
    IN UINT     Level
    );

VOID
RmDoWriteLock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    );

#if TODO
VOID
RmDoReadLock(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );
#else //!TODO
#define RmDoReadLock    RmDoWriteLock
#endif //!TODO

VOID
RmDoUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    );


#if TODO
VOID
RmReadLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    );
#else //!TODO
#define RmReadLockObject RmWriteLockObject
#endif //!TODO

VOID
RmWriteLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlockObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlockAll(
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDbgChangeLockScope(
    IN  PRM_OBJECT_HEADER           pPreviouslyLockedObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG                       LocID,
    IN  PRM_STACK_RECORD            
    );

//
// reference counting
//

VOID
RmLinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSr
    );

VOID
RmUnlinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSr
    );

VOID
RmLinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  ULONG                       InvAssocID,
    IN  const char *                szInvAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  ULONG                       InvAssocID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmLinkToExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlinkFromExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmLinkToExternalFast( // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    );

VOID
RmUnlinkFromExternalFast(   // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    );

VOID
RmTmpReferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmTmpDereferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

//
// Generic resource management
//

RM_STATUS
RmLoadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnloadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnloadAllGenericResources(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

//
// Diagnostic per-object tracking of arbitrary "associations"
//

//
// NOTE: AssociationID must not have the high-bit set. Associations with the
// high bit set are reserved for internal use of the Rm API implementation.
//

VOID
RmDbgAddAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Instance1,
    IN  ULONG_PTR                   Instance2,
    IN  ULONG                       AssociationID,
    IN  const char *                szFormatString, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDbgDeleteAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Entity1,
    IN  ULONG_PTR                   Entity2,
    IN  ULONG                       AssociationID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDbgPrintAssociations(
    IN  PRM_OBJECT_HEADER pObject,
    IN  PRM_STACK_RECORD pSR
    );

//
// Diagnostic per-object logging.
//

VOID
RmDbgLogToObject(
    IN  PRM_OBJECT_HEADER       pObject,
    IN  char *                  szPrefix,       OPTIONAL
    IN  char *                  szFormatString,
    IN  UINT_PTR                Param1,
    IN  UINT_PTR                Param2,
    IN  UINT_PTR                Param3,
    IN  UINT_PTR                Param4,
    IN  PFN_DBG_DUMP_LOG_ENTRY  pfnDumpEntry,   OPTIONAL
    IN  PVOID                   pvBuf           OPTIONAL
    );


VOID
RmDbgPrintObjectLog(
    IN PRM_OBJECT_HEADER pObject
    );

VOID
RmDbgPrintGlobalLog(VOID);

//
// Groups of Objects
//


VOID
RmInitializeGroup(
    IN  PRM_OBJECT_HEADER           pOwningObject,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  PRM_GROUP                   pGroup,
    IN  const char*                 szDescription,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDeinitializeGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    );

RM_STATUS
RmLookupObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  ULONG                       Flags, // Lookup flags defined below
    IN  PVOID                       pvKey,
    IN  PVOID                       pvCreateParams,
    OUT PRM_OBJECT_HEADER *         ppObject,
    OUT INT *                       pfCreated,
    IN  PRM_STACK_RECORD            pSR
    );

//
//  Lookup flags
//
#define RM_CREATE       0x1
#define RM_NEW          (0x1<<1)
#define RM_LOCKED       (0x1<<2)


#define RM_CREATE_AND_LOCK_OBJECT_IN_GROUP(_pGrp, _pKey, _pParams, _ppHdr, _fC,_psr)\
        RmLookupObjectInGroup(                                                      \
                            (_pGrp),                                                \
                            RM_CREATE|RM_NEW|RM_LOCKED,                             \
                            (_pKey),                                                \
                            (_pParams),                                             \
                            (_ppHdr),                                               \
                            (_fC),                                                  \
                            (_psr)                                                  \
                            );

// RM_STATUS
// RM_LOOKUP_AND_LOCK_OBJECT_IN_GROUP(
//                  PRM_GROUP           _pGrp,
//                  PVOID               _pKey,
//                  PRM_OBJECT_HEADER * _ppHdr,
//                  PRM_STACK_RECORD    _psr
//                  )
// Lookup (don't create) and lock an object in the specified group.
//
#define RM_LOOKUP_AND_LOCK_OBJECT_IN_GROUP(_pGrp, _pKey, _ppHdr, _psr)              \
        RmLookupObjectInGroup(                                                      \
                            (_pGrp),                                                \
                            RM_LOCKED,                                              \
                            (_pKey),                                                \
                            NULL,                                                   \
                            (_ppHdr),                                               \
                            NULL,                                                   \
                            (_psr)                                                  \
                            );

RM_STATUS
RmGetNextObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pCurrentObject,     OPTIONAL
    OUT PRM_OBJECT_HEADER *         ppNextObject,
    IN  PRM_STACK_RECORD            pSR
    );


VOID
RmFreeObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmFreeAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnloadAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    PFN_RM_TASK_ALLOCATOR           pfnUnloadTaskAllocator,
    PFN_RM_TASK_HANDLER             pfnUnloadTaskHandler,
    PVOID                           pvUserParam,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  UINT                        uTaskPendCode, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmEnableGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    );



// Enumeration function prototype. This function is passed into
// RmEnumerateObjectsInGroup and gets called for each object in the group
// until the function returns FALSE.
//
typedef
INT
(*PFN_RM_GROUP_ENUMERATOR) (
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );

VOID
RmEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnFunction,
    PVOID                   pvContext,
    INT                     fStrong,
    PRM_STACK_RECORD        pSR
    );

VOID
RmWeakEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnFunction,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    );

//
// Task APIs
//

VOID
RmInitializeTask(
IN  PRM_TASK                    pTask,
IN  PRM_OBJECT_HEADER           pParentObject,
IN  PFN_RM_TASK_HANDLER         pfnHandler,
IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,    OPTIONAL
IN  const char *                szDescription,  OPTIONAL
IN  UINT                        Timeout,
IN  PRM_STACK_RECORD            pSR
);


RM_STATUS
RmStartTask(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    UserParam,
IN  PRM_STACK_RECORD            pSR
);


VOID
RmAbortTask(
IN  PRM_TASK                    pTask,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmDbgDumpTask(
IN  PRM_TASK                    pTask,
IN  PRM_STACK_RECORD            pSR
);

RM_STATUS
RmSuspendTask(
IN  PRM_TASK                    pTask,
IN  UINT                        SuspendContext,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmUnsuspendTask(
IN  PRM_TASK                    pTask,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmResumeTask(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    SuspendCompletionParam,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmResumeTaskAsync(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    SuspendCompletionParam,
IN  OS_WORK_ITEM            *   pOsWorkItem,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmResumeTaskDelayed(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    SuspendCompletionParam,
IN  ULONG                       MsDelay,
IN  OS_TIMER                *   pOsTimerObject,
IN  PRM_STACK_RECORD            pSR
);


VOID
RmResumeDelayedTaskNow(
IN  PRM_TASK                    pTask,
IN  OS_TIMER                *   pOsTimer,
OUT PUINT                       pTaskResumed,
IN  PRM_STACK_RECORD            pSR
);

RM_STATUS
RmPendTaskOnOtherTask(
IN  PRM_TASK                    pTask,
IN  UINT                        SuspendContext,
IN  PRM_TASK                    pOtherTask,
IN  PRM_STACK_RECORD            pSR
);

// See  03/26/1999 notes.txt entry "Some proposed ..."
//
RM_STATUS
RmPendOnOtherTaskV2(
IN  PRM_TASK                    pTask,
IN  UINT                        SuspendContext,
IN  PRM_TASK                    pOtherTask,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmCancelPendOnOtherTask(
IN  PRM_TASK                    pTask,
IN  PRM_TASK                    pOtherTask,
IN  UINT_PTR                    UserParam,
IN  PRM_STACK_RECORD            pSR
);

//
// Timer management
//
VOID
RmResetAgeingTimer(
IN  PRM_OBJECT_HEADER           pObj,
IN  UINT                        Timeout,
IN  PRM_STACK_RECORD            pSR
);

//
// Hash table manipulation.
//

VOID
RmInitializeHashTable(
PRM_HASH_INFO pHashInfo,
PVOID         pAllocationContext,
PRM_HASH_TABLE pHashTable
);

VOID
RmDeinitializeHashTable(
PRM_HASH_TABLE pHashTable
);

BOOLEAN
RmLookupHashTable(
PRM_HASH_TABLE      pHashTable,
PRM_HASH_LINK **    pppLink,
PVOID               pvRealKey
);

BOOLEAN
RmNextHashTableItem(
PRM_HASH_TABLE      pHashTable,
PRM_HASH_LINK       pCurrentLink,   // OPTIONAL
PRM_HASH_LINK *    ppNextLink
);

VOID
RmAddHashItem(
PRM_HASH_TABLE  pHashTable,
PRM_HASH_LINK * ppLink,
PRM_HASH_LINK   pLink,
PVOID           pvKey
);

VOID
RmRemoveHashItem(
PRM_HASH_TABLE  pHashTable,
PRM_HASH_LINK   pLinkToRemove
);

typedef
VOID
(*PFN_ENUM_HASH_TABLE)
(
PRM_HASH_LINK pLink,
PVOID pvContext,
PRM_STACK_RECORD pSR
);

VOID
RmEnumHashTable(
PRM_HASH_TABLE          pHashTable,
PFN_ENUM_HASH_TABLE     pfnEnumerator,
PVOID                   pvContext,
PRM_STACK_RECORD        pSR
);

#if OBSOLETE
//
// Indexes of objects.
//

RM_STATUS
RmAllocateObjectIndex(
IN  PRM_OBJECT_HEADER           pParentObject,
// OBSOLETE IN  PRM_OBJECT_ALLOCATOR        pObjectAllocator,
IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
IN  PULONG                      Flags,
OUT PRM_OBJECT_INDEX *          ppObjectIndex,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmFreeObjectIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PRM_STACK_RECORD            pSR
);

RM_STATUS
RmLookupObjectInIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PULONG                      Flags, // create, remove, lock
IN  PVOID                       pvKey,
OUT PRM_OBJECT_HEADER *         ppObject,
IN  PRM_STACK_RECORD            pSR
);


RM_STATUS
RmRemoveObjectFromIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PRM_OBJECT_HEADER           pObject,
IN  PRM_STACK_RECORD            pSR
);

typedef
RM_STATUS
(*PFN_RM_OBJECT_INDEX_ENUMERATOR)(
IN  PRM_OBJECT_HEADER           pObject,
IN  PVOID                       pvContext,
IN  PRM_STACK_RECORD            pSR
);

RmEnumerateObjectsInIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PFN_RM_OBJECT_INDEX_ENUMERATOR
                                pfnEnumerator,
IN  PRM_STACK_RECORD            pSR
);

#endif // OBSOLETE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\priv.h ===
/*++
Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    priv.h

Abstract:

    Private structure definitions and function templates for the 1394 ARP module.

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     11-17-98    created

--*/

#define ARP1394_SYMBOLIC_NAME       L"\\DosDevices\\ARP1394"
#define ARP1394_DEVICE_NAME         L"\\Device\\ARP1394"
#define ARP1394_UL_NAME             L"ARP1394"
#define ARP1394_LL_NAME             L"TCPIP_ARP1394"

#define ARP1394_NDIS_MAJOR_VERSION      5
#define ARP1394_NDIS_MINOR_VERSION      0

// The physical address length, as reported to IP in the following places:
//                      
//      IFEntry.if_physaddr (on WIN98, IFEntry.if_physaddr is truncated to 6 bytes)
//      LLIPBindInfo.lip_addr
//      IPNetToMediaEntry.inme_physaddr
//
// Note that may be (and in fact currently is) less then the actual length of
// the actual IEEE1394 FIFO physical-address length.
//
#define ARP1394_IP_PHYSADDR_LEN         6 // TODO: make 8

// The levels of the various types of locks
//
enum
{
    LOCKLEVEL_GLOBAL=1, // Must start > 0.
    LOCKLEVEL_ADAPTER,
    LOCKLEVEL_IF_SEND

};

#define ARP1394_GLOBALS_SIG 'G31A'

// TODO: read this from configuration. Set default based on the ip/1394 standard.
//

#define ARP1394_ADAPTER_MTU         1520

#define ARP1394_MAX_PROTOCOL_PKTS   1000
#define ARP1394_MAX_PROTOCOL_PACKET_SIZE 1600 // We need to forward between ICS.

#define ARP1394_ADDRESS_RESOLUTION_TIMEOUT  1000 // Ms
#define ARP1394_MAX_ETHERNET_PKTS   4

// Delay between polling for connect status.
//
#define ARP1394_WAIT_FOR_CONNECT_STATUS_TIMEOUT             5000

//
// Packet flags for packets allocated by us.
// Go into protocol-context (pc_common.pc_flags) of the packet.
//
#define ARP1394_PACKET_FLAGS_ARP            0
#define ARP1394_PACKET_FLAGS_ICS            1
#define ARP1394_PACKET_FLAGS_MCAP           2
#define ARP1394_PACKET_FLAGS_DBGCOPY        3
#define ARP1394_PACKET_FLAGS_IOCTL          4


    
//
// Pre allocation constants to avoid low memory condition
// 
#define ARP1394_BACKUP_TASKS 4

// Forward references
//
typedef struct _ARP1394_INTERFACE ARP1394_INTERFACE;
typedef struct _ARPCB_LOCAL_IP      ARPCB_LOCAL_IP;
typedef struct _ARPCB_REMOTE_IP     ARPCB_REMOTE_IP;
typedef struct _ARPCB_REMOTE_ETH    ARPCB_REMOTE_ETH;
typedef struct _ARPCB_DEST          ARPCB_DEST, *PARPCB_DEST;


typedef IPAddr IP_ADDRESS, *PIP_ADDRESS;
typedef IPMask IP_MASK, *PIP_MASK;

typedef int MYBOOL; // Like BOOL

typedef struct _ARP1394_GLOBALS
{
    RM_OBJECT_HEADER            Hdr;

    RM_LOCK                     Lock;

    // Driver global state
    //
    struct
    {
        // Handle to Driver Object for ARP1394
        //
        PVOID                       pDriverObject;
    
        // Handle to the single device object representing this driver.
        //
        PVOID pDeviceObject;

    } driver;

    // Global NDIS State
    // 
    struct
    {
        // NDIS' protocol handle, returned in NdisRegisterProtocol
        //
        NDIS_HANDLE ProtocolHandle;
    
        // NDIS Protocol characteristics
        //
        NDIS_PROTOCOL_CHARACTERISTICS PC;
    
        // NDIS Client characteristics
        NDIS_CLIENT_CHARACTERISTICS CC;

    } ndis;

    // Global IP State
    //
    struct
    {
        //  Handle returned by IPRegisterARP
        //
        HANDLE                      ARPRegisterHandle;
    
        // Following are callback's into IP, set in IPRegisterARP
        //
        IP_ADD_INTERFACE            pAddInterfaceRtn;   // add an interface
        IP_DEL_INTERFACE            pDelInterfaceRtn;   // delete an interface
        IP_BIND_COMPLETE            pBindCompleteRtn;   // inform of bind cmpl
        IP_ADD_LINK                 pAddLinkRtn;
        IP_DELETE_LINK              pDeleteLinkRtn;

    } ip;

    // Global adapter list
    //
    struct {
        RM_GROUP Group;
    } adapters;

    // Global List of backup tasks
    SLIST_HEADER  BackupTasks;
    NDIS_SPIN_LOCK    BackupTaskLock;
    UINT           NumTasks;
}
ARP1394_GLOBALS;

extern ARP1394_GLOBALS  ArpGlobals;

typedef struct // ARP1394_ADAPTER
{
    RM_OBJECT_HEADER            Hdr;
    RM_LOCK                     Lock;

    //
    // PRIMARY_STATE flags (in Hdr.State)
    //
    //  PRIMARY_STATE is the primary state of the adapter.
    //

    #define ARPAD_PS_MASK               0x00f
    #define ARPAD_PS_DEINITED           0x000
    #define ARPAD_PS_INITED             0x001
    #define ARPAD_PS_FAILEDINIT         0x002
    #define ARPAD_PS_INITING            0x003
    #define ARPAD_PS_REINITING          0x004
    #define ARPAD_PS_DEINITING          0x005

    #define SET_AD_PRIMARY_STATE(_pAD, _IfState) \
                RM_SET_STATE(_pAD, ARPAD_PS_MASK, _IfState)
    
    #define CHECK_AD_PRIMARY_STATE(_pAD, _IfState) \
                RM_CHECK_STATE(_pAD, ARPAD_PS_MASK, _IfState)

    #define GET_AD_PRIMARY_STATE(_pAD) \
                RM_GET_STATE(_pAD, ARPAD_PS_MASK)


    //
    // ACTIVE_STATE flags (in Hdr.State)
    //
    // ACTIVE_STATE is a secondary state of the adapter.
    // Primary state takes precedence over secondary sate. For example,
    // the interface is REINITING and ACTIVE, one should not actively use the
    // interface.
    //
    // NOTE: When the primary state is INITED, the secondary state WILL be
    // ACTIVATED. It is thus usually only necessary to look at the primary state.
    //

    #define ARPAD_AS_MASK               0x0f0
    #define ARPAD_AS_DEACTIVATED        0x000
    #define ARPAD_AS_ACTIVATED          0x010
    #define ARPAD_AS_FAILEDACTIVATE     0x020
    #define ARPAD_AS_DEACTIVATING       0x030
    #define ARPAD_AS_ACTIVATING         0x040

    #define SET_AD_ACTIVE_STATE(_pAD, _IfState) \
                RM_SET_STATE(_pAD, ARPAD_AS_MASK, _IfState)
    
    #define CHECK_AD_ACTIVE_STATE(_pAD, _IfState) \
                RM_CHECK_STATE(_pAD, ARPAD_AS_MASK, _IfState)

    #define GET_AD_ACTIVE_STATE(_pAD) \
                RM_GET_STATE(_pAD, ARPAD_AS_MASK)


    // BRIDGE (Ethernet Emulation) state (in Hdr.State)
    //
    #define ARPAD_BS_MASK               0x100
    #define ARPAD_BS_ENABLED            0x100
 
    
    #define ARP_ENABLE_BRIDGE(_pAD) \
                RM_SET_STATE(_pAD, ARPAD_BS_MASK, ARPAD_BS_ENABLED)
    #define ARP_BRIDGE_ENABLED(_pAD) \
                RM_CHECK_STATE(_pAD, ARPAD_BS_MASK, ARPAD_BS_ENABLED)

    #define SET_BS_FLAG(_pAD, _IfState) \
                RM_SET_STATE(_pAD, ARPAD_BS_MASK, _IfState)
    
    #define CHECK_BS_FLAG(_pAD, _IfState) \
                RM_CHECK_STATE(_pAD, ARPAD_BS_MASK, _IfState)

    #define GET_BS_ACTIVE_STATE(_pAD) \
                RM_GET_STATE(_pAD, ARPAD_BS_MASK)

    #define ARPAD_POWER_MASK            0xf000
    #define ARPAD_POWER_LOW_POWER       0x1000
    #define ARPAD_POWER_NORMAL          0x0000

    #define SET_POWER_STATE(_pAD, _PoState) \
                RM_SET_STATE(_pAD, ARPAD_POWER_MASK , _PoState)
    
    #define CHECK_POWER_STATE(_pAD, _PoState) \
                RM_CHECK_STATE(_pAD, ARPAD_POWER_MASK, _PoState)

    #define GET_POWER_ACTIVE_STATE(_pAD) \
                RM_GET_STATE(_pAD, ARPAD_POWER_MASK)


    
    // NDIS bind info.
    //
    struct
    {
        NDIS_STRING                 ConfigName;
        NDIS_STRING                 DeviceName;
        PVOID                       IpConfigHandle;
        NDIS_HANDLE                 BindContext;

        // Init/Deinit/Reinit task
        //
        PRM_TASK pPrimaryTask;
    
        // Activate/Deactivate task
        //
        PRM_TASK pSecondaryTask;

        NDIS_HANDLE                 AdapterHandle;

        // This is read from the configuration information in the registry.
        // It is a multisz string, in theory it could contain the config-strings
        // of multiple interfaces, although IP/1394 only provides one.
        //
        NDIS_STRING                 IpConfigString;


    } bind;

    // Information about the adapter, obtained by querying it.
    // Note: MTU is the MTU reported by the adapter, and is not the same
    // as the MTU reported up to ip (the latter MTU is in the ARP1394_INTERFACE
    // structure).
    //
    struct
    {
        ULONG                       MTU;

        // Maximum speed, in bytes per second, that the local host controller
        // is capable of.
        //
        ULONG                       Speed;

    #if OBSOLETE
        // Minimum size (in bytes) of:
        //   -- Max individual async write to any remote node
        //   -- Max individual async write to any channel
        //   -- Max block we can receive on our recv FIFO
        //   -- Max block we can receive on any channel
        //
        ULONG                       MaxBlockSize;
    #endif // 0

        // max_rec (Maximum bus data record size)
        // size == 2^(max_rec+1).
        // (Macro  IP1394_MAXREC_TO_SIZE in rfc.h)
        //
        //
        ULONG                       MaxRec;

        ULONG                       MaxSpeedCode;

        //NIC1394_FIFO_ADDRESS      LocalHwAddress;
        UINT64                      LocalUniqueID;
        UCHAR *                     szDescription;
        UINT                        DescriptionLength; // including null termination.

        // This address is synthesized using the adapter's EU64 unique ID.
        //
        ENetAddr EthernetMacAddress;


    } info;

    struct 
    {

        //
        // Current Power State
        //
        NET_DEVICE_POWER_STATE  State;

        NDIS_EVENT Complete;
        //
        // Boolean variable to track the state on resume
        //
        BOOLEAN                 bReceivedSetPowerD0;
        BOOLEAN                 bReceivedAf;
        BOOLEAN                 bReceivedUnbind;
        BOOLEAN                 bResuming;
        BOOLEAN                 bFailedResume;
        
    }PoMgmt;

    // The IP interface control block (only one per adapter).
    //
    ARP1394_INTERFACE *pIF;

    // Bus Topology of the 1394 card below this adapter
    //
    EUID_TOPOLOGY EuidMap;

    //
    // Set when a Workitem is queued to query Node Addresses
    //
    MYBOOL fQueryAddress;

    //
    // Power State of the Adapter
    //
    NET_DEVICE_POWER_STATE    PowerState;
}
ARP1394_ADAPTER, *PARP1394_ADAPTER;


// This structure maintains a pool of buffers, all pointing to
// the same area of memory (whose contents are expected to be CONSTANT).
// The primary use of this structure is to maintain a pool of encapsulation headers
// buffers.
//
typedef struct _ARP_CONST_BUFFER_POOL
{
    NDIS_HANDLE             NdisHandle;         // Buffer pool handle
    PRM_OBJECT_HEADER       pOwningObject;      // ptr to object that owns this list

    // Following stuff just for statistics gathering.
    // TODO: consider conditionally-compiling this.
    //
    struct
    {
        UINT                TotBufAllocs;       // # allocs from buffer pool 
        UINT                TotCacheAllocs;     // # allocs from cache list
        UINT                TotAllocFails;      // # failed allocs

    } stats;

    UINT                    NumBuffersToCache;  // Number to keep inited and cached
    UINT                    MaxBuffers;         // Max number to allocate
    UINT                    cbMem;              // Size in bytes of mem below...
    const   VOID*           pvMem;              // Ptr to memory containg encap data
    UINT                    NumAllocd;          // # outstanding allocs from pool
    UINT                    NumInCache;         // # items sitting in cache.
    NDIS_SPIN_LOCK          NdisLock;           // Spinlock protecting the list below
    SLIST_HEADER            BufferList;         // List of available, inited bufs

} ARP_CONST_BUFFER_POOL;


// This structure is used when calling NdisRequest.
//
typedef struct _ARP_NDIS_REQUEST
{
    NDIS_REQUEST    Request;            // The NDIS request structure.
    NDIS_EVENT      Event;              // Event to signal when done.
    PRM_TASK        pTask;              // Task to resume when done.
    NDIS_STATUS     Status;             // Status of completed request.

} ARP_NDIS_REQUEST, *PARP_NDIS_REQUEST;


// Static set of information associated with a VC, mainly co-ndis call handlers.
//
typedef struct
{
    PCHAR                           Description;
    CO_SEND_COMPLETE_HANDLER        CoSendCompleteHandler;
    // CO_STATUS_HANDLER                CoStatusHandler;
    CO_RECEIVE_PACKET_HANDLER       CoReceivePacketHandler;
    // CO_AF_REGISTER_NOTIFY_HANDLER    CoAfRegisterNotifyHandler;


    // CL_MAKE_CALL_COMPLETE_HANDLER    ClMakeCallCompleteHandler;
    // CL_CLOSE_CALL_COMPLETE_HANDLER   ClCloseCallCompleteHandler;
    CL_INCOMING_CLOSE_CALL_HANDLER  ClIncomingCloseCallHandler;

    // Vc type is currently used just for stats. We may get rid of some of the
    // handlers above and use the vctype instead.
    //
    enum
    {
        ARPVCTYPE_SEND_FIFO,
        ARPVCTYPE_RECV_FIFO,
        ARPVCTYPE_BROADCAST_CHANNEL,
        ARPVCTYPE_MULTI_CHANNEL,
        ARPVCTYPE_ETHERNET,
        ARPVCTYPE_SEND_CHANNEL,
        ARPVCTYPE_RECV_CHANNEL,
    } VcType;

    BOOLEAN IsDestVc;
    
} ARP_STATIC_VC_INFO, *PARP_STATIC_VC_INFO;



// ARP's protocol vc context has this common header.
//
typedef struct
{
    PARP_STATIC_VC_INFO pStaticInfo;

    // Ndis VC handle associated with the VC. 
    //
    NDIS_HANDLE NdisVcHandle;

    // These two tasks are for making and tearingdown the VC, 
    // respectively.
    //
    PRM_TASK    pMakeCallTask;
    PRM_TASK    pCleanupCallTask;

} ARP_VC_HEADER, *PARP_VC_HEADER;

typedef struct
{
    // Channel number.
    //
    UINT            Channel;

    // IP multicast group address bound to this channel.
    //
    IP_ADDRESS      GroupAddress;

    // Absolute time at which this information was updated,
    // in seconds.
    //
    UINT            UpdateTime;

    // Absolute time at which this mapping will expire.
    // In seconds.
    //
    UINT            ExpieryTime;

    UINT            SpeedCode;

    // TBD
    //
    UINT            Flags;  // One of the MCAP_CHANNEL_FLAGS_*
    #define MCAP_CHANNEL_FLAGS_LOCALLY_ALLOCATED 0x1

    // NodeID of owner of this channel.
    //
    UINT            NodeId;

} MCAP_CHANNEL_INFO, *PMCAP_CHANNEL_INFO;


// The IP interface control block.
//
typedef struct _ARP1394_INTERFACE
{
    RM_OBJECT_HEADER Hdr;

    //
    // PRIMARY_STATE flags (in Hdr.State)
    //
    //  PRIMARY_STATE is the primary state of the interface.
    //

    #define ARPIF_PS_MASK               0x00f
    #define ARPIF_PS_DEINITED           0x000
    #define ARPIF_PS_INITED             0x001
    #define ARPIF_PS_FAILEDINIT         0x002
    #define ARPIF_PS_INITING            0x003
    #define ARPIF_PS_REINITING          0x004
    #define ARPIF_PS_DEINITING          0x005
    #define ARPIF_PS_LOW_POWER          0x006

    #define SET_IF_PRIMARY_STATE(_pIF, _IfState) \
                RM_SET_STATE(_pIF, ARPIF_PS_MASK, _IfState)
    
    #define CHECK_IF_PRIMARY_STATE(_pIF, _IfState) \
                RM_CHECK_STATE(_pIF, ARPIF_PS_MASK, _IfState)

    #define GET_IF_PRIMARY_STATE(_pIF) \
                RM_GET_STATE(_pIF, ARPIF_PS_MASK)


    //
    // ACTIVE_STATE flags (in Hdr.State)
    //
    // ACTIVE_STATE is a secondary state of the interface.
    // Primary state takes precedence over secondary sate. For example,
    // the interface is REINITING and ACTIVE, one should not actively use the
    // interface.
    //
    // NOTE: When the primary state is INITED, the secondary state WILL be
    // ACTIVATED. It is thus usually only necessary to look at the primary state.
    //

    #define ARPIF_AS_MASK               0x0f0
    #define ARPIF_AS_DEACTIVATED        0x000
    #define ARPIF_AS_ACTIVATED          0x010
    #define ARPIF_AS_FAILEDACTIVATE     0x020
    #define ARPIF_AS_DEACTIVATING       0x030
    #define ARPIF_AS_ACTIVATING         0x040
    
    #define SET_IF_ACTIVE_STATE(_pIF, _IfState) \
                RM_SET_STATE(_pIF, ARPIF_AS_MASK, _IfState)
    
    #define CHECK_IF_ACTIVE_STATE(_pIF, _IfState) \
                RM_CHECK_STATE(_pIF, ARPIF_AS_MASK, _IfState)

    #define GET_IF_ACTIVE_STATE(_pIF) \
                RM_GET_STATE(_pIF, ARPIF_AS_MASK)

    //
    // IP_STATE flags  (in Hdr.State)
    //
    // This state is set to OPEN when our open handler (ArpIpOpen) is called, and
    // to CLOSED when our close handler (ArpIpClose) is called
    //
    #define ARPIF_IPS_MASK              0xf00
    #define ARPIF_IPS_CLOSED            0x000
    #define ARPIF_IPS_OPEN              0x100
    
    #define SET_IF_IP_STATE(_pIF, _IfState) \
                RM_SET_STATE(_pIF, ARPIF_IPS_MASK, _IfState)
    
    #define CHECK_IF_IP_STATE(_pIF, _IfState) \
                RM_CHECK_STATE(_pIF, ARPIF_IPS_MASK, _IfState)

    #define GET_IF_IP_STATE(_pIF) \
                RM_GET_STATE(_pIF, ARPIF_IPS_MASK)


    // Init/Deinit/Reinit task
    //
    PRM_TASK pPrimaryTask;

    // Activate/Deactivate task
    //
    PRM_TASK pActDeactTask;

    // Maintenance task
    //
    PRM_TASK pMaintenanceTask;

    // Ndis-provided handlers and handles.
    //
    struct
    {
        // Cashed value of the adapter handle.
        //
        NDIS_HANDLE AdapterHandle;

        // The address family handle.
        //
        NDIS_HANDLE AfHandle;

    } ndis;

    // Stuff directly relating to interaction with IP.
    //
    struct
    {

        //
        // Following passed in from IP.
        //
        PVOID               Context;            // Use in calls to IP
        ULONG               IFIndex;            // Interface number
        IPRcvRtn            RcvHandler;     // Indicate Receive
        IPTxCmpltRtn        TxCmpltHandler; // Transmit Complete
        IPStatusRtn         StatusHandler;
        IPTDCmpltRtn        TDCmpltHandler; // Transfer Data Complete
        IPRcvCmpltRtn       RcvCmpltHandler;    // Receive Complete
        IPRcvPktRtn         RcvPktHandler;  // Indicate Receive Packet

        IP_PNP              PnPEventHandler;

        //
        // Following passed up to IP.
        //
        ULONG                       MTU;            // Max Transmision Unit (bytes)

        NDIS_STRING                 ConfigString;


        // Following are for IP's query/set info functionality.
        //
        UINT                        ATInstance;     // Instance # for this AT Entity
        UINT                        IFInstance;     // Instance # for this IF Entity

        //
        // Other stuff ...
        //

        // Defaults to all-1's, but may be set by ip to be something different
        // (actually the only other possibility is all-0's, when the stack is
        // running in "BSD compatibility mode".
        // This field is used to decide where a given destination address is
        // unicast or not.
        //
        //
        IP_ADDRESS BroadcastAddress;

        // This address is used in filling out ARP requests.
        //
        IP_ADDRESS DefaultLocalAddress;

    #if TODO

    #ifdef PROMIS
        NDIS_OID            EnabledIpFilters;   // Set of enabled oids -- 
                                                // set/cleared using 
                                                // arpIfSetNdisRequest.
    #endif // PROMIS
    #endif // TODO

    } ip;

    // Statistics 
    //
    //  WARNING:   arpResetIfStats() zeros this entire structure, then
    //              selectively re-inits some fields, such as StatsResetTime.
    //
    struct
    {
        // Following for MIB stats
        //
        ULONG               LastChangeTime;     // Time of last state change
        ULONG               InOctets;           // Input octets
        ULONG               InUnicastPkts;      // Input Unicast packets
        ULONG               InNonUnicastPkts;   // Input Non-unicast packets
        ULONG               OutOctets;          // Output octets
        ULONG               OutUnicastPkts;     // Output Unicast packets
        ULONG               OutNonUnicastPkts;  // Output Non-unicast packets
        ULONG               InDiscards;
        ULONG               InErrors;
        ULONG               UnknownProtos;
        ULONG               OutDiscards;
        ULONG               OutErrors;
        ULONG               OutQlen;

        //
        // Following for our private statistics gathering.
        //

        // Timestamp since the last reset of statistics collection.
        // Set by a call to NdisGetCurrentSystemTime.
        //
        LARGE_INTEGER               StatsResetTime;     // In 100-nanoseconds.
        LARGE_INTEGER               PerformanceFrequency; // In Hz.

        //
        // Some send pkt stats
        //
        struct
        {
            UINT                    TotSends;
            UINT                    FastSends;
            UINT                    MediumSends;
            UINT                    SlowSends;
            UINT                    BackFills;
            // UINT                 HeaderBufUses;
            // UINT                 HeaderBufCacheHits;
            ARP1394_PACKET_COUNTS   SendFifoCounts;
            ARP1394_PACKET_COUNTS   SendChannelCounts;

        } sendpkts;
    
        //
        // Some recv pkt stats
        //
        struct
        {
            UINT                    TotRecvs;
            UINT                    NoCopyRecvs;
            UINT                    CopyRecvs;
            UINT                    ResourceRecvs;
            ARP1394_PACKET_COUNTS   RecvFifoCounts;
            ARP1394_PACKET_COUNTS   RecvChannelCounts;
        } recvpkts;
            

        //
        // Task statistics
        //
        struct
        {
            UINT    TotalTasks;
            UINT    CurrentTasks;
            UINT    TimeCounts[ARP1394_NUM_TASKTIME_SLOTS];

        } tasks;

        //
        // Arp cache stats
        //
        struct {
            UINT    TotalQueries;
            UINT    SuccessfulQueries;
            UINT    FailedQueries;
            UINT    TotalResponses;
            UINT    TotalLookups;
            // UINT TraverseRatio; << this is picked up by looking into the
            //                     << hash table data structure.

        } arpcache;

        //
        // Call stats
        //
        struct
        {
            //
            // FIFO-related call stats.
            //
            UINT    TotalSendFifoMakeCalls;
            UINT    SuccessfulSendFifoMakeCalls;
            UINT    FailedSendFifoMakeCalls;
            UINT    IncomingClosesOnSendFifos;
        
            //
            // Channel-related call stats.
            //
            UINT    TotalChannelMakeCalls;
            UINT    SuccessfulChannelMakeCalls;
            UINT    FailedChannelMakeCalls;
            UINT    IncomingClosesOnChannels;

        } calls;

    } stats;

    //  Group containing local ip addresses, of type  ARPCB_LOCAL_IP
    //
    RM_GROUP LocalIpGroup;

    // Group containing remote ip addresses, of type ARPCB_REMOTE_IP
    // (this is the arp cache)
    //
    RM_GROUP RemoteIpGroup;

    // Group containing remote ethernet destinations. This group is only used
    // if the adapter is operating in bridge mode.
    // This is the Ethernet address cache.
    //
    RM_GROUP RemoteEthGroup;

    // Group containing remote h/w distinations, of type ARPCB_DEST
    // (each ARPCB_DEST has a group of VCs)
    //
    RM_GROUP DestinationGroup;

    // Group containing the table (bridge only) of dhcp session, and their
    // associated physical addresses
    //
    RM_GROUP EthDhcpGroup;

    // Stuff relating to the receive FIFO, which is owned by the interface.
    //
    //
    struct {

        ARP_VC_HEADER VcHdr;
        
        // Address  offset of the receive VC
        //
        struct
        {
            ULONG               Off_Low;
            USHORT              Off_High;

        } offset;
    } recvinfo;

    // This maintains interface-wide information relevant to the send path.
    //
    struct
    {
        // Lock used exclusively for sending.
        // Protects the following:
        //      ??? this->sendinfo.listPktsWaitingForHeaders
        //      ??? this->sendinfo.NumSendPacketsWaiting
        //      pLocalIp->sendinfo
        //      pDest->sendinfo
        //
        //
        RM_LOCK     Lock;

        // List of send packets waiting for header buffers to become available.
        //
        LIST_ENTRY  listPktsWaitingForHeaders;

        // Length of the above list
        //
        UINT        NumSendPacketsWaiting;

        // Pool of header buffer pool. This is seralized by its OWN lock,
        // not by sendinfo.Lock.
        //
        ARP_CONST_BUFFER_POOL   HeaderPool;

        // Pool of Channel header buffers. This is serialized by its OWN lock,
        // not by sendinfo.Lock
        //
        ARP_CONST_BUFFER_POOL   ChannelHeaderPool;

    } sendinfo;

    
    //
    // Following 3 are "special" destinations ....
    //

    // Pointer to the broadcast-channel destination object.
    //
    PARPCB_DEST pBroadcastDest;

    // Pointer to the multi-channel destination object.
    //
    PARPCB_DEST pMultiChannelDest;

    // Pointer to the ethernet destination object.
    //
    PARPCB_DEST pEthernetDest;


    // Stuff relating to running the ARP protocol
    // (All serialized by the IF lock (not the IF SEND lock).
    //
    struct
    {
        // The NDIS packet pool for ARP pkts.
        //
        NDIS_HANDLE PacketPool;

        // The NDIS buffer pool for ARP pkts.
        //
        NDIS_HANDLE BufferPool;

        // Number of currently allocated packets.
        //
        LONG NumOutstandingPackets;

        // Maximum size of the packet that can be allocated from this pool.
        //
        UINT MaxBufferSize;

    } arp;

    // Stuff relating to the Ethernet VC, which is owned by the interface.
    //
    struct {

        // The NDIS packet pool for Ethernet pkts.
        //
        NDIS_HANDLE PacketPool;

        // The NDIS buffer pool for Ethernet packet headers.
        //
        NDIS_HANDLE BufferPool;

    #if TEST_ICS_HACK
        PRM_TASK pTestIcsTask;
    #endif // TEST_ICS_HACK;
        
    } ethernet;

    #define ARP_NUM_CHANNELS 64
    struct
    {
        // Information about each channel. Information includes:
        // IP multicast group address and expiry time.
        //
        MCAP_CHANNEL_INFO rgChannelInfo[ARP_NUM_CHANNELS];

    } mcapinfo;

    struct 
    {

        PRM_TASK pAfPendingTask;

    } PoMgmt;

}

ARP1394_INTERFACE, *PARP1394_INTERFACE;

#define ARP_OBJECT_IS_INTERFACE(_pHdr) ((_pHdr)->Sig == MTAG_INTERFACE)
#define ASSERT_VALID_INTERFACE(_pIF) ASSERT((_pIF)->Hdr.Sig == MTAG_INTERFACE)

#define ARP_WRITELOCK_IF_SEND_LOCK(_pIF, _psr) \
                                RmDoWriteLock(&(_pIF)->sendinfo.Lock, (_psr))

#define ARP_READLOCK_IF_SEND_LOCK(_pIF, _psr) \
                                RmDoReadLock(&(_pIF)->sendinfo.Lock, (_psr))

#define ARP_UNLOCK_IF_SEND_LOCK(_pIF, _psr) \
                                RmDoUnlock(&(_pIF)->sendinfo.Lock, (_psr))

#define ARP_FASTREADLOCK_IF_SEND_LOCK(_pIF) \
        NdisAcquireSpinLock(&(_pIF)->sendinfo.Lock.OsLock)

#define ARP_FASTUNLOCK_IF_SEND_LOCK(_pIF) \
        NdisReleaseSpinLock(&(_pIF)->sendinfo.Lock.OsLock)

/*++
VOID
ARP_IF_STAT_INCR(
    IN  ARP1394_INTERFACE   *   _pIF
    IN  OPAQUE              StatsCounter
)
    Increment the specified StatsCounter on an Interface by 1.
--*/
#define ARP_IF_STAT_INCR(_pIF, StatsCounter)    \
            NdisInterlockedIncrement(&(_pIF)->stats.StatsCounter)


/*++
VOID
ARP_IF_STAT_ADD(
    IN  ARP1394_INTERFACE   *   _pIF
    IN  OPAQUE              StatsCounter,
    IN  ULONG               IncrValue
)
    Increment the specified StatsCounter on an Interface by the specified IncrValue.
    Take a lock on the interface to do so.
--*/
#if  BINARY_COMPATIBLE
    #define ARP_IF_STAT_ADD(_pIF, StatsCounter, IncrValue)  \
                ((_pIF)->stats.StatsCounter += (IncrValue))
#else // !BINARY_COMPATIBLE
    #define ARP_IF_STAT_ADD(_pIF, StatsCounter, IncrValue)  \
                InterlockedExchangeAdd(&(_pIF)->stats.StatsCounter, IncrValue)
#endif // !BINARY_COMPATIBLE



//
// This is the table used to store the DHCP entries used in the bridge mode
//

typedef struct _ARP1394_ETH_DHCP_ENTRY
{
    RM_OBJECT_HEADER Hdr;

    //
    // xid - per dhcp session (e.g discover, offer)
    //
    ULONG   xid;

    //
    // HW address in the dhcp packet.
    //
    ENetAddr requestorMAC;   

    //
    // New HW address that arp1394 inserts in the dhcp packet
    //
    ENetAddr newMAC;
  
    
    //
    // Time last checked to be used for aging purposes
    //
    UINT TimeLastChecked;

    //
    // Task used in unloading DhcpEntry
    //
    PRM_TASK pUnloadTask;
    
}ARP1394_ETH_DHCP_ENTRY, *PARP1394_ETH_DHCP_ENTRY;


typedef enum _ARP_RESUME_CAUSE {

    Cause_SetPowerD0,
    Cause_AfNotify,
    Cause_Unbind

} ARP_RESUME_CAUSE;
    


//=========================================================================
//                  N D I S      H A N D L E R S
//=========================================================================

INT
ArpNdBindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 BindContext,
    IN  PNDIS_STRING                pDeviceName,
    IN  PVOID                       SystemSpecific1,
    IN  PVOID                       SystemSpecific2
);

VOID
ArpNdUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 UnbindContext
);


VOID
ArpNdOpenAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status,
    IN  NDIS_STATUS                 OpenErrorStatus
);

VOID
ArpNdCloseAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status
);

VOID
ArpNdResetComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status
);

VOID
ArpNdReceiveComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext
);

VOID
ArpNdRequestComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNDIS_REQUEST               pNdisRequest,
    IN  NDIS_STATUS                 Status
);

VOID
ArpNdStatus(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 GeneralStatus,
    IN  PVOID                       pStatusBuffer,
    IN  UINT                        StatusBufferSize
);

VOID
ArpNdStatusComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext
);

VOID
ArpNdSendComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNDIS_PACKET                pNdisPacket,
    IN  NDIS_STATUS                 Status
);


//
// Following are some connectionless handlers we provide because we're calling
// connectionless entrypoints.
//

NDIS_STATUS
ArpNdReceive (
    NDIS_HANDLE  ProtocolBindingContext,
    NDIS_HANDLE Context,
    VOID *Header,
    UINT HeaderSize,
    VOID *Data,
    UINT Size,
    UINT TotalSize
    );

INT
ArpNdReceivePacket (
        NDIS_HANDLE  ProtocolBindingContext,
        PNDIS_PACKET Packet
        );



NDIS_STATUS
ArpNdPnPEvent(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNET_PNP_EVENT              pNetPnPEvent
);

VOID
ArpNdUnloadProtocol(
    VOID
);


VOID
ArpCoSendComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
);

VOID
ArpCoStatus(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext   OPTIONAL,
    IN  NDIS_STATUS                 GeneralStatus,
    IN  PVOID                       pStatusBuffer,
    IN  UINT                        StatusBufferSize
);


UINT
ArpCoReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
);


VOID
ArpCoAfRegisterNotify(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY          pAddressFamily
);



NDIS_STATUS
ArpCoCreateVc(
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 NdisVcHandle,
    OUT PNDIS_HANDLE                pProtocolVcContext
);

NDIS_STATUS
ArpCoDeleteVc(
    IN  NDIS_HANDLE                 ProtocolVcContext
);

NDIS_STATUS
ArpCoIncomingCall(
    IN      NDIS_HANDLE             ProtocolSapContext,
    IN      NDIS_HANDLE             ProtocolVcContext,
    IN OUT  PCO_CALL_PARAMETERS     pCallParameters
);

VOID
ArpCoCallConnected(
    IN  NDIS_HANDLE                 ProtocolVcContext
);

VOID
ArpCoIncomingClose(
    IN  NDIS_STATUS                 CloseStatus,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PVOID                       pCloseData  OPTIONAL,
    IN  UINT                        Size        OPTIONAL
);


VOID
ArpCoQosChange(
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS         pCallParameters
);


VOID
ArpCoOpenAfComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 NdisAfHandle
);


VOID
ArpCoCloseAfComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolAfContext
);


VOID
ArpCoMakeCallComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  NDIS_HANDLE                 NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS         pCallParameters
);


VOID
ArpCoCloseCallComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  NDIS_HANDLE                 ProtocolPartyContext OPTIONAL
);


VOID
ArpCoModifyQosComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS         pCallParameters
);

NDIS_STATUS
ArpCoRequest(
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 ProtocolVcContext   OPTIONAL,
    IN  NDIS_HANDLE                 ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST            pNdisRequest
);

VOID
ArpCoRequestComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 ProtocolVcContext   OPTIONAL,
    IN  NDIS_HANDLE                 ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST               pNdisRequest
);


//=========================================================================
//                  I P       H A N D L E R S
//=========================================================================

INT
ArpIpDynRegister(
    IN  PNDIS_STRING                pAdapterString,
    IN  PVOID                       IpContext,
    IN  struct _IP_HANDLERS *       pIpHandlers,
    IN  struct LLIPBindInfo *       pBindInfo,
    IN  UINT                        InterfaceNumber
    );

VOID
ArpIpOpen(
    IN  PVOID                       Context
    );

VOID
ArpIpClose(
    IN  PVOID                       Context
    );

UINT
ArpIpAddAddress(
    IN  PVOID                       Context,
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask,
    IN  PVOID                       Context2
    );

UINT
ArpIpDelAddress(
    IN  PVOID                       Context,
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask
    );

NDIS_STATUS
ArpIpMultiTransmit(
    IN  PVOID                       Context,
    IN  PNDIS_PACKET *              pNdisPacketArray,
    IN  UINT                        NumberOfPackets,
    IN  IP_ADDRESS                  Destination,
    IN  RouteCacheEntry *           pRCE        OPTIONAL,
    IN  VOID *                      ArpCtxt
    );

NDIS_STATUS
ArpIpTransmit(
    IN  PVOID                       Context,
    IN  PNDIS_PACKET                pNdisPacket,
    IN  IP_ADDRESS                  Destination,
    IN  RouteCacheEntry *           pRCE        OPTIONAL,
    IN  VOID *                      ArpCtxt
    );

NDIS_STATUS
ArpIpTransfer(
    IN  PVOID                       Context,
    IN  NDIS_HANDLE                 Context1,
    IN  UINT                        ArpHdrOffset,
    IN  UINT                        ProtoOffset,
    IN  UINT                        BytesWanted,
    IN  PNDIS_PACKET                pNdisPacket,
    OUT PUINT                       pTransferCount
    );

VOID
ArpIpInvalidate(
    IN  PVOID                       Context,
    IN  RouteCacheEntry *           pRCE
    );

INT
ArpIpQueryInfo(
    IN      PVOID                   Context,
    IN      TDIObjectID *           pID,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    IN      PVOID                   QueryContext
    );

INT
ArpIpSetInfo(
    IN      PVOID                   Context,
    IN      TDIObjectID *           pID,
    IN      PVOID                   pBuffer,
    IN      UINT                    BufferSize
    );

INT
ArpIpGetEList(
    IN      PVOID                   Context,
    IN      TDIEntityID *           pEntityList,
    IN OUT  PUINT                   pEntityListSize
    );


VOID
ArpIpPnPComplete(
    IN  PVOID                       Context,
    IN  NDIS_STATUS                 Status,
    IN  PNET_PNP_EVENT              pNetPnPEvent
    );


#ifdef PROMIS
EXTERN
NDIS_STATUS
ArpIpSetNdisRequest(
    IN  PVOID                       Context,
    IN  NDIS_OID                    Oid,
    IN  UINT                        On
    );
#endif // PROMIS

// The following structure has the general form of NDIS_CO_MEDIA_PARAMETERS.
// To properly track changes in NDIS_CO_MEDIA_PARAMETERS (however unlikeley!),
// code which uses any field in this structure should assert that the field is at
// the same offset as the corresponding NDIS structure.
// For example:
//  ASSERT(FIELD_OFFSET(ARP1394_CO_MEDIA_PARAMETERS,  Parameters)
//      == FIELD_OFFSET(CO_MEDIA_PARAMETERS,  MediaSpecific.Parameters))
//
//
typedef struct
{
    // First 3 fields of CO_MEDIA_PARAMETERS
    //
    ULONG                       Flags;              // TRANSMIT_VC and/or RECEIVE_VC
    ULONG                       ReceivePriority;    // 0 (unused)
    ULONG                       ReceiveSizeHint;    // 0 (unused)

    // Followed by 1st 2 fields of CO_SPECIFIC_PARAMETERS
    //
    ULONG   POINTER_ALIGNMENT   ParamType; // Set to NIC1394_MEDIA_SPECIFIC
    ULONG                       Length;    // Set to sizeof(NIC1394_MEDIA_PARAMETERS)

    // Followed by the NIC1394-specific media parameters.
    // Note: we can't directly put the NIC1394_MEDIA_PARAMETERS structure here because
    // it (currently) requires 8-byte alignment.
    //
    UCHAR                       Parameters[sizeof(NIC1394_MEDIA_PARAMETERS)];

} ARP1394_CO_MEDIA_PARAMETERS;

typedef enum _TASK_CAUSE {
    SetLowPower = 1,
    SetPowerOn
        
}TASK_CAUSE ;

typedef struct
{
    RM_TASK                     TskHdr;

    // Used to save the true return status (typically a failure status,
    // which we don't want to forget during async cleanup).
    //
    NDIS_STATUS ReturnStatus;

} TASK_ADAPTERINIT, *PTASK_ADAPTERINIT;

typedef struct
{
    RM_TASK                     TskHdr;
    ARP_NDIS_REQUEST            ArpNdisRequest;
    NIC1394_LOCAL_NODE_INFO     LocalNodeInfo;
    // Following is used to switch to PASSIVE before calling IP's add interface
    // Rtn.
    //
    NDIS_WORK_ITEM  WorkItem;

} TASK_ADAPTERACTIVATE, *PTASK_ADAPTERACTIVATE;

typedef struct
{
    RM_TASK TskHdr;
    NDIS_HANDLE pUnbindContext;

} TASK_ADAPTERSHUTDOWN, *PTASK_ADAPTERSHUTDOWN;

// This is the task structure to be used with arpTaskActivateInterface
//
typedef struct
{
    RM_TASK         TskHdr;


#if ARP_DEFERIFINIT
    // Following is used when waiting for the adapter to go to connected status
    //
    //
    NDIS_TIMER              Timer;
#endif // ARP_DEFERIFINIT

    // Following is used to switch to PASSIVE before calling IP's add interface
    // Rtn.
    //
    NDIS_WORK_ITEM  WorkItem;

} TASK_ACTIVATE_IF, *PTASK_ACTIVATE_IF;

// This is the task structure to be used with arpTaskDeactivateInterface
//
typedef struct
{
    RM_TASK         TskHdr;
    BOOLEAN         fPendingOnIpClose;
    TASK_CAUSE      Cause;   

    // Following is used to switch to PASSIVE before calling IP's del interface
    // Rtn.
    //
    NDIS_WORK_ITEM  WorkItem;

} TASK_DEACTIVATE_IF, *PTASK_DEACTIVATE_IF;

// This is the task structure to be used with arpTaskReinitInterface
//
typedef struct
{
    RM_TASK TskHdr;
    NDIS_HANDLE pUnbindContext;

    // Net PnP event to complete when reinit task is done.
    //
    PNET_PNP_EVENT pNetPnPEvent;

} TASK_REINIT_IF, *PTASK_REINIT_IF;

typedef struct
{
    RM_TASK                     TskHdr;

    // Ndis call params and media params for this call.
    //
    CO_CALL_PARAMETERS          CallParams;
    ARP1394_CO_MEDIA_PARAMETERS MediaParams;

} TASK_MAKECALL;


// This is the task structure to be used with arpTaskResolveIpAddress
//
typedef struct
{
    RM_TASK                     TskHdr;

    // Number of retry attempts left before we declare an address resolution failure.
    //
    UINT        RetriesLeft;

    // Used for the response timeout
    //
    NDIS_TIMER              Timer;

} TASK_RESOLVE_IP_ADDRESS, *PTASK_RESOLVE_IP_ADDRESS;


typedef struct
{
    RM_TASK         TskHdr;
    MYBOOL          Quit;   // If set, task will quit.
    NDIS_TIMER      Timer;  // Used for the periodically sending out packets.
    PNDIS_PACKET    p1394Pkt; // Used for testing forward to ethernet
    PNDIS_PACKET    pEthPkt;  // Used for sending connectionless ethernet pkts.
    UINT            Delay;    // Delay (ms) in between sending packets.
    UINT            PktType;  // Type of operation: do nothing, send over ethernet
                              // etc.
} TASK_ICS_TEST, *PTASK_ICS_TEST;


typedef struct
{
    RM_TASK         TskHdr;
    MYBOOL          Quit;   // If set, task will quit.
    NDIS_TIMER      Timer;  // Used for periodically waking up to do stuff.
    UINT            Delay;  // Current value of delay (seconds). Can change.
    UINT            RemoteIpMaintenanceTime; // Absolute time in seconds
    UINT            RemoteEthMaintenanceTime; // Absolute time in seconds
    UINT            LocalIpMaintenanceTime;  // Absolute time in seconds.
    UINT            McapDbMaintenanceTime; // Absolute time in seconds.
    UINT            DhcpTableMaintainanceTime; // Absolute time in seconds
    
} TASK_IF_MAINTENANCE, *PTASK_IF_MAINTENANCE;



typedef struct _TASK_BACKUP
{
    RM_TASK        Hdr;

    //
    // We are using Backup Task flag at position 31 because we do 
    // not want to conflict with the ResumeDelayed flags 
    // 
    #define ARP_BACKUP_TASK_MASK  0x80000000
    #define ARP_BACKUP_TASK_FLAG  0x80000000

    
    #define MARK_TASK_AS_BACKUP(_pT) \
                RM_SET_STATE(_pT, ARP_BACKUP_TASK_MASK  , ARP_BACKUP_TASK_FLAG )
    
    #define CHECK_TASK_IS_BACKUP(_pT) \
                RM_CHECK_STATE(_pT, ARP_BACKUP_TASK_MASK  , ARP_BACKUP_TASK_FLAG )

    #define GET_TASK_BACKUP_STATE(_pT) \
                RM_GET_STATE(_pT, ARP_BACKUP_TASK_MASK  )


    DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) SINGLE_LIST_ENTRY      List;  // Linked list pointing to next task

} TASK_BACKUP, *PTASK_BACKUP;

// This is the task structure to be used with arpTaskResolveIpAddress
//
typedef struct
{
    RM_TASK                     TskHdr;

    NDIS_WORK_ITEM              WorkItem;

} TASK_UNLOAD_REMOTE, *PTASK_UNLOAD_REMOTE;


//
// This task is used during a SetPower. 
// It contains structures that will be track of the 
// the numbero of calls that are closed /opened 
// and the events that need to be waited for.
//

typedef struct _CALL_COUNT
{
   // Count of Destination that will closeVc
    //
    ULONG           DestCount;

   // Event which the Close VC will wait on.
    //
    NDIS_EVENT      VcEvent;

} CALL_COUNT, *PCALL_COUNT;


typedef struct _TASK_POWER {
    RM_TASK         Hdr;

    // Event which the Set Power will wait on.
    //
    NDIS_EVENT      CompleteEvent;

 
    // Status of the Task
    //  
    PNDIS_STATUS    pStatus;

    // Power state we are transitioning to
    //
    NET_DEVICE_POWER_STATE  PowerState;

    //
    //WorkItem to switch to passive

    NDIS_WORK_ITEM          WorkItem;

    //
    // Last working Stage of task - dbg purpose only 
    //
    UINT                    LastStage;

    //
    // Previous state of parent object. This is used so 
    // that the object can be placed back into its previous
    // state.
    //
    UINT PrevState;
} TASK_POWER, *PTASK_POWER;



//
// This structure is used to keep track of a close call
// that originated becuase of a SetPower
//


typedef struct _TASK_SET_POWER_CALL
{

    RM_TASK             Hdr;
    
    TASK_CAUSE    Cause;

    // The Call Call Count is used as place to count the number of outstanding close calls
    // It uses  DestCount as a place to store this information
    //
    PCALL_COUNT         pCount;

}TASK_SET_POWER_CALL, *PTASK_SET_POWER_CALL;


//
// ARP1394_TASK is the union of all tasks structures used in arp1394.
// arpAllocateTask allocates memory of sizeof(ARP1394_TASK), which is guaranteed
// to be large enough to hold any task.
// 
typedef union
{
    RM_TASK                 TskHdr;
    TASK_ADAPTERINIT        AdapterInit;
    TASK_ADAPTERSHUTDOWN    AdapterShutdown;
    TASK_ADAPTERACTIVATE    AdapterActivate;
    TASK_ACTIVATE_IF        ActivateIf;
    TASK_DEACTIVATE_IF      DeactivateIf;
    TASK_REINIT_IF          ReinitIf;
    TASK_MAKECALL           MakeFifoCall;
    TASK_RESOLVE_IP_ADDRESS ResolveIpAddress;
#if TEST_ICS_HACK
    TASK_ICS_TEST           IcsTest;
#endif // TEST_ICS_HACK
    TASK_IF_MAINTENANCE IfMaintenance;
    TASK_BACKUP         Backup;
    TASK_UNLOAD_REMOTE  Unload;
    TASK_SET_POWER_CALL CloseCall;
    TASK_POWER          TaskPower;
}  ARP1394_TASK;

//
//  ---------------------------- DESTINATION (REMOTE) KEY --------------
//
#pragma pack (push, 1)
typedef union _REMOTE_DEST_KEY
{

    ENetAddr ENetAddress;
    IPAddr IpAddress;
    UCHAR  Addr[ARP_802_ADDR_LENGTH];

    struct
    {
        ULONG u32;
        USHORT u16;

    } u;

} REMOTE_DEST_KEY, *PREMOTE_DEST_KEY;

#pragma pack (pop)

#define REMOTE_DEST_IP_ADDRESS_FLAG 0xffff
#define IS_REMOTE_DEST_IP_ADDRESS(_R) ((_R)->u.u16 == REMOTE_DEST_IP_ADDRESS_FLAG )
#define REMOTE_DEST_IP_ADDRESS(_R) ((&(_R)->IpAddress))
#define REMOTE_DEST_ETH_ADDRESS(_R) ((&(_R)->ENetAddress))
#define REMOTE_DEST_KEY_INIT(_R) { (_R)->u.u32 = 0; (_R)->u.u16=REMOTE_DEST_IP_ADDRESS_FLAG ; };
//const REMOTE_DEST_KEY DefaultRemoteDestKey = {0,0,0,0,0xff,0xff};

//
//  ---------------------------- DESTINATION (REMOTE) IP CONTROL BLOCK --------------
//
//  Contains information about one destination (remote) IP address.
//
//  Parent Object: pInterface
//  Lock:          It's own lock.
//
//  There is atmost one ARP Table entry for a given IP address.
//
//  The IP Entry participates in two lists:
//  (1) A list of all entries that hash to the same bucket in the ARP Table
//  (2) A list of all entries that resolve to the same destination H/W Address --
//       this is only if the IP address is unicast.
//
//  A pointer to this structure is also used as our context value in the
//  Route Cache Entry prepared by the higher layer protocol(s).
//
//  Reference Count: We add one to its ref count for each of the following:
//  TBD:
//
typedef struct _ARPCB_REMOTE_IP
{
    RM_OBJECT_HEADER Hdr;       // Common header

    //
    // State flags for RemoteIp (in Hdr.State)
    //
    #define ARPREMOTEIP_RESOLVED_MASK   0x0f
    #define ARPREMOTEIP_UNRESOLVED      0x00
    #define ARPREMOTEIP_RESOLVED        0x01

    #define ARPREMOTEIP_SDTYPE_MASK     0x10  // "SD" == Static/Dynamic
    #define ARPREMOTEIP_STATIC          0x00
    #define ARPREMOTEIP_DYNAMIC         0x10

    #define ARPREMOTEIP_FCTYPE_MASK     0x20    // "FC" == FIFO/Channel
    #define ARPREMOTEIP_FIFO            0x00
    #define ARPREMOTEIP_CHANNEL         0x20

    #define ARPREMOTEIP_MCAP_MASK       0x40    // "FC" == FIFO/Channel
    #define ARPREMOTEIP_MCAP_CAPABLE    0x40

    #define SET_REMOTEIP_RESOLVE_STATE(_pRIp, _IfState) \
                RM_SET_STATE(_pRIp, ARPREMOTEIP_RESOLVED_MASK, _IfState)
    
    #define CHECK_REMOTEIP_RESOLVE_STATE(_pRIp, _IfState) \
                RM_CHECK_STATE(_pRIp, ARPREMOTEIP_RESOLVED_MASK, _IfState)

    #define SET_REMOTEIP_SDTYPE(_pRIp, _IfState) \
                RM_SET_STATE(_pRIp, ARPREMOTEIP_SDTYPE_MASK, _IfState)
    
    #define CHECK_REMOTEIP_SDTYPE(_pRIp, _IfState) \
                RM_CHECK_STATE(_pRIp, ARPREMOTEIP_SDTYPE_MASK, _IfState)

    #define SET_REMOTEIP_FCTYPE(_pRIp, _IfState) \
                RM_SET_STATE(_pRIp, ARPREMOTEIP_FCTYPE_MASK, _IfState)
    
    #define CHECK_REMOTEIP_FCTYPE(_pRIp, _IfState) \
                RM_CHECK_STATE(_pRIp, ARPREMOTEIP_FCTYPE_MASK, _IfState)

    #define SET_REMOTEIP_MCAP(_pRIp, _IfState) \
                RM_SET_STATE(_pRIp, ARPREMOTEIP_MCAP_MASK, _IfState)
    
    #define CHECK_REMOTEIP_MCAP(_pRIp, _IfState) \
                RM_CHECK_STATE(_pRIp, ARPREMOTEIP_MCAP_MASK, _IfState)


    
    
    IP_ADDRESS                      IpAddress;      // IP Address
    LIST_ENTRY                      linkSameDest;   // List of entries pointing to
                                                    // the same destination.
    ARPCB_DEST                      *pDest;         // Pointer to destination CB.

    REMOTE_DEST_KEY                 Key; // Ip address or Mac Address

#if TODO
            // Timers are: (all exclusive)
            // - Aging timer
            // - Waiting for ARP reply
            // - Waiting for InARP reply
            // - Delay after NAK
            // - Waiting for MARS MULTI
            // - Delay before marking for reval
#endif // TODO

    ULONG                           RetriesLeft;

    // The information in this struct is protected by the IF send lock,
    // EXCEPT as noted.
    //
    struct
    {
        // Singly-linked list of Route Cache Entries (no space in RCE to hold
        // a doubly-linked list, unfortunately.)
        //
        RouteCacheEntry *pRceList;

        // listSendPkts is NOT protected by the IF send lock. Instead it is protected
        // by this object(pRemoteIp)'s lock.
        //
        LIST_ENTRY                      listSendPkts;

        //  This entry is NOT protected by any lock. It is set to ZERO
        //  each time a packet is sent to this address and is set to the
        //  current system time periodically by the garbage collecting task.
        //
        UINT                            TimeLastChecked;

    }   sendinfo;

    PRM_TASK                        pSendPktsTask;// Points to the task  (if any)
                                            // Attempting to send queued packets.

    PRM_TASK                        pResolutionTask;// Points to the task  (if any)
                                                    // attempting to resolve
                                                    // this destination IP address.

    PRM_TASK                        pUnloadTask;    // Unload (shutdown) this object.

} ARPCB_REMOTE_IP, *PARPCB_REMOTE_IP;

#define ASSERT_VALID_REMOTE_IP(_pRemoteIp) \
                                 ASSERT((_pRemoteIp)->Hdr.Sig == MTAG_REMOTE_IP)

#define VALID_REMOTE_IP(_pRemoteIp)  ((_pRemoteIp)->Hdr.Sig == MTAG_REMOTE_IP)


//
//  --------------------- DESTINATION (REMOTE) ETHERNET CONTROL BLOCK --------------

// Creation Params -- passed into the function that creates an
// instance of a remote ethernet control block.
//
typedef struct
{
    ENetAddr                EthAddress;
    IP_ADDRESS              IpAddress;

} ARP_REMOTE_ETH_PARAMS, *PARP_REMOTE_ETH_PARAMS;

//
//  Contains information about one destination (remote) Ethernet address.
//
//  Parent Object: pInterface
//  Lock:          pInterface
//
//  There is atmost one Ethernet Table entry for a given Remote ethernet address.
//
//  The Ethernet entry participates in one group:
//   A list of all entries that hash to the same bucket in the Ethernet Table
//
typedef struct _ARPCB_REMOTE_ETH
{
    RM_OBJECT_HEADER Hdr;       // Common header
    IP_ADDRESS       IpAddress; // Remote IP address
    ENetAddr         EthAddress; // Remote Ethernet MAC addres
    PRM_TASK         pUnloadTask;   // Unload (shutdown) this object.

    //  This entry is NOT protected by any lock. It is set to ZERO
    //  each time a packet is sent to this address and is set to the
    //  current system time periodically by the garbage collecting task.
    //
    UINT                            TimeLastChecked;

} ARPCB_REMOTE_ETH, *PARPCB_REMOTE_ETH;

#define ASSERT_VALID_REMOTE_ETH(_pRemoteEth) \
                                 ASSERT((_pRemoteEth)->Hdr.Sig == MTAG_REMOTE_ETH)


//
//  ---------------------------- LOCAL IP CONTROL BLOCK --------------
//
//  Contains information about one local IP address.
//
//  Parent Object: pInterface
//  Lock:          uses parent's (pInterface's) lock.
//
typedef struct _ARPCB_LOCAL_IP
{
    RM_OBJECT_HEADER            Hdr;                // Common header

    //
    // State flags for LocalIp (in Hdr.State)
    //

    #define ARPLOCALIP_MCAP_MASK        0x40
    #define ARPLOCALIP_MCAP_CAPABLE     0x40

    #define SET_LOCALIP_MCAP(_pLIp, _IfState) \
                RM_SET_STATE(_pLIp, ARPLOCALIP_MCAP_MASK, _IfState)
    
    #define CHECK_LOCALIP_MCAP(_pLIp, _IfState) \
                RM_CHECK_STATE(_pLIp, ARPLOCALIP_MCAP_MASK, _IfState)


    UINT                        IpAddressType;      // One of the  LLIP_ADDR_* consts
    IP_ADDRESS                  IpAddress;          // The Address
    IP_MASK                     IpMask;             // Mask for the above.
    UINT                        AddAddressCount;    // No of times address was added
    PRM_TASK                    pRegistrationTask;  // Points to the task (if any)
                                                    // that is doing the unsolicited
                                                    // ARP request to report and
                                                    // validate this IP address is
                                                    // owned by the local interface.
    PRM_TASK                    pUnloadTask;        // Unload (shutdown) this object.

    LIST_ENTRY                      linkSameDest;   // List of entries pointing to
    ARPCB_DEST                      *pDest;         // Pointer to destination CB.

} ARPCB_LOCAL_IP, *PARPCB_LOCAL_IP;

// Returns true IFF pLocalIp is in the process of going away (assumes
// pLocalIp's lock is held) ...
//
#define ARP_LOCAL_IP_IS_UNLOADING(pLocalIp)  (pLocalIp->pUnloadTask != NULL)


typedef struct
{
    NIC1394_DESTINATION     HwAddr;         // Must be 1st for hash function.
    UINT                    ChannelSeqNo;
    BOOLEAN                 ReceiveOnly;
    BOOLEAN                 AcquireChannel;

} ARP_DEST_PARAMS, *PARP_DEST_PARAMS;

//
//  ---------------------------- DESTINATION CONTROL BLOCK --------------
//
//  All information about an remote destination, including list of VCs to it.
//  This is used for both unicast destinations and multicast/broadcast
//  destinations.
//
//  Parent Object: PARCB_INTERFACE (Interface control block).
//  Lock:          uses parent's (Interface).
//
typedef struct _ARPCB_DEST
{
    RM_OBJECT_HEADER                Hdr;                // Common header

    LIST_ENTRY                      listIpToThisDest;   // List of IP entries that
                                                        // point to this entry
    LIST_ENTRY                      listLocalIp;        // List of local IP entries
                                                        // related to this dest. that
                                                        // (Currently only related to
                                                        // MCAP recv channels, but
                                                        // could be extended to
                                                        // using async stream for
                                                        // FIFO as well!).


    ARP_DEST_PARAMS                 Params;             // Dest HW Address, etc.

    ARP_VC_HEADER                   VcHdr;          // Single VC associated
                                                        // with this object.
    PRM_TASK                    pUnloadTask;        // Unload (shutdown) this object.

    // The following structure is protected by the IF send lock.
    // It contains all the information required for the fast send path.
    //
    struct
    {
        PRM_TASK            pSuspendedCleanupCallTask;
        UINT                NumOutstandingSends;
        BOOLEAN             OkToSend;
        BOOLEAN             IsFifo;
    
    } sendinfo;
    #define ARP_DEST_IS_FIFO(_pDest)        ((_pDest)->sendinfo.IsFifo != 0)
    #define ARP_CAN_SEND_ON_DEST(_pDest)    ((_pDest)->sendinfo.OkToSend != 0)

} ARPCB_DEST, *PARPCB_DEST;
#define ARP_OBJECT_IS_DEST(_pHdr) ((_pHdr)->Sig == MTAG_DEST)
#define ASSERT_VALID_DEST(_pDest) \
                                 ASSERTEX((_pDest)->Hdr.Sig == MTAG_DEST, (_pDest))


#if OBSOLETE
//
//  ---------------------------- RECV CHANNEL CONTROL BLOCK --------------
//
//  All information about a receive channel destination.
//
//  Parent Object: PARCB_INTERFACE (Interface control block).
//  Lock:          uses parent's (Interface).
//
typedef struct _ARPCB_RCVCH
{
    RM_OBJECT_HEADER                Hdr;                // Common header

    LIST_ENTRY                      listLIpToThisDest;  // List of Local IP entries
                                                        // that point to this entry

    NIC1394_DESTINATION             HwAddr;             // Destination HW Address.

    ARP_VC_HEADER                   VcHdr;          // Single VC associated
                                                        // with this object.
    PRM_TASK                    pUnloadTask;        // Unload (shutdown) this object.


} ARPCB_DEST, *PARPCB_RCVCH;
#endif // OBSOLETE


// Following sits in the miniport-reserved portion of send-pkts, before they
// are sent out. We have 4 UINT_PTRs of space available to us.
//
typedef struct
{
    LIST_ENTRY linkQueue;

    union
    {
        struct
        {
            IP_ADDRESS  IpAddress;
            ULONG       Flags;
            #define ARPSPI_BACKFILLED       0x1
            #define ARPSPI_HEADBUF          0x2
            #define ARPSPI_FIFOPKT          0x4
            #define ARPSPI_CHANNELPKT       0x8
        } IpXmit;
    };

} ARP_SEND_PKT_MPR_INFO;

//
// Various macros for getting and setting information saved in the
// MiniportReserved portion of packets waiting to be sent...
//

#define ARP_OUR_CTXT_FROM_SEND_PACKET(_pPkt) \
    ((ARP_SEND_PKT_MPR_INFO *) &(_pPkt)->MiniportReserved)

#define ARP_SEND_PKT_FROM_OUR_CTXT(_pCtxt) \
                CONTAINING_RECORD((_pCtxt), NDIS_PACKET, MiniportReserved)

// Our context in the IP RouteCacheEntry.
// (Max 2 UINT_PTRs available)
// Since we also want to keep the destination type (FIFO or CHANNEL) in the RCE,
// we resort to the questionable technique of saving the FIFO/CHANNEL info in
// LSB bit of the UINT_PTR used for storing the pointer to the RemoteIp object.
// We want to keep the FIFO/CHANNEL info in the RCE so that we can prepend
// the correct header block WITHOUT holding the send lock. We want to keep
// the send lock held for as little time as possible.
//
typedef struct
{
    ARPCB_REMOTE_IP *pRemoteIp;     // Ptr to pRemoteIp
    RouteCacheEntry *pNextRce;      // Ptr to next RCE associated with the above
                                    // RemoteIP
} ARP_RCE_CONTEXT;

#define ARP_OUR_CTXT_FROM_RCE(_pRCE) \
                ((ARP_RCE_CONTEXT*)  &(_pRCE)->rce_context)

// Parsed version of the IP/1394 ARP packet.
//
typedef struct
{
    NIC1394_FIFO_ADDRESS    SenderHwAddr;       // requires 8-byte alignment.
    UINT                    OpCode;
    UINT                    SenderMaxRec;
    UINT                    SenderMaxSpeedCode;
    IP_ADDRESS              SenderIpAddress;
    IP_ADDRESS              TargetIpAddress;
    UCHAR                   SourceNodeAdddress;
    UCHAR                   fPktHasNodeAddress;
    ENetAddr                 SourceMacAddress;                    
    
} IP1394_ARP_PKT_INFO, *PIP1394_ARP_PKT_INFO;


// Parsed version of the IP/1394 MCAP Group Descriptor 
//
typedef struct
{
    UINT                    Expiration;
    UINT                    Channel;
    UINT                    SpeedCode;
    IP_ADDRESS              GroupAddress;

}  IP1394_MCAP_GD_INFO, * PIP1394_MCAP_GD_INFO;


// Parsed version of an IP/1394 MCAP packet.
//
typedef struct
{
    UINT                    SenderNodeID;
    UINT                    OpCode;
    UINT                    NumGroups;
    PIP1394_MCAP_GD_INFO    pGdis;

    // Space for storing up-to 4 GD_INFOs
    //
    IP1394_MCAP_GD_INFO     GdiSpace[4];

} IP1394_MCAP_PKT_INFO, *PIP1394_MCAP_PKT_INFO;



typedef struct _EUID_NODE_MAC_TABLE_WORKITEM
{
    // WorkItem used in the request
    NDIS_WORK_ITEM WorkItem;

} EUID_NODE_MAC_TABLE_WORKITEM, *PEUID_NODE_MAC_TABLE_WORKITEM;


typedef struct _ARP1394_WORK_ITEM ARP1394_WORK_ITEM, *PARP1394_WORK_ITEM; 

typedef 
NDIS_STATUS    
(*ARP_WORK_ITEM_PROC)(
    struct _ARP1394_WORK_ITEM*, 
    PRM_OBJECT_HEADER, 
    PRM_STACK_RECORD
    );

typedef struct _ARP1394_WORK_ITEM
{

    union
    {
        EUID_TOPOLOGY Euid;
        NDIS_WORK_ITEM NdisWorkItem;
    }  u;


    ARP_WORK_ITEM_PROC pFunc;

} ARP1394_WORK_ITEM, *PARP1394_WORK_ITEM;


// Structure to express the information carried in an IP header
typedef struct _ARP_IP_HEADER_INFO
{

    UCHAR               protocol;
    IP_ADDRESS          ipSource, ipTarget;
    USHORT              headerSize;
    ULONG               IpHeaderOffset;
    ULONG               IpPktLength;

} ARP_IP_HEADER_INFO, *PARP_IP_HEADER_INFO;


//=========================================================================
//                  I N T E R N A L     P R O T O T Y P E S
//=========================================================================

NTSTATUS
ArpDeviceIoControl(
    IN  PDEVICE_OBJECT              pDeviceObject,
    IN  PIRP                        pIrp
);

NTSTATUS
ArpWmiDispatch(
    IN  PDEVICE_OBJECT              pDeviceObject,
    IN  PIRP                        pIrp
);

NTSTATUS
ArpHandleIoctlRequest(
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
);


NDIS_STATUS
arpCfgGetInterfaceConfiguration(
        IN ARP1394_INTERFACE    *   pIF,
        IN PRM_STACK_RECORD pSR
);

NDIS_STATUS
arpCfgReadAdapterConfiguration(
    IN  ARP1394_ADAPTER *           pAdapter,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpCfgReadInterfaceConfiguration(
    IN  NDIS_HANDLE                 InterfaceConfigHandle,
    IN  ARP1394_INTERFACE *         pF,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpAllocateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription, OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
arpFreeTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskInitInterface(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskDeinitInterface(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskReinitInterface(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskActivateInterface(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskDeactivateInterface(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskMakeRecvFifoCall(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskCleanupRecvFifoCall(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskMakeCallToDest(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskCleanupCallToDest(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskResolveIpAddress(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

PRM_OBJECT_HEADER
arpAdapterCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        );

VOID
arpDeinitIf(
    PARP1394_INTERFACE  pIF,
    PRM_TASK            pCallingTask,   // OPTIONAL
    UINT                SuspendCode,    // OPTIONAL
    PRM_STACK_RECORD    pSR
    );


NDIS_STATUS
arpTaskUnloadLocalIp(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskUnloadRemoteIp(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskUnloadRemoteEth(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskUnloadDestination(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

VOID
arpObjectDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

VOID
arpAdapterDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

NDIS_STATUS
arpCopyUnicodeString(
        OUT         PNDIS_STRING pDest,
        IN          PNDIS_STRING pSrc,
        BOOLEAN     fUpCase
        );

NDIS_STATUS
arpTaskInitializeAdapter(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskShutdownAdapter(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );


NDIS_STATUS
arpTaskActivateAdapter(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskDeactivateAdapter(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );


NDIS_STATUS
arpTaskInterfaceTimer(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskInterfaceTimer(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

#if TEST_ICS_HACK
NDIS_STATUS
arpTaskDoIcsTest(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );
#endif // TEST_ICS_HACK

NDIS_STATUS
arpTaskIfMaintenance(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpInitializeConstBufferPool(
    IN      UINT                    NumBuffersToCache,
    IN      UINT                    MaxBuffers,
    IN      const VOID*             pvMem,
    IN      UINT                    cbMem,
    IN      PRM_OBJECT_HEADER       pOwningObject,
    IN OUT  ARP_CONST_BUFFER_POOL * pHdrPool,
    IN      PRM_STACK_RECORD        pSR
    );

VOID
arpDeinitializeConstBufferPool(
    IN      ARP_CONST_BUFFER_POOL * pHdrPool,
    IN      PRM_STACK_RECORD pSR
    );

PNDIS_BUFFER
arpAllocateConstBuffer(
    ARP_CONST_BUFFER_POOL       *   pHdrPool
    );

VOID
arpDeallocateConstBuffer(
    ARP_CONST_BUFFER_POOL       *   pHdrPool,
    PNDIS_BUFFER                    pNdisBuffer
    );

VOID
arpCompleteSentPkt(
    IN  NDIS_STATUS                 Status,
    IN  ARP1394_INTERFACE   *       pIF,
    IN  ARPCB_DEST          *       pDest,
    IN  PNDIS_PACKET                pNdisPacket
    );

NDIS_STATUS
arpParseArpPkt(
    IN   PIP1394_ARP_PKT      pArpPkt,
    IN   UINT                           cbBufferSize,
    OUT  PIP1394_ARP_PKT_INFO       pPktInfo
    );

VOID
arpPrepareArpPkt(
    IN      PIP1394_ARP_PKT_INFO    pArpPktInfo,
    // IN       UINT                        SenderMaxRec,
    OUT     PIP1394_ARP_PKT   pArpPkt
    );

NDIS_STATUS
arpPrepareArpResponse(
    IN      PARP1394_INTERFACE          pIF,            // NOLOCKIN NOLOCKOUT
    IN      PIP1394_ARP_PKT_INFO    pArpRequest,
    OUT     PIP1394_ARP_PKT_INFO    pArpResponse,
    IN      PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpAddOneStaticArpEntry(
    IN PARP1394_INTERFACE       pIF,    // LOCKIN LOCKOUT
    IN IP_ADDRESS               IpAddress,
    IN PNIC1394_FIFO_ADDRESS    pFifoAddr,
    IN PRM_STACK_RECORD pSR
    );

VOID
arpSetPrimaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpClearPrimaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpSetSecondaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpClearSecondaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpSetPrimaryAdapterTask(
    PARP1394_ADAPTER    pAdapter,           // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpClearPrimaryAdapterTask(
    PARP1394_ADAPTER    pAdapter,           // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpSetSecondaryAdapterTask(
    PARP1394_ADAPTER    pAdapter,           // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpClearSecondaryAdapterTask(
    PARP1394_ADAPTER    pAdapter,           // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    );

NDIS_STATUS
arpTryReconfigureIf(
    PARP1394_INTERFACE pIF,
    PNET_PNP_EVENT pNetPnPEvent,
    PRM_STACK_RECORD pSR
    );

VOID
arpResetIfStats(
        IN  PARP1394_INTERFACE  pIF, // LOCKIN LOCKOUT
        IN  PRM_STACK_RECORD    pSR
        );

VOID
arpGetPktCountBins(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    OUT PULONG              pSizeBin,
    OUT PULONG              pTimeBin
    );

VOID
arpLogSendFifoCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    IN  NDIS_STATUS         Status
    );

VOID
arpLogRecvFifoCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket
    );

VOID
arpLogSendChannelCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    IN  NDIS_STATUS         Status
    );

VOID
arpLogRecvChannelCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket
    );

NDIS_STATUS
arpInitializeVc(
    PARP1394_INTERFACE  pIF,
    PARP_STATIC_VC_INFO pVcInfo,
    PRM_OBJECT_HEADER   pOwner,
    PARP_VC_HEADER      pVcHdr,
    PRM_STACK_RECORD    pSR
    );

VOID
arpDeinitializeVc(
    PARP1394_INTERFACE  pIF,
    PARP_VC_HEADER      pVcHdr,
    PRM_OBJECT_HEADER   pOwner,     // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD    pSR
    );

NDIS_STATUS
arpAllocateControlPacketPool(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    UINT                MaxBufferSize,
    PRM_STACK_RECORD    pSR
    );

VOID
arpFreeControlPacketPool(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    );

NDIS_STATUS
arpAllocateControlPacket(
    IN  PARP1394_INTERFACE  pIF,
    IN  UINT                cbBufferSize,
    IN  UINT                PktFlags,
    OUT PNDIS_PACKET        *ppNdisPacket,
    OUT PVOID               *ppvData,
        PRM_STACK_RECORD    pSR
    );

VOID
arpFreeControlPacket(
    PARP1394_INTERFACE  pIF,
    PNDIS_PACKET        pNdisPacket,
    PRM_STACK_RECORD    pSR
    );

VOID
arpRefSendPkt(
    PNDIS_PACKET    pNdisPacket,
    PARPCB_DEST     pDest
    );

VOID
arpProcessArpPkt(
    PARP1394_INTERFACE  pIF,
    PIP1394_ARP_PKT     pArpPkt,
    UINT                cbBufferSize
    );

VOID
arpProcessMcapPkt(
    PARP1394_INTERFACE  pIF,
    PIP1394_MCAP_PKT    pMcapPkt,
    UINT                cbBufferSize
    );

VOID
arpLinkRemoteIpToDest(
    ARPCB_REMOTE_IP     *pRemoteIp,
    ARPCB_DEST          *pDest,
    PRM_STACK_RECORD    pSR
    );

VOID
arpUnlinkRemoteIpFromDest(
    ARPCB_REMOTE_IP     *pRemoteIp, // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    );

VOID
arpUnlinkAllRemoteIpsFromDest(
    ARPCB_DEST  *pDest, // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    );

VOID
arpLinkLocalIpToDest(
    ARPCB_LOCAL_IP  *   pLocalIp,
    ARPCB_DEST          *pDest,
    PRM_STACK_RECORD    pSR
    );

VOID
arpUnlinkLocalIpFromDest(
    ARPCB_LOCAL_IP  *pLocalIp,  // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    );

VOID
arpUnlinkAllLocalIpsFromDest(
    ARPCB_DEST  *pDest, // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    );

#if 0

NDIS_STATUS
arpCopyAnsiStringToUnicodeString(
        OUT         PNDIS_STRING pDest,
        IN          PANSI_STRING pSrc
        );

NDIS_STATUS
arpCopyUnicodeStringToAnsiString(
        OUT         PANSI_STRING pDest,
        IN          PNDIS_STRING pSrc
        );
#endif // 0


VOID
arpUpdateReceiveMultichannels(
        PARP1394_INTERFACE  pIF,
        UINT                SecondsSinceLastCall,
        PRM_STACK_RECORD    pSR
        );

NDIS_STATUS
arpPrepareAndSendNdisRequest(
    IN  PARP1394_ADAPTER            pAdapter,
    IN  PARP_NDIS_REQUEST           pArpNdisRequest,
    IN  PRM_TASK                    pTask,              // OPTIONAL
    IN  UINT                        PendCode,
    IN  NDIS_OID                    Oid,
    IN  PVOID                       pBuffer,
    IN  ULONG                       BufferLength,
    IN  NDIS_REQUEST_TYPE           RequestType,
    IN  PRM_STACK_RECORD            pSR
    );
        

typedef enum
{
    ARP_ICS_FORWARD_TO_1394,
    ARP_ICS_FORWARD_TO_ETHERNET,

} ARP_ICS_FORWARD_DIRECTION;


#if TEST_ICS_HACK

VOID
arpEthSendComplete(
    IN  ARP1394_ADAPTER *   pAdapter,
    IN  PNDIS_PACKET        pNdisPacket,
    IN  NDIS_STATUS         Status
);

NDIS_STATUS
arpEthReceive(
    ARP1394_ADAPTER *   pAdapter,
    NDIS_HANDLE Context,
    VOID *Header,
    UINT HeaderSize,
    VOID *Data,
    UINT Size,
    UINT TotalSize
    );
#endif // TEST_ICS_HACK


VOID
arpEthReceivePacket(
    ARP1394_INTERFACE   *   pIF,
    PNDIS_PACKET Packet
    );


NDIS_STATUS
arpAllocateEthernetPools(
    IN  PARP1394_INTERFACE  pIF,
    IN  PRM_STACK_RECORD    pSR
    );

VOID
arpFreeEthernetPools(
    IN  PARP1394_INTERFACE  pIF,
    IN  PRM_STACK_RECORD    pSR
    );

#if TEST_ICS_HACK
VOID
arpDbgStartIcsTest(
    IN  PARP1394_INTERFACE          pIF,  // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD                pSR
    );

VOID
arpDbgTryStopIcsTest(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD                pSR
    );

#endif // TEST_ICS_HACK

VOID
arpDbgIncrementReentrancy(
    PLONG pReentrancyCount
    );

VOID
arpDbgDecrementReentrancy(
    PLONG pReentrancyCount
    );

VOID
arpHandleControlPktSendCompletion(
    IN  ARP1394_INTERFACE   *   pIF,
    IN  PNDIS_PACKET            pNdisPacket
    );

VOID
arpStartIfMaintenanceTask(
    IN  PARP1394_INTERFACE          pIF,  // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD                pSR
    );

NDIS_STATUS
arpTryStopIfMaintenanceTask(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  PRM_TASK                    pTask, // task to pend until M task completes
    IN  UINT                        PendCode, // Pend code to suspend task.
    PRM_STACK_RECORD                pSR
    );

UINT
arpGetSystemTime(VOID);


BOOLEAN
arpCanTryMcap(
    IP_ADDRESS  IpAddress
    );

UINT
arpFindAssignedChannel(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  IP_ADDRESS                  IpAddress,
    IN  UINT                        CurrentTime,
    PRM_STACK_RECORD                pSR
    );

VOID
arpUpdateRemoteIpDest(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  PARPCB_REMOTE_IP            pRemoteIp,
    IN  PARP_DEST_PARAMS            pDestParams,
    PRM_STACK_RECORD                pSR
    );

MYBOOL
arpIsActiveMcapChannel(
        PMCAP_CHANNEL_INFO pMci,
        UINT CurrentTime
        );

VOID
arpSendControlPkt(
    IN  ARP1394_INTERFACE       *   pIF,            // LOCKIN NOLOCKOUT (IF send lk)
    IN  PNDIS_PACKET                pNdisPacket,
    IN  PARPCB_DEST                 pDest,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpCreateMcapPkt(
    IN  PARP1394_INTERFACE          pIF,
    IN  PIP1394_MCAP_PKT_INFO       pPktInfo,
    OUT PNDIS_PACKET               *ppNdisPacket,
    PRM_STACK_RECORD                pSR
    );

UINT
arpProcessReceivedPacket(
    IN  PARP1394_INTERFACE      pIF,
    IN  PNDIS_PACKET            pNdisPacket,
    IN  MYBOOL                  IsChannel
);

VOID
arpUpdateArpCache(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    IP_ADDRESS                  RemoteIpAddress,
    ENetAddr                    *pRemoteEthAddress,
    PARP_DEST_PARAMS            pDestParams,
    MYBOOL                      fCreateIfRequired,
    PRM_STACK_RECORD            pSR
    );

UINT
arpEthernetReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
);

VOID
arpEthReceive1394Packet(
    IN  PARP1394_INTERFACE      pIF,
    IN  PNDIS_PACKET            pNdisPacket,
    IN  PVOID                   pvHeader,
    IN  UINT                    HeaderSize,
    IN  MYBOOL                  IsChannel
    );

NDIS_STATUS
arpSlowIpTransmit(
    IN  ARP1394_INTERFACE       *   pIF,
    IN  PNDIS_PACKET                pNdisPacket,
    IN  REMOTE_DEST_KEY            Destination,
    IN  RouteCacheEntry *           pRCE        OPTIONAL
    );

VOID
arpDelRceList(
    IN  PARPCB_REMOTE_IP  pRemoteIp,    // IF send lock WRITELOCKIN WRITELOCKOUTD
    IN  PRM_STACK_RECORD pSR
    );

VOID    
arpGenericWorkItem(
    struct _NDIS_WORK_ITEM * pWorkItem, 
    PVOID pContext
    );

VOID
arpQueueWorkItem (
    PARP1394_WORK_ITEM pWorkItem,
    ARP_WORK_ITEM_PROC pFunc,
    PRM_OBJECT_HEADER pHdr,
    PRM_STACK_RECORD pSR
    );

NDIS_STATUS
arpGetEuidTopology (
    IN PARP1394_ADAPTER pAdapter,
    PRM_STACK_RECORD pSR
    );

VOID
arpNdProcessBusReset(
    IN PARP1394_ADAPTER pAdapter
    );

NDIS_STATUS 
arpAddIpAddressToRemoteIp (
    PARPCB_REMOTE_IP pRemoteIp,  
    PNDIS_PACKET pNdisPacket
    );


VOID
arpReturnBackupTask (
    IN ARP1394_TASK* pTask
    );


VOID
arpAllocateBackupTasks (
    ARP1394_GLOBALS*                pGlobals 
    );



VOID
arpFreeBackupTasks (
    ARP1394_GLOBALS*                pGlobals 
    );



ARP1394_TASK *
arpGetBackupTask (
    IN ARP1394_GLOBALS*  pGlobals
    );


NTSTATUS
arpDelArpEntry(
        PARP1394_INTERFACE           pIF,
        IPAddr                       IpAddress,
        PRM_STACK_RECORD            pSR
        );

VOID
arpAddBackupTasks (
    IN ARP1394_GLOBALS* pGlobals,
    UINT Num
    );

VOID
arpRemoveBackupTasks (
    IN ARP1394_GLOBALS* pGlobals,
    UINT Num
     );

MYBOOL
arpNeedToCleanupDestVc(
        ARPCB_DEST *pDest   // LOCKING LOCKOUT
        );

VOID
arpLowPowerCloseAllCalls (
    ARP1394_INTERFACE *pIF,
    PRM_STACK_RECORD pSR
    );
    
VOID
arpDeactivateIf(
    PARP1394_INTERFACE  pIF,
    PRM_TASK            pCallingTask,   // OPTIONAL
    UINT                SuspendCode,    // OPTIONAL
    PRM_STACK_RECORD    pSR
    );

NDIS_STATUS
arpTaskLowPower(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpSetupSpecialDest(
    IN  PARP1394_INTERFACE      pIF,
    IN  NIC1394_ADDRESS_TYPE    AddressType,
    IN  PRM_TASK                pParentTask,
    IN  UINT                    PendCode,
    OUT PARPCB_DEST         *   ppSpecialDest,
    IN  PRM_STACK_RECORD        pSR
    );

NDIS_STATUS
arpResume (
    IN ARP1394_ADAPTER* pAdapter,
    IN ARP_RESUME_CAUSE Cause,
    IN PRM_STACK_RECORD pSR
    );   


NDIS_STATUS
arpTaskOnPower (
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpMakeCallOnDest(
    IN  PARPCB_REMOTE_IP            pRemoteIp,  
    IN  PARPCB_DEST                 pDest,
    IN  PRM_TASK                    pTaskToPend,
    IN  ULONG                       PEND_StageMakeCallComplete,
    IN  PRM_STACK_RECORD            pSR
    );


//=========================================================================
//                  G L O B A L    D A T A
//=========================================================================

extern
RM_STATIC_OBJECT_INFO
ArpGlobals_AdapterStaticInfo;

extern const
NIC1394_ENCAPSULATION_HEADER
Arp1394_IpEncapHeader;


// Warning -- FAIL(NDIS_STATUS_PENDING) == TRUE
//
#define FAIL(_Status) ((_Status) != NDIS_STATUS_SUCCESS)
#define PEND(_Status) ((_Status) == NDIS_STATUS_PENDING)

#if RM_EXTRA_CHECKING
#define LOCKHDR(_pHdr, _psr) \
            RmWriteLockObject((_pHdr), dbg_func_locid, (_psr))
#else // !RM_EXTRA_CHECKING
#define LOCKHDR(_pHdr, _psr) \
            RmWriteLockObject((_pHdr), (_psr))
#endif // !RM_EXTRA_CHECKING

#define LOCKOBJ(_pObj, _psr) \
            LOCKHDR(&(_pObj)->Hdr, (_psr))

#define UNLOCKHDR(_pHdr, _psr) \
            RmUnlockObject((_pHdr), (_psr))
#define UNLOCKOBJ(_pObj, _psr) \
            UNLOCKHDR(&(_pObj)->Hdr, (_psr))


#define ARP_ALLOCSTRUCT(_p, _tag) \
                NdisAllocateMemoryWithTag(&(_p), sizeof(*(_p)), (_tag))

#define ARP_FREE(_p)            NdisFreeMemory((_p), 0, 0)

#define ARP_ZEROSTRUCT(_p) \
                NdisZeroMemory((_p), sizeof(*(_p)))

#define ARRAY_LENGTH(_array) (sizeof(_array)/sizeof((_array)[0]))

#if RM_EXTRA_CHECKING
#define DBG_ADDASSOC(_phdr, _e1, _e2, _assoc, _fmt, _psr)\
                                    RmDbgAddAssociation(    \
                                        dbg_func_locid,     \
                                        (_phdr),            \
                                        (UINT_PTR) (_e1),   \
                                        (UINT_PTR) (_e2),   \
                                        (_assoc),           \
                                        (_fmt),             \
                                        (_psr)              \
                                        )

#define DBG_DELASSOC(_phdr, _e1, _e2, _assoc, _psr)         \
                                    RmDbgDeleteAssociation( \
                                        dbg_func_locid,     \
                                        (_phdr),            \
                                        (UINT_PTR) (_e1),   \
                                        (UINT_PTR) (_e2),   \
                                        (_assoc),           \
                                        (_psr)              \
                                        )

// (debug only) Enumeration of types of associations.
//
enum
{
    ARPASSOC_IP_OPEN,           // IP has called ArpIpOpen
    ARPASSOC_LINK_IPADDR_OF_DEST,       
    ARPASSOC_LINK_DEST_OF_IPADDR,
    ARPASSOC_LOCALIP_UNLOAD_TASK,
    ARPASSOC_REMOTEIP_UNLOAD_TASK,
    ARPASSOC_REMOTEETH_UNLOAD_TASK,
    ARPASSOC_DEST_UNLOAD_TASK,
    ARPASSOC_CBUFPOOL_ALLOC,
    ARPASSOC_EXTLINK_DEST_TO_PKT,
    ARPASSOC_EXTLINK_RIP_TO_RCE,
    ARPASSOC_EXTLINK_TO_NDISVCHANDLE,
    ARPASSOC_REMOTEIP_SENDPKTS_TASK,
    ARPASSOC_IF_MAKECALL_TASK,
    ARPASSOC_IF_CLEANUPCALL_TASK,
    ARPASSOC_DEST_MAKECALL_TASK,
    ARPASSOC_DEST_CLEANUPCALL_TASK,
    ARPASSOC_DEST_CLEANUPCALLTASK_WAITING_ON_SENDS,
    ARPASSOC_PKTS_QUEUED_ON_REMOTEIP,
    ARPASSOC_PRIMARY_IF_TASK,
    ARPASSOC_ACTDEACT_IF_TASK,
    ARPASSOC_IF_OPENAF,
    ARPASSOC_PRIMARY_AD_TASK,
    ARPASSOC_ACTDEACT_AD_TASK,
    ARPASSOC_LINK_IF_OF_BCDEST,
    ARPASSOC_LINK_BCDEST_OF_IF,
    ARPASSOC_IF_PROTOPKTPOOL,
    ARPASSOC_IF_PROTOBUFPOOL,
    ARPASSOC_RESOLUTION_IF_TASK,
    ARPASSOC_LINK_IF_OF_MCDEST,
    ARPASSOC_LINK_MCDEST_OF_IF,
    ARPASSOC_LINK_IF_OF_ETHDEST,
    ARPASSOC_LINK_ETHDEST_OF_IF,
    ARPASSOC_IF_ETHPKTPOOL,
    ARPASSOC_IF_ETHBUFPOOL,
    ARPASSOC_ETH_SEND_PACKET,
    ARPASSOC_IF_MAINTENANCE_TASK,
    ARPASSOC_WORK_ITEM,
    ARPASSOC_ETHDHCP_UNLOAD_TASK,
    ARPASSOC_REMOTEIP_RESOLVE_TASK,
    ARPASSOC_TASK_TO_RESOLVE_REMOTEIP

};

#else // !RM_EXTRA_CHECKING
#define DBG_ADDASSOC(_phdr, _e1, _e2, _assoc, _fmt, _psr) (0)
#define DBG_DELASSOC(_phdr, _e1, _e2, _assoc, _psr) (0)
#endif  // !RM_EXTRA_CHECKING

#define ARPDBG_REF_EVERY_PACKET 1
#define ARPDBG_REF_EVERY_RCE    1


// USHORT
// SWAPBYTES_USHORT(USHORT  Val )
//
#define SWAPBYTES_USHORT(Val)   \
                ((((Val) & 0xff) << 8) | (((Val) & 0xff00) >> 8))


// ULONG
// SWAPBYTES_ULONG(ULONG    Val )
//
#define SWAPBYTES_ULONG(Val)    \
                ((((Val) & 0x000000ff) << 24)   |   \
                 (((Val) & 0x0000ff00) << 8)    |   \
                 (((Val) & 0x00ff0000) >> 8)    |   \
                 (((Val) & 0xff000000) >> 24) )


#define N2H_USHORT(Val) SWAPBYTES_USHORT(Val)
#define H2N_USHORT(Val) SWAPBYTES_USHORT(Val)
#define N2H_ULONG(Val)  SWAPBYTES_ULONG(Val)
#define H2N_ULONG(Val)  SWAPBYTES_ULONG(Val)

#define ARP_ATPASSIVE()  (KeGetCurrentIrql()==PASSIVE_LEVEL)

#define LOGSTATS_NoCopyRecvs(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.recvpkts.NoCopyRecvs))
#define LOGSTATS_CopyRecvs(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.recvpkts.CopyRecvs))
#define LOGSTATS_ResourceRecvs(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.recvpkts.ResourceRecvs))
#define LOGSTATS_TotRecvs(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.recvpkts.TotRecvs))
#define LOGSTATS_RecvFifoCounts(_pIF, _pNdisPacket) \
            arpLogRecvFifoCounts(_pIF, _pNdisPacket)
#define LOGSTATS_RecvChannelCounts(_pIF, _pNdisPacket) \
            arpLogRecvChannelCounts(_pIF, _pNdisPacket)
#define LOGSTATS_TotalSendFifoMakeCalls(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.TotalSendFifoMakeCalls))
#define LOGSTATS_SuccessfulSendFifoMakeCalls(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.SuccessfulSendFifoMakeCalls))
#define LOGSTATS_FailedSendFifoMakeCalls(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.FailedSendFifoMakeCalls))
#define LOGSTATS_IncomingClosesOnSendFifos(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.IncomingClosesOnSendFifos))
#define LOGSTATS_TotalChannelMakeCalls(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.TotalChannelMakeCalls))
#define LOGSTATS_SuccessfulChannelMakeCalls(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.SuccessfulChannelMakeCalls))
#define LOGSTATS_FailedChannelMakeCalls(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.FailedChannelMakeCalls))
#define LOGSTATS_IncomingClosesOnChannels(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.IncomingClosesOnChannels))

#define IF_FROM_LOCALIP(_pLIp) \
    (PARP1394_INTERFACE) RM_PARENT_OBJECT(_pLIp)

#define IF_FROM_REMOTEIP(_pRIp) \
    (PARP1394_INTERFACE) RM_PARENT_OBJECT(_pRIp)

#define IF_FROM_DEST(_pDest) \
    (PARP1394_INTERFACE) RM_PARENT_OBJECT(_pDest)

#if RM_EXTRA_CHECKING


#define OBJLOG0(_pObj, _szFmt)                          \
                        RmDbgLogToObject(               \
                                &(_pObj)->Hdr,          \
                                NULL, (_szFmt),         \
                                0, 0, 0, 0, NULL, NULL  \
                                )

#define OBJLOG1(_pObj, _szFmt, _P1)                     \
                        RmDbgLogToObject(               \
                                &(_pObj)->Hdr,          \
                                NULL, (_szFmt),         \
                                (UINT_PTR) (_P1),       \
                                0, 0, 0, NULL, NULL     \
                                )

#define OBJLOG2(_pObj, _szFmt, _P1, _P2)                \
                        RmDbgLogToObject(               \
                                &(_pObj)->Hdr,          \
                                NULL, (_szFmt),         \
                                (UINT_PTR) (_P1),       \
                                (UINT_PTR) (_P2),       \
                                0, 0, NULL, NULL        \
                                )
    
#else // !RM_EXTRA_CHECKING

#define OBJLOG0(_pObj, _szFmt)                  (0)
#define OBJLOG1(_pObj, _szFmt, _P1)             (0)
#define OBJLOG2(_pObj, _szFmt, _P1, _P2)        (0)

#endif // !RM_EXTRA_CHECKING


#if ARP_DO_TIMESTAMPS
    void
    arpTimeStamp(
        char *szFormatString,
        UINT Val
        );
    #define  TIMESTAMPX(_FormatString) \
        arpTimeStamp("TIMESTAMP %lu:%lu.%lu ARP1394 " _FormatString "\n", 0)
    #if ARP_DO_ALL_TIMESTAMPS
        #define  TIMESTAMP(_FormatString) \
            arpTimeStamp("TIMESTAMP %lu:%lu.%lu ARP1394 " _FormatString "\n", 0)
        #define  TIMESTAMP1(_FormatString, _Val) \
            arpTimeStamp("TIMESTAMP %lu:%lu.%lu ARP1394 " _FormatString "\n", (_Val))
    #else
        #define  TIMESTAMP(_FormatString)
        #define  TIMESTAMP1(_FormatString, _Val)
    #endif
#else // !ARP_DO_TIMESTAMPS
    #define  TIMESTAMP(_FormatString)
    #define  TIMESTAMPX(_FormatString)
    #define  TIMESTAMP1(_FormatString, _Val)
#endif // !ARP_DO_TIMESTAMPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\wmi.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    WMI entry points for ARP1394.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     11-23-98    Created

Notes:

--*/
#include <precomp.h>


//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_WMI


NTSTATUS
ArpWmiDispatch(
    IN  PDEVICE_OBJECT              pDeviceObject,
    IN  PIRP                        pIrp
)
/*++

Routine Description:

    System dispatch function for handling IRP_MJ_SYSTEM_CONTROL IRPs from WMI.

Arguments:

    pDeviceObject   - Pointer to device object. The device extension field
                      contains a pointer to the Interface 

    pIrp            - Pointer to IRP.

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION      pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    PVOID                   DataPath = pIrpSp->Parameters.WMI.DataPath;
    ULONG                   BufferSize = pIrpSp->Parameters.WMI.BufferSize;
    PVOID                   pBuffer = pIrpSp->Parameters.WMI.Buffer;
    NTSTATUS                Status =  STATUS_UNSUCCESSFUL;
    ULONG                   ReturnSize;
    ENTER("WmiDispatch", 0x9141e00e)

#if 0
    PATMARP_INTERFACE       pInterface;

    pInterface = AA_PDO_TO_INTERFACE(pDeviceObject);

    AA_STRUCT_ASSERT(pInterface, aai);

    ReturnSize = 0;

    switch (pIrpSp->MinorFunction)
    {
        case IRP_MN_REGINFO:

            Status = AtmArpWmiRegister(
                        pInterface,
                        PtrToUlong(DataPath),
                        pBuffer,
                        BufferSize,
                        &ReturnSize
                        );
            break;
        
        case IRP_MN_QUERY_ALL_DATA:

            Status = AtmArpWmiQueryAllData(
                        pInterface,
                        (LPGUID)DataPath,
                        (PWNODE_ALL_DATA)pBuffer,
                        BufferSize,
                        &ReturnSize
                        );
            break;
        
        case IRP_MN_QUERY_SINGLE_INSTANCE:

            Status = AtmArpWmiQuerySingleInstance(
                        pInterface,
                        pBuffer,
                        BufferSize,
                        &ReturnSize
                        );
            
            break;

        case IRP_MN_CHANGE_SINGLE_INSTANCE:

            Status = AtmArpWmiChangeSingleInstance(
                        pInterface,
                        pBuffer,
                        BufferSize,
                        &ReturnSize
                        );
            break;

        case IRP_MN_CHANGE_SINGLE_ITEM:

            Status = AtmArpWmiChangeSingleItem(
                        pInterface,
                        pBuffer,
                        BufferSize,
                        &ReturnSize
                        );
            break;

        case IRP_MN_ENABLE_EVENTS:

            Status = AtmArpWmiSetEventStatus(
                        pInterface,
                        (LPGUID)DataPath,
                        TRUE                // Enable
                        );
            break;

        case IRP_MN_DISABLE_EVENTS:

            Status = AtmArpWmiSetEventStatus(
                        pInterface,
                        (LPGUID)DataPath,
                        FALSE               // Disable
                        );
            break;

        case IRP_MN_ENABLE_COLLECTION:
        case IRP_MN_DISABLE_COLLECTION:
        default:
        
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = (NT_SUCCESS(Status) ? ReturnSize: 0);

    AADEBUGP(AAD_INFO,
        ("WmiDispatch done: IF x%p, MinorFn %d, Status x%p, ReturnInfo %d\n",
                pInterface, pIrpSp->MinorFunction, Status, pIrp->IoStatus.Information));

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

#endif // 0

    EXIT()
    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\enum\sys\enum1394.c ===
/*++


Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    enum1394.c
    
Abstract:

    1394 ndis enumerator
    
    Author: Alireza Dabagh (alid)


Environment:

    Kernel mode

Revision History :

--*/

#include <wdm.h>
//
// extra stuff to keep ks.h happy
//
#ifndef CDECL
#define CDECL
#endif
#ifndef BOOL
#define BOOL    int
#endif

#define ENUM1394_NT 1

#include "1394.h"
#include "ndis1394.h"
#include "enum1394.h"
#include "ntdd1394.h"

#define NDISENUM1394_DEVICE_NAME    L"\\Device\\NdisEnum1394"
#define NDISENUM1394_SYMBOLIC_NAME  L"\\DosDevices\\NDISENUM1394"


NDISENUM1394_CHARACTERISTICS NdisEnum1394Characteristics =
{
    1,
    0,
    0,
    NdisEnum1394RegisterDriver,
    NdisEnum1394DeregisterDriver,
    NdisEnum1394RegisterAdapter,
    NdisEnum1394DeregisterAdapter
};



KSPIN_LOCK                      ndisEnum1394GlobalLock;
ULONG                           Enum1394DebugLevel = ENUM1394_DBGLEVEL_ERROR   ;
PNDISENUM1394_LOCAL_HOST        LocalHostList = (PNDISENUM1394_LOCAL_HOST)NULL;

NIC1394_ADD_NODE_HANLDER            AddNodeHandler = NULL;
NIC1394_REMOVE_NODE_HANLDER         RemoveNodeHandler = NULL;
NIC1394_REGISTER_DRIVER_HANDLER     RegisterDriverHandler = NULL;
NIC1394_DEREGISTER_DRIVER_HANDLER   DeRegisterDriverHandler = NULL;


PDEVICE_OBJECT                  ndisEnum1394DeviceObject = NULL;
PDRIVER_OBJECT                  ndisEnum1394DriverObject = NULL;
PCALLBACK_OBJECT                ndisEnum1394CallbackObject = NULL;
PVOID                           ndisEnum1394CallbackRegisterationHandle = NULL;

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called at system initialization time so we can fill in the basic dispatch points

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS

--*/

{
    OBJECT_ATTRIBUTES   ObjectAttr;
    UNICODE_STRING      CallBackObjectName;
    NTSTATUS            Status;
    UNICODE_STRING      DeviceName;
    UNICODE_STRING      SymbolicLinkName;
    BOOLEAN             fDerefCallbackObject = FALSE;
    BOOLEAN             fDeregisterCallback = FALSE;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO,("Enum1394 DriverEntry.\n"));
    
    do
    {
        KeInitializeSpinLock(&ndisEnum1394GlobalLock);

        RtlInitUnicodeString(&DeviceName, NDISENUM1394_DEVICE_NAME);


        ndisEnum1394DriverObject = DriverObject;

        RtlInitUnicodeString(&CallBackObjectName, NDIS1394_CALLBACK_NAME);

        InitializeObjectAttributes(&ObjectAttr,
                                   &CallBackObjectName,
                                   OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                                   NULL,
                                   NULL);
                                   
        Status = ExCreateCallback(&ndisEnum1394CallbackObject,
                                  &ObjectAttr,
                                  TRUE,
                                  TRUE);

        
        if (!NT_SUCCESS(Status))
        {

            DBGPRINT(ENUM1394_DBGLEVEL_ERROR,("Enum1394 DriverEntry: failed to create a Callback object. Status %lx\n", Status));
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        fDerefCallbackObject = TRUE;
        
        ndisEnum1394CallbackRegisterationHandle = ExRegisterCallback(ndisEnum1394CallbackObject,
                                                                 Enum1394Callback,
                                                                 (PVOID)NULL);
        if (ndisEnum1394CallbackRegisterationHandle == NULL)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR,("Enum1394 DriverEntry: failed to register a Callback routine%lx\n"));
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        fDeregisterCallback = TRUE;

        ExNotifyCallback(ndisEnum1394CallbackObject,
                        (PVOID)NDIS1394_CALLBACK_SOURCE_ENUM1394,
                        (PVOID)&NdisEnum1394Characteristics);
        
        

        //
        // Initialize the Driver Object with driver's entry points
        //
        DriverObject->DriverExtension->AddDevice = ndisEnum1394AddDevice;
        
        //
        // Fill in the Mandatory handlers 
        //
        DriverObject->DriverUnload = ndisEnum1394Unload;

        DriverObject->MajorFunction[IRP_MJ_CREATE] = ndisEnum1394CreateIrpHandler;
        DriverObject->MajorFunction[IRP_MJ_CLOSE] = ndisEnum1394CloseIrpHandler;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ndisEnum1394DeviceIoControl;
        DriverObject->MajorFunction[IRP_MJ_PNP] = ndisEnum1394PnpDispatch;
        DriverObject->MajorFunction[IRP_MJ_POWER] = ndisEnum1394PowerDispatch;
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = ndisEnum1394WMIDispatch;
        
        fDerefCallbackObject =  fDeregisterCallback = FALSE;

        Status = STATUS_SUCCESS;
        
    } while(FALSE);

    if (fDeregisterCallback)
    {
        ExUnregisterCallback(ndisEnum1394CallbackRegisterationHandle);
    }

    if (fDerefCallbackObject)
    {
        ObDereferenceObject(ndisEnum1394CallbackObject);
    }


    if (Status != STATUS_SUCCESS)
    {
        if (DeRegisterDriverHandler != NULL)
            DeRegisterDriverHandler();
    }
    
    return Status;

}


NTSTATUS
ndisEnum1394AddDevice(
    PDRIVER_OBJECT  DriverObject,
    PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    This is our PNP AddDevice called with the PDO ejected from the bus driver

Arguments:


Return Value:

    

--*/

{
    NTSTATUS                    Status;
    PNDISENUM1394_REMOTE_NODE   RemoteNode;
    PDEVICE_OBJECT              DeviceObject, NextDeviceObject;
    KIRQL                       OldIrql;
    PNDISENUM1394_LOCAL_HOST    LocalHost;
    BOOLEAN                     FreeDevice = FALSE;
    BOOLEAN                     fNewHost = FALSE;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394AddDevice: PDO %lx\n", PhysicalDeviceObject));
    

    do
    {
    
        //
        // first create a FDO
        //

        Status = IoCreateDevice(
                        DriverObject,
                        sizeof (NDISENUM1394_REMOTE_NODE),  // extension size
                        NULL,                               // name (null for now)
                        FILE_DEVICE_NETWORK,                // device type
                        0,                                  // characteristics
                        FALSE,
                        &DeviceObject);


        if (!NT_SUCCESS(Status))
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394AddDevice: failed to create FDO. Status %lx, PDO %lx\n", Status, PhysicalDeviceObject));
            break;
        }

        FreeDevice = TRUE;

        DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        PhysicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        //
        //  Mark the device as being pageable.
        //
        DeviceObject->Flags |= DO_POWER_PAGABLE;

        //
        //  Attach our FDO to the PDO. This routine will return the top most
        //  device that is attached to the PDO or the PDO itself if no other
        //  device objects have attached to it.
        //
        NextDeviceObject = IoAttachDeviceToDeviceStack(DeviceObject, PhysicalDeviceObject);
        RtlZeroMemory(DeviceObject->DeviceExtension, sizeof (NDISENUM1394_REMOTE_NODE));

        RemoteNode = (PNDISENUM1394_REMOTE_NODE)DeviceObject->DeviceExtension;
        RemoteNode->DeviceObject = DeviceObject;
        RemoteNode->PhysicalDeviceObject = PhysicalDeviceObject;
        RemoteNode->NextDeviceObject = NextDeviceObject;
        RemoteNode->PnPDeviceState = PnPDeviceAdded;
        KeInitializeSpinLock(&RemoteNode->Lock);
        ndisEnum1394InitializeRef(&RemoteNode->Reference);

        Status = ndisEnum1394GetLocalHostForRemoteNode(RemoteNode, &LocalHost);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394AddDevice: ndisEnum1394GetLocalHostForRemoteNode failed. Status %lx\n", Status));
            break;
        }
        
        RemoteNode->LocalHost = LocalHost;

        ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);
        RemoteNode->Next = LocalHost->RemoteNodeList;
        LocalHost->RemoteNodeList = RemoteNode;
        ExReleaseSpinLock(&LocalHost->Lock, OldIrql);
    
        FreeDevice = FALSE;
        
    } while(FALSE);

    if (FreeDevice)
    {
        IoDeleteDevice(DeviceObject);
    }
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394AddDevice: Status %lx, PDO %lx, FDO %lx\n", Status, PhysicalDeviceObject, DeviceObject));
    
    return (Status);

}

NTSTATUS
ndisEnum1394PowerDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )
{
    PIO_STACK_LOCATION          IrpSp, NextIrpSp;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PDEVICE_OBJECT              NextDeviceObject;
    PNDISENUM1394_REMOTE_NODE   RemoteNode;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394PowerDispatch: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));


    Irp->IoStatus.Status = STATUS_SUCCESS;

    PoStartNextPowerIrp(Irp);
   
    //
    // Set up the Irp for passing it down, no completion routine is needed
    //
    IoSkipCurrentIrpStackLocation(Irp);
    
    RemoteNode = (PNDISENUM1394_REMOTE_NODE)DeviceObject->DeviceExtension;
    
    //
    //  Get a pointer to the next miniport.
    //
    NextDeviceObject = RemoteNode->NextDeviceObject;
    
    //
    // Call the lower device
    //
    PoCallDriver (NextDeviceObject, Irp);   
    
    Status = STATUS_SUCCESS;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394PowerDispatch: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));
    
    return Status;
}


NTSTATUS
ndisEnum1394WMIDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )
{
    PIO_STACK_LOCATION  NextIrpStack;
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PNDISENUM1394_REMOTE_NODE RemoteNode = NULL;
    PDEVICE_OBJECT      NextDeviceObject = NULL;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394WMIDispatch: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));
    
    
    //
    //  Get a pointer to the adapter block and miniport block then determine
    //  which one we should use.
    //
    RemoteNode = (PNDISENUM1394_REMOTE_NODE)DeviceObject->DeviceExtension;
    
    //
    //  Get a pointer to the next miniport.
    //
    NextDeviceObject = RemoteNode->NextDeviceObject;

    //
    // Pass the Irp Down
    //
    //
    // Set up the Irp for passing it down, no completion routine is needed
    //
    IoSkipCurrentIrpStackLocation(Irp);
       
    ntStatus = IoCallDriver (NextDeviceObject, Irp);

    return ntStatus;

}


NTSTATUS
ndisEnum1394StartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )   
{
    PNDISENUM1394_REMOTE_NODE   RemoteNode, TmpRemoteNode;
    PNDISENUM1394_LOCAL_HOST    LocalHost;
    NTSTATUS                    Status = STATUS_SUCCESS;
    KIRQL                       OldIrql;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394StartDevice: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    
    RemoteNode = (PNDISENUM1394_REMOTE_NODE)DeviceObject->DeviceExtension;
    LocalHost = RemoteNode->LocalHost;
    ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);
    
    do
    {

        //
        // if this is a duplicate node, leave it in the queue. but don't tag it as
        // being started so we don't end up indicating it
        //
        for (TmpRemoteNode = LocalHost->RemoteNodeList;
                        TmpRemoteNode != NULL;
                        TmpRemoteNode = TmpRemoteNode->Next)
        {
            if ((TmpRemoteNode->UniqueId[0] == RemoteNode->UniqueId[0]) &&
                (TmpRemoteNode->UniqueId[1] == RemoteNode->UniqueId[1]) &&
                ENUM_TEST_FLAG(TmpRemoteNode, NDISENUM1394_NODE_PNP_STARTED))
                
                break;              
        }

        if (TmpRemoteNode != NULL)
        {
            //
            // duplicate node
            //
            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394StartDevice: duplicate node. new node %lx, original Node %lx\n",
                                    TmpRemoteNode, RemoteNode));

            ENUM_CLEAR_FLAG(RemoteNode, NDISENUM1394_NODE_PNP_STARTED);
            break;
        }
        
        ENUM_SET_FLAG(RemoteNode, NDISENUM1394_NODE_PNP_STARTED);
        
        if((AddNodeHandler != NULL) && (LocalHost->Nic1394AdapterContext != NULL))
        {
            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394StartDevice: Notifying Nic1394 of device arrival, Miniport PDO %lx, Node PDO %lx\n", LocalHost->PhysicalDeviceObject, RemoteNode->PhysicalDeviceObject));
            if (!ENUM_TEST_FLAG(RemoteNode, NDISENUM1394_NODE_INDICATED))
            {
                ENUM_SET_FLAG(RemoteNode, NDISENUM1394_NODE_INDICATED);
                
                ExReleaseSpinLock(&LocalHost->Lock, OldIrql);
                Status = AddNodeHandler(LocalHost->Nic1394AdapterContext,
                                        (PVOID)RemoteNode,
                                        RemoteNode->PhysicalDeviceObject,
                                        RemoteNode->UniqueId[0],
                                        RemoteNode->UniqueId[1],
                                        &RemoteNode->Nic1394NodeContext);
                                        
                ASSERT(Status == STATUS_SUCCESS);
                
                ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);

                if (Status == STATUS_SUCCESS)
                {
                    ENUM_SET_FLAG(RemoteNode, NDISENUM1394_NODE_ADDED);
                }
                else
                {
                    DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394StartDevice: AddAdapter failed %lx\n", Status));
                }
            }
            
        }
        
    } while (FALSE);
    
    ExReleaseSpinLock(&LocalHost->Lock, OldIrql);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394StartDevice: Status %lx, DeviceObject %lx, Irp %lx\n", Status, DeviceObject, Irp));

    return Status;
}


VOID
ndisEnum1394IndicateNodes(
    PNDISENUM1394_LOCAL_HOST    LocalHost
    )
{

    PNDISENUM1394_REMOTE_NODE   RemoteNode;
    NTSTATUS                    Status = STATUS_UNSUCCESSFUL;
    KIRQL                       OldIrql;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394IndicateNodes: LocalHost %lx\n", LocalHost));

    
    //
    // notify 1394 NIC driver
    //
    if (AddNodeHandler == NULL)
    {
        DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394IndicateNodes: LocalHost %lx\n", LocalHost));
        return;
    }
    
    ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);

    if (ENUM_TEST_FLAG(LocalHost, NDISENUM1394_LOCALHOST_REGISTERED))
    {
    
      next:
        for (RemoteNode = LocalHost->RemoteNodeList;
                        RemoteNode != NULL;
                        RemoteNode = RemoteNode->Next)
        {
            if ((!ENUM_TEST_FLAG(RemoteNode, NDISENUM1394_NODE_INDICATED)) &&
                ENUM_TEST_FLAG(RemoteNode, NDISENUM1394_NODE_PNP_STARTED))

            {
                ENUM_SET_FLAG(RemoteNode, NDISENUM1394_NODE_INDICATED);
                break;
            }
        }

        if (RemoteNode != NULL)
        {
            
            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394IndicateNodes: Notifying Nic1394 of device arrival, Miniport PDO %lx, Node PDO %lx\n", LocalHost->PhysicalDeviceObject, RemoteNode->PhysicalDeviceObject));

            ExReleaseSpinLock(&LocalHost->Lock, OldIrql);
                
            Status = AddNodeHandler(LocalHost->Nic1394AdapterContext,
                                    (PVOID)RemoteNode,
                                    RemoteNode->PhysicalDeviceObject,
                                    RemoteNode->UniqueId[0],
                                    RemoteNode->UniqueId[1],
                                    &RemoteNode->Nic1394NodeContext);

            ASSERT(Status == STATUS_SUCCESS);

            if (Status == STATUS_SUCCESS)
            {
                ENUM_SET_FLAG(RemoteNode, NDISENUM1394_NODE_ADDED);
            }
            else
            {
                DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394IndicateNodes: AddAdapter failed %lx\n", Status));
            }
            
            ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);
            goto next;
        }
    }
    else
    {
        DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394IndicateNodes: LocalHost is not registered %lx\n", Status));
    }
    
    ExReleaseSpinLock(&LocalHost->Lock, OldIrql);
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394IndicateNodes: LocalHost %lx\n", LocalHost));

}
    

NTSTATUS
ndisEnum1394CreateIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )
{
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394CreateIrpHandler: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394CreateIrpHandler: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    return STATUS_SUCCESS;
}




NTSTATUS
ndisEnum1394CloseIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )
{
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394CloseIrpHandler: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394CloseIrpHandler: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));
    
    return STATUS_SUCCESS;
}

NTSTATUS
ndisEnum1394DeviceIoControl(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )
{
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394DeviceIoControl: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394DeviceIoControl: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    return STATUS_SUCCESS;
}

VOID
ndisEnum1394Unload(
    IN  PDRIVER_OBJECT          DriverObject
    )
{
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394Unload: DriverObject %lx\n", DriverObject));
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394Unload: DriverObject %lx\n", DriverObject));

    // 
    // Tell nic1394 that we are going away
    //
    if (DeRegisterDriverHandler != NULL ) 
    {
        DeRegisterDriverHandler()  ;
    }

    //
    // Deregister our callback structure
    // 
    ExUnregisterCallback(ndisEnum1394CallbackRegisterationHandle);

    //
    // Dereference our callback structure
    //
    ObDereferenceObject(ndisEnum1394CallbackObject);

    return;
}



/*
EXPORT
NTSTATUS
NdisEnum1394RegisterAdapter(
    IN  PVOID                   Nic1394AdapterContext,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject,
    OUT PVOID*                  pEnum1394AdapterHandle,
    OUT PLARGE_INTEGER          pLocalHostUniqueId
    );



    This routine is called at system initialization time so we can fill in the basic dispatch points

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS

Routine Description:

    This function is called by Nic1394 during its Ndis IntializeHandler to register a new
    Adapter. each registered adapter corresponds to a local host controller.
    in response Enum1394 finds the local host and for each remote node on the local host
    that have not been indicated yet calls the Nic1394 AddNodes handler.

Arguments:
    Nic1394AdapterContext   Nic1394 context for the local host
    PhysicalDeviceObject    PDO created by 1394 Bus driver for the local host
    pEnum1394AdapterHandle  a pointer a pointer to be initialized to Enum1394 LocalHost context
    pLocalHostUniqueId      a pointer to a LARGE_INTEGER to be initialized to local host unique ID
*/
NTSTATUS
NdisEnum1394RegisterAdapter(
    IN  PVOID                   Nic1394AdapterContext,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject,
    OUT PVOID*                  pEnum1394AdapterHandle,
    OUT PLARGE_INTEGER          pLocalHostUniqueId
    )
{
    PNDISENUM1394_LOCAL_HOST    LocalHost;
    PNDISENUM1394_REMOTE_NODE   LocalNode;
    NTSTATUS                    Status;
    KIRQL                       OldIrql;
    IRB                         Irb;
    GET_LOCAL_HOST_INFO1        uId;
    PDEVICE_OBJECT              DeviceObject;


    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>NdisEnum1394RegisterAdapter, PhysicalDeviceObject %lx\n", PhysicalDeviceObject));

    do
    {

        //
        // get the unique ID for the local host for this adapter
        //
        
        RtlZeroMemory(&Irb, sizeof(IRB));
        
        Irb.FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
        Irb.u.GetLocalHostInformation.nLevel = GET_HOST_UNIQUE_ID;
        Irb.u.GetLocalHostInformation.Information = (PVOID)&uId;

        Status = ndisEnum1394BusRequest(PhysicalDeviceObject, &Irb);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("NdisEnum1394RegisterAdapter: ndisEnum1394BusRequest for REQUEST_GET_LOCAL_HOST_INFO failed. Status %lx\n", Status));
            break;
        }

        //
        // GetLocal Host Refs the LocalHost - Derefed in DeRegisterAdapter            
        //
        ndisEnum1394GetLocalHostForUniqueId(uId.UniqueId, &LocalHost);


#if 0
        ExAcquireSpinLock(&ndisEnum1394GlobalLock, &OldIrql);
        
        for (LocalHost = LocalHostList; LocalHost != NULL; LocalHost = LocalHost->Next)
        {
            if ((LocalHost->UniqueId.LowPart == uId.UniqueId.LowPart) && 
                (LocalHost->UniqueId.HighPart == uId.UniqueId.HighPart))
            {
                break;
            }
        }
        
        ExReleaseSpinLock(&ndisEnum1394GlobalLock, OldIrql);
#endif

        ASSERT(LocalHost != NULL);

        if (LocalHost == NULL)
        {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }
        
        *pEnum1394AdapterHandle = (PVOID)LocalHost;
        LocalHost->Nic1394AdapterContext = Nic1394AdapterContext;
        LocalHost->PhysicalDeviceObject = PhysicalDeviceObject;
                
        *pLocalHostUniqueId = LocalHost->UniqueId;

        ENUM_SET_FLAG(LocalHost, NDISENUM1394_LOCALHOST_REGISTERED);

        ndisEnum1394IndicateNodes(LocalHost);
        
        Status = STATUS_SUCCESS;
        
    } while (FALSE);
    

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==NdisEnum1394RegisterAdapter: Status %lx\n", Status));
    
    return Status;
}


VOID
NdisEnum1394DeregisterAdapter(
    IN  PVOID                   Enum1394AdapterHandle
    )
{
    PNDISENUM1394_LOCAL_HOST LocalHost = (PNDISENUM1394_LOCAL_HOST)Enum1394AdapterHandle;
    KIRQL   OldIrql;
    PNDISENUM1394_REMOTE_NODE RemoteNode;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>NdisEnum1394DeregisterAdapter: LocalHost %lx\n", Enum1394AdapterHandle));

    //
    // go through all the nodes and remove them
    //
    ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);

    //
    // make sure we will not try to indicate any new dev node on this
    //
    ENUM_CLEAR_FLAG(LocalHost, NDISENUM1394_LOCALHOST_REGISTERED);

    
  next:
    for (RemoteNode = LocalHost->RemoteNodeList;
                    RemoteNode != NULL;
                    RemoteNode = RemoteNode->Next)
    {
        ENUM_CLEAR_FLAG(RemoteNode, NDISENUM1394_NODE_INDICATED);
        if (ENUM_TEST_FLAG(RemoteNode, NDISENUM1394_NODE_ADDED))
        {
            break;
        }
    }

    if (RemoteNode != NULL)
    {       
        DBGPRINT(ENUM1394_DBGLEVEL_INFO, 
            ("NdisEnum1394DeregisterAdapter: Notifying Nic1394 of device removal, Miniport PDO %lx, Node PDO %lx\n", LocalHost->PhysicalDeviceObject, RemoteNode->PhysicalDeviceObject));

        ExReleaseSpinLock(&LocalHost->Lock, OldIrql);
        RemoveNodeHandler(RemoteNode->Nic1394NodeContext);          
        ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);
        ENUM_CLEAR_FLAG(RemoteNode, NDISENUM1394_NODE_ADDED);
        
        goto next;
    }
    
    LocalHost->Nic1394AdapterContext = NULL;
    LocalHost->PhysicalDeviceObject = NULL;

    ExReleaseSpinLock(&LocalHost->Lock, OldIrql);

    //
    // Dereference the Ref made in RegisterAdapter by calling GetLocalHost for Unique ID
    //
    {   
        BOOLEAN bIsRefZero;

        bIsRefZero = ndisEnum1394DereferenceLocalHost(LocalHost);

        if (bIsRefZero == TRUE)
        {
            ndisEnum1394FreeLocalHost(LocalHost);
        }
    }
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==NdisEnum1394DeregisterAdapter: LocalHost %lx\n", Enum1394AdapterHandle));
    
}

NTSTATUS
ndisEnum1394GetLocalHostForRemoteNode(
    IN  PNDISENUM1394_REMOTE_NODE       RemoteNode,
    OUT PNDISENUM1394_LOCAL_HOST *      pLocalHost
    )
{
    NTSTATUS                    Status;
    PNDISENUM1394_LOCAL_HOST    LocalHost;
    KIRQL                       OldIrql;
    IRB                         Irb;
    GET_LOCAL_HOST_INFO1        uId;
    ULONG                       SizeNeeded;
    PVOID                       ConfigInfoBuffer = NULL;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394GetLocalHostForRemoteNode: RemoteNode %lx\n", RemoteNode));

    do
    {
        //
        // get the unique ID for the local host which this device
        // is connected on. then walk through all the existing local
        // hosts and see if this a new local host or not.
        //
        
        RtlZeroMemory(&Irb, sizeof(IRB));
        
        Irb.FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
        Irb.u.GetLocalHostInformation.nLevel = GET_HOST_UNIQUE_ID;
        Irb.u.GetLocalHostInformation.Information = (PVOID)&uId;

        Status = ndisEnum1394BusRequest(RemoteNode->NextDeviceObject, &Irb);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394GetLocalHostForRemoteNode: ndisEnum1394BusRequest for REQUEST_GET_LOCAL_HOST_INFO failed. Status %lx\n", Status));
            break;
        }
        
        //
        // now get the unique ID for the remote node
        //
        // we have to make this call twice. first to get the size, then the actual data
        //

        RtlZeroMemory(&Irb, sizeof(IRB));
        
        Irb.FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;

        Status = ndisEnum1394BusRequest(RemoteNode->NextDeviceObject, &Irb);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394GetLocalHostForRemoteNode: ndisEnum1394BusRequest for REQUEST_GET_CONFIGURATION_INFO (size) failed. Status %lx\n", Status));
            break;
        }

        SizeNeeded = sizeof(CONFIG_ROM) +
                     Irb.u.GetConfigurationInformation.UnitDirectoryBufferSize +
                     Irb.u.GetConfigurationInformation.UnitDependentDirectoryBufferSize +
                     Irb.u.GetConfigurationInformation.VendorLeafBufferSize +
                     Irb.u.GetConfigurationInformation.ModelLeafBufferSize;

        ConfigInfoBuffer = (PVOID)ALLOC_FROM_POOL(SizeNeeded, '  4N');
        
        if (ConfigInfoBuffer == NULL)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394GetLocalHostForRemoteNode: Failed to allocate memory for config info.\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Irb.u.GetConfigurationInformation.ConfigRom = (PCONFIG_ROM)ConfigInfoBuffer;
        Irb.u.GetConfigurationInformation.UnitDirectory = (PVOID)((PUCHAR)ConfigInfoBuffer + sizeof(CONFIG_ROM));
        Irb.u.GetConfigurationInformation.UnitDependentDirectory = (PVOID)((PUCHAR)Irb.u.GetConfigurationInformation.UnitDirectory + 
                                                                            Irb.u.GetConfigurationInformation.UnitDirectoryBufferSize);
        Irb.u.GetConfigurationInformation.VendorLeaf = (PVOID)((PUCHAR)Irb.u.GetConfigurationInformation.UnitDependentDirectory + 
                                                                                  Irb.u.GetConfigurationInformation.UnitDependentDirectoryBufferSize);
        Irb.u.GetConfigurationInformation.ModelLeaf = (PVOID)((PUCHAR)Irb.u.GetConfigurationInformation.VendorLeaf + 
                                                                                  Irb.u.GetConfigurationInformation.VendorLeafBufferSize);      
        Irb.FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;

        Status = ndisEnum1394BusRequest(RemoteNode->NextDeviceObject, &Irb);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394GetLocalHostForRemoteNode: ndisEnum1394BusRequest for REQUEST_GET_CONFIGURATION_INFO failed. Status %lx\n", Status));
            break;
        }

        ASSERT(Irb.u.GetConfigurationInformation.ConfigRom != NULL);
        
        RemoteNode->UniqueId[0] = Irb.u.GetConfigurationInformation.ConfigRom->CR_Node_UniqueID[0];
        RemoteNode->UniqueId[1] = Irb.u.GetConfigurationInformation.ConfigRom->CR_Node_UniqueID[1];

#if DBG
        
        DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("Unique ID for Node %lx: %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x\n",
                        RemoteNode->PhysicalDeviceObject,
                        *((PUCHAR)&RemoteNode->UniqueId[0]),
                        *(((PUCHAR)&RemoteNode->UniqueId[0])+1),
                        *(((PUCHAR)&RemoteNode->UniqueId[0])+2),
                        *(((PUCHAR)&RemoteNode->UniqueId[0])+3),
                        *((PUCHAR)&RemoteNode->UniqueId[1]),
                        *(((PUCHAR)&RemoteNode->UniqueId[1])+1),
                        *(((PUCHAR)&RemoteNode->UniqueId[1])+2),
                        *(((PUCHAR)&RemoteNode->UniqueId[1])+3)));
        

#endif

        ndisEnum1394GetLocalHostForUniqueId(uId.UniqueId, &LocalHost);

        if (LocalHost == NULL)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394GetLocalHostForUniqueId: Failed to get the local host.\n"));
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        *pLocalHost = LocalHost;

        
        Status = STATUS_SUCCESS;

    } while (FALSE);


    if (ConfigInfoBuffer != NULL)
    {
        FREE_POOL(ConfigInfoBuffer);
    }
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394GetLocalHostForRemoteNode: Status %lx, RemoteNode %lx, LocalHostList %lx\n", Status, RemoteNode, LocalHostList));

    return Status;
}

NTSTATUS
ndisEnum1394IrpCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This routine will get called after the next device object in the stack
    processes the IRP_MN_QUERY_CAPABILITIES IRP this needs to be merged with
    the miniport's capabilites and completed.

Arguments:

    DeviceObject
    Irp
    Context

Return Value:

--*/
{
    SET_EVENT(Context);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
ndisEnum1394PassIrpDownTheStack(
    IN  PIRP            pIrp,
    IN  PDEVICE_OBJECT  pNextDeviceObject
    )
/*++

Routine Description:

    This routine will simply pass the IRP down to the next device object to
    process.

Arguments:
    pIrp                -   Pointer to the IRP to process.
    pNextDeviceObject   -   Pointer to the next device object that wants
                            the IRP.

Return Value:

--*/
{
    KEVENT              Event;
    NTSTATUS            Status = STATUS_SUCCESS;

    //
    //  Initialize the event structure.
    //
    INITIALIZE_EVENT(&Event);

    //
    //  Set the completion routine so that we can process the IRP when
    //  our PDO is done.
    //
    IoSetCompletionRoutine(pIrp,
                           (PIO_COMPLETION_ROUTINE)ndisEnum1394IrpCompletion,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    //  Pass the IRP down to the PDO.
    //
    Status = IoCallDriver(pNextDeviceObject, pIrp);
    if (Status == STATUS_PENDING)
    {
        //
        //  Wait for completion.
        //
        WAIT_FOR_OBJECT(&Event, NULL);

        Status = pIrp->IoStatus.Status;
    }

    return(Status);
}

NTSTATUS
ndisEnum1394PnpDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )

/*++

Routine Description:

    The handler for IRP_MJ_PNP_POWER.

Arguments:

    DeviceObject - The adapter's functional device object.
    Irp - The IRP.

Return Value:

--*/
{
    PIO_STACK_LOCATION          IrpSp, NextIrpSp;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PDEVICE_OBJECT              NextDeviceObject;
    PNDISENUM1394_REMOTE_NODE   RemoteNode;
    ULONG                       PnPDeviceState;
    KEVENT                      RemoveReadyEvent;
    BOOLEAN                     fSendIrpDown = TRUE;
    BOOLEAN                     fCompleteIrp = TRUE;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394PnpDispatch: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));
    
    if (DbgIsNull(Irp))
    {
        DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394PnpDispatch: Null Irp\n"));
        DBGBREAK();
    }

    //
    //  Get a pointer to the adapter block and miniport block then determine
    //  which one we should use.
    //
    RemoteNode = (PNDISENUM1394_REMOTE_NODE)DeviceObject->DeviceExtension;
    
    //
    //  Get a pointer to the next miniport.
    //
    NextDeviceObject = RemoteNode->NextDeviceObject;
    
    IrpSp = IoGetCurrentIrpStackLocation (Irp);


    switch(IrpSp->MinorFunction)
    {
        case IRP_MN_START_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_START_DEVICE\n", RemoteNode));
            
            IoCopyCurrentIrpStackLocationToNext(Irp);
            Status = ndisEnum1394PassIrpDownTheStack(Irp, NextDeviceObject);

            //
            //  If the bus driver succeeded the start irp then proceed.
            //
            if (NT_SUCCESS(Status))
            {
                Status = ndisEnum1394StartDevice(DeviceObject, Irp);
            }
            else
            {
                DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394PnpDispatch: bus driver failed START IRP RemoteNode %lx\n", RemoteNode));
            }

            RemoteNode->PnPDeviceState = PnPDeviceStarted;

            Irp->IoStatus.Status = Status;
            fSendIrpDown = FALSE;   // we already did send the IRP down
            break;
        
        case IRP_MN_QUERY_REMOVE_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_QUERY_REMOVE_DEVICE\n", RemoteNode));
            
            RemoteNode->PnPDeviceState = PnPDeviceQueryRemoved;

            Irp->IoStatus.Status = STATUS_SUCCESS;
            //
            // if we failed query_remove, no point sending this irp down
            //
            fSendIrpDown = TRUE;
            break;
        
        case IRP_MN_CANCEL_REMOVE_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_CANCEL_REMOVE_DEVICE\n", RemoteNode));

            RemoteNode->PnPDeviceState = PnPDeviceStarted;

            Irp->IoStatus.Status = STATUS_SUCCESS;
            fSendIrpDown = TRUE;
            break;
            
        case IRP_MN_REMOVE_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_REMOVE_DEVICE\n", RemoteNode));
            ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

            //
            // call notify handler
            //

            PnPDeviceState = RemoteNode->PnPDeviceState;
            
            if (PnPDeviceState != PnPDeviceSurpriseRemoved)
            {
                RemoteNode->PnPDeviceState = PnPDeviceRemoved;
                
                Status = ndisEnum1394RemoveDevice(DeviceObject, 
                                                Irp, 
                                                NdisEnum1394_RemoveDevice);

                Irp->IoStatus.Status = Status;
            }
            else
            {
                Irp->IoStatus.Status = STATUS_SUCCESS;
            }
            
            //
            // when we are done, send the Irp down here
            // we have some post-processing to do
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(NextDeviceObject, Irp);

            IoDetachDevice(NextDeviceObject);
            IoDeleteDevice(DeviceObject);
            
            fSendIrpDown = FALSE;
            fCompleteIrp = FALSE;
            break;
            
        case IRP_MN_SURPRISE_REMOVAL:
            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_SURPRISE_REMOVAL\n", RemoteNode));
                
            ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

            RemoteNode->PnPDeviceState = PnPDeviceSurpriseRemoved;
            Status = ndisEnum1394RemoveDevice(DeviceObject, 
                                            Irp, 
                                            NdisEnum1394_SurpriseRemoveDevice);

            Irp->IoStatus.Status = Status;

            //
            // when we are done, send the Irp down here
            // we have some post-processing to do
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(NextDeviceObject, Irp);
                        
            fSendIrpDown = FALSE;
            fCompleteIrp = FALSE;
                
            break;
        
        case IRP_MN_QUERY_STOP_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_QUERY_STOP_DEVICE\n", RemoteNode));

            RemoteNode->PnPDeviceState = PnPDeviceQueryStopped;
            Irp->IoStatus.Status = STATUS_SUCCESS;
            fSendIrpDown = TRUE;
            break;
            
        case IRP_MN_CANCEL_STOP_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_CANCEL_STOP_DEVICE\n", RemoteNode));
            
            RemoteNode->PnPDeviceState = PnPDeviceStarted;
            Irp->IoStatus.Status = STATUS_SUCCESS;
            fSendIrpDown = TRUE;
            break;
            
        case IRP_MN_STOP_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_STOP_DEVICE\n", RemoteNode));

            RemoteNode->PnPDeviceState = PnPDeviceStopped;          
            Status = ndisEnum1394RemoveDevice(DeviceObject, Irp,NdisEnum1394_StopDevice);
            Irp->IoStatus.Status = Status;
            fSendIrpDown = TRUE;
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode, IRP_MN_QUERY_CAPABILITIES\n", RemoteNode));

            IoCopyCurrentIrpStackLocationToNext(Irp);
            Status = ndisEnum1394PassIrpDownTheStack(Irp, NextDeviceObject);
#ifdef  ENUM1394_NT
            //
            // Memphis does not support SurpriseRemovalOK bit
            //
            //  If the bus driver succeeded the start irp then proceed.
            //
            if (NT_SUCCESS(Status))
            {
                //
                //  Modify the capabilities so that the device is not suprise removable.
                //                                                
                IrpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = 1;
            }
#endif // NDIS_NT

            
            fSendIrpDown = FALSE;
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            Irp->IoStatus.Status = Status;
            fSendIrpDown = TRUE ;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
        case IRP_MN_QUERY_INTERFACE:
        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:
        case IRP_MN_EJECT:
        case IRP_MN_SET_LOCK:
        case IRP_MN_QUERY_ID:
        default:
            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, MinorFunction 0x%x\n", RemoteNode, IrpSp->MinorFunction));

            //
            //  We don't handle the irp so pass it down.
            //
            fSendIrpDown = TRUE;
            break;          
    }

    //
    //  First check to see if we need to send the irp down.
    //  If we don't pass the irp on then check to see if we need to complete it.
    //
    if (fSendIrpDown)
    {
        IoSkipCurrentIrpStackLocation(Irp);
        Status = IoCallDriver(NextDeviceObject, Irp);
    }
    else if (fCompleteIrp)
    {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394PnpDispatch: Status %lx, RemoteNode %lx\n", Status, RemoteNode));

    return(Status);
}


NTSTATUS
ndisEnum1394RemoveDevice(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                Irp,
    NDISENUM1394_PNP_OP PnpOp
    )
/*++

Routine Description:

    This function is called in the RemoveDevice and Stop Device code path.
    In the case of a Stop the function should undo whatever it received in the Start
    and it the case of a Remove it Should do undo the work done in AddDevice

Arguments:

    DeviceObject - The adapter's functional device object.
    Irp - The IRP.

Return Value:

--*/
{
    PNDISENUM1394_REMOTE_NODE   RemoteNode, *ppDB;
    PNDISENUM1394_LOCAL_HOST    LocalHost;
    KIRQL                       OldIrql;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394RemoveDevice: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));
    ASSERT(KeGetCurrentIrql()==PASSIVE_LEVEL );
    //
    // call 1394Nic about this device getting removed
    // if this is the last PDO on local host, get rid of
    // the PDO created for the local host
    //

    RemoteNode = (PNDISENUM1394_REMOTE_NODE)DeviceObject->DeviceExtension;
    LocalHost = RemoteNode->LocalHost;

    //
    // if the node has been indicated, let the nic1394 know
    // it is going away
    //
    if ((RemoveNodeHandler != NULL) && (ENUM_TEST_FLAGS(RemoteNode, NDISENUM1394_NODE_ADDED)))
    {
        RemoveNodeHandler(RemoteNode->Nic1394NodeContext);
        ENUM_CLEAR_FLAG(RemoteNode, NDISENUM1394_NODE_ADDED);
    }

    //
    // If this is a stop device then do NOT do any software specific cleanup work ..
    // leave it for the RemoveDevice
    //
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394RemoveDevice: - pRemoteNode %p LocalHost %p Op %x\n", 
                                        RemoteNode, 
                                        LocalHost,
                                        PnpOp));
    
    if (PnpOp != NdisEnum1394_StopDevice && LocalHost != NULL)
    {
        //
        // find the device block and remove it from local host
        //
        ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);

        for (ppDB = &LocalHost->RemoteNodeList; *ppDB != NULL; ppDB = &(*ppDB)->Next)
        {
            if (*ppDB == RemoteNode)
            {
                *ppDB = RemoteNode->Next;
                break;
            }
        }

        ExReleaseSpinLock(&LocalHost->Lock, OldIrql);

        ASSERT(*ppDB == RemoteNode->Next);

        //
        // Remove the Ref made in the Add Devive when calling GetLocalHost for Unique ID
        //
        {   
            BOOLEAN bIsRefZero;

            RemoteNode->LocalHost = NULL;

            bIsRefZero = ndisEnum1394DereferenceLocalHost(LocalHost);

            
            if (bIsRefZero == TRUE)
            {
                ndisEnum1394FreeLocalHost(LocalHost);
            }
        }
    }
    
    ENUM_CLEAR_FLAG(RemoteNode, NDISENUM1394_NODE_PNP_STARTED);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394RemoveDevice: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    return STATUS_SUCCESS;
}

/*+++
NTSTATUS
ndisEnum1394BusRequest(
    PDEVICE_OBJECT              DeviceObject,
    PIRB                        Irb
    );

Routine Description:
    this function issues a 1394 bus request to the device object. the device
    object could be the NextDeviceObject of the remote PDO or the virtual PDO
    1394 bus ejected (net PDO)

Arguments:
    DeviceObject: the target device object to send the request to
    Irb: the request block

Return Value:
    as appropriate
    
---*/

NTSTATUS
ndisEnum1394BusRequest(
    PDEVICE_OBJECT              DeviceObject,
    PIRB                        Irb
    )
{
    NTSTATUS                Status;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394BusRequest: DeviceObject %lx, Irb %lx\n", DeviceObject, Irb));
    
    do
    {
        Irp = IoAllocateIrp((CCHAR)(DeviceObject->StackSize + 1),
                                 FALSE);
        if (Irp == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394BusRequest: IoAllocateIrp failed. Status %lx\n", Status));
            break;
        }
        
        IrpSp = IoGetNextIrpStackLocation(Irp);
        ASSERT(IrpSp != NULL);
        RtlZeroMemory(IrpSp, sizeof(IO_STACK_LOCATION ));
        
        IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        IrpSp->DeviceObject = DeviceObject;
        IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
        IrpSp->Parameters.Others.Argument1 = Irb;
        Irp->IoStatus.Status  = STATUS_NOT_SUPPORTED;

        Status = ndisEnum1394PassIrpDownTheStack(Irp, DeviceObject);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394BusRequest: 1394 Bus driver failed the IRB. Status %lx\n", Status));
        }
        
    }while (FALSE);
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394BusRequest: DeviceObject %lx, Irb %lx\n", DeviceObject, Irb));

    return Status;
}

BOOLEAN
ndisEnum1394ReferenceLocalHost(
        IN PNDISENUM1394_LOCAL_HOST LocalHost
        )
{   
    BOOLEAN                     rc;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394ReferenceLocalHost : LocalHost %p\n", LocalHost));

    rc = ndisEnum1394ReferenceRef(&LocalHost->Reference);

    return rc;
}

BOOLEAN
ndisEnum1394DereferenceLocalHost(
        IN PNDISENUM1394_LOCAL_HOST LocalHost
        )
{   
    BOOLEAN                     rc;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394DereferenceLocalHost : LocalHost %p\n", LocalHost));

    rc = ndisEnum1394DereferenceRef(&LocalHost->Reference);

    return rc;
}

VOID
ndisEnum1394FreeLocalHost(
        IN PNDISENUM1394_LOCAL_HOST LocalHost
        )
{
    KIRQL                       OldIrql;
    PNDISENUM1394_LOCAL_HOST *  ppLH;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394FreeLocalHost: LocalHost %p\n", LocalHost));
    
    ASSERT(LocalHost->RemoteNodeList == NULL);
    ASSERT(LocalHost->Reference.ReferenceCount == 0);
    
    //
    // make sure we have not created a PDO for this local host
    //
    ASSERT(LocalHost->PhysicalDeviceObject == NULL);

    ExAcquireSpinLock(&ndisEnum1394GlobalLock, &OldIrql);

    for (ppLH = &LocalHostList; *ppLH != NULL; ppLH = &(*ppLH)->Next)
    {
        if (*ppLH == LocalHost)
        {
            *ppLH = LocalHost->Next;
            break;
        }
    }

    ExReleaseSpinLock(&ndisEnum1394GlobalLock, OldIrql);

    ASSERT(*ppLH == LocalHost->Next);
            
    FREE_POOL(LocalHost);
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394FreeLocalHost: LocalHost %p\n", LocalHost));
}

VOID
ndisEnum1394InitializeRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Initialize a reference count structure.

Arguments:

    RefP - The structure to be initialized.

Return Value:

    None.

--*/

{
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394InitializeRef\n"));

    RefP->Closing = FALSE;
    RefP->ReferenceCount = 1;
    KeInitializeSpinLock(&RefP->SpinLock);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394InitializeRef\n"));
}

BOOLEAN
ndisEnum1394ReferenceRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Adds a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference was added.
    FALSE if the object was closing.

--*/

{
    BOOLEAN rc = TRUE;
    KIRQL   OldIrql;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394ReferenceRef\n"));

    ExAcquireSpinLock(&RefP->SpinLock, &OldIrql);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else
    {
        ++(RefP->ReferenceCount);
    }

    ExReleaseSpinLock(&RefP->SpinLock, OldIrql);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394ReferenceRef: RefCount %lx\n", RefP->ReferenceCount));

    return(rc);
}


BOOLEAN
ndisEnum1394DereferenceRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Removes a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference count is now 0.
    FALSE otherwise.

--*/

{
    BOOLEAN rc = FALSE;
    KIRQL   OldIrql;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394DereferenceRef\n"));


    ExAcquireSpinLock(&RefP->SpinLock, &OldIrql);

    --(RefP->ReferenceCount);

    if (RefP->ReferenceCount == 0)
    {
        rc = TRUE;
    }

    ExReleaseSpinLock(&RefP->SpinLock, OldIrql);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394DereferenceRef: RefCount %lx\n", RefP->ReferenceCount));
            
    return(rc);
}

BOOLEAN
ndisEnum1394CloseRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Closes a reference count structure.

Arguments:

    RefP - The structure to be closed.

Return Value:

    FALSE if it was already closing.
    TRUE otherwise.

--*/

{
    KIRQL   OldIrql;
    BOOLEAN rc = TRUE;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394CloseRef\n"));

    ExAcquireSpinLock(&RefP->SpinLock, &OldIrql);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else RefP->Closing = TRUE;

    ExReleaseSpinLock(&RefP->SpinLock, OldIrql);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394CloseRef\n"));
            
    return(rc);
}


NTSTATUS
NdisEnum1394RegisterDriver(
    IN  PNIC1394_CHARACTERISTICS    Characteristics
    )
{
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>NdisEnum1394RegisterDriver\n"));

    //
    // Todo: do some check for the version, etc. and make sure the handlers are
    // not null and this is not a dup registeration
    //

    AddNodeHandler = Characteristics->AddNodeHandler;
    RemoveNodeHandler = Characteristics->RemoveNodeHandler;
    RegisterDriverHandler = Characteristics->RegisterDriverHandler;
    DeRegisterDriverHandler = Characteristics->DeRegisterDriverHandler;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==NdisEnum1394RegisterDriver\n"));

    return STATUS_SUCCESS;
}

VOID
NdisEnum1394DeregisterDriver(
    )
{
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>NdisEnum1394DeregisterDriver\n"));

    AddNodeHandler = NULL;
    RemoveNodeHandler = NULL;
    RegisterDriverHandler = NULL;
    DeRegisterDriverHandler = NULL;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==NdisEnum1394DeregisterDriver\n"));
}


/*+++

this routine will call the 1394 bus driver to create a virtual PDO
on the local host with matching unique ID
---*/

NTSTATUS
ndisEnum1394CreateVirtualPdo(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject,
    IN  LARGE_INTEGER   UniqueId
    )
{
    PDEVICE_OBJECT              BusDeviceObject = NULL;
    PIRP                        pirp;
    PIO_STACK_LOCATION          pirpSpN;
    NTSTATUS                    Status;
    PIEEE1394_API_REQUEST       pApiReq;
    PIEEE1394_VDEV_PNP_REQUEST  pDevPnpReq;
    PSTR                        DeviceId = "NIC1394";
    ULONG                       ulStrLen;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394CreateVirtualPdo\n"));

    do
    {
        
        pirp = IoAllocateIrp((CCHAR)(PhysicalDeviceObject->StackSize + 1),FALSE);
        
        if (NULL == pirp)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR,
                ("ndisEnum1394CreateVirtualPdo failed to allcoate IRP\n"));

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ulStrLen = strlen(DeviceId) + sizeof(UCHAR);
        pApiReq = ALLOC_FROM_POOL(sizeof(IEEE1394_API_REQUEST) + ulStrLen, NDISENUM1394_TAG_1394API_REQ);
        
        if (pApiReq == NULL)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR,
                ("ndisEnum1394CreateVirtualPdo failed to allcoate 1394 request\n"));

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        
        RtlZeroMemory(pApiReq, sizeof(IEEE1394_API_REQUEST) + ulStrLen);
        
        pApiReq->RequestNumber = IEEE1394_API_ADD_VIRTUAL_DEVICE;
        pApiReq->Flags = 0;

        pDevPnpReq = &pApiReq->u.AddVirtualDevice;

        pDevPnpReq->fulFlags = 0;
        pDevPnpReq->Reserved = 0;
        pDevPnpReq->InstanceId.LowPart = (ULONG)UniqueId.LowPart;
        pDevPnpReq->InstanceId.HighPart = (ULONG)UniqueId.HighPart;
        strncpy(&pDevPnpReq->DeviceId, DeviceId, ulStrLen);


        //
        //  Get the stack pointer.
        //
        pirpSpN = IoGetNextIrpStackLocation(pirp);
        ASSERT(pirpSpN != NULL);
        RtlZeroMemory(pirpSpN, sizeof(IO_STACK_LOCATION ) );
        
        //
        //  Set the default device state to full on.
        //
        pirpSpN->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        pirpSpN->MinorFunction = 0;
        
        pirpSpN->Parameters.DeviceIoControl.IoControlCode = IOCTL_IEEE1394_API_REQUEST;
        pirpSpN->Parameters.DeviceIoControl.InputBufferLength = sizeof(IEEE1394_API_REQUEST) + ulStrLen;

        pirp->IoStatus.Status  = STATUS_NOT_SUPPORTED;
        pirp->AssociatedIrp.SystemBuffer = pApiReq;

        Status = ndisEnum1394PassIrpDownTheStack(pirp, PhysicalDeviceObject);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR,
                ("ndisEnum1394CreateVirtualPdo IOCTL to create the virtual PDO failed with Status %lx\n", Status));

        }
        
        IoFreeIrp(pirp);
        
        FREE_POOL(pApiReq);
        
    } while (FALSE);

    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394CreateVirtualPdo: Status %lx\n", Status));

    return Status;

}

//
// this functions searchs through the list of local hosts trying to find one
// with matching unique ID. if it does not, it will allocate a new one
//
VOID
ndisEnum1394GetLocalHostForUniqueId(
    LARGE_INTEGER                   UniqueId,
    OUT PNDISENUM1394_LOCAL_HOST *  pLocalHost
    )
{

    PNDISENUM1394_LOCAL_HOST    TempLocalHost;
    PNDISENUM1394_LOCAL_HOST    LocalHost;
    KIRQL                       OldIrql;
    BOOLEAN                     bFreeTempLocalHost = FALSE;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394GetLocalHostForUniqueId\n"));
    
    do
    {
        ExAcquireSpinLock(&ndisEnum1394GlobalLock, &OldIrql);

        for (LocalHost = LocalHostList; LocalHost != NULL; LocalHost = LocalHost->Next)
        {
            if (LocalHost->UniqueId.QuadPart == UniqueId.QuadPart)
                break;
        }
        
        ExReleaseSpinLock(&ndisEnum1394GlobalLock, OldIrql);
        
        if (LocalHost == NULL)
        {

            TempLocalHost = (PNDISENUM1394_LOCAL_HOST)ALLOC_FROM_POOL(sizeof(NDISENUM1394_LOCAL_HOST), NDISENUM1394_TAG_LOCAL_HOST);
            if (TempLocalHost == NULL)
            {
                DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394GetLocalHostForUniqueId: Failed to allocate memory LocalHost.\n"));
                break;
            }
            
            RtlZeroMemory(TempLocalHost, sizeof (NDISENUM1394_LOCAL_HOST));
            
            ExAcquireSpinLock(&ndisEnum1394GlobalLock, &OldIrql);

            //
            // need to do the search again just in case between the time we release the
            // spinlock and now, we have added the local host
            //
            for (LocalHost = LocalHostList; LocalHost != NULL; LocalHost = LocalHost->Next)
            {
                if (LocalHost->UniqueId.QuadPart == UniqueId.QuadPart)
                    break;
            }
        
            if (LocalHost == NULL)
            {
                LocalHost = TempLocalHost;
                LocalHost->Next = LocalHostList;
                LocalHostList = LocalHost;
                LocalHost->RemoteNodeList = NULL;
                LocalHost->UniqueId.QuadPart = UniqueId.QuadPart;
                KeInitializeSpinLock(&LocalHost->Lock);
                ndisEnum1394InitializeRef(&LocalHost->Reference);

            }
            else
            {
                bFreeTempLocalHost = TRUE;
            }
            
            ExReleaseSpinLock(&ndisEnum1394GlobalLock, OldIrql);
            
            if (bFreeTempLocalHost)
                FREE_POOL(TempLocalHost);

        }
        else
        {
            //
            // Give the caller a reference to our struct
            //
            ndisEnum1394ReferenceLocalHost(LocalHost);
        }
        
    } while (FALSE);

    *pLocalHost = LocalHost;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394GetLocalHostForUniqueId: LocalHost %lx\n", LocalHost));

    return;
}


VOID
Enum1394Callback(
    PVOID   CallBackContext,
    PVOID   Source,
    PVOID   Characteristics
    )
{
    NTSTATUS    Status;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>Enum1394Callback: Source %lx, Characteristics %lx\n", Source, Characteristics));
    
    //
    // if we are the one issuing this notification, just return
    //
    if (Source == NDIS1394_CALLBACK_SOURCE_ENUM1394)
        return;

    //
    // notification is coming from Nic1394. grab the entry points. call it and
    // let it know that you are here
    //
    ASSERT(Source == (PVOID)NDIS1394_CALLBACK_SOURCE_NIC1394);

    RegisterDriverHandler = ((PNIC1394_CHARACTERISTICS)Characteristics)->RegisterDriverHandler;

    ASSERT(RegisterDriverHandler != NULL);

    if (RegisterDriverHandler == NULL)
    {
        DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("Enum1394Callback: Callback called with invalid Characteristics. Characteristics %lx\n", Characteristics));
        return;     
    }
    
    Status = RegisterDriverHandler(&NdisEnum1394Characteristics);
    
    if (Status == STATUS_SUCCESS)
    {
        AddNodeHandler = ((PNIC1394_CHARACTERISTICS)Characteristics)->AddNodeHandler;
        RemoveNodeHandler = ((PNIC1394_CHARACTERISTICS)Characteristics)->RemoveNodeHandler;
        DeRegisterDriverHandler = ((PNIC1394_CHARACTERISTICS)Characteristics)->DeRegisterDriverHandler;
    }
    else
    {
        DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("Enum1394Callback: RegisterDriverHandler failed: Status %lx\n", Status));
        RegisterDriverHandler = NULL;
    }
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==Enum1394Callback: Source,  %lx\n", Source));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\arp\sys\util.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Utility functions for ARP1394.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     01-05-99    Created

Notes:

--*/
#include <precomp.h>




//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_UT


//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

VOID
arpTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );



//
// TODO: make these globals constant data.
//


// ArpTasks_StaticInfo contains static information about
// objects of type  ARP1394_TASK;
//
RM_STATIC_OBJECT_INFO
ArpTasks_StaticInfo = 
{
    0, // TypeUID
    0, // TypeFlags
    "ARP1394 Task", // TypeName
    0, // Timeout

    NULL, // pfnCreate
    arpTaskDelete, // pfnDelete
    NULL,   // LockVerifier

    0,   // length of resource table
    NULL // Resource Table
};



VOID
arpTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free an object of type ARP1394_TASK.

Arguments:

    pHdr    - Actually a pointer to the ARP1394_TASK to be deleted.

--*/
{
    TASK_BACKUP* pTask= (TASK_BACKUP*)pObj;

    if (CHECK_TASK_IS_BACKUP(&pTask->Hdr) == TRUE)
    {
        arpReturnBackupTask((ARP1394_TASK*)pTask);
    }
    else
    {
        ARP_FREE(pObj);
    }
}


VOID
arpObjectDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free an unspecified object owned by the ARP module.

Arguments:

    pHdr    - Object to be freed.

--*/
{
    ARP_FREE(pObj);
}


VOID
arpAdapterDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free an object of type ARP1394_ADAPTER.

Arguments:

    pHdr    - Actually a pointer to the ARP1394_ADAPTER to be deleted.

--*/
{
    ARP1394_ADAPTER * pA = (ARP1394_ADAPTER *) pObj;

    if (pA->bind.DeviceName.Buffer != NULL)
    {
        ARP_FREE(pA->bind.DeviceName.Buffer);
    }

    if (pA->bind.ConfigName.Buffer != NULL)
    {
        ARP_FREE(pA->bind.ConfigName.Buffer);
    }

    if (pA->bind.IpConfigString.Buffer != NULL)
    {
        ARP_FREE(pA->bind.IpConfigString.Buffer);
    }

    ARP_FREE(pA);
}

NDIS_STATUS
arpAllocateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription, OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Allocates and initializes a task of subtype ARP1394_TASK.

Arguments:

    pParentObject       - Object that is to be the parent of the allocated task.
    pfnHandler          - The task handler for the task.
    Timeout             - Unused.
    szDescription       - Text describing this task.
    ppTask              - Place to store pointer to the new task.

Return Value:

    NDIS_STATUS_SUCCESS if we could allocate and initialize the task.
    NDIS_STATUS_RESOURCES otherwise
--*/
{
    ARP1394_TASK *pATask;
    NDIS_STATUS Status;
    BOOLEAN fBackupTask = FALSE;

    ARP_ALLOCSTRUCT(pATask, MTAG_TASK); // TODO use lookaside lists.

    if (pATask == NULL)
    {   
        pATask = arpGetBackupTask(&ArpGlobals);
        fBackupTask = TRUE;
    }
        
    *ppTask = NULL;

    if (pATask != NULL)
    {
        ARP_ZEROSTRUCT(pATask);

        RmInitializeTask(
                &(pATask->TskHdr),
                pParentObject,
                pfnHandler,
                &ArpTasks_StaticInfo,
                szDescription,
                Timeout,
                pSR
                );
        *ppTask = &(pATask->TskHdr);
        Status = NDIS_STATUS_SUCCESS;

        if (fBackupTask  == TRUE)
        {
            MARK_TASK_AS_BACKUP(&pATask->TskHdr);
        }
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }


    return Status;
}


NDIS_STATUS
arpCopyUnicodeString(
        OUT         PNDIS_STRING pDest,
        IN          PNDIS_STRING pSrc,
        BOOLEAN     fUpCase
        )
/*++

Routine Description:

    Copy the contents of unicode string pSrc into pDest.
    pDest->Buffer is allocated using NdisAllocateMemoryWithTag; Caller is
    responsible for freeing it.

    EXTRA EXTRA EXTRA:
        This make sure the destination is NULL terminated.
        IPAddInterface expects the Unicode string passed in to be
        NULL terminated.

    NOTE: fUpCase is ignored.

Return Value:

    NDIS_STATUS_SUCCESS on success;
    NDIS failure status on failure.
--*/
{
    USHORT Length = pSrc->Length;
    PWCHAR pwStr;
    NdisAllocateMemoryWithTag(&pwStr, Length+sizeof(WCHAR), MTAG_STRING);
    ARP_ZEROSTRUCT(pDest);

    if  (pwStr == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }
    else
    {
        pDest->Length = Length;
        pDest->MaximumLength = Length+sizeof(WCHAR);

        pDest->Buffer = pwStr;

        // We-- ignore the copy flag.
        // For some reason, we're not in passive, and moreover 
        // NdisUpcaseUnicode doesn't work.
        //
        if (0 && fUpCase)
        {
        #if !MILLEN

            ASSERT_PASSIVE();
            NdisUpcaseUnicodeString(pDest, pSrc);
        #endif // !MILLEN
        }
        else
        {
            NdisMoveMemory(pwStr, pSrc->Buffer, Length);
            if (Length & 0x1)
            {
                ((PUCHAR)pwStr)[Length] = 0;
            }
            else
            {
                pwStr[Length/sizeof(*pwStr)] = 0;
            }
        }

        return NDIS_STATUS_SUCCESS;
    }
}

VOID
arpSetPrimaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpSetPrimaryIfTask", 0x535f8cd4)
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    ASSERT(pIF->pPrimaryTask==NULL);

#if DBG
    // Veriy that this is a valid primary task. Also verify that PrimaryState
    // is a valid primary state.
    //
    {
        PFN_RM_TASK_HANDLER pfn = pTask->pfnHandler;
        ASSERT(
            ((pfn == arpTaskInitInterface) && (PrimaryState == ARPIF_PS_INITING))
        || ((pfn == arpTaskDeinitInterface) && (PrimaryState == ARPIF_PS_DEINITING))
        || ((pfn == arpTaskReinitInterface) && (PrimaryState == ARPIF_PS_REINITING))
        || ((pfn == arpTaskLowPower) && (PrimaryState == ARPIF_PS_LOW_POWER))
            );
    }
#endif // DBG

    //
    // Although it's tempting to put pTask as entity1 and pRask->Hdr.szDescption as
    // entity2 below, we specify NULL for both so that we can be sure that ONLY one
    // primary task can be active at any one time.
    //
    DBG_ADDASSOC(
        &pIF->Hdr,
        NULL,                           // Entity1
        NULL,                           // Entity2
        ARPASSOC_PRIMARY_IF_TASK,
        "   Primary task\n",
        pSR
        );

    pIF->pPrimaryTask = pTask;
    SET_IF_PRIMARY_STATE(pIF, PrimaryState);

    EXIT()
}


VOID
arpClearPrimaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpClearPrimaryIfTask", 0x10ebb0c3)

    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);
    ASSERT(pIF->pPrimaryTask==pTask);

    // Veriy that PrimaryState is a valid primary state.
    //
    ASSERT(
            (PrimaryState == ARPIF_PS_INITED)
        ||  (PrimaryState == ARPIF_PS_FAILEDINIT)
        ||  (PrimaryState == ARPIF_PS_DEINITED)
        );

    // Delete the association added when setting the primary IF task
    //
    DBG_DELASSOC(
        &pIF->Hdr,
        NULL,
        NULL,
        ARPASSOC_PRIMARY_IF_TASK,
        pSR
        );

    pIF->pPrimaryTask = NULL;
    SET_IF_PRIMARY_STATE(pIF, PrimaryState);

    EXIT()
}


VOID
arpSetSecondaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpSetSecondaryIfTask", 0xf7e925d1)
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    if (pIF->pActDeactTask != NULL)
    {
        ASSERT(FALSE);
        return;                                     // EARLY RETURN
    }

#if DBG
    // Veriy that this is a valid act/deact task. Also verify that SecondaryState
    // is a valid state.
    //
    {
        PFN_RM_TASK_HANDLER pfn = pTask->pfnHandler;
        ASSERT(
   ((pfn == arpTaskActivateInterface) && (SecondaryState == ARPIF_AS_ACTIVATING))
|| ((pfn == arpTaskDeactivateInterface) && (SecondaryState == ARPIF_AS_DEACTIVATING))
            );
    }
#endif // DBG

    //
    // Although it's tempting to put pTask as entity1 and pRask->Hdr.szDescption as
    // entity2 below, we specify NULL for both so that we can be sure that ONLY one
    // primary task can be active at any one time.
    //
    DBG_ADDASSOC(
        &pIF->Hdr,
        NULL,                           // Entity1
        NULL,                           // Entity2
        ARPASSOC_ACTDEACT_IF_TASK,
        "   ActDeact task\n",
        pSR
        );

    pIF->pActDeactTask = pTask;
    SET_IF_ACTIVE_STATE(pIF, SecondaryState);

    EXIT()
}


VOID
arpClearSecondaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpClearSecondaryIfTask", 0x2068f420)
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    if (pIF->pActDeactTask != pTask)
    {
        ASSERT(FALSE);
        return;                                     // EARLY RETURN
    }

    // Veriy that SecondaryState is a valid primary state.
    //
    ASSERT(
            (SecondaryState == ARPIF_AS_ACTIVATED)
        ||  (SecondaryState == ARPIF_AS_FAILEDACTIVATE)
        ||  (SecondaryState == ARPIF_AS_DEACTIVATED)
        );

    // Delete the association added when setting the primary IF task
    //
    DBG_DELASSOC(
        &pIF->Hdr,
        NULL,
        NULL,
        ARPASSOC_ACTDEACT_IF_TASK,
        pSR
        );

    pIF->pActDeactTask = NULL;
    SET_IF_ACTIVE_STATE(pIF, SecondaryState);

    EXIT()
}


VOID
arpSetPrimaryAdapterTask(
    PARP1394_ADAPTER pAdapter,          // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpSetPrimaryAdapterTask", 0x535f8cd4)
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    ASSERT(pAdapter->bind.pPrimaryTask==NULL);

#if DBG
    // Veriy that this is a valid primary task. Also verify that PrimaryState
    // is a valid primary state.
    //
    {
        PFN_RM_TASK_HANDLER pfn = pTask->pfnHandler;
        ASSERT(
            ((pfn == arpTaskInitializeAdapter) && (PrimaryState == ARPAD_PS_INITING))
        || ((pfn == arpTaskShutdownAdapter) && (PrimaryState == ARPAD_PS_DEINITING))
        || (pfn == arpTaskLowPower) || ( pfn == arpTaskOnPower) 
            );
    }
#endif // DBG

    //
    // Although it's tempting to put pTask as entity1 and pRask->Hdr.szDescption as
    // entity2 below, we specify NULL for both so that we can be sure that ONLY one
    // primary task can be active at any one time.
    //
    DBG_ADDASSOC(
        &pAdapter->Hdr,
        NULL,                           // Entity1
        NULL,                           // Entity2
        ARPASSOC_PRIMARY_AD_TASK,
        "   Primary task\n",
        pSR
        );

    pAdapter->bind.pPrimaryTask = pTask;
    SET_AD_PRIMARY_STATE(pAdapter, PrimaryState);

    EXIT()
}


VOID
arpClearPrimaryAdapterTask(
    PARP1394_ADAPTER pAdapter,          // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpClearPrimaryAdapterTask", 0x9062b2ab)

    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);
    ASSERT(pAdapter->bind.pPrimaryTask==pTask);

    // Veriy that PrimaryState is a valid primary state.
    //
    ASSERT(
            (PrimaryState == ARPAD_PS_INITED)
        ||  (PrimaryState == ARPAD_PS_FAILEDINIT)
        ||  (PrimaryState == ARPAD_PS_DEINITED)
        );

    // Delete the association added when setting the primary IF task
    //
    DBG_DELASSOC(
        &pAdapter->Hdr,
        NULL,
        NULL,
        ARPASSOC_PRIMARY_AD_TASK,
        pSR
        );

    pAdapter->bind.pPrimaryTask = NULL;
    SET_AD_PRIMARY_STATE(pAdapter, PrimaryState);

    EXIT()
}


VOID
arpSetSecondaryAdapterTask(
    PARP1394_ADAPTER pAdapter,          // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpSetSecondaryAdapterTask", 0x95dae9ac)
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    if (pAdapter->bind.pSecondaryTask != NULL)
    {
        ASSERT(FALSE);
        return;                                     // EARLY RETURN
    }

#if DBG
    // Veriy that this is a valid act/deact task. Also verify that SecondaryState
    // is a valid state.
    //
    {
        PFN_RM_TASK_HANDLER pfn = pTask->pfnHandler;
        ASSERT(
   ((pfn == arpTaskActivateAdapter) && (SecondaryState == ARPAD_AS_ACTIVATING))
|| ((pfn == arpTaskDeactivateAdapter) && (SecondaryState == ARPAD_AS_DEACTIVATING))
            );
    }
#endif // DBG

    //
    // Although it's tempting to put pTask as entity1 and pRask->Hdr.szDescption as
    // entity2 below, we specify NULL for both so that we can be sure that ONLY one
    // primary task can be active at any one time.
    //
    DBG_ADDASSOC(
        &pAdapter->Hdr,
        NULL,                           // Entity1
        NULL,                           // Entity2
        ARPASSOC_ACTDEACT_AD_TASK,
        "   Secondary task\n",
        pSR
        );

    pAdapter->bind.pSecondaryTask = pTask;
    SET_AD_ACTIVE_STATE(pAdapter, SecondaryState);

    EXIT()
}


VOID
arpClearSecondaryAdapterTask(
    PARP1394_ADAPTER pAdapter,          // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpClearSecondaryAdapterTask", 0xc876742b)
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    if (pAdapter->bind.pSecondaryTask != pTask)
    {
        ASSERT(FALSE);
        return;                                     // EARLY RETURN
    }

    // Veriy that SecondaryState is a valid primary state.
    //
    ASSERT(
            (SecondaryState == ARPAD_AS_ACTIVATED)
        ||  (SecondaryState == ARPAD_AS_FAILEDACTIVATE)
        ||  (SecondaryState == ARPAD_AS_DEACTIVATED)
        );

    // Delete the association added when setting the primary IF task
    //
    DBG_DELASSOC(
        &pAdapter->Hdr,
        NULL,
        NULL,
        ARPASSOC_ACTDEACT_AD_TASK,
        pSR
        );

    pAdapter->bind.pSecondaryTask = NULL;
    SET_AD_ACTIVE_STATE(pAdapter, SecondaryState);

    EXIT()
}

#if 0
NDIS_STATUS
arpCopyAnsiStringToUnicodeString(
        OUT         PNDIS_STRING pDest,
        IN          PANSI_STRING pSrc
        )
/*++

Routine Description:

    Converts pSrc into unicode and sets up pDest with the it.
    pDest->Buffer is allocated using NdisAllocateMemoryWithTag; Caller is
    responsible for freeing it.

Return Value:

    NDIS_STATUS_SUCCESS on success;
    NDIS_STATUS_RESOURCES on failure.
--*/
{

    UINT Size;
    PWCHAR pwStr;
    Size = sizeof(WCHAR) * pSrc->MaximumLength;
    NdisAllocateMemoryWithTag(&pwStr, Size, MTAG_STRING);

    ARP_ZEROSTRUCT(pDest);

    if  (pwStr == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }
    else
    {
        pDest->MaximumLength = Size;
        pDest->Buffer = pwStr;
        NdisAnsiStringToUnicodeString(pDest, pSrc);
        return NDIS_STATUS_SUCCESS;
    }
}


NDIS_STATUS
arpCopyUnicodeStringToAnsiString(
        OUT         PANSI_STRING pDest,
        IN          PNDIS_STRING pSrc
        )
/*++

Routine Description:

    Converts pSrc into ansi and sets up pDest with the it.
    pDest->Buffer is allocated using NdisAllocateMemoryWithTag; Caller is
    responsible for freeing it.

Return Value:

    NDIS_STATUS_SUCCESS on success;
    NDIS_STATUS_RESOURCES on failure.
--*/
{

    UINT Size;
    PCHAR pStr;
    Size = pSrc->MaximumLength/sizeof(WCHAR) + sizeof(WCHAR);
    NdisAllocateMemoryWithTag(&pStr, Size, MTAG_STRING);

    ARP_ZEROSTRUCT(pDest);

    if  (pStr == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }
    else
    {
        pDest->Buffer = pStr;
        NdisUnicodeStringToAnsiString(pDest, pSrc);
        pStr[pDest->Length] = 0;
        pDest->MaximumLength = Size; // Must be done AFTER call to
                                     // NdisUnicodeStringToAnsiString, which
                                     // sets MaximumLength to Length;
        return NDIS_STATUS_SUCCESS;
    }
}
#endif // 0


UINT
arpGetSystemTime(VOID)
/*++
    Returns system time in seconds.

    Since it's in seconds, we won't overflow unless the system has been up for over
    a  100 years :-)
--*/
{
    LARGE_INTEGER Time;
    NdisGetCurrentSystemTime(&Time);
    Time.QuadPart /= 10000000;          //10-nanoseconds to seconds.

    return Time.LowPart;
}

#if ARP_DO_TIMESTAMPS

void
arpTimeStamp(
    char *szFormatString,
    UINT Val
    )
{
    UINT Minutes;
    UINT Seconds;
    UINT Milliseconds;
    LARGE_INTEGER Time;
    NdisGetCurrentSystemTime(&Time);
    Time.QuadPart /= 10000;         //10-nanoseconds to milliseconds.
    Milliseconds = Time.LowPart; // don't care about highpart.
    Seconds = Milliseconds/1000;
    Milliseconds %= 1000;
    Minutes = Seconds/60;
    Seconds %= 60;


    DbgPrint( szFormatString, Minutes, Seconds, Milliseconds, Val);
}


#endif // ARP_DO_TIMESTAMPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\inc\a13ioctl.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

    This file contains the ioctl declarations for ARP1394, the IEEE1394 ARP module.

Environment:

    Kernel mode

Revision History:

    11/20/1998 JosephJ Created
    04/10/1999 JosephJ Defined structures to get/set info.

--*/

#ifndef _ARP1394_IOCTL_
#define _ARP1394_IOCTL_

#define ARP_CLIENT_DOS_DEVICE_NAME      L"\\\\.\\ARP1394"

#define ARP_IOCTL_CLIENT_OPERATION      CTL_CODE(FILE_DEVICE_NETWORK, 100, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Current version. To rev the version, increment the 2nd number in the
// expression. The 1st number is a random 32-bit number.
//
#define ARP1394_IOCTL_VERSION (0x1ac86e68+3)


// Common header.
//
typedef struct
{
    // Set version to ARP1394_IOCTL_VERSION
    //
    ULONG Version;

    // IP address (in network byte order) of interface this request applies to.
    // (All-zeros == use default).
    //
    ULONG               IfIpAddress;

    // Operation code. Each operation code is associated with
    // a structure relevant to the operation.
    //
    enum
    {
        // Display all ARP entries
        // Associated struct: ARP1394_IOCTL_GET_ARPCACHE
        //
        ARP1394_IOCTL_OP_GET_ARPCACHE,

        // Add a static arp entry.
        // Associated struct: ARP1394_IOCTL_ADD_ARP_ENTRY
        //
        ARP1394_IOCTL_OP_ADD_STATIC_ENTRY,

        // Delete a static arp entry.
        // Associated struct: ARP1394_IOCTL_DEL_ARP_ENTRY
        //
        ARP1394_IOCTL_OP_DEL_STATIC_ENTRY,

        // Purge all DYNAMIC arp cache entries.
        //
        ARP1394_IOCTL_OP_PURGE_ARPCACHE,

        // Get packet statistics.
        // Associated struct: ARP1394_IOCTL_GET_PACKET_STATS
        //
        ARP1394_IOCTL_OP_GET_PACKET_STATS,

        // Get task statistics.
        // Associated struct: ARP1394_IOCTL_GET_TASK_STATS
        //
        ARP1394_IOCTL_OP_GET_TASK_STATS,

        // Get arp table statistics.
        // Associated struct: ARP1394_IOCTL_GET_ARPCACHE_STATS
        //
        ARP1394_IOCTL_OP_GET_ARPCACHE_STATS,

        // Get call statistics.
        // Associated struct: ARP1394_IOCTL_GET_CALL_STATS
        //
        ARP1394_IOCTL_OP_GET_CALL_STATS,

        // Reset statistics collection.
        //
        ARP1394_IOCTL_OP_RESET_STATS,

        // Reinit the interface (deactivate and then activate it).
        //
        ARP1394_IOCTL_OP_REINIT_INTERFACE,

        // Send a packet
        //
        ARP1394_IOCTL_OP_SEND_PACKET,

        // Receive a packet
        //
        ARP1394_IOCTL_OP_RECV_PACKET,

        // Get bus information
        //
        ARP1394_IOCTL_OP_GET_NICINFO,

        // Get MCAP-related information
        //
        ARP1394_IOCTL_OP_GET_MCAPINFO,


        
        //
        // FOLLOWING ARE FOR ETHERNET EMULATION. THESE SHOULD NOT BE
        // SUPPORTED FROM USER MODE. HOWEVER FOR TESTING PURPOSES THEY ARE
        // CURRENTLY SUPPORED FROM USER MODE
        //

        // This is a dummy op identifying the beginning of the ethernet-related
        // Ops.
        //
        ARP1394_IOCTL_OP_ETHERNET_FIRST = 0x100,

        // Start ethernet emulation on the specified adapter. We must not
        // currently be bound to this adapter.
        //
        ARP1394_IOCTL_OP_ETHERNET_START_EMULATION =
                                   ARP1394_IOCTL_OP_ETHERNET_FIRST,

        // Stop ethernet emulation on the specified adapter. We must be
        // currently using this adapter in ethernet mode.
        //
        ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION,

        // Start listening on this ethernet multicast address.
        //
        ARP1394_IOCTL_OP_ETHERNET_ADD_MULTICAST_ADDRESS,

        // Stop listening on this ethernet multicast address.
        //
        ARP1394_IOCTL_OP_ETHERNET_DEL_MULTICAST_ADDRESS,

        // Start listening on this ethernet multicast address.
        //
        ARP1394_IOCTL_OP_ETHERNET_ENABLE_PROMISCUOUS_MODE,

        // Stop listening on this ethernet multicast address.
        //
        ARP1394_IOCTL_OP_ETHERNET_DISABLE_PROMISCUOUS_MODE,

        // This is a dummy op identifying the beginning of the ethernet-related
        // Ops.
        //
        ARP1394_IOCTL_OP_ETHERNET_LAST = 
                    ARP1394_IOCTL_OP_ETHERNET_DISABLE_PROMISCUOUS_MODE,

        // This is an ioctl that returns, the Node, Euid, and Dummy Mac address
        // for the Bus
		ARP1394_IOCTL_OP_GET_EUID_NODE_MAC_TABLE
		
    } Op;

} ARP1394_IOCTL_HEADER, *PARP1394_IOCTL_HEADER;


typedef struct
{
        UINT64              UniqueID;
        ULONG               Off_Low;
        USHORT              Off_High;
    
}   ARP1394_IOCTL_HW_ADDRESS, *PARP1394_IOCTL_HW_ADDRESS;

typedef struct
{
    ARP1394_IOCTL_HW_ADDRESS    HwAddress;
    ULONG                       IpAddress;
}
ARP1394_ARP_ENTRY, *PARP1394_ARP_ENTRY;


// Structure used to get items from the arp table.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_ARPCACHE
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Local HW Address (64-bit UniqueID and FIFO offset, if any).
    //
    ARP1394_IOCTL_HW_ADDRESS    LocalHwAddress;

    // Total entries currently in the arp table.
    //
    UINT                 NumEntriesInArpCache;

    // Total number of entries avilable in THIS structure.
    //
    UINT                 NumEntriesAvailable;

    // Number of entries filled out in this structure.
    //
    UINT                 NumEntriesUsed;

    // Zero-based index of the first entry in the structure in the
    // arp table.
    //
    UINT                 Index;

    // Space for NumEntriesAvailable arp table entries.
    //
    ARP1394_ARP_ENTRY    Entries[1];
    
} ARP1394_IOCTL_GET_ARPCACHE, *PARP1394_IOCTL_GET_ARPCACHE;


// Structure used to add a single static arp entry.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_ADD_STATIC_ENTRY
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Destination HW Address.
    //
    ARP1394_IOCTL_HW_ADDRESS HwAddress;

    // Destination IP Address in network byte order
    //
    ULONG               IpAddress;

} ARP1394_IOCTL_ADD_ARP_ENTRY, *PARP1394_IOCTL_ADD_ARP_ENTRY;


// Structure used to delete a single static arp entry.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_ADD_STATIC_ENTRY
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Destination IP Address in network byte order.
    //
    ULONG                IpAddress;

} ARP1394_IOCTL_DEL_ARP_ENTRY, *PARP1394_IOCTL_DEL_ARP_ENTRY;


// Structure used to purge all DYNAMIC arp entries from the arp
// cache.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_PURGE_ARPCACHE
    //
    ARP1394_IOCTL_HEADER Hdr;

} ARP1394_IOCTL_PURGE_ARPCACHE,  *PARP1394_IOCTL_PURGE_ARPCACHE;


// Enumeration of packet size slots
//
enum
{
    ARP1394_PKTSIZE_128,    // <= 128       bytes
    ARP1394_PKTSIZE_256,    // 129 ... 256  bytes
    ARP1394_PKTSIZE_1K,     // 257 ... 1K   bytes
    ARP1394_PKTSIZE_2K,     // 1K+1 .. .2K  bytes
    ARP1394_PKTSIZE_G2K,    // > 2K         bytes

    ARP1394_NUM_PKTSIZE_SLOTS
};

// Enumeration of packet send/recv time slots
//
enum
{
    // ARP1394_PKTTIME_1US, // <= 1 microsecond
    // ARP1394_PKTTIME_100US,   // 1+ ... 100   microsecond
    ARP1394_PKTTIME_100US,  // <= 100   microsecond
    ARP1394_PKTTIME_1MS,    // 0.1+ ... 1   millisecond
    ARP1394_PKTTIME_10MS,   // 1+ ... 10    milliseconds
    ARP1394_PKTTIME_100MS,  // 10+ ...100   milliseconds
    ARP1394_PKTTIME_G100MS, // > 100        milliseconds
    // ARP1394_PKTTIME_G10MS,   // > 10         milliseconds

    ARP1394_NUM_PKTTIME_SLOTS       
};


// Enumeration of task time slots
//
enum
{
    ARP1394_TASKTIME_1MS,   // <= 1         millisecond
    ARP1394_TASKTIME_100MS, // 1+ ... 100   milliseconds
    ARP1394_TASKTIME_1S,    // 0.1+ ... 1   second
    ARP1394_TASKTIME_10S,   // 1+ ... 10    seconds
    ARP1394_TASKTIME_G10S,  // > 10         seconds

    ARP1394_NUM_TASKTIME_SLOTS      
};


// Keeps track of the packet counts for each  combination of packet-size-slot
// and packet-time-slot.
//
typedef struct
{
    // Count of successful packets
    //
    UINT GoodCounts[ARP1394_NUM_PKTSIZE_SLOTS][ARP1394_NUM_PKTTIME_SLOTS];

    // Count of unsuccessful packets
    //
    UINT BadCounts [ARP1394_NUM_PKTSIZE_SLOTS][ARP1394_NUM_PKTTIME_SLOTS];

} ARP1394_PACKET_COUNTS, *PARP1394_PACKET_COUNTS;


// Structure used to get packet stats.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_PACKET_STATS
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Duration of stats collection, in seconds.
    //
    UINT                    StatsDuration;

    //
    // Some send stats
    //
    UINT                    TotSends;
    UINT                    FastSends;
    UINT                    MediumSends;
    UINT                    SlowSends;
    UINT                    BackFills;
    UINT                    HeaderBufUses;
    UINT                    HeaderBufCacheHits;

    //
    // Some recv stats
    //
    UINT                    TotRecvs;
    UINT                    NoCopyRecvs;
    UINT                    CopyRecvs;
    UINT                    ResourceRecvs;

    //
    // Packet counts
    //
    ARP1394_PACKET_COUNTS   SendFifoCounts;
    ARP1394_PACKET_COUNTS   RecvFifoCounts;
    ARP1394_PACKET_COUNTS   SendChannelCounts;
    ARP1394_PACKET_COUNTS   RecvChannelCounts;

} ARP1394_IOCTL_GET_PACKET_STATS, *PARP1394_IOCTL_GET_PACKET_STATS;


// Structure used to get task stats.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_TASK_STATS
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Duration of stats collection, in seconds.
    //
    UINT    StatsDuration;

    UINT    TotalTasks;
    UINT    CurrentTasks;
    UINT    TimeCounts[ARP1394_NUM_TASKTIME_SLOTS];

} ARP1394_IOCTL_GET_TASK_STATS, *PARP1394_IOCTL_GET_TASK_STATS;


// Structure used to get arp table stats.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_ARPCACHE_STATS
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Duration of stats collection, in seconds.
    //
    UINT    StatsDuration;

    UINT    TotalQueries;
    UINT    SuccessfulQueries;
    UINT    FailedQueries;
    UINT    TotalResponses;
    UINT    TotalLookups;
    UINT    TraverseRatio;

} ARP1394_IOCTL_GET_ARPCACHE_STATS, *PARP1394_IOCTL_GET_ARPCACHE_STATS;


// Structure used to get call stats.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_CALL_STATS
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Duration of stats collection, in seconds.
    //
    UINT    StatsDuration;

    //
    // FIFO-related call stats.
    //
    UINT    TotalSendFifoMakeCalls;
    UINT    SuccessfulSendFifoMakeCalls;
    UINT    FailedSendFifoMakeCalls;
    UINT    IncomingClosesOnSendFifos;

    //
    // Channel-related call stats.
    //
    UINT    TotalChannelMakeCalls;
    UINT    SuccessfulChannelMakeCalls;
    UINT    FailedChannelMakeCalls;
    UINT    IncomingClosesOnChannels;

} ARP1394_IOCTL_GET_CALL_STATS, *PARP1394_IOCTL_GET_CALL_STATS;


// Structure used to reset statistics.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_RESET_STATS
    //
    ARP1394_IOCTL_HEADER Hdr;

}  ARP1394_IOCTL_RESET_STATS, *PARP1394_IOCTL_RESET_STATS;


// Structure used to re-init the interface.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_REINIT_INTERFACE
    //
    ARP1394_IOCTL_HEADER Hdr;

}  ARP1394_IOCTL_REINIT_INTERFACE, *PARP1394_IOCTL_REINIT_INTERFACE;


#if 0
//
// the structure for returning basic information about the miniport.
//
typedef struct
{
    UINT64                  UniqueID;           // This node's 64-bit Unique ID.
    ULONG                   BusGeneration;      // 1394 Bus generation ID.
    USHORT                  NodeAddress;        // Local nodeID for the current bus
                                                // generation.
    USHORT                  Reserved;           // Padding.
    UINT                    MaxRecvBlockSize;   // Maximum size, in bytes, of blocks
                                                // that can be read.
    UINT                    MaxRecvSpeed;       // Max speed which can be accepted
                                                // -- minimum
                                                // of the max local link speed and
                                                // the max local PHY speed.

} ARP1394_IOCTL_LOCAL_NODE_INFO, *PARP1394_IOCTL_LOCAL_NODE_INFO;


//
// the structure for returning basic information about a remote node.
//
typedef struct
{
    UINT64                  UniqueID;           // This node's 64-bit Unique ID.
    USHORT                  NodeAddress;        // Local nodeID for the current bus
                                                // generation.
    USHORT                  Reserved;           // Padding.
    UINT                    MaxRecvBlockSize;   // Maximum size, in bytes, of blocks
                                                // that can be read.
    UINT                    MaxRecvSpeed;       // Max speed which can be accepted
                                                // -- minimum
                                                // of the max local link speed and
                                                // the max local PHY speed.
    UINT                    MaxSpeedBetweenNodes;// Max speed which can be accepted
    UINT                    Flags;  // One or more  ARP1394_IOCTL_REMOTEFLAGS_* consts

        #define ARP1394_IOCTL_REMOTEFLAGS_ACTIVE        (0x1<<0)
        #define ARP1394_IOCTL_REMOTEFLAGS_LOADING       (0x1<<1)
        #define ARP1394_IOCTL_REMOTEFLAGS_UNLOADING     (0x1<<2)


#if 0   // later
    //
    // Following numbers are since the last bus reset.
    //
    UINT                    NumFifoPktsSent;
    UINT                    NumFifoPktsReceived;
    UINT                    NumChannelPktsReceived;
    UINT                    NumFifoSendFailures;
    UINT                    NumFifoReceiveDiscards;
    UINT                    NumChannelPktsReceived;
    UINT64                  NumFifoBytesSent;
    UINT64                  NumChannelBytesSent;
    UINT64                  NumFifoBytesReceived;
    UINT64                  NumChannelBytesReceived;
#endif // 0

} ARP1394_IOCTL_REMOTE_NODE_INFO, *PARP1394_IOCTL_REMOTE_NODE_INFO;

typedef struct
{
    UINT    NumPacketsSent;
    UINT    NumPacketsReceived;
#if 0   // later
    UINT    NumSendFailures;
    UINT    NumReceiveDiscards;
    UINT64  NumBytesSent;
    UINT64  NumBytesReceived;
#endif // 0

} ARP1394_IOCTL_CHANNEL_INFO, *PARP1394_IOCTL_CHANNEL_INFO;
#endif // 0

#define ARP1394_IOCTL_MAX_BUSINFO_NODES     64
#define ARP1394_IOCTL_MAX_BUSINFO_CHANNELS  64
#define ARP1394_IOCTL_MAX_PACKET_SIZE       1000

typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_NICINFO
    //
    ARP1394_IOCTL_HEADER Hdr;

    // NIC information (defined in nic1394.h)
    //
    NIC1394_NICINFO      Info;

#if 0
    UINT    Version;
    UINT    ChannelMapLow;      // LSB bit == channel 0
    UINT    ChannelMapHigh;     // MSB bit == channel 63
    UINT    NumBusResets;
    UINT    SecondsSinceLastBusReset;
    UINT    NumRemoteNodes;
    ARP1394_IOCTL_LOCAL_NODE_INFO   LocalNodeInfo;
    ARP1394_IOCTL_REMOTE_NODE_INFO  RemoteNodeInfo[ARP1394_IOCTL_MAX_BUSINFO_NODES];
    ARP1394_IOCTL_CHANNEL_INFO      ChannelInfo[ARP1394_IOCTL_MAX_BUSINFO_CHANNELS];
#endif
    
    
} ARP1394_IOCTL_NICINFO, *PARP1394_IOCTL_NICINFO;


typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_SEND_PACKET
    //
    ARP1394_IOCTL_HEADER Hdr;

    UINT  PacketSize;
    UCHAR Data[ARP1394_IOCTL_MAX_PACKET_SIZE];
    
} ARP1394_IOCTL_SEND_PACKET, *PARP1394_IOCTL_SEND_PACKET;

typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_RECV_PACKET
    //
    ARP1394_IOCTL_HEADER Hdr;

    UINT  PacketSize;
    UCHAR Data[ARP1394_IOCTL_MAX_PACKET_SIZE];
    
} ARP1394_IOCTL_RECV_PACKET, *PARP1394_IOCTL_RECV_PACKET;

typedef struct
{
    // Channel number.
    //
    UINT            Channel;

    // IP multicast group address bound to this channel.
    //
    ULONG           GroupAddress;

    // Absolute time at which this information was updated,
    // in seconds.
    //
    UINT            UpdateTime;

    // Absolute time at which this mapping will expire.
    // In seconds.
    //
    UINT            ExpieryTime;

    UINT            SpeedCode;

    // Status
    //
    UINT            Flags;  // One of the ARP1394_IOCTL_MCIFLAGS_*
    #define ARP1394_IOCTL_MCIFLAGS_ALLOCATED 0x1

    // NodeID of owner of this channel.
    //
    UINT            NodeId;

} ARP1394_IOCTL_MCAP_CHANNEL_INFO;

// Structure used to get MCAP-related info.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_MCAPINFO
    //
    ARP1394_IOCTL_HEADER Hdr;

    


    // Number of entries filled out in this structure.
    //
    UINT                 NumEntries;

    // Space for NumEntriesAvailable arp table entries.
    //
    ARP1394_IOCTL_MCAP_CHANNEL_INFO
                Entries[ARP1394_IOCTL_MAX_BUSINFO_CHANNELS];
                        
    
} ARP1394_IOCTL_GET_MCAPINFO, *PARP1394_IOCTL_GET_MCAPINFO;


typedef struct
{
    // Hdr.Op must be set to  one of
    //  ARP1394_IOCTL_OP_ETHERNET_START_EMULATION
    //  ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION
    //  ARP1394_IOCTL_OP_ETHERNET_ADD_MULTICAST_ADDRESS
    //  ARP1394_IOCTL_OP_ETHERNET_DEL_MULTICAST_ADDRESS
    //  ARP1394_IOCTL_OP_ETHERNET_ENABLE_PROMISCUOUS_MODE
    //  ARP1394_IOCTL_OP_ETHERNET_DISABLE_PROMISCUOUS_MODE
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Null-terminated NDIS Adapter name
    //
    #define ARP1394_MAX_ADAPTER_NAME_LENGTH 128
    WCHAR AdapterName[ARP1394_MAX_ADAPTER_NAME_LENGTH+1];


    // Flags. Reserved for future use.
    //
    UINT        Flags;

    // Ethernet MAC address. Usage as follows:
    //
    //  ARP1394_IOCTL_OP_ETHERNET_ADD_MULTICAST_ADDRESS: Multicast address
    //  ARP1394_IOCTL_OP_ETHERNET_DEL_MULTICAST_ADDRESS: Multicast address
    //
    // Unused for other operations.
    //
    UCHAR       MacAddress[6];

} ARP1394_IOCTL_ETHERNET_NOTIFICATION, *PARP1394_IOCTL_ETHERNET_NOTIFICATION;


typedef struct
{

    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_EUID_NODE_MAC_TABLE
    //
    ARP1394_IOCTL_HEADER Hdr;

	//
	//This contains the Topology

	EUID_TOPOLOGY Map;


} ARP1394_IOCTL_EUID_NODE_MAC_INFO, *PARP1394_IOCTL_EUID_NODE_MAC_INFO;

typedef union
{
    ARP1394_IOCTL_HEADER                Hdr;
    ARP1394_IOCTL_GET_ARPCACHE          GetArpCache;
    ARP1394_IOCTL_ADD_ARP_ENTRY         AddArpEntry;
    ARP1394_IOCTL_DEL_ARP_ENTRY         DelArpEntry;
    ARP1394_IOCTL_PURGE_ARPCACHE        PurgeArpCache;
    ARP1394_IOCTL_GET_PACKET_STATS      GetPktStats;
    ARP1394_IOCTL_GET_TASK_STATS        GetTaskStats;
    ARP1394_IOCTL_GET_ARPCACHE_STATS    GetArpStats;
    ARP1394_IOCTL_GET_CALL_STATS        GetCallStats;
    ARP1394_IOCTL_RESET_STATS           ResetStats;
    ARP1394_IOCTL_REINIT_INTERFACE      ReinitInterface;
    ARP1394_IOCTL_NICINFO               IoctlNicInfo;
    ARP1394_IOCTL_SEND_PACKET           SendPacket;
    ARP1394_IOCTL_RECV_PACKET           RecvPacket;
    ARP1394_IOCTL_ETHERNET_NOTIFICATION EthernetNotification;
    ARP1394_IOCTL_EUID_NODE_MAC_INFO   EuidNodeMacInfo;				

} ARP1394_IOCTL_COMMAND, *PARP1394_IOCTL_COMMAND;


#endif  // _ARP1394_IOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\inf\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v 

$(O)\enum1394.inf: $(_INX)\enum1394.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)


$(O)\net1394.inf: $(_INX)\net1394.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\inc\ndis1394.h ===
//
// notification codes
//

#ifndef _NDIS1394_
#define _NDIS1394_


#ifndef EXPORT
#ifdef _NDIS1394ENUM_
#define EXPORT
#else
#define EXPORT DECLSPEC_IMPORT
#endif
#endif


#define NDIS1394_CALLBACK_NAME		L"\\Callback\\Ndis1394CallbackObject"


#define NDIS1394_CALLBACK_SOURCE_ENUM1394		0
#define NDIS1394_CALLBACK_SOURCE_NIC1394		1

typedef struct _NIC1394_CHARACTERISTICS *PNIC1394_CHARACTERISTICS;
typedef struct _NDISENUM1394_CHARACTERISTICS *PNDISENUM1394_CHARACTERISTICS;

typedef
NTSTATUS
(*ENUM1394_REGISTER_DRIVER_HANDLER)(
	IN	PNIC1394_CHARACTERISTICS	Characteristics
	);

typedef
VOID
(*ENUM1394_DEREGISTER_DRIVER_HANDLER)(
	VOID
	);

typedef
NTSTATUS
(*ENUM1394_REGISTER_ADAPTER_HANDLER)(
	IN	PVOID					Nic1394AdapterContext,
	IN	PDEVICE_OBJECT			PhysicalDeviceObject,
	OUT	PVOID*					pEnum1394AdapterHandle,
	OUT	PLARGE_INTEGER			pLocalHostUniqueId
	);


typedef
VOID
(*ENUM1394_DEREGISTER_ADAPTER_HANDLER)(
	IN	PVOID					Enum1394AdapterHandle
	);

typedef struct _NDISENUM1394_CHARACTERISTICS
{
	UCHAR								MajorVersion;
	UCHAR								MinorVersion;
	USHORT								Filler;
	ENUM1394_REGISTER_DRIVER_HANDLER	RegisterDriverHandler;
	ENUM1394_DEREGISTER_DRIVER_HANDLER	DeregisterDriverHandler;
	ENUM1394_REGISTER_ADAPTER_HANDLER	RegisterAdapterHandler;
	ENUM1394_DEREGISTER_ADAPTER_HANDLER	DeregisterAdapterHandler;
} NDISENUM1394_CHARACTERISTICS, *PNDISENUM1394_CHARACTERISTICS;

typedef
NTSTATUS
(*NIC1394_REGISTER_DRIVER_HANDLER)(
	IN	PNDISENUM1394_CHARACTERISTICS	Characteristics
	);

typedef
VOID
(*NIC1394_DEREGISTER_DRIVER_HANDLER)(
	VOID
	);

typedef
NTSTATUS
(*NIC1394_ADD_NODE_HANLDER)(
	IN	PVOID					Nic1394AdapterContext,	// Nic1394 handle for the local host adapter
	IN	PVOID					Enum1394NodeHandle,		// Enum1394 handle for the remote node		
	IN	PDEVICE_OBJECT			PhysicalDeviceObject,	// physical device object for the remote node
	IN	ULONG					UniqueId0,				// unique ID Low for the remote node
	IN	ULONG					UniqueId1,				// unique ID High for the remote node
	OUT	PVOID *					pNic1394NodeContext		// Nic1394 context for the remote node
	);

typedef
NTSTATUS
(*NIC1394_REMOVE_NODE_HANLDER)(
	IN	PVOID					Nic1394NodeContext		// Nic1394 context for the remote node
	);

typedef struct _NIC1394_CHARACTERISTICS
{
	UCHAR								MajorVersion;
	UCHAR								MinorVersion;
	USHORT								Filler;
	NIC1394_REGISTER_DRIVER_HANDLER		RegisterDriverHandler;
	NIC1394_DEREGISTER_DRIVER_HANDLER	DeRegisterDriverHandler;
	NIC1394_ADD_NODE_HANLDER			AddNodeHandler;
	NIC1394_REMOVE_NODE_HANLDER			RemoveNodeHandler;
} NIC1394_CHARACTERISTICS, *PNIC1394_CHARACTERISTICS;

#endif // _NDIS1394_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\enum\sys\enum1394.h ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    1394enum.h

Abstract:

    Definitions for 1394 Ndis enumerator

Author:

    Alireza Dabagh (alid) Nov 98

Environment:

    Kernel mode only

Revision History:


--*/


#ifndef _NDISENUM1394_
#define _NDISENUM1394_

typedef struct _NDISENUM1394_LOCAL_HOST     NDISENUM1394_LOCAL_HOST,*PNDISENUM1394_LOCAL_HOST;
typedef struct _NDISENUM1394_REMOTE_NODE    NDISENUM1394_REMOTE_NODE,*PNDISENUM1394_REMOTE_NODE;

//
// flags for LocalHost->Flags
//
#define     NDISENUM1394_LOCALHOST_REGISTERED       0x00000001

//
// flags for RemoteNode->Flags
//
#define     NDISENUM1394_NODE_INDICATED             0x00000001
#define     NDISENUM1394_NODE_ADDED                 0x00000002
#define     NDISENUM1394_NODE_PNP_STARTED           0x00000004
#define     NDISENUM1394_NODE_PNP_REMOVED           0x00000008


#define     NDISENUM1394_TAG_LOCAL_HOST     'hl4N'
#define     NDISENUM1394_TAG_WORK_ITEM      'iw4N'
#define     NDISENUM1394_TAG_IRB            'br4N'
#define     NDISENUM1394_TAG_DEVICE_NAME    'nd4N'
#define     NDISENUM1394_TAG_1394API_REQ    'qr4N'
#define     NDISENUM1394_TAG_DEFAULT        '  4N'

#define ENUM_SET_FLAG(_M, _F)           ((_M)->Flags |= (_F))
#define ENUM_CLEAR_FLAG(_M, _F)         ((_M)->Flags &= ~(_F))
#define ENUM_TEST_FLAG(_M, _F)          (((_M)->Flags & (_F)) != 0)
#define ENUM_TEST_FLAGS(_M, _F)         (((_M)->Flags & (_F)) == (_F))


typedef enum _NDIS_PNP_DEVICE_STATE
{
    PnPDeviceAdded,
    PnPDeviceStarted,
    PnPDeviceQueryStopped,
    PnPDeviceStopped,
    PnPDeviceQueryRemoved,
    PnPDeviceRemoved,
    PnPDeviceSurpriseRemoved
} NDIS_PNP_DEVICE_STATE;

typedef enum _NDISENUM1394_PNP_OP
{
    NdisEnum1394_StopDevice,
    NdisEnum1394_RemoveDevice,
    NdisEnum1394_SurpriseRemoveDevice,
    
    
} NDISENUM1394_PNP_OP, *PNDISENUM1394_PNP_OP;


//
// block used for references...
//
typedef struct _REFERENCE
{
    KSPIN_LOCK                  SpinLock;
    USHORT                      ReferenceCount;
    BOOLEAN                     Closing;
} REFERENCE, * PREFERENCE;

//
// one per 1394 local host. all remote 1394 controllers connected to a local host
// will be queued on this structure
//
struct _NDISENUM1394_LOCAL_HOST
{
    PNDISENUM1394_LOCAL_HOST        Next;                   // next local host node
    PVOID                           Nic1394AdapterContext;  // Nic1394 context for the local host
    LARGE_INTEGER                   UniqueId;               // unique ID for local host
    PDEVICE_OBJECT                  PhysicalDeviceObject;   // PDO created by 1394 bus
    PNDISENUM1394_REMOTE_NODE       RemoteNodeList;         // remote Nodes on local host
    KSPIN_LOCK                      Lock;
    ULONG                           Flags;
    REFERENCE                       Reference;
};


//
// one per remote node
//
struct _NDISENUM1394_REMOTE_NODE
{
    PNDISENUM1394_REMOTE_NODE       Next;
    PVOID                           Nic1394NodeContext;     // Nic1394 context for the remote node
    PDEVICE_OBJECT                  DeviceObject;
    PDEVICE_OBJECT                  NextDeviceObject;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    KSPIN_LOCK                      Lock;
    PNDISENUM1394_LOCAL_HOST        LocalHost;
    ULONG                           Flags;
    ULONG                           UniqueId[2];
    NDIS_PNP_DEVICE_STATE           PnPDeviceState;
    REFERENCE                       Reference;
};


#define INITIALIZE_EVENT(_pEvent_)          KeInitializeEvent(_pEvent_, NotificationEvent, FALSE)
#define SET_EVENT(_pEvent_)                 KeSetEvent(_pEvent_, 0, FALSE)
#define RESET_EVENT(_pEvent_)               KeResetEvent(_pEvent_)

#define WAIT_FOR_OBJECT(_O_, _TO_)          KeWaitForSingleObject(_O_,          \
                                                                  Executive,    \
                                                                  KernelMode,   \
                                                                  FALSE,        \
                                                                  _TO_)         \

#define ALLOC_FROM_POOL(_Size_, _Tag_)      ExAllocatePoolWithTag(NonPagedPool,     \
                                                                  _Size_,           \
                                                                  _Tag_)
                                                                  
#define FREE_POOL(_P_)                      ExFreePool(_P_)


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PUNICODE_STRING         RegistryPath
    );

VOID
ndisEnum1394InitializeRef(
    IN  PREFERENCE              RefP
    );
    
BOOLEAN
ndisEnum1394ReferenceRef(
    IN  PREFERENCE              RefP
    );

BOOLEAN
ndisEnum1394DereferenceRef(
    IN  PREFERENCE              RefP
    );
    
BOOLEAN
ndisEnum1394CloseRef(
    IN  PREFERENCE              RefP
    );

BOOLEAN
ndisEnum1394ReferenceLocalHost(
        IN PNDISENUM1394_LOCAL_HOST LocalHost
        );

BOOLEAN
ndisEnum1394DereferenceLocalHost(
    IN  PNDISENUM1394_LOCAL_HOST    LocalHost
    );

NTSTATUS
ndisEnum1394AddDevice(
    PDRIVER_OBJECT              DriverObject,
    PDEVICE_OBJECT              PhysicalDeviceObject
    );

NTSTATUS
ndisEnum1394PnpDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );
    
NTSTATUS
ndisEnum1394PowerDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );
    
NTSTATUS
ndisEnum1394WMIDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );

NTSTATUS
ndisEnum1394StartDevice(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );  

NTSTATUS
ndisEnum1394RemoveDevice(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                Irp,
    NDISENUM1394_PNP_OP PnpOp
    );

NTSTATUS
ndisEnum1394CreateIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );

NTSTATUS
ndisEnum1394CloseIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );
    
NTSTATUS
ndisEnum1394DeviceIoControl(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );

VOID
ndisEnum1394Unload(
    IN  PDRIVER_OBJECT          DriverObject
    );

NTSTATUS
ndisEnum1394GetLocalHostForRemoteNode(
    IN  PNDISENUM1394_REMOTE_NODE       RemoteNode,
    OUT PNDISENUM1394_LOCAL_HOST *      pLocalHost
    );
    
VOID
ndisEnum1394GetLocalHostForUniqueId(
    LARGE_INTEGER                   UniqueId,
    OUT PNDISENUM1394_LOCAL_HOST *  pLocalHost
    );
    
NTSTATUS
ndisEnum1394BusRequest(
    PDEVICE_OBJECT              DeviceObject,
    PIRB                        Irb
    );

NTSTATUS
ndisEnum1394IrpCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    );
    
NTSTATUS
ndisEnum1394PassIrpDownTheStack(
    IN  PIRP            pIrp,
    IN  PDEVICE_OBJECT  pNextDeviceObject
    );

VOID
ndisEnum1394FreeLocalHost(
    IN PNDISENUM1394_LOCAL_HOST LocalHost
    );

VOID
ndisEnum1394IndicateNodes(
    PNDISENUM1394_LOCAL_HOST    LocalHost
    );

NTSTATUS
ndisEnum1394DummyIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );

NTSTATUS
NdisEnum1394RegisterDriver(
    IN  PNIC1394_CHARACTERISTICS    Characteristics
    );

VOID
NdisEnum1394DeregisterDriver(
    VOID
    );

NTSTATUS
NdisEnum1394RegisterAdapter(
    IN  PVOID                   Nic1394AdapterContext,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject,
    OUT PVOID*                  pEnum1394AdapterHandle,
    OUT PLARGE_INTEGER          pLocalHostUniqueId
    );

VOID
NdisEnum1394DeregisterAdapter(
    IN  PVOID                   Enum1394AdapterHandle
    );

VOID
Enum1394Callback(
    PVOID   CallBackContext,
    PVOID   Source,
    PVOID   Characteristics
    );

//
// different debug level defines
//

#define ENUM1394_DBGLEVEL_NONE          0
#define ENUM1394_DBGLEVEL_ERROR         1
#define ENUM1394_DBGLEVEL_WARN          2
#define ENUM1394_DBGLEVEL_INFO          3

#if DBG
#define DBGBREAK        DbgBreakPoint
#define DbgIsNull(_Ptr)  ( ((PVOID)(_Ptr)) == NULL )

#define DBGPRINT(Level, Fmt)                                                \
    {                                                                       \
        if (Enum1394DebugLevel >= Level)                                    \
        {                                                                   \
            DbgPrint Fmt;                                                   \
        }                                                                   \
    }
    
#else
#define DBGPRINT 
#define DBGBREAK()
#define DbgIsNull(_Ptr)         FALSE
#endif


#endif      //_NDIS_1394_ENUM_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\inc\nicarp.h ===
//
// Copyright (c) 2000-2001, Microsoft Corporation, all rights reserved
//
// nicarp.h
//
// IEEE1394 mini-port/call-manager driver
//
// Decl file for structures that are common to nic1394 and arp1394
// but are private to these two modules
//
// 12/28/1998 ADube Created. 

//
// Loopback Information - Indicates to the arp module
// that a packet is a loopback packet 
//

#ifndef __NICARP_H
#define __NICARP_H

#define NIC_LOOPBACK_TAG 0x0bad0bad


typedef struct _LOOPBACK_RSVD
{
    UCHAR Mandatory[PROTOCOL_RESERVED_SIZE_IN_PACKET];

    ULONG LoopbackTag;

} LOOPBACK_RSVD, *PLOOPBACK_RSVD;



// Status Indicated by nic1394 to tell arp1394 that the bus has been reset
#define NIC1394_STATUS_BUS_RESET                     ((NDIS_STATUS)0x13940001)

// Ethernet MAC address
//
#define ARP_802_ADDR_LENGTH 6               // Length of an 802 address.
typedef  struct
{
    UCHAR  addr[ARP_802_ADDR_LENGTH];
} ENetAddr;


//
// Structure used to define the topology of the bus. 
// This is used only in the case where the bridge is present.
//


typedef struct _EUID_TUPLE
{
    // The 64 buit Unique Id of the 1394 card
    UINT64   Euid;

    // The Ethernet Mac Address associated with this 1394 card
    ENetAddr		ENetAddress;


}EUID_TUPLE, *PEUID_TUPLE;


typedef struct _EUID_TOPOLOGY
{
    //Number of remote nodes
    UINT    NumberOfRemoteNodes;

    // Have one record for each of the 64 nodes
    EUID_TUPLE Node[64];


}EUID_TOPOLOGY, *PEUID_TOPOLOGY;


//
// Structure used in parsing the Encapsulation Header
// of an IP/1394 packet
//
typedef enum _NDIS1394_FRAGMENT_LF
{
    lf_Unfragmented,
    lf_FirstFragment,
    lf_LastFragment,
    lf_InteriorFragment


} NDIS1394_FRAGMENT_LF, *PNDIS1394_FRAGMENT_LF;


typedef union _NDIS1394_UNFRAGMENTED_HEADER
{
//  NIC1394_UNFRAGMENTED_HEADER Header;

    ULONG   HeaderUlong;

    struct 
    {
            ULONG   FH_EtherType:16;
            ULONG   FH_rsv:14;
            ULONG   FH_lf:2;
    } u;

    struct 
    {
            UCHAR   fHeaderHasSourceAddress;
            UCHAR   SourceAddress;
            USHORT  EtherType;
    } u1;



} NDIS1394_UNFRAGMENTED_HEADER, *PNDIS1394_UNFRAGMENTED_HEADER;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\bcm.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// bcm.c
//
// IEEE1394 mini-port/call-manager driver
//
// Bradcast Channel Manager
//
// 07/05/99 ADube - Created - Declaration for miniport routines
//


#include <precomp.h>
#pragma hdrstop



//
// Local Prototypes
//

VOID
nicUpdateLocalHostNodeAddress (
    IN PADAPTERCB 
    );




//
// Local functions
//
VOID
nicBCMReset (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:
 Resets the Bus with the force root flag.
 Only if there are remote nodes present on the bus

Arguments:
  pAdapter

Return Value:


--*/
{
    BOOLEAN NoRemoteNodes = FALSE;

    
    TRACE( TL_T, TM_Bcm, ( "==> nicBCMReset  " ) );

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    NoRemoteNodes = IsListEmpty (&pAdapter->PDOList);
    
    ADAPTER_RELEASE_LOCK (pAdapter);


    //
    // Do not reset the bus if there are no remote nodes present
    //
    if (NoRemoteNodes == TRUE)  
    {
        return;
    }

    //
    //Reset the bus
    //
    TRACE( TL_I, TM_Bcm, ( "   RESETTING WITH FORCE ROOT") );

    nicBusReset( pAdapter , BUS_RESET_FLAGS_FORCE_ROOT);


    TRACE( TL_T, TM_Bcm, ( "<== nicBCMReset  " ) );

}


VOID
nicBCRAccessedCallback (
    IN PNOTIFICATION_INFO pNotificationInfo
    )
    // Function Description:
    //   This is the callback function invoked whenever another node
    //   tries to access the local host's BCR
    //   The value of the BCR is set elsewhere. So this function simply returns
    //
    // Arguments
    // Adapter - this is passed to the workitem
    //
    //
    // Return Value:
    //  Failure if allocation of workitem failed
    //
    
{
    UNALIGNED NETWORK_CHANNELSR*    pBCR = NULL;
    PADAPTERCB                      pAdapter = (PADAPTERCB) pNotificationInfo->Context;
    PBROADCAST_CHANNEL_DATA         pBCRData  = &pAdapter->BCRData;
    
    TRACE( TL_T, TM_Bcm, ( "==> nicBCRAccessedCallback  NotificationInfo %x", pNotificationInfo) );
    TRACE( TL_V, TM_Bcm, ( " pMdl %x", pNotificationInfo->Mdl) );
    TRACE( TL_V, TM_Bcm, ( " SourceID  %x", ((PASYNC_PACKET)pNotificationInfo->RequestPacket)->AP_Source_ID) );

    
    pBCR = (NETWORK_CHANNELSR*) NIC_GET_SYSTEM_ADDRESS_FOR_MDL(pNotificationInfo->Mdl);
    

    ASSERT (pNotificationInfo->Mdl == pAdapter->BCRData.AddressRangeContext.pMdl);

    switch (pNotificationInfo->fulNotificationOptions)
    {

        case NOTIFY_FLAGS_AFTER_READ:
        {
            TRACE( TL_V, TM_Bcm, ( " LocalHost's BCR is READ") );
                
            if ( pBCRData->Flags & BCR_ChannelAllocated)
            {
                TRACE( TL_V, TM_Bcm, ( " BCR_ChannelAllocated Flag Set ") );
            }
            else
            {
                TRACE( TL_V, TM_Bcm, ( " BCR_ChannelAllocated Flag Not Set ") );
            }
            ASSERT ( pAdapter->BCRData.LocalHostBCRBigEndian & BCR_IMPLEMENTED_BIG_ENDIAN);
            
            TRACE( TL_V, TM_Bcm, ( " pBCR %x", pBCR) );
            TRACE( TL_I, TM_Bcm, ( " BCR Accessed %x", *pBCR) );
            break;
        }

        case NOTIFY_FLAGS_AFTER_LOCK:
        {
            TRACE( TL_V, TM_Bcm, ( " LocalHost's BCR is being Locked to") );
            //
            // knowingly fall into AsyncWrite
            //
        }
        
        case NOTIFY_FLAGS_AFTER_WRITE:
        {
            ULONG LocalHostBCRLittleEndian;
            TRACE( TL_V, TM_Bcm, ( " LocalHost's BCR is being Written to") );
            
            //
            // Update local data structures.
            //
            
            LocalHostBCRLittleEndian = SWAPBYTES_ULONG (pAdapter->BCRData.LocalHostBCRBigEndian);

            pBCR = (NETWORK_CHANNELSR*)(&LocalHostBCRLittleEndian);
            TRACE( TL_V, TM_Bcm, ( " pBCR %x", pBCR) );
            TRACE( TL_V, TM_Bcm, ( " BCR %x", *pBCR) );
            
            if ( BCR_IS_VALID (pBCR) == TRUE)
            {
                ADAPTER_ACQUIRE_LOCK(pAdapter);

                pAdapter->BCRData.IRM_BCR.NC_One =1;
                pAdapter->BCRData.IRM_BCR.NC_Valid =1;
                pAdapter->BCRData.IRM_BCR.NC_Channel = pBCR->NC_Channel;
                
                BCR_SET_FLAG (pAdapter,BCR_LocalHostBCRUpdated);
                

                ADAPTER_RELEASE_LOCK(pAdapter);

                nicSetEventMakeCall(pAdapter);

                TRACE( TL_I, TM_Bcm, ( " IRM_BCR Accessed %x", pAdapter->BCRData.IRM_BCR) );

            }
            break;

        }

        default :
        {
            ASSERT (0);
            break;
        }

    }

        
    TRACE( TL_T, TM_Bcm, ( "<== nicBCRAccessedCallback NotificationInfo %x", pNotificationInfo) );
    
}




VOID
nicBCMAddRemoteNode (
    IN PADAPTERCB pAdapter,
    IN BOOLEAN fIsOnlyRemoteNode
    )
    
/*++


Routine Description:
  This is the BCM algorithm - It finds out if the local host is the IRM and goes into the appropriate code path.
  Due to network conditions, this can quietly fail if all other remedies fail

Arguments:
 pAdapter - Adapter
 Generation - Generation associated with this iteration of the algorithm

Return Value:
 None -



--*/



{
    BOOLEAN fDoBcm = FALSE;
    ULONG Generation = 0;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    TRACE( TL_T, TM_Bcm, ( "==>nicBCMAddRemoteNode pAdapter %x, fIsOnlyRemoteNode %x ", pAdapter, fIsOnlyRemoteNode  ) );


    NdisStatus = nicGetGenerationCount (pAdapter, &Generation);


    //
    // Do not schedule the BCM, if the have a valid BCR for the current generation
    //
    if (NdisStatus == NDIS_STATUS_SUCCESS &&
      (BCR_IS_VALID (&pAdapter->BCRData.IRM_BCR) == TRUE) &&
      Generation == pAdapter->Generation )
    {
        fDoBcm = FALSE;
    }
    else
    {
        fDoBcm  = TRUE;
    }

#ifdef INTEROP
    //
    //  The Samsung driver wants us to write to its BCR if it is not the IRM
    //
    fDoBcm  = TRUE;
    
#endif  // !INTEROP

    TRACE( TL_T, TM_Bcm, ( "  nicBCMAddRemoteNode fDoBCM%x ", fDoBcm) );

    
    //
    // Set An Event so a waiting BCM thread (in FindIrmAmongRemoteNodes) can
    // be schduled to run
    //
    ADAPTER_ACQUIRE_LOCK (pAdapter);


    BCR_CLEAR_FLAG (pAdapter, BCR_LastNodeRemoved);


    if (fDoBcm == TRUE)
    {
        //
        // if the BCM is already in progress, mark it as dirty
        //
        BCR_SET_FLAG (pAdapter, BCR_NewNodeArrived);    

        pAdapter->BCRData.BCRWaitForNewRemoteNode.EventCode = Nic1394EventCode_NewNodeArrived;
        
        NdisSetEvent( &pAdapter->BCRData.BCRWaitForNewRemoteNode.NdisEvent);

        
    }

    ADAPTER_RELEASE_LOCK (pAdapter);

    if (fDoBcm  == TRUE)
    {
        TRACE( TL_A, TM_Bcm , ("Add RemoteNode- scheduling the BCM" ) );

        nicScheduleBCMWorkItem(pAdapter);
    }

    //
    // now do the media connectivity stuff
    //
    
    if (fIsOnlyRemoteNode == TRUE)
    {
        //
        // WE have media connectivity 
        //
        pAdapter->MediaConnectStatus = NdisMediaStateConnected;
        
        nicMIndicateStatus( pAdapter, NDIS_STATUS_MEDIA_CONNECT, NULL, 0);  
    }
    


    TRACE( TL_T, TM_Bcm, ( "<== nicBCMAddRemoteNode ") );

}















VOID
nicBCMAlgorithm(
    PADAPTERCB pAdapter,
    ULONG BcmGeneration
    )



/*++

Routine Description:

  Execute the BCM algorithm.
  Finds out if the current host Is IRM
  If YES then inform remote nodes and exit
  if NO then find the remote node and read its BCR.

  Reasons for abort - New Node Arrival or Invalid Generation caused by a BusReset

  If no remote nodes are present and this node is the IRM it will allocate the b channel and exit

Arguments:

    pAdapter - paDapter
    BCMGeneration - Generation at which the BCM was started

Return Value:


--*/
{

    NDIS_STATUS         NdisStatus  = NDIS_STATUS_FAILURE;
    PREMOTE_NODE        pRemoteNode= NULL;  
    PREMOTE_NODE        pIRMRemoteNode = NULL;
    PTOPOLOGY_MAP       pTopologyMap = NULL;
    ULONG               Length = DEFAULT_TOPOLOGY_MAP_LENGTH;
    PVOID               pTopologyBuffer = NULL;
    NODE_ADDRESS        LocalNodeAddress;
    BOOLEAN             fIsLocalHostIrm = FALSE;
    ULONG               TopologyGeneration = 0;
    PVOID               pOldTopologyMap = NULL;
    STORE_CURRENT_IRQL;
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
    
    TRACE( TL_T, TM_Bcm, ( "==>nicBCMAlgorithm pAdapter %x, BcmGen %x", pAdapter, BcmGeneration ) );


    do
    {   
        
        ASSERT (BCR_TEST_FLAG (pAdapter, BCR_BCMInProgress) == TRUE);
        //
        // find out if the local host is the IRM and update the generation count as well
        //
        NdisStatus = nicIsLocalHostTheIrm ( pAdapter,
                                           &fIsLocalHostIrm,
                                           &pTopologyMap,
                                           &LocalNodeAddress);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            
            TRACE( TL_A, TM_Bcm, ( "    nicBCMAlgorithm:  nicIsLocalHostTheIrm FAILED ") );
            break;
        }   

        //
        // Update the adapter structure
        //
        TopologyGeneration = pTopologyMap->TOP_Generation;

        
        if (TopologyGeneration  != BcmGeneration)
        {
            TRACE( TL_A, TM_Bcm, ( "  TopologyGeneration %x, BcmGeneration %x", TopologyGeneration, BcmGeneration) );
            break;

        }
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        ASSERT (pAdapter->Generation == pTopologyMap->TOP_Generation);
        pAdapter->BCRData.LocalNodeAddress = LocalNodeAddress;
        pOldTopologyMap = pAdapter->BCRData.pTopologyMap;
        pAdapter->BCRData.pTopologyMap = pTopologyMap;
        pAdapter->BCRData.LocalNodeNumber = LocalNodeAddress.NA_Node_Number;
        pAdapter->NodeAddress = LocalNodeAddress;
        //
        // Temporary
        //
        pAdapter->Generation =  pTopologyMap->TOP_Generation;
        BcmGeneration = pTopologyMap->TOP_Generation;
        
        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Free the Old Topology Map
        //
        if (pOldTopologyMap != NULL)
        {
            FREE_NONPAGED(pOldTopologyMap);
        }

        //
        // Now Start the BCM algorithm
        //
        if (fIsLocalHostIrm == TRUE)
        {
            pAdapter->BCRData.Flags |= BCR_LocalHostIsIRM;
            
            ASSERT (pTopologyMap->TOP_Node_Count-1 ==  LocalNodeAddress.NA_Node_Number);

            TRACE( TL_V, TM_Bcm, ( "    LOCAL HOST IS IRM ") );

            NdisStatus = nicLocalHostIsIrm (pAdapter);
        }
        else
        {
            TRACE( TL_V, TM_Bcm, ( "    LOCAL HOST IS NOT IRM ") );

            NdisStatus = nicLocalHostIsNotIrm( pAdapter,
                                               BcmGeneration  );

        }

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_V, TM_Bcm, ( "    nicBCMAlogrithm: nicLocalHostIsNotIrm or nicLocalHostIsIrm FAILED") );
            break;
        }

        //
        // Marks the end of the BCM algorithm . Do the clean up work.
        // Check for the last node going away. , Release any pending make calls
        // and set up the Gasp Header
        //

        nicMakeGaspHeader (pAdapter, &pAdapter->GaspHeader);
        
        nicBCMCheckLastNodeRemoved(pAdapter);

        nicSetEventMakeCall (pAdapter);

        
    } while (FALSE);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        NIC1394_LOG_PKT(pAdapter,
                            NIC1394_LOGFLAGS_BCM_FAILED,
                            pAdapter->Generation,
                            fIsLocalHostIrm ,
                            &NdisStatus,
                            sizeof (NDIS_STATUS));

        BCR_SET_FLAG (pAdapter, BCR_BCMFailed);
    }
    
    TRACE( TL_T, TM_Bcm, ( "<==nicBCMAlgorithm %x  ", NdisStatus ) );
    MATCH_IRQL;
    
}



VOID
nicBCMAlgorithmWorkItem(
    PNDIS_WORK_ITEM pWorkItem,
    PVOID   pContext
    )

/*++

Routine Description:
  The function kicks of the BCM algorithm.
  Restarts the BCM if a reset occurred during the BCM algorithm.

Arguments:
  Adapter - localhost

Return Value:


--*/


{
    PADAPTERCB          pAdapter    = (PADAPTERCB)pContext;
    ULONG               BcmGeneration = pAdapter->Generation;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    ULONG               Generation;
    BOOLEAN             fRestartBCM = FALSE;
    BOOLEAN             fFreeBCR = FALSE;
    BOOLEAN             fFlagSetByThisThread = FALSE;
    STORE_CURRENT_IRQL;

    TRACE( TL_T, TM_Bcm, ( "==>nicBCMAlgorithmWorkItem pAdapter %x, Generation  %x", pAdapter, BcmGeneration  ) );



    //
    // Ensure that only one thread gets into the BCM algorithm and
    // all other threads are returned immediately
    //
    
    ADAPTER_ACQUIRE_LOCK (pAdapter);

    //
    // If the BCR is being freed, then don't touch it
    //
    
    if (BCR_TEST_FLAGS (pAdapter, (BCR_Freed |BCR_BCRNeedsToBeFreed ) )== TRUE)
    {
        // Do Nothing, this thread will simply exit
        //

    }
    else
    {
        //
        // The BCR is active, 
        // If there is no other thread running the BCM algorithm, then this thread should set 
        // the BCMInProgress flag
        //
        if (BCR_TEST_FLAG (pAdapter, BCR_BCMInProgress ) == FALSE )
        {
            BCR_SET_FLAG (pAdapter, BCR_BCMInProgress );
            fFlagSetByThisThread = TRUE;
        }

    }  

    ADAPTER_RELEASE_LOCK (pAdapter);


    
    do
    {

        //
        // First check to see if we have a valid reason to stop
        //
        if (fFlagSetByThisThread == FALSE)
        {
            break;
        }

        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // If there are no remote nodes then mark the BCR as so
        //
        if (IsListEmpty (&pAdapter->PDOList) == TRUE )
        {
            TRACE (TL_V, TM_Bcm, ("No Nodes present" )  );
            BCR_SET_FLAG (pAdapter, BCR_NoNodesPresent);
            
        }
        else
        {

            BCR_CLEAR_FLAG (pAdapter, BCR_NoNodesPresent);
        }   
        
        
        //
        // Clear the two flags which cause us to restart the BCM
        //
        ADAPTER_CLEAR_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) ;
        BCR_CLEAR_FLAG (pAdapter, BCR_NewNodeArrived );


        ADAPTER_RELEASE_LOCK (pAdapter);
        

        do
        {
            NdisStatus = nicGetGenerationCount (pAdapter, &Generation) ;

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_T, TM_Bcm, ( "  nicGetGenerationCount , Generation  %x", pAdapter, BcmGeneration  ) );

                break;
            }

            //
            //  If the BCM is freed then exit
            //
            if ((BCR_TEST_FLAGS (pAdapter, BCR_Freed | BCR_BCRNeedsToBeFreed )== TRUE) )
            {
                break;
            }


            //
            // Update the generation count
            //
            BcmGeneration = Generation;
            pAdapter->Generation = Generation;
            //
            // Update the remote nodes table
            //
            nicUpdateRemoteNodeTable (pAdapter);

            nicUpdateLocalHostNodeAddress (pAdapter);
        
            if ( ADAPTER_TEST_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) == TRUE)
            {
                //
                // The local host has been reset since the start of the loop. Break
                // out and restart
                //
                break;
        
            }

            //
            // Now start the BCM
            //
            

            if (BCR_TEST_FLAG (pAdapter, BCR_LocalHostBCRUpdated ) == FALSE)
            {

                //
                // We need to go and do the BCM because our registers have not been updated
                //
                nicBCMAlgorithm(pAdapter, BcmGeneration);
            }
            else
            {
                
                //
                // Our BCR was written to
                //
                ULONG                           LocalHostBCRLittleEndian ;
                NETWORK_CHANNELSR*              pBCR;

                ASSERT (BCR_TEST_FLAG (pAdapter, BCR_LocalHostBCRUpdated ) == TRUE);
                

                //
                // Update the IRM_BCR so we have a record of the new BCM
                //
                ADAPTER_ACQUIRE_LOCK (pAdapter);

                NdisZeroMemory (&pAdapter->BCRData.IRM_BCR, sizeof (NETWORK_CHANNELSR) );
                
                LocalHostBCRLittleEndian = SWAPBYTES_ULONG (pAdapter->BCRData.LocalHostBCRBigEndian);
                
                ASSERT ((LocalHostBCRLittleEndian & BCR_VALID_LITTLE_ENDIAN) == BCR_VALID_LITTLE_ENDIAN);

                pBCR = (NETWORK_CHANNELSR*)(&LocalHostBCRLittleEndian);
                
                pAdapter->BCRData.IRM_BCR.NC_Channel = pBCR->NC_Channel ;           // bits 0-5
                pAdapter->BCRData.IRM_BCR.NC_Valid = pBCR->NC_Valid ;             // bit  30
                pAdapter->BCRData.IRM_BCR.NC_One  = pBCR->NC_One ;
                
                ADAPTER_RELEASE_LOCK (pAdapter);

            }

            
        } while (FALSE);

        //
        // Check to see if another Bus Reset has come in.
        // if so we need to restart the BCM
        //

        ADAPTER_ACQUIRE_LOCK (pAdapter);

        BCR_CLEAR_FLAG (pAdapter, BCR_BCMInProgress);

        //
        // if the generation is bad the BCR is not being freed initialzed then restart the BCM
        //

        
        TRACE( TL_V, TM_Bcm, ( "pAdapter Flags %x, BCM flags %x, BCM %x", pAdapter->ulFlags, pAdapter->BCRData.Flags, pAdapter->BCRData.IRM_BCR) );

        //
        // If the BCR is getting freed , set the flag and break, then we cannot loop back, we must exit
        //
        if (BCR_TEST_FLAGS (pAdapter, (BCR_Freed |BCR_BCRNeedsToBeFreed ) )== TRUE)
        {
            //
            // As the BCM is about to be freed, this run of the BCM should terminate 
            // and free the BCR
            //
            fRestartBCM = FALSE;    
            fFreeBCR = TRUE;
            ADAPTER_RELEASE_LOCK (pAdapter);
            break;

        }

        //
        // We need to do the bcm again, if a reset has occurred or a new node has arrived
        //
        if ((ADAPTER_TEST_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) == TRUE) ||
             (BCR_TEST_FLAG (pAdapter, BCR_NewNodeArrived)== TRUE)  )
        {
        
            //
            // Invalidate the BCR and restart
            //
            pAdapter->BCRData.IRM_BCR.NC_Valid  = 0;

            //
            // We are going to try again. Update the flags
            //
            BCR_CLEAR_FLAG (pAdapter, BCR_BCMFailed | BCR_LocalHostBCRUpdated |  BCR_LocalHostIsIRM | BCR_NewNodeArrived );

            //
            // As this thread is going ot retry thr BCM, it must block all new entrants again
            //
            BCR_SET_FLAG (pAdapter, BCR_BCMInProgress);

            fRestartBCM = TRUE; 


            TRACE( TL_V, TM_Bcm, ( "Restart BCM TRUE ") );

                
        }   
        else
        {
            //
            // We do not retart the BCM has completed
            //
            TRACE( TL_V, TM_Bcm, ( "Restart BCM FALSE") );

            fRestartBCM = FALSE;    
                
        }
        
        ADAPTER_RELEASE_LOCK (pAdapter);

        if ((fRestartBCM == TRUE) &&
            (BCR_TEST_FLAGS (pAdapter, BCR_ChannelAllocated) == TRUE))
        {
            TRACE (TL_V, TM_Bcm, ("Free Channel %x", pAdapter->BCRData.LocallyAllocatedChannel ));
            nicFreeChannel (pAdapter, pAdapter->BCRData.LocallyAllocatedChannel );
        }

        //
        //  fSimply Exit is also false, and will allow this thread to execute again
        //
    }while (fRestartBCM == TRUE) ;


    if (fFlagSetByThisThread == TRUE)
    {
        if ( BCR_TEST_FLAG (pAdapter, BCR_BCRNeedsToBeFreed) == FALSE)
        {
            //
            // If we are not freeing the BCR, then the adapter is still valid.
            // Update the local Host Node Address, so that we have the latest information 
            // from the bus. 
            //
            nicUpdateLocalHostNodeAddress (pAdapter);
            nicUpdateRemoteNodeTable (pAdapter);

        }

    }

    //
    // Does the BCR need to be freed by this thread. Only threads that have been
    // given a chance to execute the bcm, should be able to free the BCR
    //
    if (fFreeBCR == TRUE)
    {
        nicFreeBroadcastChannelRegister (pAdapter);
    }


    //
    // Dereference the adapter . reference was added for the work item
    //
    nicDereferenceAdapter (pAdapter, "nicBCMAlgorithmWorkItem ");
    
    FREE_NONPAGED (pWorkItem);

    TRACE( TL_T, TM_Bcm, ( "<==nicBCMAlgorithmWorkItem fRestartBCM %x", fRestartBCM) );
    MATCH_IRQL; 
}





VOID
nicBCMAbort (
    IN PADAPTERCB pAdapter,
    IN PREMOTE_NODE pRemoteNode
    )

    // Function Description:
    //    This function is called when the BCM aborts. It should release the allocated channel
    //
    // Arguments
    //  pAdapter - Current local Host
    //
    // Return Value:
    //
{
    BOOLEAN fNeedToFreeChannel = FALSE;
    PBROADCAST_CHANNEL_DATA pBCRData = &pAdapter->BCRData;

    TRACE( TL_T, TM_Bcm, ( "==>nicBCMAbort  pAdapter %x", pAdapter) );

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    if ( BCR_TEST_FLAG (pAdapter, BCR_InformingRemoteNodes) == TRUE)
    {
        fNeedToFreeChannel = TRUE;
        BCR_CLEAR_FLAG (pAdapter, BCR_ChannelAllocated);
        BCR_CLEAR_FLAG (pAdapter, BCR_InformingRemoteNodes);
    }
    else
    {
        fNeedToFreeChannel = FALSE;
    }

    ADAPTER_RELEASE_LOCK (pAdapter);

    if (fNeedToFreeChannel == TRUE)
    {
        nicFreeChannel ( pAdapter,
                        pBCRData->LocallyAllocatedChannel);
                
    }
        
    pBCRData->LocallyAllocatedChannel = INVALID_CHANNEL;


    TRACE( TL_T, TM_Bcm, ( "<==nicBCMAbort  " ) );

}





VOID
nicBCMCheckLastNodeRemoved(
    IN PADAPTERCB pAdapter
    )
    // Function Description:
    //  Called from the BCMAlgorithm code path
    //    Check to see if the last node has gone away during the algorithm.
    //    If it has then turn off the valid bit.
    //
    // Arguments
    //   pADpater - Local host
    //
    // Return Value:
    //
{

    TRACE( TL_T, TM_Bcm, ( "==> nicBCMCheckLastNodeRemoved pAdapter %x", pAdapter ) );


    TRACE( TL_T, TM_Bcm, ( "<== nicBCMCheckLastNodeRemoved " ) );

}






NDIS_STATUS
nicFindIrmAmongRemoteNodes (
    IN PADAPTERCB pAdapter,
    IN ULONG BCMGeneration,
    OUT PPREMOTE_NODE ppIrmRemoteNode
    )
    // Function Description:
    //   This function goes through all the remote nodes
    //   and attempts to get their address to verify which one is
    //   the IRM
    //
    //
    // Arguments
    //   pADpater - Local host
    //   BCMGeneration - the Gerneration at which the BCMStarted
    //   ppIrmRemoteNode - output value - IRM
    //
    // Return Value:
    //  Success - if an IRM is found
    //
{
    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    PLIST_ENTRY             pPdoListEntry = NULL;
    PREMOTE_NODE            pRemoteNode = NULL;
    PREMOTE_NODE            pIrmRemoteNode = NULL;
    NODE_ADDRESS            RemoteNodeAddress;
    ULONG                   HighestNode;
    ULONG                   Generation;
    ULONG                   NumRetry =0;
    PNIC1394_EVENT          pBCRWaitForNewRemoteNode = &pAdapter->BCRData.BCRWaitForNewRemoteNode;
    ULONG                   BackOffWait = ONE_MINUTE>>4;


    TRACE( TL_T, TM_Bcm, ( "==>nicFindIrmAmongRemoteNodes pAdapter %x, ppIrmRemoteNode %x",
                            pAdapter, ppIrmRemoteNode) );

    ASSERT (pAdapter->BCRData.pTopologyMap != NULL);

    HighestNode =   pAdapter->BCRData.pTopologyMap->TOP_Node_Count-1;


    //
    // Set up a loop, so that we continue until we succeed, timeout, or have a good reason to break
    // One of two things will cause the break:
    //  1. the bus has been reset - break out
    //  2. Irm has been found
    //

    do
    {
        
        pBCRWaitForNewRemoteNode->EventCode  = Nic1394EventCode_InvalidEventCode;

        NdisResetEvent (&pBCRWaitForNewRemoteNode->NdisEvent);

        
        //
        // First see if we already have this remote node in our table
        //
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        if (pAdapter->NodeTable.RemoteNode[HighestNode] != NULL)
        {
            //
            // we found the IRM. Lets break out.
            //
                    
            *ppIrmRemoteNode = pAdapter->NodeTable.RemoteNode[HighestNode] ;

            //
            // Reference the IRM. This will be dereferenced after the BCM is finished. (ie) at the end of nicLocalHostisNotIrm
            //
            nicReferenceRemoteNode (*ppIrmRemoteNode, "nicFindIrmAmongRemoteNodes");

            
            ADAPTER_RELEASE_LOCK (pAdapter);

            NdisStatus = NDIS_STATUS_SUCCESS;

            //
            // Break out if the IRM is found
            //
            break;

        }
        else
        {
            
            //
            // If the IRM is not in adapter's data structures, the thread needs to wait for it to arrive
            //
            BOOLEAN bWaitSuccessful;

            ADAPTER_RELEASE_LOCK (pAdapter);

            //
            // Sleep and try again
            //
            TRACE( TL_V, TM_Bcm, ( " About to Wait 15 sec. for Remote Node") );
    
            bWaitSuccessful = NdisWaitEvent (&pBCRWaitForNewRemoteNode->NdisEvent, BackOffWait );

            TRACE( TL_V, TM_Bcm, ( "  pBCRWaitForNewRemoteNode signalled Event Code = %x, bWaitSuccessful %x",
                                     pBCRWaitForNewRemoteNode->EventCode, bWaitSuccessful) );

            BackOffWait = BackOffWait << 1;         

            if (bWaitSuccessful == TRUE)
            {
                //
                // Check for invalid  conditions
                //

                if (pBCRWaitForNewRemoteNode->EventCode == nic1394EventCode_BusReset  ||
                  pBCRWaitForNewRemoteNode->EventCode == nic1394EventCode_FreedAddressRange)
                {
                    TRACE( TL_V, TM_Bcm, ( " Bus Has been reset,or addresss range freed aborting BCM") );

                    //
                    // Break out if the Bus Has been reset
                    //
                    break;
                }

                TRACE( TL_V, TM_Bcm, ( "   New Node has arrived check its node address") );
                
                
                ASSERT (pBCRWaitForNewRemoteNode->EventCode  == Nic1394EventCode_NewNodeArrived);

                //
                // Hit the while (TRUE) condition loop back  and verify if the new node is the IRM
                //

            }
            else
            {
                //
                //  Wait has timed out
                //
                if (ADAPTER_TEST_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) == TRUE)
                {
                    //
                    // If the generation is invalid then break out and abort the BCM
                    //
                    NdisStatus = NIC1394_STATUS_INVALID_GENERATION;
                    break;

                }

                NumRetry ++;


                if (NumRetry == 5 )// aribtrary constant
                {
                    break;
                
                }
            }
        }   


            
    } while (TRUE);     

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        //
        // Log this failuire
        //
        NIC1394_LOG_PKT(pAdapter,
                        NIC1394_LOGFLAGS_BCM_IRM_NOT_FOUND,
                        pAdapter->Generation,
                        HighestNode,
                        &pAdapter->NodeTable,
                        5 * sizeof (PVOID));   // arbitrarily number - copies 5 entries

    


    }
    
    TRACE( TL_T, TM_Bcm, ( "<==nicFindIrmAmongRemoteNodes Status %x pIrm %x", NdisStatus, *ppIrmRemoteNode ) );

    return NdisStatus;
}


VOID
nicFreeBroadcastChannelRegister(
    IN PADAPTERCB pAdapter
    )

    // Function Description:
    //   Free the boradcast channed reigster. Only called
    //   from the Init failure or halt code path
    //
    // Arguments
    //   pAdapter
    //
    // Return Value:
    //
    //  None
    //

{
    ADDRESS_RANGE_CONTEXT BCRAddressRange;
    TIMESTAMP_ENTRY ("==>Free BCR");
    TRACE( TL_T, TM_Bcm, ( "==> nicFreeBroadcastChannelRegister pAdapter %x", pAdapter ) );

    
    do
    {
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        BCR_SET_FLAG (pAdapter, BCR_BCRNeedsToBeFreed);

        
        //
        // If a Make Call is pending, then set the Event so that the make call can complete.
        //
        if (BCR_TEST_FLAG (pAdapter,BCR_MakeCallPending)== TRUE)
        {

            pAdapter->BCRData.MakeCallWaitEvent.EventCode = nic1394EventCode_FreedAddressRange;   
            NdisSetEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent);
        }
        
        //
        //  If the BCM is in progress, let the BCM thread free the BCR instead
        //
        if (BCR_TEST_FLAG (pAdapter, BCR_BCMInProgress) == TRUE)
        {
            
            ADAPTER_RELEASE_LOCK (pAdapter);

            //
            // Wake up any pending threads - This wakes up an existing BCM thread that could 
            // be waiting for a new remote node
            //
            pAdapter->BCRData.BCRWaitForNewRemoteNode.EventCode = nic1394EventCode_FreedAddressRange;   
            NdisSetEvent (&pAdapter->BCRData.BCRWaitForNewRemoteNode.NdisEvent);
    
            TRACE( TL_N, TM_Bcm, ( "  nicFreeBroadcastChannelRegister BCM in progress or already freed, breaking out", pAdapter ) );
            break;

        }

        //
        // if the BCR is already freed, then simply exit. The event that the caller will wait
        // on BCRData.BCRFreeAddressRange.NdisEvent has already been set
        //
        if (BCR_TEST_FLAG (pAdapter, BCR_Freed) == TRUE)
        {
            ADAPTER_RELEASE_LOCK (pAdapter);
            break;
    
        }
        
        //
        // sanity check
        //
        ASSERT (BCR_TEST_FLAG (pAdapter,  BCR_BCRNeedsToBeFreed) == TRUE);
        //
        // Now update the flags
        //
        BCR_CLEAR_FLAG (pAdapter, BCR_Initialized | BCR_ChannelAllocated | BCR_BCRNeedsToBeFreed);

        //
        // clear all the BCR Valid bits
        //
        
        pAdapter->BCRData.IRM_BCR.NC_Valid = 0;
        pAdapter->BCRData.LocalHostBCRBigEndian  = BCR_IMPLEMENTED_LITTLE_ENDIAN;  //0x80000000

        if (pAdapter->BCRData.pRemoteBCRMdl != NULL)
        {

            nicFreeMdl (pAdapter->BCRData.pRemoteBCRMdl);
            pAdapter->BCRData.pRemoteBCRMdl = NULL;
        }

        //
        // Temporary copy of the Address Range Context
        //
        BCRAddressRange = pAdapter->BCRData.AddressRangeContext;

        //
        // Zero out the Address Range Structure. This zeroes out AddressRangeContext.Mdl as well.
        // This is ok as BCRData.pLocalBCRMdl will be freed below and they both 
        // point to the same mdl.
        //
        NdisZeroMemory (
            &pAdapter->BCRData.AddressRangeContext, 
            sizeof (pAdapter->BCRData.AddressRangeContext));

        //
        // Clear out the VC. if any
        //
        if (pAdapter->BCRData.pBroadcastChanneVc != NULL)
        {
              nicDereferenceCall ((PVCCB) pAdapter->BCRData.pBroadcastChanneVc, "nicFreeBroadcastChannelRegister ");
              pAdapter->BCRData.pBroadcastChanneVc = NULL;
        }

        ADAPTER_RELEASE_LOCK (pAdapter);


        //
        // Free Address Range
        //
        if (BCRAddressRange.hAddressRange  != NULL)
        {
            nicFreeAddressRange (pAdapter,
                                 BCRAddressRange.AddressesReturned,
                                 &BCRAddressRange.AddressRange,
                                 &BCRAddressRange.hAddressRange      );
        }


        ADAPTER_ACQUIRE_LOCK (pAdapter);
        
        if (pAdapter->BCRData.pLocalBCRMdl != NULL)
        {
            nicFreeMdl (pAdapter->BCRData.pLocalBCRMdl);
            pAdapter->BCRData.pLocalBCRMdl = NULL;
        }

        
        //
        // Free the Adapter's BCRData. TopologyMap as that is locally allocated
        //
        if (pAdapter->BCRData.pTopologyMap)
        {
            FREE_NONPAGED (pAdapter->BCRData.pTopologyMap);
            pAdapter->BCRData.pTopologyMap = NULL;
        }

        // 
        // Clear the flags to force the BCR to be reintitalized
        //
        BCR_CLEAR_ALL_FLAGS(pAdapter);
        
        BCR_SET_FLAG (pAdapter, BCR_Freed);

        
        ADAPTER_RELEASE_LOCK (pAdapter);
        //
        // Set the Event and let the halt go through
        //
        
        pAdapter->BCRData.BCRFreeAddressRange.EventCode = nic1394EventCode_FreedAddressRange;
        NdisSetEvent (&pAdapter->BCRData.BCRFreeAddressRange.NdisEvent);

        

        TRACE( TL_N, TM_Bcm, ( "  nicFreeBroadcastChannelRegister BCM freed", pAdapter ) );

        
        
    } while (FALSE);

    TRACE( TL_T, TM_Bcm, ( "<== nicFreeBroadcastChannelRegister pAdapter %x", pAdapter ) );

    TIMESTAMP_EXIT ("<==Free BCR");

}




NDIS_STATUS
nicInformAllRemoteNodesOfBCM (
    IN PADAPTERCB pAdapter
    )


    // Function Description:
    //  This function will simply walk through the remote node list and write
    //  to the BCR of all the remote nodes
    //
    // Arguments
    //  pAdapter - Current local Host
    //  Channel - Channel used for broadcast
    //
    // Return Value:
    //
    //

{

    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PREMOTE_NODE        pRemoteNode = NULL;
    PLIST_ENTRY         pPdoListEntry = NULL;
    IO_ADDRESS          Destination;
    ULONG               IrmGeneration ;
    PMDL                pBCRMdl;
    BOOLEAN             fLockAcquired = FALSE;
    NTSTATUS            NtStatus = STATUS_UNSUCCESSFUL;
    BOOLEAN             fReferencedCurrentRemoteNode = FALSE;
    
    TRACE( TL_T, TM_Bcm, ( "==> nicInformAllRemoteNodesOfBCM  pAdapter %x, Channel %x OldGeneration %x",
                             pAdapter, pAdapter->BCRData.LocalHostBCRBigEndian, pAdapter->BCRData.IrmGeneration ) );

    //
    // Set up the constants that will be used
    //
    Destination.IA_Destination_Offset.Off_Low = INITIAL_REGISTER_SPACE_LO | NETWORK_CHANNELS_LOCATION;
    Destination.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;

    if ( (pAdapter->BCRData.LocalHostBCRBigEndian & BCR_VALID_BIG_ENDIAN) != BCR_VALID_BIG_ENDIAN)
    {
        //
        // Do not write an invalid bcr to remote nodes
        //
        ASSERT ((ADAPTER_TEST_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) == TRUE)  ||
                 (BCR_TEST_FLAGS (pAdapter, BCR_Freed | BCR_BCRNeedsToBeFreed )== TRUE) );

        return NIC1394_STATUS_INVALID_GENERATION;
    }

    pBCRMdl = pAdapter->BCRData.pLocalBCRMdl;

    //
    // Acquire the lock and walk the list of remote nodes
    //

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    fLockAcquired = TRUE;

    IrmGeneration = pAdapter->BCRData.IrmGeneration;
    
    pPdoListEntry = pAdapter->PDOList.Flink ;



    //
    // Now start the actual informing the remote nodes- asyncwrite algorithm
    //

    //
    // Since the loop can be broken in the middle of the while loop. the code
    // keeps track of lock acquire/release state
    //
    
    while (pPdoListEntry != &pAdapter->PDOList )
    {
        
        pRemoteNode = CONTAINING_RECORD (pPdoListEntry,
                                            REMOTE_NODE,
                                            linkPdo);

        nicReferenceRemoteNode (pRemoteNode, "nicInformAllRemoteNodesOfBCM ");

        fReferencedCurrentRemoteNode = TRUE;

        ADAPTER_RELEASE_LOCK (pAdapter);

        fLockAcquired = FALSE;

        
        //
        // First check if we are still in the same generation
        //
        if (pAdapter->Generation != IrmGeneration)
        {
            NdisStatus = NIC1394_STATUS_INVALID_GENERATION;
            TRACE( TL_T, TM_Bcm, ( "  nicInformAllRemoteNodesOfBCM  Generation Incorrect New Gen %x, Old Gen  ",
                                      pAdapter->Generation , IrmGeneration));
            break;

        }

        
        TRACE( TL_V, TM_Bcm, ( "   BCR %x, Mdl  %x, IrmGeneration %x" ,
                                pAdapter->BCRData.LocalHostBCRBigEndian, pBCRMdl, IrmGeneration ) );

        NdisStatus = nicAsyncWrite_Synch( pRemoteNode,
                                          Destination,     // Address to write to
                                          sizeof(NETWORK_CHANNELSR),  // Bytes to write
                                          sizeof(NETWORK_CHANNELSR),             // Block size of write
                                          0 , //fulFlags,               // Flags pertinent to write
                                          pBCRMdl,                    // Destination buffer
                                          IrmGeneration ,           // Generation as known by driver
                                          &NtStatus);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // Break out if the generation has changed or there are no more nodes left
            //
            if (NtStatus == STATUS_INVALID_GENERATION ||
               BCR_TEST_FLAG (pAdapter, BCR_LastNodeRemoved) )
            {
                TRACE( TL_V, TM_Bcm, ( "  nicAsyncWrite_Synch FAILED Status %x. Aborting ", NtStatus) );

                nicBCMAbort (pAdapter, pRemoteNode);
                
                break;
            }

        }
        

        ADAPTER_ACQUIRE_LOCK (pAdapter);


        fLockAcquired = TRUE;
        //
        // If the irps succeed and then the deref happens , else it happens below
        //
        nicDereferenceRemoteNode (pRemoteNode , "nicInformAllRemoteNodesOfBCM  " );
        fReferencedCurrentRemoteNode  = FALSE;

        pPdoListEntry = ListNext (pPdoListEntry);
        
    
    }   // end of while loop while (pPdoListEntry != &pAdapter->PDOList )

    //
    // Clear the Informing remote nodes flag and release the lock
    //
    if (fLockAcquired == FALSE)
    {   
        ADAPTER_ACQUIRE_LOCK (pAdapter);
    }

    BCR_CLEAR_FLAG (pAdapter, BCR_InformingRemoteNodes);

    ADAPTER_RELEASE_LOCK (pAdapter);
    
    //
    // Dereference the ref made in the beginning of the function
    //
    if (fReferencedCurrentRemoteNode == TRUE)
    {
        nicDereferenceRemoteNode (pRemoteNode , "nicInformAllRemoteNodesOfBCM  " );
    }


    TRACE( TL_T, TM_Bcm, ( "<== nicInformAllRemoteNodesOfBCM  (always returns success) Status %x", NdisStatus ) );

    NdisStatus = NDIS_STATUS_SUCCESS; // No failure
    return NdisStatus;
}





NDIS_STATUS
nicInitializeBroadcastChannelRegister (
    PADAPTERCB pAdapter
    )
    
    // Function Description:
    //   This function allocates address range for the BCR with its own MDL and data.
    //   Allocates an MDL for the time when we try to read other node's  BCR
    //   Initializes the IRM_BCR
    //
    // Return Value:
    //   Success - if the IRP succeeds
    //
    //
    //

{

    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PULONG              pBCRBuffer = NULL;
    PMDL                pBCRMdl = NULL;
    ADDRESS_OFFSET      Required1394Offset;
    ULONG               AddressesReturned;
    ADDRESS_RANGE       BCRAddressRange;
    HANDLE              hAddressRange;
    ULONG               LocalNodeNumber;
    PMDL                pRemoteBCRMdl = NULL;


    TRACE( TL_T, TM_Bcm, ( "==>nicInitializeBroadcastChannelRegister Adapter %x" , pAdapter ) );
    do
    {   
        BCR_CLEAR_ALL_FLAGS(pAdapter);                    
        //
        //Initialize the Local Host's BCR
        //
        pAdapter->BCRData.LocalHostBCRBigEndian = BCR_IMPLEMENTED_BIG_ENDIAN;

        //
        // Get an MDL that describes this buffer
        //
        if (pAdapter->BCRData.pLocalBCRMdl == NULL)
        {
            NdisStatus = nicGetMdl (sizeof(NETWORK_CHANNELSR),
                                   &pAdapter->BCRData.LocalHostBCRBigEndian,
                                   &pBCRMdl )   ;   
            
            
            if (pBCRMdl == NULL)
            {
                TRACE( TL_A, TM_Bcm, ( "   nicInitializeBroadcastChannelRegister IoAllocateMdl  FAILED" ) );

                NdisStatus = NDIS_STATUS_RESOURCES;

                break;
            }
        }
        else
        {
            //
            // We already have an MDL
            //
             pBCRMdl    = pAdapter->BCRData.pLocalBCRMdl;   
         }

        
        //
        // Allocate an Address Range at the BCR offset and use the MDL as its descriptor
        //
        TRACE( TL_V, TM_Bcm, ( "   LocalHostBCR Mdl %x", pBCRMdl ) );

        Required1394Offset.Off_Low = INITIAL_REGISTER_SPACE_LO | NETWORK_CHANNELS_LOCATION;
        Required1394Offset.Off_High = INITIAL_REGISTER_SPACE_HI ;


        pAdapter->BCRData.AddressRangeContext.pMdl = pBCRMdl ;
        
        //
        // There is no reference for this address range. The last outgoing Remote Node will simply Free it.
        //
        NdisStatus = nicAllocateAddressRange_Synch ( pAdapter,
                                                     pBCRMdl,
                                                     0, // Little Endian
                                                     sizeof (ULONG), // length
                                                     0, // maxsegmentsize
                                                     ACCESS_FLAGS_TYPE_READ | ACCESS_FLAGS_TYPE_WRITE | ACCESS_FLAGS_TYPE_LOCK | ACCESS_FLAGS_TYPE_BROADCAST,
                                                     NOTIFY_FLAGS_AFTER_READ | NOTIFY_FLAGS_AFTER_WRITE | NOTIFY_FLAGS_AFTER_LOCK ,
                                                     nicBCRAccessedCallback,
                                                     (PVOID)pAdapter,
                                                     Required1394Offset,
                                                     NULL,
                                                     NULL,
                                                     &AddressesReturned,
                                                     &BCRAddressRange,
                                                     &hAddressRange
                                                     );
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Bcm, ( "   nicInitializeBroadcastChannelRegister  nicAllocateAddressRange_Synch  FAILED" ) );
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
            break;
            
        }

        
        TRACE( TL_V, TM_Bcm, ( "   nicInitializeBroadcastChannelRegister  nicAllocateAddressRange_Synch  Succeeded" ) );
        TRACE( TL_V, TM_Bcm, ( "   &BCR Address Range  %x, AddressesReturned %x, hAddressRange %x",
                                   &BCRAddressRange, AddressesReturned, hAddressRange) );

        NdisStatus = nicGetMdl (sizeof(NETWORK_CHANNELSR),
                              &pAdapter->BCRData.RemoteBCRMdlData,
                              &pRemoteBCRMdl);

        if (NdisStatus != NDIS_STATUS_SUCCESS || pBCRMdl == NULL)
        {
            TRACE( TL_V, TM_Bcm, ( "   nicInitializeBroadcastChannelRegister :  nicGetMdl FAILED " ) );
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
            break;
        }

        ADAPTER_ACQUIRE_LOCK (pAdapter);
        pAdapter->BCRData.AddressRangeContext.AddressRange = BCRAddressRange;
        pAdapter->BCRData.AddressRangeContext.AddressesReturned = AddressesReturned;
        pAdapter->BCRData.AddressRangeContext.hAddressRange = hAddressRange;
        pAdapter->BCRData.pLocalBCRMdl = pBCRMdl;  // points to the same MDL as pAdapter->BCRData.AddressRangeContext.pMdl
        pAdapter->BCRData.pRemoteBCRMdl = pRemoteBCRMdl;
        pAdapter->BCRData.IRM_BCR.NC_One = 1;
        pAdapter->BCRData.MakeCallWaitEvent.EventCode = Nic1394EventCode_InvalidEventCode;
        NdisResetEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent);

        BCR_SET_FLAG (pAdapter, BCR_Initialized);

        ADAPTER_RELEASE_LOCK (pAdapter);
        

    } while (FALSE);


    
    TRACE( TL_T, TM_Bcm, ( "<==nicInitializeBroadcastChannelRegister %x", NdisStatus ) );

    return NdisStatus;
}



NDIS_STATUS
nicIsLocalHostTheIrm(
    IN PADAPTERCB pAdapter,
    OUT PBOOLEAN pfIsLocalHostIrm,
    OUT PPTOPOLOGY_MAP  ppTopologyMap,
    OUT PNODE_ADDRESS pLocalHostAddress
    )
    // Function Description:
    //   This function figures out if the Local Host is the IRM.
    //   If a remote node is specified, it will use that Node, otherwise
    //   it will pick one from the adapter
    //   It gets the 1394 address, and the topologyMap. It then figures out
    //   if the local host's node address makes it the IRM
    //
    // Arguments
    //
    //  pAdapter   - Local Host,
    //  pfIsLocalHostIrm, - TRUE if Local Host Is IRM, False - otherwise
    //  ppTopologyMap, - TopologyMap used to determine if this is the IRM
    //  pLocalHostAddress  - LocalHost Address discovered by querying the local host
    //
    //
    // Return Value:
    //
    //
    //
    //
{
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PVOID               pTopologyBuffer = NULL; 
    PREMOTE_NODE        pRemoteNode = NULL;
    NODE_ADDRESS        LocalNodeAddress;
    PTOPOLOGY_MAP       pTopologyMap = NULL;
    PTOPOLOGY_MAP       pOldTopologyMap = NULL;
    ULONG               Length = DEFAULT_TOPOLOGY_MAP_LENGTH;

    
    TRACE( TL_T, TM_Bcm, ( "==>nicIsLocalHostTheIrm  ") );

    ASSERT (pfIsLocalHostIrm != NULL);

    ASSERT (ppTopologyMap!=NULL);

    ASSERT (pLocalHostAddress != NULL);

    do
    {



        //
        // get the address of the local node/
        //
        NdisStatus = nicGet1394AddressFromDeviceObject( pAdapter->pNdisDeviceObject,
                                                        &LocalNodeAddress,
                                                        USE_LOCAL_NODE );
        if (NDIS_STATUS_SUCCESS != NdisStatus)
        {
            BREAK( TM_Bcm, ( "GetAddrFrom DevObj (Local) FAILED" ) );
        }

        TRACE ( TL_I, TM_Bcm, (  "   NODE_ADDRESS  Node Address %x, Number %x",LocalNodeAddress, LocalNodeAddress.NA_Node_Number ) );

        ASSERT (LocalNodeAddress.NA_Bus_Number == 0x3ff);
        //
        // Now we get the TopologyMap to find out if LocalHostIsIrm. We could fail the 1st Irp because our buffer is not
        // big enough, hence the do .. while loop
        //
        do
        {
    
            pTopologyBuffer = ALLOC_NONPAGED (Length , MTAG_DEFAULT);

            if (pTopologyBuffer ==NULL)
            {
                NdisStatus = NDIS_STATUS_RESOURCES; 

                break;
            }


            NdisStatus = nicGetLocalHostCSRTopologyMap (pAdapter,
                                                       &Length,
                                                       pTopologyBuffer );                       

            if (NdisStatus == NDIS_STATUS_INVALID_LENGTH)
            {
                FREE_NONPAGED(pTopologyBuffer);
            }

        } while (NdisStatus == NDIS_STATUS_INVALID_LENGTH);

        TRACE ( TL_V, TM_Bcm, ( "  TopologyBuffer %x",pTopologyBuffer) );

        pTopologyMap = (PTOPOLOGY_MAP)pTopologyBuffer;

        TRACE( TL_I, TM_Bcm, ( "    Top node count = %x ", pTopologyMap->TOP_Node_Count) );



    } while (FALSE);
    

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        //
        // Now update all the output parameters. The Top_Node_count can be zero.
        //
        if ( LocalNodeAddress.NA_Node_Number == (pTopologyMap->TOP_Node_Count -1 ) ||
            pTopologyMap->TOP_Node_Count == 0)
        {
            *pfIsLocalHostIrm = TRUE;
            BCR_SET_FLAG (pAdapter, BCR_LocalHostIsIRM);
        }
        else
        {
            *pfIsLocalHostIrm = FALSE;
        }

        //
        // If there is a topology map in the pointer, then it means that the topology map from
        // the previous query. Free it first.
        //
        if ( *ppTopologyMap != NULL)
        {
            FREE_NONPAGED(*ppTopologyMap);
        }

        *ppTopologyMap = pTopologyMap;

        *pLocalHostAddress = LocalNodeAddress;
    }
    
    TRACE( TL_T, TM_Bcm, ( "<==nicIsLocalHostTheIrm  %x   NdisStatus %x",*pfIsLocalHostIrm , NdisStatus ) );

    return NdisStatus;
}



NDIS_STATUS
nicLocalHostIsIrm(
    IN PADAPTERCB pAdapter
    )
    // Function Description:
    //
    //
    //
    //
    // Arguments
    //  pAdapter - Local adapter object
    //  pRemoteNode - Node to be used for submitting IRPs to the Busdriver
    //
    //
    // Return Value:
    //
    //
    //
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    ULONG       Channel = BROADCAST_CHANNEL;
    ULONG       TimeOut = 5;
    ULONG       LocalHostBCRLittleEndian;
    ULONG       WaitBackOff = ONE_SEC;
    

    TRACE( TL_T, TM_Bcm, ( "==>nicLocalHostIsIrm Adapter %x ", pAdapter) );


    //
    // Allocate BCM channel = 31
    //
    Channel = BROADCAST_CHANNEL;    

    do
    {
        //
        // If the channel is already allocated. Do not try and reallocate it.
        //

        if (BCR_TEST_FLAG(pAdapter,BCR_ChannelAllocated) == TRUE)
        {
            ASSERT (pAdapter->BCRData.IRM_BCR.NC_Channel == Channel);
            NdisStatus = NDIS_STATUS_SUCCESS;
            break;
        }
        

        //
        // Retry a 5 times to allocate the channel
        //
        while (NdisStatus != NDIS_STATUS_SUCCESS && TimeOut-- != 0 )
        {
            NdisStatus = nicAllocateChannel (pAdapter,
                                             Channel,
                                             NULL);

            if (NdisStatus != NDIS_STATUS_SUCCESS )
            {
                TRACE( TL_V, TM_Bcm, ( "  nicNodeIsIRMAlgorithm: nicallocateChannel Failed. Sleep and try again") );


                if (BCR_TEST_FLAG (pAdapter, BCR_BCRNeedsToBeFreed |BCR_NewNodeArrived) == TRUE ||
                  ADAPTER_TEST_FLAG (pAdapter,fADAPTER_InvalidGenerationCount) == TRUE)
                {
                    break;
                }
                //
                // Sleep for 1 Sec and try again.
                //
                NdisMSleep (WaitBackOff);
                WaitBackOff  = WaitBackOff << 1;
                //
                // Someother node has alredy asked for the BroadcastChannel .Force it out.
                // Eventually will need to allocate a new channel.
                //
                
            }
        }       

    } while (FALSE);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {

        //
        // Update our BCR and inform all the remote Nodes
        //
        TRACE( TL_V, TM_Bcm, ( "  nicLocalHostIsIrm: nicallocateChannel succeeded  %x", Channel) );
        
        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
        ASSERT (Channel == BROADCAST_CHANNEL);

        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // Update State - if no reset has occurred
        //
        if (ADAPTER_TEST_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) == FALSE)
        {
            BCR_SET_FLAG (pAdapter, BCR_ChannelAllocated);
            BCR_SET_FLAG (pAdapter, BCR_InformingRemoteNodes);

            pAdapter->BCRData.IrmGeneration = pAdapter->Generation;


            pAdapter->BCRData.LocalHostBCRBigEndian = 0;
            NdisZeroMemory (&pAdapter->BCRData.IRM_BCR, sizeof (NETWORK_CHANNELSR) );

            //
            // Update the BCR
            //
                        
            pAdapter->BCRData.IRM_BCR.NC_Channel = Channel;           // bits 0-5
            pAdapter->BCRData.IRM_BCR.NC_Valid = 1;             // bit  30
            pAdapter->BCRData.IRM_BCR.NC_One = 1;               // bit  31

            pAdapter->BCRData.LocallyAllocatedChannel = Channel;
        }
        else
        {
            TRACE( TL_V, TM_Bcm, ( "  nicLocalHostIsIrm: Reset after nicallocateChannel succeeded  %x", Channel) );
            
            pAdapter->BCRData.IRM_BCR.NC_Valid = 0;             // bit  30

        }
        
        TRACE( TL_V, TM_Bcm, ( "  nicLocalHostIsIrm: IRM_BCR Updated to %x ",pAdapter->BCRData.IRM_BCR) );

        //
        // Now convert LocalHost BCR so it can be read over the network
        //

        pAdapter->BCRData.LocalHostBCRBigEndian = SWAPBYTES_ULONG (*(PULONG)(&pAdapter->BCRData.IRM_BCR));

        TRACE( TL_V, TM_Bcm, ( "  nicLocalHostIsIrm: LocalHost BCR Updated to %x ",pAdapter->BCRData.LocalHostBCRBigEndian ) );

        ADAPTER_RELEASE_LOCK (pAdapter);

        if ((pAdapter->BCRData.LocalHostBCRBigEndian & BCR_VALID_BIG_ENDIAN) == (BCR_VALID_BIG_ENDIAN))             
        {
            //
            // Tell all the other nodes about the BCM and the channel.
            // This will abort the process if a reset happenned just prior
            //  to the channel allocation.
            //
            
            nicInformAllRemoteNodesOfBCM (pAdapter);
        }
    
    }
    else
    {
        TRACE( TL_A, TM_Bcm, ( "  nicLocalHostIsIrm - Failed RESET THE BUS") );

        NIC1394_LOG_PKT(pAdapter,
                        NIC1394_LOGFLAGS_BCM_IS_IRM_TIMEOUT,
                        pAdapter->Generation,
                        0,
                        &NdisStatus,
                        sizeof (NDIS_STATUS));

        //
        // If the generation is invalid or we need to bail out of the BCM for some reason,
        // then simply exit. Otherwise reset the bus
        //
        if (! (BCR_TEST_FLAG (pAdapter, BCR_BCRNeedsToBeFreed |BCR_NewNodeArrived) == TRUE ||
                  ADAPTER_TEST_FLAG (pAdapter,fADAPTER_InvalidGenerationCount) == TRUE) )
        {
            nicBCMReset(pAdapter);
        }

    }
    
    TRACE( TL_T, TM_Bcm, ( "<==nicLocalHostIsIrm%x  ",NdisStatus ) );
    
    return NdisStatus;
}



NDIS_STATUS
nicLocalHostIsNotIrm (
    IN PADAPTERCB pAdapter,
    IN ULONG BCMGeneration
    )
    // Function Description:
    //   This function goes through all the remote nodes
    //   and attempts to read their broadcast channels register
    //   If the Read itself fails - means the IRM does not implement the BCR - we issue a  reset
    //   If the generation is wrong - means the bus has been reset and we need to abort
    //   If the read succeeds, but BCR's MSB is not set - we issue a reset
    //
    //   If the read succeeds and valid bit is not set, we retry for 5 min. waiting for the Valid bit
    //      This involves i) attempt to read the (IRM) remote Node's BCR
    //                    If Read does not find a BCR,
    //                      Sleep
    //                      Check to see if RemoteNode Has written to Our BCR
    //                      If RemoteNode has NOT written to our BCR, then go back to i)
    //                  
    //
    //   This function can be optimized into a do while loop. However for
    //   the sake of simplicity and blindly following the BCM algorithm, it is
    //   spread out.
    //
    // Arguments
    //
    //
    //
    // Return Value:
    //
    //
    //
    //
{
    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    PLIST_ENTRY             pPdoListEntry = NULL;
    PREMOTE_NODE            pIrmRemoteNode = NULL;
    PMDL                    pRemoteBCRMdl = NULL;
    ULONG                   Generation,  BCMChannel ;
    BOOLEAN                 fRemoteNodeBCRIsValid  = FALSE;
    BOOLEAN                 fNeedToReset = FALSE;
    BOOLEAN                 fDidTheBusReset = FALSE;
    BOOLEAN                 fExit= FALSE;
    ULONG                   TimeOut;
    ULONG                   LocalHostBCRLittleEndian , RemoteNodeBCRLittleEndian;
    NETWORK_CHANNELSR*      pBCR = NULL;
    BOOLEAN                 fLocalHostBCRIsValid  = FALSE;
    ULONG                   BackOffWait = ONE_SEC;

    TRACE( TL_T, TM_Bcm, ( "==>nicLocalHostIsNotIrm " ) );

    ASSERT (pAdapter->BCRData.pTopologyMap != NULL);

    do
    {
        //
        // First do the wait - BCM algorithm requires this
        //
        pBCR = (NETWORK_CHANNELSR*)(&LocalHostBCRLittleEndian) ;

        NdisStatus = nicLocalNotIrmMandatoryWait (pAdapter,
                                             BCMGeneration,
                                             pBCR);

        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            fLocalHostBCRIsValid = TRUE;

            TRACE( TL_V, TM_Bcm, ( "   BCR written to during Mandatory Wait ") );

            break;
        }
        else
        {
            fLocalHostBCRIsValid = FALSE;
        }

        //
        // Initialize variables again and move on
        //
        pBCR = NULL;
        LocalHostBCRLittleEndian  = 0;
        
        //
        // Our BCR has not been updated. Lets go and find the IRM's BCR. we will loop until we
        // i)either find the IRM,  ii)timeout and then reset, or iii)find a new generation and abort
        //
        //
        NdisStatus = nicFindIrmAmongRemoteNodes (pAdapter, BCMGeneration, &pIrmRemoteNode);

        if (NdisStatus != NDIS_STATUS_SUCCESS  )
        {
                //
                // If there is NO IRM , it means we have not been notified of its addition.
                //
                TRACE( TL_V, TM_Bcm, ( "   nicLocalHostIsNotIrm :  nicFindIrmAmongRemoteNodes FAILED " ) );
                //
                // One of two things can have caused this:
                //  1. the bus has been reset - break out
                //  2. we have not been notified of a new node - continue on
                //
                if (NdisStatus == NIC1394_STATUS_INVALID_GENERATION)
                {
                    TRACE( TL_V, TM_Bcm, ( "   Invalid Generation, the bus has been reset ") );

                    NdisStatus = NtStatusToNdisStatus(NIC1394_STATUS_INVALID_GENERATION);
                    break;
                }
                

                //
                // We have not been able to find the IRM and have timed out.  
                // If the BCR is not freed, then abort and Reset
                //
                if (BCR_TEST_FLAGS (pAdapter, (BCR_Freed | BCR_BCRNeedsToBeFreed) == FALSE))
                {
                    TRACE( TL_I, TM_Bcm, ( "   nicLocalHostIsNotIrm -  Could Not Find IRM RESETTING ") );
                    fNeedToReset = TRUE;
                }
                break;
        }

        ASSERT (pIrmRemoteNode != NULL)

        //
        // We will now wait for the BCM to come up and initialize its BCR.
        // We will attempt to read it 5 times
        //
        pRemoteBCRMdl = pAdapter->BCRData.pRemoteBCRMdl;

        pAdapter->BCRData.RemoteBCRMdlData = 0;

        TimeOut = 5;  // arbitrary
        while (TimeOut-- != 0 )
        {       
            NdisStatus = nicReadIrmBcr ( pIrmRemoteNode,
                                         pRemoteBCRMdl,
                                         BCMGeneration,
                                         &fDidTheBusReset);

            //
            // First check to see if no reset has happenned while we were reading the BCR
            //

            if ( fDidTheBusReset == TRUE ||
                 (ADAPTER_TEST_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) == TRUE))
            {
                //
                // A reset has gone through under us.
                // We need to abort this round of the BCM process
                //
                TRACE( TL_V, TM_Bcm, ( "  nicLocalHostIsNotIrm : nicReadIrmBcr FAILED Invalid generation ") );

                NdisStatus = NDIS_STATUS_FAILURE;
                break;
            }

            //
            // Now check for Success and see if the BCR is implemented by the IRM
            //

            if (NdisStatus == NDIS_STATUS_SUCCESS )
            {

                TRACE( TL_V, TM_Bcm, ( "  BCR is %x ", pAdapter->BCRData.RemoteBCRMdlData ) );

                //
                // At this point we have a guarantee that nicReadIrmBcr succeeded. If the IRM does not implement the BCR
                // at all, there is no point in retrying, reset the bus and become the IRM
                //

                RemoteNodeBCRLittleEndian  = SWAPBYTES_ULONG (pAdapter->BCRData.RemoteBCRMdlData);

                pBCR  = (NETWORK_CHANNELSR*)(&RemoteNodeBCRLittleEndian );
                
                if ( IS_A_BCR (pBCR) == FALSE && NdisStatus == NDIS_STATUS_SUCCESS)
                {
                    fNeedToReset = TRUE;
                    TRACE( TL_I, TM_Bcm, ( "  nicLocalHostIsNotIrm : IRM does not implement the BCR %x RESETTING",RemoteNodeBCRLittleEndian ) );
                    break;

                }

                //
                // The remote node implements the BCR, so now lets see if it has set up the broadcast channel by looking
                //  at the valid bit.
                //
                if (BCR_IS_VALID (pBCR) ==TRUE)
                {
                    //
                    // We've succeeded and have received a Broadcast Channel. Update data structures and exit.
                    //
                    ULONG BCMChannel;
                    
                    fRemoteNodeBCRIsValid = TRUE;

                    BCMChannel = pBCR->NC_Channel;

                    TRACE( TL_V, TM_Bcm, ( "   BCM Channel  %x ", BCMChannel  ) );

                    break;

                }
                //
                // At this point we know that the IRM implements the BCR but has not set its valid bit yet.
                // Lets sleep and give it som more time
                //
                pBCR = NULL;
                RemoteNodeBCRLittleEndian  = 0;
            }
    
            //
            // Check to see if the Remote Node PDO is valid 
            //
            if (REMOTE_NODE_TEST_FLAG(pIrmRemoteNode, PDO_Removed) )
            {
                fNeedToReset = TRUE;
                fExit = TRUE;
            }
             //
            // Remote Node's BCR  is not up yet
            // We need to sleep and retry to read the IRM's BCR in the hope that it will have allocated the
            // broadcast channel by the time we read the register again.
            //
            NdisMSleep (BackOffWait);           
            BackOffWait = BackOffWait << 1;
            
            ADAPTER_ACQUIRE_LOCK (pAdapter);

            if (BCR_TEST_FLAG (pAdapter, BCR_BCRNeedsToBeFreed) == FALSE )
            {
                LocalHostBCRLittleEndian  = SWAPBYTES_ULONG (pAdapter->BCRData.LocalHostBCRBigEndian);
            }
            else
            {
                fExit = TRUE;
            }
            ADAPTER_RELEASE_LOCK (pAdapter);

            //
            // Address range has been freed, exit
            //
            if (fExit == TRUE)
            {
                break;
            }


            pBCR = (NETWORK_CHANNELSR*)(&LocalHostBCRLittleEndian);

            //
            // Check if the BCR is valid and that no reset has come through the in the Interim.
            // The reset would have cleared the BCR_localHostBCRUpdated field
            //
            if ( BCR_IS_VALID (pBCR) == TRUE && 
                ( BCR_TEST_FLAGS (pAdapter, BCR_LocalHostBCRUpdated  ) == TRUE))
            {
                //
                // We've succeeded. Update data structures and exit.
                // The actual IRM BCR will have been updated in the BCRAccessed thread
                // so we simply exit
                //
                NdisStatus  = NDIS_STATUS_SUCCESS;

                BCMChannel = pBCR->NC_Channel;

                TRACE( TL_V, TM_Bcm, ( "   BCM Channel  %x ", BCMChannel  ) );

                fLocalHostBCRIsValid = TRUE;
                fRemoteNodeBCRIsValid = FALSE;

                break;
            }

            if (TimeOut == 0)
            {
                //
                // We've waited, retried 5 times. The IRM has not implemented the BCM
                // We need to wrest control by resetting the bus
                //
                // This happens when the remote node is still booting up.
                //
                TRACE( TL_I, TM_Bcm, ( "   nicLocalHostIsNotIrm - TIMEOUT  RESETTING") );

                fNeedToReset = TRUE;
                
            }
            
            LocalHostBCRLittleEndian   = 0;
            pBCR = NULL;


        } //while (Timeout-- != 0 )



        
        //
        // Last case: The IRM does not implement the BCR (Broadcast Channel Register). We need to wrest control
        // by issuing a Bus Reset.
        
    } while (FALSE);

    //
    // Now do the clean up work and updating of data structures that needs to be done at the end of the BCM
    // algorithm
    //
    nicLocalHostIsNotIrmPost (pAdapter,
                          pIrmRemoteNode,
                          fNeedToReset,
                          fRemoteNodeBCRIsValid ,
                          fLocalHostBCRIsValid ,
                          fDidTheBusReset,
                          pBCR  );

    //
    // If the IRM was successfuly found, then it was referenced as well.  We dereference it now
    // Ref was made in FindIRmAmongstRemoteNode
    //
    if (pIrmRemoteNode != NULL)
    {
        nicDereferenceRemoteNode (pIrmRemoteNode, "nicLocalHostIsNotIrm ");
    }

    TRACE( TL_T, TM_Bcm, ( "<==nicLocalHostIsNotIrm Status %x", NdisStatus ) );

    return NdisStatus;
 }




VOID
nicLocalHostIsNotIrmPost (
    PADAPTERCB pAdapter,
    PREMOTE_NODE pIrmRemoteNode,
    BOOLEAN fNeedToReset,
    BOOLEAN fRemoteNodeBCRIsValid ,
    BOOLEAN fLocalHostBCRIsValid ,
    BOOLEAN fDidTheBusReset,
    NETWORK_CHANNELSR*      pBCR
    )

/*++

Routine Description:
   This routine does the post processing after the Local Host Is Not Irm has completed.
   It i)resets the bus if necessary,  ii) Updates the BCR if pBCR has a valid Value
   The Boolean Variables passed in indicate the state of the BCM algorithm

Arguments:

    pAdapter - pAdapter in question,
    pIrmRemoteNode - RemoteNode that is the IRM,
    fNeedToReset - Does the bus need to be reset,
    fRemoteNodeBCRIsValid - Is the RemoteNodeBCR Valid ,
    fLocalHostBCRIsValid  - LocalHost BCR Valid,
    fDidTheBusReset - Did the bus reset during this iteration of the BCM algorithm,
    pBCR - the BCR that was passed in


Return Value:


--*/
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
        
    TRACE( TL_T, TM_Bcm, ( "==> nicLocalHostIsNotIrmPost  pAdapter %x, pIrm %x, fNeedToReset%x, fRemoteNodeBCRIsValid %x, fLocalHostBCRIsValid %x, fDidTheBusReset,%x, pBCR %x",
                                pAdapter, pIrmRemoteNode, fNeedToReset, fRemoteNodeBCRIsValid , fLocalHostBCRIsValid, fDidTheBusReset, pBCR) );

    do
    {
        
        
        if (fRemoteNodeBCRIsValid == TRUE || fLocalHostBCRIsValid == TRUE)
        {
        
            //
            // The BCM algorithm has succeeded. We need to update our internal record of
            // the IRM's BCR. In both ocde (local and Remote) the pBCR points to the BCR in little
            // endian
            //
            ASSERT (fNeedToReset == FALSE);
            //
            // One final check
            //
            ASSERT (pBCR!= NULL);
            ASSERT (pBCR->NC_Valid  == 1);

            ADAPTER_ACQUIRE_LOCK (pAdapter);


            pAdapter->BCRData.IRM_BCR.NC_One = 1;
            pAdapter->BCRData.IRM_BCR.NC_Valid = 1;
            pAdapter->BCRData.IRM_BCR.NC_Channel =  pBCR->NC_Channel;


            ASSERT ( BCR_IS_VALID (&pAdapter->BCRData.IRM_BCR) == TRUE);

            TRACE( TL_V, TM_Bcm, ( "   Updated IRM_BCM with %x ",pAdapter->BCRData.IRM_BCR ) );

            ADAPTER_RELEASE_LOCK (pAdapter);

            ASSERT (fDidTheBusReset == FALSE);
            ASSERT (fNeedToReset == FALSE);
            break;
        }

        
        if ( fNeedToReset )
        {
            //
            // If our BCR's are invalid and the IRM has gone away
            // OR if there has been a timeout, we should reset the 
            // bus to force a new BCM 
            //
            BOOLEAN NoRemoteNodes = IsListEmpty(&pAdapter->PDOList) ;

            //
            // Reset only if there are remote nodes present
            //
            if (NoRemoteNodes == FALSE)
            {
                TRACE( TL_V, TM_Bcm, ("fNeedToReset %x, RemoteNode %p\n",fNeedToReset,pIrmRemoteNode));                    
                
                nicBCMReset( pAdapter);
            }

            

            ASSERT (fRemoteNodeBCRIsValid == FALSE);
            ASSERT (fDidTheBusReset == FALSE);
            break;
        }
        
    } while (FALSE);    



    TRACE( TL_T, TM_Bcm, ( "<== nicLocalHostIsNotIrmPost  ") );


}







NDIS_STATUS
nicLocalNotIrmMandatoryWait (
    IN PADAPTERCB pAdapter,
    IN ULONG BCMGeneration,
    OUT NETWORK_CHANNELSR* pBCR
    )
    // Function Description:
    //  This function implements the mandatory portion
    //  of the local host is not Irm protion of the BCM algorithm
    //
    //   Sleeps and expects that a IRM will have written to its BCR
    //   by the time it wakes up
    //
    // Arguments
    //   pAdapter
    //
    //
    // Return Value:
    //
    //
{
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    ULONG               HighestNode = pAdapter->BCRData.pTopologyMap->TOP_Node_Count-1;
    ULONG               LocalNodeNumber = pAdapter->BCRData.LocalNodeNumber;    
    ULONG               TimeOut = 0;
    ULONG               Generation;
    ULONG               LocalHostBCRLittleEndian  = 0;
    
    ASSERT (pBCR != NULL);
    
    TRACE( TL_T, TM_Bcm, ( "==> nicLocalNotIrmMandatoryWait pAdapter %x, HighNode %x, LocalNode %x, BCMGeneration %x",
                                pAdapter, HighestNode, LocalNodeNumber, BCMGeneration) );

    
    //
    // BCM algorithm states that node must wait 15ms * IRM_ID - candidate_ID
    //

    TimeOut = HighestNode - LocalNodeNumber;

    do
    {
        if (TimeOut > 64)
        {

            ASSERT (TimeOut <= 64);
            
            NdisStatus = NDIS_STATUS_FAILURE;

            break;
        }
        
        //
        // Store the generation as a reference point. The moment the bus is reset, the gen count
        // will increment and we will need to bail out of this round of the BCM process
        //
        
        
        if (BCMGeneration != pAdapter->Generation)
        {
            
            TRACE( TL_V, TM_Bcm, ( " nicLocalHostIsNotIrm : Generations do not match " ) );

            NdisStatus = NIC1394_STATUS_INVALID_GENERATION;
            
            break;
        }

        //
        // Sleep for 15ms * IRM_ID - CandidateNodeID
        //
        NdisMSleep (TimeOut * 15000);

        //
        // First let's read our own BCR and see if someone has written a valid BCR to it.
        //
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        LocalHostBCRLittleEndian = pAdapter->BCRData.LocalHostBCRBigEndian;

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Copy it over to what pBCR points to
        //
        LocalHostBCRLittleEndian = SWAPBYTES_ULONG (LocalHostBCRLittleEndian );

        *pBCR = (*(NETWORK_CHANNELSR*)&LocalHostBCRLittleEndian );

        if ( BCR_IS_VALID(pBCR)==TRUE)
        {
            //
            // We've succeeded. Update data structures and exit. Nothing for us
            // to do as the other thread updates everything
            //
            ULONG BCMChannel  = -1;
            NdisStatus = NDIS_STATUS_SUCCESS;
            
            BCMChannel = pBCR->NC_Channel;

            TRACE( TL_V, TM_Bcm, ( "   BCM Channel  %x ", BCMChannel  ) );
            TRACE( TL_V, TM_Bcm, ( "   BCR Is valid on LocalHost BCR", pAdapter->BCRData.LocalHostBCRBigEndian) );

            NdisStatus = NDIS_STATUS_SUCCESS;
            ASSERT (BCMChannel == 31);          
            break;
        }
        else
        {
            NdisStatus = NDIS_STATUS_FAILURE;
        }


    } while (FALSE);        



    TRACE( TL_T, TM_Bcm, ( "<== nicLocalNotIrmMandatoryWait Status %x , pBCR %x", NdisStatus, pBCR) );

    return NdisStatus;
}
    








NDIS_STATUS
nicReadIrmBcr (
    PREMOTE_NODE pIrmRemoteNode,
    IN PMDL pBCRMdl,
    IN ULONG GivenGeneration,
    OUT PBOOLEAN pfDidTheBusReset
    )
    // Function Description:
    //   Purpose is to do an async read on the IRM's BCR and see if it is set.
    // Arguments
    //   pIrmRemoteNode  - The remote node (IRM)
    //   pBCRMdl The MDL that will contain the remote node's BCR. Needs to preinitialized
    // Return Value:
    //  Success - If Irp succeeded. Appropriate Error code otherwise
    //   If the Generation is incorrect. the call will be failed
    //
    //


{
    NDIS_STATUS                         NdisStatus = NDIS_STATUS_FAILURE;
    IO_ADDRESS                          Destination;
    PNETWORK_CHANNELS         pBCR = NULL;
    NTSTATUS                            NtStatus = STATUS_UNSUCCESSFUL;
    

    TRACE( TL_T, TM_Bcm, ( "==>nicReadIrmBcr  pIrm %x, pMdl %x, GivenGeneration %x",
                             pIrmRemoteNode, pBCRMdl, GivenGeneration) );

    ASSERT (pBCRMdl != NULL);
    ASSERT (pIrmRemoteNode != NULL);

    pBCR = NIC_GET_SYSTEM_ADDRESS_FOR_MDL(pBCRMdl);


    Destination.IA_Destination_Offset.Off_Low = INITIAL_REGISTER_SPACE_LO | NETWORK_CHANNELS_LOCATION;
    Destination.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;

    
    do 
    {
        if (pBCR == NULL)
        {
            break;
        }
    
        pBCR->NC_Valid = 0;


        if (pIrmRemoteNode->pAdapter->Generation != GivenGeneration)
        {
            
            TRACE( TL_A, TM_Bcm, ( "nicReadIrmBcr : Generation Mismatch orig %x, curr %x", GivenGeneration , pIrmRemoteNode->pAdapter->Generation) );
            
            NdisStatus = NDIS_STATUS_DEST_OUT_OF_ORDER;

            *pfDidTheBusReset = TRUE;

            break;
        }

        if (REMOTE_NODE_TEST_FLAG (pIrmRemoteNode, PDO_Removed))
        {
           NdisStatus = NDIS_STATUS_DEST_OUT_OF_ORDER;
           break;
        }
            
        //
        // We have a correct generation count
        //
        *pfDidTheBusReset = FALSE;  

        NdisStatus = nicAsyncRead_Synch(  pIrmRemoteNode,
                                          Destination,
                                          sizeof(NETWORK_CHANNELSR),  // Number of bytes to Read
                                          sizeof (NETWORK_CHANNELSR),  // Block Size
                                          0, // fulFlags,
                                          pBCRMdl ,
                                          GivenGeneration,
                                          &NtStatus);
                        

    } while (FALSE);

    if (NtStatus == STATUS_INVALID_GENERATION )
    {
        *pfDidTheBusReset = TRUE;
    }
    
    TRACE( TL_I, TM_Bcm, ( "   nicReadIrmBcr pBCRMdl %x, BCR %x ", pBCRMdl, *pBCR ) );

    TRACE( TL_T, TM_Bcm, ( "<==nicReadIrmBcr  Status %x, fDidTheBusReset %x", NdisStatus ,*pfDidTheBusReset ) );

    return NdisStatus;

}











NDIS_STATUS
nicScheduleBCMWorkItem(
    PADAPTERCB pAdapter
    )

/*++

Routine Description:
 This function queues a workitem to kick of the BCM algorithm.

 If there is already a BCM in progress, (look at BCM_WorkItem flag)
 it simply returns.

 It is the responsiblity of the caller to mark the invocation of BCMAlgorithm as
 dirty, thereby forcing it to restart the BCM (by setting the InvalidGeneration of the
 new Node Arrived Flags)

Arguments:
 pAdapter -     Adapter

Return Value:


--*/
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS_WORK_ITEM pBCMWorkItem;
    BOOLEAN fBCMWorkItemInProgress = FALSE;
    
    TRACE( TL_T, TM_Bcm, ( "==>nicScheduleBCMWorkItem pAdapter %x", pAdapter ) );

    do
    {
        if (BCR_TEST_FLAG(pAdapter, BCR_Initialized)== FALSE)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        pBCMWorkItem = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM);
                    
        if (pBCMWorkItem == NULL )
        {
            TRACE( TL_A, TM_Cm, ( "Local Alloc failed for WorkItem" ) );
    
            NdisStatus = NDIS_STATUS_RESOURCES;
    
            break;
        }
        else
        {   
            //
            // From here on, this function cannot fail.
            //
            NdisStatus = NDIS_STATUS_SUCCESS;
        }


        //
        // reference the adapter as it is going to passed to a workiter.
        // decremented in the workitem
        //
        nicReferenceAdapter(pAdapter, "nicScheduleBCMWorkItem ");


            
        NdisInitializeWorkItem ( pBCMWorkItem,
                                (NDIS_PROC) nicBCMAlgorithmWorkItem,
                                (PVOID) pAdapter);

        TRACE( TL_V, TM_Cm, ( "Scheduling BCM WorkItem" ) );

            
        NdisScheduleWorkItem (pBCMWorkItem);

    } while (FALSE);


    TRACE( TL_T, TM_Bcm, ( "<==nicScheduleBCMWorkItem %x  ", NdisStatus ) );

    return NdisStatus;
}


VOID
nicSetEventMakeCall (
    IN PADAPTERCB pAdapter
    )

    // Function Description:
    //  The Sets the event that a Broadcast channel Make Call might be waiting for
    //
    // Arguments
    // Adapter - this is passed to the workitem
    //
    //
    // Return Value:
    //  Failure if allocation of workitem failed
    //
{
    TRACE( TL_T, TM_Bcm, ( "==> nicSetEventMakeCall  pAdapter %x", pAdapter) );


    //
    // now inform a waiting channel Vc to move on. If the BCR is not active.
    // it will continue waiting till the next round
    //
    if (BCR_IS_VALID(&(pAdapter->BCRData.IRM_BCR))==TRUE)
    {
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        if (BCR_TEST_FLAG (pAdapter, BCR_MakeCallPending) == TRUE)
        {
            TRACE( TL_V, TM_Bcm, ( "    We found a waiting call ") );
            NdisSetEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent);            

        }
        else
        {
            TRACE( TL_V, TM_Bcm, ( "    No Call Waiting") );

        }

        ADAPTER_RELEASE_LOCK (pAdapter);


    }



    TRACE( TL_T, TM_Bcm, ( "<==nicSetEventMakeCall ") );


}



VOID
nicUpdateLocalHostNodeAddress (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:

    This function queries the Bus driver for the Local Node Address of 
    the Adapter 

    If the Node Address has changed, it updates the GaspHeader 
    

Arguments:

 pAdapter -     Adapter

Return Value:


--*/
{
    NODE_ADDRESS LocalNodeAddress, OldNodeAddress;
    NDIS_STATUS NdisStatus;

    OldNodeAddress = pAdapter->NodeAddress;

    NdisStatus = nicGet1394AddressFromDeviceObject( pAdapter->pNdisDeviceObject,
                                                &LocalNodeAddress,
                                                USE_LOCAL_NODE );

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        pAdapter->NodeAddress = LocalNodeAddress;

        // If the Node Address has changed , then update the GaspHeader
        //
        if (FALSE == NdisEqualMemory (&LocalNodeAddress,&OldNodeAddress, sizeof(NODE_ADDRESS) ) )
        {
            nicMakeGaspHeader (pAdapter, &pAdapter->GaspHeader);
        }
        
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\bcm.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// mp.h
//
// IEEE1394 mini-port/call-manager driver
//
// Broadcast Channel Manager - header file
//
// 07/05/99 ADube - Created - Declaration for miniport routines
//


//
// Various timeout used throught the BCM algorithm
//
#define ONE_SEC 1000000
#define ONE_MINUTE 60000 
#define FIFTY_MILLISECONDS 50000

#define BCM_NUM_RETRY 5
#define BCM_GENERIC_TIMEOUT 50000 // 50msec
#define BCM_WAIT_FOR_EVENT_TIME 60000000 // 60sec


//
// BCR Register flags in the BigEndian and little Endian format
//
#define BCR_IMPLEMENTED_BIG_ENDIAN              0x00000080
#define BCR_IMPLEMENTED_LITTLE_ENDIAN           0x80000000

#define BCR_VALID_BIG_ENDIAN                    0x000000C0
#define BCR_VALID_LITTLE_ENDIAN                 0xC0000000 


typedef struct _BCM_CONTEXT 
{
    ULONG Generation;
    PADAPTERCB pAdapter;

}BCM_CONTEXT, *PBCM_CONTEXT;



//
//  Broadcast Channel Manager functions begin here
//


VOID
nicBCRAccessedCallback (
    IN PNOTIFICATION_INFO pNotificationInfo
    );


VOID
nicBCMAbort (
    IN PADAPTERCB pAdapter,
    IN PREMOTE_NODE pRemoteNode
    );

    

VOID
nicBCMAddRemoteNode (
    IN PADAPTERCB pAdapter, 
    IN BOOLEAN fIsOnlyRemoteNode 
    );



VOID
nicBCMAlgorithm(
    PADAPTERCB pAdapter,
    ULONG BcmGeneration
    );


VOID
nicBCMAlgorithmWorkItem(
    PNDIS_WORK_ITEM pWorkItem,
    PVOID   Context
    );

VOID
nicBCMCheckLastNodeRemoved(
    IN PADAPTERCB pAdapter
    );


NDIS_STATUS
nicFindIrmAmongRemoteNodes (
    IN PADAPTERCB pAdapter,
    IN ULONG BCMGeneration, 
    OUT PPREMOTE_NODE ppIrmRemoteNode
    );
    

VOID
nicFreeBroadcastChannelRegister(
    IN PADAPTERCB pAdapter
    );
    

NDIS_STATUS
nicInformAllRemoteNodesOfBCM (
    IN PADAPTERCB pAdapter
    );

NDIS_STATUS
nicInitializeBroadcastChannelRegister (
    PADAPTERCB pAdapter
    );


NDIS_STATUS
nicIsLocalHostTheIrm(
    IN PADAPTERCB pAdapter, 
    OUT PBOOLEAN pfIsLocalHostIrm,
    OUT PPTOPOLOGY_MAP  ppTopologyMap,
    OUT PNODE_ADDRESS pLocalHostAddress
    );


NDIS_STATUS
nicLocalHostIsIrm(
    IN PADAPTERCB pAdapter
    );



NDIS_STATUS
nicLocalHostIsNotIrm (
    IN PADAPTERCB pAdapter,
    IN ULONG CurrentGeneration
    );


NDIS_STATUS
nicLocalNotIrmMandatoryWait (
    IN PADAPTERCB pAdapter,
    IN ULONG BCMGeneration,
    OUT NETWORK_CHANNELSR* pBCR
    );



NDIS_STATUS
nicReadIrmBcr (
    PREMOTE_NODE pIrmRemoteNode,
    IN PMDL pBCRMdl,
    IN ULONG GivenGeneration,
    OUT PBOOLEAN fDidTheBusReset
    );


NDIS_STATUS
nicRetryToReadIrmBcr( 
    PREMOTE_NODE pIrmRemoteNode, 
    PMDL pRemoteBCRMdl,                                           
    ULONG Generation,
    PBOOLEAN pfDidTheBusReset
    ); 


NDIS_STATUS
nicScheduleBCMWorkItem(
    PADAPTERCB pAdapter
    );  


VOID
nicSetEventMakeCall (
    IN PADAPTERCB pAdapter
    );





    



    


VOID
nicLocalHostIsNotIrmPost (
    PADAPTERCB pAdapter,
    PREMOTE_NODE pIrmRemoteNode,
    BOOLEAN fNeedToReset, 
    BOOLEAN fRemoteNodeBCRIsValid , 
    BOOLEAN fLocalHostBCRIsValid ,
    BOOLEAN fDidTheBusReset, 
    NETWORK_CHANNELSR*      pBCR
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\inc\rfc2734.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    rfc.h

Abstract:

    Structures and constants from the IP/1394 RFC 2734, which can be found at:
            http://www.ietf.org/rfc/rfc2734.txt 

Revision History:

    Who         When        What
    --------    --------    ----
    josephj     03-28-99    created, based on draft version 14.

--*/

#pragma pack (push, 1)

// ARP request/response pkt, including the unfragmented encapsulation header.
//
typedef struct _IP1394_ARP_PKT
{
    NIC1394_UNFRAGMENTED_HEADER header;
     
    // hardware_type is a constant that identifies IEEE1394. This field must be set
    // to IP1394_HARDWARE_TYPE, defined below. This field must be byte-swapped
    // before the packet is sent out over the wire.
    //
    USHORT                      hardware_type;

    #define IP1394_HARDWARE_TYPE    0x0018

    // protocol_type is a constant that identifies this ARP packet as being an
    // IPV4 ARP packet. This field must be set to IP1394_PROTOCOL_TYPE, defined
    // below. This field must be byte-swapped before the packet is sent out over the
    // wire.
    //
    USHORT                      protocol_type;

    #define IP1394_PROTOCOL_TYPE    0x0800

    // hw_addr_len is the size (in octets) of the senders hw address, which 
    // consists of the following:
    //      sender_unique_ID            (8 bytes)
    //      sender_maxrec               (1 byte)
    //      sspd                        (1 byte)
    //      sender_unicast_FIFO_hi      (2 bytes)
    //      sender_unicast_FIFO_lo      (4 bytes)
    // This field must be set to IP1394_HW_ADDR_LEN, defined below.
    //
    UCHAR                       hw_addr_len;

    #define IP1394_HW_ADDR_LEN  16

    // IP_addr_len is the size of the IP address field. It must be set to
    // sizeof (ULONG).
    //
    UCHAR                       IP_addr_len;


    // opcode should be set to either IP1394_ARP_REQUEST (for ARP request packets)
    // or to IP1394_ARP_RESPONSE (for ARP response packets). Both constants are
    // defined below. This field must be byte-swapped before the packet is sent out
    // over the wire.
    //
    USHORT                      opcode;

    #define IP1394_ARP_REQUEST      1
    #define IP1394_ARP_RESPONSE     2

    //
    // The following 5 fields constitute the sender's hardware address.
    //

    // sender_unique_ID is the sender's unique ID, in network byte order.
    //
    UINT64                      sender_unique_ID;

    // sender_maxrec is the value of max_rec in the sender's configuration ROM
    // bus information block. The following formula converts from max_rec to
    // size in bytes (from "FireWire System Architecture", 1st ed, pp 225 (or look
    // for max_rec in the index)):
    //          size = 2^(max_rec+1)
    // The minimum value of max_rec is 0x1.
    // The maximun value of max_rec is 0xD.
    //          
    // The macros immediately below may be used to convert from max_rec to
    // bytes, and to verify that max_rec is within the valid range.
    //
    UCHAR                       sender_maxrec;

    #define IP1394_MAXREC_TO_SIZE(_max_rec)  (2 << ((_max_rec)+1))
    #define IP1394_IS_VALID_MAXREC(_max_rec) ((_max_rec)>0 && (_max_rec)<0xE)


    // sspd encodes "sender speed", which is the lesser of the sender's link speed
    // and the PHY speed. ssped must be set to one of the IP1394_SSPD_* constants,
    // defined below.
    //
    UCHAR                       sspd;

    #define IP1394_SSPD_S100    0
    #define IP1394_SSPD_S200    1
    #define IP1394_SSPD_S400    2
    #define IP1394_SSPD_S800    3
    #define IP1394_SSPD_S1600   4
    #define IP1394_SSPD_S3200   5
    #define IP1394_IS_VALID_SSPD(_sspd) ((_sspd)<=5)

    //  sender_unicast_FIFO_hi is the high 16-bits of the sender's 48-bit FIFO
    //  address offset, in network byte order.
    //
    USHORT                      sender_unicast_FIFO_hi;

    //  sender_unicast_FIFO_lo is the low 32-bits of the sender's 48-bit FIFO
    //  address offset, in network byte order.
    //
    ULONG                       sender_unicast_FIFO_lo;

    //  sender_IP_address is the sender's IP address, in network byte order.
    //
    ULONG                       sender_IP_address;

    //  target_IP_address is the target's IP address, in network byte order.
    //  This field is ignored if opcode is set to IP1394_ARP_RESPONSE
    //
    ULONG                       target_IP_address;
    
} IP1394_ARP_PKT, *PIP1394_ARP_PKT;



// MCAP group descriptor format (one or more per MCAP packet)
//
typedef struct _IP1394_MCAP_GD
{
    // size, in octets, of this descriptor.
    //
    UCHAR                       length;

    // Type of descriptor. One of the IP1394_MCAP_GD_TYPE_* values below
    //
    UCHAR                       type;

    #define IP1394_MCAP_GD_TYPE_V1 1 // IP multicast MCAP Ver 1.

    // Reserved
    //
    USHORT                      reserved;

    // Expiration (TTL) in seconds
    //
    UCHAR                       expiration;

    // Channel number
    //
    UCHAR                       channel;

    // Speed code.
    //
    UCHAR                       speed;

    // Reserved
    //
    UCHAR                       reserved2;

    // Bandwidth (unused)
    //
    ULONG                       bandwidth;

    //  IP multicast group  address
    // (In theory it could be of arbitrary length, computed by
    //  looking at the "length" field above. However for our purposes
    //  (type==1) we expect the group_address size to be 4.
    //
    ULONG                       group_address;
    
} IP1394_MCAP_GD, *PIP1394_MCAP_GD;


// MCAP message format, including the unfragmented encapsulation header.
//
typedef struct _IP1394_MCAP_PKT
{
    NIC1394_UNFRAGMENTED_HEADER header;
     
    // size, in octets, of the entire MCAP message (NOT including the 
    // encapsulation header).
    //
    USHORT                      length;

    // Reserved
    //
    UCHAR                       reserved;

    // Opcode -- one of the IP1394_MCAP_OP* values below.
    //
    UCHAR                       opcode;

    #define IP1394_MCAP_OP_ADVERTISE    0
    #define IP1394_MCAP_OP_SOLICIT      1

    // zero or more group address descriptors
    //  
    IP1394_MCAP_GD              group_descriptors[1];
    
} IP1394_MCAP_PKT, *PIP1394_MCAP_PKT;


/*

RFC NOTES and COMMENTS

    1. No max channel expiery. Min expiery is 60sec

Extracts from the RFC re MCAP:

    speed: This field is valid only for advertise messages, in which
    case it SHALL specify the speed at which stream packets for the
    indicated channel are transmitted. Table 2 specifies the encoding
    used for speed.

    A recipient of an MCAP
    message SHALL examine the most significant ten bits of source_ID from
    the GASP header; if they are not equal to either 0x3FF or the most
    significant ten bits of the recipient's NODE_IDS register, the
    recipient SHALL IGNORE the message.

    Subsequent to sending a solicitation request, the
    originator SHALL NOT send another MCAP solicitation request until ten
    seconds have elapsed.

    If no MCAP advertise message is received for a particular group
    address within ten seconds, no multicast source(s) are active for
    channel(s) other than the default. Either there is there is no
    multicast data or it is being transmitted on the default channel.

    Once 100 ms elapses subsequent to the initial
    advertisement of a newly allocated channel number , the multicast
    source may transmit IP datagrams using the channel number advertised.

    Except when a channel owner intends to relinquish ownership (as
    described in 9.7 below), the expiration time SHALL be at least 60
    seconds in the future measured from the time the advertisement is
    transmitted.

    No more than ten seconds SHALL elapse from the transmission of its
    most recent advertisement before the owner of a channel mapping
    initiates transmission of the subsequent advertisement. The owner of
    a channel mapping SHOULD transmit an MCAP advertisement in response
    to a solicitation as soon as possible after the receipt of the
    request.

    MCAP advertisements whose
    expiration field has a value less than 60 SHALL be ignored for the
    purpose of overlapped channel detection. 

    The channel numbers
    advertised by owners with smaller physical IDs are invalid; their
    owners SHALL cease transmission of both IP datagrams and MCAP
    advertisements that use the invalid channel numbers. As soon as these
    channel mappings expire , their owners SHALL deallocate any unused
    channel numbers as described in 9.8 below.

    If the original owner
    observes an MCAP advertisement for the channel to be relinquished
    before its own timer has expired, it SHALL NOT deallocate the channel
    number.

    If the
    intended owner of the channel mapping observes an MCAP advertisement
    whose expiration field is zero, orderly transfer of the channel(s)
    from the former owner has failed. 

    A channel mapping expires when expiration seconds have elapsed since
    the most recent MCAP advertisement. At this time, multicast
    recipients SHALL stop reception on the expired channel number(s).
    Also at this time, the owner of the channel mapping(s) SHALL transmit
    an MCAP advertisement with expiration cleared to zero and SHALL
    continue to transmit such advertisements until 30 seconds have
    elapsed since the expiration of the channel mapping.


    If an IP-capable device observes an MCAP advertisement whose
    expiration field is zero, it SHALL NOT attempt to allocate any of the
    channel number(s) specified until 30 seconds have elapsed since the
    most recent such advertisement.

9.10 Bus reset

    A bus reset SHALL invalidate all multicast channel mappings and SHALL
    cause all multicast recipients and senders to zero all MCAP
    advertisement interval timers.

    Intended or prior recipients or transmitters of multicast on other
    than the default channel SHALL NOT transmit MCAP solicitation
    requests until at least ten seconds have elapsed since the completion
    of the bus reset.  Multicast data on other than the default channel
    SHALL NOT be received or transmitted until an MCAP advertisement is
    observed or transmitted for the IP multicast group address.
    Intended or prior transmitters of multicast on other than the default
    channel that did not own a channel mapping for the IP multicast group
    address prior to the bus reset SHALL NOT attempt to allocate a
    channel number from the isochronous resource manager's
    CHANNELS_AVAILABLE register until at least ten seconds have elapsed
    since the completion of the bus reset.


*/
#pragma pack (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\ccdefs.h ===
//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// The NDIS version we report when registering mini-port and address family.
//
#define NDIS_MajorVersion 5
#define NDIS_MinorVersion 0
#define NIC1394_MajorVersion 5
#define NIC1394_MinorVersion 1

#define MAX_PACKET_POOL_SIZE 0xFFFF
#define MIN_PACKET_POOL_SIZE 0x100

#define NOT !
#define IS ==
#define AND &&
#define OR ||
#define NOT_EQUAL !=

#if TODO
// Verify the following (I randomly picked 4096 here)...
#endif
#define Nic1394_MaxFrameSize    4096
#define WAIT_INFINITE 0
#define MAX_CHANNEL_NUMBER 63 
#define BROADCAST_CHANNEL 31
#define GASP_SPECIFIER_ID_HI 0
#define GASP_SPECIFIER_ID_LO 0x5E
#define INVALID_CHANNEL 0xff
#define HEADER_FRAGMENTED_MASK 0xC0000000
#define MAX_ALLOWED_FRAGMENTS 20
#define MCAST_LIST_SIZE                 32
#define ISOCH_TAG 3 // Set to 3 in accordance with 1394a spec. Clause 8.2 - Gasp Header
#define MAX_NUMBER_NODES 64  
#define QUEUE_REASSEMBLY_TIMER_ALWAYS 0


//
// Compile options
//
#define FALL_THROUGH
#define INTEROP
#define SEPERATE_CHANNEL_TYPE 1
#define INTERCEPT_MAKE_CALL 0
#define TRACK_FAILURE 1
#define USE_KLOCKS 1
#define FIFO_WRAPPER 0
#define NUM_RECV_FIFO_FIRST_PHASE 20
#define NUM_RECV_FIFO_BUFFERS   256


#ifdef Win9X

    #define _ETHERNET_ 1 

    #define PACKETPOOL_LOCK 0  // Serialize access to the packet pool
    #define QUEUED_PACKETS 1  // Serializes Recieve Indications to TCP.IP

    #if QUEUED_PACKETS 
        #define QUEUED_PACKETS_STATS 1
    #endif  
    

#endif

//
// If this is a Win2K compilation 
//

#ifdef Win2K
    #define _ETHERNET_ 1 
    #define TRACK_LOCKS 0
    #define QUEUED_PACKETS 0  // Serializes Recieve Indications to TCP.IP
    
    #ifdef DBG
    #define PKT_LOG 1
    #endif
    //#define LOWER_SEND_SPEED 1  // Lower the send speed temprarily

#endif


#define DO_TIMESTAMPS 0

#if DO_TIMESTAMPS 
    #define ENTRY_EXIT_TIME 0
    #define INIT_HALT_TIME 1
#else
    #define ENTRY_EXIT_TIME 0
    #define INIT_HALT_TIME 0
#endif


#define TESTMODE 0


//
// Constants used to tag data structures like NdisPackets and IsochDescriptors
// For informational purposes only
//
#define NIC1394_TAG_INDICATED       'idnI'
#define NIC1394_TAG_QUEUED          'ueuQ'
#define NIC1394_TAG_RETURNED        'uteR'
#define NIC1394_TAG_ALLOCATED       'ollA'
#define NIC1394_TAG_FREED           'eerF'
#define NIC1394_TAG_REASSEMBLY      'sseR'
#define NIC1394_TAG_COMPLETED       'pmoC'
#define NIC1394_TAG_IN_SEND         'dneS'
#define NIC1394_TAG_IN_CALLBACK     'llaC'



#define ADAPTER_NAME_SIZE 128

#define ANSI_ARP_CLIENT_DOS_DEVICE_NAME "\\\\.\\ARP1394"

#define NOT_TESTED_YET 0

//
// The 1394 constants for 800 and above are not defined in
// 1394.h Make temporary local definitions.
//
#define ASYNC_PAYLOAD_800_RATE_LOCAL      4096
#define ASYNC_PAYLOAD_1600_RATE_LOCAL      (4096*2)
#define ASYNC_PAYLOAD_3200_RATE_LOCAL      (4096*4)

#define MAX_REC_800_RATE_LOCAL  (MAX_REC_400_RATE+1)
#define MAX_REC_1600_RATE_LOCAL  (MAX_REC_800_RATE_LOCAL + 1)
#define MAX_REC_3200_RATE_LOCAL  (MAX_REC_1600_RATE_LOCAL + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\cm.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// cm.c
//
// IEEE1394 mini-port/call-manager driver
//
// Call Manager routines
//
// 12/28/1998 JosephJ Created
// 01/01/1999 ADube modified - Added Remote Node Capability 
//

#include "precomp.h"

    
//-----------------------------------------------------------------------------
// Call-manager handlers and completers
//-----------------------------------------------------------------------------

NDIS_STATUS
NicCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext )

    // Standard 'CmCmOpenAfHandler' routine called by NDIS when a client
    // requests to open an address family.  See DDK doc.
    //
{
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hExistingAf;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    TIMESTAMP_ENTRY ("==>Open Af");


    TRACE( TL_T, TM_Cm, ( "==>NicCmOpenAf" ) );

    pAdapter = (ADAPTERCB* )CallMgrBindingContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    if (AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_1394
        || AddressFamily->MajorVersion != NDIS_MajorVersion
        || AddressFamily->MinorVersion != NDIS_MinorVersion)
    {
        return NDIS_STATUS_BAD_VERSION;
    }


    do
    {
        AFCB *pAF  = NULL;

        // Allocate and initialize the adress family structure.
        //
        pAF = ALLOC_NONPAGED( sizeof(*pAF), MTAG_AFCB );
        if (!pAF)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        NdisZeroMemory( pAF, sizeof(*pAF) );


        // Set a marker for easier memory dump browsing and future assertions.
        //
        pAF->ulTag = MTAG_AFCB;
    
        // Save the NDIS handle associated with this AF for use in future
        // NdisXxx calls.
        //

        ADAPTER_ACQUIRE_LOCK( pAdapter );

        pAF->NdisAfHandle = NdisAfHandle;
    
    
        // Initialize the VC list for this AF.
        //
        InitializeListHead( &pAF->AFVCList );
    
    
        // Set up linkages and references.
        //
        pAF->pAdapter = pAdapter;
        nicReferenceAF( pAF );           // OpenAF
        nicReferenceAdapter( pAdapter ,"NicCmOpenAf "); // OpenAF

        InsertHeadList(&pAdapter->AFList, &pAF->linkAFCB);
    
        // Return pAF as the address family context.
        //
        *CallMgrAfContext = (PNDIS_HANDLE )pAF;

        

        ADAPTER_RELEASE_LOCK (pAdapter);

    } while (FALSE);


    TRACE( TL_T, TM_Cm, ( "NicCmOpenAf Status %x", Status ) );

    TIMESTAMP_EXIT("<==Open Af ");

    return Status;
}


NDIS_STATUS
NicCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext )

    // Standard 'CmCloseAfHandler' routine called by NDIS when a client
    // requests to close an address family.  See DDK doc.
    //
{
    AFCB* pAF;
    TIMESTAMP_ENTRY ("==>CloseAf");
    
    TRACE( TL_T, TM_Cm, ( "NicCmCloseAf" ) );

    pAF = (AFCB* )CallMgrAfContext;
    
    if (pAF->ulTag != MTAG_AFCB)
    {
        ASSERT( !"AFCB?" );
        return NDIS_STATUS_INVALID_DATA;
    }
    
    
    nicSetFlags (&pAF->ulFlags, ACBF_ClosePending);



    // This dereference will eventually lead to us calling
    // NdisMCmCloseAfComplete.
    //

    //
    // The references that were made in OpenAf
    //
    nicDereferenceAF( pAF ); 



    TRACE( TL_T, TM_Cm, ( "NicCmCloseAf pending" ) );
    
    TIMESTAMP_EXIT ("<==Close Af");

    return NDIS_STATUS_PENDING;
}



NDIS_STATUS
NicCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext )

    // Standard 'CmCreateVc' routine called by NDIS in response to a
    // client's request to create a virtual circuit.  This
    // call must return synchronously.
    //
{
    NDIS_STATUS status;
    AFCB* pAF;
    VCCB* pVc;

   
    TRACE( TL_T, TM_Cm, ( "==>NicCmCreateVc, Af %x",ProtocolAfContext) );
    
    pAF = (AFCB* )ProtocolAfContext;
    if (pAF->ulTag != MTAG_AFCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // Allocate and zero a VC control block, then make any non-zero
    // initializations.
    //
    pVc = ALLOC_VCCB( pAdapter );
    if (!pVc)
    {
        ASSERT( !"Alloc VC?" );
        return NDIS_STATUS_RESOURCES;
    }

    NdisZeroMemory( pVc, sizeof(*pVc) );

    TRACE( TL_I, TM_Cm, ( "NicCmCreateVc $%p", pVc ) );

    // Set a marker for easier memory dump browsing.
    //
    pVc->Hdr.ulTag = MTAG_VCCB;


    // Save the NDIS handle of this VC for use in indications to NDIS later.
    //
    pVc->Hdr.NdisVcHandle = NdisVcHandle;

    #if TODO // Adapt to 1394
    // Initialize link capabilities to the defaults for the adapter.
    //
    {
        NDIS_WAN_CO_INFO* pwci = &pAdapter->info;
        NDIS_WAN_CO_GET_LINK_INFO* pwcgli = &pVc->linkinfo;

        NdisZeroMemory( &pVc->linkinfo, sizeof(pVc->linkinfo) );
        pwcgli->MaxSendFrameSize = pwci->MaxFrameSize;
        pwcgli->MaxRecvFrameSize = pwci->MaxFrameSize;
        pwcgli->SendFramingBits = pwci->FramingBits;
        pwcgli->RecvFramingBits = pwci->FramingBits;
        pwcgli->SendACCM = pwci->DesiredACCM;
        pwcgli->RecvACCM = pwci->DesiredACCM;
    }
    #endif // TODO


    // The VC control block's address is the VC context we return to NDIS.
    //
    *ProtocolVcContext = (NDIS_HANDLE )pVc;

    // Add a reference to the control block and the associated address family
    // that is removed by LmpCoDeleteVc. Add the linkages.
    //
    pVc->Hdr.pAF = pAF;
    // Initialize the VC's copy of the spinlock to point to the Adapter's spinlock.
    //
    pVc->Hdr.plock =  &pAF->pAdapter->lock;

    nicReferenceVc( pVc );  // Create VC
    nicReferenceAF( pAF );  // Create VC
    

    VC_SET_FLAG (pVc, VCBF_VcCreated);
    
    // Add to list of VC's associated with this AF
    //
    AF_ACQUIRE_LOCK (pAF);
    
    InsertHeadList(&pAF->AFVCList, &pVc->Hdr.linkAFVcs);

    AF_RELEASE_LOCK (pAF);

    TRACE( TL_T, TM_Cm, ( "<==NicCmCreateVc=0" ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
NicCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext )

    // Standard 'CmDeleteVc' routine called by NDIS in response to a
    // client's request to delete a virtual circuit.  This
    // call must return synchronously.
    //
{
    VCCB* pVc = NULL;
    AFCB *pAF = NULL;
    PADAPTERCB pAdapter = NULL;

    TRACE( TL_T, TM_Cm, ( "==>NicCmDelVc($%p)", ProtocolVcContext ) );

    pVc = (VCCB* )ProtocolVcContext;
    if (pVc->Hdr.ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

        
    VC_ACQUIRE_LOCK (pVc);
    
    // Set vc flag to deleted, and remove back pointer to AF
    //
    {


        // This flag catches attempts by the client to delete the VC twice.
        //
        if (nicReadFlags( &pVc->Hdr.ulFlags ) & VCBF_VcDeleted)
        {
            TRACE( TL_A, TM_Cm, ( "VC $%p re-deleted?", pVc ) );

            VC_RELEASE_LOCK ( pVc );

            ASSERT (0);
            return NDIS_STATUS_FAILURE;
        }
        nicSetFlags( &pVc->Hdr.ulFlags, VCBF_VcDeleted );

        pAF = pVc->Hdr.pAF;
        
        
    }
    


    // Unlink from the AF vc list.
    //
    {

        nicRemoveEntryList (&pVc->Hdr.linkAFVcs);
        InitializeListHead (&pVc->Hdr.linkAFVcs);

        pVc->Hdr.pAF = NULL;

    }

    

    VC_RELEASE_LOCK (pVc);
    

    // Remove the references added by NicCmCreateVc.
    //
    nicDereferenceAF( pAF );

    //
    // This deref could cause the Vc to be deleted. Don't touch the Vc after that
    //
    nicDereferenceVc( pVc );



    TRACE( TL_T, TM_Cm, ( "<==NicCmDelVc 0"  ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
NicCmDeleteVcSpecificType(
    IN PVCCB pVc)
    // The purpose of this function is to delete all the 
    // buffers and structures that have allocated by the VC block 
    // This will be expanded to more than one function as we 
    // implement more VC types and 


{

    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Cm, ( "==>NicCmDelVc, pVc %x",pVc) );

    #ifdef TODO
    
    // switch on VCTYpe

    // if RecvFIFOVc
    // Send the Free Address Range Irb to the bus driver, so it stops issueing callbacks
    // Free all the memory on the Fifo S-List
    // Make sure to dereference for each MDL freed. Also will need to make a change in 
    // allocation routine to increment the refcount when a NEW mdl is pushed into the SLISt

    #endif
    TRACE( TL_T, TM_Cm, ( "<==NicCmDelVc, Status %x", NdisStatus ) );
    return NdisStatus;
}



NDIS_STATUS
NicCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS pCallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext )

    // Function Description:
    //
    // Standard 'CmMakeCallHandler' routine called by NDIS when the a client
    // has requested to connect to a remote end-point.  See DDK doc.
    //
    // Arguments
    // Call Mge context: 
    // Call Parameters 
    // Optiuonal NdisPartyHandle
    // Return Value:
    //
    //

{

    PVCCB pVc                                   = (VCCB* )CallMgrVcContext;
    NDIS_STATUS NdisStatus                      = NDIS_STATUS_FAILURE;
    PADAPTERCB pAdapter                         = NULL;
    NDIS_WORK_ITEM* pMakeCallCompleteWorkItem   = NULL; 

    
    PCO_MEDIA_PARAMETERS pMediaParams = pCallParameters->MediaParameters;   
    
    PNIC1394_MEDIA_PARAMETERS pN1394Params = (PNIC1394_MEDIA_PARAMETERS) pMediaParams->MediaSpecific.Parameters;

    TRACE( TL_T, TM_Cm, ( "==>NicCmMakeCall" ) );

    nicInterceptMakeCallParameters(pMediaParams); 


    do 
    {

    
        if (NdisPartyHandle != NULL || 
            pVc == NULL  ||
            pCallParameters == NULL ||
            pCallParameters->MediaParameters == NULL ||
            pCallParameters->MediaParameters->MediaSpecific.ParamType != NIC1394_MEDIA_SPECIFIC ||
            pN1394Params->MTU == 0)
        {
            //
            // We do not support these parameters
            //
            return NDIS_STATUS_FAILURE;
        }

        
        pAdapter = pVc->Hdr.pAF->pAdapter;
        ASSERT (pAdapter != NULL);


        //
        // Reference the Vc so it does not go during this makeCall
        // This is decremented in the failure code path or the workitem or 
        // when the call is closed 

        VC_ACQUIRE_LOCK (pVc);
            
        nicReferenceVc (pVc);

        //
        // Erase all references to past calls
        //
        VC_CLEAR_FLAGS (pVc, VCBM_NoActiveCall);
        
        VC_SET_FLAG (pVc, VCBF_MakeCallPending);
        //
        // Initialize the Call's refcount to 1 beacuse we are about to begin to allocate resources to the MakeCall
        // This will be decremented in the closecall handler. Or in the failure code path
        //
        nicInitializeCallRef (pVc);

        VC_RELEASE_LOCK (pVc);


        pVc->Hdr.pCallParameters = pCallParameters;
        
        NdisStatus = nicCmGenericMakeCallInit (pVc);
    

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "nicCmGenericMakeCallInit did not succeed- Make Call FAILED($%p)", CallMgrVcContext ) );      
            break;
        }
        //
        // If status is pending it means that we want to make this an asynchronous call
        // The completing th

        pMakeCallCompleteWorkItem = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM); 

        if (pMakeCallCompleteWorkItem == NULL)
        {
            TRACE( TL_A, TM_Cm, ( "Local Alloc failed for WorkItem - Make Call FAILED($%p)", CallMgrVcContext ) );
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
            
        }

        //
        // Now schedule the work item so it runs at passive level and pass the Vc as
        // an argument
        //

        NdisInitializeWorkItem ( pMakeCallCompleteWorkItem, 
                             (NDIS_PROC)nicCmMakeCallComplete,
                             (PVOID)pVc );

        NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);
                            

        NdisScheduleWorkItem (pMakeCallCompleteWorkItem);



        NdisStatus = NDIS_STATUS_PENDING;

    } while (FALSE);
    
    

    if (!NT_SUCCESS (NdisStatus))
    {

        //
        // Clean up, close the ref on the Calls, Deref the Call. And Update the Vc  
        // to show that we have failed the make call 
        //

        nicCmGenrericMakeCallFailure (pVc);

    }

    TRACE( TL_T, TM_Cm, ( "<==NicCmMakeCall, Vc %x, Status%x", pVc, NdisStatus ) );
    return NdisStatus;
}



#if SEPERATE_CHANNEL_TYPE

NDIS_STATUS
nicCmGenericMakeCallInitChannels (
    IN PCHANNEL_VCCB pChannelVc,
    VC_SEND_RECEIVE  VcType 
    )
/*++

Routine Description:
    Initialze handlers for Send / Recv Channels

Arguments:


Return Value:


--*/
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS; // As there are no allocations
    PCO_MEDIA_PARAMETERS pMediaParams = pChannelVc->Hdr.pCallParameters->MediaParameters;   
    PNIC1394_MEDIA_PARAMETERS pN1394Params = (PNIC1394_MEDIA_PARAMETERS) pMediaParams->MediaSpecific.Parameters;


    if ((pN1394Params->Flags & NIC1394_VCFLAG_ALLOCATE) == NIC1394_VCFLAG_ALLOCATE)
    {
        TRACE( TL_V, TM_Cm, ( "   MakeCall- Channel Vc %x nneds to allocate channel %x", 
                            pChannelVc,
                            pN1394Params->Destination.Channel) );


        VC_SET_FLAG (pChannelVc, VCBF_NeedsToAllocateChannel);
    }
    
    switch (VcType)
    {
        case TransmitAndReceiveVc:
        {
            //
            // Channels will be defaulted to have Send And Receive Capabilities
            //
            TRACE( TL_V, TM_Cm, ( "   MakeCall- Channel Transmit and Receive Vc Vc %x", pChannelVc ) );

            pChannelVc->Hdr.VcType = NIC1394_SendRecvChannel;
                
            pChannelVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitSendRecvChannelVc;
            pChannelVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallSendRecvChannel;
            pChannelVc->Hdr.VcHandlers.SendPackets = AsyncStreamSendPacketsHandler; 
            break;
        }
    
        case ReceiveVc:
        {
            TRACE( TL_V, TM_Cm, ( "   MakeCall- Channel Receive Vc %x", pChannelVc ) );
            pChannelVc->Hdr.VcType = NIC1394_RecvChannel;
                
            pChannelVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitSendRecvChannelVc;
            pChannelVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallSendRecvChannel;
            pChannelVc->Hdr.VcHandlers.SendPackets = DummySendPacketsHandler; 

            break;
        }
        
        case TransmitVc:
        {
            TRACE( TL_V, TM_Cm, ( "   MakeCall- Channel Transmit  Vc Vc %x", pChannelVc ) );
            pChannelVc->Hdr.VcType = NIC1394_SendChannel;
                
            pChannelVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallSendChannel ;
            pChannelVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallSendChannel;
            pChannelVc->Hdr.VcHandlers.SendPackets = AsyncStreamSendPacketsHandler; 
            break;

        }

        default:
        {

            NdisStatus = NDIS_STATUS_FAILURE;
        }

    }


    return NdisStatus;

}




NDIS_STATUS
nicCmGenericMakeCallInitFifo (
    IN PVCCB pVc,
    VC_SEND_RECEIVE  VcType 

    )
/*++

Routine Description:
    Initializes Fifo Vcs'. This only fails a recv fifo is asked for and the
    adapter already has one.
    
Arguments:
    pVc

Return Value:


--*/
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS; //As there are no allocations
    PCO_MEDIA_PARAMETERS pMediaParams = pVc->Hdr.pCallParameters->MediaParameters;  
    PNIC1394_MEDIA_PARAMETERS pN1394Params = (PNIC1394_MEDIA_PARAMETERS) pMediaParams->MediaSpecific.Parameters;

    switch (VcType)
    {
    
        case ReceiveVc:
        {
            //
            // Recv FifoVcs
            //
            PADAPTERCB      pAdapter        = pVc->Hdr.pAF->pAdapter;
            PRECVFIFO_VCCB  pRecvFIFOVc     = (PRECVFIFO_VCCB) pVc; 

            ASSERT(pMediaParams->Flags & RECEIVE_VC);
            
            TRACE( TL_V, TM_Cm, ( "   MakeCall - AsyncReceiveVc Vc %x", pVc ) );
            
            pVc->Hdr.VcType = NIC1394_RecvFIFO;

            pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitRecvFIFOVc;
            pVc->Hdr.VcHandlers.SendPackets  = DummySendPacketsHandler;
            pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallRecvFIFO;


            //
            // There are two reasons to fail a RecvFIFO Make call. 
            // One, a REcvFIFO already exists and second UniqueId != 0
            //
            
            if (pAdapter->pRecvFIFOVc == NULL && pN1394Params->Destination.FifoAddress.UniqueID == 0 )
            {
                ADAPTER_ACQUIRE_LOCK (pAdapter);
            
                pAdapter->pRecvFIFOVc = (PRECVFIFO_VCCB)pVc;
                //
                // Since the adapter now has a pointer to the Vc, increment the Refcount.
                // This will be decremented in the CloseCall
                //
                nicReferenceVc (pVc);

                ADAPTER_RELEASE_LOCK (pAdapter);
            } 
            else
            {
                TRACE( TL_A, TM_Cm, ( "Adapter at %x, already has a recvFIFO. Field is at %x", pAdapter, &pAdapter->pRecvFIFOVc  ) );
                ASSERT (pAdapter->pRecvFIFOVc == NULL);

                NdisStatus = NDIS_STATUS_FAILURE;

                pVc->Hdr.VcHandlers.MakeCallHandler = NULL;
                pVc->Hdr.VcHandlers.CloseCallHandler = NULL;
            }


            break;
        }
        
        case TransmitVc:
        {
            //
            // Send Fifo Vcs
            //
            
            TRACE( TL_V, TM_Cm, ( "    MakeCall - AsyncTransmitVc Vc %x", pVc ) );

            pVc->Hdr.VcType = NIC1394_SendFIFO;

            pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitSendFIFOVc;  
            pVc->Hdr.VcHandlers.SendPackets = AsyncWriteSendPacketsHandler; 
            pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallSendFIFO;

            break;

        }

        case TransmitAndReceiveVc:
        default:
        {

            NdisStatus = NDIS_STATUS_FAILURE;
        }

    }

    return NdisStatus;



}





NDIS_STATUS
nicCmGenericMakeCallMutilChannel (
    IN PVCCB pVc,
    VC_SEND_RECEIVE  VcType 
    )
/*++

Routine Description:
  Init the handlers

Arguments:


Return Value:


--*/
{

    TRACE( TL_A, TM_Cm, ( "Make Call Recvd for MultiChannel %x ", pVc) );
    
    pVc->Hdr.VcType = NIC1394_MultiChannel;
        
    pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallMultiChannel ;
    pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallMultiChannel ;
    pVc->Hdr.VcHandlers.SendPackets = AsyncStreamSendPacketsHandler; 

    return NDIS_STATUS_SUCCESS;


}

NDIS_STATUS
nicCmGenericMakeCallEthernet(
    IN PVCCB pVc,
    IN VC_SEND_RECEIVE VcType
    )
/*++

Routine Description:

  Init the handlers
  
Arguments:


Return Value:


--*/

{

    TRACE( TL_A, TM_Cm, ( "Make Call Recvd for Ethernet %x ", pVc) );

    pVc->Hdr.VcType = NIC1394_Ethernet;

    pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitEthernet;
    pVc->Hdr.VcHandlers.SendPackets  = nicEthernetVcSend;
    pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallEthernet ;

    return NDIS_STATUS_SUCCESS;


}



NDIS_STATUS
nicCmGenericMakeCallInit (
    IN PVCCB pVc
    )
    
    // Function Description:
    //
    // This initializes the VcType and Copied the Media Parameters over
    // Initialized VCType to SendChannel, RecvChannel, SendAndRecvChanne,
    // SendFifo,
    //
    // Arguments
    // Vc - Vc that needs to be initalized
    //
    // Return Value:
    // Success - as no memory allocation takes place


    // This function should not do anything that can fail.

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    VC_SEND_RECEIVE VcType = InvalidType;
    
    PCO_MEDIA_PARAMETERS pMediaParams = pVc->Hdr.pCallParameters->MediaParameters;  
    
    PNIC1394_MEDIA_PARAMETERS pN1394Params = (PNIC1394_MEDIA_PARAMETERS) pMediaParams->MediaSpecific.Parameters;


    TRACE( TL_T, TM_Cm, ( "==>nicCmGenericMakeCallInit  pVc %x", pVc ) );

    pVc->Hdr.Nic1394MediaParams = *pN1394Params;
    ASSERT(pVc->Hdr.pAF!=NULL);
    pVc->Hdr.pGeneration = &pVc->Hdr.pAF->pAdapter->Generation;

    //
    // Figure out if this is send or receive Vc Or both
    //
    do 
    {
        if ((pMediaParams->Flags & (TRANSMIT_VC |RECEIVE_VC)) == TRANSMIT_VC)
        {
            VcType = TransmitVc;
            break;
        }

        if ((pMediaParams->Flags & (TRANSMIT_VC |RECEIVE_VC)) == RECEIVE_VC)
        {
            VcType = ReceiveVc;
            break;
        }
        if ((pMediaParams->Flags & (TRANSMIT_VC |RECEIVE_VC)) == (TRANSMIT_VC |RECEIVE_VC)  )
        {
            VcType = TransmitAndReceiveVc;
            break;
        }

    } while (FALSE);
    
    ASSERT (VcType <= TransmitAndReceiveVc);


    switch (pN1394Params->Destination.AddressType)
    {
        case NIC1394AddressType_Channel:
        {
            NdisStatus = nicCmGenericMakeCallInitChannels ((PCHANNEL_VCCB)pVc, VcType);

            break;
        }
        case NIC1394AddressType_FIFO:
        {
            //
            // Now we are in FIFO land. 
            //
            
            NdisStatus = nicCmGenericMakeCallInitFifo (pVc,  VcType );
                
            break;
        }

        case NIC1394AddressType_MultiChannel:
        {

            NdisStatus  = nicCmGenericMakeCallMutilChannel (pVc, VcType );
            
            break;
        }

        case NIC1394AddressType_Ethernet:
        {
            NdisStatus = nicCmGenericMakeCallEthernet(pVc,  VcType );
            break;
        }

        default:
        {

            ASSERT (pN1394Params->Destination.AddressType<=NIC1394AddressType_Ethernet);
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

    }


    TRACE( TL_T, TM_Cm, ( "<==nicCmGenericMakeCallInit  pVc %x, Status %x",pVc , NdisStatus) );
    
    return NdisStatus; 
     
}

#else

NDIS_STATUS
nicCmGenericMakeCallInit (
    IN PVCCB pVc
    )
    
    // Function Description:
    //
    // This initializes the VcType and Copied the Media Parameters over
    // Initialized VCType to SendChannel, RecvChannel, SendAndRecvChanne,
    // SendFifo,
    //
    // Arguments
    // Vc - Vc that needs to be initalized
    //
    // Return Value:
    // Success - as no memory allocation takes place


    // This function should not do anything that can fail.

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    
    PCO_MEDIA_PARAMETERS pMediaParams = pVc->Hdr.pCallParameters->MediaParameters;  
    
    PNIC1394_MEDIA_PARAMETERS pN1394Params = (PNIC1394_MEDIA_PARAMETERS) pMediaParams->MediaSpecific.Parameters;


    TRACE( TL_T, TM_Cm, ( "==>nicCmGenericMakeCallInit  pVc %x", pVc ) );

    pVc->Hdr.Nic1394MediaParams = *pN1394Params;
    ASSERT(pVc->Hdr.pAF!=NULL);
    pVc->Hdr.pGeneration = &pVc->Hdr.pAF->pAdapter->Generation;
    //
    // Unfortunately we do not have a switch statement, so we'll have to use
    // if statements and do it the hard way
    //

    switch (pN1394Params->Destination.AddressType)
    {
        case NIC1394AddressType_Channel:
        {
            //
            // Channels will be defaulted to have Send And Receive Capabilities
            //
            TRACE( TL_V, TM_Cm, ( "   MakeCall- Channel Transmit and Receive Vc Vc %x", pVc ) );
        
            pVc->Hdr.VcType = NIC1394_SendRecvChannel;
                
            pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitSendRecvChannelVc;
            pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallSendRecvChannel;
            pVc->Hdr.VcHandlers.SendPackets = AsyncStreamSendPacketsHandler; 

            break;
        }
        case NIC1394AddressType_FIFO:
        {
            //
            // Now we are in FIFO land. 
            //
            
            if (pMediaParams->Flags & TRANSMIT_VC)
            {
                //
                // Send Fifo Vcs
                //
                PSENDFIFO_VCCB pSendFIFOVc = (PSENDFIFO_VCCB)pVc;
                
                TRACE( TL_V, TM_Cm, ( "    MakeCall - AsyncTransmitVc Vc %x", pVc ) );

                pVc->Hdr.VcType = NIC1394_SendFIFO;

                pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitSendFIFOVc;  
                pVc->Hdr.VcHandlers.SendPackets = AsyncWriteSendPacketsHandler; 
                pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallSendFIFO;


            }
            else 
            {
                //
                // Recv FifoVcs
                //
                PADAPTERCB      pAdapter        = pVc->Hdr.pAF->pAdapter;
                PRECVFIFO_VCCB  pRecvFIFOVc     = (PRECVFIFO_VCCB) pVc; 

                ASSERT(pMediaParams->Flags & RECEIVE_VC);
                
                TRACE( TL_V, TM_Cm, ( "   MakeCall - AsyncReceiveVc Vc %x", pVc ) );
                
                pVc->Hdr.VcType = NIC1394_RecvFIFO;

                pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitRecvFIFOVc;
                pVc->Hdr.VcHandlers.SendPackets  = DummySendPacketsHandler;
                pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallRecvFIFO;


                //
                // There are two reasons to fail a RecvFIFO Make call. 
                // One, a REcvFIFO already exists and second UniqueId != 0
                //
                
                if (pAdapter->pRecvFIFOVc == NULL && pN1394Params->Destination.FifoAddress.UniqueID == 0 )
                {
                    ADAPTER_ACQUIRE_LOCK (pAdapter);
                
                    pAdapter->pRecvFIFOVc = (PRECVFIFO_VCCB)pVc;
                    //
                    // Since the adapter now has a pointer to the Vc, increment the Refcount.
                    // This will be decremented in the CloseCall
                    //
                    nicReferenceVc (pVc);

                    ADAPTER_RELEASE_LOCK (pAdapter);
                } 
                else
                {
                    TRACE( TL_A, TM_Cm, ( "Adapter at %x, already has a recvFIFO. Field is at %x", pAdapter, &pAdapter->pRecvFIFOVc  ) );
                    ASSERT (pAdapter->pRecvFIFOVc == NULL);

                    NdisStatus = NDIS_STATUS_FAILURE;

                    pVc->Hdr.VcHandlers.MakeCallHandler = NULL;
                    pVc->Hdr.VcHandlers.CloseCallHandler = NULL;
                }

            }
            

            break;
        }

        case NIC1394AddressType_MultiChannel:
        {

            TRACE( TL_A, TM_Cm, ( "Make Call Recvd for MultiChannel %x ", pVc) );
            
            pVc->Hdr.VcType = NIC1394_MultiChannel;
                
            pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallMultiChannel ;
            pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallMultiChannel ;
            pVc->Hdr.VcHandlers.SendPackets = AsyncStreamSendPacketsHandler; 


            break;
        }

        case NIC1394AddressType_Ethernet:
        {
            TRACE( TL_A, TM_Cm, ( "Make Call Recvd for Ethernet %x ", pVc) );

            pVc->Hdr.VcType = NIC1394_Ethernet;

            pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitEthernet;
            pVc->Hdr.VcHandlers.SendPackets  = nicEthernetVcSend;
            pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallEthernet ;


            break;
        }

        default:
        {

            ASSERT (pN1394Params->Destination.AddressType<=NIC1394AddressType_Ethernet);
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

    }


    TRACE( TL_T, TM_Cm, ( "<==nicCmGenericMakeCallInit  pVc %x, Status %x",pVc , NdisStatus) );
    
    return NdisStatus; 
     
}






#endif




VOID
nicCmGenrericMakeCallFailure (
    IN PVCCB pVc
    )
    // Function Description:
    // Does the clean up on the VcHDr structure. Will cleanup the Destination, VcType
    // and Vc. Initialize Handler. Special case - Recv VC
    // Arguments
    // PVCCB : Vc on which cleanup need to be done.
    // Return Value:
    // None
{


    TRACE( TL_T, TM_Cm, ( "==>nicGenrericMakeCallFailure   pVc %x, ",pVc ) );

    pVc->Hdr.VcHandlers.MakeCallHandler = NULL;
    pVc->Hdr.VcHandlers.CloseCallHandler = NULL;

    //
    // First, we need to make sure if adapter's VC is the same as this VC, 
    // otherwise the adapters'recv VC is Valid Vc currently in Use. Do not touch it.
    //


    if (pVc->Hdr.VcType == NIC1394_RecvFIFO && 
        pVc->Hdr.pAF->pAdapter->pRecvFIFOVc == (PRECVFIFO_VCCB)pVc)
    {
        
        //
        // This is the reference that was added GenericInitVc function
        // and only applied to Recv VC's
        //
        VC_ACQUIRE_LOCK (pVc);

        nicDereferenceVc (pVc);

        VC_RELEASE_LOCK (pVc);
    }

    pVc->Hdr.VcType = NIC1394_Invalid_Type;


    NdisZeroMemory (&pVc->Hdr.Nic1394MediaParams , 
                    sizeof (pVc->Hdr.Nic1394MediaParams) );

    VC_ACQUIRE_LOCK(pVc)

    nicCloseCallRef (pVc);

    //
    // Mark the Vc Flags, with a MakeCall Failed 
    //
    VC_CLEAR_FLAGS(pVc ,VCBF_MakeCallPending);

    VC_SET_FLAG (pVc, VCBF_MakeCallFailed);

    VC_RELEASE_LOCK (pVc);
            
    
    TRACE( TL_T, TM_Cm, ( "<==nicGenrericMakeCallFailure   pVc %x, ",pVc ) );

}


VOID
nicCmMakeCallComplete (
    NDIS_WORK_ITEM* pMakeCallCompleteWorkItem,
    IN PVOID Context
    )
    // Function:
    // This function is used to complete a Make Call. This can be done synchronously
    // or asynchronous. If a status pending was passed to this function, it will complete using 
    // the asynchronous route
    //
    // If everytrhing succeeds, one Ref to the Vc will be passed through and that will be decremented
    // when the call is closed
    // This function should never return NDIS_STATUS_PENDING. Will be called as a WorkItem
{

    PVCCB pVc               = (PVCCB)Context;
    PADAPTERCB pAdapter     = pVc->Hdr.pAF->pAdapter;
    NDIS_STATUS NdisStatus  = NDIS_STATUS_FAILURE;
    STORE_CURRENT_IRQL;

    TRACE( TL_T, TM_Cm, ( "==>NicCmMakeCallComplete ,pVc %x",pVc  ) );

    //
    // Reference the Vc as we want the Vc structure to stay alive till 
    // the end of the make call complete
    //
    nicReferenceVc (pVc);
    
    
    //
    // Call the Initialize handler for the VC so that it can be initialized
    //

    ASSERT (pVc->Hdr.VcHandlers.MakeCallHandler != NULL);

    NdisStatus = (*pVc->Hdr.VcHandlers.MakeCallHandler) (pVc);
    
    MATCH_IRQL;

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        VC_ACQUIRE_LOCK(pVc);
        //
        //  Now mark the Vc as active
        //
    
    
        VC_SET_FLAG( pVc, VCBF_VcActivated);
            
        VC_CLEAR_FLAGS(pVc ,VCBF_MakeCallPending);

        
        VC_RELEASE_LOCK (pVc);
    }
    else
    {   
    
        //
        // call the clean up routine to bring the Vc back to its old state
        //

        nicCmMakeCallCompleteFailureCleanUp (pVc);

        //
        // Dereference the call that we are about to fail. This reference was made in
        // the beginning of make call routine. when the callref ==0, the Vc will be 
        // dereferenced as well
        //
        VC_ACQUIRE_LOCK (pVc);  

        VC_SET_FLAG (pVc, VCBF_MakeCallFailed);
            
        VC_CLEAR_FLAGS(pVc ,VCBF_MakeCallPending);
    
        nicDereferenceCall (pVc, "nicCmMakeCallComplete");

        VC_RELEASE_LOCK (pVc);
    
    }


    MATCH_IRQL;

    //
    // Complete the call with the correct status
    //
    TRACE( TL_N, TM_Cm, ( "Completing the Make Call , Vc %x, Status %x", pVc, NdisStatus ) );



    
    NdisCmMakeCallComplete(NdisStatus,
                            pVc->Hdr.NdisVcHandle,
                            NULL,
                            NULL,
                            pVc->Hdr.pCallParameters );
                             

    
    TRACE( TL_I, TM_Cm, ( "Called NdisCmMakeCallComplete, Vc %x, Status%x", pVc, NdisStatus ) );
    
#if 0
    {

        if (pVc->Hdr.VcType == NIC1394_MultiChannel)
        {
            NIC1394_CHANNEL_CHARACTERISTICS McChar;
            McChar.ChannelMap.QuadPart = 0x80000000;    // Must be zero unless specifying a Multi-channel VC.
            McChar.Speed = SCODE_400_RATE ;     // Same units as NIC1394_MEDIA_PARAMETERS.MaxSendSpeed.

            nicChangeChannelChar (pVc, &McChar);

        }
    }
#endif

    

    TRACE( TL_T, TM_Cm, ( "<==NicCmMakeCallComplete, Vc %x, Status%x", pVc,  NdisStatus ) );


    FREE_NONPAGED (pMakeCallCompleteWorkItem); 

    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);
    //
    // This will cause the Vc Refcount to go to zero if the Make Call fails
    //
    nicDereferenceVc (pVc);

    MATCH_IRQL;
}






NDIS_STATUS
nicCmMakeCallInitRecvFIFOVc(
    IN OUT PVCCB pVc
    )
    // Function Description:
    //
    //  This function allocates, packet pool, populates the Slist
    //  allocates the address range and 
    //  inserts the Vc into the Adapter->pRecvFifoVc field
    //  
    //  Will succeed the call, if this process was successful on 1 remote node
    // Arguments
    // PVCCB  : pVc that the call is made on
    //
    //
    // Return Value:
    //  Success: If all allocations succeeded for just 1 remote node
        

{

    PRECVFIFO_VCCB pRecvFIFOVc                      = (PRECVFIFO_VCCB) pVc;
    NDIS_STATUS NdisStatus                          = NDIS_STATUS_SUCCESS;
    REMOTE_NODE *pRemoteNode                                    = NULL;
    PADAPTERCB pAdapter                             = pRecvFIFOVc->Hdr.pAF->pAdapter;

    PNIC1394_MEDIA_PARAMETERS pN1394Params = &pVc->Hdr.Nic1394MediaParams;
    UINT64 UniqueId                                 = pN1394Params->Destination.FifoAddress.UniqueID;       
    PLIST_ENTRY pPdoListEntry                       = NULL;
    BOOLEAN fWaitSuccessful                         = FALSE;
    BOOLEAN fInitRecvFifoDataStructures             = FALSE;
    BOOLEAN fNeedToWait                             = FALSE;
    PNIC1394_FIFO_ADDRESS pFifoAddress              = NULL;

    STORE_CURRENT_IRQL;

    TRACE( TL_T, TM_Cm, ( "==>nicCmMakeCallInitRecvFIFOVc pRecvFIFOVc %x ", pRecvFIFOVc) );

    ASSERT (pAdapter != NULL);
    ASSERT (KeGetCurrentIrql()==PASSIVE_LEVEL);

    pFifoAddress = &pN1394Params->Destination.FifoAddress;

    UniqueId = pFifoAddress->UniqueID;              
    do 
    {

        

        NdisStatus = nicInitRecvFifoDataStructures (pRecvFIFOVc);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( " nicInitRecvFifoDataStructures FAILED pRecvFIFOVc is %x, UniqueId %I64x  ", pRecvFIFOVc) );
            break;
        }

        fInitRecvFifoDataStructures = TRUE; 

//      ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // This field is not used by a RecvFIFO because it has multiple Pdos
        //
        pRecvFIFOVc->Hdr.pRemoteNode = NULL;

        NdisStatus = nicAllocateAddressRange(pAdapter, pRecvFIFOVc);

        if(NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "Unable to get Pdo and allocate addresses,  call FAILED ,pRecvFIFOVc is %x", pRecvFIFOVc) );

            ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);

            break;
        }


    
        ASSERT(pRecvFIFOVc->PacketPool.Handle != NULL);
        ASSERT(pRecvFIFOVc->Hdr.MTU != 0);


    } while (FALSE);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        // 
        // Undo all allocated memory
        //
        TRACE( TL_A, TM_Cm, ( "Failing the Make Call for Vc %x" , pVc) );

        if (fInitRecvFifoDataStructures == TRUE)
        {
            nicUnInitRecvFifoDataStructures (pRecvFIFOVc);
        }
        

    }
    
    TRACE( TL_I, TM_Cm, ( "pVc's Offset High %4x",pVc->Hdr.Nic1394MediaParams.Destination.FifoAddress.Off_High ) );
    TRACE( TL_I, TM_Cm, ( "pVc's Offset Low %x",pVc->Hdr.Nic1394MediaParams.Destination.FifoAddress.Off_Low ) );


    
    TRACE( TL_T, TM_Cm, ( "<==nicCmMakeCallInitRecvFIFOVc %x",NdisStatus ) );

    MATCH_IRQL;

    return NdisStatus;

}




NDIS_STATUS
nicCmMakeCallInitSendFIFOVc(
    IN OUT PVCCB pVc 
    )

/*++

Routine Description:

 This initializes a Send Fifo Make Call. 
 It 
  i) finds the remote node using the make call parameters
  ii) inititalizes strcutures

Arguments:
 pVc - Vc that the make call is done on.

Return Value:


--*/
    //
        

{

    PSENDFIFO_VCCB          pSendFIFOVc = (PSENDFIFO_VCCB) pVc;
    NDIS_STATUS             NdisStatus  = NDIS_STATUS_SUCCESS;
    UINT                    Generation  = 0;
    PREMOTE_NODE            pRemoteNode = NULL;
    PADAPTERCB              pAdapter    = pSendFIFOVc->Hdr.pAF->pAdapter;
    PNIC1394_MEDIA_PARAMETERS pN1394Params = NULL;
    UINT64                  UniqueId    = 0;
    PNIC1394_FIFO_ADDRESS   pFifoAddress    = NULL;
    ULONG                   Speed;
    ULONG                   MaxBufferSize;
    ULONG                   RemoteMaxRec;
    BOOLEAN                 fDeRefRemoteNode = FALSE;

    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Cm, ( "==>NicCmMakeCallInitSendFIFOVc pSendFIFOVc %x", pSendFIFOVc  ) );
        
        
    pN1394Params = (PNIC1394_MEDIA_PARAMETERS)&pVc->Hdr.pCallParameters->MediaParameters->MediaSpecific.Parameters[0];
    
    ASSERT (pN1394Params->Destination.AddressType == NIC1394AddressType_FIFO);


    pFifoAddress = &pN1394Params->Destination.FifoAddress;

    UniqueId = pFifoAddress->UniqueID;              

    
    TRACE( TL_V, TM_Cm, ( "FifoAddress %x, UniqueId %I64x, Hi %.4x, Lo %x", 
                              pFifoAddress, pFifoAddress->UniqueID, 
                              pFifoAddress->Off_High, pFifoAddress->Off_Low ) );

    do 
    {

        //
        // Get the Pdo that corresponds with the UniqueId 
        //
        ASSERT(pSendFIFOVc->Hdr.pAF->pAdapter != NULL);


        
        NdisStatus = nicFindRemoteNodeFromAdapter( pSendFIFOVc->Hdr.pAF->pAdapter,
                                                  NULL,
                                                  UniqueId,
                                                  &pRemoteNode);
        
        if(NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "Unable to Find Pdo, call FAILED ,pSendFIFOVc is %x, UniqueId %I64x  ", pSendFIFOVc, UniqueId ) );

            break;
            
        }
        
        ASSERT (pRemoteNode != NULL);
        
        //
        // nicFindRemoteNodeFromAdapter ref's pRemoteNode on success.
        // We need to deref it if we're not going to be using it.
        // Let's start by assuming we aren't.
        //
        fDeRefRemoteNode = TRUE;

        //
        // Get the Generation Count of the device
        //
        NdisStatus = nicGetGenerationCount ( pRemoteNode->pAdapter, &Generation);

        if(NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "GET GENERATION FAILED ,pSendFIFOVc is %x", pSendFIFOVc ) );

            ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);
            break;
        }


                
        TRACE( TL_V, TM_Cm, ( "Found PdoCb  %x for pSendFIFOVc %x", pRemoteNode,pSendFIFOVc ) );

        //
        //  We check if the remote node's pdo is active. if so, then insert the Vc into the 
        //  PdoCb's list. Now responsibility for any removals has moved to the remove remote node code path
        // 

        //
        // Get the max buffer size that can be transmitted on this link
        //
        NdisStatus  = nicQueryRemoteNodeCaps (pAdapter,
                                              pRemoteNode,
                                              // FALSE,   // FALSE== not from cache.
                                              &Speed,
                                              &MaxBufferSize,
                                              &RemoteMaxRec);
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        ADAPTER_ACQUIRE_LOCK (pAdapter);

        if (REMOTE_NODE_ACTIVE (pRemoteNode) == FALSE)
        {
            NdisStatus = NDIS_STATUS_DEST_OUT_OF_ORDER;

            ADAPTER_RELEASE_LOCK (pAdapter);

            break;
        }


        //
        // Reference the call in the Vc as the RemoteNodePdo is about to have a pointer to it., This is dereferenced
        // in the CloseCallComplete Send Fifo Function. we have the lock
        //
        nicReferenceCall (pVc, "nicCmMakeCallInitSendFIFOVc");

        //
        // We keep the reference to pRemoteNode that was added by FindRemoteNode.
        // Derefed in SendFifoCloseCall when the pointer is nulled
        //
        fDeRefRemoteNode = FALSE;

        //
        // Insert the Vc into the Pdo's List
        //

        InsertTailList (&pRemoteNode->VcList, &pSendFIFOVc->Hdr.SinglePdoVcLink);

        TRACE( TL_V, TM_Cm, ( "Inserted Vc %x into Pdo List %x ", pSendFIFOVc, pRemoteNode) );



        //
        // This is not protected by the lock, but we are gauranteed that the Call will not be closed
        // and the Pdo will not be be removed from the system at this point, So  we can update
        // this field.
        //
        pSendFIFOVc->Hdr.pRemoteNode = pRemoteNode;


        
        ADAPTER_RELEASE_LOCK (pAdapter);

        
        //
        // Acquire the spin lock and initialize the structures
        //

        VC_ACQUIRE_LOCK (pSendFIFOVc);

        pSendFIFOVc->Hdr.MTU = pN1394Params->MTU;
    

        pSendFIFOVc->Hdr.pGeneration = &pAdapter->Generation; 

        pSendFIFOVc->FifoAddress = pN1394Params->Destination.FifoAddress;

        pSendFIFOVc->MaxSendSpeed = pN1394Params->MaxSendSpeed;

        pSendFIFOVc->Hdr.MaxPayload = min (pN1394Params->MTU, (ULONG)pN1394Params->MaxSendBlockSize); 


        VC_RELEASE_LOCK (pSendFIFOVc);



        //
        // Validate the parameters for the Vc
        //
        ASSERT(pSendFIFOVc->Hdr.pRemoteNode != NULL);
        ASSERT(pSendFIFOVc->Hdr.pRemoteNode->pPdo != NULL);
        ASSERT(pSendFIFOVc->Hdr.pGeneration != NULL);
        ASSERT(pSendFIFOVc->MaxSendSpeed != 0);
        ASSERT(pSendFIFOVc->Hdr.MTU != 0);
        

        TRACE( TL_V, TM_Cm, ( "    Generation is %x", *pSendFIFOVc->Hdr.pGeneration ) );
    
        TRACE( TL_N, TM_Cm, ( "    Pdo in the Send VC is %x", pSendFIFOVc->Hdr.pRemoteNode->pPdo) );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        
        pSendFIFOVc->MaxSendSpeed = min(pSendFIFOVc->MaxSendSpeed,Speed); 
        pSendFIFOVc->Hdr.MaxPayload = min (pSendFIFOVc->Hdr.MaxPayload, MaxBufferSize);

#ifdef LOWER_SEND_SPEED

        pSendFIFOVc->MaxSendSpeed = SCODE_200_RATE;//min(pSendFIFOVc->MaxSendSpeed,Speed); 
        
        pSendFIFOVc->Hdr.MaxPayload = ASYNC_PAYLOAD_200_RATE ;//  min(pSendFIFOVc->Hdr.MaxPayload, MaxBufferSize);
#endif

        TRACE( TL_V, TM_Cm, ( "    MaxSendSpeed  is %x", pSendFIFOVc->MaxSendSpeed) );
        TRACE( TL_V, TM_Cm, ( "    MaxPayload is %d", pSendFIFOVc->Hdr.MaxPayload ) );


    } while (FALSE);

    if ( NdisStatus != NDIS_STATUS_SUCCESS)
    {
        //
        // The Make is going to be failed asynchrnously
        // If we allocated in resources, we must free them
        // In this case, there have been no Resources allocated
        //


    }


        
    TRACE( TL_I, TM_Cm, ( "    pVc's Offset High %4x",pVc->Hdr.Nic1394MediaParams.Destination.FifoAddress.Off_High ) );
    TRACE( TL_I, TM_Cm, ( "    pVc's Offset Low %x",pVc->Hdr.Nic1394MediaParams.Destination.FifoAddress.Off_Low ) );


    TRACE( TL_T, TM_Cm, ( "<==NicCmMakeCallInitSendFIFOVc %x",NdisStatus ) );

    if (fDeRefRemoteNode)
    {
        nicDereferenceRemoteNode (pRemoteNode, "NicCmMakeCallInitSendFIFOVc");
    }


    MATCH_IRQL;
    return NdisStatus;

}



NDIS_STATUS
nicCmMakeCallInitSendRecvChannelVc(
    IN OUT PVCCB pVc 
    )
    // Function Description:
    //
    // Arguments
    // pVc, This is the send fifo that needs to be initilaized
    //
    //
    // Return Value:
    //
    // Success if the irps sent to the driver succeed
    //
    //
        

{

    PCHANNEL_VCCB                                   pChannelVc = (PCHANNEL_VCCB)pVc;
    NDIS_STATUS                                     NdisStatus = NDIS_STATUS_FAILURE;
    PNIC1394_MEDIA_PARAMETERS             pN1394Params = NULL;
    PADAPTERCB                                      pAdapter = pVc->Hdr.pAF->pAdapter;
    ULONG                                           Channel = 64;
    HANDLE                                          hResource=NULL;
    ULONG                                           MaxBufferSize = 0; 
    ULONG                                           QuadletsToStrip = 0;
    PISOCH_DESCRIPTOR                               pIsochDescriptor = NULL;
    CYCLE_TIME                                      CycleTime;
    PDEVICE_OBJECT                                  ArrayRemotePDO[64];
    //NDIS_HANDLE                                       hPacketPoolHandle=NULL;
    BOOLEAN                                         fAnyChannel = FALSE;
    NIC_PACKET_POOL                                 PacketPool;
    STORE_CURRENT_IRQL;
   
    
    TRACE( TL_T, TM_Cm, ( "==>NicCmMakeCallInitSendRecvChannelVc pVc %x", pVc ) );
    

    ASSERT (pAdapter != NULL);

    pN1394Params = (PNIC1394_MEDIA_PARAMETERS)&pVc->Hdr.pCallParameters->MediaParameters->MediaSpecific.Parameters[0];

    Channel = pN1394Params->Destination.Channel;

    TRACE( TL_V, TM_Cm, ( "Channel %x", Channel ) );

    do 
    {
        PacketPool.Handle = NULL;
        
        ADAPTER_ACQUIRE_LOCK( pAdapter );


        //
        // This is to reference the call so that it will be around until the end of this function
        //
        nicReferenceCall ( (PVCCB)pChannelVc, "nicCmMakeCallInitSendRecvChannelVc");


        //
        //  Set up the the VDO, so that all channel operations can use it
        //
        pVc->Hdr.pLocalHostVDO  = pAdapter->pNdisDeviceObject;
        

        ADAPTER_RELEASE_LOCK( pAdapter );

        
        NdisAllocatePacketPoolEx ( &NdisStatus,
                                   &PacketPool.Handle,
                                   MIN_PACKET_POOL_SIZE,
                                   MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                   sizeof (RSVD) );
        
        if (PacketPool.Handle == NULL || NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Cm, ( "NdisAllocatePacketPoolEx FAILED" ) );
        }

        //
        // Reference Call for Packet Pool Handle
        //
        nicReferenceCall ((PVCCB)pChannelVc, "nicCmMakeCallInitSendRecvChannelVc - packet pool ");
        

        PacketPool.AllocatedPackets = 0;
        
        pChannelVc->Hdr.MTU = pN1394Params->MTU;
        pChannelVc->PacketPool= PacketPool;
        KeInitializeSpinLock (&pChannelVc->PacketPool.Lock);
        NdisInitializeEvent(&pChannelVc->LastDescReturned);


        //
        // This function should do its own cleanup
        //
        NdisStatus =  nicAllocateChannelResourcesAndListen (pAdapter,
                                                     pChannelVc );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Cm, ( "nicAllocateChannelResourcesAndListen  FAILED" ) );
        }
        //
        // Return the allocated channel number, if this is an any channel 
        // or broadcast channel call
        //
        if ((pN1394Params->Destination.Channel == NIC1394_ANY_CHANNEL) &&
           (pN1394Params->Destination.AddressType == NIC1394AddressType_Channel))
        {
            pN1394Params->Destination.Channel  = pChannelVc->Channel;   
        }

        //
        // Make the same change for broadcast channels
        //

        if ((pN1394Params->Destination.Channel == NIC1394_BROADCAST_CHANNEL) &&
           (pN1394Params->Destination.AddressType == NIC1394AddressType_Channel))
        {
            pN1394Params->Destination.Channel  = pChannelVc->Channel;   
        }


    }   while (FALSE);
        
    //
    // Time to do clean up based on what resources were allocated
    //
    if (NdisStatus != NDIS_STATUS_SUCCESS )
    {
        //Undo all resources acquired
        if (PacketPool.Handle != NULL)
        {
            //
            //  Free the pool
            //
            nicFreePacketPool(&PacketPool);

            nicDereferenceCall ((PVCCB)pChannelVc, "nicCmMakeCallInitSendRecvChannelVc - packet pool ");

            NdisZeroMemory (&pChannelVc->PacketPool, sizeof (pChannelVc->PacketPool));
        }

#if 0 
        nicChannelCallFreeResources ( pChannelVc,
                                    pAdapter,
                                    NULL, //hResource,
                                    0, //NumDescriptors,
                                    NULL, //pIsochDescriptor,
                                    (BOOLEAN)VC_TEST_FLAGS( pChannelVc, VCBF_AllocatedChannel), 
                                    Channel,
                                    &PacketPool);
#endif
        //
        // Do not decrement any ref counts because if Status != success
        // then we have not incremented refcounts.
        //


    }

    //
    // This dereference was added in the beginning of the function
    //
    nicDereferenceCall ((PVCCB) pChannelVc, "NicCmMakeCallInitSendRecvChannelVc ");
    
    TRACE( TL_T, TM_Cm, ( "<==NicCmMakeCallInitSendRecvChannelVc %x", NdisStatus) );

    return NdisStatus;
}







NDIS_STATUS
nicCmMakeCallInitEthernet (
    IN PVCCB pVc
    )
/*++

Routine Description:
  Do nothing for now. Just succeed 

Arguments:


Return Value:


--*/
{

    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PADAPTERCB          pAdapter = pVc->Hdr.pAF->pAdapter;
    PETHERNET_VCCB      pEthernetVc = (PETHERNET_VCCB)pVc;
    NIC_PACKET_POOL     PacketPool;
    
    TRACE( TL_T, TM_Cm, ( "==>nicCmMakeCallInitEthernet %x", pVc) );




    do
    {
        PacketPool.Handle = NULL;
        
        //
        // Initialize the PacketPool
        //

        NdisAllocatePacketPoolEx ( &NdisStatus,
                                   &PacketPool.Handle,
                                   MIN_PACKET_POOL_SIZE,
                                   MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                   sizeof (RSVD) );
        
        if (NdisStatus!= NDIS_STATUS_SUCCESS)
        {
            ASSERT(NdisStatus != NDIS_STATUS_SUCCESS);
            pEthernetVc->PacketPool.Handle = NULL;
            PacketPool.Handle = NULL;
            break;
        }



        
        NdisStatus = NDIS_STATUS_SUCCESS;
        //
        // No more failures
        //

        nicReferenceCall ((PVCCB)pEthernetVc, "Alloc PacketPool - Ethernet VC " ) ;
        
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // Reference the VC as the adapter has a pointer to it
        //
        nicReferenceCall (pVc, "nicCmMakeCallEthernet ");

        pAdapter->pEthernetVc = (PETHERNET_VCCB)pVc;
        

        pEthernetVc->PacketPool= PacketPool;
        pEthernetVc->PacketPool.AllocatedPackets = 0;
        KeInitializeSpinLock (&pEthernetVc->PacketPool.Lock);

        ADAPTER_RELEASE_LOCK (pAdapter);

        

    } while (FALSE);


    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        if (PacketPool.Handle != NULL)
        {
            //
            //  Free the pool
            //
            nicFreePacketPool(&PacketPool);

        }
    }


    
    TRACE( TL_T, TM_Cm, ( "<==nicCmMakeCallEthernet  %x", NdisStatus) );
    return NdisStatus;

}


    
NDIS_STATUS
nicCmMakeCallMultiChannel (
    IN PVCCB pVc
    )
/*++

Routine Description:
    Do whatever the channel Vc does

Arguments:


Return Value:


--*/
{

    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    PADAPTERCB              pAdapter = pVc->Hdr.pAF->pAdapter;
    PCHANNEL_VCCB           pMcVc = (PCHANNEL_VCCB)pVc;
    NIC_PACKET_POOL         PacketPool;
    
    
    TRACE( TL_T, TM_Cm, ( "==>nicCmMakeCallMultiChannel  %x", pVc) );





    do
    {
        PacketPool.Handle = NULL;

        
        //
        // Initialize the PacketPool
        //

        NdisAllocatePacketPoolEx ( &NdisStatus,
                                   &PacketPool.Handle,
                                   MIN_PACKET_POOL_SIZE,
                                   MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                   sizeof (RSVD) );
        
        if (NdisStatus!= NDIS_STATUS_SUCCESS)
        {
            ASSERT(NdisStatus != NDIS_STATUS_SUCCESS);
            pMcVc->PacketPool.Handle = NULL;
            break;
        }



        
        NdisStatus = NDIS_STATUS_SUCCESS;
        //
        // No more failures
        //

        nicReferenceCall ((PVCCB)pMcVc, "Alloc PacketPool - MultiChannel VC " ) ;
        
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        

        pMcVc->PacketPool= PacketPool;
        pMcVc->PacketPool.AllocatedPackets = 0;
        KeInitializeSpinLock (&pMcVc->PacketPool.Lock);

        pMcVc->Hdr.MTU =   pMcVc->Hdr.Nic1394MediaParams.MTU;

        ADAPTER_RELEASE_LOCK (pAdapter);


        if (pMcVc->Hdr.Nic1394MediaParams.Destination.ChannnelMap.QuadPart == 0)
        {

            pMcVc->Channel = 0xff;
            NdisStatus = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // This portion Not Implemented yet.  ChannelMap != 0
        // Should use nicAllocateResourcesAndListen after updating the 
        // Nic1394MediaParams to make it look like a regular ChannelMake Call
        //
        NdisStatus =  NDIS_STATUS_FAILURE;
        ASSERT (0);
        
    } while (FALSE);


    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        if (PacketPool.Handle != NULL)
        {
            //
            //  Free the pool
            //
            nicFreePacketPool(&PacketPool);

        }
    }



    TRACE( TL_T, TM_Cm, ( "<==nicCmMakeCallMultiChannel   %x", NdisStatus) );
    return NdisStatus;

}
    

NDIS_STATUS
nicCmMakeCallSendChannel (
    IN PVCCB pVc
    )
/*++

Routine Description:
   This function allocates the channel but does nothing else. 
   It is only used to send data and therefore needs no other data

    It needs to update pChannelVc->Channel; ulSynch; Speed;  
    all of which are needed to do an AsyncStream Irb
    

Arguments:


Return Value:


--*/
{
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PCHANNEL_VCCB       pChannelVc = (PCHANNEL_VCCB)pVc;
    BOOLEAN             fNeedToAllocate = VC_TEST_FLAG (pChannelVc, VCBF_NeedsToAllocateChannel);
    PADAPTERCB          pAdapter = pVc->Hdr.pAF->pAdapter;
    ULONG               Speed = 0;
    UINT                MaxPacketSize = 0;
    PNIC1394_MEDIA_PARAMETERS pN1394Params = (PNIC1394_MEDIA_PARAMETERS)&pChannelVc->Hdr.Nic1394MediaParams;
    ULONG               Channel = pN1394Params->Destination.Channel;
    
    TRACE( TL_T, TM_Cm, ( "==>nicCmMakeCallSendChannel pVc %x", pVc) );

    do 
    {

        //
        // Allocate the channel 
        // 
        if (fNeedToAllocate == TRUE)
        {
    
            NdisStatus = nicAllocateRequestedChannelMakeCallComplete (pAdapter, 
                                                               pChannelVc, 
                                                               &Channel);
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {   
                BREAK (TM_Cm, ("Unable to allocate Channel on Send Only Vc" ) );
            }

        }

        //
        // Find out the Speed. 
        //  
        if (pAdapter->Speed == 0)
        {
            nicUpdateLocalHostSpeed (pAdapter);
        }   


        pChannelVc->Speed = pAdapter->Speed;

        Speed = pAdapter->Speed;
            
        switch (pChannelVc->Speed)
        {
            case SPEED_FLAGS_100  : 
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_100_RATE;
                break;
            }
            case SPEED_FLAGS_200 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_200_RATE ;
                break;
            }
                
            case SPEED_FLAGS_400 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }

            case SPEED_FLAGS_800:                          
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }

            case SPEED_FLAGS_1600:                          
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }

            case SPEED_FLAGS_3200 :                         
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }

            default :
            {
                pChannelVc->Hdr.MaxPayload   = ISOCH_PAYLOAD_400_RATE; 
                break;
            }

        }


        pChannelVc->Channel = Channel ;

        MaxPacketSize = min(pN1394Params->MTU + sizeof(GASP_HEADER) , pChannelVc->Hdr.MaxPayload);

        

        
        //
        // If broadcast channel, then decrease the speed setting, and fragment
        //

        
        
        pChannelVc->Channel = Channel;
        pChannelVc->MaxBufferSize = 0;
        pChannelVc->Speed = Speed;

        pChannelVc->Hdr.MaxPayload = MaxPacketSize;
        pChannelVc->Hdr.MTU = pN1394Params->MTU ; 

        pChannelVc->NumDescriptors = 0;
        pChannelVc->pIsochDescriptor = NULL;


        NdisStatus = NDIS_STATUS_SUCCESS;




    } while (FALSE);



    TRACE( TL_T, TM_Cm, ( "<==nicCmMakeCallSendChannel %x", NdisStatus) );

    return NdisStatus;
}










VOID
nicCmMakeCallCompleteFailureCleanUp(
    IN OUT PVCCB pVc 
    )

    // Function Description:
    // This function cleans up, if the makecallcomplete fails for whatever reason.
    // Maybe this should be split up as well
    // In the RecvFIFOVc case: it needs to deallocate the Slist and PacketPool, 
    // Common:
    // Also delete the VcType and nic1394 destination in the Vc Hdr
    // Arguments
    // PVCCB pVc - Vc that needs to be cleaned up
    //
    // Return Value:
    // 
    //  

{

    STORE_CURRENT_IRQL;
        
    TRACE( TL_T, TM_Cm, ( "==>nicCmMakeCallCompleteFailureCleanUp pVc %x", pVc ) );
    
    switch (pVc->Hdr.VcType)
    {

        case NIC1394_RecvFIFO:
        {
            PRECVFIFO_VCCB pRecvFIFOVc = (PRECVFIFO_VCCB )pVc;

            TRACE( TL_V, TM_Cm, ( "Cleaning up a recv FIFo %x", pVc ) );

            if (pRecvFIFOVc->PacketPool.Handle != NULL)
            {
                nicFreePacketPool (&pRecvFIFOVc->PacketPool);
            }
            pRecvFIFOVc->PacketPool.Handle = NULL;

            if (pRecvFIFOVc->FifoSListHead.Alignment != 0)
            {
                nicFreeAllocateAddressRangeSList (pRecvFIFOVc);
            }

            pRecvFIFOVc->FifoSListHead.Alignment = 0;
            
            break;
        }


        case NIC1394_SendFIFO:
        case NIC1394_SendRecvChannel:
        case NIC1394_SendChannel:
        case NIC1394_RecvChannel:
    

        default:
            break;
    }



    //
    // This call does the generic clean up
    //
    nicCmGenrericMakeCallFailure (pVc);

    
    TRACE( TL_T, TM_Cm, ( "<==nicCmMakeCallCompleteFailureCleanUp ") );

    MATCH_IRQL;
    return ;
}





NDIS_STATUS
NicCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size )

    // Standard 'CmCloseCallHandler' routine called by NDIS when the a client
    // has requested to tear down a call.  See DDK doc.
    //
{
    NDIS_STATUS NdisStatus                      = NDIS_STATUS_FAILURE;
    ADAPTERCB* pAdapter                         = NULL;
    VCCB* pVc                                   = NULL;
    NDIS_WORK_ITEM* pCloseCallCompleteWorkItem  = NULL;
    

    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Cm, ( "==>NicCmCloseCall($%p)", CallMgrVcContext ) );

    pVc = (VCCB* )CallMgrVcContext;

    if (pVc->Hdr.ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    
    do 
    {
        pAdapter = pVc->Hdr.pAF->pAdapter;

        if (pAdapter == NULL)
        {
            TRACE( TL_A, TM_Cm, ( "pAdpater is NULL - Make Call FAILED($%p)", CallMgrVcContext ) );
        
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        VC_ACQUIRE_LOCK (pVc);

        //
        // If the Make Call is Pending, then fail the CloseCall. 
        // Or if there call is already closing then fail this close call
        //

        if ( VC_ACTIVE (pVc) == FALSE )
        {
            TRACE( TL_A, TM_Cm, ( "NicCmCloseCall Invalid flags - Close Call FAILED Vc $%p, flags %x", pVc, pVc->Hdr.ulFlags ) );

            ASSERT ( ! "MakeCallPending or Call already closed?");

            VC_RELEASE_LOCK (pVc);
            break;
        }

        //
        //
        // Reference the Vc so we can gaurantee its presence till the end of the work item
        // to CloseCallComplete. we have the lock
        //
        nicReferenceVc (pVc);

        //
        // Mark the Call as closing, and close the refcount, so no one can increment it
        //
        VC_SET_FLAG ( pVc, VCBF_CloseCallPending); 

        nicCloseCallRef (pVc);

        VC_RELEASE_LOCK (pVc);

        pCloseCallCompleteWorkItem = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM); 

        if (pCloseCallCompleteWorkItem == NULL)
        {
            TRACE( TL_A, TM_Cm, ( "Local Alloc failed for WorkItem - Close Call FAILED($%p)", CallMgrVcContext ) );
            
            NdisStatus = NDIS_STATUS_RESOURCES;

            break;
        }
    
        NdisInitializeWorkItem ( pCloseCallCompleteWorkItem, 
                            (NDIS_PROC)nicCmCloseCallComplete,
                            (PVOID)pVc );

        NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

        NdisScheduleWorkItem (pCloseCallCompleteWorkItem);

    } while (FALSE);
    
    MATCH_IRQL;
    
    TRACE( TL_T, TM_Cm, ( "<==NicCmCloseCall pending" ) );
    
    return NDIS_STATUS_PENDING;
}


VOID
nicCmCloseCallComplete(
    NDIS_WORK_ITEM* pCloseCallCompleteWorkItem,     
    IN PVOID Context 
    )
    // Function Description:
    // This function completes the close call. The qor Item gaurantees that all work will be
    // done at passive level    
    //
    // Arguments
    // Context : Which is VCCB for  which the close call was requested
    //
    //
    // Return Value:
    // None  
    // However an NdisStatus is passed in the call to Ndis' close call complete  function   
    //
    //

{
    NDIS_STATUS NdisStatus  = NDIS_STATUS_FAILURE;
    PVCCB pVc               = (PVCCB) Context;
    PADAPTERCB pAdapter       = pVc->Hdr.pAF->pAdapter;
    BOOLEAN fCallClosable   = FALSE;
    BOOLEAN fWaitSucceeded = FALSE;

    STORE_CURRENT_IRQL;



    TRACE( TL_T, TM_Cm, ( "==>nicCmCloseCallComplete pVc %x", pVc ) );


    //
    // Invoke the close call handler of the VC
    //
    ASSERT (pVc->Hdr.VcHandlers.CloseCallHandler != NULL);
    
    NdisStatus = (*pVc->Hdr.VcHandlers.CloseCallHandler) (pVc);
     
    //
    // right now, we do not fail a close call because the bus driver failed us.
    //
    NdisStatus = NDIS_STATUS_SUCCESS;
    //
    // Made it so far, we now need to dereference the call. We made the reference in 
    // MakeCall. This will complete the call if it gets down to zero
    // 
    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        //
        // Derefercence the call ref and Vc Refs that were added at the end of 
        // a successful make call
        //
        nicDereferenceCall (pVc, "nicCmCloseCallComplete");

    
    }

    //
    // Important : THIS WAIT is for the REFCOUNT on the CALL , not the VC
    //
    TRACE( TL_N, TM_Cm, ( "About to Wait for CallRefs to go to zero pVc %x ", pVc) );

    fWaitSucceeded = NdisWaitEvent (&pVc->Hdr.CallRef.RefZeroEvent, WAIT_INFINITE );

    if (fWaitSucceeded == FALSE)
    {
        TRACE( TL_A, TM_Cm, ( "Wait Timed Out Call, Vc %x, RefCount %x ", pVc , pVc->Hdr.CallRef.ReferenceCount) );

        ASSERT (fWaitSucceeded == TRUE);
    }


    ASSERT (KeGetCurrentIrql() <= DISPATCH_LEVEL);
    //
    // Succeed the Close call as all references have gone to zero
    // The call has no more outstanding resources
    //

    TRACE( TL_N, TM_Cm, ( "About to Close Call on pVc %x", pVc ) );

    NdisMCmCloseCallComplete( NDIS_STATUS_SUCCESS,
                           pVc->Hdr.NdisVcHandle, NULL );
                           
    

    VC_ACQUIRE_LOCK (pVc);

    VC_CLEAR_FLAGS (pVc, VCBF_CloseCallPending); 
    VC_SET_FLAG (pVc, VCBF_CloseCallCompleted);

    VC_RELEASE_LOCK (pVc);

    FREE_NONPAGED (pCloseCallCompleteWorkItem);
    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);

    //
    // Release the reference made when entering the Close Call function above. so the Vc can disappear if it wants to
    // Remember that delete Vc can already have gone through at this time, and the Vc will be freed after the deref
    //
    nicDereferenceVc (pVc);

    
    TRACE( TL_T, TM_Cm, ( "<==nicCmCloseCallComplete pVc %x, Status %x", pVc, NdisStatus  ) );

    MATCH_IRQL;
    
}


NDIS_STATUS
nicCmCloseCallEthernet (
    IN PVCCB pVc
    )
/*++

Routine Description:
  Do nothing for now. Just succeed 

Arguments:


Return Value:


--*/
{

    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PADAPTERCB          pAdapter = pVc->Hdr.pAF->pAdapter;
    PETHERNET_VCCB      pEthernetVc = (PETHERNET_VCCB)pVc;
    NIC_PACKET_POOL     PacketPool;

    
    TRACE( TL_T, TM_Cm, ( "==>nicCmCloseCallEthernet  %x", pVc) );


    ADAPTER_ACQUIRE_LOCK (pAdapter);
    
    PacketPool = pEthernetVc->PacketPool;

    pEthernetVc->PacketPool.Handle = 0;
    pEthernetVc->PacketPool.AllocatedPackets = 0;
    
    ADAPTER_RELEASE_LOCK (pAdapter);

    if (PacketPool.Handle != NULL)
    {
        nicDereferenceCall ((PVCCB)pEthernetVc, "pEthernetVc - Free PacketPool" );
        nicFreePacketPool (&PacketPool);

    }


    ADAPTER_ACQUIRE_LOCK (pAdapter);

    //
    // Dereference the VC as the adapter's pointer has been cleared 
    //
    nicDereferenceCall (pVc, "nicCmMakeCallEthernet ");

    pAdapter->pEthernetVc = NULL;
    
    ADAPTER_RELEASE_LOCK (pAdapter);





    NdisStatus = NDIS_STATUS_SUCCESS;
    TRACE( TL_T, TM_Cm, ( "<==nicCmCloseCallEthernet  %x", NdisStatus) );
    return NdisStatus;

}


    
NDIS_STATUS
nicCmCloseCallMultiChannel (
    IN PVCCB pVc
    )
/*++

Routine Description:
  Free the packet pool and  Just succeed 

Arguments:


Return Value:


--*/
{

    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    PADAPTERCB              pAdapter = pVc->Hdr.pAF->pAdapter;
    PCHANNEL_VCCB           pMcVc = (PCHANNEL_VCCB)pVc;
    NIC_PACKET_POOL         PacketPool;
    
    TRACE( TL_T, TM_Cm, ( "==>nicCmCloseCallMultiChannel  %x", pVc) );

    ASSERT (VC_TEST_FLAG (pVc, VCBF_BroadcastVc) == FALSE);

    //
    // Mask the fact that this is a multichannel Call
    //
    
    NdisStatus = nicCmCloseCallSendRecvChannel  (pVc);


    //
    // Nothing to fail
    //
    NdisStatus = NDIS_STATUS_SUCCESS;

    TRACE( TL_T, TM_Cm, ( "<==nicCmCloseCallMultiChannel   %x", NdisStatus) );
    return NdisStatus;

}
    


NDIS_STATUS
nicCmCloseCallSendRecvChannel (
    IN PVCCB pVc 
    )
    // Function Description:
    // This function will do clean up for RecvFifos
    // Includes removing the VC pointer from Pdo Adapter structure.
    // And needs to go through all active remote nodes and free the address ranges on them
    // The BCM Vc has the added overhead of having an address range associated with it. 
    //  which we need to free 
    //
    // Arguments
    // PVCCB pVc - The Channel VC that needs to be closed
    //
    // Return Value:
    // Success for now
    //
    // Called with the lock held

{
    PCHANNEL_VCCB       pChannelVc = (PCHANNEL_VCCB ) pVc;
    PCHANNEL_VCCB       pTempVc = NULL;
    BOOLEAN             fIsBroadcastVc =  FALSE;
    PLIST_ENTRY         pVcListEntry = NULL;
    PADAPTERCB          pAdapter = NULL; 
    ULONG               NumDereferenced ;
    HANDLE              hResource ;
    ULONG               NumDescriptors ;
    PISOCH_DESCRIPTOR   pIsochDescriptor;
    BOOLEAN             fAllocatedChannel ;
    ULONG               Channel ;
    NIC_PACKET_POOL     PacketPool;

    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Cm, ( "==> nicCmCloseCallSendRecvChannel pVc %x", pVc) );

    ASSERT (pVc!=NULL);
    pAdapter = pChannelVc->Hdr.pAF->pAdapter;
    ASSERT (pAdapter != NULL);
    do 
    {
        



        VC_ACQUIRE_LOCK (pChannelVc);

        if (VC_TEST_FLAG (pChannelVc, VCBF_BroadcastVc) == TRUE)
        {
            PADDRESS_RANGE_CONTEXT pBCRAddress = &pAdapter->BCRData.AddressRangeContext;
            
            //
            // Free the allocated address renge for the Broadcast Channel Register
            //
            if ( BCR_TEST_FLAG (pAdapter, BCR_Initialized) == TRUE)
            {

                //
                // Clear out the Broadcast VC in the BCRData structure, Derereference the call. and clear the flag
                // The ref was made in the MakeCallAllocateChannel function 
                //
                if (pAdapter->BCRData.pBroadcastChanneVc  != NULL)
                {
                    pAdapter->BCRData.pBroadcastChanneVc = NULL;

                    nicDereferenceCall((PVCCB) pChannelVc, "nicCmCloseCallSendRecvChannel Broadcast VC");       
                }
                VC_CLEAR_FLAGS (pChannelVc, VCBF_BroadcastVc) ;
                        
            }

        }
        
        VC_RELEASE_LOCK (pChannelVc);
        
        nicIsochStop (pAdapter,
                      pChannelVc->hResource);
        

        VC_ACQUIRE_LOCK (pChannelVc);
        
        PacketPool = pChannelVc->PacketPool;

        hResource = pChannelVc->hResource;

        NumDescriptors = pChannelVc->NumDescriptors;

        pIsochDescriptor = pChannelVc->pIsochDescriptor;

        fAllocatedChannel = VC_TEST_FLAGS( pChannelVc, VCBF_AllocatedChannel);

        Channel =   pChannelVc->Channel;

        PacketPool = pChannelVc->PacketPool;

        //
        // Clean out the VC structure and then call NDIS or the bus driver to free all
        // the resources
        //
        nicChannelCallCleanDataStructure  (pChannelVc,
                                           pChannelVc->hResource,
                                           pChannelVc->NumDescriptors,
                                           pChannelVc->pIsochDescriptor,
                                           fAllocatedChannel, 
                                           pChannelVc->Channel,
                                           pChannelVc->PacketPool.Handle,
                                           &NumDereferenced );

        
        VC_RELEASE_LOCK (pChannelVc);

            
        nicChannelCallFreeResources ( pChannelVc,
                                   pAdapter,
                                   hResource,
                                   NumDescriptors,
                                   pIsochDescriptor,
                                   fAllocatedChannel, 
                                   Channel,
                                   &PacketPool);
    
        
        
    } while (FALSE);
    

    TRACE( TL_T, TM_Cm, ( "<== nicCmCloseCallSendRecvChannel Status %x(always success)" ) );
    MATCH_IRQL;
    
    return NDIS_STATUS_SUCCESS;

}



NDIS_STATUS
nicCmCloseCallRecvFIFO (
    IN PVCCB pVc 
    )
    // Function Description:
    // This function will do clean up for RecvFifos
    // Includes removing the VC pointer from Pdo Adapter structure.
    // And needs to go through all active remote nodes and free the address ranges on them
    // 
    // 
    // Arguments
    // PVCCB pVc - The SendFifo that needs to be closed
    //
    // Return Value:
    // Success for now
    //

{
    NDIS_STATUS NdisStatus          = NDIS_STATUS_FAILURE;
    PRECVFIFO_VCCB pRecvFIFOVc      = (PRECVFIFO_VCCB)pVc;
    PADDRESS_FIFO pAddressFifo      = NULL;
    PSINGLE_LIST_ENTRY pAddressFifoEntry = NULL;
    PADAPTERCB pAdapter             = pVc->Hdr.pAF->pAdapter;

        
    TRACE( TL_T, TM_Cm, ( "==> nicCmCloseCallRecvFIFO pVc %x", pVc) );

    //NdisStatus = nicFreeRecvFifoAddressRangeOnAllRemoteNodes (pAdapter);          
    NdisStatus = nicFreeAddressRange( pAdapter,
                                     pRecvFIFOVc->AddressesReturned,
                                     &pRecvFIFOVc->VcAddressRange,
                                     &pRecvFIFOVc->hAddressRange    );

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_I, TM_Cm, ( "Call to Free Address Range Failed pVc at %x",pVc ) );

        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

        //
        // Do not Break. Continue
        //
        NdisStatus = NDIS_STATUS_SUCCESS;
        
    }

    pRecvFIFOVc->hAddressRange  = NULL;
    pRecvFIFOVc->AddressesReturned = 0;
    pRecvFIFOVc->VcAddressRange.AR_Off_High = 0;
    pRecvFIFOVc->VcAddressRange.AR_Off_Low = 0;
    
    

    nicDereferenceCall ((PVCCB)pRecvFIFOVc, 
                        "nicCmCloseCallRecvFIFO  - Free address range" );

    nicFreePacketPool (&pRecvFIFOVc->PacketPool);

    //
    // Free the Slist Entries (AddressFifo, Mdl's) and their associated memory 
    // and decrease the refcount for each entry
    //
    
    NdisStatus = nicFreeAllocateAddressRangeSList (pRecvFIFOVc);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_I, TM_Cm, ( "Call to Free SList Failed pVc at %x",pVc ) );

        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

        //
        // Don't break out. Continue 
        //
        NdisStatus = NDIS_STATUS_SUCCESS;
        
    }

    //
    // At this point all the resources of the call have been exhuasted and we can del the pointer in the adapter structure
    // 
    VC_ACQUIRE_LOCK (pVc);

    pVc->Hdr.pAF->pAdapter->pRecvFIFOVc = NULL;

    VC_RELEASE_LOCK (pVc);

    //
    // Decrement the Vc Refcount as the adapter no longer has a pointer to it
    //
    nicDereferenceVc (pVc);

    TRACE( TL_T, TM_Cm, ( "<== nicCmCloseCallRecvFIFO Status %x", NdisStatus) );

    return NdisStatus;
}







NDIS_STATUS
nicCmCloseCallSendFIFO (
    IN PVCCB pVc 
    )
    // Function Description:
    // This function will do clean up for Send Fifos
    // Includes removing the pointer to the Vc that is in Pdo Adapter structure.
    // For the Send FIFO, the Pdo block is in the pVc->Hdr.pRemoteNode location, so 
    // this does not try and find the pRemoteNode
    // Arguments
    // PVCCB pVc - The SendFifo that needs to be closed
    //
    // Return Value:
    // Success for now
    //
{
    NDIS_STATUS NdisStatus      = NDIS_STATUS_FAILURE;
    REMOTE_NODE * pRemoteNode               = pVc->Hdr.pRemoteNode;
    PLIST_ENTRY pVcListEntry    = NULL;
    PSENDFIFO_VCCB pTempVc      = NULL;
    BOOLEAN fVcFound            = FALSE;
    
    TRACE( TL_T, TM_Cm, ( "==> nicCmCloseCallSendFIFO pVc %x", pVc) );


    //
    // SendComplete Handler will complete the close call.
    // This thread should not do it
    // Called in nicFreeSendPacketDataStructures
    //
    #ifdef TODO
        // Free all the structures allocated for the SendFIFO. for now they are none
    #endif

    //
    // Go through the PdoCb structure and remove the VC from it's VC List
    //
    
    ASSERT (pRemoteNode != NULL);

    VC_ACQUIRE_LOCK (pVc);
    
    for (pVcListEntry = pRemoteNode->VcList.Flink;
        pVcListEntry != &pRemoteNode->VcList;
        pVcListEntry = pVcListEntry->Flink)
    {
        pTempVc = (PSENDFIFO_VCCB) CONTAINING_RECORD (pVcListEntry, VCHDR, SinglePdoVcLink);

        //
        // Now remove the Vc from that linked list
        //
        if (pTempVc == (PSENDFIFO_VCCB) pVc )
        {

            nicRemoveEntryList (pVcListEntry);          
            
            TRACE( TL_V, TM_Cm, ( "==> Removed Vc %x From Pdo's Vc List ", pVc) );

            //
            // Remove the reference from the Vc as the Pdo no longer
            // has a pointer to it. This ref was made in MakeCallInitSendFifo
            //
            nicDereferenceCall (pVc, "nicCmCloseCallSendFIFO ");
            
            NdisStatus = NDIS_STATUS_SUCCESS;
            break;
        }


    }
        
    //
    // Decerement the Ref on the Pdo as the Vc no longer has a pointer to it.
    // This Ref was made in MakeCallSendFifo function
    //

    nicDereferenceRemoteNode (pRemoteNode, "nicCmCloseCallSendFIFO ");
    
    //
    // Null, it so that if we try to access this pointer, we bugcheck 
    //
    pVc->Hdr.pRemoteNode = NULL;

    VC_RELEASE_LOCK (pVc);

    //
    // There is no reason why we should not have found the Vc in the Pdo list
    //
    ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

    TRACE( TL_T, TM_Cm, ( "<== nicCmCloseCallSendFIFO Status %x", NdisStatus) );

    NdisStatus = NDIS_STATUS_SUCCESS;
    
    return NdisStatus;
}




NDIS_STATUS
nicCmCloseCallSendChannel(
    IN PVCCB pVc 
    )
/*++

Routine Description:

  Free the channel, if its been allocated
  
Arguments:


Return Value:


--*/
{
    PADAPTERCB pAdapter = (PADAPTERCB) pVc->Hdr.pAF->pAdapter;
    PCHANNEL_VCCB pChannelVc = (PCHANNEL_VCCB)pVc;

    TRACE( TL_T, TM_Cm, ( "==>nicCmCloseCallSendChannel " ) );

    if (VC_TEST_FLAG (pVc,VCBF_AllocatedChannel) == TRUE)
    {
        nicFreeChannel (pAdapter, pChannelVc->Channel);
        nicDereferenceCall ((PVCCB)pChannelVc, "Close Call - Send Channel - Freeing Channel" );
    }
    
    TRACE( TL_T, TM_Cm, ( "<==nicCmCloseCallSendChannel " ) );
    return NDIS_STATUS_SUCCESS;

}






VOID
nicChannelCallFreeResources ( 
    IN PCHANNEL_VCCB            pChannelVc,
    IN PADAPTERCB               pAdapter,
    IN HANDLE                   hResource,
    IN ULONG                    NumDescriptors,
    IN PISOCH_DESCRIPTOR        pIsochDescriptor,
    IN BOOLEAN                  fChannelAllocated,
    IN ULONG                    Channel,
    IN PNIC_PACKET_POOL         pPacketPool
    
    )
    // Function Description:
    //  This function is called from Close call or MakeCall Failure code path.
    //  It will detach buffers, free resources, free channel and free bandwdith. 
    //  It is the responsibility of the caller to do all the appropriate ref counting
    //
    // Arguments
    //
    // pAdapter             contains the VDO to which all the IRPs were sent
    // hResource            resource handle to be used by the bus driver,
    // NumDescriptors       Number of descriptors attached to the buffer,
    // pIsochDesciptor      Original pointer to the start of the Buffer Descriptor  ,
    // Channel, -           Channel that was allocated
    //
    // Return Value:
    //    Success if all irps completed succeesfully. Wil be ignored by called
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    STORE_CURRENT_IRQL;
    TRACE( TL_T, TM_Cm, ( "==>nicChannelCallFreeResources " ) );
    TRACE( TL_V, TM_Cm,  ( "hResource %x, NumDescriptors %.2x, pIsochDescriptor %x, Channel Allocated %.2x, Channel %x",
                             hResource, NumDescriptors, pIsochDescriptor, fChannelAllocated, Channel ) )

    //
    // Reference the pdo structure so it will be around until the end
    // of this function
    // Reference decremented at the end of this function
    //
    
    ADAPTER_ACQUIRE_LOCK (pAdapter);
    nicReferenceAdapter (pAdapter, "nicChannelCallFreeResources ");
    ADAPTER_RELEASE_LOCK (pAdapter);

    //
    // Do not break out of the loop.   We need to try and free as much as possible
    //

    if (pIsochDescriptor != NULL)
    {   
        // Detach Buffers
        //
        while (pChannelVc->NumIndicatedIsochDesc != 0 )
        {
            //
            // we will wait for ever, checking periodically for all the packets to return
            //
            TRACE( TL_V, TM_Cm, ( "  nicChannelCallFreeResources  - Sleeping to wait for packets to be retuerned " ) );
        
            NdisMSleep ( FIFTY_MILLISECONDS );      

        }

        NdisStatus = nicIsochDetachBuffers( pAdapter,
                                            hResource,
                                            NumDescriptors,
                                            pIsochDescriptor );
                                        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "nicIsochDetachBuffers FAILED " ) );
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);             
        }


        // First Free Isoch Descriptors and their associated MDLs
        //
        nicFreeIsochDescriptors (NumDescriptors, pIsochDescriptor, (PVCCB)pChannelVc);
    }

    if (hResource != NULL)
    {

        // Free resources
        //
        NdisStatus = nicIsochFreeResources( pAdapter,
                                            hResource );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "nicIsochFreeResources   FAILED " ) );
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);             
        }
                             


    }

    if (fChannelAllocated == TRUE)
    {
        PULONGLONG pLocalHostChannels = &pAdapter->ChannelsAllocatedByLocalHost; 
        
        ASSERT (Channel < 64);
        
        // Free the Channel
        //

        NdisStatus = nicFreeChannel (pAdapter,
                                     Channel);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "nicIsochFreeChannel   FAILED " ) );
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);             
            
        }

        //
        // Clear the bit in the adapter;s channel bitmap
        //
        VC_ACQUIRE_LOCK (pChannelVc);

        (*pLocalHostChannels)= ((*pLocalHostChannels)  & (~(g_ullOne <<Channel)));


        VC_CLEAR_FLAGS( pChannelVc, VCBF_AllocatedChannel);

        VC_RELEASE_LOCK (pChannelVc);


                      
    }

    if (pPacketPool->Handle != NULL)
    {
        nicFreePacketPool(pPacketPool);
    }   

    //
    // Remove The Ref that was added in the beginning of the function
    //

    nicDereferenceAdapter (pAdapter, "nicChannelCallFreeResources ");


    MATCH_IRQL;

    TRACE( TL_T, TM_Cm, ( "<==nicChannelCallFreeResources " ) );
}




VOID
nicChannelCallCleanDataStructure ( 
    IN PCHANNEL_VCCB            pChannelVc,
    IN HANDLE                   hResource,
    IN ULONG                    NumDescriptors,
    IN PISOCH_DESCRIPTOR        pIsochDescriptor,
    IN BOOLEAN                  fChannelAllocated,
    IN ULONG                    Channel,
    IN NDIS_HANDLE              hPacketPoolHandle,
    OUT PULONG                  pNumRefsDecremented 
    )
    // Function Description:
    //    If any of the data fields in the ChannelVc match the
    //    corresponding argument in this structure it will be 
    //    NULLed out and the call dereferenced
    //
    //   Called with the lock held.
    //
    // Arguments
    // PCHANNEL_VCCB            pChannelVc,  - Channel Vc 
    // HANDLE                   hResource,  - Handle to resource
    // ULONG                    NumDescriptors, - Num descriptors will be set to zero
    // PISOCH_DESCRIPTOR        pIsochDesciptor,  - Pointer to array of isoch descriptors
    // BOOLEAN                  fChannelAllocated, - Was the Channel allocated
    // ULONG                    Channel,  - channel number
    // NDIS_HANDLE              hPacketPoolHandle - Packet pool handle
    //
    //
    //
    // Return Value:
    //
    //
    //
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    ULONG NumRefsDecremented      = 0;
    TRACE( TL_T, TM_Cm, ( "==>nicChannelCallCleanDataStructure " ) );

    TRACE( TL_V, TM_Cm,  ( "hResource %x, NumDescriptors %.2x, pIsochDescriptor %x, Channel Allocated %.2x, Channel %x",
                             hResource, NumDescriptors, pIsochDescriptor, fChannelAllocated, Channel ) )

    if (pChannelVc == NULL)
    {
        return ;
    }

    if ((pChannelVc->NumDescriptors  == NumDescriptors )&&
       (pChannelVc->pIsochDescriptor  == pIsochDescriptor ) &&
       pIsochDescriptor != NULL )
    {
        pChannelVc->NumDescriptors   = 0;   
        pChannelVc->pIsochDescriptor   = NULL;
        nicDereferenceCall ((PVCCB)pChannelVc, "nicChannelCallCleanDataStructure Detach Buffers ");
        NumRefsDecremented    ++;
    }

    if (hResource != NULL && pChannelVc->hResource == hResource)
    {
        pChannelVc->hResource = NULL;
        nicDereferenceCall ((PVCCB)pChannelVc, "nicChannelCallCleanDataStructure Free Resource ");
        NumRefsDecremented    ++;
    }


    if (fChannelAllocated == TRUE)
    {
        ASSERT ( VC_TEST_FLAG (pChannelVc, VCBF_AllocatedChannel) == TRUE);
        VC_CLEAR_FLAGS (pChannelVc, VCBF_AllocatedChannel);

        pChannelVc->Channel = INVALID_CHANNEL; 
        
        nicDereferenceCall ((PVCCB)pChannelVc, "nicChannelCallCleanDataStructure - Free Channel");
        NumRefsDecremented    ++;

    }

    if (hPacketPoolHandle != NULL && pChannelVc->PacketPool.Handle == hPacketPoolHandle)
    {
        pChannelVc->PacketPool.Handle  = NULL;
        nicDereferenceCall ((PVCCB)pChannelVc, "nicChannelCallCleanDataStructure  - Packet Pool");
        NumRefsDecremented    ++;
    }


    
    //REMOTE_NODE_RELEASE_LOCK (pRemoteNodePdoCb);
    
    //
    // Remove The Ref that was added in the beginning of the function
    //

    NdisStatus = NDIS_STATUS_SUCCESS;


    if (pNumRefsDecremented  != NULL)
    {
        *pNumRefsDecremented      = NumRefsDecremented   ;
    }

    TRACE( TL_T, TM_Cm, ( "<==nicChannelCallCleanDataStructure %x", *pNumRefsDecremented     ) );
}




NDIS_STATUS
NicCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmModifyQoSCallHandler' routine called by NDIS when a client
    // requests a modification in the quality of service provided by the
    // virtual circuit.  See DDK doc.
    //
{
    TRACE( TL_T, TM_Cm, ( "NicCmModQoS" ) );

    // There is no useful concept of quality of service for IP media.
    //
    return NDIS_STATUS_NOT_SUPPORTED;
}






NDIS_STATUS
NicCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST pNdisRequest )

    // Standard 'CmRequestHandler' routine called by NDIS in response to a
    // client's request for information from the call manager.
    //
{
    AFCB* pAF;
    VCCB* pVc;
    NDIS_STATUS NdisStatus;

    TRACE( TL_T, TM_Cm, ( "==>NicCmReq" ) );

    pAF = (AFCB*) CallMgrAfContext;

    if (pAF->ulTag != MTAG_AFCB )
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pVc = (VCCB* )CallMgrVcContext;

    if (pVc && pVc->Hdr.ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    #if TODO // Add 1394-specific functionality here.
    #endif
    ASSERT(pNdisRequest != NULL);
    
    switch (pNdisRequest->RequestType)
    {
        case NdisRequestQueryStatistics:
        case NdisRequestQueryInformation:

        {
            NdisStatus = nicCmQueryInformation(
                CallMgrAfContext,
                CallMgrVcContext,
                CallMgrPartyContext,
                pNdisRequest->DATA.QUERY_INFORMATION.Oid,
                pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                &pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                &pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded );
            break;
        }

        case NdisRequestSetInformation:
        {
            
            NdisStatus = nicCmSetInformation(
                CallMgrAfContext,
                CallMgrVcContext,
                CallMgrPartyContext,
                pNdisRequest->DATA.SET_INFORMATION.Oid,
                pNdisRequest->DATA.SET_INFORMATION.InformationBuffer,
                pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength,
                &pNdisRequest->DATA.SET_INFORMATION.BytesRead,
                &pNdisRequest->DATA.SET_INFORMATION.BytesNeeded );
            break;
        }

        
        default:
        {
            NdisStatus = NDIS_STATUS_NOT_SUPPORTED;
            TRACE( TL_A, TM_Mp, ( "type=%d?", pNdisRequest->RequestType ) );
            break;
        }
    }

    TRACE( TL_T, TM_Cm, ( "<==NicCmReq" ) );
    
    return NdisStatus;
}



VOID
nicDereferenceAF(
    IN AFCB* pAF )

    // Removes a reference from the address family of adapter control block
    // 'pAdapter', and when frees the block when the last reference is
    // removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement (&pAF->lRef);

    TRACE( TL_T, TM_Ref, ( "DerefAf to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        ADAPTERCB* pAdapter = pAF->pAdapter;

        // Remove linkages.
        //
        ADAPTER_ACQUIRE_LOCK (pAdapter);
        
        pAF->pAdapter = NULL;

        nicRemoveEntryList (&pAF->linkAFCB);
        
        InitializeListHead (&pAF->linkAFCB);

        ADAPTER_RELEASE_LOCK (pAdapter);

        // Tell NDIS it's close is complete.
        //

        ASSERT ( nicReadFlags (&pAF->ulFlags) & ACBF_ClosePending);
        
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseAfComp Af %x",pAF ) );
        
        NdisMCmCloseAddressFamilyComplete( 
                     NDIS_STATUS_SUCCESS, pAF->NdisAfHandle );

        //
        // Update State information to show that we have called CloseComplete
        //
        nicSetFlags ( &pAF->ulFlags, ACBF_CloseComplete);
        nicClearFlags ( &pAF->ulFlags, ACBF_ClosePending);
        



        nicDereferenceAdapter (pAdapter, "NdisMCmCloseAfComp "); // nicDereferenceFA (CloseAfComp)

        nicFreeAF (pAF);

        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseAfComp done Af %x", pAF ) );

    }
}


BOOLEAN
nicDereferenceCall(
    IN VCCB* pVc,
    IN PCHAR pDebugPrint
    )

    // Removes a reference from the call active on 'pVc', invoking call clean
    // up when the value reaches zero.
    //
    // CAlled with the lock held
{
    BOOLEAN bRefZero = FALSE;
    //
    // If the Ref goes to zero, derefref return true
    // 
    

    bRefZero = nicDereferenceRef (&pVc->Hdr.CallRef);

    TRACE( TL_V, TM_Ref, ( "***DerefCall %x to %d , %s" , pVc, pVc->Hdr.CallRef.ReferenceCount, pDebugPrint  ) );

    if ( bRefZero == TRUE)
    {
        //
        // Dereference the Vc as the Call no longer exists. This reference was
        // added in the beginning of the make call
        nicDereferenceVc (pVc);

    }
    
    return bRefZero;
 
}


VOID
nicDereferenceVc(
    IN VCCB* pVc )

    // Removes a reference to the VC control block 'pVc', and when frees the
    // block when the last reference is removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pVc->Hdr.lRef );

    TRACE( TL_V, TM_Ref, ( "DerefVC to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0 )
    {
        // If close call is pending and the refcount has gone to zero, then call 
        // 

        ASSERT( pVc->Hdr.ulTag == MTAG_VCCB );

        pVc->Hdr.ulTag = MTAG_FREED;

        FREE_VCCB( pAdapter, pVc );

        TRACE( TL_I, TM_Mp, ( "VCB freed $%p", pVc ) );
    }
}


VOID
nicFreeAF(
    IN AFCB* pAF )

    // Frees all resources allocated for address family 'pAF', including
    // 'pAF' itself.
    //
{

#if TODO
    Assert that the various lists (such as pAF->AFVCList) and resources are empty.
#endif // TODO

    pAF->ulTag = MTAG_FREED;

    FREE_NONPAGED (pAF);
}



VOID
nicReferenceAF(
    IN AFCB* pAF )

    // Adds areference to the address family of adapter block, 'pAdapter'.
    //
{
    LONG lRef=0;

    lRef = NdisInterlockedIncrement (&pAF->lRef);

    TRACE( TL_V, TM_Ref, ( "RefAf to %d", lRef ) );
}


BOOLEAN
nicReferenceCall(
    IN VCCB* pVc,
    IN PCHAR pDebugPrint
    )

    // Returns true if a reference is added to the active call on VC control
    // block, 'pVc', or false if no reference was added because no call is
    // active.
    //
{
    BOOLEAN fActive;

    
    fActive = nicReferenceRef (&pVc->Hdr.CallRef);
    
    TRACE( TL_V, TM_Ref, ( "***RefCall %x to %d , %s" , pVc, pVc->Hdr.CallRef.ReferenceCount, pDebugPrint  ) );

    if ( fActive==FALSE)
    {
        TRACE( TL_N, TM_Ref, ( "RefC Inactive" ) );
    }

    return fActive;
}


VOID
nicReferenceVc(
    IN VCCB* pVc )

    // Adds a reference to the VC control block 'pVc'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement (&pVc->Hdr.lRef);

    TRACE( TL_I, TM_Ref, ( "RefVc to %d", lRef ) );
}


NDIS_STATUS
nicAllocateRequestedChannelMakeCallComplete (
    IN PADAPTERCB pAdapter,
    IN PCHANNEL_VCCB pChannelVc,
    IN OUT PULONG pChannel
    )
    // Function Description:
    // This function allocates the channel requested in the make
    //  If any channel is requested it will try all 64. 
    //  If the broadcast channel is requested, it will look for 
    //  for the channel allocated by the BCM
    //  Other wise it will simply try and allocate the requested channel
    //
    //  This can be called from the AddFirstRemoteNode code path.
    //
    // Arguments
    //  Channel Vc - The channel Vc in question
    //  Channel - the channel requested
    //
    // Return Value:
    // Success : if allocate channel succeeds
    // pChannel  - contains the allocated channel
    //
 {
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    ULONG Channel = *pChannel;
    BOOLEAN fAnyChannel = FALSE;
    BOOLEAN fFailCall = FALSE;
    
    TRACE( TL_T, TM_Cm, ( " ==>nicAllocateRequestedChannelMakeCallComplete pAdapter, pVc %x, Channel %x ", 
                            pAdapter, pChannelVc, *pChannel ) );

    do
    {

        //
        // First make sure we have a good channel number
        //
        
        if ( (signed long)Channel < (signed long)NIC1394_BROADCAST_CHANNEL   ||
            (signed long)Channel >(signed long)MAX_CHANNEL_NUMBER)
        {
            TRACE( TL_A, TM_Cm, ( "Invalid Channel Number, channel %x", Channel) );

            NdisStatus = NDIS_STATUS_INVALID_DATA;          

            ASSERT (!(signed long)Channel < (signed long)NIC1394_BROADCAST_CHANNEL   ||
                       (signed long)Channel >(signed long)MAX_CHANNEL_NUMBER);
            
            break;
        }

        if ((signed long)Channel == NIC1394_BROADCAST_CHANNEL   )
        {
            NETWORK_CHANNELSR* pBCR;
            ULONG i = 0;
            
            pBCR = &pAdapter->BCRData.IRM_BCR;

            ADAPTER_ACQUIRE_LOCK (pAdapter);

            if (BCR_IS_VALID (pBCR) == FALSE)
            {
                BOOLEAN bWaitSuccessful  = FALSE;
                BOOLEAN fIsTheBCRFree = FALSE;
                //
                // BCM algorithm has not completed yet, we need to wait 
                //
                TRACE( TL_I, TM_Cm, ( " nicAllocateRequestedChannelMakeCallComplete : BCR Has not completed. About to wait BCR %x ", *pBCR ) );


                BCR_SET_FLAG (pAdapter, BCR_MakeCallPending);

                ADAPTER_RELEASE_LOCK (pAdapter);

                //
                // If we don't have a BCR then we should wait until the BCM algorithm completes
                //
                
                //
                // Now wait for the BCM algorithm to complete. First we will wait for 
                // 5 seconds. (5*1)
                // If we still don't see it, we will reset the bus and hope that the new 
                // iteration of BCM will succeed. 
                //


                //
                // There can 2 reasons to stop waiting, the BCR is being freed because of a 
                // standby or BCR is correct. We check both conditions
                //
  
                NdisWaitEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent, (5000));

                //
                // We reset the bus - if the BCR is not getting freed and we 
                // still do not have a valid BCR . and than we wait 
                // for the BCR to complete
                //
                if (BCR_IS_VALID(pBCR) == FALSE &&
                    (BCR_TEST_FLAGS (pAdapter, BCR_BCRNeedsToBeFreed | BCR_Freed)== FALSE))
                {
                    TRACE( TL_I, TM_Cm, ( " nicAllocateRequestedChannelMakeCallComplete WaitCompleted - About to RESET THE BUS" ) );
                    nicIssueBusReset (pAdapter, BUS_RESET_FLAGS_FORCE_ROOT );

                    //
                    // Wait for 5 minutes before failing the Make Call 
                    // (5 minutes is an experimental number)
                    //
                    {
                        BOOLEAN bWait;

                        bWait = NdisWaitEvent (
                                        &pAdapter->BCRData.MakeCallWaitEvent.NdisEvent, 
                                        ONE_MINUTE * 5 );
                        
                    }
                }

                
                ADAPTER_ACQUIRE_LOCK (pAdapter);

                NdisResetEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent);

                pAdapter->BCRData.MakeCallWaitEvent.EventCode = Nic1394EventCode_InvalidEventCode;
                BCR_CLEAR_FLAG (pAdapter, BCR_MakeCallPending);


                //
                // if we have  not got a valid BCR, then fail the call
                //
                if (BCR_IS_VALID(pBCR) == FALSE || 
                    BCR_TEST_FLAGS (pAdapter, BCR_BCRNeedsToBeFreed | BCR_Freed)) 
                {
                    fFailCall = TRUE;
                    ADAPTER_RELEASE_LOCK(pAdapter);
                    NdisStatus = NDIS_STATUS_FAILURE;
                    break;

                }


            }

            
            Channel = pBCR->NC_Channel;

            //
            // Update the VC structure and break .
            // Do not add a reference. Do not set the flag
            //

            pChannelVc->Channel = Channel;

            pChannelVc->Hdr.Nic1394MediaParams.Destination.Channel = Channel;

            //
            // Reference that this Vc now has a pointer in the BCRData. This is dereferneced 
            // in the channel close call complete.
            //
            nicReferenceCall ((PVCCB)pChannelVc, "nicAllocateRequestedChannelMakeCallComplete Broadcast VC");

            pAdapter->BCRData.pBroadcastChanneVc = pChannelVc;

        
            VC_SET_FLAG (pChannelVc, VCBF_BroadcastVc);     

            pAdapter->ChannelsAllocatedByLocalHost  = pAdapter->ChannelsAllocatedByLocalHost | (g_ullOne<<Channel);


            ADAPTER_RELEASE_LOCK (pAdapter);
            
            NdisStatus = NDIS_STATUS_SUCCESS;
            
            break;
        }

        if ((signed long)Channel == NIC1394_ANY_CHANNEL )
        {
            TRACE( TL_V, TM_Cm, ( "Requesting Any Channel %x", Channel) );

            fAnyChannel = TRUE;
            Channel = MAX_CHANNEL_NUMBER;
        }

        //
        // Now begin the request to allocate a channel
        //
        if (fAnyChannel == FALSE)
        {
            TRACE( TL_V, TM_Cm, ( "Requesting Channel %x, on remote node ", Channel ) );

        
            NdisStatus = nicAllocateChannel ( pAdapter,
                                             Channel,
                                             NULL);

        }

        else
        {
        
            //
            // we need to go through all 64 channels. 
            //
            do
            {

                NdisStatus = nicAllocateChannel ( pAdapter,
                                                 Channel,
                                                 NULL);

                if (NdisStatus != NDIS_STATUS_SUCCESS)
                {
                    if (Channel == 0 )
                    {
                        //
                        //  We now need to fail the make call as the user asked for any channel 
                        //  and none are available
                        // 
                    
                        break;
                    }
                    
                    Channel --;

                }
                else
                {
                    //
                    // We succeeded in allocating a channel .. break
                    //
                    break;
                }

            } while (TRUE);

        }

        //
        // Status of Channel allocation. If AnyChannel == TRUE then we need to make sure that 
        // a channel was allocated
        //
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {

            VC_ACQUIRE_LOCK (pChannelVc);

            VC_SET_FLAG( pChannelVc, VCBF_AllocatedChannel); 

            pChannelVc->Channel = Channel;

            pChannelVc->Hdr.Nic1394MediaParams.Destination.Channel = Channel;

            //
            // Record the channel number in the adpater structure
            //
            pAdapter->ChannelsAllocatedByLocalHost  = pAdapter->ChannelsAllocatedByLocalHost | (g_ullOne<<Channel);

            VC_RELEASE_LOCK (pChannelVc);
            
            nicReferenceCall ((PVCCB)pChannelVc, "nicAllocateRequestedChannelMakeCallComplete  -Allocated Channel");

        
        }
        else
        {
            //
            // we failed to allocate any channel and are going to fail
            //
            if (fAnyChannel == TRUE)
            {
                Channel = 0xff;
                NdisStatus = NDIS_STATUS_RESOURCES;
                break;
            }
            else
            {

                //
                // If the Call specifically wants the channel to 
                // be allocated, we return the correct channel allocate
                // status to it,
                //
                // Otherwise we overwrite and presume that another node may
                // already have allocated the channel
                //
                if (VC_TEST_FLAG (pChannelVc,VCBF_NeedsToAllocateChannel) == FALSE)
                {
                    NdisStatus = NDIS_STATUS_SUCCESS;
                    
                }
                else
                {

                    ASSERT (!"Failing make call because channel was allocated, Hit 'g'");
                }
            }

        }


    } while (FALSE);

    
    *pChannel = Channel;

    TRACE( TL_T, TM_Cm, ( "<==nicAllocateRequestedChannelMakeCallComplete Status %x Channel %x", NdisStatus, *pChannel ) );

    return NdisStatus;

}



NDIS_STATUS
nicFindRemoteNodeFromAdapter( 
    IN PADAPTERCB pAdapter, 
    IN PDEVICE_OBJECT pRemotePdo,
    IN UINT64 UniqueId,
    IN OUT REMOTE_NODE ** ppRemoteNode
    )
/*++

Routine Description:

    This routine matches either a Remote Node' pdo OR unique
    Id to the Remote node's on the adapter
    
    It walks the RemoteNode  List in the Adapter Structure 
    and tries to find a match for the Unique Id, 
    or match the remote Pdo from the adapter's PdoList
    

Arguments:
    pAdapter - pAdapter on which to search
    pRemoptePdo - Remote Pdo to find
    UniqueId - Unique Id to find
    ppRemoteNode - Remote Node structure

Return Value:
    Success if the node is found

--*/
 {
    NDIS_STATUS     NdisStatus = NDIS_STATUS_FAILURE;
    PLIST_ENTRY     pPdoListEntry = NULL;
    PREMOTE_NODE pRemoteNode = NULL;
    BOOLEAN         fPdoFound = FALSE;
    STORE_CURRENT_IRQL;
        
    TRACE( TL_T, TM_Cm, ( "==>nicFindRemoteNodeFromAdapter pAdapter is %x, ,Pdo %x, UniqueId %I64x  ", pAdapter, pRemotePdo, UniqueId ) );

    //
    // Validate the parameters 
    //
    ASSERT (pAdapter != NULL);
    TRACE( TL_I, TM_Cm, ( "    Request to Match UniqueID %I64x or pRemotePdo %x", UniqueId, pRemotePdo) );


    do 
    {
        (*ppRemoteNode) = NULL;

        ADAPTER_ACQUIRE_LOCK (pAdapter);
        
        //
        // Check for empty list
        //
        if (pAdapter->PDOList.Flink == &pAdapter->PDOList)
        {

            ADAPTER_RELEASE_LOCK (pAdapter);
            MATCH_IRQL;
            NdisStatus = NDIS_STATUS_FAILURE;
            (*ppRemoteNode) = NULL;
            TRACE( TL_A, TM_Cm, ( "    NO REMOTE NODES PRESENT FAILING MAKE CALL ") );
            break;
        }

        //
        // go through all the Pdo's on the adapter
        //
        for (pPdoListEntry = pAdapter->PDOList.Flink;
            pPdoListEntry!= &pAdapter->PDOList;
            pPdoListEntry = pPdoListEntry->Flink)
        {
            pRemoteNode = CONTAINING_RECORD( pPdoListEntry,
                                          REMOTE_NODE,
                                          linkPdo);

            //
            // Check for the two cases, i.e unique Id's match or Pdo's match
            //
            if ( pRemoteNode->UniqueId == UniqueId || pRemoteNode->pPdo == pRemotePdo)
            {
                TRACE( TL_I, TM_Cm, ( "    Matched UniqueID or pRemotePdo for Pdo%x",pRemoteNode->pPdo) );

                *ppRemoteNode = pRemoteNode;
                nicReferenceRemoteNode (pRemoteNode, "nicFindRemoteNodeFromAdapter");
                //
                // We ref pRemoteNode to keep it alive once we release the lock.
                // Caller is responsible for derefing pRemoteNode.
                //

                fPdoFound = TRUE;

                NdisStatus = NDIS_STATUS_SUCCESS;
    
                break;
            }
            else
            {
                TRACE( TL_A, TM_Cm, ( "remote node's Unique ID's %I64x, given UniqueID %I64x ", pRemoteNode->UniqueId, UniqueId ) );
            }
        

        }
        ADAPTER_RELEASE_LOCK (pAdapter);
        MATCH_IRQL;

        TRACE( TL_V, TM_Cm, ( "Is PdoFound %.2x, RemoteNode at %x ", fPdoFound, &fPdoFound )    );

        if (fPdoFound ==FALSE)
        {
            TRACE( TL_A, TM_Cm, ( "Remote Node was NOT Found: Make Call failed  " )     );
            ASSERT ((*ppRemoteNode) == NULL);
        }


    } while (FALSE);    


    TRACE( TL_T, TM_Cm, ( "<==nicFindRemoteNodeFromAdapter pPdoBlock %x",(*ppRemoteNode) ) );

    MATCH_IRQL;
    return NdisStatus;
 }







NDIS_STATUS
nicCmQueryInformation(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    )

    // Handle QueryInformation requests.  Arguments are as for the standard
    // NDIS 'CallMgrQueryInformation' handler except this routine does not
    // count on being serialized with respect to other requests.
    //
{




    NDIS_STATUS NdisStatus;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;
    USHORT usInfo;

    //  The next variables are used to setup the data structures that are 
    //  used to respond to the OIDs they correspond to
    //


    NDIS_CO_LINK_SPEED  CoLinkSpeed;
    NIC1394_LOCAL_NODE_INFO LocalNodeInfo;
    NIC1394_VC_INFO VcInfo;
    PVCCB pVc;

    TRACE( TL_T, TM_Cm, ( "==>nicCmQueryInformation %x, Vc %x", Oid, CallMgrVcContext ) );


    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof (ulInfo);

    NdisStatus = NDIS_STATUS_SUCCESS;

    // Validate the arguments
    //
    pVc = (VCCB* )CallMgrVcContext;

    if (pVc && pVc->Hdr.ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }


    // Perform the request
    //
    switch (Oid)
    {
    
        case OID_1394_VC_INFO:
        {

            // Returns information about the VC that is being queried
            //


            TRACE( TL_N, TM_Mp, ("QInfo(OID_1394_VC_INFO)") );

            VcInfo.Destination = pVc->Hdr.Nic1394MediaParams.Destination;

            pInfo = &VcInfo;

            ulInfoLen = sizeof (VcInfo);

            break;
         }

        case OID_1394_ISSUE_BUS_RESET:
        {
            PADAPTERCB pAdapter = pVc->Hdr.pAF->pAdapter;
            
            TRACE( TL_V, TM_Mp, ( " OID_1394_ISSUE_BUS_RESET" ) );

            if (InformationBufferLength == sizeof(ULONG))
            {
                nicIssueBusReset (pAdapter, (*(PULONG)InformationBuffer));
            }
            else
            {
                nicIssueBusReset (pAdapter, BUS_RESET_FLAGS_FORCE_ROOT );

            }
            break;
        }
        
        default:
        {
            TRACE( TL_A, TM_Cm, ( "Q-OID=$%08x?", Oid ) );
            NdisStatus = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        *BytesWritten  = 0;
        
        NdisStatus = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        // Copy the found result to caller's buffer.
        //
        if (ulInfoLen > 0)
        {
            NdisMoveMemory (InformationBuffer, pInfo, ulInfoLen );

            DUMPDW( TL_N, TM_Mp, pInfo, ulInfoLen );
        }

        *BytesNeeded = *BytesWritten = ulInfoLen;
    }

    TRACE( TL_T, TM_Cm, ( "<==nicCmQueryInformation %x",NdisStatus ) );

    return NdisStatus;

}





NDIS_STATUS
nicCmSetInformation(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    )
    //
    // Not implemented yet. Will be used to set information
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_NOT_SUPPORTED;
    PVCCB pVc;

    TRACE( TL_T, TM_Cm, ( "==>NicCmMakeCallInitVc Oid %x",Oid ) );

    // Validate the arguments
    //
    pVc = (VCCB* )CallMgrVcContext;

    if (pVc->Hdr.ulTag != MTAG_VCCB)
    {
        return NDIS_STATUS_FAILURE;
    }



    switch (Oid)
    {
    
        case OID_1394_CHANGE_CHANNEL_CHARACTERISTICS    :
        {
            PNIC1394_CHANNEL_CHARACTERISTICS pMcChar = NULL;
            ULONG Channel = 0;
            UINT64 ChannelMap = 0;
            ULONG i = 0;

            
            if (InformationBufferLength != sizeof (PNIC1394_CHANNEL_CHARACTERISTICS) )
            {
                
                NdisStatus = NDIS_STATUS_INVALID_DATA;
                break;
            }   

            pMcChar =   (PNIC1394_CHANNEL_CHARACTERISTICS )InformationBuffer;

            nicChangeChannelChar (pVc , 
                                pMcChar);
            
        }

        case OID_1394_ISSUE_BUS_RESET:
        {
            PADAPTERCB pAdapter = pVc->Hdr.pAF->pAdapter;
            
            TRACE( TL_V, TM_Mp, ( " OID_1394_ISSUE_BUS_RESET" ) );

            if (InformationBufferLength == sizeof(ULONG))
            {
                nicIssueBusReset (pAdapter, (*(PULONG)InformationBuffer));
            }
            else
            {
                nicIssueBusReset (pAdapter, BUS_RESET_FLAGS_FORCE_ROOT );

            }
            break;
        }
        
      



    }


    TRACE( TL_T, TM_Cm, ( "<==NicCmMakeCallInitVc %x",NdisStatus ) );

    return NDIS_STATUS_FAILURE;
}



UINT
nicNumOfActiveRemoteNodes(
    IN PADAPTERCB pAdapter 
    )

    // Function Description:
    //
    // This returns the number of active Remote Nodes on an Adapter block
    //
    // Arguments
    // pAdapter - Adapter structure on which the remote nodes exist
    //
    // Return Value:
    // Num Of Active Nodes on the current adapter
    //
    // Called with the lock held
{


    UINT NumRemoteNodes = 0;
    PLIST_ENTRY pPdoListEntry;
    REMOTE_NODE *pRemoteNode = NULL;

    TRACE( TL_T, TM_Cm, ( "==>nicNumOfActiveRemoteNodes Adapter %x",pAdapter) );


    

    pPdoListEntry = ListNext(&pAdapter->PDOList);

    while (pPdoListEntry != &pAdapter->PDOList)
    {
        pRemoteNode = CONTAINING_RECORD (pPdoListEntry, REMOTE_NODE, linkPdo);

        if (REMOTE_NODE_ACTIVE (pRemoteNode))
        {
            NdisInterlockedIncrement (&NumRemoteNodes);             
        }

        pPdoListEntry = ListNext (pPdoListEntry);
    }
    


    TRACE( TL_T, TM_Cm, ( "<==nicNumOfActiveRemoteNodes Num %d" , NumRemoteNodes) );

    return NumRemoteNodes;

}

NDIS_STATUS
nicGetActiveRemoteNode (
    PADAPTERCB pAdapter,
    PREMOTE_NODE*      ppRemoteNode
    )
    // Function Description:
    //
    // This returns the first active Remote Node on an Adapter block
    //
    // Arguments
    // pAdapter - Adapter structure on which the remote nodes exist
    //
    // Return Value:
    //  Succes if it finds an active remote node
    //
    // Called with the lock held.
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PLIST_ENTRY pPdoListEntry = NULL;
    
    TRACE( TL_T, TM_Cm, ( "==>nicGetActiveRemoteNode Adapter %x",pAdapter) );
    //
    // Search the linked list to find an active node.
    //

    
    
    pPdoListEntry = pAdapter->PDOList.Flink ;
    
    while (pPdoListEntry != &pAdapter->PDOList )
    {
        *ppRemoteNode = CONTAINING_RECORD (pPdoListEntry,
                                               REMOTE_NODE,
                                               linkPdo);

        if (REMOTE_NODE_ACTIVE(*ppRemoteNode) )
        {
            TRACE( TL_V, TM_Cm, ( "   Active Remote Node at %x", *ppRemoteNode) );
            NdisStatus = NDIS_STATUS_SUCCESS;
            break;
        }
        else
        {
            *ppRemoteNode = NULL;
        }

        pPdoListEntry = pPdoListEntry->Flink;
    }

    
    TRACE( TL_T, TM_Cm, ( "==>nicGetActiveRemoteNode Status %x, RemoteNodePdoCb %x", 
                            NdisStatus, *ppRemoteNode) );

    return NdisStatus;
}









NDIS_STATUS
nicInitRecvFifoDataStructures (
    IN PRECVFIFO_VCCB pRecvFIFOVc
    )
    
    // Function Description:
    // This function will initialize the data structures, buffers etc that are needed on 
    // all the allocate address range Irps that will be called because of the RecvFifo Vc
    //
    // Arguments
    //  pRecvFIFOVc - RecvFifo Vc structure
    //
    // Return Value:
    //  SUCCESS: If all the values are initiaized successfully
    //  Appropriate error code otherwise
{
    

    NDIS_STATUS     NdisStatus          = NDIS_STATUS_FAILURE;
    NDIS_HANDLE     PacketPoolHandle    = NULL;
    PSLIST_HEADER   pSlistHead          = NULL;
    extern  UINT    NumRecvFifos ;
    UINT            AllocateNumBuffers  = NumRecvFifos;
    NIC_PACKET_POOL PacketPool;

    TRACE( TL_T, TM_Cm, ( "==> nicInitRecvFifoDataStructures  pVc %x",pRecvFIFOVc ) );

    do
    {
        PacketPool.Handle = NULL;
        
        //
        // Initialize the PacketPool
        //

        NdisAllocatePacketPoolEx ( &NdisStatus,
                                   &PacketPool.Handle,
                                   MIN_PACKET_POOL_SIZE,
                                   MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                   sizeof (RSVD) );
        
        if (NdisStatus!= NDIS_STATUS_SUCCESS)
        {
            ASSERT(NdisStatus != NDIS_STATUS_SUCCESS);
            pRecvFIFOVc->PacketPool.Handle = NULL;
            break;
        }

        //      
        // Do not acquire the lock as we cannot have two make 
        // calls for the same Vc at the same time
        //

        //
        // Create an S-list and intialize its structures
        //

        ExInitializeSListHead (&pRecvFIFOVc->FifoSListHead);

        KeInitializeSpinLock (&pRecvFIFOVc->FifoSListSpinLock);

        pRecvFIFOVc->Hdr.MTU = pRecvFIFOVc->Hdr.Nic1394MediaParams.MTU ;
        
        TRACE( TL_I, TM_Cm, ( " Recv FIFO MTU is %d ", pRecvFIFOVc->Hdr.MTU ) );
        

        ASSERT (pRecvFIFOVc->Hdr.MTU  >= 512);
        


        //
        // Now, fill the Slist with buffers. This will be common to 
        // all the allocated address ranges on all RecvFifoVcs
        //
        
        NdisStatus = nicFillAllocateAddressRangeSList (pRecvFIFOVc, &AllocateNumBuffers);
    
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // nicFillAllocateAddressRangeSlist does its own clean up
            // but we should free the Packet Pool Allocated above
            //
            if (PacketPool.Handle != NULL)
            {
                nicFreePacketPool (&PacketPool);
            
            }

            break;
        }

        ASSERT(AllocateNumBuffers == NumRecvFifos );

        pRecvFIFOVc->PacketPool= PacketPool;
        pRecvFIFOVc->PacketPool.AllocatedPackets = 0;
        pRecvFIFOVc->NumAllocatedFifos = AllocateNumBuffers ;
        KeInitializeSpinLock (&pRecvFIFOVc->PacketPool.Lock);


        TRACE( TL_V, TM_Cm, ( "PacketPool allocated at %x", PacketPool.Handle) );

    } while (FALSE);        

    TRACE( TL_T, TM_Cm, ( "<== nicInitRecvFifoDataStructures  Status %x", NdisStatus ) );
    return NdisStatus;
}




VOID
nicUnInitRecvFifoDataStructures (
    IN PRECVFIFO_VCCB pRecvFIFOVc
    )

/*++

Routine Description:
  Frees all the resources that were allocated in nicInitRecvFifoDataStructures 

Arguments:


Return Value:


--*/
{

    if (pRecvFIFOVc->PacketPool.Handle != NULL)
    {
        ASSERT (pRecvFIFOVc->PacketPool.AllocatedPackets == 0);
        nicFreePacketPool (&pRecvFIFOVc->PacketPool);
    }
    
    pRecvFIFOVc->PacketPool.Handle = NULL;
    

    if (pRecvFIFOVc->FifoSListHead.Alignment != 0)
    {   
                        
        nicFreeAllocateAddressRangeSList(pRecvFIFOVc);

        ASSERT (pRecvFIFOVc->FifoSListHead.Alignment == 0)

    }

    pRecvFIFOVc->FifoSListHead.Alignment = 0;




}








ULONG
nicGetMaxPayLoadForSpeed(
    IN ULONG Speed,
    IN ULONG mtu
    )
    // Function Description:
    //  The purpose is to map a speed to the max payload that 
    //  can be delivered at that speed . this is limited by the Bytes PerFrameAvailable
    //
    // Arguments
    //  Speed - the speed supported by the Bus driver or the Max speed between devices
    //  BytesPerFrameAvailable Bytes per frame available on the bus. 
    //
    //
    // Return Value:
    //   Minimin of the Size determined by the payload and the size determined by the 
    //   byte per frame available.
{


    ULONG maxIsochPayload = ISOCH_PAYLOAD_400_RATE;

    TRACE( TL_T, TM_Cm, ( "<==nicGetMaxPayLoadForSpeed %x", Speed ) );

    switch (Speed) 
    {

        case SPEED_FLAGS_100:

            maxIsochPayload = ISOCH_PAYLOAD_100_RATE;
            break;

        case SPEED_FLAGS_200:

            maxIsochPayload = ISOCH_PAYLOAD_200_RATE;
            break;

        case SPEED_FLAGS_400:

            maxIsochPayload = ISOCH_PAYLOAD_400_RATE;
            break;

        case SPEED_FLAGS_800:

            maxIsochPayload = ISOCH_PAYLOAD_800_RATE;
            break;

        case SPEED_FLAGS_1600:

            maxIsochPayload = ISOCH_PAYLOAD_1600_RATE;
            break;

        default :
        
            TRACE( TL_A, TM_Cm, ( "Invalid Speed %x", Speed ) );
            ASSERT (Speed < SPEED_FLAGS_1600);
            maxIsochPayload = ISOCH_PAYLOAD_1600_RATE;
            break;

    }

    if (maxIsochPayload > mtu)
    {
        maxIsochPayload = mtu;
    }

    
    TRACE( TL_T, TM_Cm, ( "<==nicGetMaxPayLoadForSpeed, payload %x", maxIsochPayload  ) );

    return  maxIsochPayload;

}











//---------------------------------------------------------------------------------
//  SAP function - all of them return failure
//-------------------------------------------------------------------------------

NDIS_STATUS
nicRegisterSapHandler(
    IN  NDIS_HANDLE             CallMgrAfContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    )
{

    *CallMgrSapContext = NULL;
    return NDIS_STATUS_FAILURE;
}




NDIS_STATUS
nicDeregisterSapHandler(
    IN  NDIS_HANDLE             CallMgrSapContext
    )
{
    return NDIS_STATUS_FAILURE;
    
}


NDIS_STATUS
nicCmDropPartyHandler(
    IN  NDIS_HANDLE             CallMgrPartyContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    )
{
    return NDIS_STATUS_FAILURE;

}

NDIS_STATUS
nicCmAddPartyHandler(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle,
    OUT PNDIS_HANDLE            CallMgrPartyContext
    )
{
    *CallMgrPartyContext = NULL;    
    return NDIS_STATUS_FAILURE;
}








NDIS_STATUS
nicAllocateChannelResourcesAndListen (
    IN PADAPTERCB pAdapter,
    IN PCHANNEL_VCCB pChannelVc
    )
    // Function Description:
    //   This function isolated the reource and channel allocation portion 
    //  of initializing a MakeCall. This lets us do the same work when the 
    //  AddRemoteNode code path is hit and there is an existing Channel Vc 
    //
    // Arguments
    // pChannelVc, This is the send fifo that needs to be initilaized
    // 
    // Return Value:
    //
    // Success if the irps sent to the driver succeed
    //
    //


{
    NDIS_STATUS                     NdisStatus = NDIS_STATUS_FAILURE;
    PDEVICE_OBJECT                  ArrayRemotePDO[64];
    ULONG                           Channel = INVALID_CHANNEL;
    ULONG                           Speed;
    PNIC1394_MEDIA_PARAMETERS       pN1394Params;
    ULONG                           NumDescriptors = MAX_NUM_ISOCH_DESCRIPTOR;
    PISOCH_DESCRIPTOR               pIsochDescriptor = NULL;
    ULONG                           MaxBufferSize;
    ULONG                           MaxBytesPerFrame;
    HANDLE                          hResource;
    CYCLE_TIME                      CycleTime;
    ULARGE_INTEGER                  uliChannelMap;
    ULONG                           ResourceFlags = 0;
    ULONG                           State = 0;
    BOOLEAN                         fBroadcastVc = FALSE;
    BOOLEAN                         fChannelAllocate = FALSE;
    BOOLEAN                         fIsMultiChannel = FALSE;
    enum 
    {
        StartState,
        AllocatedResources,
        AllocatedBuffers,
        AttachedBuffers,
        IsochListen
    };

    
    STORE_CURRENT_IRQL;

    TRACE( TL_T, TM_Cm, ( "==> nicAllocateChannelResourcesAndListen pAdapter %x, pChannelVc %x ", 
                               pAdapter,pChannelVc ) );


    State = StartState;
    
    pN1394Params = (PNIC1394_MEDIA_PARAMETERS)&pChannelVc->Hdr.Nic1394MediaParams;

    //
    // Use the original request to figure out which channel needs to be allocated
    //
    fIsMultiChannel  = (pN1394Params->Destination.AddressType == NIC1394AddressType_MultiChannel);

    if (fIsMultiChannel  == FALSE)
    {
        Channel = pN1394Params->Destination.Channel;
    }

    do 
    {
        if (pAdapter == NULL)
        {
            BREAK (TM_Cm, ("nicAllocateChannelResourcesAndListen : pAdapter == NULL ")   );
        }

        //
        // Get the max payload that is possible for isoch receives
        //

        if (pAdapter->Speed == 0)
        {
            nicUpdateLocalHostSpeed (pAdapter);
        }   

        Speed = pAdapter->Speed;
            
        switch (Speed)
        {
            case SPEED_FLAGS_100  : 
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_100_RATE;
                break;
            }
            case SPEED_FLAGS_200 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_200_RATE ;
                break;
            }
                
            case SPEED_FLAGS_400 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }

            case SPEED_FLAGS_800 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }

            case SPEED_FLAGS_1600 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }
            
            case SPEED_FLAGS_3200 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }
            default :
            {
                ASSERT (Speed <= SPEED_FLAGS_3200 && Speed != 0 );
                pChannelVc->Hdr.MaxPayload   = ISOCH_PAYLOAD_400_RATE; 
                break;
            }

        }

        //
        // If the make call wants the channel to allocate we try and allocate the channel, 
        // In the Multichannel case, we do not allocate the channel (as this is
        // for listening purposes only )
        //

        fBroadcastVc = (Channel == NIC1394_BROADCAST_CHANNEL);
        fChannelAllocate = VC_TEST_FLAG (pChannelVc,VCBF_NeedsToAllocateChannel);
        
        
        if (fChannelAllocate  || fBroadcastVc )
        {
            ASSERT (pChannelVc->Hdr.VcType != NIC1394_MultiChannel);

            NdisStatus =  nicAllocateRequestedChannelMakeCallComplete( pAdapter,
                                                                 pChannelVc,
                                                                 &Channel );


            

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK( TM_Cm, ( " nicAllocateChannelResourcesAndListen : nicAllocateRequestedChannelMakeCallComplete FAILED") );

            }

        
            TRACE( TL_I, TM_Cm, ( "Using Channel %x, on remote node ", Channel ) );

            ASSERT (Channel < 64);  

            ResourceFlags = 0;

            uliChannelMap.QuadPart = 0;

        }
        else
        {
            //
            //  Multichannels - no allocation just update the ullChannelMap
            //
            uliChannelMap = pChannelVc->uliChannelMap;

            if (fIsMultiChannel == TRUE)
            {
                ResourceFlags = RESOURCE_USE_MULTICHANNEL; 
            }
            else
            {
                pChannelVc->Channel = Channel ;
            }
        }
        
        MaxBufferSize = min(pN1394Params->MTU + sizeof(GASP_HEADER) , pChannelVc->Hdr.MaxPayload);

        MaxBytesPerFrame =  MaxBufferSize;

        TRACE( TL_V, TM_Cm, ( "   MAxBufferSize %x, MaxBytesPerFrame  %x", MaxBufferSize, MaxBytesPerFrame ) );

        //
        // Add the flags used for resources allocation
        //
        ResourceFlags |= (RESOURCE_USED_IN_LISTENING | RESOURCE_USE_PACKET_BASED  | RESOURCE_BUFFERS_CIRCULAR); 
            
        
        //
        // MaxBufferSize should be an integral mutiple of MaxBytesPerFram
        //
        ASSERT (MaxBufferSize % MaxBytesPerFrame == 0);

        //
        // Noe allocate the resource 
        //
        NdisStatus = nicIsochAllocateResources( pAdapter,
                                             Speed,
                                             ResourceFlags, 
                                             Channel,
                                             MaxBytesPerFrame,
                                             NumDescriptors,
                                             MaxBufferSize,
                                             0, //QuadletsToStrip,
                                             uliChannelMap,
                                             &hResource); 

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            hResource = NULL;
            BREAK(TM_Cm, ( "Allocate Resources Failed. Make Call failed ") );
        }
    
        State = AllocatedResources;
        
        ASSERT (NumDescriptors != 0);       

        ASSERT (pChannelVc->Hdr.MTU  != 0);

        // 
        // Get Isoch Descriptors that will be submitted to the Bus drivers
        // 

        //
        // Add room for the Isoch Header and Isoch prefix
        //
        MaxBufferSize += ISOCH_PREFIX_LENGTH        ;

        NdisStatus = nicAllocateAndInitializeIsochDescriptors (pChannelVc,
                                                          NumDescriptors,
                                                          MaxBufferSize,
                                                          &pIsochDescriptor );
        if(NdisStatus != NDIS_STATUS_SUCCESS)
        {
            
            BREAK (TM_Cm, (" nicAllocateAndInitializeIsochDescriptors  failed, Make Call Failed") );
        }
        
        ASSERT (pIsochDescriptor != NULL);

        State = AllocatedBuffers;

        NdisStatus = nicIsochAttachBuffers( pAdapter, 
                                         hResource,
                                         NumDescriptors,
                                         pIsochDescriptor);
                                        

        if (NdisStatus != NDIS_STATUS_SUCCESS)  
        {
            BREAK (TM_Cm, "nicIsochAttachBuffers FAILED");
        }

        State = AttachedBuffers;

        //
        // Start the Listen
        //
        NdisZeroMemory (&CycleTime, sizeof(CycleTime));
        
        NdisStatus = nicIsochListen (pAdapter,
                                     hResource,
                                     0,
                                     CycleTime ); // Cycle Time is Zero
        //
        // Update the Vc structure, because we have now succeeded
        //
        State = IsochListen;

        VC_ACQUIRE_LOCK (pChannelVc);
                
        //
        // If broadcast channel, then decrease the speed setting, and fragment
        //
        if (Channel == NIC1394_BROADCAST_CHANNEL)
        {
            
            Speed = SPEED_FLAGS_200   ;
            pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_200_RATE ;
        }

        

        pChannelVc->Channel = Channel;
        pChannelVc->MaxBufferSize = MaxBufferSize - ISOCH_PREFIX_LENGTH;
        pChannelVc->Speed = Speed;
        
        pChannelVc->hResource = hResource;
        //
        // Reference Call for allocated resource handle
        //
        nicReferenceCall ( (PVCCB) pChannelVc, "nicAllocateRequestedChannelMakeCallComplete - allocate resources ");

        pChannelVc->NumDescriptors = NumDescriptors;
        pChannelVc->pIsochDescriptor = pIsochDescriptor;
        //
        // Reference the call because we will now need to detach buffers
        //
        nicReferenceCall ( (PVCCB) pChannelVc, "nicAllocateRequestedChannelMakeCallComplete  - Attach Buffers");


        //
        // We have succeded in allocating all resources. 
        // If the Freed Resources flag is set it needs to be cleared
        //
        VC_CLEAR_FLAGS (pChannelVc, VCBF_FreedResources);           
        VC_RELEASE_LOCK (pChannelVc);

        //
        // No more failures
        //
    } while (FALSE);


    //
    // Time to do clean up based on what resources were allocated.
    //  There are no failures after the point where the refs for
    //  Allocate Resources and Attach Buffers are added, so 
    //  No Derefs in the following code except in ( FreeIsochDesc)
    //
    if (NdisStatus != NDIS_STATUS_SUCCESS )
    {
        BOOLEAN fAllocatedChannel = FALSE;

        switch (State)
        {
            case  IsochListen:
            {
                nicIsochStop(pAdapter, hResource);
                FALL_THROUGH
            }
            case AttachedBuffers:
            {
                nicIsochDetachBuffers( pAdapter,
                                   hResource,
                                   NumDescriptors,
                                   pIsochDescriptor );
                                        

                FALL_THROUGH;
            }
            case  AllocatedBuffers:
            {
                //
                // Free the isoch Buffers and Descriptors that were
                // allocated
                //
                nicFreeIsochDescriptors(NumDescriptors,
                                    pIsochDescriptor, 
                                    (PVCCB) pChannelVc);
                
                FALL_THROUGH
            }

            case  AllocatedResources:
            {
                //
                // Free the Isoch Resources Handle 
                //
                nicIsochFreeResources (pAdapter, hResource);
                FALL_THROUGH
            }

            case  StartState:
            {
                FALL_THROUGH
            }
            default:
            {
            
                break;
            }
        }
        VC_ACQUIRE_LOCK (pChannelVc);

        //
        // Update Flags in the VC structure
        //
        VC_SET_FLAG  (pChannelVc, VCBF_FreedResources);         
        
        fAllocatedChannel = VC_TEST_FLAGS( pChannelVc, VCBF_AllocatedChannel);

        //
        // Do we need to free a channel as well
        //
        if (fAllocatedChannel  == TRUE)
        {
            Channel = pChannelVc->Channel;
            pChannelVc->Channel = INVALID_CHANNEL; 

            nicDereferenceCall ((PVCCB) pChannelVc, "Free Allocated Channel");
        }   
        VC_RELEASE_LOCK (pChannelVc);


        if (fAllocatedChannel)
        {
            nicFreeChannel (pAdapter, pChannelVc->Channel);
        }

        
    }  // end of failure code path

    TRACE( TL_T, TM_Cm, ( "<== nicAllocateChannelResourcesAndListen NdisStatus %x ",NdisStatus) );

    MATCH_IRQL;
    return NdisStatus;
    

}




NDIS_STATUS
nicQueryRemoteNodeCaps (
    IN PADAPTERCB pAdapter,
    IN PREMOTE_NODE pRemoteNode,
    OUT PULONG pSpeedTo,
    OUT PULONG pMaxBufferSize,
    OUT PULONG pMaxRec
    )
/*++

Routine Description:

 Queries the remote Node for speed and max size

Arguments:
    pSpeedTo        -- max speed to the remote node. From nodes config rom.
                          in units of SCODE_XXX_RATE.
    pMaxBufferSize  -- max buffer size to use ( this is the min of local,
                          remote and max allowed by *pSpeedTo).
    pMaxRec         -- maxrec of the remote node -- from the node's config
                         rom.


Return Value:


--*/
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    ULONG Speed = 0;        // Speed in units of SPEED_FLAG_XXX
    ULONG MaxBufferSize;
    PVOID pCRom = NULL;
    PCONFIG_ROM pBusInfo = NULL;
    ULONG SpeedMaxRec = 0;
    ULONG MaxRec= 0;
    ULONG MinMaxRec= 0;

    TRACE( TL_T, TM_Cm, ( "==> nicQueryRemoteNodeCaps pRemoteNode%x ",pRemoteNode) );

    do 
    {
        ASSERT (KeGetCurrentIrql()==PASSIVE_LEVEL);
    
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        if (REMOTE_NODE_ACTIVE (pRemoteNode) == FALSE)
        {
            NdisStatus = NDIS_STATUS_DEST_OUT_OF_ORDER;

            ADAPTER_RELEASE_LOCK (pAdapter);

            break;
        }

        ADAPTER_RELEASE_LOCK (pAdapter);

    
        NdisStatus = nicGetMaxSpeedBetweenDevices (pAdapter,
                                                   1 ,
                                                   &pRemoteNode->pPdo,
                                                   &Speed);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Cm, (" nicQueryRemoteNodeCaps   : nicGetMaxSpeedBetweenDevices FAILED") );
        
        }
        
        TRACE( TL_V, TM_Cm, ( "nicGetMaxSpeedBetweenDevices  Speed %x ",Speed) );

        //
        //  This is the MaxRec from the Actual speed of 
        //  the link.
        //  

        SpeedMaxRec = nicGetMaxRecFromSpeed(Speed);



        //
        // Now get the max rec from the config rom
        //

        NdisStatus = nicGetConfigRom (pRemoteNode->pPdo, &pCRom);


        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Cm, (" nicQueryRemoteNodeCaps   : nicGetMaxSpeedBetweenDevices FAILED") );
        
        }

        //
        // Now extract the bus info, and get the remoteNode's MaxRec
        // The max rec is a 4-bit field at location 0x0000f000.
        // See for example Figure 11-3: Format of the Bus_Info_Block in
        // the Mind Share Inc's FireWire System Architecture book.
        //
        //
        pBusInfo = (PCONFIG_ROM) pCRom;

        MaxRec = SWAPBYTES_ULONG (pBusInfo->CR_BusInfoBlockCaps);

        MaxRec &= 0xf000;

        MaxRec = MaxRec >> 12;


        //
        // Take the minimum of the adapter, the remote node
        // and the link's maxRec
        //
        MinMaxRec = min (MaxRec, pAdapter->MaxRec);
        MinMaxRec = min (MinMaxRec, SpeedMaxRec);

        switch (MinMaxRec)
        {
            case MAX_REC_100_RATE:
            {
                MaxBufferSize = ASYNC_PAYLOAD_100_RATE ;
                break;
            }
            case MAX_REC_200_RATE:
            {
                MaxBufferSize = ASYNC_PAYLOAD_200_RATE;
                break;
            }
            case MAX_REC_400_RATE :
            {
                MaxBufferSize = ASYNC_PAYLOAD_400_RATE;
                break;
            }
            
            default: 
            {
                //                    
                // Use the 400 size for all larger payloads.
                //
                MaxBufferSize = ASYNC_PAYLOAD_400_RATE;
                break;
            }

        }


        TRACE( TL_N, TM_Cm, (" MaxRec %x\n", MaxRec ) );

    } while (FALSE);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        Speed = nicSpeedFlagsToSCode(Speed);
        *pSpeedTo = Speed;
        *pMaxBufferSize = MaxBufferSize;
        *pMaxRec = MaxRec;

        // Update the remote node's cached caps.
        //
        REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);
        pRemoteNode->CachedCaps.SpeedTo = Speed;
        pRemoteNode->CachedCaps.EffectiveMaxBufferSize = MaxBufferSize;
        pRemoteNode->CachedCaps.MaxRec = MaxRec;
                                           
        REMOTE_NODE_RELEASE_LOCK (pRemoteNode);
    }
    
    if (pCRom != NULL)
    {
        FREE_NONPAGED (pCRom);
    }

    TRACE( TL_T, TM_Cm, ( "<== nicQueryRemoteNodeCaps pRemoteNode%x , NdisStatus %x",pRemoteNode, NdisStatus) );
    return NdisStatus;
}











NDIS_STATUS
nicChangeChannelChar (
    PVCCB pVc, 
    PNIC1394_CHANNEL_CHARACTERISTICS pMcChar
    )
/*++

Routine Description:

    If a channel has been allocated it sends Isoch Modify Irp Down to the bus driver 
    else
    it sets up the call parameters and calls the AllocateResourcesAndListen function:

    This is called through an Ndis Request which is gauranteed to be serialized. this function is not re-entrant
    
Return Value:

    Success - if all operations succeed
--*/
{

    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    PCHANNEL_VCCB           pMcVc = (PCHANNEL_VCCB) pVc;
    BOOLEAN                 fVcActive = TRUE;
    ULONG                   AllocatedChannel = 0xff;
    ULARGE_INTEGER          uliPrevMap ;
    ULARGE_INTEGER          uliChannelMap ;
    PULARGE_INTEGER         pChannelNum = NULL;
    ULONG                   ulPrevSpeed;

    STORE_CURRENT_IRQL;
    

    TRACE( TL_T, TM_Cm, ( "==> nicChangeChannelChar  pVc %x , Channel %x,  Speed %x ",pMcVc, pMcChar->ChannelMap, pMcVc->Speed) );

    do
    {
        //
        // Validate 
        //
/*      if ( pMcVc->ulTag != MTAG_VCCB ||
           pMcVc->Hdr.Nic1394MediaParams.Destination.AddressType != NIC1394AddressType_MultiChannel)
        {
                BREAK( TM_Cm, ("Tag or AddressType is invalid  "));
        }
*/      //


        uliChannelMap = pMcChar->ChannelMap;


        TRACE ( TL_V, TM_Cm, ("MultiChannel Modify Isoch Map %I64x,  Speed %x",
                              uliChannelMap, pMcChar->Speed ) );


        //
        // Check to see if this is a zero to N transition
        //
        VC_ACQUIRE_LOCK (pMcVc);
        
        uliPrevMap = pMcVc->uliChannelMap;

        pMcVc->uliChannelMap = uliChannelMap;

        ulPrevSpeed = pMcVc->Speed;
        
        pMcVc->Speed = pMcChar->Speed;

        VC_RELEASE_LOCK (pMcVc);
        
        if (pMcVc->hResource == NULL)
        {   
            //
            // No Resources have been allocated. Allocate resources 
            //
        
            NdisStatus = nicAllocateChannelResourcesAndListen (pMcVc->Hdr.pAF->pAdapter, pMcVc );

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK( TM_Cm, ("MultiChannel AllocateChannelResourcesAnd Listen FAILED") ) ;
            }

        }

            
        //
        // A Channel has been previously allocated, we need to change it 
        // and use the new channel instead
        //
        NdisStatus = nicIsochModifyStreamProperties (pMcVc->Hdr.pAF->pAdapter,
                                              pMcVc->hResource,
                                              uliChannelMap,
                                              pMcChar->Speed);
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {

            BREAK (TM_Cm, ("Modify Isoch Properties failed" ) );
        }



    } while (FALSE);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        VC_ACQUIRE_LOCK (pMcVc);

        pMcVc->uliChannelMap = uliPrevMap;
        pMcVc->Speed = ulPrevSpeed;

        VC_RELEASE_LOCK (pMcVc);

    }
    
    TRACE( TL_T, TM_Cm, ( "<== nicChangeChannelChar  NdisStatus %x ",NdisStatus) );

    MATCH_IRQL;
    return NdisStatus;
}










VOID 
nicInterceptMakeCallParameters (
    PCO_MEDIA_PARAMETERS pMedia     
    )
    
{

    PNIC1394_MEDIA_PARAMETERS p1394Params = (PNIC1394_MEDIA_PARAMETERS )(pMedia->MediaSpecific.Parameters);

#if INTERCEPT_MAKE_CALL 


    if (p1394Params->Destination.AddressType == NIC1394AddressType_MultiChannel)
    {
        p1394Params->Destination.AddressType = NIC1394AddressType_Channel;
        p1394Params->Destination.Channel = 0x3a;
        p1394Params->Flags |= NIC1394_VCFLAG_ALLOCATE;
        pMedia->Flags |= TRANSMIT_VC;
        pMedia->Flags &= (~RECEIVE_VC);
        return;
        
    }

    if (p1394Params->Destination.AddressType == NIC1394AddressType_Ethernet)
    {
        p1394Params->Destination.AddressType = NIC1394AddressType_Channel;
        p1394Params->Destination.Channel = 0x3a;
        pMedia->Flags |= RECEIVE_VC;
        pMedia->Flags &= (~TRANSMIT_VC);
        return;

    }


#endif
}


UINT
nicSpeedFlagsToSCode(
    IN UINT SpeedFlags
    )
{
    UINT SCode = SCODE_400_RATE;

    switch (SpeedFlags)
    {
        case SPEED_FLAGS_100  : 
        {
            SCode = SCODE_100_RATE;
            break;
        }
        case SPEED_FLAGS_200 :
        {
            SCode = SCODE_200_RATE;
            break;
        }
            
        case SPEED_FLAGS_400 :
        {
            SCode = SCODE_400_RATE;
            break;
        }

        case SPEED_FLAGS_800 :
        {
            SCode = SCODE_800_RATE;
            break;
        }

        case SPEED_FLAGS_1600 :
        {
            SCode = SCODE_1600_RATE;
            break;
        }

        case SPEED_FLAGS_3200 :
        {
            SCode = SCODE_3200_RATE;
            break;
        }

        default :
        {
            ASSERT (!"SpeedFlags out of range");
            
            break;
        }
    }

    return SCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\channel.c ===
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// send.c
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port Send routines
//
// 05/15/1999 ADube Created, 
//




#include <precomp.h>




//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

extern ULONG           NdisBufferAllocated[NoMoreCodePaths];
extern ULONG           NdisBufferFreed[NoMoreCodePaths];


NDIS_STATUS
nicGetIsochDescriptors(
    IN UINT Num,
    OUT PPISOCH_DESCRIPTOR  ppIsochDescriptor
    );



NDIS_STATUS
nicInitializeIsochDescriptor (
    IN PCHANNEL_VCCB pChannelVc,
    IN PMDL pMdl,
    IN PISOCH_DESCRIPTOR pIsochDesriptor
    );


VOID
nicIsochRxCallback (
    IN PVOID Context1,
    IN PVOID Context2
    );

ULONG           ReassemblyCompleted = 0;

//-----------------------------------------------------------------------------
// prototypes implementations (alphabetically)
//-----------------------------------------------------------------------------





NDIS_STATUS
nicAllocateAndInitializeIsochDescriptors (
    IN PCHANNEL_VCCB pChannelVc,
    IN UINT NumDescriptors,
    IN UINT BufferLength,
    IN OUT PPISOCH_DESCRIPTOR  ppIsochDescriptor
    )

    
    // Function Description:
    //   This function allocate and initializes a 
    //   a numer of isoch descriptors all allocated 
    //   together.
    //   This should allocate isoch desc, 
    //   get local memory, get mdls 
    //   initialize mdl, isoch _desc and then return
    //
    //
    // Arguments
    //  ChannelVc- this contains all the other argumernts, size
    //  num of descriptors,etc
    //  ppIsochDescriptor- will contain the pointer to the allocated 
    //  array of IsochDescriptor
    //
    //
    // Return Value:
    //  Success if all the memory allocations succeeded 
    //
    //
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    UINT Size;
    UINT index =0;
    PMDL pMdl = NULL;
    PVOID pLocalBuffer = NULL;

    TRACE( TL_T, TM_Recv, ( "==>nicAllocateAndInitializeIsochDescriptors Vc %.8x, Num %.8x", 
                                 pChannelVc, NumDescriptors) );
    TRACE( TL_V, TM_Recv, ( "Max BuffferSize %.8x", pChannelVc, BufferLength) );

    do
    {
        
        NdisStatus = nicGetIsochDescriptors (NumDescriptors, ppIsochDescriptor);

    
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK ( TM_Recv, "nicGetIsochDescriptors FAILED" );
        }

        ASSERT (*ppIsochDescriptor != NULL);

        while (index < NumDescriptors)
        {
            //
            // Get a local that point to the isoch descriptor that needs to be initialized
            //
            PISOCH_DESCRIPTOR pIsochDescriptor = NULL;
            pIsochDescriptor = (PISOCH_DESCRIPTOR)((ULONG_PTR)(*ppIsochDescriptor)+ index*sizeof(ISOCH_DESCRIPTOR));
            //
            // Get Locally owned memory for the data
            // 
            NdisStatus = nicGetLocalBuffer (BufferLength, &pLocalBuffer);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK ( TM_Recv, ( "nicGetLocalBuffer FAILED " ) );
            }
            
            //
            // Get an MDL and initialze the MDL with the buffer 
            //
            NdisStatus = nicGetMdl ( BufferLength,
                                    pLocalBuffer,
                                    &pMdl);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK ( TM_Recv, ( "nicGetMdl FAILED " ) );
            }

            //
            // this reference will be removed when the MDL will be freed 
            // in FreeSingleIsochDescriptor
            //
            nicReferenceCall ((PVCCB)pChannelVc, "nicAllocateAndInitializeIsochDescriptors " );

            NdisStatus = nicInitializeIsochDescriptor (pChannelVc,
                                                  pMdl,
                                                  pIsochDescriptor);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK ( TM_Recv, ( "nicInitializeIsochDescriptor FAILED " ) );
            }
                               
            index++;
        }


    } while (FALSE);


    TRACE( TL_T, TM_Recv, ( "==>nicAllocateAndInitializeIsochDescriptors Status %.8x", NdisStatus) );

    return NdisStatus;

}


NDIS_STATUS
nicFreeIsochDescriptors(
    IN UINT Num,
    IN PISOCH_DESCRIPTOR  pIsochDescriptor,
    IN PVCCB pVc
    )
    // Function Description:
    //   Free Num number of IsochDescriptors
    //
    // Arguments
    //  Num number of descriptors
    //  Start of the allocated memory
    //
    //
    // Return Value:
    //  Success if all the memory allocations succeeded 
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PISOCH_DESCRIPTOR pCurrDesc = pIsochDescriptor;
    UINT i=0;

    
    TRACE( TL_T, TM_Recv, ( "==>nicFreeIsochDescriptors Num %.8x, pIsochDescriptor %x", Num, pIsochDescriptor ) );
    do 
    {
        if (pIsochDescriptor == NULL)
        {
            break;
        }
        
        pCurrDesc = pIsochDescriptor;

        while (i < Num)
        {
            nicFreeSingleIsochDescriptor( pCurrDesc, pVc);

            pCurrDesc  = (PISOCH_DESCRIPTOR)((PUCHAR)pCurrDesc + sizeof(ISOCH_DESCRIPTOR));

            i++;

        }       
        
        FREE_NONPAGED (pIsochDescriptor);   

    } while (FALSE);

    NdisStatus = NDIS_STATUS_SUCCESS;

    TRACE( TL_T, TM_Recv, ( "<==nicGetIsochDescriptors Status %.8x", NdisStatus ) );
    return NdisStatus;
    
}



NDIS_STATUS
nicFreeSingleIsochDescriptor(
    IN PISOCH_DESCRIPTOR  pIsochDescriptor,
    IN PVCCB pVc
    )
    // Function Description:
    //   Free IsochDescriptor and its MDL
    //
    // Arguments
    //  Start of the isochDesc
    //
    //
    // Return Value:
    //  Success if all the memory allocations succeeded 
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PCHANNEL_VCCB pChannelVc = pIsochDescriptor->Context1;

    ASSERT (pVc == (PVCCB)pChannelVc);
    
    TRACE( TL_T, TM_Recv, ( "==>nicFreeSingleIsochDescriptor pIsochDescriptor %x", pIsochDescriptor ) );

    //
    // Lets make sure we have a VC and Channel VC 
    //
    ASSERT (pChannelVc->Hdr.ulTag == MTAG_VCCB );

    //
    // Just to protect ourselves against a bad isoch descriptor
    //
    if (pIsochDescriptor->Mdl != NULL)
    {
        PVOID pVa = MmGetMdlVirtualAddress(pIsochDescriptor->Mdl);
        ULONG Length = MmGetMdlByteCount(pIsochDescriptor->Mdl);
            
        nicDereferenceCall ((PVCCB)pChannelVc, "nicFreeSingleIsochDescriptors ");

        nicFreeMdl (pIsochDescriptor->Mdl);

        nicFreeLocalBuffer(Length, pVa);
    }
    else
    {
        ASSERT (pIsochDescriptor->Mdl != NULL);
    }
    
    
    NdisStatus = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Recv, ( "<==nicFreeSingleIsochDescriptors Status %.8x", NdisStatus ) );
    return NdisStatus;
    
}




NDIS_STATUS
nicGetIsochDescriptors(
    IN UINT Num,
    OUT PPISOCH_DESCRIPTOR  ppIsochDescriptor
    )
    // Function Description:
    //   The function returns a block of contigious memory of size
    //   Num * sizeof (ISOCH_DESCRIPTOR)
    //
    //
    // Arguments
    //  Num number of descriptors
    //  Start of the allocated memory
    //
    //
    // Return Value:
    //  Success if all the memory allocations succeeded 
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PVOID pMemory = NULL; 
    
    TRACE( TL_T, TM_Recv, ( "==>nicGetIsochDescriptors Num %.8x", Num) );

    pMemory = ALLOC_NONPAGED (Num*sizeof(ISOCH_DESCRIPTOR),  MTAG_CBUF  );  

    if (pMemory != NULL)
    {
        NdisStatus = NDIS_STATUS_SUCCESS;
        *ppIsochDescriptor = (PISOCH_DESCRIPTOR)pMemory;
    
    }
    else
    {
        *ppIsochDescriptor  = NULL;
        TRACE( TL_A, TM_Recv, ( "<==nicGetIsochDescriptors About to Fail") );
        ASSERT (*ppIsochDescriptor  != NULL);

        
    }

    TRACE( TL_T, TM_Recv, ( "<==nicGetIsochDescriptors Status %.8x, StartAddress %.8x", NdisStatus , *ppIsochDescriptor) );
    return NdisStatus;
    
}



NDIS_STATUS
nicInitializeIsochDescriptor (
    IN PCHANNEL_VCCB pChannelVc,
    IN PMDL pMdl,
    IN OUT PISOCH_DESCRIPTOR pIsochDescriptor
    )
    // Function Description:
    //   Initializes the Isoch_desciptor using the fields in
    //   the Channel Vc Block and the Mdl
    //
    // Arguments
    //   ChannelVc- Pointer to the Channel Vc which will own 
    //              Descriptor, also contains information
    //   pMdl- The IsochDescriptor will get a pointer to this Mdl
    //   pIsochDescriptor - is the descriptor whose fields will get 
    //                    initialized
    //
    // Return Value:
    //  Success if all the memory allocations succeeded 
    //


{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;

    TRACE( TL_T, TM_Recv, ( "==>nicInitializeIsochDescriptor Vc %.8x, Mdl ", pChannelVc, pMdl) );

    pIsochDescriptor->fulFlags = DESCRIPTOR_SYNCH_ON_TAG;

    //
    // Mdl pointing to buffer
    //
    pIsochDescriptor->Mdl = pMdl;

    //
    // Length of combined buffer(s) as represented by the Mdl
    //
    pIsochDescriptor->ulLength = MmGetMdlByteCount(pMdl);

    //
    // Payload size of each Isoch packet to be used in this descriptor
    //
    pIsochDescriptor->nMaxBytesPerFrame = MmGetMdlByteCount(pMdl);

    //
    // Synchronization field; equivalent to Sy in the Isoch packet
    //
    pIsochDescriptor->ulSynch= 0;

    //
    // Synchronization field; equivalent to Tag in the Isoch packet. 
    //
    pIsochDescriptor->ulTag = g_IsochTag;

    //
    // Cycle time field; returns time to be sent/received or when finished
    //
    //    (ULONG)pIsochDescriptor->CycleTime=0;

    //
    // Callback routine (if any) to be called when this descriptor completes
    //
    pIsochDescriptor->Callback = nicIsochRxCallback;

    //
    // First context (if any) parameter to be passed when doing callbacks
    //
    pIsochDescriptor->Context1 = pChannelVc;

    //
    // Second context (if any) parameter to be passed when doing callbacks
    //
    pIsochDescriptor->Context2 = pIsochDescriptor;

    //
    // Holds the final status of this descriptor. Assign a bogus value
    //
    pIsochDescriptor->status = STATUS_INFO_LENGTH_MISMATCH;

    NdisStatus = NDIS_STATUS_SUCCESS;

    TRACE( TL_T, TM_Recv, ( "<==nicInitializeIsochDescriptors  Status %.8x, IsochDesc %.8x", NdisStatus, pIsochDescriptor) );
    return NdisStatus;
}




VOID
nicIsochRxCallback (
    PVOID Context1,
    PVOID Context2
    )
/*++

Routine Description:
    This is the callback routine passed to bus driver
    This function does some channel specific work and calls the common callback routine

Arguments:
    Context1 - pChannel Vc
    Context2 - pIsochDescriptor2

Return Value:


--*/
    
{
    PISOCH_DESCRIPTOR pIsochDescriptor = (PISOCH_DESCRIPTOR)Context2;
    PVCCB pVc = (PVCCB) Context1;

    MARK_ISOCH_DESCRIPTOR_INDICATED (pIsochDescriptor);
    STORE_CHANNELVC_IN_DESCRIPTOR (pIsochDescriptor, pVc );
    NdisInterlockedIncrement (&((PCHANNEL_VCCB)pVc)->NumIndicatedIsochDesc);
    CLEAR_DESCRIPTOR_NEXT (pIsochDescriptor);
    pIsochDescriptor->Mdl->Next = NULL;
    

    nicReceiveCommonCallback (pIsochDescriptor ,
                            pVc,
                            IsochReceive,
                            pIsochDescriptor->Mdl);
}



VOID
nicReceiveCommonCallback (
    IN PVOID pIndicatedStruct,
    IN PVCCB pVc,
    BUS_OPERATION RecvOp,
    PMDL pMdl
    )
/*++

Routine Description:

    This function is the common receive code for Isoch and Fifo Recv

    It allocate an NdisBuffer that points to the Ip1394 data
    If packet is complete (i.e reassembly is complete) , then it allocates an ndis packet
        and indicates it up to Ndis


Arguments:
    pIndicatedStruct - Isoch Desc. or Address fifo,
    pVc - VC on which data was indicated, 
    RecvOp - Isoch or Fifo,
    pMdl - Mdl associated with the Isoch Desc or Fifo. 
           Passed in seperately for ease of use (debugging)


Return Value:
    None

--*/



{
    NDIS_STATUS                         NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS1394_REASSEMBLY_STRUCTURE      pReassembly = NULL;
    NIC_RECV_DATA_INFO                  RcvInfo;
    ULONG                               DataLength = 0;
    BOOLEAN                             fVcActive = FALSE;
    ULONG                               ulValidDataLength = 0;
    PVOID                               pStartValidData = NULL;
    PNDIS_BUFFER                        pHeadNdisBuffer = NULL;
    PADAPTERCB                          pAdapter = NULL;
    BOOLEAN                             fPacketCompleted  = FALSE;
    PNDIS_PACKET                        pMyPacket = NULL;
    ULONG                               PacketLength = 0;
    PPKT_CONTEXT                        pPktContext = NULL;
    NDIS_STATUS                         IndicatedStatus = NDIS_STATUS_FAILURE;
    PVOID                               pIndicatedChain = NULL;

    
    STORE_CURRENT_IRQL;

    
    ASSERT (pMdl != NULL);

    ASSERT (RecvOp == IsochReceive || RecvOp == AddressRange);

    TRACE( TL_T, TM_Recv, ( "==>nicReceiveCommonCallback pVc %x, IndicatedStruc %x, Mdl %x", 
                              pVc, pIndicatedStruct , pMdl ) );



    do 
    {
    

        if (pVc->Hdr.ulTag != MTAG_VCCB)
        {
            ASSERT (pVc->Hdr.ulTag == MTAG_VCCB);
            NdisStatus = NDIS_STATUS_VC_NOT_ACTIVATED;

            break;
        }
        //
        // First, we need to check if we still have an active make call. VC will be present will bus driver
        // has buffers
        //

        fVcActive = VC_ACTIVE (pVc) ;

        if (fVcActive == TRUE)
        {
            pAdapter = pVc->Hdr.pAF->pAdapter;
        }

        
        
        if (fVcActive == FALSE ) 
        {
            TRACE( TL_N, TM_Recv, ( "We do not have a valid VC Block  %x ",pVc) );   

            NdisStatus = NDIS_STATUS_VC_NOT_ACTIVATED;

            break;
        }


        NdisStatus = nicValidateRecvData ( pMdl,
                                      RecvOp,
                                      pIndicatedStruct,
                                      pVc  ,
                                      &RcvInfo);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE (TL_A, TM_Recv, ("Invalid Data Received pMdl %x, RecvOp %x, pVc %x", 
                                    pMdl, RecvOp, pVc) );
            break;
        }

                                        
        nicDumpMdl (pMdl, RcvInfo.Length1394, "Received Mdl\n");


#ifdef PKT_LOG
            
        {
            

            if (RecvOp == IsochReceive)
            {
                PPACKET_FORMAT pPacketFormat = (PPACKET_FORMAT)RcvInfo.p1394Data; 
                GASP_HEADER GaspHeader = pPacketFormat->IsochReceiveNonFragmented.GaspHeader;
                GaspHeader.FirstQuadlet.GaspHeaderHigh = SWAPBYTES_ULONG (GaspHeader.FirstQuadlet.GaspHeaderHigh);


                NIC1394_LOG_PKT(
                    pVc->Hdr.pAF->pAdapter,
                    NIC1394_LOGFLAGS_RECV_CHANNEL,
                    GaspHeader.FirstQuadlet.u.GH_Source_ID, // SourceID
                    ((PCHANNEL_VCCB)pVc)->Channel, // DestID
                    RcvInfo.p1394Data,
                    RcvInfo.DataLength );
            }
            else
            {
                PNOTIFICATION_INFO pNotificationInfo = (PNOTIFICATION_INFO)pIndicatedStruct;
                ULONG NodeNumber =  ((PASYNC_PACKET)pNotificationInfo->RequestPacket)->AP_Source_ID.NA_Node_Number;
                
                    NIC1394_LOG_PKT(
                    pVc->Hdr.pAF->pAdapter,
                    NIC1394_LOGFLAGS_RECV_FIFO  ,
                    NodeNumber , // SourceID
                    pAdapter->BCRData.LocalNodeNumber,
                    RcvInfo.p1394Data,
                    RcvInfo.DataLength );


            }
        }

#endif
        //
        // Sanity check 
        //
        
        if (RcvInfo.fFragmented == FALSE)
        {
            //
            // Pack the mdl into an ndispacket and indicate it to Ndis.
            // SHOULD BE NDIS_BUFFERS
            //

            
            ulValidDataLength = RcvInfo.DataLength;

        
            pStartValidData  = (PVOID)RcvInfo.pEncapHeader;

            {
                
                PNDIS1394_UNFRAGMENTED_HEADER pEncapHeader = (PNDIS1394_UNFRAGMENTED_HEADER)RcvInfo.pEncapHeader;
                
                if (0x777 == SWAPBYTES_USHORT(pEncapHeader->u1.EtherType))
                {
                   TRACE (TL_N, TM_Recv, ("Received Bridge STA Packet %p\n", pEncapHeader));
                }
            }
    
            NdisStatus = nicGetNdisBuffer ( ulValidDataLength,
                                            pStartValidData,
                                            &pHeadNdisBuffer);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                pHeadNdisBuffer = NULL;
                break;
            }

            nicIncRecvBuffer(pVc->Hdr.VcType == NIC1394_RecvFIFO);

            pIndicatedChain = RcvInfo.NdisPktContext.pCommon;


            fPacketCompleted = TRUE;



        }
        else  // Recv Data is fragemented
        {
            PREMOTE_NODE    pRemoteNode= NULL;
            USHORT          SourceNodeAddress = 0xff;

            //
            // First extract all the useful information from the indicated structure, rem node, dgl, first frag, etc
            //
            nicInitRecvDataFragmented (pMdl, RecvOp, pIndicatedStruct, &RcvInfo);

            
            RcvInfo.pRemoteNode = nicGetRemoteNodeFromTable (RcvInfo.SourceID,pAdapter);


            TRACE( TL_T, TM_Recv, ( "     pRemoteNode %x", RcvInfo.pRemoteNode) );
            //
            // If there is no remote node present , break out
            //

            if (RcvInfo.pRemoteNode == NULL)
            {
                NdisStatus = NDIS_STATUS_FAILURE;

                nicRecvNoRemoteNode (pAdapter);
                BREAK (TM_Recv, (" Rx - Did not find a remote Node for reassembly" ) );
            }

            //
            // Try and use the indicated data to reassemble 
            //
            NdisStatus = nicDoReassembly (&RcvInfo, &pReassembly, &fPacketCompleted  );

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                TRACE (TL_N, TM_Recv, ("Generic  RX - Reassembly Failed") );
                break;
            }
            
            ASSERT (pReassembly != NULL);
            
            if (fPacketCompleted  == TRUE && 
              REASSEMBLY_ACTIVE (pReassembly))
            {
                
                TRACE( TL_V, TM_Recv, ( " pReassembly->ReassemblyComplete %x ", pReassembly->fReassemblyComplete )  );

                pHeadNdisBuffer = pReassembly->pHeadNdisBuffer;

                pIndicatedChain = pReassembly->Head.pCommon;

                nicReassemblyCompleted(pAdapter);

            }
            else
            {
                //
                // Do not call the return packet as reassembly is in progress. Dereference the ref made 
                // when the reaassembly was found in nicFindReassembly...
                //
                ASSERT (pHeadNdisBuffer == NULL);

                NdisStatus = NDIS_STATUS_SUCCESS;

            }

            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

                
            //
            // Dereference the ref that was made nicFindReassembly. After this only one thread
            // should have the reassembly struct. And there should be one ref on it.
            //
            nicDereferenceReassembly (pReassembly, "nicIsochRxCallback Reassembly Incomplete");


        }  // Completed the ifFragmented code


        if (RcvInfo.pRemoteNode != NULL)
        {
            //
            // Deref the ref made earlier in the if fragmented code path within this function
            //
            nicDereferenceRemoteNode(RcvInfo.pRemoteNode , "nicCommonRxCallback - nicGetRemoteNodeFromTable");
            RcvInfo.pRemoteNode = NULL;
        }

        
        if (fPacketCompleted  == FALSE)
        {
            //
            // If  the  packet is not completely reassembled, then there is no 
            // more work to be done
            //
            pReassembly = NULL;

            NdisStatus  = NDIS_STATUS_SUCCESS;
            break;
        }

        if (pReassembly)
        {
            ASSERT (pReassembly->Ref == 1);
        }
        

        
        //
        // Now we package the data into an NdisPacket
        //

        nicAllocatePacket (&NdisStatus,
                        &pMyPacket,
                        RcvInfo.pPacketPool);


        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            pMyPacket = NULL;
            ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);
            break;
        }

        
        //
        // Set the NdisBuffer as Head and Tail of the Packet
        //
        NdisChainBufferAtFront (pMyPacket, pHeadNdisBuffer);


        NdisQueryPacket( pMyPacket,
                       NULL,
                       NULL,
                       NULL,
                       &PacketLength);

        TRACE( TL_V, TM_Recv, ( "Packet %x Length %x", pMyPacket, PacketLength )  ); 

    
        NDIS_SET_PACKET_STATUS (pMyPacket, NDIS_STATUS_SUCCESS);

        // Insert the node address if we are in bridge mode
        //
        if (ADAPTER_TEST_FLAG(pAdapter,fADAPTER_BridgeMode)== TRUE)
        {
            nicInsertNodeAddressAtHead (pMyPacket, &RcvInfo);
        }
        //
        // Set up the context in the ndis packet . Contains the Vc, and 
        // the Buffer registered with the bus driver
        //

        pPktContext = (PPKT_CONTEXT)&pMyPacket->MiniportReserved;   
        pPktContext->Receive.pVc = pVc;
        pPktContext->Receive.IndicatedStruct.pCommon = pIndicatedChain ;

        
        //
        // Its time to indicate the packet to NDIS
        //

        IndicatedStatus = NDIS_GET_PACKET_STATUS(pMyPacket);

        nicIndicateNdisPacketToNdis (pMyPacket,
                                     pVc,
                                     pVc->Hdr.pAF->pAdapter);
                                     
        //
        // Dereference the reassembly here . so that pReassembly is valid and it will catch all 
        // failures prior this 
        //

        if (pReassembly != NULL)
        {
            //
            // This should free the reassembly
            //
            nicFreeReassemblyStructure (pReassembly);
            pReassembly = NULL;
        }
        
    } while (FALSE);

    ASSERT (IndicatedStatus != NDIS_STATUS_RESOURCES);

    if (IndicatedStatus == NDIS_STATUS_RESOURCES)
    {
#if QUEUED_PACKETS
        //
        // Do nothing the queue will complete the packet
        //
#else

        //
        // The packet was completed with  a status of resources.
        // It is gauranteed to be valid and we need to call the 
        // return packet handler
        //
        nicInternalReturnPacket (pVc, pMyPacket);
#endif          

    }
    //
    // Failure code path
    //
    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        //
        // if there was a valid reassembly structure and the failure occured after that
        // then we need to abort the reaasembly
        //
        if (pMyPacket)
        {
            
            nicFreePacket (pMyPacket, RcvInfo.pPacketPool);
        }

        //
        // There could still be NdisBuffers that are allocated.
        //
        if (pReassembly != NULL)
        {
            nicDereferenceReassembly (pReassembly, "Indication failure");
            nicAbortReassembly(pReassembly);

        }
        else
        {
            //
            // We need to return this descriptor or fifo back to the bus driver
            //
            
            if (pVc->Hdr.VcType == NIC1394_SendRecvChannel || 
              pVc->Hdr.VcType == NIC1394_RecvChannel )
            {
                nicReturnDescriptorChain ((PISOCH_DESCRIPTOR)pIndicatedStruct,
                                      (PCHANNEL_VCCB) pVc);
            }
            else
            {
                ASSERT (pVc->Hdr.VcType == NIC1394_RecvFIFO);
                ASSERT (((PNOTIFICATION_INFO)pIndicatedStruct)->Fifo != NULL);
                
                nicReturnFifoChain ( ((PNOTIFICATION_INFO)pIndicatedStruct)->Fifo, 
                                   (PRECVFIFO_VCCB) pVc);

            }

            if (pHeadNdisBuffer != NULL)
            {   
                nicReturnNdisBufferChain(pHeadNdisBuffer, pVc);
            }

        }

    }

    
    TRACE( TL_T, TM_Recv, ( "<==nicReceiveCommonCallback  " )  ); 

}






VOID 
nicChannelReturnPacket (
    IN PVCCB pVc,
    IN PNDIS_PACKET pMyPacket
    )

    // Function Description:
    //  Return Packets Handler -
    //   For FIFO's will reinsert the buffer (MDL) into  the Fifo SList
    //   Check for the VC Active  and then return it ot the SList . Free it otherwise
    //
    // Arguments
    //  RecvFIFOVc - Vc of the packet
    //  pPacket = Packet in question
    //
    // Return Value:
    //
    //
    //
    
{
    PCHANNEL_VCCB       pChannelVc = (PCHANNEL_VCCB)pVc;
    PNDIS_BUFFER        pMyNdisBuffer;
    PPKT_CONTEXT        pPktContext  = (PPKT_CONTEXT)&pMyPacket->MiniportReserved; 
    PISOCH_DESCRIPTOR   pIsochDescriptor = NULL;
    
    
    TRACE( TL_T, TM_Recv, ( "==>nicChannelReturnPacket  pVc %x, pPacket %x", 
                             pChannelVc, pMyPacket) );

    ASSERT (pMyPacket != NULL);                          

    NdisUnchainBufferAtFront (pMyPacket,
                              &pMyNdisBuffer);
 
    while (pMyNdisBuffer != NULL)
    {

        NdisFreeBuffer(pMyNdisBuffer);
        nicDecChannelRecvBuffer();
        
        pMyNdisBuffer = NULL;
        
        NdisUnchainBufferAtFront (pMyPacket,
                                 &pMyNdisBuffer);
    
    } 


    //
    // Return the Descriptors to the bus driver
    //
    
    pIsochDescriptor = pPktContext->IsochListen.pIsochDescriptor;
                    

    //
    // temporary sanity check asserts
    //
    ASSERT (pIsochDescriptor != NULL);


    nicReturnDescriptorChain (pIsochDescriptor, pChannelVc);

    //
    // Free The packet 
    //
    nicFreePacket(pMyPacket, &pChannelVc->PacketPool);
    //
    // Update Count
    //
    //NdisInterlockedDecrement (&pChannelVc->OutstandingPackets ) ;

    

    TRACE( TL_T, TM_Recv, ( "<==nicChannelReturnPacket  "  ) );

}



VOID
nicReturnDescriptorChain ( 
    IN PISOCH_DESCRIPTOR pIsochDescriptor,
    IN PCHANNEL_VCCB pChannelVc
    )
{
    //
    // Walk the list of isoch descriptors and mark them as returned
    //

    PISOCH_DESCRIPTOR pCurr = NULL;
    PVOID       pNext = NULL;
    PMDL        pMdl = NULL;
    PVOID       pVa = NULL;
    ULONG       Len = 0;

    TRACE( TL_T, TM_Recv, ( "==> nicReturnDescriptorChain pIsochDescriptor %x",pIsochDescriptor  ) );
    
    pCurr = pIsochDescriptor ;
    


    while (pCurr != NULL)
    {   
        //ASSERT (pChannelVc == (PCHANNEL_VCCB)GET_CHANNELVC_FROM_DESCRIPTOR(pCurr));

        if (pNext != NULL)
        {
            pCurr = CONTAINING_RECORD (pNext, 
                                       ISOCH_DESCRIPTOR,
                                       DeviceReserved[IsochNext] );

            
        }
        
        pNext = (PVOID)NEXT_ISOCH_DESCRIPTOR(pCurr);

        TRACE (TL_V, TM_Recv ,(" Isoch Descriptors Curr %x, next %x" , pCurr, pNext) );
        
        CLEAR_DESCRIPTOR_OF_NDIS_TAG(pCurr);

        CLEAR_DESCRIPTOR_NEXT(pCurr);

        //
        // Zero out the data that is being returned to the bus driver
        //
#if 0       
        pMdl = pCurr->Mdl;
        pVa = NIC_GET_SYSTEM_ADDRESS_FOR_MDL (pMdl);

        if (pVa != NULL)
        {
            Len = NIC_GET_BYTE_COUNT_FOR_MDL(pMdl); 
            NdisZeroMemory(pVa, Len);

        }
#endif      
        pCurr = pNext;

        //
        // Update the count, The close call will wait for this count to go to zero
        //

        NdisInterlockedDecrement (&pChannelVc->NumIndicatedIsochDesc);

        //
        // Clear the Variables
        //
        pMdl = NULL;
        pVa = NULL;
        Len = 0;


    }

    TRACE( TL_T, TM_Recv, ( "<== nicReturnDescriptorChain  pIsochDescriptor %x",pIsochDescriptor  ) );


}










VOID
nicRecvNoRemoteNode(
    PADAPTERCB pAdapter
    )

    

/*++

Routine Description:

 Queues a work item to go and update the node addresses of all the remote node

Arguments:


Return Value:


--*/

{
    NDIS_STATUS NdisStatus  = NDIS_STATUS_FAILURE;
    
    TRACE( TL_T, TM_Send, ( "==>nicRecvNoRemoteNode ") );

    ASSERT (pAdapter != NULL);
    
    do
    {
        PNDIS_WORK_ITEM pUpdateTableWorkItem  = NULL;
        BOOLEAN fWorkItemAlreadyLaunched  = FALSE;

        //
        // We need to update the generation count
        //
        pUpdateTableWorkItem   = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM); 

        if (pUpdateTableWorkItem   == NULL)
        {
            TRACE( TL_A, TM_Cm, ( "Local Alloc failed for WorkItem - GetGeneration FAILED" ) );

            break;
        }

        
        
        ADAPTER_ACQUIRE_LOCK (pAdapter);
        
        if (ADAPTER_TEST_FLAGS (pAdapter, fADAPTER_UpdateNodeTable))
        {
            fWorkItemAlreadyLaunched = TRUE;
        }
        else
        {
            ADAPTER_SET_FLAG (pAdapter, fADAPTER_UpdateNodeTable);
            //
            // Ref the adapter. Deref in workitem
            //
            nicReferenceAdapter (pAdapter, "nicRecvNoRemoteNode" );
            fWorkItemAlreadyLaunched = FALSE;

        }
        
        ADAPTER_RELEASE_LOCK (pAdapter);

        if (fWorkItemAlreadyLaunched == TRUE)
        {
            FREE_NONPAGED(pUpdateTableWorkItem);
            break;
        }


        //
        // Set the Workitem
        //

        NdisInitializeWorkItem ( pUpdateTableWorkItem, 
                              (NDIS_PROC)nicUpdateNodeTable,
                              (PVOID)pAdapter );
                              
        NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

        NdisScheduleWorkItem (pUpdateTableWorkItem);

        
        NdisStatus = NDIS_STATUS_SUCCESS;

    } while (FALSE);




    TRACE( TL_T, TM_Send, ( "<==nicRecvNoRemoteNode %x", NdisStatus) );



}




VOID
nicUpdateNodeTable(
    NDIS_WORK_ITEM* pUpdateTable,
    IN PVOID Context 
    )

/*++

Routine Description:
 
    This is called when the reassembly cannot find 
    a remote node for reassembly

    For simplicity's sake, we go through all 63 entries

    We find a remote node, get its address. now the address' entry
    in the Node Table may already have another node there, so we take that 
    node out put the new remote Node in that location.  Then we go
    and update the node address of that remote node

    This is the WorkItem version of nicUpdateRemoteNodeTable

Arguments:
   pAdapter Local host

Return Value:


--*/
{

    ULONG               i = 0;
    ULONG               NumNodes = 0;
    PREMOTE_NODE        pRemoteNode = NULL;
    NODE_ADDRESS        NodeAddress ;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_SUCCESS;
    PADAPTERCB          pAdapter = (PADAPTERCB)Context;

    NdisZeroMemory (&NodeAddress, sizeof(NODE_ADDRESS));

    do
    {
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // Get a remote node
        //
        pRemoteNode = NULL;
        
        while (i<MAX_NUMBER_NODES)
        {
            pRemoteNode = pAdapter->NodeTable.RemoteNode[i];
            
            if (pRemoteNode != NULL)
            {
                break;
            }
            
            i++;
        }

        if (pRemoteNode != NULL)
        {
            nicReferenceRemoteNode (pRemoteNode, "nicVerifyRemoteNodeAddress ");
        }           

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        //  break out if we are the end of the loop
        //

        if  (i>=MAX_NUMBER_NODES)
        {
            ASSERT (pRemoteNode == NULL)
            break;
        }
        
        if (pRemoteNode == NULL)
        {
            break;
        }

        i++;

    
        //
        // Now update the table. The new location of the Node in the
        // NodeTable may already have a Node, so we we will need to
        // update that remote node's address as well
        // 
        do
        {
            PREMOTE_NODE pRemNodeOld = NULL;


            nicGet1394AddressOfRemoteNode (pRemoteNode,
                                           &NodeAddress,
                                           0);
                                           

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                //
                // Just use the old node address, if it fails
                //
                NodeAddress  = pRemoteNode->RemoteAddress;
            }

            
            ADAPTER_ACQUIRE_LOCK (pAdapter);

            //
            // Extract the occupant of the location
            //
            pRemNodeOld = pAdapter->NodeTable.RemoteNode[NodeAddress.NA_Node_Number];

            //
            // Update RemoteNode Address
            //
        
            pRemoteNode->RemoteAddress = NodeAddress  ;
    
            if (pRemNodeOld == pRemoteNode)
            {
                //
                //  The remote nodes are the same, so we do not
                //  care about the old remote node
                //
                pRemNodeOld = NULL;
            }

            //
            // Only Reference And Update the Old remoteNode'address
            // if it is not our current remote node
            //

            if ( pRemNodeOld != NULL )
            {
                //
                // This location is already occupied. 
                // Take it out, reference it and update its address
                //
                nicReferenceRemoteNode (pRemNodeOld, "nicVerifyRemoteNode");
                
                
            }


            //
            //  Update the Master Node Table
            //
            pAdapter->NodeTable.RemoteNode[NodeAddress.NA_Node_Number] = pRemoteNode;

            //
            // This either derefs' the remote node or pRemNodeOld from a previous interation
            //
            nicDereferenceRemoteNode (pRemoteNode, "nicVerifyRemoteNode" );

            //
            // Update pRemoteNode so that it loops again 
            // and we can update the node addres of this pRemNodeOld
            //  else it will be null and we exit this loop
            // 
            pRemoteNode = pRemNodeOld;
            
            ADAPTER_RELEASE_LOCK (pAdapter);


        } while (pRemoteNode != NULL);

    //
    // If we have not gone through all the nodes . 
    //  get the next remote node
    // 

    }while (i<MAX_NUMBER_NODES);
    

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    ADAPTER_CLEAR_FLAG (pAdapter, fADAPTER_UpdateNodeTable);

    ADAPTER_RELEASE_LOCK (pAdapter);

        
        
    FREE_NONPAGED (pUpdateTable);
    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);

    nicDereferenceAdapter(pAdapter, "nicRecvNoRemoteNode Derefed in  nicUpdateNodeTable" );
    
}


VOID
nicInsertNodeAddressAtHead (
    IN PNDIS_PACKET pPacket, 
    IN PNIC_RECV_DATA_INFO pRcvInfo
    )
/*++

Routine Description:
    Adds the Node Address to the first 16 bits in the packet. 
    It fails quietly if it is not able to do so

Arguments:
    pPacket  pPacket in Question
    pRcvInfo -> With the correct Gasp Header
Return Value:


--*/
{
    PNDIS1394_UNFRAGMENTED_HEADER pHeader = NULL;

    TRACE( TL_T, TM_Recv, ( "nicInsertNodeAddressAtHead , pPacket %x pRecvInfo %x",pPacket, pRcvInfo  ) );

    do
    {
        pHeader = nicNdisBufferVirtualAddress (pPacket->Private.Head);

        if (pHeader == NULL)
        {
            break;
        }

        //
        // Assert for now. Will not work if there are 1394 bridges with bus number = 0;
        //

        ASSERT (pRcvInfo->SourceID < 64);
        pHeader->u1.SourceAddress= (UCHAR)(pRcvInfo->SourceID); 

        pHeader->u1.fHeaderHasSourceAddress = TRUE;
        
    } while (FALSE);

    TRACE( TL_T, TM_Recv, ( "nicInsertNodeAddressAtHead , pHeader %x =  *pHeader %x", pHeader, pHeader->HeaderUlong  ) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\cm.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// cm.c
//
// IEEE1394 mini-port/call-manager driver
//
// Call Manager routines
//
// 06/20/1999 ADube Created - Declarations for call-manager routines 
//



// Debug counts of client oddities that should not be happening.
//
extern ULONG g_ulUnexpectedInCallCompletes;
extern ULONG g_ulCallsNotClosable;

//#define MaxNumSlistEntry 0x100
#define MAX_NUM_ISOCH_DESCRIPTOR 0x20
#define MAX_CHANNEL_BUFFER_SIZE 0x300
#define MAX_CHANNEL_BYTES_PER_FRAME 0x280



//-----------------------------------------------------------------------------
//          L O C A L   T Y P E S    F O R     cm.c
//-----------------------------------------------------------------------------

typedef enum _VC_SEND_RECEIVE
{
    TransmitVc = 0,
    ReceiveVc,
    TransmitAndReceiveVc,
    InvalidType
    

} VC_SEND_RECEIVE  ;



//-----------------------------------------------------------------------------
//          N D I S     C A L L - M A N A G E R     H A N D L E R S 
//-----------------------------------------------------------------------------


NDIS_STATUS
NicCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext
    );

NDIS_STATUS
NicCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext
    );


NDIS_STATUS
NicCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext
    );

NDIS_STATUS
NicCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext
    );


NDIS_STATUS
NicCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext
    );



NDIS_STATUS
NicCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size
    );


NDIS_STATUS
NicCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

NDIS_STATUS
NicCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST NdisRequest
    );

NDIS_STATUS
nicRegisterSapHandler(
    IN  NDIS_HANDLE             CallMgrAfContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    );

NDIS_STATUS
nicDeregisterSapHandler(
    IN  NDIS_HANDLE             CallMgrSapContext
    );

NDIS_STATUS
nicCmAddPartyHandler(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle,
    OUT PNDIS_HANDLE            CallMgrPartyContext
    );
    
NDIS_STATUS
nicCmDropPartyHandler(
    IN  NDIS_HANDLE             CallMgrPartyContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    );


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------





VOID
InterceptMakeCallParameters(
    PCO_MEDIA_PARAMETERS pMediaParams,
    PNIC1394_MEDIA_PARAMETERS pN1394Params
    );

NDIS_STATUS
nicAllocateAddressRangeOnActiveRemoteNodes (
    IN PADAPTERCB pAdapter
    );

VOID
nicCallSetupComplete(
    IN VCCB* pVc
    );

VOID
nicChannelCallFreeResources ( 
    IN PCHANNEL_VCCB            pChannelVc,
    IN PADAPTERCB               pAdapter,
    IN HANDLE                   hResource,
    IN ULONG                    NumDescriptors,
    IN PISOCH_DESCRIPTOR        pIsochDesciptor,
    IN BOOLEAN                  fChannelAllocated,
    IN ULONG                    Channel,
    IN PNIC_PACKET_POOL         pPool
    );


VOID
nicChannelCallCleanDataStructure ( 
    IN PCHANNEL_VCCB            pChannelVc,
    IN HANDLE                   hResource,
    IN ULONG                    NumDescriptors,
    IN PISOCH_DESCRIPTOR        pIsochDesciptor,
    IN BOOLEAN                  fChannelAllocated,
    IN ULONG                    Channel,
    IN NDIS_HANDLE              hPacketPoolHandle,
    OUT PULONG                  pNumRefsDecremented 
    );

NDIS_STATUS
nicAllocateChannelResourcesAndListen (
    IN PADAPTERCB pAdapter,
    IN PCHANNEL_VCCB pChannelVc
    );

NDIS_STATUS
nicCmGenericMakeCallInit (
    IN PVCCB pVc
    );

VOID
nicCmGenrericMakeCallFailure (
    IN PVCCB pVc
    );

VOID
nicCmCloseCallComplete(
    NDIS_WORK_ITEM* pCloseCallCompleteWorkItem,     
    IN PVOID Context 
    );


NDIS_STATUS
nicCmCloseCallEthernet (
    IN PVCCB pVc
    );
    
NDIS_STATUS
nicCmCloseCallMultiChannel (
    IN PVCCB pVc
    );

NDIS_STATUS
nicCmCloseCallRecvFIFO (
    IN PVCCB pVc
    );


NDIS_STATUS
nicCmCloseCallSendFIFO (
    IN PVCCB pVc
    );
    

NDIS_STATUS
nicCmCloseCallSendRecvChannel (
    IN PVCCB pVc 
    );

NDIS_STATUS
nicCmCloseCallSendChannel(
    IN PVCCB pVc 
    );

VOID
nicCmMakeCallComplete (
    NDIS_WORK_ITEM* pMakeCallCompleteWorkItem,
    IN PVOID Context
    );

VOID
nicCmMakeCallCompleteFailureCleanUp(
    IN OUT PVCCB pVc 
    );

NDIS_STATUS
nicCmMakeCallInitRecvChannelVc(
    IN OUT PVCCB pVc 
    );

    
NDIS_STATUS
nicCmMakeCallInitSendChannelVc(
    IN OUT PVCCB pVc 
    );

    
NDIS_STATUS
nicCmMakeCallInitSendRecvChannelVc(
    IN OUT PVCCB pVc 
    );


NDIS_STATUS
nicCmMakeCallInitEthernet(
    IN PVCCB pVc
    );

NDIS_STATUS
nicCmMakeCallSendChannel (
    IN PVCCB pVc
    );

NDIS_STATUS
nicCmMakeCallMultiChannel (
    IN PVCCB pVc
    );


NDIS_STATUS
nicAllocateRequestedChannelMakeCallComplete (
    IN PADAPTERCB pAdapter,
    IN PCHANNEL_VCCB pChannelVc,
    IN OUT PULONG pChannel
    );


NDIS_STATUS
nicCmMakeCallInitRecvFIFOVc(
    IN OUT PVCCB pVc
    );


NDIS_STATUS
nicCmMakeCallInitSendFIFOVc(
    IN OUT PVCCB pVc
    );

VOID
nicDereferenceAF(
    IN AFCB* pAF
    );

ULONG
nicGetMaxPayLoadForSpeed(
    IN ULONG Speed,
    IN ULONG mtu
    );
    

VOID
nicInactiveCallCleanUp(
    IN VCCB* pVc
    );


NDIS_STATUS
nicInitRecvFifoDataStructures (
    IN PRECVFIFO_VCCB pRecvFIFOVc
    );

VOID
nicUnInitRecvFifoDataStructures (
    IN PRECVFIFO_VCCB pRecvFIFOVc
    );

VOID
nicFreeAF(
    IN AFCB* pAF
    );


VOID
nicReferenceAF(
    IN AFCB* pAF
    );


#if TODO
VOID
nicTimerQTerminateComplete(
    IN TIMERQ* pTimerQ,
    IN VOID* pContext );
#endif // TODO


NDIS_STATUS
nicCmQueryInformation(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    );


NDIS_STATUS
nicCmSetInformation(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    );


NDIS_STATUS
nicGetActiveRemoteNode (
    PADAPTERCB pAdpater,
    PREMOTE_NODE*      ppRemoteNodePdoCb
    );


NDIS_STATUS
nicChangeChannelChar (
    PVCCB pVc, 
    PNIC1394_CHANNEL_CHARACTERISTICS pMcChar
    );



NDIS_STATUS
nicCmGenericMakeCallInitChannels (
    IN PCHANNEL_VCCB pChannelVc,
    VC_SEND_RECEIVE  VcType 
    );


NDIS_STATUS
nicCmGenericMakeCallInitFifo (
    IN PVCCB pVc,
    VC_SEND_RECEIVE  VcType 
    );



NDIS_STATUS
nicCmGenericMakeCallMutilChannel (
    IN PVCCB pVc,
    VC_SEND_RECEIVE  VcType 
    );
    


NDIS_STATUS
nicCmGenericMakeCallEthernet(
    IN PVCCB pVc,
    IN VC_SEND_RECEIVE VcType
    );

VOID 
nicInterceptMakeCallParameters (
    PCO_MEDIA_PARAMETERS pMedia     
    );

NDIS_STATUS
nicQueryRemoteNodeCaps (
    IN PADAPTERCB pAdapter,
    IN PREMOTE_NODE pRemoteNode,
    OUT PULONG pSpeed,
    OUT PULONG pMaxBufferSize,
    OUT PULONG pMaxRec
    );

UINT
nicSpeedFlagsToSCode(
    IN UINT SpeedFlags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\debug.c ===
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// debug.c
// IEEE1394 mini-port/call-manager driver
// Debug utilities and globals
//
// 12/28/1998 JosephJ Adapted from the l2tp project.


#include "precomp.h"


//-----------------------------------------------------------------------------
// Global data definitions
//-----------------------------------------------------------------------------

//
// Temporary definition for testing purposes
//


#if TESTMODE
#define DEFAULTTRACELEVEL TL_V  
#define DEFAULTTRACEMASK TM_RemRef
#else
#define DEFAULTTRACELEVEL TL_None
#define DEFAULTTRACEMASK TM_Base
#endif

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' are
// displayed.  All messages from any (TM_*) set(s) present in 'g_ulTraceMask'
// are displayed.
//
ULONG g_ulTraceLevel = DEFAULTTRACELEVEL;
ULONG g_ulTraceMask = DEFAULTTRACEMASK;


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------


#if DBG
VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks )

    // Tries to detect corruption in list 'pList', printing verbose linkage
    // output if 'fShowLinks' is set.
    //
{
    LIST_ENTRY* pLink;
    ULONG ul;

    ul = 0;
    for (pLink = pList->Flink;
         pLink != pList;
         pLink = pLink->Flink)
    {
        if (fShowLinks)
        {
            DbgPrint( "N13: CheckList($%p) Flink(%d)=$%p\n",
                pList, ul, pLink );
        }
        ++ul;
    }

    for (pLink = pList->Blink;
         pLink != pList;
         pLink = pLink->Blink)
    {
        if (fShowLinks)
        {
            DbgPrint( "N13: CheckList($%p) Blink(%d)=$%p\n",
                pList, ul, pLink );
        }
        --ul;
    }

    if (ul)
    {
        DbgBreakPoint();
    }
}
#endif


#if DBG
VOID
Dump(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )

    // Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
    // For example, with 'ulGroup' of 1, 2, and 4:
    //
    // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    // 0000 0000 0000 0000 0000 0000 0000 0000 |................|
    // 00000000 00000000 00000000 00000000 |................|
    //
    // If 'fAddress' is true, the memory address dumped is prepended to each
    // line.
    //
{
    while (cb)
    {
        INT cbLine;

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
    }
}
#endif


#if DBG
VOID
DumpLine(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress)
        DbgPrint( "N13: %p: ", p );
    else
        DbgPrint( "N13: " );

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\irp.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// irp.c
//
// IEEE1394 mini-port/call-manager driver
//
// Routines that issue the numerous Irbs to the 1394 Bus driver 
//
// 04/01/1999 ADube Created, adapted from the l2tp sources.
//

#include "precomp.h"



//
// This file will contain all the functions that issue Irps with the various Irbs to the 
// 1394 bus. All Irbs except the actual send/recv irbs will be implemented here
//

//
// The functions will follow this general algorithm
// nicGetIrb
// nicInitialize....Irb
// nicPrintDebugSpew
// nicGetIrp
// nicSubmit_Irp_Synch
// return Status
//

//-----------------------------------------------------------------------------
// A Simple template that can be used to send Irps syncronously
//-----------------------------------------------------------------------------



/*
Comments Template

/*++

Routine Description:


Arguments:


Return Value:


--*/

/*

    // Function Description:
    //
    //
    //
    //
    //
    // Arguments
    //
    //
    //
    // Return Value:
    //
    //
    //
    //




Function template

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    

    TRACE( TL_T, TM_Irp, ( "==>nicGe....ect, pAdapter %x", pAdapter ) );


    ASSERT (pNodeAddress != NULL);
    do
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressFromDeviceObject, nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        nicInit....Irb (..)
        
        
        NdisStatus = nicGetIrp ( pRemoteNodePdoCb, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressFromDeviceObject, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_Synch ( pAdapter->pLocalHostPdoCb,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressFromDeviceObject, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;


        }
    
        Copy returned data to nic1394's data structures

    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    TRACE( TL_T, TM_Irp, ( "<==nicGet139...,  pAdapter %x", pAdapter ) );


    return NdisStatus;







*/

//-----------------------------------------------------------------------------
// Routines begin here
//-----------------------------------------------------------------------------

NDIS_STATUS
nicAllocateAddressRange_Synch (
    IN PADAPTERCB pAdapter,
    IN PMDL pMdl,
    IN ULONG fulFlags,
    IN ULONG nLength,
    IN ULONG MaxSegmentSize,
    IN ULONG fulAccessType,
    IN ULONG fulNotificationOptions,
    IN PVOID Callback,
    IN PVOID Context,
    IN ADDRESS_OFFSET  Required1394Offset,
    IN PSLIST_HEADER   FifoSListHead,
    IN PKSPIN_LOCK     FifoSpinLock,
    OUT PULONG pAddressesReturned,  
    IN OUT PADDRESS_RANGE  p1394AddressRange,
    OUT PHANDLE phAddressRange
    )
    // Function Description:
    //   Takes the parameter and just passes it down to the bus driver
    // Arguments
    //
    // Return Value:
    //

{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    

    TRACE( TL_T, TM_Irp, ( "==>nicAllocateAddressRange_Synch, pAdapter %x, Offset %x", pAdapter, Required1394Offset ) );

    TRACE (TL_V, TM_Irp, ("    pMdl %x, fulFlags %x, nLength %x, MaxSegmentSize %x, fulAcessType %x", 
                              pMdl, fulFlags, nLength, MaxSegmentSize, fulAccessType ) );

    TRACE (TL_V, TM_Irp, ("    fulNotification %x, Callback %x, Context %x, ReqOffset.High %x, ReqOffset.Low %x" ,
                               fulNotificationOptions, Callback, Context, Required1394Offset.Off_High, Required1394Offset.Off_Low ) );

    TRACE (TL_V, TM_Irp, ("    FifoSListHead %x, FifoSpinLock %x, p1394AddressRange %x" ,FifoSListHead, FifoSpinLock, p1394AddressRange ) )
    do
    {
        
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicAllocateAddressRange_Synch , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

            
        NdisStatus = nicGetIrp (pAdapter->pNdisDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicAllocateAddressRange_Synch , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);

        pIrb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;      
        pIrb->Flags = 0;
        pIrb->u.AllocateAddressRange.Mdl = pMdl;                    // Address to map to 1394 space
        pIrb->u.AllocateAddressRange.fulFlags = fulFlags;               // Flags for this operation
        pIrb->u.AllocateAddressRange.nLength = nLength;                // Length of 1394 space desired
        pIrb->u.AllocateAddressRange.MaxSegmentSize = MaxSegmentSize;         // Maximum segment size for a single address element
        pIrb->u.AllocateAddressRange.fulAccessType = fulAccessType;          // Desired access: R, W, L
        pIrb->u.AllocateAddressRange.fulNotificationOptions = fulNotificationOptions; // Notify options on Async access
        pIrb->u.AllocateAddressRange.Callback = Callback;               // Pointer to callback routine
        pIrb->u.AllocateAddressRange.Context = Context;                // Pointer to driver supplied data
        pIrb->u.AllocateAddressRange.Required1394Offset = Required1394Offset;     // Offset that must be returned
        pIrb->u.AllocateAddressRange.FifoSListHead = FifoSListHead;          // Pointer to SList FIFO head
        pIrb->u.AllocateAddressRange.FifoSpinLock = FifoSpinLock;           // Pointer to SList Spin Lock
        pIrb->u.AllocateAddressRange.p1394AddressRange = p1394AddressRange; // Address Range Returned

        ASSERT ( pIrb->u.AllocateAddressRange.p1394AddressRange != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                               pIrp,
                                               pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicAllocateAddressRange_Synch , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;


        }

        //
        // Update the output values
        //
        
        *pAddressesReturned = pIrb->u.AllocateAddressRange.AddressesReturned;      // Number of addresses returned
        p1394AddressRange = pIrb->u.AllocateAddressRange.p1394AddressRange;      // Pointer to returned 1394 Address Ranges
        *phAddressRange = pIrb->u.AllocateAddressRange.hAddressRange;          // Handle to address range
        
        TRACE (TL_V, TM_Irp, ("    *pAddressesReturned  %x, p1394AddressRange %x, phAddressRange %x," ,
                                   *pAddressesReturned, p1394AddressRange, *phAddressRange ) );
    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    TRACE( TL_T, TM_Irp, ( "<==nicAllocateAddressRange_Synch, Status %x", NdisStatus) );

    return NdisStatus;


}








NDIS_STATUS
nicGet1394AddressOfRemoteNode( 
    IN PREMOTE_NODE pRemoteNode,
    IN OUT NODE_ADDRESS *pNodeAddress,
    IN ULONG fulFlags
    )
    // Function Description:
    // This function will get the 1394 Address from the device object. 
    //
    // Arguments
    // PdoCb * Local Host's Pdo Control Block
    // NodeAddress * Node Address structre wher the address will be returned in 
    // fulFlags - Could specify USE_LOCAL_HOST
    //
    // Return Value:
    // Success if the irp succeeeded
    // Failure: if the pdo is not active or the irp failed
    //
    
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    
    TRACE( TL_T, TM_Irp, ( "==>nicGet1394AddressOfRemoteNode, pRemoteNode %x, pNodeAdddress ", pRemoteNode, pNodeAddress) );


    ASSERT (pNodeAddress != NULL);
    do
    {
    
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressOfRemoteNode, nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);
        
        pIrb->FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;     
        pIrb->u.Get1394AddressFromDeviceObject.fulFlags = fulFlags;

        NdisStatus = nicGetIrp (pRemoteNode->pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressOfRemoteNode, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);

        
        NdisStatus = nicSubmitIrp_Synch (pRemoteNode,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressOfRemoteNode, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;


        }
    
        (*pNodeAddress) = pIrb->u.Get1394AddressFromDeviceObject.NodeAddress;

    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //

    if (pIrb != NULL)
    {
        nicFreeIrb (pIrb);
    }

    if (pIrp != NULL)
    {
        nicFreeIrp (pIrp);
    }

    TRACE( TL_T, TM_Irp, ( "<==nicGet1394AddressOfRemoteNode, Status %x, Address %x", NdisStatus, *pNodeAddress ) );

    return NdisStatus;
}








NDIS_STATUS
nicGet1394AddressFromDeviceObject( 
    IN PDEVICE_OBJECT pPdo,
    IN OUT NODE_ADDRESS *pNodeAddress,
    IN ULONG fulFlags
    )
    // Function Description:
    // This function will get the 1394 Address from the device object. 
    //
    // Arguments
    // PdoCb * Local Host's Pdo Control Block
    // NodeAddress * Node Address structre wher the address will be returned in 
    // fulFlags - Could specify USE_LOCAL_HOST
    //
    // Return Value:
    // Success if the irp succeeeded
    // Failure: if the pdo is not active or the irp failed
    //
    
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    
    TRACE( TL_T, TM_Irp, ( "==>nicGet1394AddressFromDeviceObject, pPdo %x, pNodeAdddress ", 
                            pPdo, pNodeAddress) );


    ASSERT (pNodeAddress != NULL);
    ASSERT (pPdo != NULL);
    do
    {
    
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressFromDeviceObject, nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        pIrb->Flags = 0;
        pIrb->FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;     
        pIrb->u.Get1394AddressFromDeviceObject.fulFlags = fulFlags;

        NdisStatus = nicGetIrp (pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressFromDeviceObject, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);

        
        NdisStatus = nicSubmitIrp_PDOSynch (pPdo,
                                            pIrp,
                                            pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressFromDeviceObject, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;


        }
    
        (*pNodeAddress) = pIrb->u.Get1394AddressFromDeviceObject.NodeAddress;

    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //

    if (pIrb != NULL)
    {
        nicFreeIrb (pIrb);
    }

    if (pIrp != NULL)
    {
        nicFreeIrp (pIrp);
    }

    TRACE( TL_T, TM_Irp, ( "<==nicGet1394AddressFromDeviceObject, Status %x, Address %x", NdisStatus, *pNodeAddress ) );

    return NdisStatus;
}



NDIS_STATUS
nicGetGenerationCount(
    IN PADAPTERCB       pAdapter,
    IN OUT PULONG    GenerationCount
    )
    // This function returns the generation count of the Device Object that PDO points to.
    //
{
    NDIS_STATUS       NdisStatus = NDIS_STATUS_SUCCESS;
    PIRB               pIrb = NULL;
    PIRP               pIrp = NULL;
    PDEVICE_OBJECT   pDeviceObject = pAdapter->pNdisDeviceObject;


    TRACE( TL_T, TM_Irp, ( "==>nicGetGenerationCount, PDO %x, pVc %x", pDeviceObject ) );



    ASSERT( pDeviceObject != NULL);
    


    do
    {

        NdisStatus  = nicGetIrb( &pIrb );
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {

            TRACE( TL_A, TM_Irp, ( "Failed to allocate an Irb in nicGetGenerationCout") );
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisStatus = nicGetIrp (pDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {

            TRACE( TL_A, TM_Irp, ( "Failed to allocate an Irp in nicGetGenerationCout") );
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        

        pIrb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
        pIrb->Flags = 0;

        NdisStatus = nicSubmitIrp_LocalHostSynch( pAdapter, pIrp, pIrb);

        if (NdisStatus == NDIS_STATUS_SUCCESS) 
        {
        
            *GenerationCount = pIrb->u.GetGenerationCount.GenerationCount;

            TRACE( TL_N, TM_Irp,  ("GenerationCount = 0x%x\n", *GenerationCount) );
        }
        else 
        {

            TRACE(TL_A, TM_Irp, ("SubmitIrpSync failed = 0x%x\n", NdisStatus));
            ASSERT (0);
            break;
        }


    } while(FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //

    if (pIrb != NULL)
    {
        nicFreeIrb (pIrb);
    }

    if (pIrp != NULL)
    {
        nicFreeIrp (pIrp);
    }
    
    TRACE( TL_T, TM_Irp, ( "<==nicGetGenerationCount, PDO %x, Generation %x", pDeviceObject, *GenerationCount) );

    return NdisStatus;
}




NDIS_STATUS
nicFreeAddressRange(
    IN PADAPTERCB pAdapter,
    IN ULONG nAddressesToFree,
    IN PADDRESS_RANGE p1394AddressRange,
    IN PHANDLE phAddressRange
    )
    // Function Description:
    //    This is the generic call to free an address range. It is the callers responsibility to figure out 
    //    the reference counting on the RemoteNode
    //    This is because in the RecvFIFO code path we allocate one address range on each remote node
    //    whereas in the Broadcast channel register, we allocate one addreesss on ONE remote node only
    //
    // Arguments
    //  pRemoteNode, - Remote Node used to submit the IRP
    //  nAddressesToFree, - Number of addreses to free
    //  p1394AddressRange, - pointer to the address range which was allocated
    //  phAddressRange - Handle returned by the bus driver
    //
    // Return Value:
    // Success if the irp succeeeded
    // Failure: if the pdo is not active or the irp failed
    //
    
{
 
    PIRP    pIrp            = NULL;
    PIRB    pIrb            = NULL;
    PDEVICE_OBJECT  pPdo    = pAdapter->pNdisDeviceObject;
    NDIS_STATUS NdisStatus  = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Irp, ( "==>nicFreeAddressRange  pAdapter %x", pAdapter ) );
    
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL); 
    
    do
    {

        if (pPdo == NULL)
        {
            TRACE( TL_A, TM_Irp, ( "pPdo is NULL in nicFreeRecvFifoAddressRange" ) );
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }


        NdisStatus = nicGetIrb(&pIrb);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrb failed in nicFreeRecvFifoAddressRange" ) );
            break;
        }

        
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrp failed in nicFreeRecvFifoAddressRange" ) );
            break;
        }

        TRACE (TL_V, TM_Cm, (" NumAddresses %x, hAddressRange %x, Hi %x, Length %x, Lo %x", 
                               nAddressesToFree,
                               phAddressRange,
                               p1394AddressRange->AR_Off_High,
                               p1394AddressRange->AR_Length,
                               p1394AddressRange->AR_Off_Low ) );
        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_FREE_ADDRESS_RANGE;
        pIrb->Flags = 0;
        pIrb->u.FreeAddressRange.nAddressesToFree = nAddressesToFree;
        pIrb->u.FreeAddressRange.p1394AddressRange = p1394AddressRange;
        pIrb->u.FreeAddressRange.pAddressRange = phAddressRange;


        
        NdisStatus = nicSubmitIrp_LocalHostSynch( pAdapter, 
                                                 pIrp,
                                                 pIrb );


        
    } while (FALSE);

    //
    // Free the locally allocated memory
    //
    if (pIrp!= NULL)
    {
        nicFreeIrp(pIrp);
    }
    if (pIrb != NULL)
    {
        nicFreeIrb(pIrb);
    }

            
    //
    // We do not care about the status, because we do not know what to do if it fails.
    // However, spew some debug out.
    //

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_N, TM_Irp, ( "nicFreeAddressRangeFAILED %x", NdisStatus) );
    
        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
    }


    
    TRACE( TL_T, TM_Irp, ( "<==nicFreeAddressRangeStatus %x (always success)", NdisStatus) );

    NdisStatus = NDIS_STATUS_SUCCESS;
    return NdisStatus;
}



NDIS_STATUS
nicFreeRecvFifoAddressRange(
    IN REMOTE_NODE *pRemoteNode
    )
    //
    // This function will send an Irp to the bus1394 to free the address range in the VC 
    // that was allocated by the AllocatedAddressRange
    //
    // The argument will be changed to RecvFIFOData once a Pdo can have multiple 
    // RecvFIFOVc hanging off it.

    //
    // This will not change the refcount on the call, the calling function must take care of it.
    //
    
{
 
    PIRP    pIrp            = NULL;
    PIRB    pIrb            = NULL;
    DEVICE_OBJECT * pPdo    = pRemoteNode->pPdo;
    NDIS_STATUS NdisStatus  = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Irp, ( "==>nicFreeRecvFifoAddressRange pRemoteNode %x, ", pRemoteNode) );
    
    ASSERT (pRemoteNode != NULL);
    ASSERT (pRemoteNode->pPdo != NULL);
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL); 
    
    do
    {

        if (pRemoteNode->pPdo == NULL)
        {
            TRACE( TL_A, TM_Irp, ( "pPdo is NULL in nicFreeRecvFifoAddressRange" ) );
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }


        NdisStatus = nicGetIrb(&pIrb);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrb failed in nicFreeRecvFifoAddressRange" ) );
            break;
        }

        ASSERT (pRemoteNode->pPdo != NULL);
        
        NdisStatus = nicGetIrp ( pRemoteNode->pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrp failed in nicFreeRecvFifoAddressRange" ) );
            break;
        }

        
        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_FREE_ADDRESS_RANGE;
        pIrb->Flags = 0;
        pIrb->u.FreeAddressRange.nAddressesToFree = pRemoteNode->RecvFIFOData.AddressesReturned;
        pIrb->u.FreeAddressRange.p1394AddressRange = &pRemoteNode->RecvFIFOData.VcAddressRange;
        pIrb->u.FreeAddressRange.pAddressRange = &pRemoteNode->RecvFIFOData.hAddressRange;


        
        NdisStatus = nicSubmitIrp_Synch( pRemoteNode, 
                                     pIrp,
                                     pIrb );

         REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);

         pRemoteNode->RecvFIFOData.AllocatedAddressRange = FALSE;

         REMOTE_NODE_RELEASE_LOCK (pRemoteNode);

         // Dereference the Pdo Structure. Ref added in AllocateAddressRange.
         // The Address Range is now free
         //
         nicDereferenceRemoteNode (pRemoteNode, "nicFreeRecvFifoAddressRange");

        
    } while (FALSE);

    //
    // Free the locally allocated memory
    //
    if (pIrp!= NULL)
    {
        nicFreeIrp(pIrp);
    }
    if (pIrb != NULL)
    {
        nicFreeIrb(pIrb);
    }

            
    //
    // We do not care about the status, because we do not know what to do if it fails.
    // However, spew some debug out.
    //

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_N, TM_Irp, ( "nicFreeRecvFifoAddressRange FAILED %x", NdisStatus) );
    
        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
    }


    
    TRACE( TL_T, TM_Irp, ( "<==nicFreeRecvFifoAddressRange Status %x (always success)", NdisStatus) );

    NdisStatus = NDIS_STATUS_SUCCESS;
    return NdisStatus;
}



VOID
nicFreeAddressRangeDebugSpew(
    IN PIRB pIrb 
    )
    // This functions spews out the parameters in a Free Address Range Irb
    //
    //
{


    TRACE( TL_V, TM_Irp, ( "==>nicFreeAddressRangeDebugSpew, pIrb = %x", pIrb) );
    ASSERT(pIrb != NULL);
    
    TRACE( TL_N, TM_Irp, ( "Num Addresses Returned %x ",pIrb->u.FreeAddressRange.nAddressesToFree ) );
    TRACE( TL_N, TM_Irp, ( "Address High %x", pIrb->u.FreeAddressRange.p1394AddressRange->AR_Off_High ) );
    TRACE( TL_N, TM_Irp, ( "Address Low %x", pIrb->u.FreeAddressRange.p1394AddressRange->AR_Off_Low ) );
    TRACE( TL_N, TM_Irp, ( "Address Length %x", pIrb->u.FreeAddressRange.p1394AddressRange->AR_Length ) );
    TRACE( TL_N, TM_Irp, ( "Handle %x", pIrb->u.FreeAddressRange.pAddressRange ) );
    
    TRACE( TL_V, TM_Irp, ( "<==nicFreeAddressRangeDebugSpew " ) );

}



NDIS_STATUS
nicFreeChannel(
    IN PADAPTERCB pAdapter,
    IN ULONG nChannel
    )
    // Function Description:
    //  This function sends an Irp to the Bus driver to free a channel
    //  Any remote Pdo can be used for the Irp. However for the sake of
    //  bookkeeping use the same Pdo that the channel was allocated on (maybe) 
    // Arguments
    //  PdoCb The Pdo for the remote node to which the Irp is submitted
    //  Channel Pointer The Channel, requested and the  channel returned
    //
    // Return Value:
    // Success if the channel was allocated
    // Failure otherwise
    //
    
{
 
    PIRP    pIrp            = NULL;
    PIRB    pIrb            = NULL;
    PDEVICE_OBJECT pPdo     = pAdapter->pNdisDeviceObject;
    NDIS_STATUS NdisStatus  = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Irp, ( "==>nicFreeChannel pAdapter %x, Channel %x", pAdapter, nChannel) );
    
    ASSERT (pAdapter!= NULL);
    ASSERT (pPdo != NULL);
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL); 
    
    do
    {

        if (pPdo == NULL)
        {
            TRACE( TL_A, TM_Irp, ( "pPdo is NULL in nicFreeChannel" ) );
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }


        NdisStatus = nicGetIrb(&pIrb);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrb failed in nicFreeChannel" ) );
            break;
        }

        
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrp failed in nicFreeChannel" ) );
            break;
        }

        
        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_FREE_CHANNEL;
        pIrb->Flags = 0;
        pIrb->u.IsochFreeChannel.nChannel = nChannel;

        
        NdisStatus = nicSubmitIrp_LocalHostSynch( pAdapter, 
                                              pIrp,
                                              pIrb );

        //
        // Regardless update the mask, as the channel could have been freed by a bus reset
        //
        if (nChannel != BROADCAST_CHANNEL)
        {
            ADAPTER_ACQUIRE_LOCK (pAdapter);
            

            //
            // Clear the channel in the mask
            //
            pAdapter->ChannelsAllocatedByLocalHost &= (~( g_ullOne <<nChannel ));

            ADAPTER_RELEASE_LOCK (pAdapter);

        }

    } while (FALSE);

    //
    // Free the locally allocated memory
    //
    if (pIrp!= NULL)
    {
        nicFreeIrp(pIrp);
    }
    if (pIrb != NULL)
    {
        nicFreeIrb(pIrb);
    }

            
    //
    // We do not care about the status, because we do not know what to do if it fails.
    // However, spew some debug out.
    //

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_N, TM_Irp, ( "nicFreeChannel FAILED %x", NdisStatus) );
    
        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
    }


    
    TRACE( TL_T, TM_Irp, ( "<==nicFreeChannel Status %x ", NdisStatus) );

    return NdisStatus;
}



NDIS_STATUS
nicAllocateChannel (
    IN PADAPTERCB pAdapter,
    IN ULONG Channel,
    OUT PULARGE_INTEGER pChannelsAvailable OPTIONAL
    )
    // Function Description:
    //  This function sends an Irp to the Bus driver to allocate a channel
    //  Any remote Pdo can be used for the Irp
    //  
    // Arguments
    //  PdoCb The Pdo for the remote node to which the Irp is submitted
    //  Channel  -The Channel, requested and the  channel returned
    //
    // Return Value:
    // Success if the channel was allocated
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    PDEVICE_OBJECT pDeviceObject = pAdapter->pNdisDeviceObject;
    STORE_CURRENT_IRQL;

    TRACE( TL_T, TM_Irp, ( "==>nicIsochAllocateChannel, PdoCb, %x Channel %d", pAdapter, Channel ) );

    do
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicIsochAllocateChannel , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_CHANNEL;
        pIrb->Flags = 0;
        pIrb->u.IsochAllocateChannel.nRequestedChannel = Channel;

        ASSERT (Channel < 64);
            
        NdisStatus = nicGetIrp ( pDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochAllocateChannel , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                               pIrp,
                                               pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochAllocateChannel , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }
    
        if (pChannelsAvailable  != NULL)
        {
            pChannelsAvailable->QuadPart = pIrb->u.IsochAllocateChannel.ChannelsAvailable.QuadPart; 

        }
        

        TRACE( TL_N, TM_Irp, ( "Channel allocated %d", Channel ) );

        if (Channel != BROADCAST_CHANNEL)
        {
            
            ADAPTER_ACQUIRE_LOCK (pAdapter);
            

            //
            // Set the channel in the mask
            //
            pAdapter->ChannelsAllocatedByLocalHost |= ( g_ullOne <<Channel );

            ADAPTER_RELEASE_LOCK (pAdapter);

        }

    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;

    TRACE( TL_T, TM_Irp, ( "<==nicIsochAllocateChannel, Channel %d, Status %x",  Channel, NdisStatus ) );
        
    return NdisStatus;
}




NDIS_STATUS
nicQueryChannelMap (
    IN PADAPTERCB pAdapter,
    OUT PULARGE_INTEGER pChannelsAvailable 
    )
    // Function Description:
    //  This function sends an Irp to the Bus driver to allocate a channel
    //  Any remote Pdo can be used for the Irp
    //  
    // Arguments
    //  PdoCb The Pdo for the remote node to which the Irp is submitted
    //  Channel  -The Channel, requested and the  channel returned
    //
    // Return Value:
    // Success if the channel was allocated
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    PDEVICE_OBJECT pDeviceObject = pAdapter->pNdisDeviceObject;
    STORE_CURRENT_IRQL;

    TRACE( TL_T, TM_Irp, ( "==>nicQueryChannelMap , PdoCb, %x ", pAdapter) );

    do
    {
        if (pChannelsAvailable == NULL)
        {
            ASSERT (pChannelsAvailable != NULL);
            NdisStatus =  NDIS_STATUS_FAILURE;
            break;
        }

        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicQueryChannelMap  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_QUERY_RESOURCES ;
        pIrb->u.IsochQueryResources.fulSpeed = SPEED_FLAGS_100;
        pIrb->Flags = 0;

            
        NdisStatus = nicGetIrp ( pDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicQueryChannelMap  , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                               pIrp,
                                               pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicQueryChannelMap  , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }

        

        //
        // We get the *available* channels, in network-byte order.
        // We have to byte reverse and flip the bits to get 
        // it in the form we want.
        //
        // Looks like we really have to flip the *bits*, not just the bytes.
        //
        {
            LARGE_INTEGER in, out;
            PUCHAR        puc;
            UINT u;
            in = pIrb->u.IsochQueryResources.ChannelsAvailable;
            out.LowPart =  ~SWAPBYTES_ULONG (in.HighPart );
            out.HighPart = ~SWAPBYTES_ULONG (in.LowPart );

            // Now swap the bits in each byte.
            //
            puc = (PUCHAR) &out;
            for (u=sizeof(out); u; u--,puc++)
            {
                UCHAR uc,uc1;
                UINT u1;
                uc= *puc;
                uc1=0;
                for (u1=0;u1<8;u1++)
                {
                    if (uc & (1<<u1))
                    {
                        uc1 |= (1 << (7-u1));
                    }
                }
                *puc = uc1;
            }

            pChannelsAvailable->QuadPart = out.QuadPart;
        }

        
            
    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;

    TRACE( TL_T, TM_Irp, ( "<==nicQueryChannelMap , , Status %x",  NdisStatus ) );
        
    return NdisStatus;
}


NDIS_STATUS
nicIsochAllocateBandwidth(
    IN PREMOTE_NODE pRemoteNodePdoCb,
    IN ULONG MaxBytesPerFrameRequested, 
    IN ULONG SpeedRequested,
    OUT PHANDLE phBandwidth,
    OUT PULONG  pBytesPerFrameAvailable,
    OUT PULONG  pSpeedSelected
    )

    // Function Description:
    //   This function allocates bandwith on the bus
    //   
    // Arguments
    //  PdoCb - Remote Nodes Pdo Block
    //  MaxBytesPerFrame Requested -
    //  SpeedRequested - 
    //  hBandwidth
    //  pSpeedSelected
    //  Bytes Per Frame Available
    //
    //
    // Return Value:
    //  hBandwidth, 
    //  Speed and 
    //  BytesPerFrameAvailable
    //
    //
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    

    TRACE( TL_T, TM_Irp, ( "==>nicIsochAllocateBandwidth, pRemoteNodePdoCb %x", pRemoteNodePdoCb) );


    do
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK( TM_Irp, ( "nicIsochAllocateBandwidth, nicGetIrb FAILED" ) );
        }
        
        ASSERT ( pIrb != NULL);

        pIrb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_BANDWIDTH;
        pIrb->Flags = 0;
        pIrb->u.IsochAllocateBandwidth.nMaxBytesPerFrameRequested = MaxBytesPerFrameRequested;
        pIrb->u.IsochAllocateBandwidth.fulSpeed = SpeedRequested;

        
        ASSERT (pRemoteNodePdoCb->pPdo != NULL);
        
        NdisStatus = nicGetIrp (pRemoteNodePdoCb->pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK( TM_Irp, ( "nicIsochAllocateBandwidth, nicGetIrp FAILED" ) );
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_Synch ( pRemoteNodePdoCb,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE (TL_N, TM_Irp, ( "nicIsochAllocateBandwidth, nicSubmitIrp_Synch FAILED ") );
            break;
        }

        *phBandwidth = pIrb->u.IsochAllocateBandwidth.hBandwidth ;
        *pBytesPerFrameAvailable = pIrb->u.IsochAllocateBandwidth.BytesPerFrameAvailable;
        *pSpeedSelected = pIrb->u.IsochAllocateBandwidth.SpeedSelected;
  
        TRACE( TL_V, TM_Irp, ( "hBandwidth %x", *phBandwidth) );
        TRACE( TL_V, TM_Irp, ( "BytesPerFrameAvailable %x", *pBytesPerFrameAvailable) );
        TRACE( TL_V, TM_Irp, ( "SpeedSelected %x", *pSpeedSelected) );

            

    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    TRACE( TL_T, TM_Irp, ( "<==nicIsochAllocateBandwidth NdisStatus %x", NdisStatus) );

    return NdisStatus;

}




NDIS_STATUS
nicAsyncLock(
    PREMOTE_NODE    pRemoteNode,
    IO_ADDRESS      DestinationAddress,     // Address to lock to
    ULONG           nNumberOfArgBytes,      // Bytes in Arguments
    ULONG           nNumberOfDataBytes,     // Bytes in DataValues
    ULONG           fulTransactionType,     // Lock transaction type
    ULONG           Arguments[2],           // Arguments used in Lock
    ULONG           DataValues[2],          // Data values
    PVOID           pBuffer,                // Destination buffer (virtual address)
    ULONG           ulGeneration           // Generation as known by driver
    )

    
    // Function Description:
    //  This performs an asynchronous lock operation in another
    //  nodes address space
    //
    // Arguments
    //PREMOTE_NODE  pRemoteNode             // Remote Node which owns the Destination address
    //IO_ADDRESS      DestinationAddress,     // Address to lock to
    //ULONG           nNumberOfArgBytes,      // Bytes in Arguments
    //ULONG           nNumberOfDataBytes,     // Bytes in DataValues
    //ULONG           fulTransactionType,     // Lock transaction type
    //ULONG           fulFlags,               // Flags pertinent to lock
    //ULONG           Arguments[2],           // Arguments used in Lock
    //ULONG           DataValues[2],          // Data values
    //PVOID           pBuffer,                // Destination buffer (virtual address)
    //ULONG           ulGeneration,           // Generation as known by driver
    //
    // Return Value:
    //  Success - if successful
    //  Invalid Generation
    //
    //
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Mp, ( "==>nicAsyncLock, Remote Node, %x ", pRemoteNode ) );


    TRACE( TL_V, TM_Mp, ( "   Destination %x, NumArgBytes %x, NumDataBytes ",
                               DestinationAddress, nNumberOfArgBytes, nNumberOfDataBytes  ) );


    TRACE( TL_V, TM_Mp, ( "   TransactionType %x, , Buffer %x, Generation %x",   
                               fulTransactionType, pBuffer, ulGeneration ) );

                               
    TRACE( TL_V, TM_Mp, ( "   Arg[0] %x, Arg[1] %x, Data[0] %x, Data[1] %x",   
                               Arguments[0], Arguments[1], DataValues[0], DataValues[1] ) );


    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK ( TM_Irp, ( "nicAsyncLock, nicGetIrb FAILED" ) );
        }
        
        ASSERT ( pIrb != NULL);

        pIrb->FunctionNumber = REQUEST_ASYNC_LOCK;
        pIrb->Flags = 0;
        pIrb->u.AsyncLock.DestinationAddress = DestinationAddress; 
        pIrb->u.AsyncLock.nNumberOfArgBytes = nNumberOfArgBytes; 
        pIrb->u.AsyncLock.nNumberOfDataBytes = nNumberOfDataBytes;  
        pIrb->u.AsyncLock.fulTransactionType = fulTransactionType;
        pIrb->u.AsyncLock.Arguments[0] = Arguments[0];
        pIrb->u.AsyncLock.Arguments[1] = Arguments[1];
        pIrb->u.AsyncLock.DataValues[0] = DataValues[0];
        pIrb->u.AsyncLock.DataValues[1] = DataValues[1];
        pIrb->u.AsyncLock.pBuffer = pBuffer;
        pIrb->u.AsyncLock.ulGeneration = ulGeneration; 
        
        
        NdisStatus = nicGetIrp ( pRemoteNode->pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (  TM_Irp, ( "nicAsyncLock, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_Synch ( pRemoteNode,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE ( TL_A, TM_Irp, ( "nicAsyncLock, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }
        
        
    } while (FALSE);


    TRACE( TL_T, TM_Mp, ( "<==nicAsyncLock, Success , %x ", NdisStatus) );
    return NdisStatus;
}





NDIS_STATUS
nicAsyncRead_Synch(
    PREMOTE_NODE    pRemoteNode,
    IO_ADDRESS      DestinationAddress,     
    ULONG           nNumberOfBytesToRead,
    ULONG           nBlockSize,
    ULONG           fulFlags,
    PMDL            Mdl,
    ULONG           ulGeneration,
    OUT NTSTATUS    *pNtStatus
    )

    
    // Function Description:
    //  This is an asyc read operation a remote node;s address space
    //
    //
    //
    //
    // Arguments
    //PREMOTE_NODE  pRemoteNode             // Remote Node which owns the Destination address
    //        IO_ADDRESS      DestinationAddress;     // Address to read from
    //        ULONG           nNumberOfBytesToRead;   // Bytes to read
    //        ULONG           nBlockSize;             // Block size of read
    //        ULONG           fulFlags;               // Flags pertinent to read
    //        PMDL            Mdl;                    // Destination buffer
    //        ULONG           ulGeneration;           // Generation as known by driver
    //
    // Return Value:
    //  Success - if successful
    //  Invalid Generation
    //
    //
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Mp, ( "==>nicAsyncRead, Remote Node, %x ", pRemoteNode ) );



    TRACE( TL_V, TM_Mp, ( "   fulFlags %x, Mdl %x, Generation %x, pNtStatus %x",   
                               fulFlags, Mdl, ulGeneration, pNtStatus ) );

    ASSERT(DestinationAddress.IA_Destination_Offset.Off_High  == INITIAL_REGISTER_SPACE_HI);


    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK ( TM_Irp, ( "nicAsyncRead, nicGetIrb FAILED" ) );
        }
        
        ASSERT ( pIrb != NULL);

        pIrb->FunctionNumber = REQUEST_ASYNC_READ;
        pIrb->Flags = 0;
        pIrb->u.AsyncRead.DestinationAddress = DestinationAddress; 
        pIrb->u.AsyncRead.nNumberOfBytesToRead  = nNumberOfBytesToRead ; 
        pIrb->u.AsyncRead.nBlockSize = nBlockSize ;  
        pIrb->u.AsyncRead.fulFlags = fulFlags;
        pIrb->u.AsyncRead.Mdl = Mdl;
        pIrb->u.AsyncRead.ulGeneration = ulGeneration; 
        
        
        NdisStatus = nicGetIrp ( pRemoteNode->pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (  TM_Irp, ( "nicAsyncRead, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_Synch ( pRemoteNode,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE ( TL_A, TM_Irp, ( "nicAsyncRead, nicSubmitIrp_Synch FAILED %xm pRemoteNode %x", NdisStatus, pRemoteNode) );
            break;
        }

        if (pNtStatus != NULL)
        {
            *pNtStatus = pIrp->IoStatus.Status;
        }

    } while (FALSE);



    TRACE( TL_T, TM_Mp, ( "<==nicAsyncRead, Status, %x ", NdisStatus) );


    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);

    
    return NdisStatus;
}



NDIS_STATUS
nicAsyncWrite_Synch(
    PREMOTE_NODE    pRemoteNode,
    IO_ADDRESS      DestinationAddress,     // Address to write to
    ULONG           nNumberOfBytesToWrite,  // Bytes to write
    ULONG           nBlockSize,             // Block size of write
    ULONG           fulFlags,               // Flags pertinent to write
    PMDL            Mdl,                    // Destination buffer
    ULONG           ulGeneration,           // Generation as known by driver
    OUT NTSTATUS   *pNtStatus               // pointer to NTSTatus returned by the IRP  
    )


    
    // Function Description:
    //  This performs an asynchronous write operation in thje remote node's
    //  address space
    //
    // Arguments
    //PREMOTE_NODE  pRemoteNode             // Remote Node which owns the Destination address
    //IO_ADDRESS      DestinationAddress;     // Address to write to
    //ULONG           nNumberOfBytesToWrite;  // Bytes to write
    //ULONG           nBlockSize;             // Block size of write
    //ULONG           fulFlags;               // Flags pertinent to write
    //PMDL            Mdl;                    // Destination buffer
    //ULONG           ulGeneration;           // Generation as known by driver
    //
    // Return Value:
    //  Success - if successful
    //  Invalid Generation
    //
    //
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Mp, ( "==>nicAsyncWrite_Synch, Remote Node, %x ", pRemoteNode ) );


    TRACE( TL_V, TM_Mp, ( "   Destination %x, nNumberOfBytesToWrite %x, nBlockSize %x",
                               DestinationAddress, nNumberOfBytesToWrite, nBlockSize) );


    TRACE( TL_V, TM_Mp, ( "   fulFlags %x, , Mdl %x, Generation %x, pNtStatus %x",   
                               fulFlags , Mdl, ulGeneration, pNtStatus ) );


    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK ( TM_Irp, ( "nicAsyncWrite_Synch, nicGetIrb FAILED" ) );
        }
        
        ASSERT ( pIrb != NULL);

        pIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
        pIrb->Flags = 0;
        pIrb->u.AsyncWrite.DestinationAddress = DestinationAddress; 
        pIrb->u.AsyncWrite.nNumberOfBytesToWrite = nNumberOfBytesToWrite; 
        pIrb->u.AsyncWrite.nBlockSize = nBlockSize;  
        pIrb->u.AsyncWrite.fulFlags = fulFlags;
        pIrb->u.AsyncWrite.Mdl = Mdl;
        pIrb->u.AsyncWrite.ulGeneration = ulGeneration; 
        
        
        NdisStatus = nicGetIrp ( pRemoteNode->pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (  TM_Irp, ( "nicAsyncWrite_Synch, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_Synch ( pRemoteNode,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE ( TL_A, TM_Irp, ( "nicAsyncWrite_Synch, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }

        if (pNtStatus != NULL)
        {
            *pNtStatus = pIrp->IoStatus.Status;
        }
        
    } while (FALSE);


    TRACE( TL_T, TM_Mp, ( "<==nicAsyncWrite_Synch, Success , %x Nt %x", NdisStatus, pIrp->IoStatus.Status) );

    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);
    
    return NdisStatus;
}



    
NDIS_STATUS
nicIsochAllocateResources (
    IN PADAPTERCB       pAdapter,
    IN ULONG            fulSpeed,               // Speed flags
    IN ULONG            fulFlags,               // Flags
    IN ULONG            nChannel,               // Channel to be used
    IN ULONG            nMaxBytesPerFrame,      // Expected size of Isoch frame
    IN ULONG            nNumberOfBuffers,       // Number of buffer(s) that will be attached
    IN ULONG            nMaxBufferSize,         // Max size of buffer(s)
    IN ULONG            nQuadletsToStrip,       // Number striped from start of every packet
    IN ULARGE_INTEGER   uliChannelMask,     // ChannelMask for Multiple channels
    IN OUT PHANDLE      phResource              // handle to Resource
    )
    // Function Description:
    // This function sends an allocate resources irp to the driver. The miniport must do this before it 
    // attempts any channel operation
    // Arguments
    // Taken from documentation for the IsochAllocateResources  
    // fulSpeed - should be the max speed the tx side is expected to stream
    // The payload size in nMaxBytesPerFram cannot exceed the max payload for
    // for this speed.
    // fulFlags - For receive, wtih the standard header stripped, the field should
    // be = (RESOURCE_USED_IN_LISTEN | RESOURCES_STRIP_ADDITIONAL_QUADLETS)
    // Also nQuadletsToStrip = 1
    // For no stripping set nQuadsTostrip to 0 and dont specify the stripping flag.
    // nMaxBytesPerframe - If not stripping it should include the 8 bytes for header/trailer
    // expected to be recieved for each packet.
    // nNumberOfBuffer - see below
    // nMaxBufferSize - This should be always such mode(nMaxBufferSize,nMaxBytesPerFrame) == 0
    // (integer product of number of bytes per packet).
    // nQuadletsTostrip - If stripping only one quadlet (standrd iso header) this is set to 1
    // if zero, the isoch header will be included AND the trailer. So 8 bytes extra will be recieved
    // hResource - see below

    // Return Value:
    // Success if the channel was allocated
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicIsochAllocateResources ") );
    ASSERT (fulSpeed != 0); // 0 is undefined in ISOCH_SP...
    
    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicIsochAllocateResources  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_RESOURCES;
        pIrb->Flags = 0;
        pIrb->u.IsochAllocateResources.fulSpeed = fulSpeed; 
        pIrb->u.IsochAllocateResources.fulFlags = fulFlags;
        pIrb->u.IsochAllocateResources.nChannel = nChannel;
        pIrb->u.IsochAllocateResources.nMaxBytesPerFrame = nMaxBytesPerFrame;
        pIrb->u.IsochAllocateResources.nNumberOfBuffers = nNumberOfBuffers;  
        pIrb->u.IsochAllocateResources.nMaxBufferSize = nMaxBufferSize; 
        pIrb->u.IsochAllocateResources.nQuadletsToStrip = nQuadletsToStrip;
        pIrb->u.IsochAllocateResources.ChannelMask = uliChannelMask;
        
        nicIsochAllocateResourcesDebugSpew(pIrb);

        
        NdisStatus = nicGetIrp ( pAdapter->pNdisDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochAllocateResources  , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                 pIrp,
                                                 pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochAllocateResources , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }

        
        TRACE( TL_N, TM_Irp, ( "nicIsochAllocateResources  Succeeded  hResource %x", pIrb->u.IsochAllocateResources.hResource) );

        *phResource = pIrb->u.IsochAllocateResources.hResource;
                
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    TRACE( TL_T, TM_Irp, ( "<==nicIsochAllocateResources  , Status %x, hResource %x", NdisStatus, *phResource ) );

    MATCH_IRQL;

        
    return NdisStatus;
}


VOID
nicIsochAllocateResourcesDebugSpew(
    IN PIRB pIrb)
{
    


    TRACE( TL_V, TM_Irp, ( " Speed %x", pIrb->u.IsochAllocateResources.fulSpeed ) );
    TRACE( TL_V, TM_Irp, ( " flags %x", pIrb->u.IsochAllocateResources.fulFlags  ) );
    TRACE( TL_V, TM_Irp, ( " Channel %x", pIrb->u.IsochAllocateResources.nChannel  ) );
    TRACE( TL_V, TM_Irp, ( " nMaxBytesPerFrame %x", pIrb->u.IsochAllocateResources.nMaxBytesPerFrame  ) );
    TRACE( TL_V, TM_Irp, ( " nNumberOfBuffers %x", pIrb->u.IsochAllocateResources.nNumberOfBuffers  ) );
    TRACE( TL_V, TM_Irp, ( " nMaxBufferSize  %x", pIrb->u.IsochAllocateResources.nMaxBufferSize  ) );
    TRACE( TL_V, TM_Irp, ( " nQuadletsToStrip %x",  pIrb->u.IsochAllocateResources.nQuadletsToStrip  ) );
    TRACE( TL_V, TM_Irp, ( " pIrb->u.IsochAllocateResources.ChannelMask  %I64x",  pIrb->u.IsochAllocateResources.ChannelMask ) );



}






NDIS_STATUS
nicIsochFreeBandwidth(
    IN REMOTE_NODE *pRemoteNode,
    IN HANDLE hBandwidth
    )
    // Function Description:
    // Arguments
    //
    // Return Value:
    //
    
{
 
    PIRP    pIrp            = NULL;
    PIRB    pIrb            = NULL;
    DEVICE_OBJECT * pPdo    = pRemoteNode->pPdo;
    NDIS_STATUS NdisStatus  = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Irp, ( "==>nicIsochFreeBandwidth pRemoteNode %x, hBandwidth %8x", pRemoteNode , hBandwidth) );
    
    ASSERT (pRemoteNode != NULL);
    ASSERT (pRemoteNode->pPdo != NULL);
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL); 
    ASSERT (hBandwidth != NULL);

    do
    {

        if (pRemoteNode->pPdo == NULL)
        {
            TRACE( TL_A, TM_Irp, ( "pPdo is NULL in nicIsochFreeBandwidth" ) );
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }


        NdisStatus = nicGetIrb(&pIrb);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrb failed in nicIsochFreeBandwidth" ) );
            break;
        }

        ASSERT (pRemoteNode->pPdo != NULL);
        
        NdisStatus = nicGetIrp ( pRemoteNode->pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrp failed in nicIsochFreeBandwidth" ) );
            break;
        }

        
        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_FREE_BANDWIDTH;
        pIrb->Flags = 0;
        pIrb->u.IsochFreeBandwidth.hBandwidth = hBandwidth;

        
        NdisStatus = nicSubmitIrp_Synch( pRemoteNode, 
                                     pIrp,
                                     pIrb );

    } while (FALSE);

    //
    // Free the locally allocated memory
    //
    if (pIrp!= NULL)
    {
        nicFreeIrp(pIrp);
    }
    if (pIrb != NULL)
    {
        nicFreeIrb(pIrb);
    }

            
    //
    // We do not care about the status, because we do not know what to do if it fails.
    // However, spew some debug out.
    //

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_N, TM_Irp, ( "nicIsochFreeBandwidth FAILED %x", NdisStatus) );
    
        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
    }


    
    TRACE( TL_T, TM_Irp, ( "<==nicIsochFreeBandwidth Status %x (always success)", NdisStatus) );

    NdisStatus = NDIS_STATUS_SUCCESS;
    return NdisStatus;
}



NDIS_STATUS
nicIsochFreeResources(
    IN PADAPTERCB pAdapter,
    IN HANDLE hResource
    )
    // Function Description:
    // Arguments
    //
    // Return Value:
    //
    
{
 
    PIRP    pIrp            = NULL;
    PIRB    pIrb            = NULL;
    PDEVICE_OBJECT  pPdo    = pAdapter->pNdisDeviceObject;
    NDIS_STATUS NdisStatus  = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Irp, ( "==>nicIsochFreeResources pAdapter %x, hResource %8x", pAdapter, hResource) );
    
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL); 
    ASSERT (hResource != NULL);

    do
    {
        NdisStatus = nicGetIrb(&pIrb);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrb failed in nicIsochFreeResources" ) );
            break;
        }

        
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrp failed in nicIsochFreeResources" ) );
            break;
        }

        
        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_FREE_RESOURCES;
        pIrb->Flags = 0;
        pIrb->u.IsochFreeResources.hResource = hResource;

        
        NdisStatus = nicSubmitIrp_LocalHostSynch( pAdapter, 
                                               pIrp,
                                               pIrb );

    } while (FALSE);

    //
    // Free the locally allocated memory
    //
    if (pIrp!= NULL)
    {
        nicFreeIrp(pIrp);
    }
    if (pIrb != NULL)
    {
        nicFreeIrb(pIrb);
    }

            
    //
    // We do not care about the status, because we do not know what to do if it fails.
    // However, spew some debug out.
    //

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_N, TM_Irp, ( "nicIsochFreeResources FAILED %x", NdisStatus) );
    
        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
    }


    
    TRACE( TL_T, TM_Irp, ( "<==nicIsochFreeResources Status %x (always success)", NdisStatus) );

    NdisStatus = NDIS_STATUS_SUCCESS;
    return NdisStatus;
}



NDIS_STATUS
nicIsochModifyStreamProperties (
    PADAPTERCB pAdapter,
    NDIS_HANDLE hResource,
    ULARGE_INTEGER ullChannelMap,
    ULONG ulSpeed)
/*++

Routine Description:
 Sets up the Irp and uses the VDO to do an IoCallDriver
 
Arguments:


Return Value:


--*/
{
    PIRP    pIrp            = NULL;
    PIRB    pIrb            = NULL;
    PDEVICE_OBJECT  pPdo    = pAdapter->pNdisDeviceObject;
    NDIS_STATUS NdisStatus  = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Irp, ( "==>nicIsochModifyStreamProperties  pAdapter %x, hResource %x, Speed %x, ChannelMap %I64x", 
                          pAdapter, 
                          hResource,
                          ulSpeed,
                          ullChannelMap) );
    
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL); 
    ASSERT (hResource != NULL);

    do
    {
        NdisStatus = nicGetIrb(&pIrb);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrb failed in nicIsochModifyStreamProperties " ) );
            break;
        }

        
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrp failed in nicIsochModifyStreamProperties " ) );
            break;
        }

        
        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_MODIFY_STREAM_PROPERTIES  ;
        pIrb->Flags = 0;
        pIrb->u.IsochModifyStreamProperties.hResource = hResource;
        pIrb->u.IsochModifyStreamProperties.ChannelMask = ullChannelMap;
        pIrb->u.IsochModifyStreamProperties.fulSpeed = ulSpeed;

        
        NdisStatus = nicSubmitIrp_LocalHostSynch( pAdapter, 
                                               pIrp,
                                               pIrb );

    } while (FALSE);

    //
    // Free the locally allocated memory
    //
    if (pIrp!= NULL)
    {
        nicFreeIrp(pIrp);
    }
    if (pIrb != NULL)
    {
        nicFreeIrb(pIrb);
    }

            
    //
    // We do not care about the status, because we do not know what to do if it fails.
    // However, spew some debug out.
    //

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_N, TM_Irp, ( "nicIsochModifyStreamProperties  FAILED %x", NdisStatus) );
    
        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
    }


    
    TRACE( TL_T, TM_Irp, ( "<==nicIsochModifyStreamProperties  Status %x (always success)", NdisStatus) );

    return NdisStatus;








}






NDIS_STATUS
nicBusReset (
    IN PADAPTERCB pAdapter,
    IN OUT ULONG fulFlags
    )
    // Function Description:
    //  This function sends an Irp to the Bus driver to reset the bus
    //  Any remote Pdo can be used for the Irp. 
    //  A flag can be set to force the root to be reset
    // Arguments
    //  PdoCb The Pdo for the remote node to which the Irp is submitted
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    PDEVICE_OBJECT pPdo = pAdapter->pNdisDeviceObject;
    STORE_CURRENT_IRQL;

        
    
    TRACE( TL_T, TM_Irp, ( "==>nicBusReset , PdoCb, %x Flags %x", pAdapter, fulFlags ) );
    ASSERT (pPdo != NULL);
    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicBusReset  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_BUS_RESET;
        pIrb->Flags = 0;
        pIrb->u.BusReset.fulFlags = fulFlags;

        
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicBusReset, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);

        TRACE( TL_N, TM_Irp, ( "BUS RESET,  Flags%d on pAdapter %x", fulFlags, pAdapter) );
    

        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicBusReset , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }

        NdisInterlockedIncrement (&pAdapter->AdaptStats.ulNumResetsIssued);     
                
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    TRACE( TL_T, TM_Irp, ( "<==nicBusReset %x",  NdisStatus ) );
    MATCH_IRQL;
    
        
    return NdisStatus;
}


NDIS_STATUS
nicBusResetNotification (
    IN PADAPTERCB pAdapter,
    IN ULONG fulFlags,
    IN PBUS_BUS_RESET_NOTIFICATION pResetRoutine,
    IN PVOID pResetContext
    )
    // Function Description:
    //  This function sends an Irp to the Bus driver to register/deregister 
    //  a notification routine. Any remote Pdo can be used for the Irp. 
    //  
    // Arguments
    //  PdoCb The Pdo for the remote node to which the Irp is submitted
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PDEVICE_OBJECT pPdo  = pAdapter->pNdisDeviceObject;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicBusResetNotification, pAdapter %x, Flags %x, Routine %x, Context %x", pAdapter, fulFlags, pResetRoutine, pResetContext  ) );

    ASSERT (KeGetCurrentIrql()==PASSIVE_LEVEL);
    
    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicBusResetNotification  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
        pIrb->Flags = 0;
        pIrb->u.BusResetNotification.fulFlags = fulFlags;
        pIrb->u.BusResetNotification.ResetRoutine = pResetRoutine;
        pIrb->u.BusResetNotification.ResetContext= pResetContext;

        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicBusResetNotification , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicBusResetNotification  , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }
    
        TRACE( TL_N, TM_Irp, ( "    nicBusResetNotification success,  Flags %d on pAdapter %x", fulFlags, pAdapter) );
                
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<==nicBusResetNotification %x",  NdisStatus ) );
        
    return NdisStatus;
}



NDIS_STATUS
nicAsyncStream (
    PREMOTE_NODE          pRemoteNodePdoCb,
    ULONG           nNumberOfBytesToStream, // Bytes to stream
    ULONG           fulFlags,               // Flags pertinent to stream
    PMDL            pMdl,                  // Source buffer
    ULONG           ulTag,                  // Tag
    ULONG           nChannel,               // Channel
    ULONG           ulSynch,                // Sy
    ULONG           Reserved,               // Reserved for future use
    UCHAR           nSpeed
    )
    // Function Description:
    //  This is the interface to the Bus Apis. This will cause transmission on 
    //  an isochronous channel. The data is supllied by a single Mdl
    //
    // Arguments
    //
    // nNumberOfBytesToStream, // Bytes to stream
    // fulFlags,               // Flags pertinent to stream
    // Mdl,                    // Source buffer
    // ulTag,                  // Tag
    // nChannel,               // Channel
    // ulSynch,                // Sy
    // Reserved,               // Reserved for future use
    // nSpeed
    //
    //
    // Return Value:
    // Status of the Irp
    
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    
    TRACE( TL_T, TM_Irp, ( "==>nicAsyncStream , pRemoteNodePdoCb %x, Mdl %x", pRemoteNodePdoCb, pMdl) );

    ASSERT (pRemoteNodePdoCb->pPdo != NULL);
    ASSERT (pMdl != NULL);
    
    do
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicAsyncStream , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);
        
        pIrb->FunctionNumber = REQUEST_ASYNC_STREAM;
        pIrb->Flags = 0;
        pIrb->u.AsyncStream.nNumberOfBytesToStream = nNumberOfBytesToStream;
        pIrb->u.AsyncStream.fulFlags = fulFlags;
        pIrb->u.AsyncStream.ulTag = ulTag;
        pIrb->u.AsyncStream.nChannel = nChannel;
        pIrb->u.AsyncStream.ulSynch = ulSynch;
        pIrb->u.AsyncStream.nSpeed = nSpeed;
        pIrb->u.AsyncStream.Mdl = pMdl;

        nicAsyncStreamDebugSpew (pIrb);

        NdisStatus = nicGetIrp ( pRemoteNodePdoCb->pPdo, 
                              &pIrp );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicAsyncStream , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);

        ASSERT ( REMOTE_NODE_TEST_FLAG (pRemoteNodePdoCb, PDO_Activated) );
        
        NdisStatus = nicSubmitIrp_Synch (  pRemoteNodePdoCb,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicAsyncStream , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }
    

    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //

    if (pIrb != NULL)
    {
        nicFreeIrb (pIrb);
    }

    if (pIrp != NULL)
    {
        nicFreeIrp (pIrp);
    }

    TRACE( TL_T, TM_Irp, ( "<==nicAsyncStream , Status %x", NdisStatus ) );

    return NdisStatus;


}




VOID
nicAsyncStreamDebugSpew (
    PIRB pIrb
    )
    // Function Description:
    //   This function prints out all the parameters for an async stream irb
    // Arguments
    //   Irb - whose paramters will be printed out 
    // Return Value:
    //
{

    TRACE( TL_V, TM_Irp, ( "==>nicAsyncStreamDebugSpew " ) );

    TRACE( TL_V, TM_Irp, ( "Number of Bytes to Stream %x ", pIrb->u.AsyncStream.nNumberOfBytesToStream  ) );
    TRACE( TL_V, TM_Irp, ( "fulFlags %x ", pIrb->u.AsyncStream.fulFlags  ) );
    TRACE( TL_V, TM_Irp, ( "ulTag %x ", pIrb->u.AsyncStream.ulTag ) );
    TRACE( TL_V, TM_Irp, ( "Channel %x", pIrb->u.AsyncStream.nChannel  ) );
    TRACE( TL_V, TM_Irp, ( "Synch %x", pIrb->u.AsyncStream.ulSynch  ) );
    TRACE( TL_V, TM_Irp, ( "Speed %x", pIrb->u.AsyncStream.nSpeed  ) );
    TRACE( TL_V, TM_Irp, ( "Mdl %x", pIrb->u.AsyncStream.Mdl ) );

    TRACE( TL_V, TM_Irp, ( "<==nicAsyncStreamDebugSpew " ) );

}
    


NDIS_STATUS
nicGetMaxSpeedBetweenDevices (
    PADAPTERCB pAdapter,
    UINT   NumOfRemoteNodes,
    PDEVICE_OBJECT pArrayDestinationPDO[64],
    PULONG  pSpeed
    )
    // Function Description:
    //   This function submits an irp to the bus driver
    //   to get the max speed between 2 nodes
    //   Uses REQUEST_GET_SPEED_BETWEEN_DEVICES  
    //
    //
    // Arguments
    //   Remote Node Start of an array of PDOs for remote nodes
    //   NumOfRemoteNodes The number of remote nodes we are interested in
    //   pArrayDestinationPDO = Array of Destination PDO's
    // Return Value:
    //  Success if irp succeeded
    //  pSpeed will point to the Speed
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    UINT index =0;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    BOOLEAN fRefRemoteNode = FALSE;
    ULONG NumRemote = NumOfRemoteNodes;
    
    TRACE( TL_T, TM_Irp, ( "==>nicGetMaxSpeedBetweenDevices pRemoteNodeArray %x", 
                            pArrayDestinationPDO ) );
    TRACE( TL_T, TM_Irp, ( "==>NumOfRemoteNodes %x, pSpeed %x", 
                            NumOfRemoteNodes, pSpeed ) );

    do 
    {

        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGetMaxSpeedBetweenDevices , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        while (NumRemote != 0)
        {
            pIrb->u.GetMaxSpeedBetweenDevices.hDestinationDeviceObjects[NumRemote-1] = pArrayDestinationPDO[NumRemote-1];   
            TRACE( TL_V, TM_Irp, ( " NumRemote %x, hPdo[] %x = pArray[] %x",NumRemote , 
                            pIrb->u.GetMaxSpeedBetweenDevices.hDestinationDeviceObjects[NumRemote-1] ,pArrayDestinationPDO[NumRemote-1] ) );

            TRACE( TL_V, TM_Irp, ( " &hPdo[] %x, &pArray[] %x",
                                    &pIrb->u.GetMaxSpeedBetweenDevices.hDestinationDeviceObjects[NumRemote-1] ,&pArrayDestinationPDO[NumRemote-1] ) );

            //
            // catching a strange condition that debug spew showed up 
            //
            ASSERT (pArrayDestinationPDO[NumRemote] != pArrayDestinationPDO[NumRemote-1]);  
            NumRemote --;
        }

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_GET_SPEED_BETWEEN_DEVICES;
        pIrb->Flags = 0;
        pIrb->u.GetMaxSpeedBetweenDevices.fulFlags = USE_LOCAL_NODE;
        pIrb->u.GetMaxSpeedBetweenDevices.ulNumberOfDestinations = NumOfRemoteNodes;
        

        
        NdisStatus = nicGetIrp ( pAdapter->pNdisDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetMaxSpeedBetweenDevices , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                    pIrp,
                                                    pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetMaxSpeedBetweenDevices , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }

        *pSpeed = pIrb->u.GetMaxSpeedBetweenDevices.fulSpeed ;
    

    } while (FALSE);    
    
    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);

    

    TRACE( TL_T, TM_Irp, ( "<==nicGetMaxSpeedBetweenDevices Status %x, Speed %x",
                             NdisStatus, *pSpeed ) );


    
    return NdisStatus;

    
                             


}
    



NDIS_STATUS
nicIsochAttachBuffers (
    IN PADAPTERCB           pAdapter,
    IN HANDLE              hResource,
    IN ULONG               nNumberOfDescriptors,
    PISOCH_DESCRIPTOR       pIsochDescriptor
    )
    // Function Description:
    //  
    // Arguments
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    ASSERT (pIsochDescriptor!=NULL);
    ASSERT (hResource != NULL);
    ASSERT (nNumberOfDescriptors > 0);

    TRACE( TL_T, TM_Irp, ( "==>nicIsochAttachBuffers, pAdapter, %x ", pAdapter) );
    TRACE( TL_N, TM_Irp, ( "hResource  %x, nNumberOfDescriptors %x, pIsochDescriptor %x, ", hResource, nNumberOfDescriptors, pIsochDescriptor ) );



    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicIsochAttachBuffers, nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_ATTACH_BUFFERS;
        pIrb->Flags = 0;
        pIrb->u.IsochAttachBuffers.hResource = hResource ;
        pIrb->u.IsochAttachBuffers.nNumberOfDescriptors = nNumberOfDescriptors;
        pIrb->u.IsochAttachBuffers.pIsochDescriptor = pIsochDescriptor;
        
        NdisStatus = nicGetIrp ( pAdapter->pNdisDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochAttachBuffers , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                 pIrp,
                                                 pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochAttachBuffers  , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }
    
        TRACE( TL_N, TM_Irp, ( "nicIsochAttachBuffers success") );
                
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<==nicIsochAttachBuffers %x",  NdisStatus ) );
        
    return NdisStatus;
}

NDIS_STATUS
nicIsochDetachBuffers (
    IN PADAPTERCB           pAdapter,
    IN HANDLE              hResource,
    IN ULONG               nNumberOfDescriptors,
    PISOCH_DESCRIPTOR     pIsochDescriptor
    )
    // Function Description:
    //  
    // Arguments
    //        HANDLE              hResource;            // Resource handle
    //        ULONG               nNumberOfDescriptors; // Number to detach
    //        PISOCH_DESCRIPTOR   pIsochDescriptor;     // Pointer to Isoch descriptors - same as
    //                                                      pointer used in Attach Buffers
    // Return Status :
    //       Success if the Irp succeeded 
    //


{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    PDEVICE_OBJECT pPdo = pAdapter->pNdisDeviceObject;
    STORE_CURRENT_IRQL;

    ASSERT (pIsochDescriptor!=NULL);
    ASSERT (hResource != NULL);
    ASSERT (nNumberOfDescriptors > 0);

    TRACE( TL_T, TM_Irp, ( "==>nicIsochDetachBuffers, ") );
    TRACE( TL_V, TM_Irp, ( "hResource  %x, nNumberOfDescriptors %x, pIsochDescriptor %x, ", hResource, nNumberOfDescriptors, pIsochDescriptor ) );



    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicIsochDetachBuffers, nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_DETACH_BUFFERS;
        pIrb->Flags = 0;
        pIrb->u.IsochDetachBuffers.hResource = hResource ;
        pIrb->u.IsochDetachBuffers.nNumberOfDescriptors = nNumberOfDescriptors;
        pIrb->u.IsochDetachBuffers.pIsochDescriptor = pIsochDescriptor;
        
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochDetachBuffers , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                               pIrp,
                                               pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochDetachBuffers  , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }
    
        TRACE( TL_V, TM_Irp, ( "nicIsochDetachBuffers success,  ") );
                
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<==nicIsochDetachBuffers %x",  NdisStatus ) );
        
    return NdisStatus;
}



NDIS_STATUS
nicIsochListen (
    IN PADAPTERCB pAdapter,
    HANDLE        hResource,
    ULONG         fulFlags,
    CYCLE_TIME    StartTime
    )
    // Function Description:
    //  Activates the bus driver to listen to data on that channel
    // Arguments
    //  RemoteNode - Remote Node
    //  hResource - Handle to resource with ISochDescriptors
    //  Flags - not used yet
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    ASSERT (hResource != NULL);

    TRACE( TL_T, TM_Irp, ( "==>nicIsochListen, pAdapter %x, hResource  %x ", pAdapter,hResource) );

    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicIsochListen, nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_LISTEN;
        pIrb->Flags = 0;
        pIrb->u.IsochListen.hResource = hResource ;
        pIrb->u.IsochListen.fulFlags = fulFlags;
        pIrb->u.IsochListen.StartTime = StartTime;
        
        NdisStatus = nicGetIrp ( pAdapter->pNdisDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochListen , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                 pIrp,
                                                 pIrb );
                                                 
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochListen  , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }
    
        TRACE( TL_N, TM_Irp, ( "nicIsochListen success,  pAdapter %x", pAdapter) );
                
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<==nicIsochListen %x",  NdisStatus ) );
        
    return NdisStatus;





}






NDIS_STATUS
nicIsochStop (
    IN PADAPTERCB pAdapter,
    IN HANDLE  hResource
    )
    // Function Description:
    //   Issues an IsochStop Irp to the Device
    //  Should stop Isoch IO on that resource
    // Arguments
    //  PdoCb The Pdo for the remote node to which the Irp is submitted
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    PDEVICE_OBJECT pPdo = pAdapter->pNdisDeviceObject;
    STORE_CURRENT_IRQL;


    TRACE( TL_T, TM_Irp, ( "==>nicIsochStop , pPdo, %x hResource %x", pPdo, hResource) );

    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicIsochStop  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_STOP;
        pIrb->Flags = 0;
        pIrb->u.IsochStop.hResource = hResource;
        pIrb->u.IsochStop.fulFlags = 0;
        
        NdisStatus = nicGetIrp (pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochStop , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                pIrp,
                                                pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochStop , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }

        
            
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<== nicIsochStop , Status ", NdisStatus) );
        
    return NdisStatus;
}




NDIS_STATUS
nicGetLocalHostCSRTopologyMap(
    IN PADAPTERCB pAdapter,
    IN PULONG pLength,
    IN PVOID pBuffer
    )
    // Function Description:
    //  Retrieves the local hosts CSR.  
    // Arguments
    //  pBuffer - LocalHostBuffer
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    GET_LOCAL_HOST_INFO6    LocalHostInfo6;
    STORE_CURRENT_IRQL;

    ASSERT (pLength != NULL);
    ASSERT (pBuffer != NULL);
    
    TRACE( TL_T, TM_Irp, ( "==>nicGetLocalHostCSRTopologyMap , pAdapter %x ,Length %x, Buffer", 
                           pAdapter, *pLength, pBuffer) );

    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostCSRTopologyMap  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        LocalHostInfo6.CsrBaseAddress.Off_High  = INITIAL_REGISTER_SPACE_HI;
        LocalHostInfo6.CsrBaseAddress.Off_Low  = TOPOLOGY_MAP_LOCATION;
        LocalHostInfo6.CsrDataLength = *pLength;
        LocalHostInfo6.CsrDataBuffer = pBuffer;
        
        
        pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
        pIrb->Flags = 0;
        pIrb->u.GetLocalHostInformation.nLevel = GET_HOST_CSR_CONTENTS;
        pIrb->u.GetLocalHostInformation.Information = &LocalHostInfo6;

        
        NdisStatus = nicGetIrp ( pAdapter->pNdisDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostCSRTopologyMap , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostCSRTopologyMap , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );

            TRACE( TL_A, TM_Irp, ( "Length Needed %.x", LocalHostInfo6.CsrDataLength) );

            if (pIrp->IoStatus.Status == STATUS_INVALID_BUFFER_SIZE)
            {
                *pLength = LocalHostInfo6.CsrDataLength; 
            }
            break;
        }

            
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<== nicGetLocalHostCSRTopologyMap , Status %x", NdisStatus) );
        
    return NdisStatus;
}






NDIS_STATUS
nicGetLocalHostConfigRom(
    IN PADAPTERCB pAdapter,
    OUT  PVOID *ppCRom
    )
    // Function Description:
    //  Retrieves the local hosts CSR.  
    // Arguments
    //  pBuffer - Locally allocated. Caller has to free
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    GET_LOCAL_HOST_INFO5 Info;
    PVOID pCRom;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicGetLocalHostConfigRom, pAdapter %x ", 
                           pAdapter) );

    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostConfigRom , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        Info.ConfigRom = NULL;
        Info.ConfigRomLength = 0;
        
        pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO ;
        pIrb->Flags = 0;
        pIrb->u.GetLocalHostInformation.nLevel = GET_HOST_CONFIG_ROM;
        pIrb->u.GetLocalHostInformation.Information = &Info;
        
        NdisStatus = nicGetIrp ( pAdapter->pNdisDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostConfigRom , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);

        //
        // First find the length
        // 

        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (Info.ConfigRomLength == 0)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
        
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostConfigRom, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;

        }

        nicFreeIrp (pIrp);

        pCRom = ALLOC_NONPAGED (Info.ConfigRomLength, 'C31N');

        if (pCRom == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        Info.ConfigRom = pCRom;

        NdisStatus = nicGetIrp ( pAdapter->pNdisDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostConfigRom, nicGetIrp FAILED" ) );
            break;
        }
        
        
        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                               pIrp,
                                               pIrb );

        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostConfigRom, nicGetIrp FAILED" ) );
            break;
        }

        *ppCRom = pCRom;

            
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<== nicGetLocalHostCSRTopologyMap , Status %x", NdisStatus) );
        
    return NdisStatus;
}






NDIS_STATUS
nicGetConfigRom(
    IN PDEVICE_OBJECT pPdo,
    OUT PVOID *ppCrom
    )
    // Function Description:
    //  Retrieves the Config Rom from the Device Object.
    // Caller responsibility to free this memory.  
    // Arguments
    //  pBuffer - LocalHostBuffer
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    ULONG SizeNeeded= 0;
    PVOID pConfigInfoBuffer;

    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicGetConfigRom, pPdo %x ",pPdo ) );

    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostCSRTopologyMap  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        
        
        pIrb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
            
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetConfigRom, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_PDOSynch ( pPdo,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetConfigRom, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );

            break;
        }

        nicFreeIrp (pIrp);

        
        SizeNeeded = sizeof(CONFIG_ROM) +pIrb->u.GetConfigurationInformation.UnitDirectoryBufferSize +
                                pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize + 
                                pIrb->u.GetConfigurationInformation.VendorLeafBufferSize +
                                pIrb->u.GetConfigurationInformation.ModelLeafBufferSize;

        TRACE( TL_A, TM_Irp, ( "nicGetConfigRom , SixeNeeded %x", SizeNeeded) );

        pConfigInfoBuffer = ALLOC_NONPAGED (SizeNeeded , 'C13N');

        if (pConfigInfoBuffer  == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
    
        }

        pIrb->u.GetConfigurationInformation.ConfigRom = (PCONFIG_ROM)pConfigInfoBuffer;
        pIrb->u.GetConfigurationInformation.UnitDirectory = (PVOID)((PUCHAR)pConfigInfoBuffer + sizeof(CONFIG_ROM));
        pIrb->u.GetConfigurationInformation.UnitDependentDirectory = (PVOID)((PUCHAR)pIrb->u.GetConfigurationInformation.UnitDirectory + 
                                                                            pIrb->u.GetConfigurationInformation.UnitDirectoryBufferSize);
        pIrb->u.GetConfigurationInformation.VendorLeaf = (PVOID)((PUCHAR)pIrb->u.GetConfigurationInformation.UnitDependentDirectory + 
                                                                                  pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize);
        pIrb->u.GetConfigurationInformation.ModelLeaf = (PVOID)((PUCHAR)pIrb->u.GetConfigurationInformation.VendorLeaf + 
                                                                                  pIrb->u.GetConfigurationInformation.VendorLeafBufferSize);        
        pIrb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;

        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetConfigRom, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_PDOSynch ( pPdo,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetConfigRom, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );

            break;
        }
        TRACE( TL_A, TM_Irp, ( "nicGetConfigRom, pConfigRom %x, Size %x", pConfigInfoBuffer  , SizeNeeded ) );
        

        *ppCrom = pConfigInfoBuffer;
        
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<== nicGetLocalHostCSRTopologyMap , Status %x", NdisStatus) );
        
    return NdisStatus;
}





NDIS_STATUS
nicGetReadWriteCapLocalHost(
    IN PADAPTERCB pAdapter,
    PGET_LOCAL_HOST_INFO2 pReadWriteCaps
    )
/*++

Routine Description:
  Gets the ReadWrite Capabilities for the local host

Arguments:
    ReadWriteCaps - To be filled up byt the bus driver

Return Value:


--*/

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicGetReadWriteCapLocalHost, pAdapter %x pReadWriteCaps %x", 
                           pAdapter, pReadWriteCaps) );

    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGetReadWriteCapLocalHost , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        NdisZeroMemory (pReadWriteCaps, sizeof(*pReadWriteCaps));
 
        
        pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
        pIrb->Flags = 0;
        pIrb->u.GetLocalHostInformation.nLevel = GET_HOST_CAPABILITIES;
        pIrb->u.GetLocalHostInformation.Information = pReadWriteCaps;

        
        NdisStatus = nicGetIrp ( pAdapter->pNdisDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetReadWriteCapLocalHost, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetReadWriteCapLocalHost, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );

            break;
        }

            
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);

    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<== nicGetReadWriteCapLocalHost, Status %x", NdisStatus) );
        
    return NdisStatus;
}



NDIS_STATUS
nicSetLocalHostPropertiesCRom (
    IN PADAPTERCB pAdapter,
    IN PUCHAR pConfigRom,
    IN ULONG Length,
    IN ULONG Flags,
    IN OUT PHANDLE phCromData,
    IN OUT PMDL *ppConfigRomMdl
    )


    // Function Description:
    //   Allocates an MDL pointing to the Buffer 
    //   and sends it to the bus driver
    //
    // Arguments
    //   pAdapter - Local host
    //   ConfigRom - Buffer to be sent to the bus driver
    //   Length - Length of the Config Rom Buffer
    //   Flags - Add or remove
    //   phConfigRom - if Remove then this is an input parameter
    // Return Value: 
    //   Handle  - Is successful
    //

{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    PMDL pMdl = NULL;
    SET_LOCAL_HOST_PROPS3 SetLocalHost3;

    TRACE( TL_T, TM_Irp, ( "==>nicSetLocalHostPropertiesCRom , pAdapter %x, pConfigRom %x",pAdapter, pConfigRom) );

    if (Flags == SLHP_FLAG_ADD_CROM_DATA)
    {
        TRACE( TL_T, TM_Irp, ( "    ADD") );

    }
    else
    {
        TRACE( TL_T, TM_Irp, ( "    REMOVE Handle %x", *pConfigRom) );
    
    }


    do
    {   
        //
        // Get an mdl describing the config rom
        //

        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicSetLocalHostPropertiesCRom , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);
        
        //
        // Initialize the set local host struct
        //

        if (Flags == SLHP_FLAG_ADD_CROM_DATA)
        {
            NdisStatus = nicGetMdl ( Length, pConfigRom, &pMdl);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Irp, ( "nicSetLocalHostPropertiesCRom , nicGetIrb FAILED" ) );
                break;
            }


            SetLocalHost3.fulFlags = SLHP_FLAG_ADD_CROM_DATA;          
            SetLocalHost3.hCromData = NULL;
            SetLocalHost3.nLength = Length;
            SetLocalHost3.Mdl = pMdl;
        }
        else
        {
            SetLocalHost3.fulFlags = SLHP_FLAG_REMOVE_CROM_DATA  ;
            ASSERT (phCromData != NULL);
            SetLocalHost3.hCromData  = *phCromData;
        }

        pIrb->FunctionNumber = REQUEST_SET_LOCAL_HOST_PROPERTIES;
        pIrb->Flags = 0;
        pIrb->u.GetLocalHostInformation.nLevel = SET_LOCAL_HOST_PROPERTIES_MODIFY_CROM;
        pIrb->u.GetLocalHostInformation.Information = &SetLocalHost3;


        //
        // Get an Irp
        //

        NdisStatus = nicGetIrp ( pAdapter->pNdisDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicSetLocalHostPropertiesCRom , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicSetLocalHostPropertiesCRom , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;


        }

        if (Flags == SLHP_FLAG_ADD_CROM_DATA)
        {
            *phCromData = SetLocalHost3.hCromData;
            *ppConfigRomMdl = pMdl;

        }
        else
        {
            //
            // Free the Mdl that contains the CROM
            //
            ASSERT (*ppConfigRomMdl);
            nicFreeMdl (*ppConfigRomMdl);
        }
    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    TRACE( TL_T, TM_Irp, ( "<==nicSetLocalHostPropertiesCRom  pAdapter %x", pAdapter ) );


    return NdisStatus;

}


NDIS_STATUS
nicGetLocalHostUniqueId(
    IN PADAPTERCB pAdapter,
    IN OUT PGET_LOCAL_HOST_INFO1 pUid
    )
    // Function Description:
    //  Retrieves the local hosts UniqueId.  
    // Arguments
    //  pBuffer - LocalHostBuffer
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicGetLocalHostUniqueId , pAdapter%x ,pUid", 
                           pAdapter, pUid) );

    do 
    {
        ASSERT (pAdapter->pNdisDeviceObject != NULL);
        
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostUniqueId  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        
        
        pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
        pIrb->Flags = 0;
        pIrb->u.GetLocalHostInformation.nLevel = GET_HOST_UNIQUE_ID;
        pIrb->u.GetLocalHostInformation.Information = (PVOID) pUid;

        
        NdisStatus = nicGetIrp ( pAdapter->pNdisDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostCSRTopologyMap , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostUniqueId , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );

            break;
        }

            
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<== nicGetLocalHostUniqueId , Status %x", NdisStatus) );
        
    return NdisStatus;
}



//---------------------------------------------------------
// The routines to submit Irp's to the bus, synchronously or 
// asynchronously begin here 
//---------------------------------------------------------


NTSTATUS 
nicSubmitIrp(
   IN PDEVICE_OBJECT    pPdo,
   IN PIRP              pIrp,
   IN PIRB              pIrb,
   IN PIO_COMPLETION_ROUTINE  pCompletion,
   IN PVOID             pContext
   )
   
    //
    // This is the generic function used by all Irp Send Handlers 
    // to do an IoCallDriver. It sets up the next location in the 
    // stack prior to calling the Irp   
    // Make sure the Irp knows about the Irb by setting it up as an argument
    //
{

    NTSTATUS NtStatus ;
    PIO_STACK_LOCATION  NextIrpStack;
    
    TRACE( TL_T, TM_Irp, ( "==>nicSubmitIrp, pPdo %x, Irp %x, Irb %x, ", 
                            pPdo, pIrp ,pIrb, pCompletion ) );

    TRACE( TL_T, TM_Irp, ( "     pCompletion %x, pContext %x", 
                            pCompletion, pContext ) );


    ASSERT (pPdo != NULL);

    IoSetCompletionRoutine (pIrp,
                            pCompletion,
                            pContext,
                            TRUE,
                            TRUE,
                            TRUE);
    

    //
    //  Insert the Irp as as the argument in the NextStack location for the IRP
    //


    if (pIrb) 
    {
        NextIrpStack = IoGetNextIrpStackLocation (pIrp);
        NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        NextIrpStack->DeviceObject = pPdo;
        NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
        NextIrpStack->Parameters.Others.Argument1 = pIrb;
    }
    else 
    {
        IoCopyCurrentIrpStackLocationToNext(pIrp);
    }


    //
    //  Reference the PDO and Submit the Irp 
    //  If Ref fails, it means the PDO has been deactivated on another thread
    //
    NtStatus = IoCallDriver (pPdo, pIrp);


    
    

    TRACE( TL_T, TM_Irp, ( "<==nicSubmitIrp, PDO %x, NtStatus %x",
                              pPdo, NtStatus ) );
    
    //
    //  Since we did a IoCallDriver, we have a guarantee that the completion
    //  routine will be called.  Exit gracefully
    //
    
    return NtStatus;

}


NDIS_STATUS
nicSubmitIrp_Synch(
    IN REMOTE_NODE      *pRemoteNode,
    IN PIRP           pIrp,
    IN PIRB           pIrb 
    )

    // Callers need to make sure that no context is set for the Irp
    // as it will be a synchronous call for them
    //

    // We refcount the Pdo block so that the pdo block  will not disappear 
    // during the duration of the IoCallDriver
   
{
    NDIS_EVENT  NdisSynchEvent;
    NTSTATUS NtStatus; 
    NDIS_STATUS NdisStatus;
    BOOLEAN bSuccessful = FALSE;
    BOOLEAN bIsPdoValid = FALSE;
    
    TRACE( TL_T, TM_Irp, ( "==>nicSubmitIrp_Synch, PDO %x", pRemoteNode->pPdo ) );


    ASSERT (pRemoteNode != NULL);
    ASSERT (pRemoteNode->pPdo != NULL);
    
    ASSERT (pIrp != NULL);
    ASSERT (pIrb != NULL)


    do
    {
        //
        // Check to see if Pdo is Valid. We do not care here if the Pdo is being 
        // removed because Vcs may want to submit Irps as part of their cleanup
        // process
        //
        REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);

        if (  REMOTE_NODE_TEST_FLAG (pRemoteNode, PDO_Activated ) 
             && (nicReferenceRemoteNode (pRemoteNode, "nicSubmitIrp_Synch") == TRUE) )
        {
            bIsPdoValid = TRUE;
        }

        REMOTE_NODE_RELEASE_LOCK (pRemoteNode);

        if ( bIsPdoValid == FALSE)
        {
            NtStatus = STATUS_NO_SUCH_DEVICE;
        
            TRACE( TL_A, TM_Irp, ( "==>PDO is NOT Valid, nicSubmitIrp_Synch, PdoCb %x, Pdo %x", pRemoteNode, pRemoteNode->pPdo ) );

            break;  
        }


        //
        // Add a reference to the PDO block so it cannot be removed
        // This reference is decremented at the end of this function
        //
        NdisInitializeEvent (&NdisSynchEvent);

            
        NtStatus = nicSubmitIrp (  pRemoteNode->pPdo,
                                  pIrp,
                                  pIrb,
                                  nicSubmitIrp_SynchComplete,
                                  (PVOID)&NdisSynchEvent); 


    

    } while (FALSE);

    if (NT_SUCCESS (NtStatus) ==TRUE)  // Could also pend
    {
        //
        // Now we need to wait for the event  to complete
        // and return a good status if we do not hit the timeout
        //
        ASSERT (KeGetCurrentIrql()==PASSIVE_LEVEL);

        bSuccessful = NdisWaitEvent (&NdisSynchEvent,0x0fffffff);

        if (bSuccessful == TRUE)
        {
            //
            // We waited successfully. Now lets see how the Irp fared.
            //
            TRACE( TL_V, TM_Irp, ("    Irp Completed Status %x", pIrp->IoStatus.Status) );
            
            NdisStatus = NtStatusToNdisStatus (pIrp->IoStatus.Status);
        }
        else
        {
            NdisStatus = NDIS_STATUS_FAILURE;
        }

    }
    else
    {   //
        // The call to submit Irp failed synvhronously. Presently, the only cause is an 

        NdisStatus = NtStatusToNdisStatus (NtStatus);       

    }

    if (bIsPdoValid  == TRUE)
    {   
        //
        // If this variable is set, it means we have referenced the PDO 
        //
        nicDereferenceRemoteNode (pRemoteNode, "nicSubmitIrp_Synch");
    }
    
    TRACE( TL_T, TM_Irp, ( "<==nicSubmitIrp_Synch, bSuccessful %.2x, Status %x", bSuccessful, NdisStatus) );

    return NdisStatus;

}


NTSTATUS
nicSubmitIrp_SynchComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID           Context   
    )
    // This is the completion routine for functions nicSubmitIrp_synch.
    // It sets the event (int the context) and exits
    //

{
    PNDIS_EVENT pNdisSynchEvent = (PNDIS_EVENT) Context;
    
    TRACE( TL_T, TM_Irp, ( "==>nicSubmitIrp_SynchComplete, PDO %x, pIrp %x, status %x",DeviceObject,pIrp, pIrp->IoStatus.Status  ) );

    NdisSetEvent (pNdisSynchEvent);

    return (STATUS_MORE_PROCESSING_REQUIRED);

}
    


NDIS_STATUS
nicSubmitIrp_LocalHostSynch(
    IN PADAPTERCB       pAdapter,
    IN PIRP             pIrp,
    IN PIRB             pIrb 
    )

    // Callers need to make sure that no context is set for the Irp
    // as it will be a synchronous call for them
    //
    // No Checking 
    //
   
{
    NDIS_EVENT  NdisSynchEvent;
    NTSTATUS NtStatus; 
    NDIS_STATUS NdisStatus;
    BOOLEAN bSuccessful = FALSE;
    BOOLEAN bIsPdoValid = FALSE;
    
    TRACE( TL_T, TM_Irp, ( "==>nicSubmitIrp_LocalHostSynch, PDO %x", pAdapter->pNdisDeviceObject ) );
    TRACE( TL_V, TM_Irp, ( "Current Irql , %.2x", KeGetCurrentIrql()) );


    
    ASSERT (pIrp != NULL);
    ASSERT (pIrb != NULL)

    
    do
    {
        //
        // Check to see if Pdo is Valid. 
        //

        //
        // Add a reference to the PDO block so it cannot be removed
        // This reference is decremented at the end of this function
        //
        // This reference is decrement below

        
        if (ADAPTER_ACTIVE(pAdapter))
        {
            nicReferenceAdapter(pAdapter, "nicSubmitIrp_LocalHostSynch");
            TRACE( TL_V, TM_Irp, ( "Adapter Active pAdapter %x,  ulflags %x", pAdapter , pAdapter->ulFlags) );

            bIsPdoValid = TRUE;
        }
        else
        {
            TRACE( TL_V, TM_Irp, ( "Adapter INActive pAdapter %x,  ulflags %x", pAdapter , pAdapter->ulFlags) );
            bIsPdoValid = FALSE;

        }

        
        if ( bIsPdoValid == FALSE)
        {
            NtStatus = STATUS_NO_SUCH_DEVICE;
        
            TRACE( TL_A, TM_Irp, ( "==>PDO is NOT Valid, nicSubmitIrp_LocalHostSynch, pAdapter %x, Pdo %x", pAdapter , pAdapter->pNdisDeviceObject) );

            break;  
        }


        NdisInitializeEvent (&NdisSynchEvent);

            
        NtStatus = nicSubmitIrp ( pAdapter->pNdisDeviceObject,
                                  pIrp,
                                  pIrb,
                                  nicSubmitIrp_SynchComplete,
                                  (PVOID)&NdisSynchEvent); 


    

    } while (FALSE);

    if (NT_SUCCESS (NtStatus) ==TRUE)  // Could also pend
    {
        //
        // Now we need to wait for the event  to complete
        // and return a good status if we do not hit the timeout
        //

        bSuccessful = NdisWaitEvent (&NdisSynchEvent,WAIT_INFINITE);

        if (bSuccessful == TRUE)
        {
            //
            // We waited successfully. Now lets see how the Irp fared.
            //
            TRACE( TL_V, TM_Irp, ("    Irp Completed Status %x", pIrp->IoStatus.Status) );
            
            NdisStatus = NtStatusToNdisStatus (pIrp->IoStatus.Status);
        }
        else
        {
            NdisStatus = NDIS_STATUS_FAILURE;
        }

    }
    else
    {
        //
        // IoCallDriver failed synchronously
        //
        NdisStatus = NtStatusToNdisStatus (NtStatus);       
    }

    if (bIsPdoValid  == TRUE)
    {
         nicDereferenceAdapter(pAdapter, "nicSubmitIrp_LocalHostSynch");
    }
    TRACE( TL_T, TM_Irp, ( "<==nicSubmitIrp_LocalHostSynch, bSuccessful %.2x, Status %x", bSuccessful, NdisStatus) );

    return NdisStatus;

}


NDIS_STATUS
nicSubmitIrp_PDOSynch(
    IN PDEVICE_OBJECT pPdo,
    IN PIRP             pIrp,
    IN PIRB             pIrb 
    )

    // Callers need to make sure that no context is set for the Irp
    // as it will be a synchronous call for them
    //
    // No Checking 
    //
   
{
    NDIS_EVENT  NdisSynchEvent;
    NTSTATUS NtStatus; 
    NDIS_STATUS NdisStatus;
    BOOLEAN bSuccessful = FALSE;
    BOOLEAN bIsPdoValid = FALSE;
    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Irp, ( "==>nicSubmitIrp_PDOSynch, PDO %x", pPdo) );
    TRACE( TL_V, TM_Irp, ( "Current Irql , %.2x", KeGetCurrentIrql()) );


    
    ASSERT (pIrp != NULL);
    ASSERT (pIrb != NULL)

    //
    // No Checks to see if Pdo is Valid. 
    //


    //
    // Send the Irp to the bus driver
    //
    NdisInitializeEvent (&NdisSynchEvent);

    NtStatus = nicSubmitIrp ( pPdo,
                              pIrp,
                              pIrb,
                              nicSubmitIrp_SynchComplete,
                              (PVOID)&NdisSynchEvent); 





    if (NT_SUCCESS (NtStatus) ==TRUE)  // Could also pend
    {
        //
        // Now we need to wait for the event  to complete
        // and return a good status if we do not hit the timeout
        //
        ASSERT (KeGetCurrentIrql()==PASSIVE_LEVEL);

        bSuccessful = NdisWaitEvent (&NdisSynchEvent,WAIT_INFINITE);

        if (bSuccessful == TRUE)
        {
            //
            // We waited successfully. Now lets see how the Irp fared.
            //
            TRACE( TL_V, TM_Irp, ("    Irp Completed Status %x", pIrp->IoStatus.Status) );
            
            NdisStatus = NtStatusToNdisStatus (pIrp->IoStatus.Status);
        }
        else
        {
            NdisStatus = NDIS_STATUS_FAILURE;
        }

    }
    else
    {
        //
        // IoCallDriver failed synchronously
        //
        NdisStatus = NtStatusToNdisStatus (NtStatus);       
    }

    TRACE( TL_T, TM_Irp, ( "<==nicSubmitIrp_PDOSynch, bSuccessful %.2x, Status %x", bSuccessful, NdisStatus) );
    MATCH_IRQL;
    return NdisStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\debug.h ===
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// debug.h
// IEEE1394 mini-port/call-manager driver
// Debug helper header
//
// 12/27/1998 JosephJ adapted from the l2tp project.


#ifndef _DEBUG_H_
#define _DEBUG_H_



//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

// Memory tags used with NdisAllocateMemoryWithTag to identify allocations
// made by the 1394 nic driver.  Also, several context blocks define a first field
// of 'ulTag' set to these values for ASSERT sanity checking and eased memory
// dump browsing.  Such tags are set to MTAG_FREED just before NdisFreeMemory
// is called. Form: N13a, N13b, etc.
//
#define MTAG_FREED              'a31N'
#define MTAG_ADAPTERCB          'b31N'
#define MTAG_AFCB               'c31N'
#define MTAG_VCCB               'd31N'
#define MTAG_WORKITEM           'e31N'
#define MTAG_TIMERQ             'f31N'
#define MTAG_TIMERQITEM         'g31N'
#define MTAG_PACKETPOOL         'h31N'
#define MTAG_FBUFPOOL           'i31N'
#define MTAG_HBUFPOOL           'j31N'
#define MTAG_INCALL             'k31N'
#define MTAG_UTIL               'l31N'
#define MTAG_RBUF               'r31N'   // Used in Receive Buffer 
#define MTAG_REMOTE_NODE        'p31N'
#define MTAG_CBUF               'n31N' // Used in send buffer
#define MTAG_DEFAULT            'z31N'
#define MTAG_FRAG               'x31N'
#define MTAG_REASSEMBLY         's31N'
#define MTAG_PKTLOG             'y31N'
#define MTAG_FIFO               'w31N'
// Trace levels.
//
#define TL_None 0    // Trace disabled
#define TL_A    0x10 // Alert
#define TL_I    0x18 // Interface (highest level workable for general use)
#define TL_N    0x20 // Normal
#define TL_T    0x25 // Displays Entry and Exit points of all functions
#define TL_V    0x30 // Verbose
#define TL_D    0x40 // Dump packets

// Trace mask bits.
//
#define TM_Cm       0x00000001 // Call manager general
#define TM_Mp       0x00000002 // Mini-port general
#define TM_Send     0x00000004 // Send path
#define TM_Recv     0x00000008 // Receive path
#define TM_Init     0x00000020 // Initialization
#define TM_Misc     0x00000040 // Miscellaneous
#define TM_Bcm      0x00000080 // BCM Algorithm
#define TM_Pkt      0x00000100 // Dump packets
#define TM_Reas     0x00000200 // Reassembly
#define TM_Irp      0x00000400 // Irp Handling and Bus Interface routines
#define TM_Ref      0x00010000 // References
#define TM_Time     0x00020000 // Timer queue
#define TM_Pool     0x00080000 // Buffer and packet pooling
#define TM_Stat     0x00100000 // Call statistics
#define TM_RemRef   0x00200000 // Remote Node Refs
#define TM_Spec     0x01000000 // Special purpose temporary traces
#define TM_Lock     0x02000000 // Lock Acquure / Release
#define TM_Dbg      0x80000000 // Debug corruption checks

#define TM_Wild 0xFFFFFFFF // Everything
#define TM_All  0x7FFFFFFF // Everything except corruption checks
#define TM_Base 0x000000FF // Base only

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16


//-----------------------------------------------------------------------------
// Debug global declarations (defined in debug.c)
//-----------------------------------------------------------------------------

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' and from
// any (TM_*) set(s) present in 'g_ulTraceMask' are displayed.
//
extern ULONG g_ulTraceLevel;
extern ULONG g_ulTraceMask;


//-----------------------------------------------------------------------------
// Debug macros
//-----------------------------------------------------------------------------

#if DBG

// TRACE sends printf style output to the kernel debugger.  Caller indicates a
// "verbosity" level with the 'ulLevel' argument and associates the trace with
// one or more trace sets with the 'ulMask' bit mask argument.  Notice that
// the variable count printf arguments 'Args' must be parenthesized.  For
// example...
//
// A "leave" routine message:
//     TRACE( TL_N, TM_Init, ( "DriverEntry=$%x", status ) );
// An error condition occurred:
//     TRACE( TL_E, TM_Init, ( "NdisMRegisterMiniport=$%x", status ) );
//
//
#define TRACE(ulLevel,ulMask,Args)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        DbgPrint Args;                                         \
        DbgPrint( "\n" );                                      \
    }                                                          \
}

// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                           \
{                                                           \
    if (!(x))                                               \
    {                                                       \
        DbgPrint( "N13: !ASSERT( %s ) at line %d of %s\n",  \
            #x, __LINE__, __FILE__ );                       \
        DbgBreakPoint();                                    \
    }                                                       \
}

// DUMP prints to the kernel debugger a hex dump of 'cb' bytes starting at 'p'
// in groups of 'ul'.  If 'f' is set the address of each line in shown before
// the dump.  DUMPB, DUMPW, and DUMPDW are BYTE, WORD, and DWORD dumps
// respectively.  Note that the multi-byte dumps do not reflect little-endian
// (Intel) byte order.  The 'ulLevel' and 'ulMask' are described for TRACE.
//
#define DUMP(ulLevel,ulMask,p,cb,f,ul)                         \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, f, ul );                          \
    }                                                          \
}

#define DUMPB(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 1 );                           \
    }                                                          \
}

#define DUMPW(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 2 );                           \
    }                                                          \
}

#define DUMPDW(ulLevel,ulMask,p,cb)                            \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 4 );                           \
    }                                                          \
}


// Double-linked list corruption detector.  Runs the test if 'ulMask' is
// enabled, with TM_Dbg a suggested setting.  Shows verbose output if
// 'ulLevel' is at or above the current trace threshold.
//
#define CHECKLIST(ulMask,p,ulLevel)                            \
{                                                              \
    if (g_ulTraceMask & ulMask)                                \
    {                                                          \
        CheckList( p, (BOOLEAN )(ulLevel <= g_ulTraceLevel) ); \
    }                                                          \
}


// DBG_if can be used to put in TRACE/DUMPs conditional on an expression that
// need not be evaluated in non-DBG builds, e.g the statements below generate
// no code in a non-DBG build, but in DBG builds print the TRACE if x<y and
// asserts otherwise.
//
//     DBG_if (x < y)
//         TRACE( TL_N, TM_Misc, ( "x < y" ) );
//     DBG_else
//         ASSERT( FALSE );
//
//
#define DBG_if(x) if (x)
#define DBG_else  else


#else // !DBG

// Debug macros compile out of non-DBG builds.
//
#define TRACE(ulLevel,ulMask,Args)
#undef ASSERT
#define ASSERT(x)
#define DUMP(ulLevel,ulMask,p,cb,f,dw)
#define DUMPB(ulLevel,ulMask,p,cb)
#define DUMPW(ulLevel,ulMask,p,cb)
#define DUMPDW(ulLevel,ulMask,p,cb)
#define CHECKLIST(ulMask,p,ulLevel)
#define DBG_if(x)
#define DBG_else

#endif


//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

#if DBG

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );
#else
#define Dump(p,cb,fAddress,ulGroup)

#endif


VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\globals.c ===
#include <precomp.h>


NIC1394_CHARACTERISTICS Nic1394Characteristics =
{
    5,
    1,
    0,
    NicRegisterEnum1394,
    NicDeregisterEnum1394,
    nicAddRemoteNode,
    nicRemoveRemoteNode
};

ENUM1394_REGISTER_DRIVER_HANDLER    NdisEnum1394RegisterDriver = NULL;
ENUM1394_DEREGISTER_DRIVER_HANDLER  NdisEnum1394DeregisterDriver = NULL;
ENUM1394_REGISTER_ADAPTER_HANDLER   NdisEnum1394RegisterAdapter = NULL;
ENUM1394_DEREGISTER_ADAPTER_HANDLER NdisEnum1394DeregisterAdapter = NULL;

PCALLBACK_OBJECT                Nic1394CallbackObject = NULL;
PVOID                           Nic1394CallbackRegisterationHandle = NULL;


ULONG g_IsochTag = ISOCH_TAG;
ULONGLONG g_ullOne = 1;


LONG g_ulMedium ;
UINT NumRecvFifos = NUM_RECV_FIFO_FIRST_PHASE ; 
UINT NicSends;
UINT BusSends;
UINT NicSendCompletes;
UINT BusSendCompletes;


const PUCHAR pnic1394DriverDescription = "NET IP/1394 Miniport";
const USHORT nic1394DriverGeneration = 0;

BOOLEAN g_ulNicDumpPacket  = FALSE;
ULONG g_ulDumpEthPacket = 0;


// Debug counts of client oddities that should not be happening.
//
ULONG g_ulUnexpectedInCallCompletes = 0;
ULONG g_ulCallsNotClosable = 0;
BOOLEAN g_AdapterFreed = FALSE;


ULONG AdapterNum = 0;

#ifdef INTEROP

const unsigned char Net1394ConfigRom[48] = {
    0x00, 0x04, 0xad, 0xeb, 0x12, 0x00, 0x00, 0x5e, 
    0x13, 0x00, 0x00, 0x01, 0x17, 0x7b, 0xb0, 0xcf, 
    0x81, 0x00, 0x00, 0x01, 0x00, 0x06, 0x38, 0x91, 
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x09, 
    0x4e, 0x00, 0x49, 0x00, 0x43, 0x00, 0x31, 0x00, 
    0x33, 0x00, 0x39, 0x00, 0x34, 0x00, 0x00, 0x00
};




#else
const unsigned char Net1394ConfigRom[48] = {
        0x00, 0x04, 0xa8, 0x36, 0x12, 0x00, 0x00, 0x5e,
        0x13, 0x00, 0x00, 0x01, 0x82, 0x7b, 0xb0, 0xcf,
        0x81, 0x00, 0x00, 0x01, 0x00, 0x06, 0x38, 0x91,
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x09,
        0x4e, 0x00, 0x49, 0x00, 0x43, 0x00, 0x31, 0x00,
        0x33, 0x00, 0x39, 0x00, 0x34, 0x00, 0x00, 0x00
};
#endif  // INTEROP



//
// Histograms to collect data
//
STAT_BUCKET     SendStats;
STAT_BUCKET     RcvStats;

// Stats
ULONG           nicMaxRcv;
ULONG           nicMaxSend;
ULONG           BusFailure;
ULONG           MallocFailure;
ULONG           IsochOverwrite;
ULONG           RcvTimerCount;      // Number of times timer has fired.
ULONG           SendTimerCount;     // Number of times timer has fired.
ULONG           TotSends;
ULONG           TotRecvs;
ULONG           MaxIndicatedFifos;
ULONG           MdlsAllocated[NoMoreCodePaths];
ULONG           MdlsFreed[NoMoreCodePaths];
ULONG           NdisBufferAllocated[NoMoreCodePaths];
ULONG           NdisBufferFreed[NoMoreCodePaths];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\driver.c ===
//--------------------------------------------------------//
//                                                        // 
//                                                        //   
//   ZwLoadDriver is locally declared because if I try    //
//   and include ZwApi.h there are conflicts with         //
//   structures defined in wdm.h                          //
//                                                        //
//                                                        //
//--------------------------------------------------------//


#include "precomp.h"


NDIS_STRING ArpName  = NDIS_STRING_CONST("\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ARP1394");

//----------------------------------------------------------//
//      Local Prototypes                                    //
//----------------------------------------------------------//

NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadDriver(
    IN PUNICODE_STRING DriverServiceName
    );

VOID
nicEthStartArpWorkItem (
    PNDIS_WORK_ITEM pWorkItem, 
    IN PVOID Context
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

VOID
nicSetupIoctlToLoadArp (
    IN PADAPTERCB pAdapter,
    IN PARP_INFO pArpInfo
    );

VOID
nicSetupAndSendIoctlToArp (
    IN PADAPTERCB pAdapter,
    IN PARP_INFO pArpInfo
    );
    
//----------------------------------------------------------//
//      Functions                                           //
//----------------------------------------------------------//



VOID
nicSendIoctlToArp(
    PARP1394_IOCTL_COMMAND pCmd
)
/*++

Routine Description:

Send the start Ioctl to the ARp module

Arguments:


Return Value:


--*/

{
    BOOLEAN                 fRet = FALSE;
    PUCHAR                  pc;
    HANDLE                  DeviceHandle;
    ULONG                   BytesReturned;
    OBJECT_ATTRIBUTES       Atts;
    NDIS_STRING             strArp1394 = NDIS_STRING_CONST ("\\Device\\Arp1394");
    HANDLE                  Handle;
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    IO_STATUS_BLOCK         ioStatusBlock;

    do
    {   
    
        InitializeObjectAttributes(&Atts,
                                   &strArp1394,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

                 
       status = ZwCreateFile(&Handle,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &Atts,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN_IF,
                             0,
                             NULL,
                             0);

        if (!NT_SUCCESS(status))
        {
            Handle = NULL;
            break;
        }

        //
        // Submit the request to the forwarder
        //

            
        status = ZwDeviceIoControlFile(
                          Handle,
                          NULL,
                          NULL,
                          NULL,
                          &ioStatusBlock,
                          ARP_IOCTL_CLIENT_OPERATION,
                          pCmd,
                          sizeof(*pCmd),
                          pCmd,
                          sizeof(*pCmd));


                              
        //
        // Close the device.
        //
        
        ZwClose(Handle);

        if (!NT_SUCCESS(status))
        {
            ASSERT (status == STATUS_SUCCESS);
            break;
        }

    } while (FALSE);



}


VOID
nicLoadArpDriver ()
/*++

Routine Description:

Load the arp module

Arguments:


Return Value:


--*/
{
    ZwLoadDriver(&ArpName);

    TRACE (TL_T, TM_Mp,("Loaded the Arp Module %p\n", &ArpName));

}





VOID
nicGetAdapterName (
    IN PADAPTERCB pAdapter,
    IN WCHAR* pAdapterName, 
    IN ULONG  BufferSize,
    IN PULONG  pSizeReturned 
    )
/*++

Routine Description:

Get the Adapter Name From NDIS

Arguments:


Return Value:


--*/

{

    //
    // The BufferSize always has to be greater than SizeReturned
    //

    NdisMoveMemory (pAdapterName, 
                   &pAdapter->AdapterName[0],
                   pAdapter->AdapterNameSize * sizeof (WCHAR));


    if (pSizeReturned  != NULL)
    {

        *pSizeReturned = pAdapter->AdapterNameSize ;
    }
}



VOID
nicSetupIoctlToArp (
    IN PADAPTERCB pAdapter,
    IN PARP_INFO pArpInfo
    )
    /*++

Routine Description:

    Sets up the Ioctl to be sent to the Arp module

Arguments:


Return Value:


--*/

{

    PARP1394_IOCTL_ETHERNET_NOTIFICATION pEthCmd = &pAdapter->ArpIoctl.EthernetNotification;


    ADAPTER_ACQUIRE_LOCK(pAdapter);

    if (BindArp == pArpInfo->Action || LoadArp == pArpInfo->Action)
    {
        // BRIDGE START
        pEthCmd->Hdr.Op     =  ARP1394_IOCTL_OP_ETHERNET_START_EMULATION;
        pAdapter->fIsArpStarted  = TRUE;
        ADAPTER_SET_FLAG(pAdapter,fADAPTER_BridgeMode);
    }


    if (UnloadArp == pArpInfo->Action || UnloadArpNoRequest== pArpInfo->Action)
    {
        // BRIDGE STOP
        pEthCmd->Hdr.Op     = ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION;
        pAdapter->fIsArpStarted  = FALSE;
        ADAPTER_CLEAR_FLAG(pAdapter,fADAPTER_BridgeMode);

    }


    ADAPTER_RELEASE_LOCK(pAdapter);



}   



VOID
nicSetupAndSendIoctlToArp (
    IN PADAPTERCB pAdapter,
    PARP_INFO pArpInfo    )
/*++

Routine Description:

    Sets up an Ioctl and Sends it to the Arp module

Arguments:


Return Value:


--*/
{   

    
    nicSetupIoctlToArp (pAdapter, pArpInfo);


    nicSendIoctlToArp(&pAdapter->ArpIoctl);

}








VOID
nicSendNotificationToArp(
    IN PADAPTERCB pAdapter,
    IN PARP_INFO  pArpInfo 
    )
/*++

Routine Description:

    Send the notification to the arp module

Arguments:


Return Value:


--*/

{
    PNDIS_REQUEST   pRequest = NULL;
    ULONG           Start = FALSE;
    NDIS_STATUS     NdisStatus = NDIS_STATUS_SUCCESS;
  
    ARP1394_IOCTL_COMMAND ArpIoctl;

    //
    // Extract our variables from the workitem
    //
  
    TRACE (TL_T, TM_Mp, ("==>nicEthStartArpWorkItem Start  %x", Start ));

    

    do
    {
        //
        // First complete the request, so that protocols can start sending new 
        // requests . Notes  11/30/00
        // 
        if (pArpInfo->Action == LoadArp || pArpInfo->Action == UnloadArp)
        {
            //
            // in either of these cases, it is a request that has initiated the action.
            // 
            // 
            if (pRequest == NULL)
            {
                //
                // This came in through our CL SetInformation Handler
                //
                NdisMSetInformationComplete (pAdapter->MiniportAdapterHandle, NdisStatus );
            }
            else
            {
                NdisMCoRequestComplete ( NdisStatus ,
                                         pAdapter->MiniportAdapterHandle,
                                         pRequest);
                                         
            }


        }

        

        //
        // "arp13 -bstart adapter"
        // If we are asked to Load Arp, we verify that the arp hasn't 
        // already been started
        //

        
        if (pArpInfo->Action == LoadArp &&  pAdapter->fIsArpStarted == FALSE)// we are turning ON
        {
            //
            // Load the driver
            //
            nicLoadArpDriver ();
            //
            // Send it an IOCTL to open the nic1394 adapter
            //

        }
        
        
        if (pArpInfo->Action == BindArp && pAdapter->fIsArpStarted  == FALSE)
        {
            //
            // if the arp module has not been started and we are asking to bind,
            // then it means that an unload was ahead of us in the queue and
            // unbound nic1394 from arp1394. This thread can exit.
            //
            break;

        }


        //
        // Send the Ioctl to the Arp module
        //
        
        nicSetupAndSendIoctlToArp (pAdapter, pArpInfo);
        
    
        
    } while (FALSE);
    
    //
    // end of function
    //
    FREE_NONPAGED (pArpInfo);

    TRACE (TL_T, TM_Mp, ("<==nicEthStartArpWorkItem fLoadArp %x", pArpInfo->Action));

    return;


}



VOID
nicProcessNotificationForArp(
    IN PNDIS_WORK_ITEM pWorkItem,   
    IN PVOID Context 
    )
/*++

Routine Description:

    This function extracts the notification from the workitem and 
    sends the Load/Unload/ BInd notfication to ARp 1394
    
Arguments:


Return Value:


--*/
{

    PADAPTERCB      pAdapter = (PADAPTERCB) Context;

    ADAPTER_ACQUIRE_LOCK (pAdapter);
    

    //
    // Empty the Queue indicating as many packets as possible
    //
    while (IsListEmpty(&pAdapter->LoadArp.Queue)==FALSE)
    {
        PARP_INFO               pArpInfo;
        PLIST_ENTRY             pLink;
        NDIS_STATUS             NdisStatus;

        pAdapter->LoadArp.PktsInQueue--;

        pLink = RemoveHeadList(&pAdapter->LoadArp.Queue);

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Extract the send context
        //
        if (pLink != NULL)
        {
            pArpInfo = CONTAINING_RECORD(
                                               pLink,
                                               ARP_INFO,
                                               Link);

            nicSendNotificationToArp(pAdapter, pArpInfo);
        }        
        ADAPTER_ACQUIRE_LOCK (pAdapter);

    }
    
    //
    // clear the flag
    //

    ASSERT (pAdapter->LoadArp.PktsInQueue==0);
    ASSERT (IsListEmpty(&pAdapter->LoadArp.Queue));

    pAdapter->LoadArp.bTimerAlreadySet = FALSE;


    ADAPTER_RELEASE_LOCK (pAdapter);

    NdisInterlockedDecrement (&pAdapter->OutstandingWorkItems);
    

}


VOID
nicInitializeLoadArpStruct(
    PADAPTERCB pAdapter
    )
/*++

Routine Description:

    This function initializes the LoadArp struct in _ADAPTERCB
    
Arguments:


Return Value:


--*/

{

    if (pAdapter->LoadArp.bInitialized == FALSE)
    {
        
        PARP1394_IOCTL_ETHERNET_NOTIFICATION pEthCmd = &pAdapter->ArpIoctl.EthernetNotification;
        ULONG Size;

        NdisZeroMemory (&pAdapter->LoadArp, sizeof(pAdapter->LoadArp));
        InitializeListHead(&pAdapter->LoadArp.Queue); 
        pAdapter->LoadArp.bInitialized  = TRUE;
       
        NdisInitializeWorkItem (&pAdapter->LoadArp.WorkItem,
                                nicProcessNotificationForArp,
                                pAdapter);



        nicGetAdapterName (pAdapter,
                           pEthCmd->AdapterName, 
                           sizeof(pEthCmd->AdapterName)-sizeof(WCHAR),
                           &Size );

        pEthCmd->AdapterName[Size/2]=0;


        pEthCmd->Hdr.Version    = ARP1394_IOCTL_VERSION;


    }
}
    


NDIS_STATUS
nicQueueRequestToArp(
    PADAPTERCB pAdapter, 
    ARP_ACTION Action,
    PNDIS_REQUEST pRequest
    )
/*++

Routine Description:

    This function inserts a request to load/unload or bind the Arp module
    If there is no timer servicing the queue
    then it queues a timer to dequeue the packet in Global Event's context


Arguments:

    Self explanatory 
    
Return Value:
    Success - if inserted into the the queue

--*/
    
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fSetWorkItem = FALSE;
    PARP_INFO pArpInfo;

    do
    {

        pArpInfo = ALLOC_NONPAGED(sizeof (ARP_INFO), MTAG_DEFAULT); 

        if (pArpInfo == NULL)
        {
            break;
        }
        
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // Find out if this thread needs to fire the timer
        //

        pArpInfo->Action = Action;
        pArpInfo->pRequest = pRequest;

        if (pAdapter->LoadArp.bTimerAlreadySet == FALSE)
        {
            fSetWorkItem = TRUE;
            pAdapter->LoadArp.bTimerAlreadySet = TRUE;

        }
                
        InsertTailList(
                &pAdapter->LoadArp.Queue,
                &pArpInfo->Link
                );
        pAdapter->LoadArp.PktsInQueue++;

        
        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Now queue the timer
        //
        
        if (fSetWorkItem== TRUE)
        {
            PNDIS_WORK_ITEM pWorkItem;
            //
            //  Initialize the timer
            //
            pWorkItem = &pAdapter->LoadArp.WorkItem;      

            
            TRACE( TL_V, TM_Recv, ( "   Set Timer "));
            
                                  
            NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

            NdisScheduleWorkItem (pWorkItem);


        }


        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    ASSERT (Status == NDIS_STATUS_SUCCESS);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\md5.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// md5.h
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port routines
//
// 08/08/2000 ADube created.  
// 
// Purpose: Create a unique MAC address from 1394 EUID 
//
// Derived from derived from the RSA Data  Security, 
// Inc. MD5 Message-Digest Algorithm 
//

/*
  been defined with C compiler flags.
 */
#ifndef PROTOTYPES
#define PROTOTYPES 1
#endif

/* POINTER defines a generic pointer type */
typedef unsigned char *POINTER;

/* UINT2 defines a two byte word */
typedef unsigned short int UINT2;

/* UINT4 defines a four byte word */
typedef unsigned long int UINT4;

/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.
If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
  returns an empty list.
 */
#if PROTOTYPES
#define PROTO_LIST(list) list
#else
#define PROTO_LIST(list) ()
#endif


/* MD5 context. */

typedef struct _MD5_CTX{
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
} MD5_CTX, MD_CTX;



void MD5Init PROTO_LIST ((MD5_CTX *));
void MD5Update PROTO_LIST
  ((MD5_CTX *, unsigned char *, unsigned int));
void MD5Final PROTO_LIST ((unsigned char [16], MD5_CTX *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\makefile.inc ===
clean: 
    del nicwmi.h $(O)\nicwmi.bmf

nicwmi.h: $(O)\nicwmi.bmf
    wmimofck -hnicwmi.h  $(O)\nicwmi.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\md5.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// md5.c
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port routines
//
// 08/08/2000 ADube created.  
// 
// Purpose: Create a unique MAC address from 1394 EUID 
//
// Derived from derived from the RSA Data  Security, 
// Inc. MD5 Message-Digest Algorithm 
//

#include <precomp.h>
#pragma hdrstop

#include "md5.h"

// Constants for MD5Transform routine.

#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void MD5Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));
static void Encode PROTO_LIST
  ((unsigned char *, UINT4 *, unsigned int));
static void Decode PROTO_LIST
  ((UINT4 *, unsigned char *, unsigned int));
static void MD5_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));
static void MD5_memset PROTO_LIST ((POINTER, int, unsigned int));

static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// F, G, H and I are basic MD5 functions.
 
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

// ROTATE_LEFT rotates x left n bits.
 
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

// FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
// Rotation is separate from addition to prevent recomputation.
 
#define FF(a, b, c, d, x, s, ac) { \
 (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) { \
 (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) { \
 (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) { \
 (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }

// MD5 initialization. Begins an MD5 operation, writing a new context.
 
void 
MD5Init (
    MD5_CTX *context// context 
    )
{
  context->count[0] = context->count[1] = 0;
  // Load magic initialization constants.

  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}

// MD5 block update operation. Continues an MD5 message-digest
//  operation, processing another message block, and updating the
//  context.
 
void 
MD5Update (
    MD5_CTX *context,   // context 
    unsigned char *input,   // input block 
    unsigned int inputLen   // length of input block 
    )
{
    unsigned int i, index, partLen;

    // Compute number of bytes mod 64 
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);

    // Update number of bits 
    if ((context->count[0] += ((UINT4)inputLen << 3))
        < ((UINT4)inputLen << 3))
    {        
        context->count[1]++;
    }
    
    context->count[1] += ((UINT4)inputLen >> 29);

    partLen = 64 - index;

    // Transform as many times as possible.

    if (inputLen >= partLen) 
    {
        MD5_memcpy   ((POINTER)&context->buffer[index], 
                        (POINTER)input, 
                        partLen);

        MD5Transform (context->state, context->buffer);

        for (i = partLen; i + 63 < inputLen; i += 64)
        {
            MD5Transform (context->state, &input[i]);
        }

        index = 0;
    }
    else
    {
        i = 0;
    }
    // Buffer remaining input 
    MD5_memcpy
    ((POINTER)&context->buffer[index], (POINTER)&input[i],
    inputLen-i);
}

// MD5 finalization. Ends an MD5 message-digest operation, writing the
// the message digest and zeroizing the context.
 
void 
MD5Final (
    unsigned char digest[16],                         // message digest 
    MD5_CTX *context
    )                                       // context 
{
  unsigned char bits[8];
  unsigned int index, padLen;

  // Save number of bits 
  Encode (bits, context->count, 8);

  // Pad out to 56 mod 64.

  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);

  // Append length (before padding) 
  MD5Update (context, bits, 8);

  // Store state in digest 
  Encode (digest, context->state, 6);

  // Zeroize sensitive information.

  MD5_memset ((POINTER)context, 0, sizeof (*context));
}

// MD5 basic transformation. Transforms state based on block.
 
static 
void 
MD5Transform (
    UINT4 state[4],
    unsigned char block[64]
    )
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];

  Decode (x, block, 64);

  // Round 1 
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); // 1 
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); // 2 
  FF (c, d, a, b, x[ 2], S13, 0x242070db); // 3 
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); // 4 
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); // 5 
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); // 6 
  FF (c, d, a, b, x[ 6], S13, 0xa8304613); // 7 
  FF (b, c, d, a, x[ 7], S14, 0xfd469501); // 8 
  FF (a, b, c, d, x[ 8], S11, 0x698098d8); // 9 
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); // 10 
  FF (c, d, a, b, x[10], S13, 0xffff5bb1); // 11 
  FF (b, c, d, a, x[11], S14, 0x895cd7be); // 12 
  FF (a, b, c, d, x[12], S11, 0x6b901122); // 13 
  FF (d, a, b, c, x[13], S12, 0xfd987193); // 14 
  FF (c, d, a, b, x[14], S13, 0xa679438e); // 15 
  FF (b, c, d, a, x[15], S14, 0x49b40821); // 16 

 // Round 2 
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); // 17 
  GG (d, a, b, c, x[ 6], S22, 0xc040b340); // 18 
  GG (c, d, a, b, x[11], S23, 0x265e5a51); // 19 
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); // 20 
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); // 21 
  GG (d, a, b, c, x[10], S22,  0x2441453); // 22 
  GG (c, d, a, b, x[15], S23, 0xd8a1e681); // 23 
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); // 24 
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); // 25 
  GG (d, a, b, c, x[14], S22, 0xc33707d6); // 26 
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); // 27 
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); // 28 
  GG (a, b, c, d, x[13], S21, 0xa9e3e905); // 29 
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); // 30 
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); // 31 
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); // 32 

  // Round 3 
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); // 33 
  HH (d, a, b, c, x[ 8], S32, 0x8771f681); // 34 
  HH (c, d, a, b, x[11], S33, 0x6d9d6122); // 35 
  HH (b, c, d, a, x[14], S34, 0xfde5380c); // 36 
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); // 37 
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); // 38 
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); // 39 
  HH (b, c, d, a, x[10], S34, 0xbebfbc70); // 40 
  HH (a, b, c, d, x[13], S31, 0x289b7ec6); // 41 
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); // 42 
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); // 43 
  HH (b, c, d, a, x[ 6], S34,  0x4881d05); // 44 
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); // 45 
  HH (d, a, b, c, x[12], S32, 0xe6db99e5); // 46 
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); // 47 
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); // 48 

  // Round 4 
  II (a, b, c, d, x[ 0], S41, 0xf4292244); // 49 
  II (d, a, b, c, x[ 7], S42, 0x432aff97); // 50 
  II (c, d, a, b, x[14], S43, 0xab9423a7); // 51 
  II (b, c, d, a, x[ 5], S44, 0xfc93a039); // 52 
  II (a, b, c, d, x[12], S41, 0x655b59c3); // 53 
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); // 54 
  II (c, d, a, b, x[10], S43, 0xffeff47d); // 55 
  II (b, c, d, a, x[ 1], S44, 0x85845dd1); // 56 
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); // 57 
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); // 58 
  II (c, d, a, b, x[ 6], S43, 0xa3014314); // 59 
  II (b, c, d, a, x[13], S44, 0x4e0811a1); // 60 
  II (a, b, c, d, x[ 4], S41, 0xf7537e82); // 61 
  II (d, a, b, c, x[11], S42, 0xbd3af235); // 62 
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); // 63 
  II (b, c, d, a, x[ 9], S44, 0xeb86d391); // 64 

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;

  // Zeroize sensitive information.

  MD5_memset ((POINTER)x, 0, sizeof (x));
}

// Encodes input (UINT4) into output (unsigned char). Assumes len is
// a multiple of 4.
 
static 
void 
Encode (
    unsigned char *output,
    UINT4 *input,
    unsigned int len
    )
{
    unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4) 
    {
        output[j] = (unsigned char)(input[i] & 0xff);
        output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
        output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
        output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
    }
}

// Decodes input (unsigned char) into output (UINT4). Assumes len is
// a multiple of 4.
 
static 
void 
Decode (
    UINT4 *output,
    unsigned char *input,
    unsigned int len
    )
{
  unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4)
    {
    output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
                (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
    }
}

// Note: Replace "for loop" with standard memcpy if possible.
 

static 
void 
MD5_memcpy (
    POINTER output,
    POINTER input,
    unsigned int len
    )
{
    unsigned int i;

    for (i = 0; i < len; i++)
    { 
        output[i] = input[i];
    }
}

// Note: Replace "for loop" with standard memset if possible.
 
static 
void 
MD5_memset (
    POINTER output,
    int value,
    unsigned int len
    )
{
    unsigned int i;

    for (i = 0; i < len; i++)
    {   
        ((char *)output)[i] = (char)value;
    }
}


#define ETH_IS_MULTICAST(Address) \
        (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x01))


VOID
nicGetMacAddressFromEuid (
    UINT64 *pEuid,
    MAC_ADDRESS *pMacAddr
    )
{

   MD_CTX context;
    unsigned char digest[6];
    unsigned int len = 8;

    MD5Init (&context);
    MD5Update (&context, (unsigned char*)pEuid, len);
    MD5Final (digest, &context);

    NdisMoveMemory (pMacAddr, digest, 6);

    // Set the locally administered bit 
    // and clear the multicast bit.

    //
    // randomize the returned Mac Address
    // by xor ing the address with a random 
    // 0xf22f617c91e0 (a random number)
    //
    //pMacAddr->addr[0] ^= 0x00;

    pMacAddr->addr[0] |= 0x2;
    pMacAddr->addr[0] &= 0xf2;
    pMacAddr->addr[1] ^= 0x2f;
    pMacAddr->addr[2] ^= 0x61;
    pMacAddr->addr[3] ^= 0x7c;
    pMacAddr->addr[4] ^= 0x91;
    pMacAddr->addr[5] ^= 0x30;

    
}


        
// Digests a string and prints the result.
 
VOID
nicGetFakeMacAddress(
    UINT64 *pEuid, 
    MAC_ADDRESS *pMacAddr
    )
{

	nicGetMacAddressFromEuid (pEuid, pMacAddr);
    



    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\irp.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// irp.h
//
// IEEE1394 mini-port/call-manager driver
//
// Delaration for Routines that issue the Irps to the 1394 Bus driver 
//
// 06/20/1999 ADube Created, adapted from the l2tp sources.
//


//----------------------------------------------------------------------------
//      1 3 9 4 B U S   I N T E R F A C E   F U N C T I O N S
//----------------------------------------------------------------------------



NDIS_STATUS
nicAllocateAddressRange_Synch (
    IN PADAPTERCB pAdapter,
    IN PMDL pMdl,
    IN ULONG fulFlags,
    IN ULONG nLength,
    IN ULONG MaxSegmentSize,
    IN ULONG fulAccessType,
    IN ULONG fulNotificationOptions,
    IN PVOID Callback,
    IN PVOID Context,
    IN ADDRESS_OFFSET  Required1394Offset,
    IN PSLIST_HEADER   FifoSListHead,
    IN PKSPIN_LOCK     FifoSpinLock,
    OUT PULONG pAddressesReturned,  
    OUT PADDRESS_RANGE  p1394AddressRange,
    OUT PHANDLE phAddressRange
    );


NDIS_STATUS
nicAsyncStream (
    PREMOTE_NODE  pRemoteNodePdoCb,
    ULONG           nNumberOfBytesToStream, // Bytes to stream
    ULONG           fulFlags,               // Flags pertinent to stream
    PMDL            pMdl,                  // Source buffer
    ULONG           ulTag,                  // Tag
    ULONG           nChannel,               // Channel
    ULONG           ulSynch,                // Sy
    ULONG           Reserved,               // Reserved for future use
    UCHAR           nSpeed
    );



NDIS_STATUS
nicAsyncRead_Synch(
    PREMOTE_NODE    pRemoteNode,
    IO_ADDRESS      DestinationAddress,     
    ULONG         nNumberOfBytesToRead,
    ULONG         nBlockSize,
    ULONG         fulFlags,
    PMDL          Mdl,
    ULONG         ulGeneration,
    OUT NTSTATUS *pNtStatus
    );




NDIS_STATUS
nicAsyncWrite_Synch(
    PREMOTE_NODE    pRemoteNode,
    IO_ADDRESS      DestinationAddress,     // Address to write to
    ULONG           nNumberOfBytesToWrite,  // Bytes to write
    ULONG           nBlockSize,             // Block size of write
    ULONG           fulFlags,               // Flags pertinent to write
    PMDL            Mdl,                    // Destination buffer
    ULONG           ulGeneration,           // Generation as known by driver
    OUT NTSTATUS   *pNtStatus               // pointer to NTSTatus returned by the IRP  
    );


NDIS_STATUS
nicFreeAddressRange(
    IN PADAPTERCB pAdapter,
    IN ULONG nAddressesToFree,
    IN PADDRESS_RANGE p1394AddressRange,
    IN PHANDLE phAddressRange
    );

    

NDIS_STATUS
nicBusReset (
    IN PADAPTERCB pAdapter,
    IN OUT ULONG fulFlags
    );


NDIS_STATUS
nicBusResetNotification (
    IN PADAPTERCB pAdapter,
    IN ULONG fulFlags,
    IN PBUS_BUS_RESET_NOTIFICATION pResetRoutine,
    IN PVOID pResetContext
    );



NDIS_STATUS
nicFreeChannel(
    IN PADAPTERCB pAdapter,
    IN ULONG nChannel
    );


NDIS_STATUS
nicGet1394AddressFromDeviceObject( 
    IN PDEVICE_OBJECT pPdo,
    IN OUT NODE_ADDRESS *pNodeAddress,
    IN ULONG fulFlags
    );


NDIS_STATUS
nicGet1394AddressOfRemoteNode( 
    IN PREMOTE_NODE pRemoteNode,
    IN OUT NODE_ADDRESS *pNodeAddress,
    IN ULONG fulFlags
    );


NDIS_STATUS
nicGetGenerationCount(
    IN PADAPTERCB       pAdapter,
    IN OUT PULONG    GenerationCount
    );


NDIS_STATUS
nicIsochAllocateBandwidth(
    IN PREMOTE_NODE pRemoteNodePdoCb,
    IN ULONG MaxBytesPerFrameRequested, 
    IN ULONG SpeedRequested,
    OUT PHANDLE phBandwidth,
    OUT PULONG  pBytesPerFrameAvailable,
    OUT PULONG  pSpeedSelected
    );

    
NDIS_STATUS
nicAllocateChannel (
    IN PADAPTERCB pAdapter,
    IN ULONG pChannel,
    OUT PULARGE_INTEGER pChannelsAvailable OPTIONAL
    );
    

NDIS_STATUS
nicQueryChannelMap (
    IN PADAPTERCB pAdapter,
    OUT PULARGE_INTEGER pChannelsAvailable 
    );


NDIS_STATUS
nicIsochAllocateResources (
    IN PADAPTERCB       pAdapter,
    IN ULONG            fulSpeed,              
    IN ULONG            fulFlags,               
    IN ULONG            nChannel,              
    IN ULONG            nMaxBytesPerFrame,      
    IN ULONG            nNumberOfBuffers,
    IN ULONG            nMaxBufferSize,         
    IN ULONG            nQuadletsToStrip,        
    IN ULARGE_INTEGER   uliChannelMask,     
    IN OUT PHANDLE      hResource              
    );

 
NDIS_STATUS
nicIsochAttachBuffers (
    IN PADAPTERCB           pAdapter,
    HANDLE                  hResource,
    ULONG                   nNumberOfDescriptors,
    PISOCH_DESCRIPTOR       pIsochDescriptor
    );


NDIS_STATUS
nicIsochFreeResources(
    IN PADAPTERCB pAdapter,
    IN HANDLE hResource
    );



NDIS_STATUS
nicIsochFreeBandwidth(
    IN REMOTE_NODE *pRemoteNode,
    IN HANDLE hBandwidth
    );



NDIS_STATUS
nicIsochListen (
    IN PADAPTERCB pAdapter,
    HANDLE        hResource,
    ULONG         fulFlags,
    CYCLE_TIME    StartTime
    );

    

NDIS_STATUS
nicGetMaxSpeedBetweenDevices (
    PADAPTERCB pAdapter,
    UINT   NumOfRemoteNodes,
    PDEVICE_OBJECT pArrayDestinationPDO[64],
    PULONG pSpeed
    );
    

NDIS_STATUS
nicIsochDetachBuffers (
    IN PADAPTERCB           pAdapter,
    IN HANDLE               hResource,
    IN ULONG                nNumberOfDescriptors,
    PISOCH_DESCRIPTOR    pIsochDescriptor
    );




NDIS_STATUS
nicIsochStop (
    IN PADAPTERCB pAdapter,
    IN HANDLE  hResource
    );


NDIS_STATUS
nicIsochModifyStreamProperties (
    PADAPTERCB pAdapter,
    NDIS_HANDLE hResource,
    ULARGE_INTEGER ullChannelMap,
    ULONG ulSpeed);

    
NDIS_STATUS
nicGetLocalHostCSRTopologyMap(
    IN PADAPTERCB pAdapter,
    IN PULONG pLength,
    IN PVOID pBuffer
    );


NDIS_STATUS
nicAsyncLock(
    PREMOTE_NODE    pRemoteNode,
    IO_ADDRESS      DestinationAddress,     // Address to lock to
    ULONG           nNumberOfArgBytes,      // Bytes in Arguments
    ULONG           nNumberOfDataBytes,     // Bytes in DataValues
    ULONG           fulTransactionType,     // Lock transaction type
    ULONG           Arguments[2],           // Arguments used in Lock
    ULONG           DataValues[2],          // Data values
    PVOID           pBuffer,                // Destination buffer (virtual address)
    ULONG           ulGeneration           // Generation as known by driver
    );



NDIS_STATUS
nicSetLocalHostPropertiesCRom (
    IN PADAPTERCB pAdapter,
    IN PUCHAR pConfigRom,
    IN ULONG Length,
    IN ULONG Flags,
    IN OUT PHANDLE phCromData,
    IN OUT PMDL *ppConfigRomMdl
    );

NDIS_STATUS
nicGetLocalHostUniqueId(
    IN PADAPTERCB pAdapter,
    IN OUT PGET_LOCAL_HOST_INFO1 pUid
    );
    

NDIS_STATUS
nicGetConfigRom(
    IN PDEVICE_OBJECT pPdo,
    OUT PVOID *ppCrom
    );



NDIS_STATUS
nicGetLocalHostConfigRom(
    IN PADAPTERCB pAdapter,
    OUT  PVOID *ppCRom
    );


NDIS_STATUS
nicGetReadWriteCapLocalHost(
    IN PADAPTERCB pAdapter,
    PGET_LOCAL_HOST_INFO2 pReadWriteCaps
    );
    
NTSTATUS 
nicSubmitIrp(
   IN PDEVICE_OBJECT    pPDO,
   IN PIRP              pIrp,
   IN PIRB              pIrb,
   IN PIO_COMPLETION_ROUTINE  pCompletion,
   IN PVOID             pContext
   );


NDIS_STATUS
nicSubmitIrp_Synch(
    IN REMOTE_NODE      *pRemoteNode,
    IN PIRP           pIrp,
    IN PIRB           pIrb 
    );

NTSTATUS
nicSubmitIrp_SynchComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID           Context   
    );

    
NDIS_STATUS
nicSubmitIrp_LocalHostSynch(
    IN PADAPTERCB       pAdapter,
    IN PIRP             pIrp,
    IN PIRB             pIrb 
    );
    

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
nicAsyncStreamDebugSpew (
    PIRB pIrb
    );

VOID
nicFreeAddressRangeDebugSpew(
    IN PIRB pIrb 
    );

VOID
nicIsochAllocateResourcesDebugSpew(
    IN PIRB pIrb
    );

NTSTATUS
nicSubmitIrp_DummyComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID           Context   
    );



NDIS_STATUS
nicSubmitIrp_PDOSynch(
    IN PDEVICE_OBJECT pPdo,
    IN PIRP             pIrp,
    IN PIRB             pIrb 
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\nicwmi.h ===
#ifndef _nicwmi_h_
#define _nicwmi_h_



// in order to make our custom oids hopefully somewhat unique
// we will use 0xFF (indicating implementation specific OID)
//               A0 (first byte of non zero intel unique identifier)
//               C9 (second byte of non zero intel unique identifier) - used 00 for now??
//               XX (the custom OID number - providing 255 possible custom oids)
#define OID_IP1394_QUERY_UID            0xFF00C901
#define OID_IP1394_QUERY_STATS          0xFF00C902
#define OID_IP1394_QUERY_REMOTE_UID     0xFF00C903






// IP1394_QueryArrayOID - E100BExampleQueryArrayOID
// An Array to query (reads the UID of the local host)

/*
#define IP1394_QueryArrayOIDGuid\
    { 0x734b44a9,0x74b6,0x41e6, { 0xbb, 0xe7, 0xa1, 0xf4, 0xed, 0x8c, 0xea, 0x45} }
*/


//
// Query the EUID of the local host
//

#define IP1394_QueryArrayOIDGuid\
    { 0x734b44a9,  0x74b6,  0x41e6,  0xbb, 0xe7, 0xa1, 0xf4, 0xed, 0x8c, 0xea, 0x45 }

    
#define IP1394_QueryStatsGuid   \
    { 0xee2ebfc6, 0x944d, 0x426b, 0xb1, 0x87, 0x82, 0xfa, 0xc1, 0x7d, 0x7d, 0xee }


#define IP1394_QueryRemoteUIDGuid   \
    {0x6a3e8063, 0x767d, 0x4531, 0x96, 0x2b, 0xf6, 0x83, 0xdf, 0x1a, 0xa3, 0xa1}



    static const NDIS_GUID GuidList[] =
    { 
        { // {734b44a9-74b6-41e6-bbe7-a1f4ed8cea45} UI64 query
            IP1394_QueryArrayOIDGuid,
            OID_IP1394_QUERY_UID,
            sizeof(UINT64), // size is size of each element in the array
            (fNDIS_GUID_TO_OID)
        },

        {
            IP1394_QueryRemoteUIDGuid,  
            OID_IP1394_QUERY_REMOTE_UID,
            sizeof(UINT32),
            (fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY)

        },
        {
            IP1394_QueryStatsGuid,
            OID_IP1394_QUERY_STATS, 
            sizeof (UINT32),   // size of each element in the array
            (fNDIS_GUID_TO_OID | fNDIS_GUID_ARRAY)


        },


    };

#define MAX_NUM_REMOTE_NODES 5  // temp max

typedef struct _REMOTE_UID
{
    UINT32 Uid[2*MAX_NUM_REMOTE_NODES];
    
} REMOTE_UID , *PREMOTE_UID;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\mp.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// mp.h
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port routines - header file
//
// 06/20/99 ADube - Created - Declaration for miniport routines
//

//-------------------------------------------------------------------
//          G L O B A L    D E C L A R A T I O N S
//-------------------------------------------------------------------

#ifdef PSDEBUG

// List of all allocated PAYLOADSENT contexts and the lock that protects the
// list.  (for debug purposes only)
//
NDIS_SPIN_LOCK g_lockDebugPs;
LIST_ENTRY g_listDebugPs;

#endif


#define DEFAULT_TOPOLOGY_MAP_LENGTH 0x400


#define FIVE_SECONDS_IN_MILLSECONDS 2000  /*Incorrect value during debugging */




//
// Used to generate a MAC address amd for informational use
//
extern ULONG AdapterNum ;
extern BOOLEAN g_AdapterFreed;

// Call statistics totals for all calls since loading, calls and the lock
// protecting access to them.  For this global only, the 'ullCallUp' field is
// the number of calls recorded, rather than a time.
//
CALLSTATS g_stats;
NDIS_SPIN_LOCK g_lockStats;



// Global driver list lock
//
NDIS_SPIN_LOCK g_DriverLock;

// Global adapter list, serialized by g_DriverLock;
//
LIST_ENTRY g_AdapterList;


//-----------------------------------------------------------------------------
//          N D I S     M I N I P O R T     H A N D L E R S 
//-----------------------------------------------------------------------------


NDIS_STATUS
NicMpInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext
    );

VOID
NicMpHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
NicMpReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext
    );

VOID
NicMpReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet
    );

NDIS_STATUS
NicMpQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    );

NDIS_STATUS
NicMpSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    );

NDIS_STATUS
NicMpCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    );

NDIS_STATUS
NicMpCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext
    );


VOID
NicMpCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets
    );

NDIS_STATUS
NicMpCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest
    );


BOOLEAN
CheckForHang(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );



//-----------------------------------------------------------------------------
// prototypes for miniport.c (alphabetically)
//-----------------------------------------------------------------------------

NDIS_STATUS
nicAllocateAddressRangeOnNewPdo (
    IN PADAPTERCB pAdapter,
    IN PREMOTE_NODE     pRemoteNode 
    );


VOID
nicResetNotificationCallback (                
    IN PVOID pContext               
    );

VOID
nicBusResetWorkItem(
    NDIS_WORK_ITEM* pResetWorkItem,     
    IN PVOID Context 
    );

VOID
nicFreeAdapter(
    IN ADAPTERCB* pAdapter 
    );


NDIS_STATUS
nicFreeRemoteNode(
    IN REMOTE_NODE *pRemoteNode 
    );


NDIS_STATUS
nicGetRegistrySettings(
    IN NDIS_HANDLE WrapperConfigurationContext,
    IN ADAPTERCB * pAdapter
    );



NDIS_STATUS
nicQueryInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN OUT PNDIS_REQUEST NdisRequest 
    );


NDIS_STATUS
nicSetInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN OUT PNDIS_REQUEST NdisRequest
    );


VOID
nicIssueBusReset (
    PADAPTERCB pAdapter,
    ULONG Flags
    );


VOID 
nicResetReallocateChannels (
    IN PADAPTERCB pAdapter
    );  

VOID
nicResetRestartBCM (
    IN PADAPTERCB pAdapter
    );

VOID
nicReallocateChannels (
    IN PNDIS_WORK_ITEM pWorkItem,   
    IN PVOID Context 
    );



VOID
nicUpdateLocalHostSpeed (
    IN PADAPTERCB pAdapter
    );


VOID 
nicInitializeAllEvents (
    IN PADAPTERCB pAdapter
    );




VOID
nicAddRemoteNodeChannelVc (
    IN PADAPTERCB pAdapter, 
    IN PREMOTE_NODE pRemoteNode
    );


VOID
nicNoRemoteNodesLeft (
    IN PADAPTERCB pAdapter
    );
    
VOID
nicDeleteLookasideList (
    IN OUT PNIC_NPAGED_LOOKASIDE_LIST pLookasideList
    );



VOID
nicInitializeAdapterLookasideLists (
    IN PADAPTERCB pAdapter
    );



VOID
nicInitializeLookasideList(
    IN OUT PNIC_NPAGED_LOOKASIDE_LIST pLookasideList,
    ULONG Size,
    ULONG Tag,
    USHORT Depth
    );

VOID
nicDeleteAdapterLookasideLists (
    IN PADAPTERCB pAdapter
    );


VOID
nicFillRemoteNodeTable (
    IN PADAPTERCB pAdapter
    );  



VOID
ReassemblyTimerFunction (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );



extern const PUCHAR pnic1394DriverDescription;
extern const USHORT nic1394DriverGeneration; 
extern const unsigned char Net1394ConfigRom[48];

NDIS_STATUS 
nicAddIP1394ToConfigRom (
    IN PADAPTERCB pAdapter
    );

VOID
nicUpdateRemoteNodeTable (
    IN PADAPTERCB pAdapter
    );

NTSTATUS
nicUpdateRemoteNodeCompletion (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext 
    );

NDIS_STATUS
nicMCmRegisterAddressFamily (
    IN PADAPTERCB pAdapter
    );

VOID
nicFreeReassembliesOnRemoteNode (
    IN PREMOTE_NODE pRemoteNode, 
    IN PLIST_ENTRY pReassemblyList
    );

VOID
nicFreeReassembliesOnRemoteNode (
    IN PREMOTE_NODE pRemoteNode,
    PLIST_ENTRY pToBeFreedList
    );
    
UCHAR
nicGetMaxRecFromBytes(
    IN ULONG ByteSize
    );

UCHAR
nicGetMaxRecFromSpeed(
    IN ULONG Scode
    );

PREMOTE_NODE
nicGetRemoteNodeFromTable (
    ULONG NodeNumber,
    PADAPTERCB pAdapter
    );




//
//  ConnectionLess Handlers
//
NDIS_STATUS 
NicEthQueryInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
);





NDIS_STATUS
NicEthSetInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    NDIS_OID            Oid,
    PVOID               InformationBuffer,
    ULONG               InformationBufferLength,
    PULONG              BytesRead,
    PULONG              BytesNeeded
    );



VOID
NicMpSendPackets(
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN PPNDIS_PACKET            PacketArray,
    IN UINT                     NumberOfPackets
    );



NDIS_STATUS
nicFillNicInfo (
    IN PADAPTERCB pAdapter, 
    PNIC1394_NICINFO pInNicInfo,
    PNIC1394_NICINFO pOutNicInfo
    );


NDIS_STATUS
nicFillBusInfo(
    IN      PADAPTERCB pAdapter, 
    IN  OUT PNIC1394_BUSINFO pBi
    );


NDIS_STATUS
nicFillChannelInfo(
    IN      PADAPTERCB pAdapter, 
    IN OUT  PNIC1394_CHANNELINFO pCi
    );
    

NDIS_STATUS
nicFillRemoteNodeInfo(
    IN      PADAPTERCB pAdapter, 
    IN OUT  PNIC1394_REMOTENODEINFO pRni
    );



VOID
nicCopyPacketStats (
    NIC1394_PACKET_STATS* pStats,
    UINT    TotNdisPackets,     // Total number of NDIS packets sent/indicated
    UINT    NdisPacketsFailures,// Number of NDIS packets failed/discarded
    UINT    TotBusPackets,      // Total number of BUS-level reads/writes
    UINT    BusPacketFailures   // Number of BUS-level failures(sends)/discards(recv)
    );

VOID
nicAddPacketStats(
    NIC1394_PACKET_STATS* pStats,
    UINT    TotNdisPackets,     // Total number of NDIS packets sent/indicated
    UINT    NdisPacketsFailures,// Number of NDIS packets failed/discarded
    UINT    TotBusPackets,      // Total number of BUS-level reads/writes
    UINT    BusPacketFailures   // Number of BUS-level failures(sends)/discards(recv)
    );


NDIS_STATUS
nicResetStats (
    IN      PADAPTERCB pAdapter, 
    PNIC1394_RESETSTATS     pResetStats 
    );

VOID
nicInformProtocolsOfReset(
    IN PADAPTERCB pAdapter
    );


VOID
nicUpdateSpeedInAllVCs (
    PADAPTERCB pAdapter,
    ULONG Speed
    );

VOID
nicUpdateRemoteNodeCaps(
    PADAPTERCB          pAdapter
);

VOID
nicQueryInformationWorkItem(
    IN PNDIS_WORK_ITEM pWorkItem,   
    IN PVOID Context 
);


VOID
nicIndicateStatusTimer(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );

VOID
nicMIndicateStatus(
    IN  PADAPTERCB              pAdapter ,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );


NDIS_STATUS
nicInitSerializedStatusStruct(
    PADAPTERCB pAdapter
    );


VOID
nicDeInitSerializedStatusStruct(
    PADAPTERCB pAdapter
    );


NDIS_STATUS
nicEthLoadArpModule (
    IN PADAPTERCB pAdapter, 
    IN ULONG StartArp,
    IN PNDIS_REQUEST pRequest
    );

    

VOID
nicGetAdapterName (
    IN PADAPTERCB pAdapter,
    IN WCHAR *pAdapterName, 
    IN ULONG  BufferSize,
    IN PULONG  SizeReturned 
    );


NDIS_STATUS
nicQueueRequestToArp(
    PADAPTERCB pAdapter, 
    ARP_ACTION Action,
    PNDIS_REQUEST pRequest
    );


NTSTATUS 
nicSubmitIrp(
   IN PDEVICE_OBJECT    pPdo,
   IN PIRP              pIrp,
   IN PIRB              pIrb,
   IN PIO_COMPLETION_ROUTINE  pCompletion,
   IN PVOID             pContext
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\precomp.h ===
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// precomp.h
// IEEE 1394 NDIS mini-port/call-manager driver
//
//  Precompiled common header.
//
// 12/28/1998 JosephJ
//
//

#include <ccdefs.h>
#include <ndis.h>
#include <ndistapi.h>
#include <1394.h>
#include <ndis1394.h>
#include <nic1394.h>
#include <nicarp.h>
#include "a13ioctl.h"
#include "nicwmi.h"
#include "debug.h"
#include "pktlog.h"
#include "priv.h"
#include "mp.h"
#include "cm.h"
#include "send.h"
#include "receive.h"
#include "irp.h"
#include "bcm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\mp.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// mp.c
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port routines
//
// 12/28/1998 JosephJ Created, 
//

#include <precomp.h>
#include "mp.h"
#pragma hdrstop



//-----------------------------------------------------------------------------
// Data used in processing requests
//-----------------------------------------------------------------------------

NDIS_OID SupportedOids[] = 
{
    OID_GEN_CO_SUPPORTED_LIST,
    OID_GEN_CO_HARDWARE_STATUS,
    OID_GEN_CO_MEDIA_SUPPORTED,
    OID_GEN_CO_MEDIA_IN_USE,
    OID_GEN_CO_LINK_SPEED,
    OID_GEN_CO_VENDOR_ID,
    OID_GEN_CO_VENDOR_DESCRIPTION,
    OID_GEN_CO_DRIVER_VERSION,
    OID_GEN_CO_PROTOCOL_OPTIONS,
    OID_GEN_CO_MEDIA_CONNECT_STATUS,
    OID_GEN_CO_MAC_OPTIONS,
    OID_GEN_CO_VENDOR_DRIVER_VERSION,
    OID_GEN_CO_MINIMUM_LINK_SPEED,
    OID_GEN_CO_XMIT_PDUS_OK, 
    OID_GEN_CO_RCV_PDUS_OK,
    OID_GEN_CO_XMIT_PDUS_ERROR,
    OID_GEN_CO_RCV_PDUS_ERROR,
    OID_GEN_CO_RCV_PDUS_NO_BUFFER,
    OID_1394_LOCAL_NODE_INFO,
    OID_1394_VC_INFO,
    OID_1394_NICINFO,
    OID_1394_IP1394_CONNECT_STATUS,
    OID_1394_ENTER_BRIDGE_MODE,
    OID_1394_EXIT_BRIDGE_MODE,
    OID_1394_ISSUE_BUS_RESET,
    OID_802_3_CURRENT_ADDRESS,
    
#ifdef _ETHERNET_

    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_PHYSICAL_MEDIUM,
    

#endif

    OID_PNP_QUERY_POWER,
    OID_PNP_SET_POWER,
    OID_IP1394_QUERY_UID,
    OID_IP1394_QUERY_STATS,
    OID_IP1394_QUERY_REMOTE_UID,
    OID_1394_QUERY_EUID_NODE_MAP
};


//-----------------------------------------------------------------------------
// Locally used function prototypes
//-----------------------------------------------------------------------------
NDIS_STATUS
nicAllocateLoopbackPacketPool (
    IN PADAPTERCB pAdapter
    );

VOID
nicFreeLoopbackPacketPool (
    IN PADAPTERCB pAdapter
    );

VOID
nicLoopbackPacket(
    IN VCCB* pVc,
    IN PNDIS_PACKET pPacket
    );

VOID
nicQueryEuidNodeMacMap (
    IN PADAPTERCB pAdapter,
    IN PNDIS_REQUEST pRequest
    );

VOID
nicRemoveRemoteNodeFromNodeTable(
    IN PNODE_TABLE pNodeTable,
    IN PREMOTE_NODE pRemoteNode
    );

NDIS_STATUS
MPSetPower (
    IN PADAPTERCB pAdapter,
    IN NET_DEVICE_POWER_STATE DeviceState
    );


//-----------------------------------------------------------------------------
// Mini-port handlers
//-----------------------------------------------------------------------------

NDIS_STATUS
NicMpInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext 
    )

    // Standard 'MiniportInitialize' routine called by NDIS to initialize a
    // new WAN adapter.  See DDK doc.  The driver will receive no requests
    // until this initialization has completed.
    //
    // After a resume from suspend, multiple miniports will be initialized in a 
    // non -serialized manner. Be prepared.
    //
{
    NDIS_STATUS         NdisStatus;
    NTSTATUS            NtStatus;
    PADAPTERCB          pAdapter= NULL;
    PDEVICE_OBJECT      pNdisDeviceObject = NULL;
    PDEVICE_OBJECT      p1394DeviceObject = NULL;
    LARGE_INTEGER       LocalHostUniqueId;   
    REMOTE_NODE         *p1394RemoteNodePdoCb = NULL;
    UINT64              u64LocalHostUniqueId =0;
    BOOLEAN             FreeAdapter = FALSE;
    BOOLEAN             DequeueAdapter = FALSE;
    ULONG               Generation;
    ULONG               InitStatus;
    //
    // This is the order with which the initialize routine is done. 
    //
    enum    
    {
        NoState,
        AllocatedAdapter,
        AdapterQueued,
        InitializedEvents,
        InitializedBcr,
        RegisteredResetCallback,
        AddedConfigRom,
        RegisteredEnumerator,
        InitializedLookasideList,
        InitializedPktLog,
        InitializedRcvThread,
        InitializedSendThread,
        InitializedReassembly,
        InitializedLoopbackPool

    }; 

    STORE_CURRENT_IRQL

    TIMESTAMP_ENTRY("==>IntializeHandler");
    TIMESTAMP_INITIALIZE();

    TRACE( TL_T, TM_Init, ( "==>NicMpInitialize" ) );

    InitStatus = NoState;
    NdisStatus = *OpenErrorStatus = NDIS_STATUS_SUCCESS;

    // Find the medium index in the array of media, looking for the only one
    // we support, 'NdisMedium1394'.
    //
    {
        UINT i;

        for (i = 0; i < MediumArraySize; ++i)
        {
            if (MediumArray[ i ] == g_ulMedium )
            {
                break;
            }
        }

        if (i >= MediumArraySize)
        {
            TRACE( TL_A, TM_Init, ( "medium?" ) );
            return NDIS_STATUS_FAILURE;
        }

        *SelectedMediumIndex = i;
    }

    // Allocate and zero a control block for the new adapter.
    //
    pAdapter = ALLOC_NONPAGED( sizeof(ADAPTERCB), MTAG_ADAPTERCB );
    TRACE( TL_N, TM_Init, ( "Acb=$%p", pAdapter ) );
    if (!pAdapter)
    {
        return NDIS_STATUS_RESOURCES;
    }

    
    FreeAdapter = TRUE;
    InitStatus = AllocatedAdapter;

    NdisZeroMemory (pAdapter, sizeof(*pAdapter) );

    // Add a reference that will eventually be removed by an NDIS call to
    // the nicFreeAdapter handler.
    //
    nicReferenceAdapter (pAdapter, "MpInitialize" );

    // Set a marker for easier memory dump browsing and future assertions.
    //
    pAdapter->ulTag = MTAG_ADAPTERCB;

    // Save the NDIS handle associated with this adapter for use in future
    // NdisXxx calls.
    //
    pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;

    // Initialize the adapter-wide lock.
    //
    NdisAllocateSpinLock( &pAdapter->lock );

    // Initialize the various lists of top-level resources.
    //
    pAdapter->HardwareStatus = NdisHardwareStatusInitializing;

    //
    // The enumerator and bus1394 have asked us to load, therefore media 
    // should be connected
    //
    pAdapter->MediaConnectStatus = NdisMediaStateDisconnected;
    
    InitializeListHead( &pAdapter->AFList );
    InitializeListHead( &pAdapter->PDOList );
    InitializeListHead( &pAdapter->BroadcastChannel.VcList );


    //
    // Default initialization values
    //
    pAdapter->Speed = SPEED_FLAGS_400;
    pAdapter->SpeedMbps = 4 * 1000000;
    pAdapter->SCode = SCODE_400_RATE;


    do
    {

        // Read this adapter's registry settings.
        //
        NdisStatus = nicGetRegistrySettings(
                        WrapperConfigurationContext,
                        pAdapter
                        );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }


 
        // Inform NDIS of the attributes of our adapter.  Set the
        // 'MiniportAdapterContext' returned to us by NDIS when it calls our
        // handlers to the address of our adapter control block.  Turn off
        // hardware oriented timeouts.
        //
        NdisMSetAttributesEx(
            MiniportAdapterHandle,
            (NDIS_HANDLE)pAdapter,
            (UINT)0,
            NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT | NDIS_ATTRIBUTE_IGNORE_TOKEN_RING_ERRORS |
                NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND | NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT | 
                NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK,
            NdisInterfaceInternal );

        NdisStatus  = nicMCmRegisterAddressFamily (pAdapter);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // If we fail, Let the next entrant try the same thing
            //
            break;
        }
        
        ADAPTER_SET_FLAG (pAdapter,fADAPTER_RegisteredAF); 

        //
        // Insert into global list of adapters. So we will be ready to receive notifications
        // from the enumerator
        //
        NdisAcquireSpinLock ( &g_DriverLock);

        InsertHeadList (&g_AdapterList, &pAdapter->linkAdapter);
        
        DequeueAdapter = TRUE;
        InitStatus = AdapterQueued;

        NdisReleaseSpinLock (&g_DriverLock);

        pAdapter->HardwareStatus = NdisHardwareStatusReady;
        
        //
        // Set up linkages. Get the PDO for the device from Ndis
        //
        NdisMGetDeviceProperty( MiniportAdapterHandle, 
                               &pNdisDeviceObject, 
                               NULL, 
                               NULL, 
                               NULL,
                               NULL );

        ASSERT (pNdisDeviceObject != NULL);

        pAdapter->Generation  = 0;

        //
        // Update data structure with the local hosts VDO
        //

        pAdapter->pNdisDeviceObject = pNdisDeviceObject;        

        TRACE( TL_I, TM_Mp, ( "  LocalHost VDO %x", pNdisDeviceObject) );

        nicInitializeAllEvents (pAdapter);

        InitStatus = InitializedEvents;
        
        //
        //  Initialize the BCM so it is ready to handle Resets
        //
        NdisStatus = nicInitializeBroadcastChannelRegister (pAdapter); 

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK( TM_Init, ( "nicMpInitialize - nicInitializeBroadcastChannelRegister  ") );
        }

        InitStatus = InitializedBcr;

        //
        // Initialize the generation count , reset callback and config rom
        //
        NdisStatus = nicGetGenerationCount (pAdapter, &Generation);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Init, ("Initialize Handler - nicGetGeneration Failed" ) );            
        }
        
        pAdapter->Generation = Generation;
        //
        // request notification of bus resets
        //
        NdisStatus = nicBusResetNotification (pAdapter,
                                              REGISTER_NOTIFICATION_ROUTINE,
                                              nicResetNotificationCallback,
                                              pAdapter);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Init, ("Initialize Handler - nicBusResetNotification  Failed" ) );            
        }

        InitStatus = RegisteredResetCallback;

        //
        // add ip/1394 to the config rom
        //
        NdisStatus = nicAddIP1394ToConfigRom (pAdapter);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Init, ("Initialize Handler - nicAddIP1394ToConfigRom  Failed" ) );            
        }


        InitStatus = AddedConfigRom;

        //
        // Lets find out our MaxRec
        //
        NdisStatus = nicGetReadWriteCapLocalHost(pAdapter, &pAdapter->ReadWriteCaps);

        pAdapter->MaxRec = nicGetMaxRecFromBytes(pAdapter->ReadWriteCaps.MaxAsyncWriteRequest);

        TRACE (TL_V, TM_Mp,  (" MaxRec %x\n", pAdapter->MaxRec ) );

        nicUpdateLocalHostSpeed (pAdapter);
        
        TRACE (TL_V, TM_Mp,  (" SCode %x", pAdapter->SCode) );
        
        //
        // Bus Reset - used to kick off the BCM algorithm
        //

        nicIssueBusReset (pAdapter,BUS_RESET_FLAGS_FORCE_ROOT );

#if QUEUED_PACKETS

        nicInitSerializedStatusStruct (pAdapter); // cannot fail
#endif

        //
        // Register this adapter with the enumerator. 
        //
        if (NdisEnum1394DeregisterAdapter != NULL)
        {
        
            NtStatus = NdisEnum1394RegisterAdapter((PVOID)pAdapter,
                                                   pNdisDeviceObject,
                                                   &pAdapter->EnumAdapterHandle,
                                                   &LocalHostUniqueId);
            if (NtStatus != STATUS_SUCCESS)
            {
                
                ADAPTER_SET_FLAG(pAdapter, fADAPTER_FailedRegisteration);

                //
                // Don;t Bail Out
                //
                
                //NdisStatus = NDIS_STATUS_FAILURE;
                BREAK( TM_Init, ( "nicMpInitialize  -  NdisEnum1394RegisterAdapter FAILED ") );
                
            }
            else
            {
                ADAPTER_SET_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator);
                InitStatus = RegisteredEnumerator;

            }


        }
        else
        {
            GET_LOCAL_HOST_INFO1  Uid;
            //
            // Enum is not loaded get the Unique Id
            //
            NdisStatus = nicGetLocalHostUniqueId (pAdapter, 
                                                 &Uid );                            
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK( TM_Init, ( " nicMpInitialize  - nicGetLocalHostUniqueId  FAILED ") );
            }
            else
            {
                LocalHostUniqueId = Uid.UniqueId;
            }
        }
       
        //
        // Validate the Local Adapter's Unique Id
        //
        if (LocalHostUniqueId.QuadPart == (UINT64)(0) )
        {
            nicWriteErrorLog (pAdapter,NDIS_ERROR_CODE_HARDWARE_FAILURE, NIC_ERROR_CODE_INVALID_UNIQUE_ID_0);
            NdisStatus = NDIS_STATUS_FAILURE;
            break;            
        }
        if (LocalHostUniqueId.QuadPart == (UINT64)(-1) )
        {
            nicWriteErrorLog (pAdapter,NDIS_ERROR_CODE_HARDWARE_FAILURE,NIC_ERROR_CODE_INVALID_UNIQUE_ID_FF);
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

#ifdef PKT_LOG

        nic1394AllocPktLog (pAdapter);

        if (pAdapter->pPktLog == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            BREAK (TM_Init, ("nicMpInitialize - Could not allocate packetlog" ) );
        }

        nic1394InitPktLog(pAdapter->pPktLog);

        InitStatus = InitializedPktLog;

#endif

#if QUEUED_PACKETS

        NdisStatus = nicInitSerializedReceiveStruct(pAdapter);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Init, ("nicMpInitialize - nicInitSerializedReceiveStruct  FAILED" ) );
        }
        InitStatus = InitializedRcvThread;

        NdisStatus = nicInitSerializedSendStruct(pAdapter);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Init, ("nicMpInitialize - nicInitSerializedSendStruct FAILED" ) );
        }
        InitStatus = InitializedSendThread;

        //
        // Init Stats
        //
        nicInitQueueStats();
        nicInitTrackFailure();

        pAdapter->AdaptStats.ulResetTime = nicGetSystemTime() ;

#endif

        //
        // Initialize the reassembly timers
        //
        nicInitSerializedReassemblyStruct(pAdapter); // cannot fail

        InitStatus = InitializedReassembly;

        //
        // This swap is done so that the byte reported by the bus driver matches that 
        // which is used in the notification of add nodes, remove nodes and make call
        //
        LocalHostUniqueId.LowPart = SWAPBYTES_ULONG (LocalHostUniqueId.LowPart );
        LocalHostUniqueId.HighPart = SWAPBYTES_ULONG (LocalHostUniqueId.HighPart );
        
        u64LocalHostUniqueId = LocalHostUniqueId.QuadPart;

            
        pAdapter->UniqueId = u64LocalHostUniqueId;
        pAdapter->HardwareStatus = NdisHardwareStatusReady;

        //
        // Get Our local Fake Mac address
        //
        nicGetFakeMacAddress (&u64LocalHostUniqueId, &pAdapter->MacAddressEth);

        TRACE( TL_I, TM_Init, ( "NdisDeviceObject %.8x, p1394DeviceObject %.8x", pNdisDeviceObject, p1394DeviceObject) );

        
        //
        // Initialize the lookaside lists
        //
        nicInitializeAdapterLookasideLists (pAdapter);
        InitStatus = InitializedLookasideList;
        


        //
        //  Initialize the remote node table 
        //
        
        nicUpdateRemoteNodeTable (pAdapter);

        // 
        // initialize the gasp header
        //
        nicMakeGaspHeader (pAdapter, &pAdapter->GaspHeader);


        //
        // Assign a MAC address to this Adapter
        //
#ifdef _ETHERNET_

        {
            AdapterNum++;
            //
            //  generate a locally 
            //  administered address by manipulating the first two bytes.
            //

        }

#endif

        //
        // Allocate the loopback pools
        //
        NdisStatus= nicAllocateLoopbackPacketPool (pAdapter);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Init, ("nicMpInitialize - nicAllocateLoopbackPacketPool  FAILED" ) );
        }
        InitStatus = InitializedLoopbackPool;

        ADAPTER_SET_FLAG (pAdapter, fADAPTER_DoStatusIndications);

        pAdapter->PowerState = NetDeviceStateD0;



    }  while (FALSE);


    
    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        ULONG FailureStatus  = NDIS_STATUS_FAILURE; 
        // Failed, so undo whatever portion succeeded.
        //
        TRACE( TL_I, TM_Init, ( "NicMpInitialize FAILING InitStatus %x", InitStatus) );

        ADAPTER_SET_FLAG (pAdapter, fADAPTER_FailedInit);
        ADAPTER_CLEAR_FLAG (pAdapter, fADAPTER_DoStatusIndications);

        //
        // This is in reverse order of the init and there are no breaks here.
        // The implicit assumption is that if the code failed at a certain point
        // it will have to undo whatever was previously allocated
        //

        switch (InitStatus)
        {
            case InitializedLoopbackPool:
            {
                nicFreeLoopbackPacketPool(pAdapter);
                FALL_THROUGH;
            }
            case InitializedLookasideList:
            {
                nicDeleteAdapterLookasideLists(pAdapter);
                FALL_THROUGH;
            }

            case InitializedReassembly:
            {
                nicDeInitSerializedReassmblyStruct(pAdapter);
                FALL_THROUGH;

            }

            case InitializedSendThread:
            {
#if QUEUED_PACKETS
                nicDeInitSerializedSendStruct(pAdapter);
#endif
                FALL_THROUGH;
            }
            case InitializedRcvThread:
            {
#if QUEUED_PACKETS
                nicDeInitSerializedReceiveStruct(pAdapter);

                nicDeInitSerializedStatusStruct (pAdapter);
#endif


                FALL_THROUGH;
            }
            case InitializedPktLog:
            {

#ifdef PKT_LOG
                nic1394DeallocPktLog(pAdapter);
#endif
                FALL_THROUGH
            }
            
            case RegisteredEnumerator:
            {
                //
                // If we registered with the enumerator , then deregister
                //
                if ((NdisEnum1394DeregisterAdapter != NULL) &&
                    ADAPTER_TEST_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator))
                {       
                    //
                    // deregister this adapter with enumerator
                    //
                    TRACE( TL_V, TM_Init, ( "  Deregistering with the Enum %x", pAdapter->EnumAdapterHandle) );

                    NdisEnum1394DeregisterAdapter(pAdapter->EnumAdapterHandle);
        
                    ADAPTER_CLEAR_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator | fADAPTER_FailedRegisteration);
                }   

                FALL_THROUGH
            }

            case AddedConfigRom:
            {
                TRACE( TL_V, TM_Init, ( "  removing config rom handle %x", pAdapter->hCromData ) );

                
                FailureStatus = nicSetLocalHostPropertiesCRom(pAdapter,
                                                              (PUCHAR)&Net1394ConfigRom,
                                                               sizeof(Net1394ConfigRom),
                                                               SLHP_FLAG_REMOVE_CROM_DATA,
                                                               &pAdapter->hCromData,
                                                               &pAdapter->pConfigRomMdl);
    
    
                FALL_THROUGH

            }

            case RegisteredResetCallback:
            {
                TRACE( TL_V, TM_Init, ( "  Deregistering reset callback ") );

                //
                // Deregeister the reset callback
                //
                FailureStatus = nicBusResetNotification (pAdapter,
                                                         DEREGISTER_NOTIFICATION_ROUTINE,
                                                         nicResetNotificationCallback,
                                                         pAdapter) ;
                                         

                FALL_THROUGH



            }

            case InitializedBcr:
            {
                TRACE( TL_V, TM_Init, ( "  Freeing BCR ") );

                nicFreeBroadcastChannelRegister(pAdapter);

                TRACE (TL_V, TM_Mp, ("About to Wait for Free AddressRange" ) );
                NdisWaitEvent (&pAdapter->BCRData.BCRFreeAddressRange.NdisEvent, WAIT_INFINITE);
                TRACE (TL_V, TM_Mp, ("Wait Completed for Free AddressRange\n" ) );


                FALL_THROUGH

            }

            case InitializedEvents:
            {
                //
                // Do nothing
                //
                FALL_THROUGH
            }

            case AdapterQueued:
            {
                NdisAcquireSpinLock ( &g_DriverLock);
                nicRemoveEntryList (&pAdapter->linkAdapter);
                NdisReleaseSpinLock (&g_DriverLock);

                FALL_THROUGH
            }

            case AllocatedAdapter:
            {
                nicDereferenceAdapter(pAdapter, "NicMpInitialize");
                
                break;
            }

            default :
            {
                ASSERT (0);
            }
        }
    }


    TRACE( TL_T, TM_Init, ( "<==NicMpInitialize=$%08x", NdisStatus ) );
    MATCH_IRQL;

    TRACE( TL_I, TM_Init, ( "NicMpInitialize Status %x, pAdapter %p", NdisStatus,pAdapter  ) );

    TIMESTAMP_EXIT("<==IntializeHandler");

    return NdisStatus;
}


VOID
NicMpHalt(  
    IN NDIS_HANDLE MiniportAdapterContext 
    )

    // Standard 'MiniportHalt' routine called by NDIS to deallocate all
    // resources attached to the adapter.  NDIS does not make any other calls
    // for this mini-port adapter during or after this call.  NDIS will not
    // call this routine when packets indicated as received have not been
    // returned, or when any VC is created and known to NDIS.  Runs at PASSIVE
    // IRQL.
    //
{
    PADAPTERCB pAdapter = (PADAPTERCB) MiniportAdapterContext;
    BOOLEAN TimerCancelled = FALSE;
    STORE_CURRENT_IRQL

    TIMESTAMP_ENTRY("==>Haltandler");

    TRACE( TL_T, TM_Mp, ( "==>NicMpHalt" ) );
    

    TRACE( TL_I, TM_Mp, ( "  Adapter %x Halted", pAdapter ) );

    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return;
    }

    ADAPTER_CLEAR_FLAG (pAdapter, fADAPTER_DoStatusIndications);

    //
    // Unload the Arp module if necessary
    //
    if (pAdapter->fIsArpStarted == TRUE)
    {
        nicQueueRequestToArp(pAdapter, UnloadArpNoRequest, NULL);
    }

    ADAPTER_SET_FLAG (pAdapter, fADAPTER_Halting);

#if QUEUED_PACKETS

    nicDeInitSerializedStatusStruct(pAdapter);

    nicDeInitSerializedSendStruct(pAdapter);

    nicDeInitSerializedReceiveStruct(pAdapter);


#endif

    //
    // Stop the reassembly timer
    //
    nicDeInitSerializedReassmblyStruct(pAdapter);

    //
    // Deallocating the packet log
    //
#ifdef PKT_LOG
    nic1394DeallocPktLog(pAdapter);
#endif
    //
    //  remove the config rom
    //
    nicSetLocalHostPropertiesCRom(pAdapter,
                                  (PUCHAR)&Net1394ConfigRom,
                                  sizeof(Net1394ConfigRom),
                                  SLHP_FLAG_REMOVE_CROM_DATA,
                                  &pAdapter->hCromData,
                                  &pAdapter->pConfigRomMdl);

    pAdapter->hCromData = NULL;

    //
    // free the apapter packet pool
    
    nicFreeLoopbackPacketPool(pAdapter);

    //
    // Free the BCR
    //
    nicFreeBroadcastChannelRegister(pAdapter);

    TRACE (TL_V, TM_Mp,  ("About to Wait for Free AddressRange\n" ) );
    NdisWaitEvent (&pAdapter->BCRData.BCRFreeAddressRange.NdisEvent, WAIT_INFINITE);
    TRACE (TL_V, TM_Mp, ("Wait Completed for Free AddressRange\n" ) );

    nicBusResetNotification (pAdapter,
                             DEREGISTER_NOTIFICATION_ROUTINE,
                             nicResetNotificationCallback,
                             pAdapter);

    //
    // deregister this adapter with enumerator
    //
    if ((NdisEnum1394DeregisterAdapter != NULL) &&
        ADAPTER_TEST_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator))
    {       
        //
        // deregister this adapter with enumerator
        //
        NdisEnum1394DeregisterAdapter(pAdapter->EnumAdapterHandle);
        
        ADAPTER_CLEAR_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator | fADAPTER_FailedRegisteration);
    }   

    //
    // No more Irps on this adapter's VDO
    //

    ADAPTER_SET_FLAG (pAdapter, fADAPTER_VDOInactive);

    
    //
    //  Cancel Outstanding Timer
    //

    ADAPTER_SET_FLAG (pAdapter, fADAPTER_FreedTimers);

    //
    //  Cancel Outstanding WorItems
    //
    while (pAdapter->OutstandingWorkItems  != 0) 
    {

        NdisMSleep (10000);                       

    } 

    ADAPTER_SET_FLAG (pAdapter, fADAPTER_DeletedWorkItems);

    // Remove this adapter from the global list of adapters.
    //
    NdisAcquireSpinLock(&g_DriverLock);
    nicRemoveEntryList(&pAdapter->linkAdapter);
    NdisReleaseSpinLock(&g_DriverLock);

    ADAPTER_ACQUIRE_LOCK (pAdapter);
    // do Adapter Specific Work here
    pAdapter->HardwareStatus = NdisHardwareStatusClosing;   

    //
    // Free all lookaside lists
    // 
    nicDeleteAdapterLookasideLists (pAdapter);

    ADAPTER_SET_FLAG (pAdapter, fADAPTER_DeletedLookasideLists);
    
    //
    // Free the Adapter's BCRData. TopologyMap as that is locally allocated
    //
    if (pAdapter->BCRData.pTopologyMap)
    {
        FREE_NONPAGED (pAdapter->BCRData.pTopologyMap);
    }
    
    ADAPTER_RELEASE_LOCK (pAdapter);
        
    NdisFreeSpinLock (&pAdapter->lock);

    while (pAdapter->lRef != 1)
    {
        //
        // sleep for 1 second waiting for outstanding operations to complete
        //
        NdisMSleep (1000); 
    }

    nicDereferenceAdapter( pAdapter, "nicMpHalt" );


    //ASSERT (g_AdapterFreed == TRUE);
    
    TRACE( TL_T, TM_Mp, ( "<==NicMpHalt " ) );

    TIMESTAMP_EXIT("<==Haltandler");
    TIMESTAMP_HALT();

    TRACE( TL_I, TM_Init, ( "Nic1394 Halted %p ", pAdapter ) );


    MATCH_IRQL
}


NDIS_STATUS
NicMpReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext 
    )

    // Standard 'MiniportReset' routine called by NDIS to reset the driver's
    // software state.
    //
{
    TRACE( TL_T, TM_Mp, ( "NicMpReset" ) );

    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
NicMpCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters 
    )

    // Standard 'MiniportCoActivateVc' routine called by NDIS in response to a
    // protocol's request to activate a virtual circuit.
    //
    // The only "protocol" to call us is our call manager half, which knows
    // exactly what it's doing and so we don't have to do anything here.
    // It does expect us to return success synchronously.
    //
{
    return NDIS_STATUS_SUCCESS;
}



NDIS_STATUS
NicMpCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext 
    )

    // Standard 'MiniportCoDeactivateVc' routine called by NDIS in response to
    // a protocol's request to de-activate a virtual circuit.
    //
    // The only "protocol" to call us is our call manager half, which knows
    // exactly what it's doing and so we don't have to do anything here.
    // It does expect us to return success synchronously.
    //
{
    return NDIS_STATUS_SUCCESS;
}



VOID
NicMpCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets 
    )

    // 'MiniportCoSendPackets' routine called by NDIS in response to
    // a protocol's request to send packets on a virtual circuit.
    //
{
    UINT i;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    NDIS_PACKET** ppPacket;
    VCCB* pVc;
    extern UINT NicSends;

    TRACE( TL_V, TM_Send, ( "==>NicMpCoSendPackets(%d), Vc %.8x", NumberOfPackets, MiniportVcContext ) );

    

    pVc = (VCCB* )MiniportVcContext;
    ASSERT( pVc->Hdr.ulTag == MTAG_VCCB );

    for (i = 0, ppPacket = PacketArray;
         i < NumberOfPackets;
         ++i, ++ppPacket)
    {
        NDIS_PACKET* pPacket = *ppPacket;

        // SendPacket sends the packet and eventually calls
        // NdisMCoSendComplete to notify caller of the result.
        //
        NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_PENDING );
        nicIncrementSends (pVc);

        nicDumpPkt (pPacket , "Sending ");

        //
        // Loopback the packet it is a broadcast packet
        //
        if (pVc->Hdr.VcType == NIC1394_SendRecvChannel ||
            pVc->Hdr.VcType == NIC1394_MultiChannel ||
            pVc->Hdr.VcType == NIC1394_SendChannel)
        {
            nicLoopbackPacket(pVc, pPacket);
        }
        
#if QUEUED_PACKETS

                
        NdisStatus = nicQueueSendPacket(pPacket, pVc);

    
#else   

        nicUpdatePacketState (pPacket, NIC1394_TAG_IN_SEND);

        NdisStatus = pVc->Hdr.VcHandlers.SendPackets (pVc, pPacket);

#endif      
        if (NT_SUCCESS (NdisStatus) == FALSE)
        {
              TRACE( TL_N, TM_Send, ( "SendHandler failed Status %.8x", NdisStatus ) );

            break;
        }
    }

    //  If the call to the VC's Send handler was not successful
    //  Indicate failure for that packet and all packets following it
    //

    if (NT_SUCCESS(NdisStatus) == FALSE) // can pend also 
    {   
        //  Start from the packet which caused the break and indicate
        //  Failure (call the completion handler for each packet
        //

        for ( ; i < NumberOfPackets;++i,++ppPacket)
        {
            TRACE( TL_V, TM_Send, ( "Calling NdisCoSendComplete, status %x, VcHandle %x, pPkt %x",
                          NDIS_STATUS_FAILURE , pVc->Hdr.NdisVcHandle, *ppPacket ) );

            nicMpCoSendComplete (NDIS_STATUS_FAILURE, pVc,*ppPacket);
        }
        
    }


    TRACE( TL_T, TM_Send, ( "<==NicMpCoSendPackets " ) );
}


NDIS_STATUS
NicMpCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest 
    )

    // Standard 'MiniportCoRequestHandler' routine called by NDIS in response
    // to a protocol's request information from the mini-port.  Unlike the
    // Query/SetInformation handlers that this routine obsoletes, requests are
    // not serialized.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_STATUS status;

    TRACE( TL_T, TM_Mp, ( "NicMpCoReq, Request %.8x", NdisRequest ) );


    pAdapter = (ADAPTERCB* )MiniportAdapterContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pVc = (VCCB* )MiniportVcContext;
    if (pVc && pVc->Hdr.ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    switch (NdisRequest->RequestType)
    {
        case NdisRequestQueryStatistics:
        case NdisRequestQueryInformation:
        {
            status = nicQueryInformation(
                pAdapter,
                pVc,
                NdisRequest
                );
            break;
        }

        case NdisRequestSetInformation:
        {   
            status = nicSetInformation(
                pAdapter,
                pVc,
                NdisRequest
                );
            break;
        }

        
        default:
        {
            status = NDIS_STATUS_NOT_SUPPORTED;
            TRACE( TL_V, TM_Mp, ( "type=%d?", NdisRequest->RequestType ) );
            break;
        }
    }

    TRACE( TL_T, TM_Mp, ( "NicMpCoReq, Status=$%x", status ) );

    return status;
}


//-----------------------------------------------------------------------------
// Mini-port utility routines (alphabetically)
// Some are used externally
//-----------------------------------------------------------------------------

VOID
nicDereferenceAdapter(
    IN PADAPTERCB pAdapter, 
    IN PCHAR pDebugPrint
    )

    // Removes a reference from the adapter control block 'pAdapter', and when
    // frees the adapter resources when the last reference is removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pAdapter->lRef );

    TRACE( TL_V, TM_Ref, ( "**nicDereferenceAdapter  pAdapter %x, to %d, %s ", pAdapter, pAdapter->lRef, pDebugPrint  ) );

    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        nicFreeAdapter( pAdapter );
    }
}


VOID
nicFreeAdapter(
    IN ADAPTERCB* pAdapter
    )

    // Frees all resources allocated for adapter 'pAdapter', including
    // 'pAdapter' itself.
    //
{


    pAdapter->ulTag = MTAG_FREED;

    ASSERT (pAdapter->lRef == 0);
     
    FREE_NONPAGED( pAdapter );

    g_AdapterFreed  = TRUE;
}


NDIS_STATUS
nicGetRegistrySettings(
    IN NDIS_HANDLE WrapperConfigurationContext,
    IN ADAPTERCB * pAdapter
    )

    // Read this mini-port's registry settings into caller's output variables.
    // 'WrapperConfigurationContext' is the handle to passed to
    // MiniportInitialize.
    //
{
    NDIS_STATUS status;
    NDIS_HANDLE hCfg;
    NDIS_CONFIGURATION_PARAMETER* pncp;
    PNDIS_CONFIGURATION_PARAMETER pNameConfig;
    NDIS_STRING strMiniportName = NDIS_STRING_CONST("MiniportName");
    ULONG AdapterNameSizeInBytes = 0;


    NdisOpenConfiguration( &status, &hCfg, WrapperConfigurationContext );
    if (status != NDIS_STATUS_SUCCESS)
        return status;

    do
    {
        //
        // Read the Miniport Name. First setup the buffer
        //
    
        NdisReadConfiguration(&status,
                              &pNameConfig,
                              hCfg,
                              &strMiniportName,
                              NdisParameterString);

        if (status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        AdapterNameSizeInBytes = pNameConfig->ParameterData.StringData.Length;


        //
        // Only Copy the Adapter name if the size of the string from the registry
        // is smaller than the size we have allocated in the adapter structure.
        // There should also be room for the trailing L'\0' character.
        //

        if ((ADAPTER_NAME_SIZE*sizeof(WCHAR)) > (AdapterNameSizeInBytes+2))
        {
            PUCHAR pAdapterName = (PUCHAR)&pAdapter->AdapterName[0];
            
            pAdapter->AdapterNameSize = AdapterNameSizeInBytes; 

            NdisMoveMemory (pAdapterName,   // Destination
                            pNameConfig->ParameterData.StringData.Buffer, // Source
                             AdapterNameSizeInBytes ); // number of characters
            
            //
            // NULL - terminate the string by adding the L'\0' Unicode character
            //
            pAdapterName[AdapterNameSizeInBytes]= 0;
            pAdapterName[AdapterNameSizeInBytes+1]= 0;
            
        }
        


    }
    while (FALSE);

    NdisCloseConfiguration( hCfg );

    TRACE( TL_N, TM_Init,
        ( "Reg: Name %s", &pAdapter->AdapterName));

    return status;
}


NDIS_STATUS
nicQueryInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN OUT PNDIS_REQUEST NdisRequest
    )

/*++

Routine Description:

    NOTE: this function can be called in at least two contexts:
    1: in the context of an NdisRequest
    2: in the context of our own work item, if the request needs to be completed
       at passive.


Arguments:


Return Value:


--*/

{

    NDIS_STATUS status;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;
    USHORT usInfo;
    NDIS_OID Oid;
    PVOID InformationBuffer;
    ULONG InformationBufferLength;
    PULONG BytesWritten;
    PULONG BytesNeeded;
    NDIS_CO_LINK_SPEED          CoLinkSpeed;
    NIC1394_LOCAL_NODE_INFO     LocalNodeInfo;
    NIC1394_VC_INFO             VcInfo;
    REMOTE_UID                  RemoteUid;
    NDIS_PNP_CAPABILITIES       PnpCaps;
    NIC1394_NICINFO             NicInfo;
    
    Oid =            NdisRequest->DATA.QUERY_INFORMATION.Oid;
    InformationBuffer =  NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;
    InformationBufferLength = 
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength;
    BytesWritten =  &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten;
    BytesNeeded = &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded;
    

    //  The next variables are used to setup the data structures that are 
    //  used to respond to the OIDs they correspond to
    //
 
    TRACE( TL_T, TM_Init, ( "==>nicQueryInformation, Adapter %.8x, Vc %.8x, Oid %.8x",pAdapter, pVc, Oid ));


    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof(ulInfo);

    status = NDIS_STATUS_SUCCESS;
    
    switch (Oid)
    {
    
        
        case OID_GEN_CO_SUPPORTED_LIST:
        {
            
            pInfo = &SupportedOids[0];
            ulInfoLen = sizeof(SupportedOids);
            break;
        }

        case OID_GEN_CO_HARDWARE_STATUS:
        {
            
            //
            //  Copy the hardware status into the users buffer.
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_HARDWARE_STATUS)" ) );

            NdisAcquireSpinLock (&pAdapter->lock);

            pInfo = (PUCHAR) &pAdapter->HardwareStatus;

            NdisReleaseSpinLock (&pAdapter->lock);
            
            ulInfoLen = sizeof(pAdapter->HardwareStatus);
            break;
        }


        case OID_GEN_MAXIMUM_LOOKAHEAD:
        {
            
            #if TODO
            // Verify the following...
            #endif
            // Report the maximum number of bytes we can always provide as
            // lookahead data on receive indications.  We always indicate full
            // packets so this is the same as the receive block size.  And
            // since we always allocate enough for a full packet, the receive
            // block size is the same as the frame size.
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_LOOKAHEAD)" ) );
            ulInfo = Nic1394_MaxFrameSize;
            break;
        }

        case OID_GEN_CO_MAC_OPTIONS:
        {
            #if TODO
            // Verify the following...
            #endif
            // Report a bitmask defining optional properties of the driver.
            //
            // NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA promises that our receive
            // buffer is not on a device-specific card.
            //
            // NDIS_MAC_OPTION_TRANSFERS_NOT_PEND promises we won't return
            // NDIS_STATUS_PENDING from our TransferData handler which is true
            // since we don't have one.
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_MAC_OPTIONS)" ) );
            ulInfo = 0;
            break;
        }



        case OID_GEN_CO_MEDIA_SUPPORTED:
        case OID_GEN_CO_MEDIA_IN_USE:
        {
            //
            //  We support 1394.
            //
              
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_MEDIA_SUPPORTED or OID_GEN_CO_MEDIA_IN_USE)" ) );

            ulInfo = g_ulMedium;

            break;
        }


#ifndef _ETHERNET_      
        //
        // There are different return values for CO_LINK_SPEED and LINK_SPEED
        //
        case OID_GEN_CO_LINK_SPEED:
#endif      
        case OID_GEN_CO_MINIMUM_LINK_SPEED:
        {

            //
            //  Link speed depends upon the type of adapter. We will need to 
            //  add support for different speeds and so forth
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_MINIMUM_LINK_SPEED or OID_GEN_CO_LINK_SPEED)" ) );
            CoLinkSpeed.Inbound = CoLinkSpeed.Outbound = pAdapter->SpeedMbps; //10 Mbps ????
                                    
            pInfo = (PUCHAR)&CoLinkSpeed;
            ulInfoLen = sizeof(CoLinkSpeed);

            TRACE( TL_V, TM_Mp, ( "Link Speed %x" ,CoLinkSpeed.Outbound  ) );


            break;
        }

        case OID_GEN_CO_VENDOR_ID:
        {
            //
            //  We need to add the appropriate vendor id for the nic1394
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_VENDOR_ID)" ) );
                    
            ulInfo = 0xFFFFFFFF;

            break;

        }

        case OID_GEN_CO_VENDOR_DESCRIPTION:
        {

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_VENDOR_DESCRIPTION)" ) );
        
            pInfo = (PUCHAR)pnic1394DriverDescription;
            ulInfoLen = strlen(pnic1394DriverDescription);

            break;
        }
       
        case OID_GEN_VENDOR_DRIVER_VERSION:
        {

            pInfo =(PVOID) &nic1394DriverGeneration;
            ulInfoLen = sizeof(nic1394DriverGeneration);
            break;
        }

        case OID_GEN_CO_DRIVER_VERSION:
        {
            //
            //  Return the version of NDIS that we expect.
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_DRIVER_VERSION)" ) );
                    
            usInfo = ((NDIS_MajorVersion << 8) | NDIS_MinorVersion);
            pInfo = (PUCHAR)&usInfo;
            ulInfoLen = sizeof(USHORT);

            break;
        }
        
        case OID_GEN_CO_PROTOCOL_OPTIONS:
        {
            //
            //  We don't support protocol options.
            //

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_PROTOCOL_OPTIONS)" ) );
                    
            ulInfo = 0;

            break;
        }
        
        case OID_GEN_CO_MEDIA_CONNECT_STATUS:
        {
            //
            //  Return our true state only if we have ever received a 
            // remote node in this boot.
            //
            
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_MEDIA_CONNECT_STATUS)" ) );

            if (ADAPTER_TEST_FLAG(pAdapter, fADAPTER_RemoteNodeInThisBoot) == FALSE)
            {
                ulInfo = NdisMediaStateConnected;
            }
            else
            {
                ulInfo = pAdapter->MediaConnectStatus;
            }

            break;
        }

        case OID_1394_IP1394_CONNECT_STATUS:
        {
            //
            //  Return whether or not we have a link. This is used by the Arp
            //  module to set connectivity
            //
            
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_1394_IP1394_CONNECT_STATUS)" ) );
                    
            ulInfo = pAdapter->MediaConnectStatus;

            break;
        }

        case OID_GEN_CO_SUPPORTED_GUIDS:
        {
            //
            //  Point to the list of supported guids.
            //  We do not support any guids at the current time

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_SUPPORTED_GUIDS)" ) );
            
            pInfo = (PUCHAR) &GuidList;
            ulInfoLen =  sizeof(GuidList);
            break;
            
            break;
        
        }

        case OID_1394_LOCAL_NODE_INFO:
        {

            //  This Oid return information about the local node 
            //  on the machine
            //  Need to change this with real values that will be present
            //  in the header structures
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_1394_LOCAL_NODE_INFO)" ) );

            ADAPTER_ACQUIRE_LOCK (pAdapter);
 
            LocalNodeInfo.UniqueID = pAdapter->UniqueId;
            LocalNodeInfo.BusGeneration = pAdapter->Generation;
            LocalNodeInfo.NodeAddress = pAdapter->NodeAddress;
            LocalNodeInfo.MaxRecvBlockSize = pAdapter->MaxRec; 
            LocalNodeInfo.MaxRecvSpeed = pAdapter->SCode;

            ADAPTER_RELEASE_LOCK (pAdapter);
            
            pInfo = &LocalNodeInfo;
            ulInfoLen = sizeof(LocalNodeInfo);
            break;
        }

        case OID_1394_VC_INFO:
        {

            // Returns information about the VC that is being queried
            //


            TRACE( TL_V, TM_Mp, ("QInfo(OID_1394_VC_INFO)") );

            if (pVc != NULL)
            {
                VcInfo.Destination = pVc->Hdr.Nic1394MediaParams.Destination;

            
                pInfo = &VcInfo;
                ulInfoLen = sizeof(VcInfo);
            }
            else
            {
                status = NDIS_STATUS_FAILURE;
            }
            
            break;
        }


        case OID_1394_NICINFO:
        {
            if (InformationBufferLength >= sizeof(NicInfo))
            {
                //
                // We need to call nicFillNicInfo at passive, so we switch
                // to a work item context.
                //
                if (KeGetCurrentIrql() > PASSIVE_LEVEL)
                {
                    PNIC_WORK_ITEM pNicWorkItem;
                    pNicWorkItem = ALLOC_NONPAGED (sizeof(NIC_WORK_ITEM), MTAG_WORKITEM); 
                    if (pNicWorkItem != NULL)
                    {
                        NdisZeroMemory(pNicWorkItem, sizeof(*pNicWorkItem));
                        pNicWorkItem->RequestInfo.pNdisRequest = NdisRequest;
                        pNicWorkItem->RequestInfo.pVc = NULL;
                        NdisInitializeWorkItem ( &pNicWorkItem->NdisWorkItem, 
                                             (NDIS_PROC) nicQueryInformationWorkItem,
                                             (PVOID) pAdapter);

                        TRACE( TL_V, TM_Cm, ( "Scheduling QueryInformation WorkItem" ) );
                                            
                        nicReferenceAdapter (pAdapter, "nicFillBusInfo ");

                        NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

                        NdisScheduleWorkItem (&pNicWorkItem->NdisWorkItem);
                        status = NDIS_STATUS_PENDING;
                    }
                    else
                    {
                        status = NDIS_STATUS_RESOURCES;
                    }
                }
                else
                {
                    status =  nicFillNicInfo (
                                pAdapter,
                                (PNIC1394_NICINFO) InformationBuffer,   // Input
                                &NicInfo                                // Output
                                );
                    ASSERT(status != NDIS_STATUS_PENDING);
                }
            }

            pInfo = &NicInfo;
            ulInfoLen = sizeof(NicInfo);
            break;

        }
        case OID_1394_QUERY_EUID_NODE_MAP:
        {
            if (sizeof (EUID_TOPOLOGY) <= InformationBufferLength )
            {
                nicQueryEuidNodeMacMap (pAdapter, NdisRequest);
                status = NDIS_STATUS_PENDING;
            }
            else
            {
                //
                // This will cause NDIS_STATUS_INVALID_LENGTH to be returned
                //
                ulInfoLen = sizeof (EUID_TOPOLOGY);  
            }
            break;
        }        
        case OID_GEN_CO_XMIT_PDUS_OK: 
        {
            ulInfo = pAdapter->AdaptStats.ulXmitOk;
            break;
        }
        case OID_GEN_CO_RCV_PDUS_OK:
        {
            ulInfo = pAdapter->AdaptStats.ulRcvOk;
            break;
        }
        case OID_GEN_CO_XMIT_PDUS_ERROR:
        {
            ulInfo = pAdapter->AdaptStats.ulXmitError;
            break;
        }
        case OID_GEN_CO_RCV_PDUS_ERROR:
        {
            ulInfo = pAdapter->AdaptStats.ulRcvError;
            break;
        }
        case OID_GEN_CO_RCV_PDUS_NO_BUFFER:
        {
            ulInfo = 0;
            break;
        }

        case OID_GEN_PHYSICAL_MEDIUM:
        {
            TRACE( TL_V, TM_Mp, ( " OID_GEN_PHYSICAL_MEDIUM" ) );

            ulInfo = NdisPhysicalMedium1394;
            break;
        }

        case OID_1394_ISSUE_BUS_RESET:
        {
            TRACE( TL_V, TM_Mp, ( " OID_1394_ISSUE_BUS_RESET" ) );

            //
            // The ndistester is currently  the only user of this oid and does not set the flag
            //
            if (InformationBufferLength == sizeof(ULONG))
            {
                nicIssueBusReset (pAdapter, BUS_RESET_FLAGS_FORCE_ROOT );
            }
            
            break;
        }

        //
        // Wmi below
        //
    
        case OID_IP1394_QUERY_UID:
        {
            TRACE( TL_V, TM_Mp, ( " OID_IP1394_QUERY_UID" ) );

            pInfo = &pAdapter->UniqueId;
            ulInfoLen = sizeof (UINT64);
            break;
        }

        case OID_IP1394_QUERY_STATS:
        {
            TRACE( TL_V, TM_Mp, ( " OID_IP1394_QUERY_STATS" ) );

            pInfo = &pAdapter->AdaptStats;
            ulInfoLen = sizeof (ADAPT_STATS);
            break;


        }

        case OID_IP1394_QUERY_REMOTE_UID:
        {
            TRACE( TL_V, TM_Mp, ( "OID_IP1394_QUERY_REMOTE_UID " ) );

            
            NdisZeroMemory (&RemoteUid, sizeof (RemoteUid) );
            
            ADAPTER_ACQUIRE_LOCK (pAdapter);
            {
                ULONG j = 0;  
                // Populate all 5 remote node entries
                
                while (j < (2*MAX_NUM_REMOTE_NODES))
                {   
                    if (pAdapter->NodeTable.RemoteNode[j/2] != NULL)
                    {
                        PULARGE_INTEGER pUniqueId = (PULARGE_INTEGER)&pAdapter->NodeTable.RemoteNode[j/2]->UniqueId;
                        RemoteUid.Uid[j] = pUniqueId->LowPart ;
                        j++;
                        RemoteUid.Uid[j] = pUniqueId->HighPart;
                    }
                    else
                    {
                        j++;
                    }

                    j++;
                }
        

            }
            ADAPTER_RELEASE_LOCK (pAdapter);

            pInfo = &RemoteUid;
            ulInfoLen = sizeof (RemoteUid);
            break;
        }




        case OID_PNP_CAPABILITIES:
        {
            TRACE( TL_V, TM_Mp, ("QInfo(OID_PNP_CAPABILITIES)") );
            
            PnpCaps.Flags = 0;
            PnpCaps.WakeUpCapabilities.MinMagicPacketWakeUp = NdisDeviceStateUnspecified;           
            PnpCaps.WakeUpCapabilities.MinPatternWakeUp = NdisDeviceStateUnspecified;
            PnpCaps.WakeUpCapabilities.MinLinkChangeWakeUp = NdisDeviceStateUnspecified;

            pInfo = &PnpCaps;
            ulInfoLen = sizeof (PnpCaps);
            
            break;
        }

        case OID_PNP_QUERY_POWER:
        {
            //
            // The miniport is always ready to go into low power state.
            //
            *BytesWritten = sizeof (NDIS_DEVICE_POWER_STATE );
            *BytesNeeded = sizeof (NDIS_DEVICE_POWER_STATE  );

            status = NDIS_STATUS_SUCCESS;
            break;
        }

        

#ifdef _ETHERNET_

            
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_MAXIMUM_FRAME_SIZE:
        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
        case OID_GEN_MAXIMUM_SEND_PACKETS:
        case OID_GEN_TRANSMIT_BUFFER_SPACE:
        case OID_GEN_RECEIVE_BUFFER_SPACE:
        case OID_802_3_PERMANENT_ADDRESS:
        case OID_802_3_CURRENT_ADDRESS:
        case OID_802_3_MULTICAST_LIST:
        case OID_802_3_MAXIMUM_LIST_SIZE:
        case OID_802_3_RCV_ERROR_ALIGNMENT:
        case OID_802_3_XMIT_ONE_COLLISION:
        case OID_802_3_XMIT_MORE_COLLISIONS:
        case OID_GEN_LINK_SPEED:
        case OID_GEN_CURRENT_PACKET_FILTER:
        {
            status = NicEthQueryInformation((NDIS_HANDLE)pAdapter, 
                                           Oid,
                                           InformationBuffer,
                                           InformationBufferLength,
                                           BytesWritten,
                                           BytesNeeded
                                           );


            if (status == NDIS_STATUS_SUCCESS)
            {
                pInfo = InformationBuffer;
                ulInfoLen = *BytesWritten;

            }
            else
            {
                if (status == NDIS_STATUS_INVALID_LENGTH)
                {
                   ulInfoLen = *BytesNeeded;            
                }
                else
                {
                    status = NDIS_STATUS_NOT_SUPPORTED;
                    TRACE( TL_V, TM_Mp, ( "Q-OID=$%08x?", Oid ) );
                }
            }
            break;

        }
#endif


        default:
        {
            TRACE( TL_V, TM_Mp, ( "Q-OID=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        *BytesWritten  = 0;
        status = NDIS_STATUS_INVALID_LENGTH;
    }
    else 
    {
        //
        // If the request has not been pended then, fill
        // out the retuen values
        //
        if (status == NDIS_STATUS_SUCCESS )
        {
            // Copy the found result to caller's buffer.
            //
            if (ulInfoLen > 0)
            {
                NdisMoveMemory( InformationBuffer, pInfo, ulInfoLen );
                DUMPDW( TL_V, TM_Mp, pInfo, ulInfoLen );
            }

            *BytesNeeded = *BytesWritten = ulInfoLen;
        }
    }


    TRACE( TL_N, TM_Mp, ( " Q-OID=$%08x, Status %x, Bytes Written %x", Oid, status, *BytesWritten ) );

    TRACE( TL_T, TM_Init, ( "<==nicQueryInformation, Status %.8x", status ));

    return status;
}


VOID
nicReferenceAdapter(
    IN ADAPTERCB* pAdapter ,
    IN PCHAR pDebugPrint
    )

    // Adds areference to the adapter block, 'pAdapter'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pAdapter->lRef );

    TRACE( TL_V, TM_Ref, ( "**nicReferenceAdapter  pAdapter %x, to %d, %s ", pAdapter, pAdapter->lRef, pDebugPrint  ) );

}


NDIS_STATUS
nicSetInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN OUT PNDIS_REQUEST NdisRequest
    )

    // Handle SetInformation requests.  Arguments are as for the standard NDIS
    // 'MiniportQueryInformation' handler except this routine does not count
    // on being serialized with respect to other requests.
    //
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG ulInfo = 0;
    VOID* pInfo= NULL;
    ULONG ulInfoLen= 0;
    USHORT usInfo = 0;
    NDIS_OID Oid;
    PVOID InformationBuffer;
    ULONG InformationBufferLength;
    PULONG BytesRead;
    PULONG BytesNeeded;

    //
    // Initialize the REquest Variables
    //
    Oid =            NdisRequest->DATA.SET_INFORMATION.Oid;
    InformationBuffer =  NdisRequest->DATA.SET_INFORMATION.InformationBuffer;
    InformationBufferLength = 
                NdisRequest->DATA.SET_INFORMATION.InformationBufferLength;
    BytesRead =  &NdisRequest->DATA.SET_INFORMATION.BytesRead;
    BytesNeeded = &NdisRequest->DATA.SET_INFORMATION.BytesNeeded;
    
    TRACE( TL_T, TM_Init, ( "==>nicSetInformation , Adapter %.8x, Vc %.8x, Oid %.8x",pAdapter, pVc, Oid ));
    


    Status = NDIS_STATUS_SUCCESS;

    switch (Oid)
    {

#if 0
        // These OIDs are mandatory according to current doc, but since
        // NDISWAN never requests them they are omitted.
        //
        case OID_GEN_CURRENT_PACKET_FILTER:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_PROTOCOL_OPTIONS:
        case OID_WAN_PROTOCOL_TYPE:
        case OID_WAN_HEADER_FORMAT:
#endif

        case OID_GEN_CURRENT_PACKET_FILTER:
        {
            ULONG Filter;
            
            if (InformationBufferLength < sizeof (ULONG))
            {
                Status = NDIS_STATUS_INVALID_LENGTH;
                break;
            }
            else
            {
                *BytesNeeded  = sizeof (ULONG);
            }

            //
            // Store the new value.
            //
            NdisMoveMemory(&Filter, InformationBuffer, sizeof(ULONG));

            //
            // Don't allow promisc mode, because we can't support that.
            //
            if (Filter & NDIS_PACKET_TYPE_PROMISCUOUS)
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            Filter = *((PULONG)InformationBuffer);
            
            pAdapter->CurPacketFilter = Filter;

            Status = NDIS_STATUS_SUCCESS;

            ulInfoLen = sizeof (ULONG);
            break;

        }

        case OID_1394_ENTER_BRIDGE_MODE:
        {
            *BytesNeeded = 0;                           

            nicInitializeLoadArpStruct(pAdapter);
            
            Status = nicQueueRequestToArp (pAdapter, 
                                                   LoadArp, // Load Arp Module
                                                   NdisRequest);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                //
                // we have successfully queued a Workitem
                // so this request needs to be pended
                //
                Status = NDIS_STATUS_PENDING;

            }
            ulInfoLen = sizeof (ULONG);
            break;

        }

        case OID_1394_EXIT_BRIDGE_MODE:
        {

            *BytesNeeded = 0;                           


            if (ADAPTER_TEST_FLAG(pAdapter, fADAPTER_BridgeMode) == TRUE)
            {
                Status = nicQueueRequestToArp (pAdapter, 
                                              UnloadArp, //Unload Arp Module
                                              NdisRequest);

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    //
                    // we have successfully queued a Workitem
                    // so this request needs to be pended
                    //
                    Status = NDIS_STATUS_PENDING;

                }
            }
            else
            {
                //
                // We are not in bridge mode, tcpip must not have triggered the bridge to send us 
                // ENTER_BRIDGE_MODE Oid. Succeed the request 
                //
                Status = NDIS_STATUS_SUCCESS;
            }
            ulInfoLen = sizeof (ULONG);


            break;
        }

        
        case OID_802_3_MULTICAST_LIST:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_NETWORK_LAYER_ADDRESSES:
        {
            Status =  NicEthSetInformation(pAdapter,
                                           Oid,
                                          InformationBuffer,
                                          InformationBufferLength,
                                          BytesRead ,
                                          BytesNeeded 
                                          );

            if (Status != NDIS_STATUS_SUCCESS && Status  != NDIS_STATUS_INVALID_LENGTH)
            {
                Status = NDIS_STATUS_NOT_SUPPORTED;
            }
                                       
            break;
        }

        case OID_1394_ISSUE_BUS_RESET:
        {
            TRACE( TL_V, TM_Mp, ( " OID_1394_ISSUE_BUS_RESET" ) );
            //
            // The ndistester is currently  the only user of this oid and does not set the flag
            //
            if (InformationBufferLength == sizeof(ULONG))
            {
                nicIssueBusReset (pAdapter, BUS_RESET_FLAGS_FORCE_ROOT );
            }
            
            break;
        }

        case OID_PNP_SET_POWER:

            TRACE( TL_V, TM_Mp, ( "QInfo OID_PNP_SET_POWER %x", Oid ) );
        
            *BytesRead = sizeof (NDIS_DEVICE_POWER_STATE );
            *BytesNeeded = sizeof (NDIS_DEVICE_POWER_STATE  );
            if (InformationBufferLength >= sizeof (NDIS_DEVICE_POWER_STATE))
            {
                NDIS_DEVICE_POWER_STATE PoState;
                NdisMoveMemory (&PoState, InformationBuffer, sizeof(PoState));
                Status = MPSetPower(pAdapter,PoState);
            }
            break;

        default:
        {
            TRACE( TL_A, TM_Mp, ( "S-OID=$%08x?", Oid ) );
            Status = NDIS_STATUS_NOT_SUPPORTED;
            *BytesRead = *BytesNeeded = 0;
            break;
        }
    }

    if (*BytesNeeded  > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesRead  = 0;
        Status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {

        *BytesNeeded = *BytesRead = ulInfoLen;
    }

        
      
    TRACE( TL_A, TM_Mp, ( " S-OID=$%08x, Status %x, Bytes Read %x", Oid, Status, *BytesRead ) );


    TRACE( TL_T, TM_Init, ( "<==nicSetInformation, Status %.8x", Status ));

    return Status;
}



//------------------------------------------------------------------------------
// C O N N E C T I O N    L E S S   F U N T I O N S    S T A R T    H E R E  
//


NDIS_STATUS
NicEthSetInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    NDIS_OID            Oid,
    PVOID               InformationBuffer,
    ULONG               InformationBufferLength,
    PULONG              BytesRead,
    PULONG              BytesNeeded
    )


/*++

Routine Description:

    This is the Set information that will be used by the CL edge

Arguments:


Return Value:


--*/

{
    NDIS_STATUS         NdisStatus = NDIS_STATUS_SUCCESS;
    UINT                BytesLeft       = InformationBufferLength;
    PUCHAR              InfoBuffer      = (PUCHAR)(InformationBuffer);
    UINT                OidLength;
    ULONG               LookAhead;
    ULONG               Filter;
    PADAPTERCB          pAdapter;
    BOOLEAN             IsShuttingDown;
    STORE_CURRENT_IRQL;

   

    pAdapter = (PADAPTERCB)MiniportAdapterContext;

    TRACE( TL_T, TM_Init, ( "==>nicEthSetInformation , Adapter %.8x, Oid %.8x",pAdapter, Oid ));

    // 
    // IS the adapter shutting down
    //
    ADAPTER_ACQUIRE_LOCK (pAdapter);
    IsShuttingDown = (! ADAPTER_ACTIVE(pAdapter)) ;
    ADAPTER_RELEASE_LOCK (pAdapter);

    if (IsShuttingDown)
    {
        TRACE( TL_T, TM_Init, ( "  nicSetInformation Shutting Down , Adapter %.8x, Oid %.8x",pAdapter, Oid ));
        
        *BytesRead = 0;
        *BytesNeeded = 0;

        NdisStatus = NDIS_STATUS_SUCCESS;
        return (NdisStatus);
    }

    //
    // Get Oid and Length of request
    //
    OidLength = BytesLeft;

    switch (Oid) 
    {

        case OID_802_3_MULTICAST_LIST:

            if (OidLength % sizeof(MAC_ADDRESS))
            {
                NdisStatus = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
                *BytesNeeded = 0;
                break;
            }
            
            if (OidLength > (MCAST_LIST_SIZE * sizeof(MAC_ADDRESS)))
            {
                NdisStatus= NDIS_STATUS_MULTICAST_FULL;
                *BytesRead = 0;
                *BytesNeeded = 0;
                break;
            }
            
            NdisZeroMemory(
                    &pAdapter->McastAddrs[0], 
                    MCAST_LIST_SIZE * sizeof(MAC_ADDRESS)
                    );
            NdisMoveMemory(
                    &pAdapter->McastAddrs[0], 
                    InfoBuffer,
                    OidLength
                    );
            pAdapter->McastAddrCount = OidLength / sizeof(MAC_ADDRESS);


            break;

        case OID_GEN_CURRENT_PACKET_FILTER:
            //
            // Verify length
            //
            if (OidLength != sizeof(ULONG)) 
            {
                NdisStatus = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
                *BytesNeeded = sizeof(ULONG);
                break;
            }

            //
            // Store the new value.
            //
            NdisMoveMemory(&Filter, InfoBuffer, sizeof(ULONG));

            //
            // Don't allow promisc mode, because we can't support that.
            //
            if (Filter & NDIS_PACKET_TYPE_PROMISCUOUS)
            {
                NdisStatus = NDIS_STATUS_FAILURE;
                break;
            }

            ADAPTER_ACQUIRE_LOCK (pAdapter);        

            pAdapter->CurPacketFilter = Filter;

            ADAPTER_RELEASE_LOCK (pAdapter);
            
            break;

        case OID_802_5_CURRENT_FUNCTIONAL:
        case OID_802_5_CURRENT_GROUP:

            // XXX just accept whatever for now ???
            
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:

            //
            // Verify length
            //
            if (OidLength != 4) 
            {
                NdisStatus = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
                *BytesNeeded = 0;
                break;
            }

            //
            // Store the new value.
            //
            NdisMoveMemory(&LookAhead, InfoBuffer, 4);
        
            pAdapter->CurLookAhead = LookAhead;

            break;

        case OID_GEN_NETWORK_LAYER_ADDRESSES:

            
            NdisStatus = NDIS_STATUS_SUCCESS;
            *BytesRead = InformationBufferLength;
            *BytesNeeded = InformationBufferLength;
            break;

        case OID_PNP_SET_POWER:

            TRACE( TL_V, TM_Mp, ( "QInfo OID_PNP_SET_POWER %x", Oid ) );
        
            *BytesRead = sizeof (NDIS_DEVICE_POWER_STATE );
            *BytesNeeded = sizeof (NDIS_DEVICE_POWER_STATE  );
            
            if (InformationBufferLength >= sizeof (NDIS_DEVICE_POWER_STATE))
            {
                NDIS_DEVICE_POWER_STATE PoState;
                NdisMoveMemory (&PoState, InformationBuffer, sizeof(PoState));
                NdisStatus = MPSetPower(pAdapter,PoState);
            }
            break;
            
        case OID_1394_ISSUE_BUS_RESET:
        {
            
            TRACE( TL_V, TM_Mp, ( " OID_1394_ISSUE_BUS_RESET" ) );

            if (InformationBufferLength == sizeof(ULONG))
            {
                nicIssueBusReset (pAdapter, (*(PULONG)InformationBuffer));
            }
            else
            {
                nicIssueBusReset (pAdapter, BUS_RESET_FLAGS_FORCE_ROOT );

            }
            break;
        }        
        
        default:

            NdisStatus = NDIS_STATUS_INVALID_OID;

            *BytesRead = 0;
            *BytesNeeded = 0;

            break;

    }

    if (NdisStatus == NDIS_STATUS_SUCCESS) 
    {
        DUMPDW( TL_V, TM_Mp, InformationBuffer, InformationBufferLength );

        *BytesRead = BytesLeft;
        *BytesNeeded = 0;
    }



    TRACE( TL_T, TM_Init, ( "<==NicEthSetInformation , Adapter %.8x, Oid %.8x, NdisStatus %x",pAdapter, Oid, NdisStatus  ));

    MATCH_IRQL;

    return NdisStatus;
}



NDIS_STATUS 
NicEthQueryInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
)

/*++

Routine Description:

    This is the Query information that will be used by the CL edge

Arguments:


Return Value:


--*/
{
    UINT                    BytesLeft       = InformationBufferLength;
    PUCHAR                  InfoBuffer      = (PUCHAR)(InformationBuffer);
    NDIS_STATUS             NdisStatus      = NDIS_STATUS_SUCCESS;
    NDIS_HARDWARE_STATUS    HardwareStatus  = NdisHardwareStatusReady;
    NDIS_MEDIA_STATE        MediaState;
    NDIS_MEDIUM             Medium;
    PADAPTERCB              pAdapter;   
    ULONG                   GenericULong;
    USHORT                  GenericUShort;
    UCHAR                   GenericArray[6];
    UINT                    MoveBytes       = sizeof(GenericULong);
    PVOID                   MoveSource      = (PVOID)(&GenericULong);
    ULONG                   i;
//  PATMLANE_MAC_ENTRY      pMacEntry;
//  PATMLANE_ATM_ENTRY      pAtmEntry;
    STORE_CURRENT_IRQL;



    pAdapter = (PADAPTERCB)MiniportAdapterContext;

    TRACE( TL_T, TM_Init, ( "==>NicEthQueryInformation , Adapter %.8x, Oid %.8x",pAdapter, Oid ));

    

    //
    // Switch on request type
    //
    switch (Oid) 
    {
        case OID_GEN_MAC_OPTIONS:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MAC_OPTIONS)" ) );
            
            GenericULong = NDIS_MAC_OPTION_NO_LOOPBACK;


            break;

        case OID_GEN_SUPPORTED_LIST:

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_SUPPORTED_LIST)" ) );
            MoveSource = (PVOID)(SupportedOids);
            MoveBytes = sizeof(SupportedOids);
            break;

        case OID_GEN_HARDWARE_STATUS:

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_HARDWARE_STATUS)" ) );
            HardwareStatus = NdisHardwareStatusReady;
            MoveSource = (PVOID)(&HardwareStatus);
            MoveBytes = sizeof(NDIS_HARDWARE_STATUS);

            break;

        case OID_GEN_MEDIA_CONNECT_STATUS:

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MEDIA_CONNECT_STATUS)" ) );
            if (ADAPTER_TEST_FLAG(pAdapter, fADAPTER_RemoteNodeInThisBoot) == FALSE)
            {
                MediaState = NdisMediaStateConnected;
            }
            else
            {
                MediaState = pAdapter->MediaConnectStatus;
            }
            MoveSource = (PVOID)(&MediaState);
            
            MoveBytes = sizeof(NDIS_MEDIA_STATE);

            break;

        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MEDIA_SUPPORTED)" ) );

            Medium = g_ulMedium;

            
            MoveSource = (PVOID) (&Medium);
            MoveBytes = sizeof(NDIS_MEDIUM);

            break;

        case OID_GEN_MAXIMUM_LOOKAHEAD:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_LOOKAHEAD)" ) );
                
            GenericULong = pAdapter->MaxRecvBufferSize;
            
            break;
            
        case OID_GEN_CURRENT_LOOKAHEAD:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CURRENT_LOOKAHEAD)" ) );
            
            GenericULong = pAdapter->MaxRecvBufferSize;
        
            break;

        case OID_GEN_MAXIMUM_FRAME_SIZE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_FRAME_SIZE)" ) );
            
            GenericULong = 1512; //pAdapter->MaxRecvBufferSize;
            
            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_TOTAL_SIZE)" ) );
            
            GenericULong = 1512; //pAdapter->MaxRecvBufferSize;
            
            break;

        case OID_GEN_TRANSMIT_BLOCK_SIZE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_TRANSMIT_BLOCK_SIZE)" ) );
            
            GenericULong = pAdapter->MaxRecvBufferSize - sizeof (NDIS1394_UNFRAGMENTED_HEADER);

            break;
            
        case OID_GEN_RECEIVE_BLOCK_SIZE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_RECEIVE_BLOCK_SIZE)" ) );
            
            GenericULong = pAdapter->MaxRecvBufferSize - sizeof (NDIS1394_UNFRAGMENTED_HEADER);
            
            break;
        
        case OID_GEN_MAXIMUM_SEND_PACKETS:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_SEND_PACKETS)" ) );
            
            GenericULong = 32;      // XXX What is our limit? From adapter?
            
            break;
        
        case OID_GEN_LINK_SPEED:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_LINK_SPEED)" ) );
            
            GenericULong = pAdapter->SpeedMbps;
            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_TRANSMIT_BUFFER_SPACE)" ) );
            
            GenericULong = pAdapter->MaxSendBufferSize;;
            break;

        case OID_GEN_RECEIVE_BUFFER_SPACE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_RECEIVE_BUFFER_SPACE)" ) );
            GenericULong = pAdapter->MaxRecvBufferSize;
            break;

        case OID_GEN_VENDOR_ID:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_VENDOR_ID)" ) );

            GenericULong = 0xFFFFFFFF;
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_VENDOR_DESCRIPTION)" ) );
            MoveSource = (PVOID)"Microsoft IP/1394 Miniport";
            MoveBytes = 27;

            break;

        case OID_GEN_DRIVER_VERSION:
        case OID_GEN_VENDOR_DRIVER_VERSION:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_DRIVER_VERSION)" ) );

            GenericULong = 2;

            break;

        case OID_802_3_PERMANENT_ADDRESS:
        case OID_802_3_CURRENT_ADDRESS:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_802_3_CURRENT_ADDRESS)" ) );

            NdisMoveMemory((PCHAR)GenericArray,
                        &pAdapter->MacAddressEth,
                        sizeof(MAC_ADDRESS));
                         
            MoveSource = (PVOID)(GenericArray);
            MoveBytes = sizeof(MAC_ADDRESS);


            break;

 
        case OID_802_3_MULTICAST_LIST:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_802_3_MULTICAST_LIST)" ) );

            MoveSource = (PVOID) &pAdapter->McastAddrs[0];
            MoveBytes = pAdapter->McastAddrCount * sizeof(MAC_ADDRESS);

            break;

        case OID_802_3_MAXIMUM_LIST_SIZE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_802_3_MAXIMUM_LIST_SIZE)" ) );

            GenericULong = MCAST_LIST_SIZE;

            break;


        case OID_GEN_XMIT_OK:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_XMIT_OK)" ) );

            GenericULong = pAdapter->AdaptStats.ulXmitOk;;

            
            break;

        case OID_GEN_RCV_OK:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_RCV_OK)" ) );

            GenericULong = pAdapter->AdaptStats.ulRcvOk  ;

            
            break;
        case OID_GEN_CURRENT_PACKET_FILTER:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CURRENT_PACKET_FILTER)" ) );

            GenericULong = pAdapter->CurPacketFilter ;
            break;
            
        case OID_GEN_XMIT_ERROR:
        case OID_GEN_RCV_ERROR:
        case OID_GEN_RCV_NO_BUFFER:
        case OID_802_3_RCV_ERROR_ALIGNMENT:
        case OID_802_3_XMIT_ONE_COLLISION:
        case OID_802_3_XMIT_MORE_COLLISIONS:

            GenericULong = 0;
            TRACE( TL_V, TM_Mp, ( "QInfo oid %x", Oid ) );

            
            break;

           
        case OID_PNP_QUERY_POWER:
            TRACE( TL_V, TM_Mp, ( "QInfo OID_PNP_QUERY_POWER %x", Oid ) );

            *BytesWritten = sizeof (NDIS_DEVICE_POWER_STATE );
            *BytesNeeded = sizeof (NDIS_DEVICE_POWER_STATE  );

            NdisStatus = NDIS_STATUS_SUCCESS;
            
            break;


        case OID_1394_ISSUE_BUS_RESET:
        {
            
            TRACE( TL_V, TM_Mp, ( " OID_1394_ISSUE_BUS_RESET" ) );

            GenericULong = 0;

            if (InformationBufferLength == sizeof(ULONG))
            {
                nicIssueBusReset (pAdapter, (*(PULONG)InformationBuffer));
            }
            else
            {
                nicIssueBusReset (pAdapter, BUS_RESET_FLAGS_FORCE_ROOT );

            }
            break;
        }
        default:

            NdisStatus = NDIS_STATUS_INVALID_OID;
            break;

    }


    if (NdisStatus == NDIS_STATUS_SUCCESS) 
    {
        if (MoveBytes > BytesLeft) 
        {
            //
            // Not enough room in InformationBuffer. Punt
            //
            *BytesNeeded = MoveBytes;

            NdisStatus = NDIS_STATUS_INVALID_LENGTH;
        }
        else
        {
            //
            // Store result.
            //
            NdisMoveMemory(InfoBuffer, MoveSource, MoveBytes);

            //(*BytesWritten) += MoveBytes;
            *BytesWritten = MoveBytes;
            DUMPDW( TL_V, TM_Mp, InfoBuffer, *BytesWritten);

        }
    }


    TRACE( TL_T, TM_Init, ( "<==NicEthQueryInformation , Adapter %.8x, Oid %.8x, Status %x Bytes Written %x ",pAdapter, Oid, NdisStatus, *BytesWritten ));
    //MATCH_IRQL;
    return NdisStatus;
}




VOID
NicMpSendPackets(
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN PPNDIS_PACKET            PacketArray,
    IN UINT                     NumberOfPackets
    )
{
    PADAPTERCB              pAdapter = (PADAPTERCB)MiniportAdapterContext;
    PETHERNET_VCCB          pEthernetVc = NULL;
    BOOLEAN                 fVcActive = FALSE;
    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    NDIS_STATUS             IndicatedStatus = NDIS_STATUS_FAILURE;

    ULONG i;

    TRACE( TL_T, TM_Init, ( "==> NicMpSendPackets , Adapter %.8x, ppPacket %x, Num %x",pAdapter, PacketArray, NumberOfPackets ));

    do
    {
    

        if (pAdapter->pEthernetVc == NULL)
        {
            break;
        }


        ADAPTER_ACQUIRE_LOCK (pAdapter);
        pEthernetVc = pAdapter->pEthernetVc;

        fVcActive = VC_ACTIVE(pEthernetVc);

        if (fVcActive  == TRUE)
        {
            for (i =0 ; i < NumberOfPackets; i++)
            {
                //
                // Reference the Vc for each packet
                //
                nicReferenceCall((PVCCB)pEthernetVc, "NicMpSendPackets");
            }
        }
        
        ADAPTER_RELEASE_LOCK (pAdapter);


        if (fVcActive)
        {
                //
                //Set resource and indicate the packet array up to ndis
                //
                for (i =0 ; i < NumberOfPackets; i++)
                {
                    PNDIS_PACKET pMyPacket = NULL, pPacket = NULL;
                    PPKT_CONTEXT        pPktContext = NULL;

                    pPacket = PacketArray[i];

                    //
                    // Now allocate a new packet
                    // 
                    nicAllocatePacket (&NdisStatus, 
                                   &pMyPacket,
                                   &pEthernetVc->PacketPool);

                    if (NdisStatus != NDIS_STATUS_SUCCESS)
                    {
                        pMyPacket = NULL;
                        break;
                    }

                    //
                    // Set the original packet as the packet context 
                    //
                    pPktContext = (PPKT_CONTEXT)&pMyPacket->MiniportReservedEx; 
                    pPktContext->EthernetSend.pOrigPacket = pPacket;    

                    IndicatedStatus = NDIS_STATUS_RESOURCES;
                    NDIS_SET_PACKET_STATUS (pMyPacket, IndicatedStatus);

                    //
                    // Chain the NdisBuffers 
                    //
                    pMyPacket->Private.Head = pPacket->Private.Head;
                    pMyPacket->Private.Tail = pPacket->Private.Tail;

                    //
                    // Dump the packet
                    //
                    {
                        nicDumpPkt (pMyPacket, "Conn Less Send ");

                        nicCheckForEthArps (pMyPacket);
                    }
                    //
                    // We are in Ndis' context so we do not need a timer
                    //

                    NdisMCoIndicateReceivePacket(pEthernetVc->Hdr.NdisVcHandle, &pMyPacket,NumberOfPackets );


                    if (IndicatedStatus == NDIS_STATUS_RESOURCES)
                    {
                        //
                        //  Return Packets work
                        //

                        
                        pPktContext = (PPKT_CONTEXT)&pMyPacket->MiniportReservedEx; 
                        ASSERT ( pPacket == pPktContext->EthernetSend.pOrigPacket );

                        //
                        // Free the locally allocated packet 
                        //
                        nicFreePacket(pMyPacket, &pEthernetVc->PacketPool);
                    }   
    
                }
                
                                    
                NdisMCoReceiveComplete(pAdapter->MiniportAdapterHandle);

        }   

            

        
    }while (FALSE); 


    //
    // Regardless of success, we need to complete the sends
    //
    
    for ( i = 0 ; i < NumberOfPackets; i++)
    {
        if (fVcActive == TRUE)
        {
            nicDereferenceCall ((PVCCB)pEthernetVc, "NicMpSendPackets" );
        }
        NdisMSendComplete ( pAdapter->MiniportAdapterHandle,
                           PacketArray[i],
                           NDIS_STATUS_SUCCESS);

    }


    TRACE( TL_T, TM_Init, ( "<== NicMpSendPackets "));

}





//----------------------------------------------------------------------------
// R E M O T E    N O D E  F U N C T I O N S       S T A R T      H E R E 
//



NTSTATUS
nicAddRemoteNode(
    IN  PVOID                   Nic1394AdapterContext,          // Nic1394 handle for the local host adapter 
    IN  PVOID                   Enum1394NodeHandle,             // Enum1394 handle for the remote node      
    IN  PDEVICE_OBJECT          RemoteNodePhysicalDeviceObject, // physical device object for the remote node
    IN  ULONG                   UniqueId0,                      // unique ID Low for the remote node
    IN  ULONG                   UniqueId1,                      // unique ID High for the remote node
    OUT PVOID *                 pNic1394NodeContext             // Nic1394 context for the remote node
    )
    // Function Description:
    // This function does updates all the required nic1394 data structures to signal the arrival
    // of a new remote node. Inserts itself into the correct list and allocates an address range 
    // for itself.
    //
    // Arguments
    // pAdapter - Adapter structure
    // UINT64 Unique Id associated with the remote node
    //
    // Return Value:
    // Out is the pointer to the Pdo Control block that will be sent as a context for the Remove routine

{
    NTSTATUS    Status = STATUS_SUCCESS;
    REMOTE_NODE *pRemoteNode = NULL;
    PADAPTERCB  pAdapter = (PADAPTERCB)Nic1394AdapterContext;
    UINT64 RemoteNodeUniqueId;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    BOOLEAN fNeedToRequestResetNotification = FALSE;
    ULONG Generation = 0;
    BOOLEAN fIsOnlyNode  = FALSE;

    STORE_CURRENT_IRQL;
    

    
    RemoteNodeUniqueId = 0;

    RemoteNodeUniqueId = UniqueId0;
    RemoteNodeUniqueId = RemoteNodeUniqueId<<32;    
    RemoteNodeUniqueId = RemoteNodeUniqueId | UniqueId1 ;

   
    
    TRACE( TL_N, TM_Mp, ( "** nicAddRemoteNode Remote %.8x, UniqueId %I64x", RemoteNodePhysicalDeviceObject, RemoteNodeUniqueId) );

    // Initialize a PdoCb with the 1394 Pdo and insert it into the Pdo list
    //
    do
    {
        NdisStatus = NicInitializeRemoteNode(&pRemoteNode,
                                             RemoteNodePhysicalDeviceObject,
                                             RemoteNodeUniqueId);

        *pNic1394NodeContext = pRemoteNode;

        if (NdisStatus!=NDIS_STATUS_SUCCESS)
        {
            TRACE(  TL_A, TM_Mp, ( "NicMpInitializePdoCb FAILED %.8x", RemoteNodePhysicalDeviceObject) );
            break;
        }

        pRemoteNode->pAdapter = pAdapter;
        pRemoteNode->Enum1394NodeHandle = Enum1394NodeHandle;

        pAdapter->MediaConnectStatus = NdisMediaStateConnected;

        //
        // We need to go through the RecvFiFo List and get allocate any address ranges on this pdo as well
        //
        ADAPTER_ACQUIRE_LOCK (pAdapter);
        //
        // Increment the Refcount. This signifies that the pRemoteNode has been created and will
        // be derefed only when the nic gets a notification of removal. 
        //
    
        pRemoteNode->pAdapter = pAdapter;

        //
        // Add a reference to the adapter as the Pdo Block, now has a pointer to it
        // Will be derefed in the RemoveRemoteNode
        //
        nicReferenceAdapter (pAdapter, "nicAddRemoteNode");

        //
        // Figure out if there are no remote node in the Adapter's list. that will make this node the only remote node
        // and we will have to kickstart the BCM algorithm
        //
        fIsOnlyNode  = IsListEmpty (&pAdapter->PDOList);

        TRACE( TL_V, TM_Mp, ( "   nicAddRemoteNode: fIsOnlyNode  %x", fIsOnlyNode ) );

        //
        // Insert the PDO into the adapter's RemoteNode List
        //

        InsertTailList (&pAdapter->PDOList, &pRemoteNode->linkPdo);        

        NdisInterlockedIncrement (&pAdapter->AdaptStats.ulNumRemoteNodes);

        //
        // Increment the ref on the Pdo block as the adapter, now has a pointer to it
        // Will be derefed whereve the remote node is popped of the list 
        //
        nicReferenceRemoteNode (pRemoteNode, "nicAddRemoteNode");

        //
        // Now set the flag that the Pdo Block is activated, and that
        // it is ready to receive Irps
        //
        REMOTE_NODE_SET_FLAG (pRemoteNode, PDO_Activated);

        

        ADAPTER_RELEASE_LOCK (pAdapter);




        {       

            NODE_ADDRESS RemoteNodeAddress;


            NdisStatus = nicGet1394AddressOfRemoteNode( pRemoteNode,
                                                        &RemoteNodeAddress,
                                                              0 );

            if (NdisStatus == NDIS_STATUS_SUCCESS)
            {
                
                TRACE( TL_V, TM_Mp, ( "   RemoteNode %x , NodeAddress %", 
                                          pRemoteNode, RemoteNodeAddress.NA_Node_Number) );
                                          
                ADAPTER_ACQUIRE_LOCK (pAdapter);

                pAdapter->NodeTable.RemoteNode[RemoteNodeAddress.NA_Node_Number] = pRemoteNode; 

                pRemoteNode->RemoteAddress = RemoteNodeAddress;

                ADAPTER_RELEASE_LOCK (pAdapter);

            
            }
            else
            {
                ASSERT (!" Unable to get Address from remote node");

                //
                // Do not fail the Add Node
                //

                REMOTE_NODE_SET_FLAG (pRemoteNode, PDO_NotInsertedInTable);

                NdisStatus = NDIS_STATUS_SUCCESS;
            }

        }

        //
        // Update the local host's speed values
        //
        nicUpdateLocalHostSpeed (pAdapter);

        //
        // Update the remote node's cached caps.
        //
        {
            UINT SpeedTo;
            UINT EffectiveMaxBufferSize;
            UINT MaxRec;


            // Specifying FALSE (!from cache) below causes pRemoteNode's cached caps
            // to be refreshed. Ignore return value.
            //
            (VOID) nicQueryRemoteNodeCaps (pAdapter,
                                          pRemoteNode,
                                          &SpeedTo,
                                          &EffectiveMaxBufferSize,
                                          &MaxRec
                                          );
        }

        //
        // We have received a remote node in this boot. 
        // Set the flag. No need to hold the lock
        //
        ADAPTER_SET_FLAG(pAdapter, fADAPTER_RemoteNodeInThisBoot);
    
        //
        // Kick start the BCM algorithm if this is the only node in the Adapter's list.  also need to initialize the BCR
        // if necessary. All done in this BCMAddRemoteNode function
        //
        nicBCMAddRemoteNode (pAdapter, 
                             fIsOnlyNode );

        //
        // Inform the protocols of this new node, so that
        // it can query us for a new Euid Map
        //
        nicInformProtocolsOfReset(pAdapter);

    }while (FALSE);

    
    TRACE( TL_T, TM_Mp, ("<==nicAddRemoteNode Remote %.8x, Status %.8x", RemoteNodePhysicalDeviceObject, Status));

    MATCH_IRQL;
    return NdisStatus;

}






VOID
nicAddRemoteNodeChannelVc (
    IN PADAPTERCB pAdapter, 
    IN PREMOTE_NODE pRemoteNode
    )
    // Function Description:
    //   Do Nothing for now
    //
    //  Called with the lock held
    // Arguments
    //   pADapter - Local host
    //  pRemoteNode - Remote Node being added
    //
    // Return Value:
    //  None;
    //
    //
{
    PLIST_ENTRY         pVcListEntry = NULL;
    PLIST_ENTRY         pAfListEntry = NULL;
    PVCCB               pVc = NULL;
    PCHANNEL_VCCB       pChannelVc = NULL; 
    PAFCB               pAf = NULL;

    TRACE( TL_T, TM_Mp, ("==>nicAddRemoteNodeChannelVc pAdapter %x, pRemoteNode %x", pAdapter, pRemoteNode ) );

    
    TRACE( TL_T, TM_Mp, ("<==nicAddRemoteNodeChannelVc pAdapter %x, pRemoteNode %x", pAdapter, pRemoteNode ) );


}
        


        
VOID
nicDeleteLookasideList (
    IN OUT PNIC_NPAGED_LOOKASIDE_LIST pLookasideList
    )
{
    TRACE( TL_T, TM_Cm, ( "==> nicDeleteLookasideList  pLookaside List %x", pLookasideList ) );

    if (pLookasideList)
    {
        ASSERT (pLookasideList->OutstandingPackets == 0);
        
        NdisDeleteNPagedLookasideList (&pLookasideList->List);
    }

    TRACE( TL_T, TM_Cm, ( "<== nicDeleteLookasideList pLookaside List %x", pLookasideList) );
    
}







NDIS_STATUS
nicFreeRemoteNode(
    IN REMOTE_NODE *pRemoteNode 
    )

    // Function:
    // Frees the memory cocupied by a PdoCb
    // Argument:
    // PdoControl Block
    // Return Value, Always Success

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    
    TRACE( TL_T, TM_Mp, ( "==>nicFreeRemoteNodepRemoteNode %.8x", pRemoteNode ) );

    ASSERT (pRemoteNode->Ref.ReferenceCount == 0);

    nicFreeNicSpinLock  (&pRemoteNode->ReassemblyLock);

    nicSetFlags (&pRemoteNode->ulFlags, PDO_Removed);

    nicClearFlags (&pRemoteNode->ulFlags, PDO_BeingRemoved);

    pRemoteNode->pPdo = NULL;

    pRemoteNode->ulTag = MTAG_FREED;

    FREE_NONPAGED (pRemoteNode);
    
    TRACE( TL_T, TM_Mp, ( "<==nicFreeRemoteNode" ) );

    return NdisStatus;
}






VOID
nicInitializeLookasideList(
    IN OUT PNIC_NPAGED_LOOKASIDE_LIST pLookasideList,
    ULONG Size,
    ULONG Tag,
    USHORT Depth
    )
/*++

Routine Description:
  Allocates and initializes a nic Lookaside list

Arguments:


Return Value:


--*/
{
    TRACE( TL_T, TM_Cm, ( "==> nicInitializeLookasideList pLookaside List %x, size %x, Tag %x, Depth %x, ", 
                             pLookasideList, Size, Tag, Depth) );
                             
    NdisInitializeNPagedLookasideList( &pLookasideList->List,
                                       NULL,                        //Allocate 
                                       NULL,                            // Free
                                       0,                           // Flags
                                       Size,
                                       MTAG_CBUF,
                                       Depth );                             // Depth

    pLookasideList->Size =  Size;


    TRACE( TL_T, TM_Cm, ( "<== nicInitializeLookasideList " ) );
}   
                                  






NDIS_STATUS
NicInitializeRemoteNode(
    OUT REMOTE_NODE **ppRemoteNode,
    IN   PDEVICE_OBJECT p1394DeviceObject,
    IN   UINT64 UniqueId 
    )

/*++

Routine Description:

    This function allocates and initializes a control block for the Device Object
    that is being passed . Also sets the initalize flag and, intialized the Vc List 
    Copies the unique id,  Initializes the reassembly structures ( lock and list)


Arguments:

    pRemoteNode - Pointer to remote node that was allocated
    pDevice Object for the remote node
    Unique Id - UID of the  remote node
    
Return Value:
    Resources - if the Allocation failed
    Success - otherwise
--*/

{

    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    PREMOTE_NODE pRemoteNode = NULL;

    TRACE( TL_T, TM_Mp, ( "==>NicInitializeRemoteNode PDO %.8x UniqueId %I64x", p1394DeviceObject, UniqueId) );

    do
    {
        pRemoteNode = ALLOC_NONPAGED( sizeof(REMOTE_NODE), MTAG_REMOTE_NODE);
        
        if (pRemoteNode == NULL)
        {

            TRACE( TL_A, TM_Mp, ( "Memory Allocation for Pdo Block FAILED" ) );
            *ppRemoteNode = NULL;
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Zero out the strcuture
        //
        NdisZeroMemory ( pRemoteNode , sizeof(REMOTE_NODE) ); 

        //
        // Set up the tag
        //
        pRemoteNode ->ulTag = MTAG_REMOTE_NODE;

        //
        // Set up the  remote device's PDO
        //
        pRemoteNode ->pPdo = p1394DeviceObject;

        //
        // Set up the Unique ID
        //
        pRemoteNode ->UniqueId = UniqueId;

        //
        // Set up a Fake Mac Address for the Unique ID
        //
        nicGetMacAddressFromEuid(&UniqueId, &pRemoteNode->ENetAddress) ;
        //
        // Initialize the VC that are open on this Remote Node
        //
        InitializeListHead ( &(pRemoteNode->VcList));

        //
        // Initialize the ref count
        //
        nicInitializeRef (&pRemoteNode->Ref);

        //
        // allocate the spin lock to control reassembly
        //
        nicInitializeNicSpinLock (&(pRemoteNode ->ReassemblyLock));
        
        //
        //  list for all reassemblies happenning on the remote node
        //
        InitializeListHead (&pRemoteNode->ReassemblyList);

        *ppRemoteNode = pRemoteNode ;
                                   
    } while (FALSE);
     
    TRACE( TL_T, TM_Mp, ( "<==NicInitializeRemoteNode, Status %.8x, pRemoteNode %.8x", NdisStatus, *ppRemoteNode) );

    return NdisStatus;
}



VOID
nicNoRemoteNodesLeft (
    IN PADAPTERCB pAdapter
    )
    // Function Description:
    //  Called from the RemoveRemote Node codepath
    //   This means that the last node has gone away.
    //   We need to clean out all the BroadcastChannel's register
    //   so that the next incoming node does not read incorrect values.
    //   Check to see if a BCM algorithm is not in progress
    // Arguments
    //   pADpater - Local host
    //
    // Return Value:
    //
{
    BOOLEAN fBCMInProgress;
    ADDRESS_RANGE_CONTEXT BCRAddressRange;
    
    TRACE( TL_T, TM_Bcm, ( "==>nicNoRemoteNodesLeft  pAdapter %x  ",pAdapter ) );

    
    pAdapter->MediaConnectStatus = NdisMediaStateDisconnected;

    if (ADAPTER_TEST_FLAG( pAdapter, fADAPTER_Halting) == FALSE)
    {
        nicMIndicateStatus ( pAdapter,NDIS_STATUS_MEDIA_DISCONNECT, NULL,0);  
    }




    TRACE( TL_T, TM_Bcm, ( "<==nicNoRemoteNodesLeft  pAdapter %x  ",pAdapter ) );

}






VOID
nicReallocateChannels (
    IN PNDIS_WORK_ITEM pWorkItem,   
    IN PVOID Context 
    )
    // Function Description:
    //   Walk through all the channel VCs and reallocate all their respective channels
    //   Except the BCM channel . the BCM will reallocate this 
    //
    //   Tell the protocol that the 1394 bus has been reset. after all the channels have 
    //   been allocated
    //
    // Arguments
    // Context= pRemoteNode - that is still around
    //
    // Return Value:
    //  None
{
    ULONGLONG           ChannelsAllocatedByLocalHost = 0;
    ULONG               Channel = 0;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PADAPTERCB          pAdapter = (PADAPTERCB) Context; 
    ULONGLONG           One = 1;


    TRACE( TL_T, TM_Mp, ( "==>nicReallocateChannels pAdpater %x", pAdapter) );


    
    TRACE( TL_V, TM_Mp, ("  nicReallocateChannels ChannelsAllocatedByLocalHost %I64x ", ChannelsAllocatedByLocalHost) );

    Channel =0;
    while (Channel < 64)
    {
        //
        // Does the channel 'i' need to be allocated
        //
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        ChannelsAllocatedByLocalHost  = pAdapter->ChannelsAllocatedByLocalHost ;

        ADAPTER_RELEASE_LOCK (pAdapter);
        
        if ( (( g_ullOne<<Channel ) & ChannelsAllocatedByLocalHost) == TRUE) 
        {
            if (Channel == BROADCAST_CHANNEL)
            {
                //
                // The broadcast channel will  be allocated by the BCM. skip it.
                //
                continue;
            }
            NdisStatus = nicAllocateChannel (pAdapter,
                                             Channel,
                                             NULL);

            //
            // If allocation fails ... Have not implemented recovery yet.
            //
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                ASSERT (NdisStatus == NDIS_STATUS_SUCCESS)
            }
        }
    
        Channel ++;
    }

#if 0 // We don't need this currently
    //
    // Pick up the remote node info for all remote nodes.
    //
    nicUpdateRemoteNodeCaps(pAdapter);
#endif // 0

    //
    // Now that the channels are reallocated, inform the protocols of the reset
    //

    nicInformProtocolsOfReset(pAdapter);
    
    
    //
    // Dereference the ref that was added prior to scheduling this workitem
    //
    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);

    nicDereferenceAdapter(pAdapter, "nicResetReallocateChannels ");


    FREE_NONPAGED(pWorkItem);
    
    TRACE( TL_T, TM_Mp, ( "<==nicReallocateChannels "  ) );


}






NDIS_STATUS
nicRemoteNodeRemoveVcCleanUp(
    IN REMOTE_NODE  *pRemoteNode
    )

    // Function Description:
    //
    // This function walks through the Pdo's Vc list annd closes 
    // the calls on each of them. These are SendFIFO VCs 
    // Channel VC's will not be closed when the remote node is removed.
    // This is typically called from a remove remote node function
    //
    // Arguments
    //  PdoCb Pdo Control block that is getting removed
    //
    // Return Value:
    // Always Success
    //
    // Called with the lock held
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PVCCB pVc = NULL;
    PLIST_ENTRY pVcList = NULL;
    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Mp, ( "==>nicRemoteNodeRemoveVcCleanUp pRemoteNode %.8x", pRemoteNode ) );

    pVcList = ListNext (&pRemoteNode->VcList);

    while (pVcList != &pRemoteNode->VcList)
    {

        pVc = (VCCB*) CONTAINING_RECORD (pVcList, VCHDR, SinglePdoVcLink);

        //
        // move to the next Vc in the list
        //
        pVcList = ListNext (pVcList);


        TRACE( TL_V, TM_Mp, ( "   nicRemoteNodeRemoveVcCleanUp VcType %x",pVc->Hdr.VcType  ) );

        
        switch(pVc->Hdr.VcType)
        {
            case NIC1394_SendRecvChannel:
            case NIC1394_RecvChannel:
            case NIC1394_SendChannel:
            {
                PCHANNEL_VCCB pChannelVc = (PCHANNEL_VCCB)pVc;
                PREMOTE_NODE pNewChannelNode = NULL;
                //
                // Nothing to do here now
                //
                break;                                      
            }

            case NIC1394_SendFIFO:
            {   
                //
                // We know that it is a Send FIFO and the call needs to be closed
                //
                VC_SET_FLAG (pVc, VCBF_VcDispatchedCloseCall);


                //
                // This is to guarantee that we have the Vc Structure around at the end of the call
                //
                
                nicReferenceVc (pVc);

                REMOTE_NODE_RELEASE_LOCK (pRemoteNode);

                TRACE( TL_V, TM_Mp, ( "Dispatching a close call for Vc%.8x ",pVc ) );

                
                NdisMCmDispatchIncomingCloseCall (NDIS_STATUS_SUCCESS,
                                              pVc->Hdr.NdisVcHandle,
                                              NULL,
                                              0 );
                                               
                REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);

                //
                // Deref the ref made above.
                //
                nicDereferenceVc (pVc);

                break;
            }

            default:
            {   
                //
                // There should be no other VC types here
                //
                
                TRACE( TL_A, TM_Mp, ( "  Invalid VC  %x Type nicRemoteNodeRemoveVcCleanUp ", pVc ) );
                
                ASSERT (0);

            }
                    
        }


    }


    MATCH_IRQL;
    TRACE( TL_T, TM_Mp, ( "<==nicRemoteNodeRemoveVcCleanUp " ) );

    
    return NDIS_STATUS_SUCCESS;

}








NTSTATUS
nicRemoveRemoteNode(
    IN  PVOID                   Nic1394NodeContext      // Nic1394 context for the remote node
    )
    // Function Description:
    // This function does all the hard work when the nic gets notification
    // of a remote node going away.
    // Closes all calls on the Pdo ,
    // Removes the Remote Node from the adapter's listPdo
    // frees all the reassemblies on this node
    // and then waits for the refcount to go to zero
    //
    // Arguments
    // Nic1394NodeContext      : The Remote Node that is going away 
    //
    // Return Value:
    // Success: if all calls succeed
    //
    //
    //
    

{
    NDIS_STATUS     NdisStatus = NDIS_STATUS_FAILURE;
    NTSTATUS        Status = STATUS_SUCCESS;
    PREMOTE_NODE    pRemoteNode = (REMOTE_NODE *)Nic1394NodeContext;
    PADAPTERCB      pAdapter = pRemoteNode->pAdapter;
    BOOLEAN         bWaitEventSignalled = FALSE;
    PLIST_ENTRY     pVcListEntry = NULL;
    PVCCB           pVc = NULL;
    BOOLEAN         FreeAddressRange = TRUE;
    BOOLEAN         fIsPdoListEmpty = FALSE;
    LIST_ENTRY      ReassemblyList;

    STORE_CURRENT_IRQL;


    
    TRACE( TL_T, TM_Mp, ( "  ** nicRemoveRemoteNode Node Context %x , Pdo  %x",Nic1394NodeContext, pRemoteNode->pPdo    ) );


    do 
    {
        pAdapter->pLastRemoteNode = pRemoteNode;

        REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);

        //
        // We should tell everyone that the Pdo is being removed. However keep the node active      
        // because there are Vc's which might need to submit Irps
        //
        REMOTE_NODE_SET_FLAG (pRemoteNode, PDO_BeingRemoved);

        //
        // Dispatch Close call requests for active calls on this Pdo. 
        // However, keep the VCs in the pdocb's list
        // The NicCmCloseCall is the only function that removes Pdo's from the list
        // Will need to free the address range for any recv Vcs seperately
        //
        NdisStatus = nicRemoteNodeRemoveVcCleanUp (pRemoteNode);



        //
        // Remove the remote node from the RemoteNode Table
        //
        //
        nicRemoveRemoteNodeFromNodeTable(&pAdapter->NodeTable,pRemoteNode);

        //
        // Free All reassembly operations on this remopte node
        // 
        nicFreeReassembliesOnRemoteNode (pRemoteNode, &ReassemblyList);
        
        //
        // Dereference the ref that was added when the Pdo block was inserted in the Adapter's list
        // The actual removal will take place later. We still have close calls to be completed and they
        // will need the PdoCb. So it remains in the adapter's queue
        //
        nicDereferenceRemoteNode (pRemoteNode, "nicRemoveRemoteNode");
        
        //
        // Need to Deref the Reference made in NicInitializeRemoteNode function
        //
        nicDereferenceRemoteNode (pRemoteNode, "nicRemoveRemoteNode");

        //
        // Dequeue the remote node here
        //

        nicRemoveEntryList (&pRemoteNode->linkPdo);

        NdisInterlockedDecrement (&pAdapter->AdaptStats.ulNumRemoteNodes);

        //
        // If this was the last remote node, then some special cleaning will be done
        //
        fIsPdoListEmpty = IsListEmpty (&pAdapter->PDOList);
    
        TRACE( TL_T, TM_Mp, ( "  nicRemoveRemoteNode fIsOnlyNode %x ",fIsPdoListEmpty ) );

        
        REMOTE_NODE_RELEASE_LOCK (pRemoteNode);
        
        //
        // Now, we wait forever for all the reference to go away
        //
        TRACE( TL_V, TM_Mp, ( "About ot Wait RemoteNode Ref's to go to zero" ) );
        
        
        bWaitEventSignalled = NdisWaitEvent (&pRemoteNode->Ref.RefZeroEvent, ONE_MINUTE);

        if (bWaitEventSignalled == FALSE)
        {
            //
            // Our WaitEvent timed out. Will need to fail gracefully. For now assert(0)
            //
            TRACE( TL_A, TM_Mp, ( "Wait Timed Out pRemoteNode %.8x, RefCount %.8x ", 
                                   pRemoteNode, pRemoteNode->Ref.ReferenceCount) );

            ASSERT (bWaitEventSignalled == TRUE);

        }

        TRACE( TL_V, TM_Mp, ( "Wait Succeeded Ref == 0, pRemoteNode %.8x, RefCount %.8x ", 
                              pRemoteNode, pRemoteNode->Ref.ReferenceCount) );
            
        
        //
        // If this was the last node, and the remote node list is empty, we need to clean up the BCR
        //
        if (fIsPdoListEmpty == TRUE)
        {
            nicNoRemoteNodesLeft (pAdapter);
        }

        //
        // Delete the reassemblies that belong to this remote node and free them
        //
        if (IsListEmpty (&ReassemblyList) == FALSE)
        {
            nicAbortReassemblyList (&ReassemblyList);
        }

        nicFreeRemoteNode(pRemoteNode);

        //
        // Now update the speed on the adapter
        //

        nicUpdateLocalHostSpeed(pAdapter);

        //
        // Inform the protocols of the node removal, so that
        // it can query us for a new Euid Map
        //
        nicInformProtocolsOfReset(pAdapter);


        //
        // Careful this could cause the adapter refcounts to go to zero
        //
        nicDereferenceAdapter(pAdapter, "nicRemoveRemoteNode ");


    } while (FALSE);

    
    TRACE( TL_T, TM_Mp, ( "<== nicRemoveRemoteNode Status %.8x ", 
                               NdisStatus ) );

    MATCH_IRQL;
    

    return NDIS_STATUS_SUCCESS;

}



VOID
nicResetNotificationCallback (                
    IN PVOID pContext               
    )
    // Function Description:
    //  This routine will be called whenever  the bus is reset. 
    //  It will be called at DISPATCH Level
    // 
    // Arguments
    //  Context : a Remote Node
    //
    //
    // Return Value:
    //  None
{
    PADAPTERCB pAdapter = (PADAPTERCB) pContext;
    BOOLEAN fNeedToQueueBCMWorkItem = FALSE; 
    
    TRACE( TL_T, TM_Mp, ( "==>nicResetNotificationCallback Context %.8x ", pContext ) );

    NdisInterlockedIncrement (&pAdapter->AdaptStats.ulNumResetCallbacks);       
    pAdapter->AdaptStats.ulResetTime = nicGetSystemTime();

    //NdisInterlockedIncrement (&pAdapter->Generation);

    TRACE( TL_I, TM_Mp, ( "    BUS RESET Callback Context %x, Old Gen %x ", pContext , pAdapter->Generation) );

    //
    // Restart the BCM
    //
            
    nicResetRestartBCM (pAdapter);
    //
    // reallocate all channels that were opened by this node
    //
    nicResetReallocateChannels( pAdapter);      

    
    //
    // Invalidate all pending reassemblies
    //
    nicFreeAllPendingReassemblyStructures(pAdapter);


    TRACE( TL_T, TM_Mp, ( "<==nicResetNotificationCallback " ) );


}



VOID 
nicResetReallocateChannels (
    IN PADAPTERCB pAdapter
    )
    // Function Description:
    //   Fires off a workitem to reallocate channels. ONLY To be called from a reset.
    //   because it causes an indication to the protocols, once all the channels have
    //   been re-allocated
    //
    // Arguments
    //  Adapter: Local Adapter
    //
    //
    // Return Value:
    //  None
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS_WORK_ITEM pResetChannelWorkItem;
    
    TRACE( TL_T, TM_Mp, ( "==>nicResetReallocateChannels  " ) );

    //
    // reference the adapter as it is going to passed to a workiter.
    // decremented in the workitem
    //
    nicReferenceAdapter(pAdapter, "nicResetReallocateChannels");

    do
    {
    
        pResetChannelWorkItem = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM); 

                    
        if (pResetChannelWorkItem== NULL)
        {
            TRACE( TL_A, TM_Cm, ( "nicResetReallocateChannels : Local Alloc failed for WorkItem" ) );
    
            NdisStatus = NDIS_STATUS_RESOURCES;
    
            break;
        }
        else
        {   
            //
            // From here on, this function cannot fail.
            //
            NdisStatus = NDIS_STATUS_SUCCESS;
        }

                             
            
        NdisInitializeWorkItem ( pResetChannelWorkItem, 
                                 (NDIS_PROC) nicReallocateChannels ,
                                 (PVOID) pAdapter);

        TRACE( TL_V, TM_Cm, ( "Scheduling Channels WorkItem" ) );
                                
        NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);
            
        NdisScheduleWorkItem (pResetChannelWorkItem);


    } while (FALSE);


    TRACE( TL_T, TM_Mp, ( "<==nicResetReallocateChannels %x  ", NdisStatus ) );

}




VOID
nicResetRestartBCM (
    IN PADAPTERCB pAdapter
    )

    // Function Description:
    //   Clean up the adapter's data structure and restart the BCM algorithm
    //
    // Arguments
    //  Adapter: Local Adapter
    //
    //
    // Return Value:
    //  None
{

    TRACE( TL_T, TM_Mp, ( "==>nicResetRestartBCM  pAdpater %x", pAdapter ) );

    //
    // We might have a thread waiting in FindIrmAmongRemoteNodes. .. Let it go and make it
    // abort the BCM
    //
    
    pAdapter->BCRData.BCRWaitForNewRemoteNode.EventCode = nic1394EventCode_BusReset;

    NdisSetEvent (&pAdapter->BCRData.BCRWaitForNewRemoteNode.NdisEvent);

    //
    // Now set up the data structures so we can restart the BCM for this generation
    //
    ADAPTER_ACQUIRE_LOCK(pAdapter);

    pAdapter->BCRData.LocalHostBCRBigEndian = BCR_IMPLEMENTED_BIG_ENDIAN;

    pAdapter->BCRData.IRM_BCR.NC_One = 1;
    pAdapter->BCRData.IRM_BCR.NC_Valid  = 0;
    pAdapter->BCRData.IRM_BCR.NC_Channel  = 0x3f; 

    //
    // Clear the flags that are only valid through a single run of the BCM algorithm
    //
    BCR_CLEAR_FLAG (pAdapter, BCR_BCMFailed | BCR_LocalHostBCRUpdated | BCR_ChannelAllocated | BCR_LocalHostIsIRM);
    //
    // This will inform any BCM algorithm that a new reset happened
    //
    ADAPTER_SET_FLAG (pAdapter, fADAPTER_InvalidGenerationCount);

    
    ADAPTER_RELEASE_LOCK(pAdapter);

    //
    // Now reschedule a work item to do the BCM algorithm
    //
    TRACE( TL_A, TM_Bcm , ("Reset - scheduling the BCM" ) );
    nicScheduleBCMWorkItem(pAdapter);

    TRACE( TL_T, TM_Mp, ( "<==nicResetRestartBCM  " ) );

}







VOID
nicBusResetWorkItem(
    NDIS_WORK_ITEM* pResetWorkItem,     
    IN PVOID Context 
    )
{


    PADAPTERCB pAdapter= (PADAPTERCB) Context; 

    TRACE( TL_T, TM_Mp, ( "==>nicBusResetWorkItem " ) );
    

    nicBusReset (pAdapter,
                BUS_RESET_FLAGS_FORCE_ROOT );


    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);

    nicDereferenceAdapter(pAdapter, "nicBusResetWorkItem");
    
    TRACE( TL_T, TM_Mp, ( "<==nicBusResetWorkItem" ) );


    FREE_NONPAGED (pResetWorkItem);


}
    




VOID
nicIssueBusReset (
    PADAPTERCB pAdapter,
    ULONG Flags
    )

    // Function Description:
    //   Picks up a PDO and issues a bus reset on that PDO
    //   As this can come down through an NdisRequest, it can be at IRQL <=DISPATCH_LEVEL
    // Arguments
    //   pAdapter - Local Host in question
    //
    // Return Value:
    //  Success - If Irp succeeded. Appropriate Error code otherwise
    //
    //
{
    PREMOTE_NODE pRemoteNode = NULL;

    TRACE( TL_T, TM_Mp, ( "==> nicIssueBusReset %x ",Flags ) );

    if (PASSIVE_LEVEL == KeGetCurrentIrql () )
    {
        nicBusReset (pAdapter, Flags);          

    }
    else
    {
        //
        // Dereferenced in the workitem
        //
        
        nicReferenceAdapter (pAdapter, "nicIssueBusReset ");

        do
        {
            PNDIS_WORK_ITEM pReset;
            pReset = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM); 

        
            if (pReset == NULL)
            {
                TRACE( TL_A, TM_Cm, ( "Local Alloc failed for WorkItem" ) );
        
                break;
            }

                
        
            NdisInitializeWorkItem ( pReset, 
                                     (NDIS_PROC)nicBusResetWorkItem,
                                      (PVOID)pAdapter);

            TRACE( TL_A, TM_Cm, ( "Setting WorkItem" ) );
                                        
            NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);
            
            NdisScheduleWorkItem (pReset);

        }while (FALSE);


    }

    TRACE( TL_T, TM_Mp, ( "<== nicIssueBusReset " ) );


}







VOID
nicUpdateLocalHostSpeed (
    IN PADAPTERCB pAdapter
    )

/*++

Routine Description:
  Updates the speed for the local host and updates the payload for 
  all ChannelVCs 

  This also updates the SCode that goes to the ARP module..
  The SCode will never be updated unless this function is called
  via the BCM algorithm

  
Arguments:


Return Value:


--*/


{
    NDIS_STATUS                 NdisStatus = NDIS_STATUS_FAILURE;
    PREMOTE_NODE                pRemoteNode = NULL;
    PDEVICE_OBJECT              Node[64];
    ULONG                       Num = 0;
    PREMOTE_NODE                pTempNode;
    PLIST_ENTRY                 pListEntry  = ListNext(&pAdapter->PDOList);
    ULONG                       SpeedMbps = 10000000;
    ULONG                       PrevSpeed = pAdapter->Speed;
    ULONG                       Speed =0;
    ULONG                       MaxRecvBufferSize = 0;
    ULONG                       MaxSendBufferSize = 0;
    ULONG                       SCode = 0;
    
    TRACE( TL_T, TM_Bcm, ( "==> nicUpdateLocalHostSpeed " ) );


    do
    {
        NdisZeroMemory (&Node[0], 64*sizeof(PVOID) );
        
        while (pListEntry != &pAdapter->PDOList)
        {
            pTempNode = CONTAINING_RECORD (pListEntry,
                                           REMOTE_NODE,
                                           linkPdo);

            if (REMOTE_NODE_ACTIVE (pTempNode) == TRUE)
            {
                //
                // Add this node to our array as it is valid
                //
                Num++;
                
                Node[Num-1] = pTempNode->pPdo;


            }
                                                                   
            pListEntry = ListNext (pListEntry); 

        } // End of while loop

        if (Num >63 || Num == 0)
        {
            TRACE (TL_I, TM_Mp, ("Invalid Num OfRemoteNodes %x", Num) );
            Speed = 0;
            break;
        }
        
        NdisStatus = nicGetMaxSpeedBetweenDevices( pAdapter,
                                                    Num,
                                                    Node,
                                                    &Speed);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {   
            Speed = 0;
            BREAK (TM_Mp, ("nicUpdateLocalHostSpeed : nicGetMaxSpeedBetweenDevices FAILED") );
        }

        //
        // By looking at the speed constants 1 -> 100Mbps
        //
        SpeedMbps = Speed*1000000;

        //
        // update the scode -- default 400. 
        // As 400+ hardware is prototype from WinXP, we default to 400 for now
        //
        SCode = SCODE_400_RATE;

        if (Speed > SPEED_FLAGS_400)
        {
            Speed = SPEED_FLAGS_400;
        }
       
        switch (Speed)
        {
            case SPEED_FLAGS_400 :
            {
                SCode = SCODE_400_RATE ;
                MaxRecvBufferSize = ISOCH_PAYLOAD_400_RATE;
                MaxSendBufferSize = ASYNC_PAYLOAD_400_RATE;
                break;
            }
            case SPEED_FLAGS_100 :
            {
                SCode = SCODE_100_RATE;
                MaxRecvBufferSize = ISOCH_PAYLOAD_100_RATE;
                MaxSendBufferSize = ASYNC_PAYLOAD_100_RATE;

                break;
            }
            case SPEED_FLAGS_200 :
            {
                SCode = SCODE_200_RATE;
                MaxRecvBufferSize = ISOCH_PAYLOAD_200_RATE;
                MaxSendBufferSize = ASYNC_PAYLOAD_200_RATE;

                break;
            }
            
            default:
            {
                SCode = SCODE_400_RATE ;
                MaxRecvBufferSize = ISOCH_PAYLOAD_400_RATE;
                MaxSendBufferSize = ASYNC_PAYLOAD_400_RATE;
                break;
            }


        }
        
        ADAPTER_ACQUIRE_LOCK(pAdapter);

        pAdapter->Speed = Speed;
        pAdapter->SpeedMbps = SpeedMbps;
        pAdapter->SCode = SCode;
        pAdapter->MaxRecvBufferSize = MaxRecvBufferSize;
        pAdapter->MaxSendBufferSize = MaxSendBufferSize;

        ADAPTER_RELEASE_LOCK (pAdapter);
        
        TRACE( TL_V, TM_Mp, ( "  nicUpdateLocalHostSpeed Speed returned %d",SpeedMbps  ) );


        //
        // Now update the speed value in all the channel VC's as they are dependent on this parameter
        // 
        
        if (Speed == PrevSpeed || 
            Speed > SPEED_FLAGS_1600 )

        {
            //
            // either the speed has not changed or it has invalid value, break out
            //
            TRACE (TL_V, TM_Init, ("Will not update - Speed %x, Prev Speed %x", Speed, PrevSpeed) );
            break;
        }

        //
        // The speed  and the payload have changed. Update all the channel Vc's
        // and Recv FIFOVc's payload
        //


        nicUpdateSpeedInAllVCs (pAdapter,
                             Speed
                             );


        
    } while (FALSE);



    TRACE( TL_T, TM_Mp, ( "<== nicUpdateLocalHostSpeed SpeedCode %x, Num %x" , pAdapter->Speed, Num) );


}

VOID
nicUpdateSpeedInAllVCs (
    PADAPTERCB pAdapter,
    ULONG Speed
    )
/*++

Routine Description:

 This routine updates the speed flag in all Channel Vcs
 It assumes that the new speed is different from the old speed

Arguments:

 pAdapter- Local Adapter intance    
 Speed - new speed
Return Value:


--*/
{

    PAFCB pAfcb = NULL;
    PVCCB pVc = NULL;
    PLIST_ENTRY pAfEntry = NULL;
    PLIST_ENTRY pVcEntry = NULL;
    ULONG MaxPayload = 0;
    ULONG                       SCode = 0;

    TRACE( TL_T, TM_Mp, ( "==> nicUpdateSpeedInAllVCs ") );

    
    switch (Speed)
    {
        case SPEED_FLAGS_100  : 
        {
            SCode = SCODE_100_RATE;
            MaxPayload  = ISOCH_PAYLOAD_100_RATE;
            break;
        }
        case SPEED_FLAGS_200 :
        {
            SCode = SCODE_200_RATE;
            MaxPayload  = ISOCH_PAYLOAD_200_RATE ;
            break;
        }
            
        case SPEED_FLAGS_400 :
        {
            SCode = SCODE_400_RATE;
            MaxPayload  = ISOCH_PAYLOAD_400_RATE;
            break;
        }

        case SPEED_FLAGS_800 :
        {
            SCode = SCODE_800_RATE;
            MaxPayload  = ISOCH_PAYLOAD_400_RATE;
            break;
        }

        case SPEED_FLAGS_1600 :
        {
            SCode = SCODE_1600_RATE;
            MaxPayload  = ISOCH_PAYLOAD_400_RATE;
            break;
        }

        case SPEED_FLAGS_3200 :
        {
            SCode = SCODE_1600_RATE;
            MaxPayload  = ISOCH_PAYLOAD_400_RATE;
            break;
        }

        default :
        {
            ASSERT (Speed <= SPEED_FLAGS_3200 && Speed != 0 );
            
            break;
        }

    }

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    pAfEntry = ListNext (&pAdapter->AFList);

    //
    // Walk through all the Vc and set the value on the channelVcs
    //
    while (pAfEntry != &pAdapter->AFList)
    {

        pAfcb = CONTAINING_RECORD (pAfEntry, AFCB, linkAFCB);

        pAfEntry = ListNext (pAfEntry);

        pVcEntry = ListNext (&pAfcb->AFVCList);

        //
        // Now walk through the VCs on the Af
        //
        while (pVcEntry != &pAfcb->AFVCList)
        {
            pVc = (PVCCB) CONTAINING_RECORD  (pVcEntry, VCHDR, linkAFVcs );

            pVcEntry = ListNext ( pVcEntry );

            //
            // If it is a channel Send Vc update the Speed and Payload
            //
            if (pVc->Hdr.VcType == NIC1394_SendRecvChannel || pVc->Hdr.VcType == NIC1394_SendChannel)
            {
                PCHANNEL_VCCB pChannelVc = (PCHANNEL_VCCB)pVc;

                pChannelVc->Speed = Speed;
                pVc->Hdr.MaxPayload  = MaxPayload;
            }

           

        }  //while (pVcEntry != &pAfcb->AFVCList)



    } //while (pAfEntry != &pAdapter->AFList)


    pAdapter->SCode = SCode;
    
    ADAPTER_RELEASE_LOCK (pAdapter);


    TRACE( TL_T, TM_Mp, ( "<== nicUpdateSpeedInAllVCs ") );

}




VOID 
nicInitializeAllEvents (
    IN PADAPTERCB pAdapter
    )
    // Function Description:
    //   Initialize all the events in the adapter block
    //
    // Arguments
    //   pAdapter - The local host in question. 
    //
    // Return Value:
    // None 
    
{

    TRACE( TL_T, TM_Mp, ( "==> nicInitializeAllEvents " ) );

    NdisInitializeEvent (&pAdapter->RecvFIFOEvent);

    NdisInitializeEvent (&pAdapter->WaitForRemoteNode.NdisEvent);
    pAdapter->WaitForRemoteNode.EventCode = Nic1394EventCode_InvalidEventCode;

    NdisInitializeEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent); 
    pAdapter->BCRData.MakeCallWaitEvent.EventCode = Nic1394EventCode_InvalidEventCode;

    NdisInitializeEvent (&pAdapter->BCRData.BCRWaitForNewRemoteNode.NdisEvent);
    pAdapter->BCRData.BCRWaitForNewRemoteNode.EventCode = Nic1394EventCode_InvalidEventCode;


    NdisInitializeEvent (&pAdapter->BCRData.BCRFreeAddressRange.NdisEvent);
    pAdapter->BCRData.BCRFreeAddressRange.EventCode = Nic1394EventCode_InvalidEventCode;


    TRACE( TL_T, TM_Mp, ( "<== nicInitializeAllEvents " ) );


}




VOID
nicInitializeAdapterLookasideLists (
    IN PADAPTERCB pAdapter
    )
    // Function Description:
    //   Initialize all the lookaside lists in the adapter block
    //
    // Arguments
    //   pAdapter - The local host in question. 
    //
    // Return Value:
    // None 
    
{
    USHORT DefaultDepth = 15;
    
    TRACE( TL_T, TM_Mp, ( "==> nicInitializeAdapterLookasideLists pAdpater %x ", pAdapter ) );


    nicInitializeLookasideList ( &pAdapter->SendLookasideList100,
                                sizeof (PAYLOAD_100_LOOKASIDE_BUFFER),
                                MTAG_CBUF,
                                DefaultDepth );                                

    pAdapter->SendLookasideList100.MaxSendSize = PAYLOAD_100;
    TRACE( TL_V, TM_Mp, ( "  SendLookasideList100 Payload %x", PAYLOAD_100) );
    
    nicInitializeLookasideList ( &pAdapter->SendLookasideList2K,
                                 sizeof (PAYLOAD_2K_LOOKASIDE_BUFFER), 
                                 MTAG_CBUF,
                                 DefaultDepth );

    pAdapter->SendLookasideList2K.MaxSendSize = PAYLOAD_2K;
    TRACE( TL_V, TM_Mp, ( "  SendLookasideList2K Payload %x", PAYLOAD_2K) );
    
    nicInitializeLookasideList ( &pAdapter->SendLookasideList8K,
                                 sizeof (PAYLOAD_8K_LOOKASIDE_BUFFER), 
                                 MTAG_CBUF,                     
                                 0 );

    pAdapter->SendLookasideList8K.MaxSendSize = PAYLOAD_8K;
    TRACE( TL_V, TM_Mp, ( "  SendLookasideList8K Payload %x", PAYLOAD_8K) );

    

    TRACE( TL_T, TM_Mp, ( "<== nicInitializeAdapterLookasideLists  " ) );

}





VOID
nicDeleteAdapterLookasideLists (
    IN PADAPTERCB pAdapter
    )
    // Function Description:
    //   Delete all the lookaside lists in the adapter block
    //
    // Arguments
    //   pAdapter - The local host in question. 
    //
    // Return Value:
    // None 

{
    TRACE( TL_T, TM_Mp, ( "==> nicDeleteAdapterLookasideLists pAdapter %x ", pAdapter  ) );

    TRACE( TL_T, TM_Mp, ( "  Delete NonFragmentationLookasideList %x ", &pAdapter->SendLookasideList2K) );

    nicDeleteLookasideList (&pAdapter->SendLookasideList2K);

    TRACE( TL_T, TM_Mp, ( "  Delete FragmentationLookasideList %x ", &pAdapter->SendLookasideList100) );

    nicDeleteLookasideList (&pAdapter->SendLookasideList100);

    TRACE( TL_T, TM_Mp, ( "  Delete SmallPacketLookasideList %x ", &pAdapter->SendLookasideList8K) );

    nicDeleteLookasideList (&pAdapter->SendLookasideList8K);


    TRACE( TL_T, TM_Mp, ( "<== nicDeleteAdapterLookasideLists  " ) );

}







VOID
ReassemblyTimerFunction (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )

    // Function Description:
    //    Walk through all the pending reassembly operations and 
    //    take out the ones that need to be freed (Have been untouched
    //    since the timer last fired)
    //
    //    Append the ToBeFreed reassemblies into a seperate linked list
    //    and free them after releasing the spin locks
    //
    //    If the there are any pending reassemblies then the timer requeues 
    //    itself
    //
    // Arguments
    //   padapter - Adapter (local host in question)
    //
    //
    // Return Value:
    //   None
    //
{
    PREMOTE_NODE pRemoteNode = NULL;
    PLIST_ENTRY pRemoteNodeList = NULL;
    PLIST_ENTRY pReassemblyList = NULL;
    LIST_ENTRY ToBeFreedList;
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly = NULL;
    PADAPTERCB pAdapter = (PADAPTERCB) FunctionContext;
    ULONG RefValue = 0;
    STORE_CURRENT_IRQL;
    

    ( TL_T, TM_Mp, ( "==> ReassemblyTimerFunction pAdapter %x", pAdapter ) );

    InitializeListHead(&ToBeFreedList);


    ADAPTER_ACQUIRE_LOCK (pAdapter);

    pRemoteNodeList = ListNext (&pAdapter->PDOList);
    pAdapter->Reassembly.PktsInQueue =0;        

    //
    // Walking through the remote nodes
    //
    while (pRemoteNodeList != &pAdapter->PDOList)
    {
        pRemoteNode = CONTAINING_RECORD(pRemoteNodeList, REMOTE_NODE, linkPdo);

        pRemoteNodeList = ListNext (pRemoteNodeList);

        RefValue = pRemoteNode->Ref.ReferenceCount; ;

        //
        // Reference the remote node, so we can guarantee its presence
        //
        if (REMOTE_NODE_ACTIVE (pRemoteNode) == FALSE)
        {
            //
            // The remote node is going away. Skip this remote node
            //
            
            continue;
        }

        if (nicReferenceRemoteNode (pRemoteNode, "ReassemblyTimerFunction" )== FALSE )
        {
            //
            // The remote node is going away. Skip this remote node
            //
            
            continue;
        }

         
        REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK (pRemoteNode);
        //
        // Now walking through all the reassembly structures on that remote node
        //
        
        

        pReassemblyList = ListNext(&pRemoteNode->ReassemblyList);

        while (pReassemblyList  != &pRemoteNode->ReassemblyList)
        {
            pReassembly = CONTAINING_RECORD (pReassemblyList, 
                                             NDIS1394_REASSEMBLY_STRUCTURE, 
                                             ReassemblyListEntry);

            pReassemblyList = ListNext(pReassemblyList);


            //
            // If the reassembly has not been touched since the last timer it needs to be freed.
            // Other threads can ask us to free the reassembly by setting the aborted flag
            //
            if (REASSEMBLY_TEST_FLAG (pReassembly, REASSEMBLY_FREED) == TRUE)
            {

                continue;

            }
            
            if (REASSEMBLY_TEST_FLAG (pReassembly, (REASSEMBLY_NOT_TOUCHED| REASSEMBLY_ABORTED)) == TRUE)
            {
                
                REASSEMBLY_SET_FLAG (pReassembly, REASSEMBLY_FREED);
                //
                // We  have the lock, so we can remove this reassembly structure from the remote node
                //
                TRACE( TL_V, TM_Reas, ( "Removing Reassembly %x", pReassembly) );
                
                RemoveEntryList(&pReassembly->ReassemblyListEntry);

                //
                //  dereference the remote node . ref was made when the reassembly was added 
                // to the remote node
                //
                nicDereferenceRemoteNode (pRemoteNode, "ReassemblyTimerFunction - Removing reassembly" );

                nicDereferenceReassembly (pReassembly, "ReassemblyTimerFunction - Removing reassembly");

                //
                // add this reassembly to the to be freed list.
                //
                InsertTailList(&ToBeFreedList,&pReassembly->ReassemblyListEntry);
            }
            else
            {
                //
                // Mark the Reassembly as Not Touched. If a fragment is received, it will clear the flag
                //
                REASSEMBLY_SET_FLAG (pReassembly, REASSEMBLY_NOT_TOUCHED);

                pAdapter->Reassembly.PktsInQueue ++;        
            }
                    
        }//     while (pReassemblyList  != &pRemoteNode->ReassemblyList)


        REMOTE_NODE_REASSEMBLY_RELEASE_LOCK(pRemoteNode);

        nicDereferenceRemoteNode(pRemoteNode , "ReassemblyTimerFunction " );

        
        
    } //while (pRemoteNodeList != &pAdapter->PDOList)


    //
    // Clear the timer set flag , so that any new reassenblies will restart the timer
    //
    pAdapter->Reassembly.bTimerAlreadySet = FALSE;

    
    pAdapter->Reassembly.CompleteEvent.EventCode = nic1394EventCode_ReassemblyTimerComplete;

    NdisSetEvent (&pAdapter->Reassembly.CompleteEvent.NdisEvent);
    
    ADAPTER_RELEASE_LOCK (pAdapter);
    //
    // Now we walk the ToBeFreedList and free each of the reasembly structures
    //
    if (IsListEmpty (&ToBeFreedList) == FALSE)
    {
        nicAbortReassemblyList (&ToBeFreedList);
    }


    if (pAdapter->Reassembly.PktsInQueue > 0)
    {
        //
        // Requeue the timer, as there are still fragments remaining in the list.
        //
        nicQueueReassemblyTimer(pAdapter, FALSE);

    }
    
    TRACE( TL_T, TM_Mp, ( "<== ReassemblyTimerFunction   " ) );
    MATCH_IRQL;


}

NDIS_STATUS 
nicAddIP1394ToConfigRom (
    IN PADAPTERCB pAdapter
    )
{   
    HANDLE hCromData = NULL;
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    PMDL pConfigRomMdl = NULL;
    
    TRACE( TL_T, TM_Mp, ( "==> nicAddIP1394ToConfigRom  pAdapter %x", pAdapter ) );


    NdisStatus  = nicSetLocalHostPropertiesCRom(pAdapter,
                                               (PUCHAR)&Net1394ConfigRom,
                                               sizeof(Net1394ConfigRom),
                                               SLHP_FLAG_ADD_CROM_DATA,
                                               &hCromData,
                                               &pConfigRomMdl);
    
    ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        pAdapter->hCromData = hCromData;
        pAdapter->pConfigRomMdl = pConfigRomMdl;
    }
    
    TRACE( TL_T, TM_Mp, ( "<== nicAddIP1394ToConfigRom  pAdapter %x", pAdapter ) );
    return NdisStatus;

}


NDIS_STATUS
nicMCmRegisterAddressFamily (
    IN PADAPTERCB pAdapter
    )
    // Function Description:
    //   This function will only be called once per local host
    //    This will cause the ARP module to send Create Vc's etc
    //
    // Arguments
    //  pAdapter -local host
    //
    //
    // Return Value:
    //  None
    //
{   
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    BOOLEAN fDoRegister = TRUE;

    TRACE( TL_T, TM_Mp, ( "==> nicCmRegisterAddressFamily pAdapter %x", pAdapter ) );

    do 
    {
        

        // Register the address family of our call manager with NDIS for the
        // newly bound adapter.  We use the mini-port form of
        // RegisterAddressFamily instead of the protocol form because
        // we are a miniport/callmanager combo. The mini-port form
        // causes the call manager VC context to
        // automatically map to the mini-port VC context, which is exactly
        // what we want.
        //
        // NDIS notifies all call manager clients of the new family we
        // register.
        //
        {
            NDIS_CALL_MANAGER_CHARACTERISTICS ncmc;
            CO_ADDRESS_FAMILY family;

            NdisZeroMemory( &family, sizeof(family) );
            family.MajorVersion = NDIS_MajorVersion;
            family.MinorVersion = NDIS_MinorVersion;
            family.AddressFamily = CO_ADDRESS_FAMILY_1394;

            NdisZeroMemory( &ncmc, sizeof(ncmc) );
            ncmc.MajorVersion = NDIS_MajorVersion;
            ncmc.MinorVersion = NDIS_MinorVersion;
            ncmc.CmCreateVcHandler = NicCmCreateVc;
            ncmc.CmDeleteVcHandler = NicCmDeleteVc;
            ncmc.CmOpenAfHandler = NicCmOpenAf;
            ncmc.CmCloseAfHandler = NicCmCloseAf;

            ncmc.CmRegisterSapHandler = nicRegisterSapHandler;
            ncmc.CmDeregisterSapHandler = nicDeregisterSapHandler;

            ncmc.CmMakeCallHandler = NicCmMakeCall;
            ncmc.CmCloseCallHandler = NicCmCloseCall;

            // NEW for 1394 no ncmc.CmIncomingCallCompleteHandler
            ncmc.CmAddPartyHandler = nicCmAddPartyHandler;
            ncmc.CmDropPartyHandler = nicCmDropPartyHandler; 

            // no CmDropPartyHandler
            // NEW for 1394 no ncmc.CmActivateVcCompleteHandler
            // NEW for 1394 no ncmc.CmDeactivateVcCompleteHandler
            ncmc.CmModifyCallQoSHandler = NicCmModifyCallQoS;
            ncmc.CmRequestHandler = NicCmRequest;
            // no CmRequestCompleteHandler

            TRACE( TL_I, TM_Cm, ( "NdisMCmRegAf" ) );
            
            NdisStatus = NdisMCmRegisterAddressFamily (pAdapter->MiniportAdapterHandle, 
                                                       &family, 
                                                       &ncmc, 
                                                       sizeof(ncmc) );
                                                 
            TRACE( TL_I, TM_Cm, ( "NdisMCmRegAf=$%x", NdisStatus ) );
        }


    } while (FALSE);
    
    TRACE( TL_T, TM_Mp, ( "<== nicCmRegisterAddressFamily NdisStatus %x", NdisStatus  ) );

    return NdisStatus;

}




VOID
nicFreeReassembliesOnRemoteNode (
    IN PREMOTE_NODE pRemoteNode,
    PLIST_ENTRY pToBeFreedList
    )
/*++

Routine Description:
 Free All reassemblies that are on this remote node.
 Acquires the reassembly Lock , pops the reassemblies off the list and then aborts them

 This functions is an exception to our reassembly garbage collection. algorithm as the context of this function
 requires immediate freeing of the reassembly structures
 
 Expects the remote node lock to be held
Arguments:
  pRemote Node - Remote Node that is being pulled out
  
Return Value:


--*/


{
    ULONG NumFreed=0;
    PLIST_ENTRY pReassemblyList = NULL;
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly = NULL;
    
    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Mp, ( "==> nicFreeReassembliesOnRemoteNode  pRemoteNode %x", pRemoteNode) );

    InitializeListHead(pToBeFreedList);

    //
    // Now walking through all the reassembly structures on that remote node
    //

    //
    // If the remtoe node is in the list, it is fair game for us to extract it 
    //
    REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK (pRemoteNode);
    
    pReassemblyList = ListNext(&pRemoteNode->ReassemblyList);

    while (pReassemblyList  != &pRemoteNode->ReassemblyList)
    {
        pReassembly = CONTAINING_RECORD (pReassemblyList, 
                                         NDIS1394_REASSEMBLY_STRUCTURE, 
                                         ReassemblyListEntry);

        pReassemblyList = ListNext(pReassemblyList);

        //
        // Once the reassembly has been marked as free, it should no longer be in the remote 
        // node's list . 
        //
        ASSERT (REASSEMBLY_TEST_FLAG (pReassembly, REASSEMBLY_FREED) == FALSE);
        
            
        REASSEMBLY_SET_FLAG (pReassembly, REASSEMBLY_FREED);
        //
        // We  have the lock, so we can remove this reassembly structure from the remote node
        //
        TRACE( TL_V, TM_Mp, ( "Removing Reassembly %x", pReassembly) );
            
        RemoveEntryList(&pReassembly->ReassemblyListEntry);

        //
        //  dereference the remote node . ref was made when the reassembly was added 
        // to the remote node
        //
        nicDereferenceRemoteNode (pRemoteNode, "nicFreeReassembliesOnRemoteNode " );

        nicDereferenceReassembly(pReassembly,  "nicFreeReassembliesOnRemoteNode " );


        //
        // add this reassembly to the to be freed list.
        //
        InsertTailList(pToBeFreedList,&pReassembly->ReassemblyListEntry);
                
    }//     while (pReassemblyList  != &pRemoteNode->ReassemblyList)



    REMOTE_NODE_REASSEMBLY_RELEASE_LOCK(pRemoteNode);

    
    TRACE( TL_T, TM_Mp, ( "<== nicFreeReassembliesOnRemoteNode  NumFreed %x",NumFreed ) );
    MATCH_IRQL;

}
 

UCHAR
nicGetMaxRecFromBytes(
    IN ULONG ByteSize
    )
/*++

Routine Description:
  Converts Size in bytes to MaxRec
  512 - 8
  1024 - 9
Arguments:
  ULONG Bytes Size

Return Value:


--*/
{

    TRACE( TL_T ,TM_Mp, ( "==>nicGetMaxRecFromBytes ByteSize %x",ByteSize) );

    if (ByteSize == ASYNC_PAYLOAD_100_RATE) return MAX_REC_100_RATE;
    if (ByteSize == ASYNC_PAYLOAD_200_RATE) return MAX_REC_200_RATE;
    if (ByteSize == ASYNC_PAYLOAD_400_RATE) return MAX_REC_400_RATE;
    if (ByteSize == ASYNC_PAYLOAD_800_RATE_LOCAL) return MAX_REC_800_RATE_LOCAL;
    if (ByteSize == ASYNC_PAYLOAD_1600_RATE_LOCAL) return MAX_REC_1600_RATE_LOCAL;
    if (ByteSize == ASYNC_PAYLOAD_3200_RATE_LOCAL) return MAX_REC_3200_RATE_LOCAL;
    //
    // Default to 400 for all greater values
    //
    return MAX_REC_400_RATE;
}



UCHAR
nicGetMaxRecFromSpeed(
    IN ULONG Scode
    )
/*++

Routine Description:
  Converts Size in bytes to MaxRec
  512 - 8
  1024 - 9
Arguments:
  ULONG Bytes Size

Return Value:


--*/
{

    TRACE( TL_T ,TM_Mp, ( "==>nicGetMaxRecFromSpeed  Scode %x",Scode) );

    if (Scode == SPEED_FLAGS_100) return MAX_REC_100_RATE;
    if (Scode == SPEED_FLAGS_200  ) return MAX_REC_200_RATE;
    if (Scode == SPEED_FLAGS_400   ) return MAX_REC_400_RATE;
    if (Scode == SPEED_FLAGS_800   ) return MAX_REC_800_RATE_LOCAL  ;
    if (Scode == SPEED_FLAGS_1600   ) return MAX_REC_1600_RATE_LOCAL  ;
    if (Scode == SPEED_FLAGS_3200   ) return MAX_REC_3200_RATE_LOCAL  ;
                      
    //
    //  default
    //
    return MAX_REC_400_RATE;
}


PREMOTE_NODE
nicGetRemoteNodeFromTable (
    ULONG NodeNumber,
    PADAPTERCB pAdapter
    )
/*++

Routine Description:
  Looks up the remote node in a locked table  , references the remote node and returns

Arguments:
  ULONG NodeNumber  

Return Value:
  pRemoteNode

--*/

{
    PREMOTE_NODE pRemoteNode = NULL;

    ADAPTER_ACQUIRE_LOCK (pAdapter);
    pRemoteNode = pAdapter->NodeTable.RemoteNode[NodeNumber];

    if (pRemoteNode != NULL)
    {
        nicReferenceRemoteNode (pRemoteNode, "nicGetRemoteNodeFromTable");
    }
    ADAPTER_RELEASE_LOCK (pAdapter);

    
    return pRemoteNode;

}




NDIS_STATUS
nicFillNicInfo (
    IN PADAPTERCB pAdapter, 
    PNIC1394_NICINFO pInNicInfo,
    PNIC1394_NICINFO pOutNicInfo
    )

/*++

Routine Description:


Arguments:
    pAdapter- fills in the required data
    pBus Info - Assumes the buffer is valid
    
Return Value:


--*/

{
    NDIS_STATUS Status = NDIS_STATUS_INVALID_DATA;

    do
    {
        //
        // First check internal version
        //
        if (pInNicInfo->Hdr.Version != NIC1394_NICINFO_VERSION)
        {
            TRACE( TL_A, TM_Mp, ( "  NICINFO.Version mismatch. Want %lu got %lu\n",
                        NIC1394_NICINFO_VERSION,
                        pInNicInfo->Hdr.Version
                        ));
            break;
        }

        //
        // Struct-copy the old to the new. It's wasteful, but we don't want
        // to dig into how much of the in buffer contains valid data.
        //
        *pOutNicInfo = *pInNicInfo;

        //
        // Rest is op-specific
        //
        switch(pOutNicInfo->Hdr.Op)
        {

        case NIC1394_NICINFO_OP_BUSINFO:
            Status = nicFillBusInfo(pAdapter, &pOutNicInfo->BusInfo);
            break;

        case NIC1394_NICINFO_OP_REMOTENODEINFO:
            Status = nicFillRemoteNodeInfo(pAdapter, &pOutNicInfo->RemoteNodeInfo);
            break;

        case NIC1394_NICINFO_OP_CHANNELINFO:
            Status = nicFillChannelInfo(pAdapter, &pOutNicInfo->ChannelInfo);
            break;
        case NIC1394_NICINFO_OP_RESETSTATS:
            Status = nicResetStats (pAdapter, &pOutNicInfo->ResetStats);
        default:
            TRACE( TL_A, TM_Mp, ( "  NICINFO.Op (%lu) is unknown.\n",
                        pInNicInfo->Hdr.Op
                        ));
            break;
        
        }

    } while (FALSE);


    return Status;
}



NDIS_STATUS
nicResetStats (
    IN      PADAPTERCB pAdapter, 
    PNIC1394_RESETSTATS     pResetStats 
    )
{


    NdisZeroMemory (&pAdapter->AdaptStats.TempStats, sizeof (pAdapter->AdaptStats.TempStats) );
    return NDIS_STATUS_SUCCESS;

}



NDIS_STATUS
nicFillBusInfo(
    IN      PADAPTERCB pAdapter, 
    IN  OUT PNIC1394_BUSINFO pBi
    )
{
    ULARGE_INTEGER BusMap, ActiveMap;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    NIC_SEND_RECV_STATS* pNicStats = NULL;
    PADAPT_STATS pAdaptStats = &pAdapter->AdaptStats;
    //
    // Fill with Dummy data
    //
    pBi->NumBusResets = pAdaptStats->ulNumResetCallbacks;
    pBi->SecondsSinceBusReset = nicGetSystemTime() - pAdaptStats->ulResetTime;
    
    pBi->Flags =  (BCR_TEST_FLAG( pAdapter, BCR_LocalHostIsIRM) == TRUE ) ? NIC1394_BUSINFO_LOCAL_IS_IRM : 0;


    //
    // CHANNEL RELATED INFORMATION
    //
    NdisStatus = nicQueryChannelMap( pAdapter, &BusMap);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        pBi->Channel.BusMap = BusMap.QuadPart;
    }
    
    //
    // For now
    //
    ActiveMap.QuadPart = pAdapter->ChannelsAllocatedByLocalHost;

    //
    // First zero out some info
    //
    NdisZeroMemory( &pBi->Channel.SendPktStats, sizeof (pBi->Channel.SendPktStats ));
    NdisZeroMemory( &pBi->Fifo.SendPktStats, sizeof (pBi->Fifo.SendPktStats) ) ;

    //
    // Now go through each Vc and extract the relevant information
    //
    ADAPTER_ACQUIRE_LOCK (pAdapter);

    #define GARBAGE 9999    


    pBi->Channel.Bcr = *((PULONG) &pAdapter->BCRData.IRM_BCR);
    pBi->LocalNodeInfo.UniqueID = pAdapter->UniqueId;           // This node's 64-bit Unique ID.
    pBi->LocalNodeInfo.BusGeneration = pAdapter->Generation;    // 1394 Bus generation ID.
    pBi->LocalNodeInfo.NodeAddress = pAdapter->NodeAddress;
    pBi->LocalNodeInfo.MaxRecvBlockSize = pAdapter->MaxRec; 
    pBi->LocalNodeInfo.MaxRecvSpeed = pAdapter->SCode;

    //
    // Fill up Recv Vc Stats
    //
    if (pAdapter->pRecvFIFOVc != NULL)
    {
        PRECVFIFO_VCCB pRecvVc = pAdapter->pRecvFIFOVc;
        
        pBi->Fifo.Recv_Off_Low = pRecvVc->VcAddressRange.AR_Off_Low;
        pBi->Fifo.Recv_Off_High = pRecvVc ->VcAddressRange.AR_Off_High;

        nicCopyPacketStats(&pBi->Fifo.RecvPktStats
                         ,pAdapter->AdaptStats.TempStats.Fifo.ulRecv, 
                         GARBAGE , 
                         GARBAGE ,
                         GARBAGE);

        pBi->Fifo.NumFreeRecvBuffers  = pRecvVc->NumAllocatedFifos - pRecvVc->NumIndicatedFifos;
        pBi->Fifo.MinFreeRecvBuffers = GARBAGE ; // todo
    }
    //
    // Fifo Send Stats
    //
    pNicStats = &pAdaptStats->TempStats.Fifo;
    
    nicCopyPacketStats ( &pBi->Fifo.SendPktStats,  
                    pNicStats->ulSendNicSucess,
                    pNicStats->ulSendNicFail,
                    pNicStats->ulSendBusSuccess,
                    pNicStats->ulSendBusFail );

    nicCopyPacketStats ( &pBi->Fifo.RecvPktStats,  
                    pNicStats->ulRecv,
                    0,
                    0,
                    0);

    //
    // Channel Send Stats
    //
    pNicStats = &pAdapter->AdaptStats.TempStats.Channel;
    nicCopyPacketStats ( &pBi->Channel.SendPktStats,
                    pNicStats->ulSendNicSucess,
                    pNicStats->ulSendNicFail,
                    pNicStats->ulSendBusSuccess,
                    pNicStats->ulSendBusFail );

    //
    // Broadcast channel data - same as channel
    //
    nicCopyPacketStats  ( &pBi->Channel.BcSendPktStats,
                        pNicStats->ulSendNicSucess,
                        pNicStats->ulSendNicFail,
                        pNicStats->ulSendBusSuccess,
                        pNicStats->ulSendBusFail );

    //
    // Recv Channels
    //
    nicCopyPacketStats ( &pBi->Channel.BcRecvPktStats ,
                        pNicStats->ulRecv, 
                        0, 
                        0, 
                        0);

    ADAPTER_RELEASE_LOCK (pAdapter);

    pBi->Channel.ActiveChannelMap= ActiveMap.QuadPart;
    pBi->Fifo.NumOutstandingReassemblies = pAdaptStats->TempStats.ulNumOutstandingReassemblies;
    pBi->Fifo.MaxOutstandingReassemblies =pAdaptStats->TempStats.ulMaxOutstandingReassemblies;
    //pBi->Fifo.NumAbortedReassemblies = ReassemblyCompleted;
    
    
    //
    // Information about remote nodes. More information about each of these nodes
    // may be queried using *OP_REMOTE_NODEINFO
    //
    pBi->NumRemoteNodes = pAdaptStats->ulNumRemoteNodes;

    ADAPTER_ACQUIRE_LOCK (pAdapter);
    {
        UINT i = 0;
        PLIST_ENTRY pRemoteEntry = ListNext(&pAdapter->PDOList);

        while (pRemoteEntry != &pAdapter->PDOList)
        {
            PREMOTE_NODE pRemote = CONTAINING_RECORD (pRemoteEntry,
                                                           REMOTE_NODE,
                                                           linkPdo);
            pRemoteEntry = ListNext(pRemoteEntry);
            
            pBi->RemoteNodeUniqueIDS[i] = pRemote->UniqueId;

            i++;
        }

    }
    
    ADAPTER_RELEASE_LOCK (pAdapter);
    
    return NDIS_STATUS_SUCCESS;
}



NDIS_STATUS
nicFillChannelInfo(
    IN      PADAPTERCB pAdapter, 
    IN OUT  PNIC1394_CHANNELINFO pCi
    )
{
    return NDIS_STATUS_SUCCESS;
}



NDIS_STATUS
nicFillRemoteNodeInfo(
    IN      PADAPTERCB pAdapter, 
    IN OUT  PNIC1394_REMOTENODEINFO pRni
    )
{
    NDIS_STATUS NdisStatus;
    REMOTE_NODE *pRemoteNode = NULL;

    do
    {
        //
        // First let's find the remote node, based on the unique ID.
        // nicFindRemoteNodeFromAdapter refs pRemoteNode on success.
        //
        NdisStatus = nicFindRemoteNodeFromAdapter(pAdapter,
                                                  NULL, // pPDO OPTIONAL
                                                  pRni->UniqueID,
                                                  &pRemoteNode);
    
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            pRemoteNode = NULL;
            break;
        }

        NdisStatus  = nicQueryRemoteNodeCaps (pAdapter,
                                              pRemoteNode,
                                              &pRni->MaxSpeedBetweenNodes,
                                              &pRni->EffectiveMaxBlockSize,
                                              &pRni->MaxRec
                                              );

        REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);

        pRni->NodeAddress = *(PUSHORT) &pRemoteNode->RemoteAddress;
    

        if (REMOTE_NODE_ACTIVE (pRemoteNode))
        {
            pRni->Flags = NIC1394_REMOTEINFO_ACTIVE;
        }
        else
        {
            pRni->Flags = NIC1394_REMOTEINFO_UNLOADING; // we assume it's unloading.
        }

        REMOTE_NODE_RELEASE_LOCK (pRemoteNode);
    
        //
        // Don't support the following yet.
        //
        NdisZeroMemory (&pRni->SendFifoPktStats, sizeof (pRni->SendFifoPktStats) );
        NdisZeroMemory (&pRni->SendFifoPktStats, sizeof (pRni->SendFifoPktStats));
        NdisZeroMemory (&pRni->RecvFifoPktStats, sizeof (pRni->SendFifoPktStats));
        NdisZeroMemory (&pRni->RecvChannelPktStats , sizeof (pRni->SendFifoPktStats));
    } while (FALSE);

    if (pRemoteNode != NULL)
    {
        nicDereferenceRemoteNode(pRemoteNode, "nicFillRemoteNodeInfo");
    }

    return NdisStatus;
}





VOID
nicCopyPacketStats (
    NIC1394_PACKET_STATS* pStats,
    UINT    TotNdisPackets,     // Total number of NDIS packets sent/indicated
    UINT    NdisPacketsFailures,// Number of NDIS packets failed/discarded
    UINT    TotBusPackets,      // Total number of BUS-level reads/writes
    UINT    BusPacketFailures   // Number of BUS-level failures(sends)/discards(recv)
    )
{

    pStats->TotNdisPackets= TotNdisPackets;     // Total number of NDIS packets sent/indicated
    pStats->NdisPacketsFailures= NdisPacketsFailures;// Number of NDIS packets failed/discarded
    pStats->TotBusPackets = TotBusPackets;      // Total number of BUS-level reads/writes
    pStats->TotBusPackets = BusPacketFailures;  // Number of BUS-level failures(sends)/discards(recv)


}

VOID
nicAddPacketStats(
    NIC1394_PACKET_STATS* pStats,
    UINT    TotNdisPackets,     // Total number of NDIS packets sent/indicated
    UINT    NdisPacketsFailures,// Number of NDIS packets failed/discarded
    UINT    TotBusPackets,      // Total number of BUS-level reads/writes
    UINT    BusPacketFailures   // Number of BUS-level failures(sends)/discards(recv)
    )
{

    pStats->TotNdisPackets+= TotNdisPackets;        // Total number of NDIS packets sent/indicated
    pStats->NdisPacketsFailures+= NdisPacketsFailures;// Number of NDIS packets failed/discarded
    pStats->TotBusPackets += TotBusPackets;     // Total number of BUS-level reads/writes
    pStats->TotBusPackets += BusPacketFailures; // Number of BUS-level failures(sends)/discards(recv)


}




VOID
nicInformProtocolsOfReset(
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:

    Informs protocols of reset. Does an NdisMCoIndicateStatus with a locally allocated structure 
    which includes the new Local Node Address and Generation

Arguments:


Return Value:


--*/
{
    NIC1394_STATUS_BUFFER  StatusBuffer;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    
    TRACE( TL_T, TM_Mp, ( "==> nicInformProtocolsOfReset ") );

    do
    {
    
        NdisZeroMemory (&StatusBuffer, sizeof (StatusBuffer) );

        StatusBuffer.Signature = NIC1394_MEDIA_SPECIFIC;

        StatusBuffer.Event = NIC1394_EVENT_BUS_RESET;


        NdisMCoIndicateStatus(pAdapter->MiniportAdapterHandle,
                           NULL,
                           NDIS_STATUS_MEDIA_SPECIFIC_INDICATION,
                           &StatusBuffer,
                           sizeof(StatusBuffer));
    } while (FALSE);



    TRACE( TL_T, TM_Mp, ( "<== nicInformProtocolsOfReset ") );

}

VOID
nicUpdateRemoteNodeCaps(
    PADAPTERCB          pAdapter
)
/*++
    Update the caps (maxrec, maxspeed-to, max effective buffer size) for all
    nodes that we have connections to.
--*/
{

    ULONG               i = 0;
    ULONG               NumNodes = 0;
    PREMOTE_NODE        pRemoteNode = NULL;
    NODE_ADDRESS        NodeAddress;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_SUCCESS;

    for (i=0; i<MAX_NUMBER_NODES; i++)
    {
        UINT SpeedTo;
        UINT EffectiveMaxBufferSize;
        UINT MaxRec;

        if (pAdapter->NodeTable.RemoteNode[i] == NULL)
        {
            continue;     // ******************* CONTINUE ****************
        }


        ADAPTER_ACQUIRE_LOCK (pAdapter);

        pRemoteNode = pAdapter->NodeTable.RemoteNode[i];
            
        // We check again, with the lock held.
        //
        if (pRemoteNode == NULL || !REMOTE_NODE_ACTIVE (pRemoteNode))
        {
            ADAPTER_RELEASE_LOCK (pAdapter);
            continue;     // ******************* CONTINUE ****************
        }
        nicReferenceRemoteNode (pRemoteNode, "nicUpdateRemoteNodeCaps ");
        ADAPTER_RELEASE_LOCK (pAdapter);


        // Specifying FALSE (!from cache) below causes pRemoteNode's cached caps
        // to be refreshed.
        //
        NdisStatus  = nicQueryRemoteNodeCaps (pAdapter,
                                              pRemoteNode,
                                              &SpeedTo,
                                              &EffectiveMaxBufferSize,
                                              &MaxRec
                                              );
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Mp, ( "nicUpdateRemoteNodeCaps couldn't update caps fo node %x", pRemoteNode));
        }
        nicDereferenceRemoteNode (pRemoteNode, "nicUpdateRemoteNodeCaps ");
    }
}




VOID
nicQueryInformationWorkItem(
    IN PNDIS_WORK_ITEM pWorkItem,   
    IN PVOID Context 
    )
{
    PADAPTERCB pAdapter= (PADAPTERCB) Context;
    PNIC_WORK_ITEM pNicWorkItem =  (PNIC_WORK_ITEM) pWorkItem;
    NDIS_STATUS Status;

    Status =  nicQueryInformation(
                pAdapter,
                pNicWorkItem->RequestInfo.pVc,
                pNicWorkItem->RequestInfo.pNdisRequest
                );
    //
    // We call at passive, so we should never be pending here.
    //
    ASSERT(Status != NDIS_STATUS_PENDING);

    //
    // Asynchronously complete the work item.
    //
   NdisMCoRequestComplete(
          Status,
          pAdapter->MiniportAdapterHandle,
          pNicWorkItem->RequestInfo.pNdisRequest
          );

    //
    // Deref the work item adapter reference.
    //
    FREE_NONPAGED (pWorkItem);
    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);
    nicDereferenceAdapter(pAdapter, "nicQueryInfoWorkItem");
}


NDIS_STATUS
nicInitSerializedStatusStruct(
    PADAPTERCB pAdapter
    )
/*++

Routine Description:
    Used to initialize the Send Serialization Struct

Arguments:



Return Value:


--*/
{


    NdisZeroMemory (&pAdapter->Status, sizeof(pAdapter->Status));
    InitializeListHead(&pAdapter->Status.Queue);

    NdisMInitializeTimer (&pAdapter->Status.Timer,
                      pAdapter->MiniportAdapterHandle,
                      nicIndicateStatusTimer,
                      pAdapter);


    return NDIS_STATUS_SUCCESS;

}



VOID
nicDeInitSerializedStatusStruct(
    PADAPTERCB pAdapter
    )
/*++

Routine Description:
 Deinits the Status  Init routine

Arguments:


Return Value:


--*/
{



}




VOID
nicMIndicateStatus(
    IN  PADAPTERCB              pAdapter ,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    )
/*++

Routine Description:

    This function inserts a packet into the send queue. If there is no timer servicing the queue
    then it queues a timer to dequeue the packet in Global Event's context


Arguments:

    Self explanatory 
    
Return Value:
    Success - if inserted into the the queue

--*/
    
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fSetTimer = FALSE;
    BOOLEAN fNeedToFreeContext = FALSE;
    PNDIS_STATUS_CONTEXT  pContext = NULL;


    if (ADAPTER_TEST_FLAG (pAdapter, fADAPTER_DoStatusIndications) == FALSE)
    {
        return;
    }


#if QUEUED_PACKETS
    do
    {

        pContext = ALLOC_NONPAGED (sizeof(NDIS_STATUS_CONTEXT ), MTAG_TIMERQ);

        if (pContext == NULL)
        {
            break;
        }
        //
        // Store the pvc in the Miniport Reserved
        //
        pContext->GeneralStatus = GeneralStatus;
        pContext->StatusBuffer = StatusBuffer;
        pContext->StatusBufferSize = StatusBufferSize;
                
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // Find out if this thread needs to fire the timer
        //
        if (ADAPTER_TEST_FLAG (pAdapter, fADAPTER_Halting) ||
            ADAPTER_TEST_FLAG (pAdapter, fADAPTER_VDOInactive))
        {
            
            ADAPTER_RELEASE_LOCK (pAdapter);
            fNeedToFreeContext = TRUE;
            break;
        
        }

        if (pAdapter->Status.bTimerAlreadySet == FALSE)
        {
            fSetTimer = TRUE;
            pAdapter->Status.bTimerAlreadySet = TRUE;

        }
                
        InsertTailList(
                &pAdapter->Status.Queue,
                &pContext->Link
                );
                
        pAdapter->Status.PktsInQueue++;

        nicReferenceAdapter (pAdapter, "nicMIndicateStatus ");

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Now queue the timer
        //
        
        if (fSetTimer == TRUE)
        {
            PNDIS_MINIPORT_TIMER pTimer;
            //
            //  Initialize the timer
            //
            pTimer = &pAdapter->Status.Timer;       
            
            NdisMSetTimer ( pTimer, 0);
        }


        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

#else


    NdisMCoIndicateStatus (pAdapter->MiniportAdapterHandle ,
                        NULL,
                         GeneralStatus,
                         StatusBuffer,
                         StatusBufferSize   
                         );


#endif

    if (fNeedToFreeContext == TRUE)
    {
        FREE_NONPAGED (pContext);
    }
    
}





VOID
nicIndicateStatusTimer(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )
/*++

Routine Description:
   This function dequeues a packet and invokes the appropriate send handler
   to fire this packet off to the 1394 bus driver

Arguments:

    Function context - Adapter structure, which has the Packet queue. 
    Each packet has the VC embedded in it.

Return Value:


--*/
{
    

    PADAPTERCB      pAdapter = (PADAPTERCB) FunctionContext;
    BOOLEAN         fVcCorrupted = FALSE;

    TRACE( TL_T, TM_Recv, ( "==>nicIndicateStatusTimer Context %x", FunctionContext));


    ADAPTER_ACQUIRE_LOCK (pAdapter);
    


    //
    // Empty the Queue indicating as many packets as possible
    //
    while (IsListEmpty(&pAdapter->Status.Queue)==FALSE)
    {
        PNDIS_STATUS_CONTEXT        pStatus;
        PLIST_ENTRY                 pLink;
        NDIS_STATUS                 NdisStatus;

        pAdapter->Status.PktsInQueue--;

        pLink = RemoveHeadList(&pAdapter->Status.Queue);

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Extract the send context
        //
        pStatus = CONTAINING_RECORD(
                                           pLink,
                                           NDIS_STATUS_CONTEXT,
                                           Link);





        NdisMCoIndicateStatus (pAdapter->MiniportAdapterHandle,
                            NULL,
                             pStatus->GeneralStatus,
                             pStatus->StatusBuffer,
                             pStatus->StatusBufferSize
                             ) ;
        

        FREE_NONPAGED (pStatus);

        
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        nicDereferenceAdapter(pAdapter, "nicIndicateStatusTimer");
        

    }
    
    //
    // clear the flag
    //

    ASSERT (pAdapter->Status.PktsInQueue==0);
    ASSERT (IsListEmpty(&pAdapter->Status.Queue));

    pAdapter->Status.bTimerAlreadySet = FALSE;


    ADAPTER_RELEASE_LOCK (pAdapter);

    
    TRACE( TL_T, TM_Recv, ( "<==nicIndicateStatusTimer"));

    


}


NDIS_STATUS
nicAllocateLoopbackPacketPool (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:
    allocate a packet and buffer pool for loopback packet

Arguments:


Return Value:


--*/
    
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    do
    {
        //
        // Allocate a packet pool to indicate loopback receives from.
        //
        NdisAllocatePacketPoolEx(
            &NdisStatus,
            &pAdapter->LoopbackPool.Handle,
            32,
            32,
            sizeof(LOOPBACK_RSVD)
            );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        pAdapter->LoopbackPool.AllocatedPackets = 0;
        KeInitializeSpinLock (&pAdapter->LoopbackPool.Lock);
        
        
        NdisAllocateBufferPool(
            &NdisStatus,
            &pAdapter->LoopbackBufferPool,
            64
            );
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

    } while (FALSE);
    

    return NdisStatus;
}




VOID
nicFreeLoopbackPacketPool (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:
    free the packet and buffer pool for loopback packet

Arguments:


Return Value:


--*/
{
    if (pAdapter->LoopbackPool.Handle != NULL)
    {
        nicFreePacketPool (&pAdapter->LoopbackPool);
    }

    
    if (pAdapter->LoopbackBufferPool != NULL)
    {
        NdisFreeBufferPool(pAdapter->LoopbackBufferPool);
        pAdapter->LoopbackBufferPool = NULL;
    }

  
    


}


VOID
nicLoopbackPacket(
    IN VCCB* pVc,
    IN PNDIS_PACKET pPacket
    )
/*++

Routine Description:
    Allocate a packet and indicate it up on the vc

Arguments:


Return Value:


--*/
{
    NDIS_STATUS Status;
    PNDIS_BUFFER pFirstBuffer;
    ULONG TotalLength;

    PNDIS_PACKET pLoopbackPacket;
    PUCHAR pCopyBuf;
    PNDIS_BUFFER pLoopbackBuffer;
    ULONG BytesCopied;

    ADAPTERCB* pAdapter;
    PLOOPBACK_RSVD pLoopbackRsvd; 

    pAdapter = pVc->Hdr.pAF->pAdapter;

    TRACE( TL_T, TM_Recv, ("NIC1394: loopback pkt %p on VC %p, type %d\n",
        pPacket, pVc, pVc->Hdr.VcType));

    pLoopbackPacket = NULL;
    pLoopbackBuffer = NULL;
    pCopyBuf = NULL;

    do
    {
        nicAllocatePacket(&Status, &pLoopbackPacket, &pAdapter->LoopbackPool);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        NdisQueryPacket(
            pPacket,
            NULL,
            NULL,
            &pFirstBuffer,
            &TotalLength
            );
        
        pCopyBuf = ALLOC_NONPAGED (TotalLength, MTAG_RBUF); 

        if (pCopyBuf == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisAllocateBuffer(
            &Status,
            &pLoopbackBuffer,
            pAdapter->LoopbackBufferPool,
            pCopyBuf,
            TotalLength
            );
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        pLoopbackBuffer->Next = NULL;
        NdisChainBufferAtFront(pLoopbackPacket, pLoopbackBuffer);

        NdisCopyFromPacketToPacket(
            pLoopbackPacket,
            0,
            TotalLength,
            pPacket,
            0,
            &BytesCopied
            );

        //
        // Make sure we can reclaim the packet after the receive indicate
        // returns.  
        //
        // If the status is made async, then the loopback Tag will
        // break in the return packet handler
        //
        NDIS_SET_PACKET_STATUS(pLoopbackPacket, NDIS_STATUS_RESOURCES);

        // Set the Loopback Tag. 
        pLoopbackRsvd = (PLOOPBACK_RSVD) pLoopbackPacket->ProtocolReserved;
        pLoopbackRsvd->LoopbackTag = NIC_LOOPBACK_TAG;

        NdisMCoIndicateReceivePacket(
            pVc->Hdr.NdisVcHandle,
            &pLoopbackPacket,
            1);
        
        NdisFreeBuffer(pLoopbackBuffer);
        nicFreePacket(pLoopbackPacket, &pAdapter->LoopbackPool);

        FREE_NONPAGED(pCopyBuf);
    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        if (pCopyBuf)
        {
            FREE_NONPAGED(pCopyBuf);
        }

        if (pLoopbackBuffer)
        {
            NdisFreeBuffer(pLoopbackBuffer);
        }

        if (pLoopbackPacket)
        {
            nicFreePacket(pLoopbackPacket, &pAdapter->LoopbackPool);
        }
    }
}



VOID
nicWriteErrorLog (
    IN PADAPTERCB pAdapter,
    IN NDIS_ERROR_CODE ErrorCode,
    IN ULONG ErrorValue
    )
{

    NdisWriteErrorLogEntry( pAdapter->MiniportAdapterHandle,
                            ErrorCode,
                            1,
                            ErrorValue
                            );


}





VOID
nicUpdateRemoteNodeTable (
    IN PADAPTERCB pAdapter
    )
    // Function Description:
    //
    //  Go through all the remote nodes in the system and query its Node Address
    //  Make two tables, one contains all the remote nodes that have been refed. The
    //  other contains the Nodes according to their Node Addresses(TempNodeTable).
    //
    //  Simple algorithm:
    //      Take a snapshot of the current RemoteNodes List into RefNodeTable
    //      Ref all the remote nodes in a local structure.
    //      Get their new remote node addresses (TempNodeTable)
    //      Copy the TempNodeTable into the Adapter Structure - it is now official
    //      Update the address in the remote node themselves
    //      Dereference the Ref made above
    //
    // Arguments
    //
    //
    //
    // Return Value:
    //
    //
{
    NDIS_STATUS     NdisStatus = NDIS_STATUS_FAILURE;
    PNODE_TABLE     pNodeTable = &pAdapter->NodeTable;
    PLIST_ENTRY     pRemoteNodeList;
    NODE_ADDRESS    RemoteNodeAddress;
    NODE_TABLE      RefNodeTable;
    NODE_TABLE      TempNodeTable;
    ULONG           NumRemoteNodes = 0;
    ULONG           MaxNumRefNodeTable = 0;
    
    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Mp, ( " ==>nicUpdateRemoteNodeTable pAdapter %x, TempNodeTable%x", pAdapter , &TempNodeTable) );


    NdisZeroMemory (&TempNodeTable, sizeof (NODE_TABLE) );
    NdisZeroMemory (&RefNodeTable, sizeof(RefNodeTable));

    NumRemoteNodes = 0;

    
    ADAPTER_ACQUIRE_LOCK (pAdapter);



    pRemoteNodeList = ListNext (&pAdapter->PDOList);

    //
    // Walk through the entire list and make a copy of the current list.
    // Reference each remote node on the list. 
    // The lock will ensure that the list is valid
    //
    
    while (pRemoteNodeList != &pAdapter->PDOList)
    {
        PREMOTE_NODE pRemoteNode;
        
        pRemoteNode = CONTAINING_RECORD (pRemoteNodeList, REMOTE_NODE, linkPdo);

        //
        // Reference the remote node. This guarantees that the remote node will
        // remain valid and in the list until it is dereferenced (deref happens below)
        //
        nicReferenceRemoteNode (pRemoteNode, "nicUpdateRemoteNodeTable ");
        RefNodeTable.RemoteNode[MaxNumRefNodeTable] = pRemoteNode;


        //
        // Increment the Cursors and go to the next RemoteNode
        //
        pRemoteNodeList = ListNext (pRemoteNodeList);
        MaxNumRefNodeTable++;

    }  //while (pRemoteNodeList != &pAdapter->PDOList)

    ADAPTER_RELEASE_LOCK (pAdapter);

    //
    // Without the lock, call into the Bus Driver to get the remote address
    // of each remote node
    //
    {
        USHORT RefIndex;
        PREMOTE_NODE pCurrRemoteNode;

        //
        // Initialize the structures
        //
        pCurrRemoteNode = RefNodeTable.RemoteNode[0];
        RefIndex =0;
        
        while (pCurrRemoteNode != NULL)
        {
            // Get the Node Address of the current Remote Node
            //
            NdisStatus =  nicGet1394AddressOfRemoteNode (pCurrRemoteNode,
                                                        &RemoteNodeAddress,
                                                        0);

            if (NdisStatus == NDIS_STATUS_SUCCESS)
            {
                // 
                // Fill in the Temp Remote Node Table
                //
                PREMOTE_NODE    *ppRemoteNode;
                ppRemoteNode = &TempNodeTable.RemoteNode[RemoteNodeAddress.NA_Node_Number];

                if (*ppRemoteNode == NULL)
                {
                    //
                    // Update the value in the table
                    //
                    *ppRemoteNode = pCurrRemoteNode;
                    NumRemoteNodes ++;
                }

        
            }

            // Move to the next node in our local RefNodeTable
            //

            RefIndex++;
            pCurrRemoteNode = RefNodeTable.RemoteNode[RefIndex];

        }

    }

    ADAPTER_ACQUIRE_LOCK(pAdapter)
    
    //
    // Use the results of our queries to update our internal structures
    // Regardless of success or failure, copy the temp node table over 
    // into the adapter
    //


    NdisMoveMemory (&pAdapter->NodeTable, &TempNodeTable, sizeof (NODE_TABLE) );

    pAdapter->NumRemoteNodes = NumRemoteNodes;

    //
    // Update the node address within each of these remote nodes
    //
    {
        ULONG NumUpdated = 0;
        USHORT i=0;

        //
        // Update the Remote Node structures with their new Node Addresses
        //
        while (NumUpdated != NumRemoteNodes)
        {
            if (i >= (sizeof(TempNodeTable.RemoteNode)/sizeof(TempNodeTable.RemoteNode[0])))
            {
                // We've gone past the end of the array. Should never do that.
                //
                ASSERT(!"Walked off the end of the NodeTable");
                break;
            }
        
            if (TempNodeTable.RemoteNode[i] != NULL)
            {
                TempNodeTable.RemoteNode[i]->RemoteAddress.NA_Node_Number = i; 

                NumUpdated ++;
            }

            i++; // Use i to check if we have walked off the end of the table
            
            TRACE( TL_V, TM_Mp, ( " UpdatingRemoteNodeAddresses NumUpdated %x, i %x, NumRemoteNodes %x",
                                  NumUpdated, i, NumRemoteNodes) );

        } //        while (TRUE)
    }

    //
    // We're done, Now Dereference the Remote Node References Made above
    //
    {
        USHORT RefIndex=0;
        PREMOTE_NODE pCurrRemoteNode;

        //
        // Initialize the structures
        //
        pCurrRemoteNode = RefNodeTable.RemoteNode[0];
        RefIndex =0;
        
        while (pCurrRemoteNode != NULL)
        {
            nicDereferenceRemoteNode(pCurrRemoteNode, "nicUpdateRemoteNodeTable");
            RefIndex++;
            pCurrRemoteNode = RefNodeTable.RemoteNode[RefIndex];
        }

    }


    ADAPTER_RELEASE_LOCK (pAdapter);

    
    TRACE( TL_T, TM_Mp, ( "<== nicUpdateRemoteNodeTable pAdapter %x, NumRemoteNodes %x", pAdapter, NumRemoteNodes ) );
    MATCH_IRQL;
}


VOID
nicRemoveRemoteNodeFromNodeTable(
    IN PNODE_TABLE pNodeTable,
    IN PREMOTE_NODE pRemoteNode
    )
{

    //
    // This function assumes that the adapter lock is held.
    //
    PPREMOTE_NODE ppRemoteNode = NULL;

    //        
    // find the remote node and delete it from the node table.
    //

    //
    // The RemoteNode is probably already in the correct place in the Node Table. We'll look there first
    //
    ppRemoteNode = &pNodeTable->RemoteNode[pRemoteNode->RemoteAddress.NA_Node_Number] ;

    if (*ppRemoteNode != pRemoteNode)
    {
        //
        //We did not find the remote node, now we need to go through all the entries and see 
        // if the remote node is there
        //
        UINT i =0;
        while (i<MAX_NUMBER_NODES)
        {
            ppRemoteNode = &pNodeTable->RemoteNode[i];

            if (*ppRemoteNode == pRemoteNode)
            {
                //
                // we have found the remote node in the node table-- remove it
                //
                break;
            }
            
            i++;  // try the next node

        } // while ()
    }

    //
    // if we were able to find the remote node either by the node number or through our iterative search
    // then remove it from the Node Table
    // 
    if (*ppRemoteNode == pRemoteNode)
    {
       *ppRemoteNode = NULL;     
    }
    
    

    
}


VOID
nicVerifyEuidTopology(
    IN PADAPTERCB pAdapter,
    IN PEUID_TOPOLOGY pEuidMap
    )
/*++

Routine Description:

    Update THe node address of each remote node and then fills up the euid Map structre
    
Arguments:


Return Value:


--*/
{
   EUID_TOPOLOGY EuidTopology;
   PLIST_ENTRY pRemoteNodeList;
   PREMOTE_NODE pRemoteNode = NULL;

    //
    // Requery each  remote node for its latest HW address
    //
    nicUpdateRemoteNodeTable (pAdapter);  
    //
    // Recreate the list and verify that the topology has not changed from under us.
    //
    NdisZeroMemory (pEuidMap, sizeof(*pEuidMap));
    ADAPTER_ACQUIRE_LOCK(pAdapter);


    pRemoteNodeList = ListNext (&pAdapter->PDOList);

    //
    // Walk through the entire list and fire of a request for each RemoteNode
    // The lock will ensure that the list is valid
    //
    
    while (pRemoteNodeList != &pAdapter->PDOList)
    {
        USHORT NodeNumber;

        pEuidMap->NumberOfRemoteNodes++;

        pRemoteNode = CONTAINING_RECORD (pRemoteNodeList, REMOTE_NODE, linkPdo);

        pRemoteNodeList = ListNext (pRemoteNodeList);

        NodeNumber = pRemoteNode->RemoteAddress.NA_Node_Number;

        pEuidMap->Node[NodeNumber].Euid = pRemoteNode->UniqueId;
        pEuidMap->Node[NodeNumber].ENetAddress = pRemoteNode->ENetAddress;

    }  //while (pRemoteNodeList != &pAdapter->PDOList)

    ADAPTER_RELEASE_LOCK (pAdapter);

    

}


nicVerifyEuidMapWorkItem (
    NDIS_WORK_ITEM* pWorkItem,
    IN PVOID Context 
    )

/*++

Routine Description:
 
    This routine is a workitem routine.
    It is called whenever we are asked to report back our Mapping and is always
    called in the context of the miniport getting a request from arp1394.sys.
    

Arguments:
   pAdapter Local host

Return Value:


--*/
{
    PNIC_WORK_ITEM pNicWorkItem = (PNIC_WORK_ITEM )pWorkItem;
    PNDIS_REQUEST pRequest = pNicWorkItem->RequestInfo.pNdisRequest;
    PADAPTERCB pAdapter = (PADAPTERCB)Context;
    PEUID_TOPOLOGY pEuidMap = (PEUID_TOPOLOGY) pRequest->DATA.QUERY_INFORMATION.InformationBuffer;


    //
    //  Verify the contents of the Euid Map
    //

    nicVerifyEuidTopology(pAdapter,pEuidMap);
        

    //
    // As we atleast have the old data (before verification), 
    // we should always succeed the request
    //
    NdisMCoRequestComplete(NDIS_STATUS_SUCCESS,
                           pAdapter->MiniportAdapterHandle,
                           pRequest);

   

    FREE_NONPAGED (pNicWorkItem);
    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);

}


VOID
nicQueryEuidNodeMacMap (
    IN PADAPTERCB pAdapter,
    IN PNDIS_REQUEST pRequest
    )
/*++

Routine Description:
    Goes through all the remote nodes and extracts their Euid, Node Number and Mac
    address.

    This function first tries to query each remote node to get 
    its latest address either via by directly asking the remote node or thorough a work item.

    If that fails, then it takes the last known good values and reports it to the Arp module.
    
Arguments:


Return Value:


--*/
{
    PLIST_ENTRY pRemoteNodeList;
    PREMOTE_NODE pRemoteNode;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    PEUID_TOPOLOGY pEuidMap = (PEUID_TOPOLOGY) pRequest->DATA.QUERY_INFORMATION.InformationBuffer;
    PNIC_WORK_ITEM pUpdateTableWorkItem  = NULL;
  

    NdisZeroMemory (pEuidMap, sizeof (*pEuidMap));



    Status = NDIS_STATUS_SUCCESS;

    do
    {


        if (KeGetCurrentIrql() == PASSIVE_LEVEL)
        {
            //
            // This thread queries and completes the request
            //

            nicVerifyEuidTopology(pAdapter, pEuidMap);
            break;

        }

        //
        // We need to update the generation count
        //
        pUpdateTableWorkItem   = ALLOC_NONPAGED (sizeof(NIC_WORK_ITEM), MTAG_WORKITEM); 

        if (pUpdateTableWorkItem !=NULL)
        {
     
            
            //
            // Set the Workitem
            //

            NdisInitializeWorkItem ( &pUpdateTableWorkItem->NdisWorkItem, 
                                  (NDIS_PROC)nicVerifyEuidMapWorkItem,
                                  (PVOID)pAdapter );

            pUpdateTableWorkItem->RequestInfo.pNdisRequest = pRequest;
                                  
            NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

            NdisScheduleWorkItem (&pUpdateTableWorkItem->NdisWorkItem);

            //
            // Only code path that pends the request  -because of the workitem       
            //
            Status = NDIS_STATUS_PENDING;

        }
        else
        {
                         
            //
            //  Allocation failure - We report the results without verifying them.
            //

            ADAPTER_ACQUIRE_LOCK(pAdapter);


            pRemoteNodeList = ListNext (&pAdapter->PDOList);

            //
            // Walk through the entire list and fire of a request for each RemoteNode
            // The lock will ensure that the list is valid
            //
            
            while (pRemoteNodeList != &pAdapter->PDOList)
            {
                USHORT NodeNumber;

                pEuidMap->NumberOfRemoteNodes++;

                pRemoteNode = CONTAINING_RECORD (pRemoteNodeList, REMOTE_NODE, linkPdo);

                pRemoteNodeList = ListNext (pRemoteNodeList);

                NodeNumber = pRemoteNode->RemoteAddress.NA_Node_Number;

                pEuidMap->Node[NodeNumber].Euid = pRemoteNode->UniqueId;
                pEuidMap->Node[NodeNumber].ENetAddress = pRemoteNode->ENetAddress;

            }  //while (pRemoteNodeList != &pAdapter->PDOList)


            
            ADAPTER_RELEASE_LOCK (pAdapter);

            //
            // This thread completes the request with possibly stale data.
            //
            break;

    
        }

    }while (FALSE);


    if (NDIS_STATUS_PENDING != Status)
    {
        NdisMCoRequestComplete(Status,
                              pAdapter->MiniportAdapterHandle,
                              pRequest);

    }

}


NDIS_STATUS
MPSetPower (
    IN PADAPTERCB pAdapter,
    IN NET_DEVICE_POWER_STATE DeviceState
    )
/*++

Routine Description:

    if PowerState is LowPower, then we 
    1) there are no outstanding VCs or AFs open in the miniport
    2) free the Broadcast Channel Register,

    If the PowerState is On, then 
    1) we reallocate the BroadcastChannel Register
    2) if we are in bridge mode, Start the Arp module 
    
Arguments:


Return Value:


--*/
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    switch (DeviceState)
    {
        case NetDeviceStateD0:
        {
            //
            //  Initialize the BCM so it is ready to handle Resets
            //
            
            ADAPTER_CLEAR_FLAG(pAdapter, fADAPTER_LowPowerState);

            NdisStatus = nicInitializeBroadcastChannelRegister (pAdapter); 

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                nicFreeBroadcastChannelRegister(pAdapter);
                break;
            }
            

            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

            nicScheduleBCMWorkItem (pAdapter);

            //
            // If we are in bridge mode, then start the arp module
            //
            if (ADAPTER_TEST_FLAG (pAdapter, fADAPTER_BridgeMode) == TRUE)
            {
                nicQueueRequestToArp(pAdapter, BindArp, NULL);
            }

            //
            // Re-initialize the Reassembly Timer
            //
            nicInitSerializedReassemblyStruct(pAdapter); // cannot fail
    
            NdisStatus = NDIS_STATUS_SUCCESS;
           
        }
        break;
        case NetDeviceStateD1:
        case NetDeviceStateD2:
        case NetDeviceStateD3:
        {

            
            //
            // Free the Broadcast Channel Register
            // 
            nicFreeBroadcastChannelRegister(pAdapter);

            //
            // Wait for the Free to complete.
            //
            NdisWaitEvent (&pAdapter->BCRData.BCRFreeAddressRange.NdisEvent,0);
            NdisResetEvent (&pAdapter->BCRData.BCRFreeAddressRange.NdisEvent);

            

            ADAPTER_SET_FLAG(pAdapter, fADAPTER_LowPowerState);

            //
            // ReStart any pending broadcast channel make calls 
            //
            pAdapter->BCRData.MakeCallWaitEvent.EventCode = nic1394EventCode_FreedAddressRange;
            NdisSetEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent);


            //
            //  Wait for Outstanding WorItems and timers
            //
            nicDeInitSerializedReassmblyStruct(pAdapter);

            while (pAdapter->OutstandingWorkItems  != 0) 
            {

                NdisMSleep (10000);                       

            } 
            

            NdisStatus = NDIS_STATUS_SUCCESS;

        }
        break;

        default:
        {
            ASSERT (0);
            break;
        }

    }

    ASSERT (NDIS_STATUS_SUCCESS == NdisStatus);
    pAdapter->PowerState = DeviceState;

    return NdisStatus;




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\nt.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// nt.c
//
// IEEE1394 mini-port/call-manager driver
//
// Main routine (DriverEntry) and global data definitions
//
//	12/28/98	adube
//	9/5/99		alid: added callback registeration and interface to enum1394
//



#include "precomp.h"
//-----------------------------------------------------------------------------
// Local prototypes
//-----------------------------------------------------------------------------

extern NDIS_SPIN_LOCK g_DriverLock;
extern LIST_ENTRY g_AdapterList;

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
NicUnloadHandler(
	IN	PDRIVER_OBJECT			DriverObject
	);


// Mark routine to be unloaded after initialization.
//
#pragma NDIS_INIT_FUNCTION(DriverEntry)


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath )

    // Standard 'DriverEntry' driver initialization entrypoint called by the
    // I/0 system at IRQL PASSIVE_LEVEL before any other call to the driver.
    //
    // On NT, 'DriverObject' is the driver object created by the I/0 system
    // and 'RegistryPath' specifies where driver specific parameters are
    // stored.  These arguments are opaque to this driver (and should remain
    // so for portability) which only forwards them to the NDIS wrapper.
    //
    // Returns the value returned by NdisMRegisterMiniport, per the doc on
    // "DriverEntry of NDIS Miniport Drivers".
    //
{
    NDIS_STATUS 					NdisStatus;
    NTSTATUS                        NtStatus = STATUS_SUCCESS;
    NDIS_MINIPORT_CHARACTERISTICS	nmc;
    NDIS_HANDLE						NdisWrapperHandle;
	UNICODE_STRING					CallbackObjectName;
	OBJECT_ATTRIBUTES				ObjectAttr;
	BOOLEAN							fDerefCallbackObject = FALSE, fDeregisterCallback = FALSE;
	PDEVICE_OBJECT 					pDummyDeviceObject;

    TRACE( TL_I, TM_Init, ( " Nic1394 - DriverEntry" ) );

	do
	{
#ifdef CHANGE_MEDIUMS
		DbgPrint ("Nic1394 Driver Entry - Medium Type %x", &g_ulMedium);
		DbgBreakPoint();


#else
		//
		// Now depending on the ETHERNET preprocessor, define a medium
		//
	#ifdef _ETHERNET_		
		g_ulMedium = NdisMedium802_3; 
	#else
		g_ulMedium = NdisMedium1394;  
	#endif  // _ETHERNET_

#endif  // CHANGE_MEDIUMS


	    // Register  this driver with the NDIS wrapper.  This call must occur
	    // before any other NdisXxx calls.
	    //
	    NdisMInitializeWrapper(
	        &NdisWrapperHandle, DriverObject, RegistryPath, NULL );

	  
	    // Set up the mini-port characteristics table that tells NDIS how to call
	    // our mini-port.
	    //
	    NdisZeroMemory( &nmc, sizeof(nmc) );

	    nmc.MajorNdisVersion = NDIS_MajorVersion;
	    nmc.MinorNdisVersion = NDIS_MinorVersion;


	    // nmc.CheckForHangHandler = CheckForHang;
	    // no DisableInterruptHandler
	    // no EnableInterruptHandler
	    nmc.HaltHandler = NicMpHalt;
	    // no HandleInterruptHandler
	    nmc.InitializeHandler = NicMpInitialize;
	    // no ISRHandler
	    // no QueryInformationHandler (see CoRequestHandler)
	    nmc.ResetHandler = NicMpReset;
	    // no SendHandler (see CoSendPacketsHandler)
	    // no WanSendHandler (see CoSendPacketsHandler)
	    // no SetInformationHandler (see CoRequestHandler)
	    // no TransferDataHandler
	    // no WanTransferDataHandler
	    // nmc.ReturnPacketHandler = NicMpReturnPacket;
	    // no SendPacketsHandler (see CoSendPacketsHandler)
	    // no AllocateCompleteHandler
	    nmc.CoActivateVcHandler = NicMpCoActivateVc;
	    nmc.CoDeactivateVcHandler= NicMpCoDeactivateVc;
	    nmc.CoSendPacketsHandler = NicMpCoSendPackets;
	    nmc.CoRequestHandler = NicMpCoRequest;
	    nmc.ReturnPacketHandler = NicReturnPacket;

#ifdef _ETHERNET_ 
		nmc.QueryInformationHandler = NicEthQueryInformation;
		nmc.SetInformationHandler = NicEthSetInformation;
		nmc.SendPacketsHandler = NicMpSendPackets;

#endif

		//
		// Create a dummy device object
		//
#ifdef Win9X

 		IoCreateDevice(DriverObject,
						0,
                        NULL,
                        FILE_DEVICE_PHYSICAL_NETCARD,
                        0,
                        FALSE,// exclusive flag
		                &pDummyDeviceObject);
 
#endif
	    // Register this driver as the IEEE1394 mini-port.  This will result in NDIS
	    // calling back at NicMpInitialize.
	    //

	    TRACE( TL_V, TM_Init, ( "NdisMRegMp" ) );
	    NdisStatus = NdisMRegisterMiniport( NdisWrapperHandle, &nmc, sizeof(nmc) );
	    TRACE( TL_A, TM_Init, ( "NdisMRegMp=$%x", NdisStatus ) );

         //

	    if (NdisStatus == NDIS_STATUS_SUCCESS)
	    {
	        {
	            extern CALLSTATS g_stats;
	            extern NDIS_SPIN_LOCK g_lockStats;

	            NdisZeroMemory( &g_stats, sizeof(g_stats) );
	            NdisAllocateSpinLock( &g_lockStats );
	        }
	        
	        // Initialize driver-wide lock and adapter list.
	        //
	        {

	            NdisAllocateSpinLock( &g_DriverLock );
	            InitializeListHead( &g_AdapterList );
			}

	        //
	        // BINARY_COMPATIBILITY_BUG
	        //
#if	NDIS_NT	        
			NdisMRegisterUnloadHandler(NdisWrapperHandle, NicUnloadHandler);
#endif

			
#ifdef PSDEBUG
	        {
	            extern LIST_ENTRY g_listDebugPs;
	            extern NDIS_SPIN_LOCK g_lockDebugPs;

	            InitializeListHead( &g_listDebugPs );
	            NdisAllocateSpinLock( &g_lockDebugPs );
	        }
#endif

			//
			// create a named Callback object with os
			// then register a callback routine with send a notification to all modules that
			// have a Callback routine registered with this function
			// if enum1394 is already loaded, this will let it know the nic driver is loaded
			// the enum1394 will get the driver registeration entry points from the notification
			// callback and calls NicRegisterDriver to pass the enum entry points
			// if enum1394 is not loaded and gets loaded later, it will send a notication to modules
			// who have registered with this callback object and passes its own driver registeration
			// the purpose of passign the entry points this way vs. exporting them, is to avoid
			// getting loaded as a DLL which fatal for both nic1394 and enum1394
			//

			//
			// every Callback object is identified by a name.
			//
			RtlInitUnicodeString(&CallbackObjectName, NDIS1394_CALLBACK_NAME);

			InitializeObjectAttributes(&ObjectAttr,
									   &CallbackObjectName,
									   OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
									   NULL,
									   NULL);
									   
			NtStatus = ExCreateCallback(&Nic1394CallbackObject,
										&ObjectAttr,
										TRUE,			// allow creating the object if it does not exist
										TRUE);			// allow mutiple callback registeration

			
			if (!NT_SUCCESS(NtStatus))
			{
			    TRACE( TL_A, TM_All, ("Nic1394 DriverEntry: failed to create a Callback object. Status %lx\n", NtStatus));
				NtStatus = STATUS_UNSUCCESSFUL;
				break;
			}

			fDerefCallbackObject = TRUE;
			
			Nic1394CallbackRegisterationHandle = ExRegisterCallback(Nic1394CallbackObject,
																	Nic1394Callback,
																	(PVOID)NULL);
			if (Nic1394CallbackRegisterationHandle == NULL)
			{
				TRACE(TL_A, TM_All, ("Nic1394 DriverEntry: failed to register a Callback routine%lx\n"));
				NtStatus = STATUS_UNSUCCESSFUL;
				break;
			}
							   
			fDeregisterCallback = TRUE;

			//
			// now notify enum1394 (if it is already loaded) use Arg1 to tell it where
			// the notification is coming from
			//
			ExNotifyCallback(Nic1394CallbackObject,
							(PVOID)NDIS1394_CALLBACK_SOURCE_NIC1394,
							(PVOID)&Nic1394Characteristics);


			NtStatus = STATUS_SUCCESS;
			fDerefCallbackObject = fDeregisterCallback = FALSE;
	    }
	    else
	    {
	        NdisTerminateWrapper( NdisWrapperHandle, NULL );
	        NtStatus = NdisStatus;
	        break;
	    }
	} while (FALSE);


	if (fDerefCallbackObject)
	{
		ObDereferenceObject(Nic1394CallbackObject);
	}

	if (fDeregisterCallback)
	{
		ExUnregisterCallback(Nic1394CallbackRegisterationHandle);
	}
	
	if (NtStatus != STATUS_SUCCESS)
	{
		if (NdisEnum1394DeregisterDriver != NULL)
			NdisEnum1394DeregisterDriver();
	}
	
    return NtStatus;
}







VOID
NicUnloadHandler(
	IN	PDRIVER_OBJECT			DriverObject
	)
{
	ASSERT(IsListEmpty(&g_AdapterList));



	if (NdisEnum1394DeregisterDriver != NULL)
	{
		NdisEnum1394DeregisterDriver();
	}

	if (Nic1394CallbackRegisterationHandle != NULL)
	{
		ExUnregisterCallback(Nic1394CallbackRegisterationHandle);
	}
	
	if (Nic1394CallbackObject != NULL)
	{
		ObDereferenceObject(Nic1394CallbackObject);
	}
	
	return;
}


VOID
nicDeregisterWithEnum ()

{

	if (NdisEnum1394DeregisterDriver != NULL)
	{
		NdisEnum1394DeregisterDriver();
	}


}


VOID 
nicDeregisterWithKernel ()
{

	if (Nic1394CallbackRegisterationHandle != NULL)
	{
		ExUnregisterCallback(Nic1394CallbackRegisterationHandle);
	}
	
	if (Nic1394CallbackObject != NULL)
	{
		ObDereferenceObject(Nic1394CallbackObject);
	}


}







//
// the registeration entry for enum1394
// typically this will be only called if enum1394 detects the presence of
// the nic1394 through receiving a call back notification. this is how enum1394
// lets nic1394 know that it is there and ready.
// if nic1394 detects the presence of the enum1394 by receiving a notification
// callbak, it will call NdisEunm1394RegisterDriver and in that case enum1394
// will -not- call Nic1394RegisterDriver.
//
NTSTATUS
NicRegisterEnum1394(
	IN	PNDISENUM1394_CHARACTERISTICS	NdisEnum1394Characteristcis
	)
{
	PADAPTERCB	pAdapter;
	LIST_ENTRY	*pAdapterListEntry;
	
	NdisEnum1394RegisterDriver = NdisEnum1394Characteristcis->RegisterDriverHandler;
	NdisEnum1394DeregisterDriver = NdisEnum1394Characteristcis->DeregisterDriverHandler;
	NdisEnum1394RegisterAdapter = NdisEnum1394Characteristcis->RegisterAdapterHandler;
	NdisEnum1394DeregisterAdapter = NdisEnum1394Characteristcis->DeregisterAdapterHandler;

	Nic1394RegisterAdapters();

	return STATUS_SUCCESS;

}

VOID
NicDeregisterEnum1394(
	VOID
	)
{
	PADAPTERCB	pAdapter;
	LIST_ENTRY	*pAdapterListEntry;

	//
	// go through all the adapters and Deregister them if necessary
	//
	NdisAcquireSpinLock (&g_DriverLock);

	for (pAdapterListEntry = g_AdapterList.Flink; 
		pAdapterListEntry != &g_AdapterList; 
		pAdapterListEntry = pAdapterListEntry->Flink)
	{
		pAdapter = CONTAINING_RECORD(pAdapterListEntry, 
		                             ADAPTERCB,
		                             linkAdapter);
		                             
		if (ADAPTER_TEST_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator))
		{
		    nicReferenceAdapter(pAdapter,"NicDeregisterEnum1394");
			NdisReleaseSpinLock(&g_DriverLock);

			NdisEnum1394DeregisterAdapter((PVOID)pAdapter->EnumAdapterHandle);
								   		   
			NdisAcquireSpinLock( &g_DriverLock);
			nicDereferenceAdapter(pAdapter, "NicDeregisterEnum1394");
			
		}
		
		ADAPTER_CLEAR_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator | fADAPTER_FailedRegisteration);
		
	}
	
	NdisReleaseSpinLock(&g_DriverLock);

	NdisEnum1394RegisterDriver = NULL;
	NdisEnum1394DeregisterDriver = NULL;
	NdisEnum1394RegisterAdapter = NULL;
	NdisEnum1394DeregisterAdapter = NULL;
}

VOID
Nic1394Callback(
	PVOID	CallBackContext,
	PVOID	Source,
	PVOID	Characteristics
	)
{
	NTSTATUS	Status;
	
	//
	// if we are the one issuing this notification, just return
	//
	if (Source == (PVOID)NDIS1394_CALLBACK_SOURCE_NIC1394)
		return;

	//
	// notification is coming from Nic1394. grab the entry points. call it and
	// let it know that you are here
	//
	ASSERT(Source == (PVOID)NDIS1394_CALLBACK_SOURCE_ENUM1394);

	if (Source != (PVOID)NDIS1394_CALLBACK_SOURCE_ENUM1394)
	{
		return;
	}

	NdisEnum1394RegisterDriver = ((PNDISENUM1394_CHARACTERISTICS)Characteristics)->RegisterDriverHandler;

	ASSERT(NdisEnum1394RegisterDriver != NULL);

	if (NdisEnum1394RegisterDriver == NULL)
	{
		//
		// invalid characteristics
		//
		return;		
	}

	
	Status = NdisEnum1394RegisterDriver(&Nic1394Characteristics);
	
	if (Status == STATUS_SUCCESS)
	{
		NdisEnum1394DeregisterDriver = ((PNDISENUM1394_CHARACTERISTICS)Characteristics)->DeregisterDriverHandler;
		NdisEnum1394RegisterAdapter = ((PNDISENUM1394_CHARACTERISTICS)Characteristics)->RegisterAdapterHandler;
		NdisEnum1394DeregisterAdapter = ((PNDISENUM1394_CHARACTERISTICS)Characteristics)->DeregisterAdapterHandler;
		
		Nic1394RegisterAdapters();
	}
	else
	{
		NdisEnum1394RegisterDriver = NULL;
	}
	
}

//
// This function walks the global list of the adapters and 
// will register those that have not been registered with enum1394
//
VOID
Nic1394RegisterAdapters(
	VOID
	)
{
	PADAPTERCB		pAdapter;
	LIST_ENTRY		*pAdapterListEntry;
	LARGE_INTEGER	LocalHostUniqueId;
	NTSTATUS		NtStatus;
	
	//
	// go through all the adapters and register them if necessary. if there are
	// any remote nodes connected to these adapters, they will be indicated back
	// in the context of registering the adapter
	//
	NdisAcquireSpinLock(&g_DriverLock);

	for (pAdapterListEntry = g_AdapterList.Flink; 
		 pAdapterListEntry != &g_AdapterList; 
		 pAdapterListEntry = pAdapterListEntry->Flink)
	{
		pAdapter = CONTAINING_RECORD(pAdapterListEntry, 
		                             ADAPTERCB,
		                             linkAdapter);
		                             
		if (!ADAPTER_TEST_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator | fADAPTER_FailedRegisteration))
		{
		    nicReferenceAdapter (pAdapter, "Nic1394RegisterAdapters");
			NdisReleaseSpinLock (&g_DriverLock);

			NtStatus = NdisEnum1394RegisterAdapter((PVOID)pAdapter,
													pAdapter->pNdisDeviceObject,
													&pAdapter->EnumAdapterHandle,
													&LocalHostUniqueId);
								   		   
			NdisAcquireSpinLock(&g_DriverLock);
			nicDereferenceAdapter(pAdapter, "Nic1394RegisterAdapters");
			
			if (NtStatus == STATUS_SUCCESS)
			{
				ADAPTER_SET_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator);
			}
			else
			{
				ADAPTER_SET_FLAG(pAdapter, fADAPTER_FailedRegisteration);
			    TRACE(TL_A, TM_All, ("Nic1394RegisterAdapters: failed to register Adapter %lx with enum1394. Status %lx\n", pAdapter, NtStatus));
			}
		}
		
	}
	
	NdisReleaseSpinLock(&g_DriverLock);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\pktlog.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// pktlog.c
//
// IEEE1394 mini-port/call-manager driver
//
// Packet logging utilities.
//
// 10/12/1999 JosephJ Created
//
    
#include <precomp.h>






VOID
nic1394InitPktLog(
    PNIC1394_PKTLOG pPktLog
    )
/*++

Routine Description:

    Initializes a packet log.

Arguments:

    pPktLog     - Pkt log to to be initialized.

--*/
{
    if (pPktLog == NULL)
        return;
    NdisZeroMemory(pPktLog, sizeof(*pPktLog));
    pPktLog->InitialTimestamp = KeQueryPerformanceCounter(
                                        &pPktLog->PerformanceFrequency);
    pPktLog->EntrySize = sizeof(pPktLog->Entries[0]);
    pPktLog->NumEntries = N1394_NUM_PKTLOG_ENTRIES;

}


VOID
Nic1394LogPkt (
    PNIC1394_PKTLOG pPktLog,
    ULONG           Flags,
    ULONG           SourceID,
    ULONG           DestID,
    PVOID           pvData,
    ULONG           cbData
)
/*++

Routine Description:

    Adds a pkt log entry to the specified circular pkt log.
    The entry gets added at location
     (NdisInterlockedIncrement(&pPktLog->SequenceNo) % N1394_NUM_PKTLOG_ENTRIES)

    May be called at any IRQL. Does not use explicit locking -- relies on
    the serialization produced by NdisInterlockedIncrement.

Arguments:

    pPktLog     - Pkt log to log packet
    Flags       - User-defined flags
    SourceID    - User-defined source ID
    DestID      - User-defined destination ID
    pvData      - Data from packet  // can be null
    cbData      - size of this data (at most N1394_PKTLOG_DATA_SIZE bytes are logged)


--*/
{
    ULONG                       SequenceNo;
    PN1394_PKTLOG_ENTRY         pEntry;

    SequenceNo      = NdisInterlockedIncrement(&pPktLog->SequenceNo);
    pEntry          = &pPktLog->Entries[SequenceNo % N1394_NUM_PKTLOG_ENTRIES];

    pEntry->SequenceNo          = SequenceNo;
    pEntry->Flags               = Flags;
    pEntry->TimeStamp           = KeQueryPerformanceCounter(NULL);
    pEntry->SourceID            = SourceID;
    pEntry->DestID              = DestID;
    pEntry->OriginalDataSize    = cbData;

    if (cbData > sizeof(pEntry->Data))
    {
        cbData = sizeof(pEntry->Data);
    }

    if (pvData != NULL && cbData != 0)
    {
        NdisMoveMemory(pEntry->Data, pvData, cbData);
    }
}



VOID
nic1394AllocPktLog(
    IN ADAPTERCB* pAdapter
    )
/*++

Routine Description:

    Initialize the packet log
    
Arguments:
    
Return Value:

--*/
{
    ASSERT (pAdapter->pPktLog==NULL);
    pAdapter->pPktLog =  ALLOC_NONPAGED(sizeof(*pAdapter->pPktLog), MTAG_PKTLOG);
    if (pAdapter->pPktLog == NULL)
    {
        TRACE( TL_A, TM_Misc, ( "  Could not allocate packet log for Adapter %x",
                    pAdapter ) );
    }
}

VOID
nic1394DeallocPktLog(
    IN ADAPTERCB* pAdapter
    )
/*++

Routine Description:

        Free the packet log
        
Arguments:
    
Return Value:

--*/
{
    
    if (pAdapter->pPktLog != NULL)
    {
        FREE_NONPAGED(pAdapter->pPktLog);
        pAdapter->pPktLog = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\pktlog.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// pktlog.c
//
// IEEE1394 mini-port/call-manager driver
//
// Packet logging utilities.
//
// 10/12/1999 JosephJ Created
//
    

#define N1394_PKTLOG_DATA_SIZE 64       // Amount of data logged per packet.

#define N1394_NUM_PKTLOG_ENTRIES 1000   // Size of log (circular buffer)


//----------------------------------------------------------------------
// P A C K E T     L O G G I N G
//----------------------------------------------------------------------

// One (fixed-size)  log entry.
//
typedef struct
{
    ULONG Flags;                            // User-defined flags
    ULONG SequenceNo;                       // Sequence number of this entry

    LARGE_INTEGER TimeStamp;                // Timestamp (KeQueryPerformanceCounter)

    ULONG SourceID;
    ULONG DestID;

    ULONG OriginalDataSize;
    ULONG Reserved;

    UCHAR Data[N1394_PKTLOG_DATA_SIZE];

} N1394_PKTLOG_ENTRY, *PN1394_PKTLOG_ENTRY;

typedef struct
{
    LARGE_INTEGER           InitialTimestamp;       // In 100-nanoseconds.
    LARGE_INTEGER           PerformanceFrequency;   // In Hz.
    ULONG                   SequenceNo;             // Current sequence number
    ULONG                   EntrySize;              // sizeof(N1394_PKTLOG_ENTRY)
    ULONG                   NumEntries;             // N1394_NUM_PKTLOG_ENTRIES
    N1394_PKTLOG_ENTRY      Entries[N1394_NUM_PKTLOG_ENTRIES];
    
} NIC1394_PKTLOG, *PNIC1394_PKTLOG;


    

VOID
nic1394InitPktLog(
    PNIC1394_PKTLOG pPktLog
    );

VOID
Nic1394LogPkt (
    PNIC1394_PKTLOG pPktLog,
    ULONG           Flags,
    ULONG           SourceID,
    ULONG           DestID,
    PVOID           pvData,
    ULONG           cbData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\receive.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// receive.c
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port Receive routines
//
// 2/13/1998 ADube Created, 
//

#include <precomp.h>
#define MAX_NUM_SLIST_ENTRY 0x10
//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
nicAllocateAddressRangeCallback( 
    IN PNOTIFICATION_INFO NotificationInfo 
);

VOID
nicAllocateAddressRangeDebugSpew(
    IN PIRB pIrb 
    );

NDIS_STATUS
nicGetInitializedAddressFifoElement(
    IN     UINT BufferLength, 
    IN OUT PADDRESS_FIFO *ppElement 
    );

NDIS_STATUS
nicGetEmptyAddressFifoElement(
    IN PADDRESS_FIFO *ppElement
    );
    
VOID
nicReceivePacketWorkItem(
    PNDIS_WORK_ITEM pWorkItem,
    PVOID   pContext
    );

VOID
nicAllocateRemainingFifoWorkItem (
    PNDIS_WORK_ITEM pNdisWorkItem, 
    IN PVOID Context
    );

VOID
nicFifoAllocationScheme (
    PRECVFIFO_VCCB pRecvFIFOVc
);

ULONG           ReassemblyAllocated = 0;
extern ULONG           NdisBufferAllocated[NoMoreCodePaths];
extern ULONG           NdisBufferFreed[NoMoreCodePaths];

//-----------------------------------------------------------------------------
// prototype implementation (alphabetically)
//-----------------------------------------------------------------------------

/*
NDIS_STATUS
nicAllocateAddressRange(
    IN PREMOTE_NODE pRemoteNode
    )
*/

NDIS_STATUS
nicAllocateAddressRange(
    IN PADAPTERCB pAdapter,
    IN PRECVFIFO_VCCB pRecvFIFOVc
    )

    // Function Description:
    //  This function will use the AllocateAddressRange Bus Api
    //  To do this it must initialize an S-list with structures
    //  Allocate and Initialize an Irb and an Irp and call the nic
    //  nicSubmitIrp routine
    //  This routine will complete synchronously
    //
    //
    // Arguments
    //  pdo Cb The Pdo for the remote node on which the address range will 
    //  be allocated. There is also a pointer to the Paramters that need to be 
    //
    // Return Value:
    //
    //  
{

    PIRB                    pIrb = NULL;
    PIRP                    pIrp = NULL; 
    PSLIST_HEADER           pSlistHead = NULL;
    UINT                    cnt = 0;   
    PDEVICE_OBJECT          pPdo = NULL;
    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    UINT                    Length;
    ADDRESS_OFFSET          AddressOffset;
    UINT                    MaxNumSlistEntry = MAX_NUM_SLIST_ENTRY;
    BOOLEAN                 bRefCall = FALSE;
    STORE_CURRENT_IRQL;
    
        
    ASSERT (pRecvFIFOVc == pAdapter->pRecvFIFOVc);
    
    ASSERT (pRecvFIFOVc != NULL);

    TRACE( TL_T, TM_Recv, ( "==>nicAllocateAddressRange, pAdapter 8x, pRecvFIFOVc %x", pAdapter, pRecvFIFOVc ) );

    
    do
    {
        // Increment the Refcount on the VC, so we can gaurantee its presence
        //
        VC_ACQUIRE_LOCK (pRecvFIFOVc)   

        //
        // Add a reference to the pdo block. 
        // This reference is added to guarantee its presence
        // Removed in Free Address Range or at the end of the function
        //
        
        bRefCall =  nicReferenceCall ((PVCCB) pRecvFIFOVc, "nicAllocateAddressRange" ) ;

        VC_RELEASE_LOCK (pRecvFIFOVc);

        if ( bRefCall == FALSE )
        {
            //
            // This will only fail if the Vc is not activated
            //
            NdisStatus = NDIS_STATUS_FAILURE;
        
            break;
        }
        
        //
        //  Allocate an IRB                                                                                                                                
        //
        
        NdisStatus = nicGetIrb (&pIrb);
    
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }
    
        ASSERT (pIrb != NULL);
        
        //
        // Initalize the IrB with the correct values
        // AllocateAddressRange
        //

        ASSERT (pRecvFIFOVc->Hdr.Nic1394MediaParams.Destination.AddressType == NIC1394AddressType_FIFO);
        
        AddressOffset.Off_High = pRecvFIFOVc->Hdr.Nic1394MediaParams.Destination.FifoAddress.Off_High;

        AddressOffset.Off_Low = pRecvFIFOVc->Hdr.Nic1394MediaParams.Destination.FifoAddress.Off_Low;

        ASSERT (pRecvFIFOVc->Hdr.MTU !=0 );
        
        Length = pRecvFIFOVc->Hdr.MTU;
                
        nicInitAllocateAddressIrb( pIrb,    
                                pAdapter,
                                0,
                                Length,
                                0,
                                ACCESS_FLAGS_TYPE_WRITE|ACCESS_FLAGS_TYPE_BROADCAST,
                                NOTIFY_FLAGS_AFTER_WRITE,
                                &AddressOffset,
                                pRecvFIFOVc);
            
        //
        // Allocate an Irp
        //

    
        NdisStatus = nicGetIrp (pAdapter->pNdisDeviceObject, &pIrp);
                                                                                                                                                             
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        ASSERT(pIrp != NULL);
    
        NdisStatus = nicSubmitIrp_LocalHostSynch(pAdapter,
                                               pIrp,
                                               pIrb );
                           

        //
        // Make this a synchronous call as this is during init
        //
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Recv, ( "nicAllocateAddressRange SUBMIT IRP FAILED NdisStatus %.8x", NdisStatus ) );

            break;
            
        }

        nicAllocateAddressRangeDebugSpew(pIrb);

        //
        // Check to see if the IoCallDriver succeeded
        //

        if(pIrp->IoStatus.Status == STATUS_SUCCESS)
        {
            NdisStatus = nicAllocateAddressRangeSucceeded (pIrb, pRecvFIFOVc);
            

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }
        else
        {
            ASSERT (pIrp->IoStatus.Status != STATUS_MORE_PROCESSING_REQUIRED);
            // else mark status as failure
            //
            // 
            //This means dereference will happen in this function
            NdisStatus = NDIS_STATUS_FAILURE;
            
        }
        //
        // we need to clean up the Irb and the Irp
        //

        
    } while (FALSE);

    //
    // Clean up -dereference the Call if things failed
    // If we successfully completed the Irp then all the references made above
    // will be dereferenced when the remote node goes away or the
    // Call is closed
    //
    // Deref the references that were made above. 
   
    VC_ACQUIRE_LOCK (pRecvFIFOVc);

    if (! NT_SUCCESS (NdisStatus))
    {
        if (bRefCall == TRUE)
        {
            nicDereferenceCall ( (PVCCB) pRecvFIFOVc , "nicAllocateAddressRange");

        }
        
    }
    
    VC_RELEASE_LOCK (pRecvFIFOVc);

    // We don't care about the status as we are just freeing locally allocated memory
    //
    if (pIrb != NULL)
    {
        nicFreeIrb (pIrb);
    }
    
    if (pIrp!= NULL)
    {
        nicFreeIrp (pIrp);
    }


    MATCH_IRQL

    TRACE( TL_T, TM_Recv, ( "<==nicAllocateAddressRange, pVc %.8x, Status %.8x ", pRecvFIFOVc, NdisStatus ) );

    return NdisStatus;

}
 



VOID
nicAllocateAddressRangeCallback( 
    IN PNOTIFICATION_INFO pNotificationInfo 
    )
{
    PADAPTERCB pAdapter = (PADAPTERCB) pNotificationInfo->Context;
    PRECVFIFO_VCCB pRecvFIFOVc = pAdapter->pRecvFIFOVc;
    PNODE_ADDRESS pSenderNodeAddress = NULL;

    //
    // Debug spew for debugging
    //
    
    TRACE( TL_V, TM_Recv, ( "    Mdl is at %.8x",pNotificationInfo->Mdl ) );
       
    TRACE( TL_V, TM_Recv, ( "    ulLength is %.8x",pNotificationInfo->nLength) );
    
    TRACE( TL_V, TM_Recv, ( "    pNotificationInfo->RequestPacket %x, ", pNotificationInfo->RequestPacket) );

    TRACE( TL_V, TM_Recv, ( "    tLabel %x, ", ((PASYNC_PACKET)pNotificationInfo->RequestPacket)->AP_tLabel) );

    pSenderNodeAddress = & (((PASYNC_PACKET)pNotificationInfo->RequestPacket)->AP_Source_ID);

    TRACE( TL_V, TM_Recv, ( "    Senders' NodeAddress %x, ", pSenderNodeAddress->NA_Node_Number ) );

    TRACE (TL_V, TM_Reas,("tLabel %x    ", ((PASYNC_PACKET)pNotificationInfo->RequestPacket)->AP_tLabel));

    NdisInterlockedIncrement (&pRecvFIFOVc->NumIndicatedFifos);
    
    pNotificationInfo->Fifo->FifoList.Next = NULL;
    pNotificationInfo->Fifo->FifoMdl->Next = NULL;

    nicFifoAllocationScheme (pRecvFIFOVc);

    nicSetTagInFifoWrapper(pNotificationInfo->Fifo, NIC1394_TAG_IN_CALLBACK);


    nicStatsRecordNumIndicatedFifos(pRecvFIFOVc->NumIndicatedFifos);

    nicReceiveCommonCallback (pNotificationInfo, 
                             (PVCCB)pRecvFIFOVc ,
                             AddressRange,
                             pNotificationInfo->Mdl );
}




VOID
nicAllocateAddressRangeDebugSpew(
    IN PIRB pIrb )


    // Prints out all the parameters of the allocateaddressrange Irb
    //
{

    

    ASSERT(pIrb);

/*  TRACE( TL_T, TM_Recv, ( "==>nicAllocateAddressRangeDebugSpew pIrb %.8x", pIrb ) );
    
    
    //
    // Spew out all the information you can
    //


    TRACE(TL_V, TM_Recv, ("MaxSegmentSize = 0x%x\n", pIrb->u.AllocateAddressRange.MaxSegmentSize));
    TRACE(TL_V, TM_Recv, ("fulAccessType = 0x%x\n", pIrb->u.AllocateAddressRange.fulAccessType));
    TRACE(TL_V, TM_Recv, ("fulNotificationOptions = 0x%x\n", pIrb->u.AllocateAddressRange.fulNotificationOptions));
    TRACE(TL_V, TM_Recv, ("Callback = 0x%x\n", pIrb->u.AllocateAddressRange.Callback));
    TRACE(TL_V, TM_Recv, ("Context = 0x%x\n", pIrb->u.AllocateAddressRange.Context));
    TRACE(TL_V, TM_Recv, ("Required1394Offset->Off_High = 0x%x\n", pIrb->u.AllocateAddressRange.Required1394Offset.Off_High));
    TRACE(TL_V, TM_Recv, ("Required1394Offset->Off_Low = 0x%x\n", pIrb->u.AllocateAddressRange.Required1394Offset.Off_Low));
    TRACE(TL_V, TM_Recv, ("FifoSListHeader = 0x%x\n", pIrb->u.AllocateAddressRange.FifoSListHead));
    TRACE(TL_V, TM_Recv, ("FifoSListSpinLock = 0x%x\n", pIrb->u.AllocateAddressRange.FifoSpinLock));
    TRACE(TL_V, TM_Recv, ("AddressesReturned = 0x%x\n", pIrb->u.AllocateAddressRange.AddressesReturned));
    TRACE(TL_V, TM_Recv, ("p1394AddressRange = 0x%x\n", pIrb->u.AllocateAddressRange.p1394AddressRange));
    TRACE(TL_V, TM_Recv, ("hAddressRange = 0x%x\n", pIrb->u.AllocateAddressRange.hAddressRange));

    
    TRACE(TL_V, TM_Recv, ("AR_Off_High 0x%.4x\n",pIrb->u.AllocateAddressRange.p1394AddressRange[0].AR_Off_High));
    TRACE(TL_V, TM_Recv, ("AR_Off_Low 0x%.8x\n",pIrb->u.AllocateAddressRange.p1394AddressRange[0].AR_Off_Low));
    TRACE(TL_V, TM_Recv, ("AR_Length 0x%.8x\n",pIrb->u.AllocateAddressRange.p1394AddressRange[0].AR_Length));

    ASSERT(pIrb->u.AllocateAddressRange.AddressesReturned == 1);
*/
    
    TRACE( TL_T, TM_Recv, ( "<==nicAllocateAddressRangeComplete" ) );
    return;

}



NDIS_STATUS
nicAllocateAddressRangeSucceeded (
    IN PIRB pIrb,
    IN OUT PRECVFIFO_VCCB   pRecvFIFOVc
    )
    // Function Description:
    // This function updates all the Vc, PdoCb structures once the allocate address range Irb has succeeded
    // If the Irp succeeds but the rempte node is going away then it will free the address range before
    // returning
    // The Irb is used to initialize the fields. If this is the first Pdo for Vc, then it will initlalize the VC. 
    // It will also check to see if the data returned by the Irb matches with the data in the Vc
    // Arguments:
    // PIRB : The Irb that was used in the Irp that just succeeded
    // REMOTE_NODE : The PdoCb that was used to perform the IoCallDriver ... (remote node)
    //
    // Return Value:
    // Success if the remote node is active 
    // failure if the remote node has gone away and it need to free the address range
    //
    
{

    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    BOOLEAN                 fPdoBeingRemoved = FALSE;
    NIC1394_FIFO_ADDRESS *pFifoAddress = NULL; 
    BOOLEAN                 fFirstAddressRangeOnVc = FALSE;

    //
    // These are pointers to the locations that the newly allocated address range needs to be copied to 
    //

    ADDRESS_RANGE           *pSrcAddressRange = &pIrb->u.AllocateAddressRange.p1394AddressRange[0];
//  ADDRESS_RANGE           *pPdoAddressRange = &pRemoteNode->RecvFIFOData.VcAddressRange;
    ADDRESS_RANGE           *pVcAddressRange = &pRecvFIFOVc->VcAddressRange;

    TRACE( TL_T, TM_Recv, ( "==>nicAllocateAddressRangeSucceeded pIrb %.8x, ", pIrb) );


    ASSERT (pIrb->u.AllocateAddressRange.AddressesReturned == 1);

    //
    // we expect this to be populated or 
    // nicFreeAllAllocatedAddressRangesOnPdo will have problems
    //
    ASSERT (pRecvFIFOVc != NULL);


    //
    // If both high and low are zero, the bus driver is doing something wrong, return  Failure
    //

    if (pSrcAddressRange->AR_Off_Low ==0 && pSrcAddressRange ->AR_Off_High == 0)
    {   
        // Some fun with DeMorgan's theorem
        ASSERT (pSrcAddressRange->AR_Off_Low!=0 || pSrcAddressRange ->AR_Off_High!=0);
        return NDIS_STATUS_FAILURE;
    }
    
    //
    // Copy the Address Ranges returned. For now just copy locally without allocating extra memory
    //

    pFifoAddress = &pRecvFIFOVc->Hdr.Nic1394MediaParams.Destination.FifoAddress;

    VC_ACQUIRE_LOCK (pRecvFIFOVc);

    do 
    {

        //
        // Now we need copy the returned values to the Pdo structure.
        //
        
        
//      pPdoAddressRange->AR_Off_Low = pSrcAddressRange->AR_Off_Low;
//      pPdoAddressRange ->AR_Off_High = pSrcAddressRange ->AR_Off_High;
//      pPdoAddressRange->AR_Length = pSrcAddressRange->AR_Length;
//      pRemoteNode->RecvFIFOData.AddressesReturned = pIrb->u.AllocateAddressRange.AddressesReturned;
//      pRemoteNode->RecvFIFOData.hAddressRange = pIrb->u.AllocateAddressRange.hAddressRange ;


        //
        // check to see if we need to update the Recv Fifo's structures. This needs to be done if the addresses are zeroes
        //
        if (pFifoAddress->Off_Low  == 0 && pFifoAddress->Off_High  == 0)
        {

            fFirstAddressRangeOnVc = TRUE;
            
            pFifoAddress->Off_Low  = pSrcAddressRange->AR_Off_Low;
            pFifoAddress->Off_High = pSrcAddressRange->AR_Off_High;


            pVcAddressRange->AR_Off_Low = pSrcAddressRange->AR_Off_Low;
            pVcAddressRange->AR_Off_High = pSrcAddressRange->AR_Off_High;
            pVcAddressRange->AR_Length = pSrcAddressRange->AR_Length;


        }
        else 
        {
            ASSERT (pFifoAddress->Off_Low == pSrcAddressRange->AR_Off_Low);
            ASSERT (pFifoAddress->Off_High == pSrcAddressRange->AR_Off_High);

        }

        pRecvFIFOVc->AddressesReturned = pIrb->u.AllocateAddressRange.AddressesReturned;
        pRecvFIFOVc->hAddressRange = pIrb->u.AllocateAddressRange.hAddressRange;

//      if (REMOTE_NODE_TEST_FLAGS (pRemoteNode, PDO_BeingRemoved))
//      {
//          fPdoBeingRemoved = TRUE;


            //
            // This flag implies that the allocate address range Irp will be failed
            // i.e. nicAllocateAddressIrp will return failure, it is now our responsiblity
            // to free all resources 
            //
//          NdisStatus = NDIS_STATUS_FAILURE;

//          break;
//      }

        //
        // otherwise we have succeeded, now it is the remote node's responsibility to free us
        //
//      pRemoteNode->RecvFIFOData.AllocatedAddressRange = TRUE;
    
        //
        // If we reached this far, we have succeeded
        //
        NdisStatus = NDIS_STATUS_SUCCESS;   

    } while (FALSE);

    VC_RELEASE_LOCK (pRecvFIFOVc);
    TRACE( TL_T, TM_Recv, ( "   hAddressRange %x, NumReturned %x , Low %x , Hi %x, Length %x", 
                             pRecvFIFOVc->hAddressRange ,
                             pRecvFIFOVc->AddressesReturned,
                             pSrcAddressRange->AR_Off_Low,
                             pSrcAddressRange->AR_Off_High,
                             pSrcAddressRange->AR_Length) );


//  if (fPdoBeingRemoved == TRUE)
//  {
        //
        // We need to free the address range as the pdo is being 
        // removed and we have not updated any of the Pdo's data structures
        //

//      nicFreeRecvFifoAddressRange (pRemoteNode);

        //
        // Clear the pointers to  the Address Range, they exist in both 
        // the Pdo Block and the VC Block.
        // However clear the Vc blocks' copy of the address range only if this 
        // is the Allocate Address Range that populated it 
        //
        
//      NdisZeroMemory (&pRemoteNode->RecvFIFOData, sizeof (RECV_FIFO_DATA));
        
//      if (fFirstAddressRangeOnVc = TRUE)
//      {
//          pFifoAddress->Off_Low  = 0;
//          pFifoAddress->Off_High = 0;


//          pVcAddressRange->AR_Off_Low = 0;
//          pVcAddressRange->AR_Off_High = 0;
//          pVcAddressRange->AR_Length = 0;
//          pRecvFIFOVc->AddressesReturned = 0;
                        
//      }
//  }


    TRACE( TL_T, TM_Recv, ( "<==nicAllocateAddressRangeSucceeded Status %.8x", NdisStatus ) );

    return NdisStatus;
}


NDIS_STATUS
nicFreeAddressFifo(
    IN PADDRESS_FIFO pAddressFifo,
    IN PRECVFIFO_VCCB pRecvFIFOVc 
    )
    //
    // Frees the address fifo element and also its local buffer 
    // IMP: The Addressfifo should belong to the pRecvFIFOVc 
    //

{

    PVOID SystemAddress = NIC_GET_SYSTEM_ADDRESS_FOR_MDL (pAddressFifo->FifoMdl);
    UINT Length = MmGetMdlByteCount(pAddressFifo->FifoMdl);

    ASSERT (SystemAddress!=NULL);
    ASSERT (Length != 0);
    
    TRACE( TL_T, TM_Recv, ( "==>nicFreeAddressFifo") );

    if (SystemAddress != NULL)
    {
        nicFreeLocalBuffer(Length, SystemAddress);
    }
    
    nicFreeMdl (pAddressFifo->FifoMdl);

    nicSetTagInFifoWrapper(pAddressFifo, NIC1394_TAG_FREED );

    FREE_NONPAGED((PVOID)pAddressFifo);

    //
    // Dereference the reference added when this AddressFifo was inserted into the list
    //

    nicDereferenceCall ((PVCCB)pRecvFIFOVc, "nicFreeAddressFifo");

    

    TRACE( TL_T, TM_Recv, ( "<==nicFreeAddressFifo") );

    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
nicFreeAllocateAddressRangeSList(
    IN PRECVFIFO_VCCB pRecvFIFOVc 
    )
    //
    // This function should pop entries from the Slist
    // Each entry is an Adress_fifo element containing an MDl
    // The function should call nicFreeAddressFifo to free the Address FIFO element
    // 
{

    NDIS_STATUS         NdisStatus = NDIS_STATUS_SUCCESS;
    PADDRESS_FIFO       pAddressFifoElement = NULL;
    SINGLE_LIST_ENTRY   *pSingleListEntry = NULL;
    UINT                NumFreed = 0;

    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Recv, ( "==>nicFreeAllocateAddressRangeSList, Num %.8x", 
                              ExQueryDepthSList (&pRecvFIFOVc->FifoSListHead) ) );

    while ( ExQueryDepthSList (&pRecvFIFOVc->FifoSListHead) != 0)
    {
        pSingleListEntry= ExInterlockedPopEntrySList ( &pRecvFIFOVc->FifoSListHead,
                                                  &pRecvFIFOVc->FifoSListSpinLock );

        //
        // This will dereference the call
        //
        pAddressFifoElement = CONTAINING_RECORD (pSingleListEntry, ADDRESS_FIFO, FifoList);

        ASSERT (pAddressFifoElement != NULL);

        //
        // This will dereference the Vc and free the address fifo
        //
        NdisStatus = nicFreeAddressFifo ( pAddressFifoElement, 
                                          pRecvFIFOVc ); 
        NumFreed ++;                                          
    }

    VC_ACQUIRE_LOCK (pRecvFIFOVc);

    ASSERT ( ExQueryDepthSList (&pRecvFIFOVc->FifoSListHead) == 0);
    
    pRecvFIFOVc->FifoSListHead.Alignment = 0;
    pRecvFIFOVc->NumOfFifosInSlistInCloseCall = NumFreed;

    VC_RELEASE_LOCK (pRecvFIFOVc);


    MATCH_IRQL;

    TRACE( TL_T, TM_Recv, ( "<==nicFreeAllocateAddressRangeSList %.8x, NumFreed %x", NdisStatus, NumFreed  ) );
    return NdisStatus;

}


NDIS_STATUS
nicFreeRecvFifoAddressRangeOnAllRemoteNodes (
    IN PADAPTERCB pAdapter 
    )           
    // Function Description:
    // This will walk through all the remote nodes and remove the address range 
    // on each remote node
    // The implicit assumption is that RecvFIFO's will be allocated on all remote nodes 
    // on an adapter
    // Arguments
    // pAdapter - the adapter on which all the remote nodes are on. 
    //
    // Return Value:
    // Success : Always
    // Even if one fails this will continue to try on all remaining nodes
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PLIST_ENTRY pPdoListEntry = NULL;
    REMOTE_NODE *pRemoteNode = NULL;
    
    TRACE( TL_T, TM_Recv, ( "==>nicFreeRecvFifoAddressRangeOnAllRemoteNodes Adapter %.8x", pAdapter) );

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    //
    // Now Walk the list and free the address range on each pdo
    //
    for (pPdoListEntry = ListNext (&pAdapter->PDOList);
        pPdoListEntry != &pAdapter->PDOList;
        pPdoListEntry = ListNext(pPdoListEntry))
    {
        ADDRESS_RANGE *pPdoAddressRange, *pVcAddressRange;
        
        pRemoteNode = CONTAINING_RECORD (pPdoListEntry, REMOTE_NODE, linkPdo);

        pPdoAddressRange = &pRemoteNode->RecvFIFOData.VcAddressRange;
        pVcAddressRange = &pRemoteNode->pAdapter->pRecvFIFOVc->VcAddressRange;

            
        TRACE( TL_V, TM_Recv, ( "Closing all address ranges on pRemoteNode %.8x", pRemoteNode) );

        if (REMOTE_NODE_TEST_FLAG (pRemoteNode, PDO_BeingRemoved) == TRUE)
        {
            //
            // This flag is set in the Remove Remote node code path. 
            // If this flag is set, we do not have to free the address range
            // If Not Set, then Arp has asked to close the call and we must free
            // the address range
            //
            continue;

        }

        //
        // Debug checks to see if the values match up
        //
        ASSERT ( pPdoAddressRange->AR_Off_Low == pVcAddressRange->AR_Off_Low);
        ASSERT ( pPdoAddressRange->AR_Off_High == pVcAddressRange->AR_Off_High);
        ASSERT ( pPdoAddressRange->AR_Length == pVcAddressRange->AR_Length);

        


        //
        // Now free the address range 
        // This function expects the lock to be held
        //
        
        NdisStatus = nicFreeAllAllocatedAddressRangesOnPdo (pRemoteNode);


        if (pRemoteNode != NULL)
        {
            NdisZeroMemory (&pRemoteNode->RecvFIFOData, sizeof (RECV_FIFO_DATA) );
        }

        
    }

    
    ADAPTER_RELEASE_LOCK (pAdapter);

    NdisStatus = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Recv, ( "<==nicFreeRecvFifoAddressRangeOnAllRemoteNodes Status %.8x", NdisStatus) );

    return NdisStatus;
}



NDIS_STATUS
nicFreeAllAllocatedAddressRangesOnPdo (
    IN PREMOTE_NODE pRemoteNode
    )
    // Function Description:
    // Goes through the PdoCb and frees all the allocated address ranges.
    // for now we have one RecvFIFOVc only so this is a small function
    // This will be called from the remove remote node code path
    //
    // Arguments
    // PdoCb * Pdo Control Block that has the address ranges that this 
    // function will free
    //
    // Return Value:
    // Success: always. 
    //
    // Called With the Lock held
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PVCCB pVc = (PVCCB)(pRemoteNode->RecvFIFOData.pRecvFIFOVc);
    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Recv, ( "==>nicFreeAllAllocatedAddressRangesOnPdo  pRemoteNode %.8x", pRemoteNode) );

    //
    // Check if the Allocated Address Range is true for the RecvFifoData structure in the
    // PdoCb. If it is, then it is this thread's responsibility to free the address range
    //
    
    if (pRemoteNode->RecvFIFOData.AllocatedAddressRange == TRUE)
    {   
        ULONG AddressesReturned = pRemoteNode->RecvFIFOData.AddressesReturned;
        ADDRESS_RANGE VcAddressRange  = pRemoteNode->RecvFIFOData.VcAddressRange;
        HANDLE hAddressRange = pRemoteNode->RecvFIFOData.hAddressRange ;
        
    
        pRemoteNode->RecvFIFOData.AllocatedAddressRange = FALSE;

        
        REMOTE_NODE_RELEASE_LOCK (pRemoteNode);


        //
        // Now we free the address range. 
        //
        ASSERT (0);
        NdisStatus =  nicFreeAddressRange (pRemoteNode->pAdapter,
                                          AddressesReturned ,
                                          &VcAddressRange ,
                                          &hAddressRange );
        
        REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);
        
        
        nicDereferenceCall (pVc, "nicFreeAllAllocatedAddressRangesOnPdo  ");
        

    }
    else
    {
        NdisStatus = NDIS_STATUS_SUCCESS;
    }

    //
    // Now if anyone tries to access this pointer they will bugcheck,..
    // So we can ensure that there will be no more indications via this pointer
    //

    NdisZeroMemory (&pRemoteNode->RecvFIFOData, sizeof (RECV_FIFO_DATA) );

    MATCH_IRQL;
    TRACE( TL_T, TM_Recv, ( "<==nicFreeAllAllocatedAddressRangesOnPdo  Status %.8x (always success)", NdisStatus) );

    NdisStatus = NDIS_STATUS_SUCCESS;

    return NdisStatus;

}




NDIS_STATUS
nicFillAllocateAddressRangeSList(
    PRECVFIFO_VCCB pRecvFIFOVc,
    UINT *Num )
    //
    //  Function inits the Slist that will be sent down with the 
    //  AllocateAddressRange Irb
    //  RedvFifoVc - VC to be linked with the Slist
    //  Num - Num  of AddressFifo Elements that are inserted into the SList
    //
     
{


    PADDRESS_FIFO pRecvFifoElement = NULL;
    NDIS_STATUS NdisStatus;
    UINT cnt = 0;
    BOOLEAN bRef = FALSE;

    TRACE( TL_T, TM_Recv, ( "==>nicFillAllocateAddressRangeSList" ) );

    ASSERT (pRecvFIFOVc != NULL);

    ASSERT (pRecvFIFOVc->Hdr.MTU != 0);


    do
    {
  
        NdisStatus = nicGetInitializedAddressFifoElement (pRecvFIFOVc->Hdr.MTU, 
                                                    &pRecvFifoElement);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        ASSERT (pRecvFifoElement  != NULL);
 

        nicSetTagInFifoWrapper(pRecvFifoElement, NIC1394_TAG_QUEUED);
        
        ExInterlockedPushEntrySList ( &pRecvFIFOVc->FifoSListHead,
                                     &pRecvFifoElement->FifoList,
                                     &pRecvFIFOVc->FifoSListSpinLock);

        //
        // Add this once for every Address Fifo element inserted 
        // Will be decremented by  a call to nicFreeAddressFifo
        //
        VC_ACQUIRE_LOCK (pRecvFIFOVc);

#if FIFO_WRAPPER 

        pRecvFIFOVc->pFifoTable[cnt] = pRecvFifoElement;

#endif

        bRef = nicReferenceCall ((PVCCB) pRecvFIFOVc, "nicFillAllocateAddressRangeSList");

        VC_RELEASE_LOCK (pRecvFIFOVc);
        
        if (bRef == FALSE)
        {
            NdisStatus = NDIS_STATUS_VC_NOT_ACTIVATED;
            break;
        }

        TRACE( TL_V, TM_Recv, ( "cnt %.8x, Num %.8x, ",cnt, *Num) );

    } while (++cnt < *Num);

    //
    // Need to handle failure cases and also return number allocated
    //
    *Num = cnt;

    
    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_V, TM_Recv, ( "nicFillAllocateAddressRangeSList Failed, num allotted %.8x, MTU %,8x ",cnt ,pRecvFIFOVc->Hdr.MTU ) );

        NdisStatus = nicFreeAllocateAddressRangeSList (pRecvFIFOVc);

        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
    }

    TRACE( TL_T, TM_Recv, ( "==>nicFillAllocateAddressRangeSList Num %.8x, MTU %.8x",cnt,pRecvFIFOVc->Hdr.MTU ) );

    return NdisStatus;
}





NDIS_STATUS
nicGetInitializedAddressFifoElement(
    IN     UINT BufferLength, 
    IN OUT PADDRESS_FIFO *ppElement )
    //
    // This function return a single  AddressFifo element, 
    // with an MDL pointing to locally owned allocated memory
    // The size of the memory needs to be specified at MTU of
    // the VC that this belongs to and is the BufferLength. 
    //
    // Get locally owned buffer, get address fifo , init MDL with
    // local buffer. return the AddressFifo
    //


{


    PVOID pLocalBuffer = NULL;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;

    TRACE( TL_T, TM_Recv, ( "==>nicGetAddressInitializedFifoElement" ) );
    
    ASSERT (BufferLength != 0);
    do
    {
        if (BufferLength == 0)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            TRACE( TL_A, TM_Recv, ( "BufferLength is 0" ) );

            break;
        }
        //
        // Get Locally owned memory for the data
        // 
        NdisStatus = nicGetLocalBuffer (BufferLength, &pLocalBuffer);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            (*ppElement) = NULL;
            break;
        }

        //
        // Get Empty memory for the Address Fifo element
        //
        NdisStatus = nicGetEmptyAddressFifoElement (ppElement);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            nicFreeLocalBuffer (BufferLength, 
                            pLocalBuffer);

            (*ppElement) = NULL;
            
            break;
        }

        //
        // Get an MDL and initialze the MDL with the buffer 
        // and initialize the fifo ,with MDL. 
        //
        nicGetMdl ( BufferLength,
                   pLocalBuffer,
                   &((*ppElement)->FifoMdl));

    } while(FALSE);
    

    TRACE( TL_T, TM_Recv, ( "<==nicGetInitializedAddressFifoElement, Status %.8x, AddressFifo at %.8x, LocalBuffer at %.8x", 
                              NdisStatus, *ppElement,MmGetMdlVirtualAddress((*ppElement)->FifoMdl ) ) );
    
    return NdisStatus;

}


NDIS_STATUS
nicGetEmptyAddressFifoElement(
    IN PADDRESS_FIFO *ppElement)
    //
    // Returns an empty Address Fifo element. 
    // NULL otherwise
    //  
    // i.e just allocates memory and returns for now

{


    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    ULONG Size = 0;
    TRACE( TL_T, TM_Recv, ( "==>nicGetEmptyAddressFifoElement" ) );

#if FIFO_WRAPPER  // Used to track missing Address Fifo elements

    Size = sizeof (ADDRESS_FIFO_WRAPPER);
#else   
    Size = sizeof (ADDRESS_FIFO );
#endif  
    
    *ppElement = ALLOC_NONPAGED (Size, MTAG_FIFO);

    if (*ppElement != NULL)
    {
        NdisZeroMemory (*ppElement, Size);

        nicSetTagInFifoWrapper(*ppElement, NIC1394_TAG_ALLOCATED );

        NdisStatus = NDIS_STATUS_SUCCESS;
    }

    TRACE( TL_T, TM_Recv, ( "<==nicGetEmptyAddressFifoElement, Status % .8x, at %.8x",NdisStatus,*ppElement ) );
       

    return NdisStatus;


}



NDIS_STATUS
nicGetNdisBuffer(
    IN UINT Length,
    IN PVOID pLocalBuffer,
    IN OUT PNDIS_BUFFER *ppNdisBuffer )

    // This function will be used by the receive side
    // This returns an NdisBuffer as opposed to an MDL
    // initialized to the corect start addresses
    //
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    ASSERT (pLocalBuffer != NULL);
    ASSERT (Length > 0);
    ASSERT (ppNdisBuffer != NULL);
    
    TRACE( TL_T, TM_Recv, ( "==>nicGetNdisBuffer Local Buffer %.8x, Length %.8x", pLocalBuffer, Length) );

    if ( Length > 0 &&
       pLocalBuffer != NULL &&
       ppNdisBuffer != NULL)
    {
        NdisAllocateBuffer( &NdisStatus,
                            ppNdisBuffer,
                            NULL,
                            pLocalBuffer,
                            Length );
    }
    else
    {
        nicIncrementMallocFailure();
        NdisStatus = NDIS_STATUS_FAILURE;
    }


    TRACE( TL_T, TM_Recv, ( "<==nicGetNdisBuffer  Buffer %x, NdisStatus %.8x", *ppNdisBuffer, NdisStatus  ) );
    return NdisStatus;

}





NDIS_STATUS
nicInitAllocateAddressIrb(
   IN PIRB                  pIrb,   
   IN PVOID                 pContext,   
   IN ULONG                 fulFlags,
   IN ULONG                 nLength,
   IN ULONG                 MaxSegmentSize,
   IN ULONG                 fulAccessType,
   IN ULONG                 fulNotificationOptions,
   IN PADDRESS_OFFSET       pOffset,
   IN PRECVFIFO_VCCB        pRecvFIFOVc
   )

    //
    //  Initializes the allocate adddress Irb with the 
    //  values passed to the function
    //
    //  And adds constants for certain preknown values (e.g. callback, context)

    //  Spew as much debug as possible
    //
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    ASSERT (pRecvFIFOVc != NULL);

    TRACE( TL_T, TM_Recv, ( "==>nicInitAllocateAddressIrb" ) );

    pIrb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;
    pIrb->Flags = 0;
    pIrb->u.AllocateAddressRange.Mdl = NULL;
    pIrb->u.AllocateAddressRange.fulFlags = 0;
    pIrb->u.AllocateAddressRange.nLength = nLength;
    pIrb->u.AllocateAddressRange.MaxSegmentSize = 0;
    pIrb->u.AllocateAddressRange.fulAccessType = fulAccessType;
    pIrb->u.AllocateAddressRange.fulNotificationOptions = NOTIFY_FLAGS_AFTER_WRITE;
    pIrb->u.AllocateAddressRange.Callback = nicAllocateAddressRangeCallback;
    pIrb->u.AllocateAddressRange.Context = pContext; // should be pAdapter

    
    pIrb->u.AllocateAddressRange.Required1394Offset.Off_High = pOffset->Off_High;
    pIrb->u.AllocateAddressRange.Required1394Offset.Off_Low = pOffset->Off_Low;

    pIrb->u.AllocateAddressRange.FifoSListHead = &pRecvFIFOVc->FifoSListHead;
    pIrb->u.AllocateAddressRange.FifoSpinLock = &pRecvFIFOVc->FifoSListSpinLock;
    
    pIrb->u.AllocateAddressRange.AddressesReturned = 0;
    pIrb->u.AllocateAddressRange.p1394AddressRange = &pRecvFIFOVc->VcAddressRange;

    



    TRACE(TL_V, TM_Recv, ("nLength = 0x%x\n", pIrb->u.AllocateAddressRange.nLength));
    TRACE(TL_V, TM_Recv, ("MaxSegmentSize = 0x%x\n", pIrb->u.AllocateAddressRange.MaxSegmentSize));
    TRACE(TL_V, TM_Recv, ("fulAccessType = 0x%x\n", pIrb->u.AllocateAddressRange.fulAccessType));
    TRACE(TL_V, TM_Recv, ("fulNotificationOptions = 0x%x\n", pIrb->u.AllocateAddressRange.fulNotificationOptions));
    TRACE(TL_V, TM_Recv, ("Callback = 0x%x\n", pIrb->u.AllocateAddressRange.Callback));
    TRACE(TL_V, TM_Recv, ("Context = 0x%x\n", pIrb->u.AllocateAddressRange.Context));
    TRACE(TL_V, TM_Recv, ("Required1394Offset->Off_High = 0x%x\n", pIrb->u.AllocateAddressRange.Required1394Offset.Off_High));
    TRACE(TL_V, TM_Recv, ("Required1394Offset->Off_Low = 0x%x\n", pIrb->u.AllocateAddressRange.Required1394Offset.Off_Low));
    TRACE(TL_V, TM_Recv, ("FifoSListHeader = 0x%x\n", pIrb->u.AllocateAddressRange.FifoSListHead));
    TRACE(TL_V, TM_Recv, ("FifoSListSpinLock = 0x%x\n", pIrb->u.AllocateAddressRange.FifoSpinLock));
    TRACE(TL_V, TM_Recv, ("AddressesReturned = 0x%x\n", pIrb->u.AllocateAddressRange.AddressesReturned));
    TRACE(TL_V, TM_Recv, ("p1394AddressRange = 0x%x\n", pIrb->u.AllocateAddressRange.p1394AddressRange));


    TRACE( TL_T, TM_Recv, ( "<==nicInitAllocateAddressIrb" ) );
       
    return NdisStatus;

}




VOID 
nicFifoReturnPacket (
    IN PVCCB pVc,
    IN PNDIS_PACKET pMyPacket
    )

    // Function Description:
    //  Return Packets Handler -
    //   For FIFO's will reinsert the buffer (MDL) into  the Fifo SList
    //   Check for the VC Active  and then return it ot the SList . Free it otherwise
    //
    // Arguments
    //  RecvFIFOVc - Vc of the packet
    //  pPacket = Packet in question
    //
    // Return Value:
    //
    //
    //
    
{
    PRECVFIFO_VCCB          pRecvFIFOVc  = (PRECVFIFO_VCCB) pVc; 
    PNDIS_BUFFER            pMyNdisBuffer;
    PADAPTERCB              pAdapter = pRecvFIFOVc->Hdr.pAF->pAdapter;
    BOOLEAN                 fVcActive = FALSE;
    PADDRESS_FIFO           pAddressFifo;
    PPKT_CONTEXT            pPktContext = (PPKT_CONTEXT)&pMyPacket->MiniportReserved;   
    
    
    TRACE( TL_T, TM_Recv, ( "==>nicFifoReturnPacket pVc %x, pPacket %x, pAdapter %x, ", 
                             pRecvFIFOVc, pMyPacket, pAdapter) );


    //
    // Either the reassembly structure has the indicated Fifo's or if no reassembly was done
    // then the PktContext has it.
    //
    pAddressFifo = pPktContext->AllocateAddressRange.pIndicatedFifo;    

    // 
    // Do not push it back in the list if the VC is about to close. 
    // However, we push it back in, if the VC has not been activated yet
    //

    
    nicReturnFifoChain ( pAddressFifo , pRecvFIFOVc) ;
    

    //
    // Now we have to free the packet and ndis buffers that we got in the 
    // Calback code
    //
    TRACE( TL_V, TM_Recv, ( " AllocateAddress Range - Free Packet and Free Buffer" ) );

    nicReturnNdisBufferChain  (pMyPacket->Private.Head, pVc);

    nicFreePacket(pMyPacket, &pRecvFIFOVc->PacketPool);
    

    TRACE( TL_T, TM_Recv, ( "<==nicFifoReturnPacket "  ) );


    return;

}

VOID
nicReturnNdisBufferChain (
    IN PNDIS_BUFFER pNdisBuffer ,
    IN PVCCB pVc
    )
{
    PNDIS_BUFFER pNext;
    BOOLEAN fIsFifo = (pVc->Hdr.VcType == NIC1394_RecvFIFO);

    if (pNdisBuffer == NULL)
    {
        ASSERT (pNdisBuffer != NULL);
        return;
    }


    while (pNdisBuffer != NULL)
    {
        pNext = pNdisBuffer->Next;

        NdisFreeBuffer(pNdisBuffer);

        nicDecRecvBuffer(fIsFifo);
        pNdisBuffer = pNext;
    } 

}









VOID
nicReturnFifoChain (
    IN PADDRESS_FIFO pAddressFifo,
    IN PRECVFIFO_VCCB pRecvFIFOVc
    )
    // Function Description:
    //   This takes a chain of Address Fifos and returns it to the slist
    //   if the VC is active or frees it if the VC is not active
    //
    //
    //
    // Arguments
    //  pAddressFifo - chain of address fifo element
    //  pRecvFIFOVc - Recv VC
    //
    // Return Value:
    //
    //  None
    //
{
    
    TRACE( TL_T, TM_Recv, ( "==> nicReturnFifoChain pAddressFifo %x, pRecvFifoVc %x", pAddressFifo, pRecvFIFOVc) );


    VC_ACQUIRE_LOCK (pRecvFIFOVc);

    //
    // lets update the value again, before we insert the Address Fifo back in to the Slist
    // If there are any remote nodes present and the VC is active 
    // , then we should insert this back into the SList
    //
    

    if  ( VC_ACTIVE (pRecvFIFOVc) == TRUE )
    {     

        //
        // Return all the AddressFifo elements to the slist
        // Do this with the lock held so no one can change the
        // VC state from under us
        //

            
        while (pAddressFifo != NULL)
        {
            PADDRESS_FIFO pNextFifo = (PADDRESS_FIFO)(pAddressFifo->FifoList.Next);

            nicSetTagInFifoWrapper(pAddressFifo, NIC1394_TAG_QUEUED);

            ExInterlockedPushEntrySList ( &pRecvFIFOVc->FifoSListHead,
                                          &pAddressFifo ->FifoList,
                                          &pRecvFIFOVc->FifoSListSpinLock);
        
            TRACE( TL_V, TM_Recv, ( "  VcActive Address Fifo %x, Next Fifo %x",pAddressFifo , pNextFifo) );

            pAddressFifo = pNextFifo;

            NdisInterlockedDecrement (&pRecvFIFOVc->NumIndicatedFifos);


        }

        VC_RELEASE_LOCK (pRecvFIFOVc);

    }
    else  //VC_ACTIVE (pRecvFIFOVc) == TRUE 
    {

        VC_RELEASE_LOCK (pRecvFIFOVc);
        //
        // free all the Address Fifo after releasing the lock
        //
            
        while (pAddressFifo != NULL)
        {
            PADDRESS_FIFO pNextFifo = (PADDRESS_FIFO)(pAddressFifo->FifoList.Next);

            // 
            // Free the Mdl and Address Fifo structure and decrease the refcount
            // on the call. Do not touch the Vc after this
            //

            TRACE( TL_V, TM_Recv, ( "  Vc NOT Active  Address Fifo %x, Next Fifo %x",pAddressFifo , pNextFifo) );

            nicFreeAddressFifo(pAddressFifo ,
                               pRecvFIFOVc);
        
            NdisInterlockedDecrement (&pRecvFIFOVc->NumIndicatedFifos);

            pAddressFifo = pNextFifo;

        }


    }

    TRACE( TL_T, TM_Recv, ( "<== nicReturnFifoChain ") );

    return; 
}




VOID
nicInternalReturnPacket(
    IN  PVCCB                   pVc ,
    IN  PNDIS_PACKET            pPacket
    )
/*++

Routine Description:
    Finds out what type of Vc is being indicated and calls the appropriate VC return packets handler

Arguments:
    MiniportAdapterContext  - the pAdapter structure,
    pPacket - pPacket that the protocol returns


Return Value:


--*/
{
    PPKT_CONTEXT    pPktContext = (PPKT_CONTEXT)&pPacket->MiniportReserved;


    switch (pVc->Hdr.VcType)
    {
        case NIC1394_SendRecvChannel:
        case NIC1394_RecvChannel:
        {
            nicChannelReturnPacket (pVc, pPacket );
            break;
        }
        case NIC1394_RecvFIFO:
        {
    
            nicFifoReturnPacket ( pVc, pPacket);        
            break;
        }


        case NIC1394_Ethernet:
        {
            ASSERT (pVc->Hdr.VcType != NIC1394_Ethernet);
            break;
        }

        case NIC1394_MultiChannel:
        {
            ASSERT (pVc->Hdr.VcType != NIC1394_MultiChannel);

            break;
        }
        case NIC1394_SendChannel:
        {
            ASSERT (pVc->Hdr.VcType != NIC1394_SendChannel);

            break;

        }
        
        default :
        {
            
            ASSERT (0);
            break;
        }



    }
    

    return;


}

VOID
NicReturnPacket(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            pPacket
    )
/*++

Routine Description:
    This is the return packets handler. 
    This functikon handles all the instrumentation to catch outstanding packets and 
    then calls the internal return packets function

Arguments:
    MiniportAdapterContext  - the pAdapter structure,
    pPacket - pPacket that the protocol returns


Return Value:


--*/
{

    PADAPTERCB      pAdapter = (PADAPTERCB) MiniportAdapterContext;
    PPKT_CONTEXT    pPktContext = (PPKT_CONTEXT)&pPacket->MiniportReserved;
    PINDICATE_RSVD  pIndicateRsvd  = NULL;
    PRSVD           pRsvd = NULL;

    //
    // The first parameter of the MiniportReserved will always contain the VC
    //

    PVCCB pVc = (PVCCB)pPktContext->AllocateAddressRange.pRecvFIFOVc;


    TRACE( TL_T, TM_Recv, ( "==> NicReturnPacket pPacket %x ", pPacket) );

    do
    {

        //
        // Mark the packet as returned
        //
        pRsvd =(PRSVD)(pPacket->ProtocolReserved);
        pIndicateRsvd = &pRsvd->IndicateRsvd;

        ASSERT (pIndicateRsvd->Tag == NIC1394_TAG_INDICATED);
        
        pIndicateRsvd->Tag =  NIC1394_TAG_RETURNED;

#if MISSING_PACKETS
        if (pVc == NULL)
        {
            NDIS_STATUS Status = NDIS_GET_PACKET_STATUS(pPacket); 
            TRACE (TL_V, TM_Recv, ("Packet %x Status %x\n", pPacket, Status) );
            ASSERT (0);
            break;
        }
#endif
        nicInternalReturnPacket (pVc, pPacket);

    }while (FALSE);
    
    TRACE( TL_T, TM_Recv, ( " <== NicReturnPacket ") );

    return;
}



NDIS_STATUS
nicFindReassemblyStructure (
    IN PREMOTE_NODE pRemoteNode,
    IN USHORT Dgl,
    IN BUS_OPERATION BusOp,
    IN PVCCB pVc,
    OUT PNDIS1394_REASSEMBLY_STRUCTURE* ppReassembly
    )
    // Function Description:
    //  Walk through all the reassembly operations on this remote node
    //  and see if one is present 
    //
    //  If no reassembly is found, it will allocate and initialie a structure. 
    //  All within the context of the reassembly  lock  
    //
    // Arguments
    //  pRemoteNode - Remote Node that is sending the fragments
    //  dgl  - identifier for reassembly packet
    //  Together they are unique for each reassembly operation
    // Return Value:
    //
    //

{

    PNDIS1394_REASSEMBLY_STRUCTURE      pTempReassembly = NULL;
    PNDIS1394_REASSEMBLY_STRUCTURE      pReassembly = NULL;
    PLIST_ENTRY                         pReassemblyList = NULL;
    NDIS_STATUS                         NdisStatus = NDIS_STATUS_FAILURE;


    TRACE( TL_T, TM_Recv, ( "==>nicFindReassemblyStructure  pRemoteNode %x, dgl %x " , pRemoteNode , Dgl) );

    //
    // Acquire the reassebly lock . Only let go when either a reassembly structure is found or a new 
    // reassembly structure is inserted into the remote node's reassembly list
    //
    REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);
    REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK (pRemoteNode)

    pReassemblyList = pRemoteNode->ReassemblyList.Flink;

    //
    // Find the reassembly with the same dgl 
    // 
    
    while ( pReassemblyList != &pRemoteNode->ReassemblyList)
    {   
        pTempReassembly = CONTAINING_RECORD (pReassemblyList ,
                                               NDIS1394_REASSEMBLY_STRUCTURE,
                                               ReassemblyListEntry );
                                               
    
        TRACE( TL_V, TM_Recv, ( "Current Dgl %x, dgl %x " , pTempReassembly->Dgl , Dgl) );

        if (pTempReassembly->Dgl == Dgl)
        {
            pReassembly = pTempReassembly;
            break;
        }

        pReassemblyList  = pReassemblyList->Flink;
    }

    

    do 
    {
        //
        // If we have found a valid reassembly then return
        //

        if (pReassembly != NULL )
        {
            *ppReassembly = pReassembly ;

            NdisStatus = NDIS_STATUS_SUCCESS;
        }
        else
        {   
            //
            // We need to allocate and initialize  a reassembly structure
            // 
            NdisStatus = nicGetReassemblyStructure (&pReassembly);
            

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {

                BREAK (TM_Recv, ("    nicGetReassemblyStructure nicGetReassemblyStructure FAILED") ); 
            }

            NdisStatus = nicInitializeReassemblyStructure (pReassembly, 
                                                       Dgl, 
                                                       pRemoteNode, 
                                                       pVc, 
                                                       BusOp);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
            
                pReassembly = NULL;
                BREAK (TM_Recv, ("    nicFindReassemblyStructure nicInitializeReassemblyStructure FAILED" ) );
            }

        }
        
    } while (FALSE);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        //
        // Increment the ref count. Ref Count will be freed when the fragment is inserted into 
        // the reassembly structure or the packet indicated up
        //
        nicReferenceReassembly ( pReassembly, "nicFindReassemblyStructure " );
        
    }
    
    REMOTE_NODE_REASSEMBLY_RELEASE_LOCK (pRemoteNode)
    REMOTE_NODE_RELEASE_LOCK (pRemoteNode);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        //
        // Update output parameters
        //
        *ppReassembly = pReassembly;

    }
    TRACE( TL_T, TM_Recv, ( "<==nicFindReassemblyStructure NdisStatus %x, *ppReassembly %x" , NdisStatus ,*ppReassembly ) );

    return NdisStatus ;
}



NDIS_STATUS
nicGetReassemblyStructure ( 
    IN OUT PNDIS1394_REASSEMBLY_STRUCTURE* ppReassembly
    )
    // Function Description:
    //  Just allocates a structure and returns
    //
    // Arguments
    //  ppReassembly - to point to the newly allocated structure
    //  
    //
    //
    // Return Value:
    //  Success - if succeeded 
    //
    // Called with the lock held
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    TRACE( TL_T, TM_Recv, ( "==>nicGetReassemblyStructure  ppReassembly %x", ppReassembly ) );

    *ppReassembly = ALLOC_NONPAGED (sizeof (NDIS1394_REASSEMBLY_STRUCTURE), MTAG_REASSEMBLY);

    if (*ppReassembly == NULL)
    {
        nicIncrementMallocFailure();
        NdisStatus = NDIS_STATUS_FAILURE;

    }
    else
    {
        NdisZeroMemory (*ppReassembly, sizeof (NDIS1394_REASSEMBLY_STRUCTURE) );
        NdisStatus = NDIS_STATUS_SUCCESS;
        (*ppReassembly)->Tag = MTAG_REASSEMBLY;
        ReassemblyAllocated++;  
    }

    

    TRACE( TL_T, TM_Recv, ( " <==nicGetReassemblyStructure  NdisStatus %x, pReassembly %x", NdisStatus, *ppReassembly) );
    return NdisStatus;
}



VOID
nicFreeReassemblyStructure ( 
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly
    )
    // Function Description:
    //  Just Frees the structure and returns
    //
    // Arguments
    //  ppReassembly - to point to the newly allocated structure
    //
    //
    // Return Value:
    //  Success - if succeeded 
    //
{
    TRACE( TL_T, TM_Recv, ( "== nicFreeReassemblyStructure  ppReassembly %x", pReassembly ) );

    pReassembly->Tag = MTAG_FREED;
    nicDereferenceReassembly (pReassembly, "nicFreeReassemblyStructure ");

    return;
}


NDIS_STATUS
nicInitializeReassemblyStructure (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    IN USHORT Dgl,
    IN PREMOTE_NODE pRemoteNode,
    IN PVCCB pVc,
    IN BUS_OPERATION ReceiveOp
    )
    // Function Description:
    //   Goes in and assigns values to all the structures
    //
    // Arguments
    //  pReassembly = pReassembly structure all zeroed out,
    //  Dgl,- Datagram Label to be used in reassembly 
    //  pRemoteNode - pRemoteNode pointing to the sender
    //
    //
    // Return Value:
    //   Success : - If remote node active and this has been inserted into the remote node's list
    //   Failure - If remote Node is not active   
    //  Called with the lock held
    //

{
    BOOLEAN fRemoteNodeActive = FALSE;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PADAPTERCB pAdapter = pVc->Hdr.pAF->pAdapter;
    
    TRACE( TL_T, TM_Recv, ( "==> nicInitializeReassemblyStructure pReassembly %x, ReceiveOp %x", pReassembly, ReceiveOp ) );

    TRACE( TL_T, TM_Recv, ( "     pRemoteNode %x, Dgl %x, pVc %x ", pReassembly, Dgl, pVc ) );

    //
    // Increment the reassembly count
    //
    nicReassemblyStarted(pAdapter);
    pAdapter->AdaptStats.TempStats.ulMaxOutstandingReassemblies = 
                    max(pAdapter->AdaptStats.TempStats.ulMaxOutstandingReassemblies,
                         pAdapter->AdaptStats.TempStats.ulNumOutstandingReassemblies);

    
    //
    // Dgl  - Datagram label. Unique for every reassembly structure gernerated by this local host
    //
    pReassembly->Dgl = Dgl;


    //
    // pRemoteNode  -> RemoteNode + Dgl are unique for each reassembly structure
    //
    pReassembly->pRemoteNode = pRemoteNode;
    
    
    //
    // ExpectedFragmentOffset is computed by the Last Fragment's Offset + 
    // length of fragment. Does not account for gaps in the reassembled packet.
    // 
    pReassembly->ExpectedFragmentOffset = 0;



    //
    // LastNdisBuffer that was appended to the packet 
    //
    pReassembly->pTailNdisBuffer = NULL;

    //
    // Packet that is being reassembled
    //
    pReassembly->pNdisPacket = NULL;


    pReassembly->Head.pAddressFifo = NULL;
    pReassembly->Tail.pAddressFifo = NULL;
    pReassembly->ReceiveOp = ReceiveOp;
    pReassembly->pVc = pVc;
    

    //
    // Reference the remote node. This will be derefernced when the packet is returned
    //

    fRemoteNodeActive = (REMOTE_NODE_ACTIVE (pRemoteNode));

    TRACE( TL_V, TM_Recv, ( "  nicInitializeReassemblyStructure fRemoteNodeActive %x", fRemoteNodeActive) );


    if (fRemoteNodeActive  == TRUE) 
    {
        //
        // REfcount made as the reassembly will happen on the remote node. 
        // REfcount released when the last fragment is complete
        //
        nicReferenceRemoteNode (pRemoteNode, "nicInitializeReassemblyStructure");

        InsertTailList(&pRemoteNode->ReassemblyList, &pReassembly->ReassemblyListEntry);

        //
        // Reerence REassembly . Ref removed when this is removed from the Remote node list
        //
        nicReferenceReassembly (pReassembly, "nicInitializeReassembly" );
    }
    

    if (fRemoteNodeActive  == FALSE)
    {
        //
        // Temporary assert 
        //

        FREE_NONPAGED (pReassembly);
        
        NdisStatus = NDIS_STATUS_FAILURE;
    }
    else
    {
        NdisStatus = NDIS_STATUS_SUCCESS;
    }

    //
    // reference the reassembly for its creation. Dereferenced in the Indicate Packet Code path
    //
    nicReferenceReassembly (pReassembly, " nicInitializeReassemblyStructure ");

    TRACE( TL_T, TM_Recv, ( "<== nicInitializeReassemblyStructure NdisStatus %x, pReassembly%x ", NdisStatus,pReassembly ) );

    return NdisStatus;
}


VOID
nicAbortReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly
    )
    // Function Description:
    //    
    //    Assumes that the Reassembly structure is no longer in the remote node's list
    //
    //   This funciotn will free all allocated NdisBuffers and return all AddressFifo 
    //   elements to the bus driver (or frees them if the VC is closing down).
    //
    // Arguments
    //   pReasssembly - Reassembly structure that needs to be freed
    //
    //
    // Return Value:
    //  None
    //

{

    PNDIS_BUFFER pNdisBuffer = NULL;
    PRECVFIFO_VCCB pRecvFIFOVc = NULL;
    PCHANNEL_VCCB pChannelVc  = NULL;
    PADAPTERCB pAdapter = pReassembly->pVc->Hdr.pAF->pAdapter;
    STORE_CURRENT_IRQL;

    
    
    TRACE( TL_T, TM_Recv, ( "==> nicAbortReassembly  pReassembly %x", pReassembly ) );

    
    //
    // Free all the ndis buffers and so forth
    //
    if (pReassembly != NULL)
    {   
        //
        // First Chain the reassembly array into a linked so our return functions can deal with it
        //
        nicChainReassembly (pReassembly);

        if (pReassembly->pHeadNdisBuffer != NULL)
        {
            nicReturnNdisBufferChain(pReassembly->pHeadNdisBuffer, pReassembly->pVc);         
        }

        switch (pReassembly->ReceiveOp)
        {
            case AddressRange:
            {
                pRecvFIFOVc = (PRECVFIFO_VCCB) pReassembly->pVc;


                //
                // Time to return all of our address fifos
                //
                nicReturnFifoChain (pReassembly->Head.pAddressFifo,
                                    pRecvFIFOVc
                                    );
                            
                pReassembly->Head.pAddressFifo = NULL;
                break;
            }

            case IsochReceive:
            {
                pChannelVc = (PCHANNEL_VCCB)pReassembly->pVc;

                nicReturnDescriptorChain ( pReassembly->Head.pIsochDescriptor,
                                       pChannelVc);
                                       
                pReassembly->Head.pIsochDescriptor = NULL;
                break;
            }


            default:
            {

                ASSERT (0);
            }


        }


    }
    else
    {
        ASSERT (0);
    }

    //
    // Now deref the reassembly and free it.
    //
    nicReassemblyAborted (pAdapter);
    nicFreeReassemblyStructure (pReassembly);

    TRACE( TL_T, TM_Recv, ( "<== nicAbortReassembly  pReassembly %x", pReassembly ) );
    MATCH_IRQL;
    return;
}















NDIS_STATUS
nicDoReassembly ( 
    IN PNIC_RECV_DATA_INFO pRcvInfo,
    OUT PNDIS1394_REASSEMBLY_STRUCTURE *ppReassembly,
    PBOOLEAN pfReassemblyComplete
    )
/*++

Routine Description:
       Does the reassembly work . 
       Allocates an ndisbuffer pointing to the data .
       Does In order or out of order reassembly
        
Arguments:
        pRcvInfo  - pRcv Information
        pReassembly reassmbly structure associated with this fragment
        pfReassemblyComplete - Is the REassembly complete
Return Value:
        Success - if this fragment was successfully associated with a reassembly structure

--*/
{
    NDIS_STATUS                                 NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS_BUFFER                                pNdisBuffer = NULL;
    PNDIS1394_REASSEMBLY_STRUCTURE              pReassembly = NULL;
    BOOLEAN                                     fInOrder = FALSE;
    BOOLEAN                                     fNeedToReleaseReassemblyLock = FALSE;
    BOOLEAN                                     fReassemblyComplete = FALSE;
    PADAPTERCB                                  pAdapter = pRcvInfo->pRemoteNode->pAdapter;

    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Recv, ( "==> nicDoReassembly ppReassembly %x pRcvInfo %x",
                           ppReassembly, pRcvInfo ) );

    
    do
    {
        //
        // Get an NdisBuffer pointing to the data 
        //
        NdisStatus = nicGetNdisBufferForReassembly( pRcvInfo, &pNdisBuffer);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // If we break from here, the reassmbly will never get completed and the 
            // garbage collector will eventually free this.
            //
            pNdisBuffer = NULL;
            BREAK (TM_Send, ("nicDoReassembly  nicGetNdisBufferForReassembly FAILED" ) );

        }

                
        //
        // Either there is a reassembly currently going or one will be allocated and initialized
        //
        
        NdisStatus = nicFindReassemblyStructure (pRcvInfo->pRemoteNode, 
                                            pRcvInfo->Dgl, 
                                            pRcvInfo->RecvOp, 
                                            (PVCCB)pRcvInfo->pVc,
                                            &pReassembly);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            pReassembly=NULL;
            BREAK (TM_Recv, ("    nicDoReassembly  nicFindReassemblyStructure FAILED")); 
        }
    

        //
        // Now we start doing the actual work . Acquire the 
        // reassembly lock so no one else can touch the reassembly
        //
        
        
        ASSERT (pReassembly != NULL);
        TRACE( TL_V, TM_Recv, ( " ExpectedFragmentOffset  %x FragmentHeader Offset %x, ",
                               pReassembly->ExpectedFragmentOffset , pRcvInfo->FragmentOffset) );

        //
        // Code expects that if the reassembly is not Null, then the lock is acquired. 
        //
        REASSEMBLY_ACQUIRE_LOCK (pReassembly);
        fNeedToReleaseReassemblyLock = TRUE;

        
        if (REASSEMBLY_ACTIVE (pReassembly) == FALSE)
        {
            //
            // Drop the reassembly, as this structure is about to be freed
            // 
            NdisStatus = NDIS_STATUS_FAILURE;
            break;

        }


        //
        // This is the new reassembly scheme, which uses a table and does out of order and inorder
        // reassembly
        //
        

        NdisStatus = nicInsertFragmentInReassembly (pReassembly,
                                              pRcvInfo);
                                      

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // Do not assert
            //
            TRACE (TL_V,  TM_Reas, ("nicDoReassembly nicInsertFragmentInReassembly  FAILED") );
            break;
        }


        fReassemblyComplete = pReassembly->fReassemblyComplete;


        
    } while (FALSE);

    //
    // Release the reassembly lock (if acquired)
    //
    if (fNeedToReleaseReassemblyLock == TRUE)
    {
        REASSEMBLY_RELEASE_LOCK (pReassembly);

        if (fReassemblyComplete  == TRUE)
        {
            //
            // Dereference the remote node as we are removing the reassembly from the remote node
            //
            nicDereferenceReassembly (pReassembly, "nicInsertFragmentInReassembly " );
            //
            // now dereference the remote node. ref was added when the reassembly was
            // inserted into the remote node's list
            //
            nicDereferenceRemoteNode(pReassembly->pRemoteNode, "nicInsertFragmentInReassembly ");   

            pReassembly->pRemoteNode = NULL;

        }
    }
    //
    // Clean up time. First handle the failure case. 
    // If reassembly is != NULL, then free the lock 
    // and free the reassembly structure
    //

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        *ppReassembly = pReassembly; 

        //
        // Queue a Reassembly timer, if reassembly was not complete
        //
        if (fReassemblyComplete == FALSE)
        {   
            nicQueueReassemblyTimer(pAdapter, FALSE);
        }
    }   

    if (NdisStatus != NDIS_STATUS_SUCCESS )
    {
        //
        // Do not touch the reassembly.
        //
        if (pNdisBuffer)
        {
            NdisFreeBuffer (pNdisBuffer);
        }
        //
        // Return NULL as output. The Reassembly structure is  
        // in the remote node's list. The timer routine will pick it up
        //

        //
        // Deref the ref made the REassembly was found/
        //
        if (pReassembly != NULL)
        {
             nicDereferenceReassembly (pReassembly, "nicDoReassembly - failure" );
        }
        
        *ppReassembly = pReassembly = NULL;

    }

    *pfReassemblyComplete = fReassemblyComplete;


    TRACE( TL_T, TM_Recv, ( "<== nicDoReassembly NdisStatus %x, , pReassembly %x, Complete %x", NdisStatus, *ppReassembly, *pfReassemblyComplete  ) );
    MATCH_IRQL;
    
    return NdisStatus;  

}





NDIS_STATUS
nicGetNdisBufferForReassembly(
    IN PNIC_RECV_DATA_INFO pRcvInfo,
    OUT PNDIS_BUFFER *ppNdisBuffer
    )
    // Function Description:
    //   This function gets an Ndis Buffer that points to the start of the data
    //   that the Mdl points to. The Data starts from the point after the 
    //   Fragmentation Header
    //
    //    If this is the First fragment, then 32 bytes of the fragment header are also
    //    copied to make room for the header that the ARP  module expects
    // Arguments
    //  
    // Return Value:
    // Success  - if the mem alloc succeeded
    //   NdisBuffer - Buffer pointing ot the data ,
    //   Data Length  Length of the NdisBuffer
    //   StartValidData - StartVa of the NdisBuffer
    //
{
    NDIS_STATUS                 NdisStatus = NDIS_STATUS_FAILURE;
    PVOID                       pStartValidData = NULL;
    ULONG                       ulValidDataLength = 0;
    PNDIS1394_FRAGMENT_HEADER   pNonByteSwappedFragmentHeader  = NULL;
    USHORT                      Dgl;
    PNDIS_BUFFER                pNdisBuffer = NULL;
    ULONG                       IsochPrefix = ISOCH_PREFIX_LENGTH;
    PPACKET_FORMAT              pIndicatedData = NULL;

    TRACE( TL_T, TM_Recv, ( "==> nicGetNdisBufferForReassembly ") );
    do
    {
        //
        // Get a pointer to the start of the data, ie. it should point past the encapsulation header
        //
        pStartValidData = (PVOID)((ULONG_PTR)pRcvInfo->pEncapHeader + sizeof(NDIS1394_FRAGMENT_HEADER));

        ulValidDataLength  = pRcvInfo->DataLength - sizeof (NDIS1394_FRAGMENT_HEADER);
        //
        // if this is the first fragment, then leave room for the Unfragmented header that will need 
        // to be added before sending it up to the IP module
        // 
        if (pRcvInfo->fFirstFragment == TRUE)
        {
            ULONG ExtraData = (sizeof(NDIS1394_FRAGMENT_HEADER) - sizeof (NDIS1394_UNFRAGMENTED_HEADER)) ;

            pStartValidData = (PVOID)((ULONG_PTR)pStartValidData - ExtraData);

            ulValidDataLength  += ExtraData ;
        }
        
        
        NdisStatus = nicGetNdisBuffer ( ulValidDataLength,   
                                   pStartValidData,
                                   &pNdisBuffer);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Recv, ( "nicGetNdisBufferForReassembly: nicGetNdisBuffer Failed" ) );
        }

        nicIncRecvBuffer(pRcvInfo->pVc->Hdr.VcType == NIC1394_RecvFIFO);

        *ppNdisBuffer = pNdisBuffer;
        pRcvInfo->pNdisBuffer = pNdisBuffer;
        pRcvInfo->pNdisBufferData = pStartValidData;
        
    }while (FALSE);



    TRACE( TL_T, TM_Recv, ( "<== nicGetNdisBufferForReassembly NdisStatus %x, *ppNdisbuffer %x, pStartValidData%x ,ulValidDataLength %x", 
                             NdisStatus, *ppNdisBuffer, pStartValidData, ulValidDataLength) );



    return NdisStatus;

}


VOID
nicAddUnfragmentedHeader (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    IN PVOID pEncapHeader
    )
/*++

Routine Description:
   Its purpose is to add the fragment header that arp expects.
   There is room in the Head NdisBuffer to do this
     
   We own the buffer, so we can manipulate the data
    

Arguments:
    pReassembty Structure - contains all the necessary reasembly info
    pEncapHeader - Pointer to where th Unfragmented header will be stored

Return Value:
    None

--*/


{
    
    PNDIS1394_UNFRAGMENTED_HEADER pHeader = NULL;
    ASSERT (sizeof(NDIS1394_UNFRAGMENTED_HEADER) == sizeof(ULONG));
    TRACE( TL_T, TM_Recv, ( "==> nicAddUnfragmentedHeader  %x, pEncapHeader %x", pReassembly, pEncapHeader) );


    pHeader = (PNDIS1394_UNFRAGMENTED_HEADER) pEncapHeader;

    //
    // Now we add the unfragmented header. first zero it, then add the approriate values
    //
    pHeader->HeaderUlong = 0;   
    pHeader->u.FH_lf = lf_Unfragmented;
    pHeader->u.FH_EtherType = pReassembly->EtherType;

    //
    // Convert the header  to network order and indicate it up.
    //
    pHeader->HeaderUlong = SWAPBYTES_ULONG (pHeader->HeaderUlong);

    
    
    TRACE( TL_T, TM_Recv, ( "<== nicAddUnfragmentedHeader  pReasembly %x, pHeader %x ", pReassembly, pHeader->HeaderUlong) );
    
    return;
}











VOID
nicAbortReassemblyList (
    PLIST_ENTRY pToBeFreedList
    )
    // Function Description:
    //   Walks the list and calls nicAbortReassembly on each structure
    //   
    //   Does not do any lock or refcount work
    //
    //
    // Arguments
    //   pToBeFreedList - list of reassembly structures that are going to be freed
    //
    //
    // Return Value:
    //  None
    //
    //
    //
{

    PLIST_ENTRY pReassemblyList  = ListNext (pToBeFreedList);
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly = NULL;

    TRACE( TL_T, TM_Recv, ( "==> nicAbortReassemblyList  pToBeFreedList %x",  pToBeFreedList));


    while (pReassemblyList  != pToBeFreedList)
    {
        pReassembly = CONTAINING_RECORD(pReassemblyList, 
                                        NDIS1394_REASSEMBLY_STRUCTURE, 
                                        ReassemblyListEntry);

        pReassemblyList = ListNext(pReassemblyList);

        TRACE( TL_T, TM_Recv, ( "       Aborting pReassembly %x",  pReassembly));
        
        nicAbortReassembly(pReassembly);
    }

}


VOID
nicFreeAllPendingReassemblyStructures(
    IN PADAPTERCB pAdapter
    )
    // Function Description:
    //   When we are notified of a reset we need to go and invalidate all
    //   reassemblies
    //   
    //   This will always be called from the Reset code path . and will be at dispatch
    //   It will clear out all the remote node reaassembly and mark them as aborted.
    //   The Timer routine will then pick them up and free it
    //
    //   Does not actually free anything. Just marks them as aborted
    //
    // Arguments
    //   pAdapter - pAdapter that has been resets
    //
    //
    // Return Value:
    //
    //

{
    PLIST_ENTRY pRemoteNodeList = NULL;
    PREMOTE_NODE pRemoteNode = NULL;
    PLIST_ENTRY pReassemblyList = NULL;
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly = NULL;
    ULONG NumMarkedAborted = 0;
    
    TRACE( TL_T, TM_Recv, ( "==> nicFreeAllPendingReassemblyStructures "));

    
    pRemoteNodeList = ListNext(&pAdapter->PDOList);

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    //
    // Walking through the remote nodes
    //
    while (pRemoteNodeList != &pAdapter->PDOList)
    {
        pRemoteNode = CONTAINING_RECORD(pRemoteNodeList, 
                                        REMOTE_NODE, 
                                        linkPdo);

        pRemoteNodeList = ListNext (pRemoteNodeList);
        

        //
        // Reference the remote node, so we can guarantee its presence
        //
        if (REMOTE_NODE_ACTIVE (pRemoteNode)== FALSE) 
        {
            //
            // The remote node is going away. Skip this remote node
            //
            continue;
        }
        if (nicReferenceRemoteNode (pRemoteNode, "nicFreeAllPendingReassemblyStructures" )== FALSE )
        {
            //
            // The remote node is going away. Skip this remote node
            //
            continue;
        }

        //
        // Now walking through all the reassembly structures on that remote node
        //
        REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK(pRemoteNode);
        
        pReassemblyList = ListNext (&pRemoteNode->ReassemblyList);

        while (pReassemblyList  != &pRemoteNode->ReassemblyList)
        {
            pReassembly = CONTAINING_RECORD (pReassemblyList, 
                                             NDIS1394_REASSEMBLY_STRUCTURE, 
                                             ReassemblyListEntry);

            pReassemblyList = ListNext(pReassemblyList);


            //
            // If the reassembly has not been touched since the last timer it needs to be freed.
            // Other threads can ask us to free the reassembly by setting the aborted flag
            //
            if (REASSEMBLY_TEST_FLAG (pReassembly, REASSEMBLY_ABORTED) == FALSE);
            {

                REASSEMBLY_SET_FLAG (pReassembly, REASSEMBLY_ABORTED);
            
                NdisInterlockedIncrement (&NumMarkedAborted);
            }
        }


        REMOTE_NODE_REASSEMBLY_RELEASE_LOCK(pRemoteNode);

        nicDereferenceRemoteNode (pRemoteNode, "nicFreeAllPendingReassemblyStructures" );   

    }

    
    ADAPTER_RELEASE_LOCK (pAdapter);
    


    TRACE( TL_T, TM_Recv, ( "<== nicFreeAllPendingReassemblyStructures NumMarkedAborted  %x"));


}



ULONG
nicReferenceReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    PCHAR pString
    )
{   
    ULONG Ref;
    
    Ref = NdisInterlockedIncrement (&pReassembly->Ref);

    TRACE( TL_V, TM_Ref, ( "**nicReferenceReassembly  pReassembly %x, to %d, %s ", pReassembly, pReassembly->Ref, pString) );

    return Ref;


}









ULONG
nicDereferenceReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    PCHAR pString
    )
{   
    ULONG Ref;
    
    Ref = NdisInterlockedDecrement (&pReassembly->Ref);

    TRACE( TL_V, TM_Ref, ( "**nicDereferenceReassembly  pReassembly %x, to %d, %s ", pReassembly, pReassembly->Ref, pString) );

    if ( Ref ==0 )
    {
        
        TRACE( TL_V, TM_Ref, ( "**FREEING pReassembly %x,  ", pReassembly) );
        FREE_NONPAGED (pReassembly);
    }

    return Ref;
}





VOID
nicIndicateNdisPacketToNdis (
    PNDIS_PACKET pPacket, 
    PVCCB pVc, 
    PADAPTERCB pAdapter
    )
    // Function Description:
    //   This is to be used to indicate packets to NDIS . 
    //   In Win 9x indications will go through a timer routine
    //
    //   Assumption - There will be only one packet in the array
    //
    // Arguments
    //   ppPacket  - Packet Array
    //   pVc -Vc
    //   MiniportAdapterhandle
    // Return Value:
    //  None
    //
{
    NDIS_STATUS             NdisStatus = NDIS_STATUS_SUCCESS;
    PRSVD                   pRsvd = NULL;
    PNDIS_MINIPORT_TIMER    pRcvTimer= NULL;
    PINDICATE_RSVD          pIndicateRsvd = NULL;


    TRACE( TL_T, TM_Recv, ( "==> nicIndicateNdisPacketToNdis  pPacket %x, pVc %x, pAdapter %x ",
                            pPacket , pVc, pAdapter));

    TRACE (TL_V, TM_Reas, ("Indicating packet " ));                            

    
    do
    {
        NdisInterlockedIncrement (&pAdapter->AdaptStats.ulRcvOk);

        nicDumpPkt (pPacket,"Indicating Rcv ");

        
        ASSERT (pPacket != NULL);   

        //
        // Set up the Context for the indication
        //
        pRsvd =(PRSVD)(pPacket->ProtocolReserved);
        pIndicateRsvd = &pRsvd->IndicateRsvd;


        
#if QUEUED_PACKETS

        pIndicateRsvd->Tag =  NIC1394_TAG_QUEUED;

        NdisStatus = nicQueueReceivedPacket( pPacket, pVc, pAdapter);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // We were not able to queue the packet.
            // Call the return packet handler
            //
            ASSERT (0);
            NicReturnPacket (pAdapter, pPacket);
        }


#else  // QUEUED_PACKETS

        TRACE( TL_V, TM_Recv, ( "   Indicating without timer"));

        //
        // Update the tag increment counter and indicate rcv
        //

        pIndicateRsvd->Tag =  NIC1394_TAG_INDICATED;

        ASSERT (pPacket != NULL);

        nicIncrementRcvVcPktCount(pVc,pPacket);

        NdisMCoIndicateReceivePacket(pVc->Hdr.NdisVcHandle, &pPacket, 1);

        ASSERT (pAdapter->MiniportAdapterHandle != NULL);
        NdisMCoReceiveComplete(pAdapter->MiniportAdapterHandle);

#endif  //QUEUED_PACKETS




    }while (FALSE);





    TRACE( TL_T, TM_Recv, ( "<==nicIndicateNdisPacketToNdis  %x"));



}



NDIS_STATUS
nicValidateRecvDataIsoch(
    IN  PMDL                pMdl,
    IN  PISOCH_DESCRIPTOR  pIsochDescriptor,
    IN  PVCCB               pVc,
    OUT PNIC_RECV_DATA_INFO pRcvInfo
    )
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;

    do
    {

        NODE_ADDRESS NodeAddress;
        PGASP_HEADER pGaspHeader;
        //
        // Isoch header is already byte swapped
        //
        pRcvInfo->DataLength = pRcvInfo->p1394Data->IsochReceiveFragmented.IsochHeader.IH_Data_Length;
        
        if (pRcvInfo->DataLength <= (UINT)FIELD_OFFSET(DATA_FORMAT,IsochReceiveFragmented.Data))
        {
            // Too small. Note that for simplicitly we check for the 
            // fragmented case.
            //
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }           

        pRcvInfo->fGasp = TRUE;

        //
        // The total length of the data indicated by the bus driver
        //
        pRcvInfo->Length1394 = pRcvInfo->DataLength + sizeof (ISOCH_HEADER) + sizeof(ULONG); // Account for the prefix and isoch header

        //
        // The valid data does not include the gasp header
        //
        pRcvInfo->DataLength -= sizeof (GASP_HEADER);


        pRcvInfo->NdisPktContext.pIsochContext = pIsochDescriptor;

        pRcvInfo->pPacketPool = &((PCHANNEL_VCCB) pVc)->PacketPool;

        //
        // Get the source Info out. 
        //
        //
        // pRcvInfo->p1394Data points to the start of the Mdl's VA that was indicated by the bus driver
        //
        pGaspHeader = &pRcvInfo->p1394Data->IsochReceiveFragmented.GaspHeader;

        //
        // Byte swap the Gasp Header in the actual data. we own the buffer, so we can byte swap it   
        //
        pGaspHeader->FirstQuadlet.GaspHeaderHigh = SWAPBYTES_ULONG(pGaspHeader->FirstQuadlet.GaspHeaderHigh);
        pGaspHeader->SecondQuadlet.GaspHeaderLow = SWAPBYTES_ULONG(pGaspHeader->SecondQuadlet.GaspHeaderLow);

        TRACE (TL_V, TM_Recv, (" Gasp Hi %x, Gasp Lo %x.",  
                                pGaspHeader->FirstQuadlet.GaspHeaderHigh,
                                pGaspHeader->SecondQuadlet.GaspHeaderLow ) );

        pRcvInfo->pGaspHeader = pGaspHeader;
        
        pRcvInfo->SourceID = pGaspHeader->FirstQuadlet.u1.GH_NodeAddress.NA_Node_Number;

        pRcvInfo->SourceID = pGaspHeader->FirstQuadlet.u1.GH_NodeAddress.NA_Node_Number;

        NdisStatus = NDIS_STATUS_SUCCESS;


    } while (FALSE);

    return NdisStatus;
}



NDIS_STATUS
nicValidateRecvDataFifo(
    IN  PMDL                pMdl,
    IN  PNOTIFICATION_INFO pFifoContext,
    IN  PVCCB               pVc,
    OUT PNIC_RECV_DATA_INFO pRcvInfo
    )
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    do
    {
        pRcvInfo->DataLength = pFifoContext->nLength;
        
        if (pRcvInfo->DataLength <= (UINT)FIELD_OFFSET(DATA_FORMAT, AsyncWriteFragmented.Data))
        {
            // Too small. Note that for simplicitly we check for the 
            // fragmented case.
            //
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        pRcvInfo->fGasp = FALSE;

        //
        //In Fifo receives the DataLength is equal to the total amount of data indicated by the bus driver
        //
        pRcvInfo->Length1394 = pRcvInfo->DataLength;            
        
        pRcvInfo->NdisPktContext.pFifoContext = pFifoContext ->Fifo;

        pRcvInfo->pPacketPool = &((PRECVFIFO_VCCB) pVc)->PacketPool;

        pRcvInfo->SourceID =  ((PASYNC_PACKET)pFifoContext->RequestPacket)->AP_Source_ID.NA_Node_Number;

        NdisStatus = NDIS_STATUS_SUCCESS;

    }while (FALSE);

    return NdisStatus;


}


NDIS_STATUS
nicValidateRecvData(
    IN  PMDL                pMdl,
    IN  BUS_OPERATION       RecvOp,
    IN  PVOID               pIndicatedStruct,
    IN  PVCCB               pVc,
    OUT PNIC_RECV_DATA_INFO pRcvInfo
    )
/*++

Routine Description:

    This routine verifies that the length is not too small
    This routine initializes the RecvDataInfo for the default (unfragmented case).
    If the data is unfragmented the main recv routine will then call the Fragmented version of this routine

    This initializes the length and StartData and fGasp fields of the struct only 
Arguments:
    pMdl - Mdl that was indicated up by the bus driver
    RecvOp - Is this part of isoch callback, or AddrRange Callback
    pIndicatedStruct - NotificationInfo or IsochDescriptor
    pRcvInfo - Recv Structure that will be updated

Return Value:
    Success  - if all the operations succeeded  

--*/
{
    NDIS_STATUS                         NdisStatus = NDIS_STATUS_FAILURE;
    PDATA_FORMAT                        pData = NULL;
    NDIS1394_UNFRAGMENTED_HEADER        EncapHeader;
    PNDIS1394_UNFRAGMENTED_HEADER   pEncapHeader = NULL;
    NDIS1394_FRAGMENT_LF                lf;
    ULONG                               UlongLf;


    NdisZeroMemory (pRcvInfo , sizeof (NIC_RECV_DATA_INFO) );

    TRACE( TL_T, TM_Recv, ( "==>nicValidateRecvData pMdl %x, RecvOp %x, pIndicatedStruct %x, pRcvInfo %x", 
                                pMdl, RecvOp , pIndicatedStruct, pRcvInfo));

    ASSERT (RecvOp ==  IsochReceive || RecvOp == AddressRange);

    pRcvInfo->RecvOp = RecvOp;
    pRcvInfo->pVc = pVc;
    
    do
    {   
        if (pMdl == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            BREAK (TM_Recv, ("nicValidateRecvData  , no Mdl present") );
        }

        pRcvInfo->p1394Data = (PPACKET_FORMAT)NIC_GET_SYSTEM_ADDRESS_FOR_MDL (pMdl);

        if (pRcvInfo->p1394Data  == NULL)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

    
        //
        // Check minimum valid packet size . Checks whether the data length that was passed to us includes
        // at least the first byte of data
        //
        
        if (RecvOp == IsochReceive)
        {
            NdisStatus = nicValidateRecvDataIsoch (pMdl, 
                                                 (PISOCH_DESCRIPTOR)pIndicatedStruct,
                                                 pVc,
                                                 pRcvInfo
                                                 );

            if (NdisStatus != NDIS_STATUS_SUCCESS)           
            {
                // Validation failed . exit
                break;
            }           
            
            //
            // Get to the Encap header. Should be at the same position for Fragmented and nonfragmented 
            //
            pEncapHeader = &pRcvInfo->p1394Data->IsochReceiveNonFragmented.NonFragmentedHeader;

        }
        else
        {

            NdisStatus = nicValidateRecvDataFifo(pMdl,(PNOTIFICATION_INFO)pIndicatedStruct,pVc,pRcvInfo);

            if (NdisStatus != NDIS_STATUS_SUCCESS)           
            {
                // Failure
                break;
            }

            pEncapHeader  = &pRcvInfo->p1394Data->AsyncWriteNonFragmented.NonFragmentedHeader;


        }

        //
        // Byteswap Unfrag Header into a local variable
        //
        //EncapHeader.HeaderUlong = SwapBytesUlong (pEncapHeader->HeaderUlong);

        EncapHeader.HeaderUlong = SWAPBYTES_ULONG (pEncapHeader->HeaderUlong);

        EncapHeader.HeaderUlong  = pEncapHeader->HeaderUlong & 0x000000C0;
        EncapHeader.HeaderUlong  = EncapHeader.HeaderUlong >> 6;
        
        pRcvInfo->lf = EncapHeader.HeaderUlong ; 
    
        //
        // Update the lf
        //
    
        pRcvInfo->lf = EncapHeader.HeaderUlong;
        TRACE (TL_V, TM_Reas,("Header %x\n",pRcvInfo->lf ) );

        ASSERT (EncapHeader.HeaderUlong <= lf_InteriorFragment);


        if (pRcvInfo->lf != lf_Unfragmented)
        {
            pRcvInfo->fFragmented = TRUE;
        }
        else
        {
            pRcvInfo->fFragmented = FALSE;
        }

        if (pRcvInfo->DataLength > pVc->Hdr.MTU)
        {
            //
            // This cannot belong to us
            //
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }
        NdisStatus = NDIS_STATUS_SUCCESS;


        pRcvInfo->pEncapHeader = (PVOID)pEncapHeader;
        
        //
        // Spew out all the information discovered
        //
        TRACE ( TL_V, TM_Recv, ( "lf %x, p1394Data %x, Length1394 %x, DataLength %x, pEncapHeader %x " , 
                                pRcvInfo->lf,
                                pRcvInfo->p1394Data, 
                                pRcvInfo->Length1394, 
                                pRcvInfo->DataLength, 
                                pRcvInfo->pEncapHeader ) );

        
    } while (FALSE);

    TRACE( TL_T, TM_Recv, ( "<==nicValidateRecvData %x", NdisStatus));
    return NdisStatus;
}





VOID
nicInitRecvDataFragmented (
    IN  PMDL                pMdl,
    IN  BUS_OPERATION       RecvOp,
    IN  PVOID               pIndicatedStruct,
    OUT PNIC_RECV_DATA_INFO pRcvInfo
    )
/*++

Routine Description:
    The routine will extract from the packet all the information that is required for reassembly
    and store it in the pRcvInfo
    
Arguments:
    pMdl - Indicated Mdl
    RecvOp - IsochReceive ot AddressRange Callback
    pIndicatedStruct - IsochDesc or Address Fifo
    pRcvInfo - output structure

Return Value:
    None

--*/




{

    PNOTIFICATION_INFO                  pNotificationInfo = NULL;
    PGASP_HEADER                        pGaspHeader = NULL;
    PNDIS1394_FRAGMENT_HEADER           pEncapHeader = NULL; 

    
    TRACE( TL_T, TM_Recv, ( "==> nicInitRecvDataFragmented pMdl, %x, RecvOp %x, pIndicatedStruct %x, pRcvInfo %x", 
                                 pMdl, RecvOp, pIndicatedStruct, pRcvInfo));

    do
    {   
        pRcvInfo->pMdl  = pMdl;
        
        
        if (RecvOp == IsochReceive)
        {
            
            pRcvInfo->NdisPktContext.pIsochContext = (PISOCH_DESCRIPTOR) pIndicatedStruct;

        }
        else
        {
            pNotificationInfo = (PNOTIFICATION_INFO) pIndicatedStruct;
            
         
            pRcvInfo->NdisPktContext.pFifoContext = pNotificationInfo->Fifo;

        }

        
        //
        // Now byte swap the fragment header so it can be correctly interpreted
        //
        pEncapHeader = (PNDIS1394_FRAGMENT_HEADER )pRcvInfo->pEncapHeader;
        
        pRcvInfo->FragmentHeader.u.FH_High = SWAPBYTES_ULONG(pEncapHeader->u.FH_High);
        pRcvInfo->FragmentHeader.u1.FH_Low = SWAPBYTES_ULONG(pEncapHeader->u1.FH_Low);
        
        //
        // Now get the Dgl 
        //
        pRcvInfo->Dgl = (USHORT)pRcvInfo->FragmentHeader.u1.SecondQuadlet.FH_dgl;

        if (pRcvInfo->lf == lf_FirstFragment)
        {
            pRcvInfo->fFirstFragment = TRUE;
            pRcvInfo->EtherType  = pRcvInfo->FragmentHeader.u.FirstQuadlet_FirstFragment.FH_EtherType;
            pRcvInfo->FragmentOffset   = 0;

        }
        else
        {
            pRcvInfo->fFirstFragment = FALSE            ;
            pRcvInfo->FragmentOffset  = pRcvInfo->FragmentHeader.u.FirstQuadlet.FH_fragment_offset;

        }



        
        
        pRcvInfo->BufferSize = pRcvInfo->FragmentHeader.u.FirstQuadlet.FH_buffersize ;

        //
        // Spew out all the information that has been found
        //
        TRACE ( TL_V, TM_Recv, (" SourceId %x, FragHead Hi %x, FragHead Lo %x, Dgl %x, fFirstFragment %x",
                                pRcvInfo->SourceID,
                                pRcvInfo->FragmentHeader.u.FH_High, 
                                pRcvInfo->FragmentHeader.u1.FH_Low ,
                                pRcvInfo->Dgl,
                                pRcvInfo->fFirstFragment ) );

        TRACE ( TL_V, TM_Recv, ("  Fragment Offset %x, bufferSize %x", pRcvInfo->FragmentOffset, pRcvInfo->BufferSize));                                
        ASSERT (pRcvInfo->SourceID < 64);                           

    } while (FALSE);




    

    TRACE( TL_T, TM_Recv, ( "<==nicInitRecvDataFragmented " ));

}






















NDIS_STATUS
nicInsertFragmentInReassembly (
    PNDIS1394_REASSEMBLY_STRUCTURE  pReassembly,
    PNIC_RECV_DATA_INFO pRcvInfo
    )
/*++

Routine Description:
 
    Checks for over laps and if valid then copies current fragment
    into the table

    This function does the validation for overlaps
  
Arguments:
    PNDIS1394_REASSEMBLY_STRUCTURE  pReassembly,
    PNDIS_BUFFER pNdisBuffer,
    PMDL pMdl,
    PVOID pIndicatedStructure,
    ULONG FragOffset,
    ULONG IPLength


Return Value:


--*/

{

    NDIS_STATUS     NdisStatus = NDIS_STATUS_SUCCESS; 
    BOOLEAN         fFragPositionFound = FALSE;
    ULONG           FragmentNum = 0;
    BOOLEAN         Completed = FALSE;
    PNDIS_BUFFER    pNdisBuffer = pRcvInfo->pNdisBuffer;
    PMDL            pMdl = pRcvInfo->pMdl;
    PVOID           pIndicatedStructure = pRcvInfo->NdisPktContext.pCommon;
    ULONG           FragOffset = pRcvInfo->FragmentOffset;
    ULONG           IPLength = pRcvInfo->DataLength - sizeof (NDIS1394_FRAGMENT_HEADER);
    

    TRACE( TL_T, TM_Recv, ( "==> nicInsertFragmentInReassembly " ));

    do
    {
        if (pReassembly->BufferSize != 0 && 
            FragOffset >= pReassembly->BufferSize )
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // First Find the correct entry in the frag table.
        //

        nicFindInsertionPosition (pReassembly, 
                                  FragOffset, 
                                  IPLength, 
                                  &FragmentNum);

        if (pReassembly->FragTable[FragmentNum].IPLength != 0)
        {
            //
            // we must copy the current fragments descriptors  in the table 
            // so as not to overwrite the table
            //
            LONG OffsetIndex =0;
            
            //
            // First lets check for overlaps. Do we overlap the last fragment.
            // At this point, FragmentNum contains the record for the 
            // next fragment in the reassembly
            //
            if (FragmentNum != 0)
            {
                if (pReassembly->FragTable[FragmentNum-1].Offset + pReassembly->FragTable[FragmentNum-1].IPLength >  FragOffset)
                {
                    NdisStatus = NDIS_STATUS_FAILURE;
                    break;
                }
    
            }

            //
            // Do we overlap the next fragment
            //

            if (FragmentNum < pReassembly->MaxOffsetTableIndex)
            {
                if (FragOffset + IPLength > pReassembly->FragTable[FragmentNum].Offset )
                {
                    NdisStatus = NDIS_STATUS_FAILURE;
                    break;
            
                }
            }
            
            //
            // Now make room for this fragment
            //
            OffsetIndex = pReassembly->MaxOffsetTableIndex ; 
            
            //
            // Signed compare and move the records ahead by one
            //
            while (OffsetIndex >= (LONG)FragmentNum)
            {
                pReassembly->FragTable[OffsetIndex+1].Offset  =  pReassembly->FragTable[OffsetIndex].Offset ;
                pReassembly->FragTable[OffsetIndex+1].IPLength =  pReassembly->FragTable[OffsetIndex].IPLength;
                pReassembly->FragTable[OffsetIndex+1].pMdl =  pReassembly->FragTable[OffsetIndex].pMdl;
                pReassembly->FragTable[OffsetIndex+1].pNdisBuffer=  pReassembly->FragTable[OffsetIndex].pNdisBuffer;
                pReassembly->FragTable[OffsetIndex+1].pNdisBuffer=  pReassembly->FragTable[OffsetIndex].pNdisBuffer;
                pReassembly->FragTable[OffsetIndex+1].IndicatedStructure.pCommon = pReassembly->FragTable[OffsetIndex].IndicatedStructure.pCommon ;
                pReassembly->FragTable[OffsetIndex+1].FragHeader =  pReassembly->FragTable[OffsetIndex].FragHeader;
                
                OffsetIndex --;                     
            }

        }

        pNdisBuffer->Next = NULL;
        pMdl->Next = NULL;

        //
        // Copy the current fragment into the table
        //
        pReassembly->FragTable[FragmentNum].Offset = FragOffset;
        pReassembly->FragTable[FragmentNum].IPLength = IPLength;
        pReassembly->FragTable[FragmentNum].pNdisBuffer = pNdisBuffer;
        pReassembly->FragTable[FragmentNum].pMdl    = pMdl;
        pReassembly->FragTable[FragmentNum].FragHeader =  pRcvInfo->FragmentHeader;
        
        if (pReassembly->ReceiveOp == IsochReceive)
        {
            pReassembly->FragTable[FragmentNum].IndicatedStructure.pCommon = &((PISOCH_DESCRIPTOR)pIndicatedStructure)->DeviceReserved[IsochNext];
        }
        else
        {
            pReassembly->FragTable[FragmentNum].IndicatedStructure.pFifo = (PADDRESS_FIFO)pIndicatedStructure;
        }
        
        pReassembly->BytesRecvSoFar += IPLength;
        //
        // Now increment the Max offset
        //

        pReassembly->MaxOffsetTableIndex ++;

        
        if (pReassembly->BufferSize == 0)
        {       
            pReassembly->BufferSize = pRcvInfo->BufferSize;
        }

        //
        // Add the unfragmented header here as we have to extract the EtherType here
        //
        if (pRcvInfo->fFirstFragment == TRUE)
        {
                
            pReassembly->EtherType = (USHORT)pRcvInfo->EtherType;

            nicAddUnfragmentedHeader (pReassembly, pRcvInfo->pNdisBufferData );
            

        }

        if (pReassembly->BytesRecvSoFar  == pReassembly->BufferSize + 1)
        {

            nicChainReassembly (pReassembly);

            pReassembly->fReassemblyComplete = TRUE;

            RemoveEntryList (&pReassembly->ReassemblyListEntry);

            //
            // These references are done in nicDoReassembly AFTER the lock has been freed
            //
            
            //
            // Dereference the remote node as we are removing the reassembly from the remote node
            //
            //nicDereferenceReassembly (pReassembly, "nicInsertFragmentInReassembly " );
            //
            // now dereference the remote node. ref was added when the reassembly was
            // inserted into the remote node's list
            //
            //nicDereferenceRemoteNode(pReassembly->pRemoteNode, "nicInsertFragmentInReassembly "); 

            //pReassembly->pRemoteNode = NULL;

        }
        


    } while (FALSE);
    

    TRACE( TL_T, TM_Recv, ( "<== nicInsertFragmentInReassembly Status %x, Complete ", NdisStatus , pReassembly->fReassemblyComplete  ));

    return NdisStatus;
}










VOID
nicFindInsertionPosition (
    PNDIS1394_REASSEMBLY_STRUCTURE  pReassembly, 
    ULONG FragOffset, 
    ULONG IPLength, 
    PULONG pFragmentNum
    )
{

    ULONG FragmentNum = 0;
    

    do
    {
        //
        // First Do quick checks for Inorder reassembly
        //

        //
        // Is it the first arrived fragment
        //
        if (pReassembly->MaxOffsetTableIndex == 0 || 
            FragOffset < pReassembly->FragTable[0].Offset +pReassembly->FragTable[0].IPLength  )
        {
            FragmentNum = 0;    
            break;
        }

        //
        // Do we need to insert it in the last position
        //
        if ((pReassembly->FragTable[pReassembly->MaxOffsetTableIndex-1].Offset +
            pReassembly->FragTable[pReassembly->MaxOffsetTableIndex-1].IPLength ) <=
            FragOffset)
        {

            FragmentNum = pReassembly->MaxOffsetTableIndex; 

            break;
        }

        //
        // Now walk the table and try to find the correct offset
        // We know there is atleast one entry and the current fragment
        // goes is not the last entry
        //
        while ( FragmentNum != pReassembly->MaxOffsetTableIndex)
        {
            if (FragOffset < pReassembly->FragTable[FragmentNum].Offset)
            {
                //
                //We have found the Correct position
                //
                break;
            }

            FragmentNum++;

            

        }
        ASSERT (FragmentNum != pReassembly->MaxOffsetTableIndex); 
        


    } while (FALSE);


        
    *pFragmentNum = FragmentNum;

    
}




VOID 
nicChainReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE  pReassembly
    )
/*++

Routine Description:
 Chains the mdl, ndis buffers and indicated structures
 This can be called from abort on the reasssembly complete code path
Arguments:
    preassembly

Return Value:


--*/

{

    ULONG i = 0;


    //
    // first chain all fragments save the last one
    //
    while (i< pReassembly->MaxOffsetTableIndex-1)
    {
        PFRAGMENT_DESCRIPTOR pCurr = & pReassembly->FragTable[i];
        PFRAGMENT_DESCRIPTOR pNext = & pReassembly->FragTable[i+1];
        
        ASSERT (pNext->IPLength != 0);

        pCurr->pMdl->Next = pNext->pMdl;
        pCurr->pNdisBuffer->Next = pNext->pNdisBuffer;
        pCurr->IndicatedStructure.pListEntry->Next = pNext->IndicatedStructure.pListEntry;

        i++;
    }


    //
    // Clear the next pointers for the last descriptor
    //
    {
        PFRAGMENT_DESCRIPTOR pLast = & pReassembly->FragTable[pReassembly->MaxOffsetTableIndex-1];
        pLast->pMdl->Next = NULL;
        pLast->pNdisBuffer->Next = NULL;
        pLast->IndicatedStructure.pListEntry->Next = NULL;

    }   

    pReassembly->pHeadNdisBuffer = pReassembly->FragTable[0].pNdisBuffer;
    pReassembly->pHeadMdl = pReassembly->FragTable[0].pMdl;

    if (pReassembly->ReceiveOp == IsochReceive)
    {
        //
        // The pointer currently has the Next field. But the Head expects that start of an IsochDescriptor
        //
        pReassembly->Head.pCommon = CONTAINING_RECORD (pReassembly->FragTable[0].IndicatedStructure.pCommon,
                                                        ISOCH_DESCRIPTOR,
                                                        DeviceReserved[IsochNext] );

    }
    else
    {
        pReassembly->Head.pCommon = pReassembly->FragTable[0].IndicatedStructure.pCommon;
    }

    

}



NDIS_STATUS
nicInitSerializedReceiveStruct(
    PADAPTERCB pAdapter
    )
/*++

Routine Description:
  Initialize the Recv serialization structure

Arguments:
  padapter

Return V