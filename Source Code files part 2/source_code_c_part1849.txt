aps, midiOutOpen and
    midiOutGetDevCaps with the uDeviceID equal to 0xFFFF, which was the constant 
    for Wave/MIDI Mapper under 16-bit windows. Under 32-bit the new constant is 
    0xFFFFFFFF. This is going to be fixed in winmm code for Whistler but we still 
    keep this shim to fix apps on w2k.

 Notes:

   This is a general purpose shim.

 History:

   01/26/2000 dmunsil Created
   10/09/2000 maonis  Added hooks for midiOutGetDevCaps and midiOutOpen.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorrectSoundDeviceId)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(waveOutOpen)
    APIHOOK_ENUM_ENTRY(waveOutGetDevCapsA)
    APIHOOK_ENUM_ENTRY(waveOutGetDevCapsW)
    APIHOOK_ENUM_ENTRY(midiOutOpen)
    APIHOOK_ENUM_ENTRY(midiOutGetDevCapsA)
APIHOOK_ENUM_END


/*++

 This stub function fixes calls with the uDeviceID equal to 0xFFFF, which was 
 the constant for Wave Mapper under 16-bit windows. 

--*/

MMRESULT 
APIHOOK(waveOutOpen)(
    LPHWAVEOUT      phwo,                 // return buffer         
    UINT            uDeviceID,            // id of the device to use
    LPWAVEFORMATEX  pwfx,                 // what format you need (i.e. 11K, 16bit, stereo)
    DWORD           dwCallback,           // callback for notification on buffer completion
    DWORD           dwCallbackInstance,   // instance handle for callback
    DWORD           fdwOpen               // flags
    )              
{
    if (uDeviceID == 0xFFFF) {
        LOGN(
            eDbgLevelError,
            "[waveOutOpen] Fixed invalid Wave Mapper device ID.");
        
        uDeviceID = (UINT)-1;
    }
    
    return ORIGINAL_API(waveOutOpen)(
                            phwo,
                            uDeviceID,
                            pwfx,
                            dwCallback,
                            dwCallbackInstance,
                            fdwOpen);
}

/*++

 This stub function fixes calls with the uDeviceID equal to 0xFFFF, which was 
 the constant for Wave Mapper under 16-bit windows. 

--*/

MMRESULT 
APIHOOK(waveOutGetDevCapsA)(
    UINT           uDeviceID,   // id of the device to use
    LPWAVEOUTCAPSA pwoc,        // returned caps structure
    UINT           cbwoc        // size in bytes of the WAVEOUTCAPS struct
    )                   
{
    if (uDeviceID == 0xFFFF) {
        LOGN(
            eDbgLevelError,
            "[waveOutGetDevCapsA] Fixed invalid Wave Mapper device ID.");
        
        uDeviceID = (UINT)-1;
    }
    
    return ORIGINAL_API(waveOutGetDevCapsA)(
                            uDeviceID,
                            pwoc,
                            cbwoc);    
}

/*++

 This stub function fixes calls with the uDeviceID equal to 0xFFFF, which was 
 the constant for Wave Mapper under 16-bit windows. 

--*/

MMRESULT 
APIHOOK(waveOutGetDevCapsW)(
    UINT           uDeviceID,   // id of the device to use
    LPWAVEOUTCAPSW pwoc,        // returned caps structure
    UINT           cbwoc        // size in bytes of the WAVEOUTCAPS struct
    )                   
{
    if (uDeviceID == 0xFFFF) {
        LOGN(
            eDbgLevelError,
            "[waveOutGetDevCapsW] Fixed invalid Wave Mapper device ID.");
        
        uDeviceID = (UINT)-1;
    }
    
    return ORIGINAL_API(waveOutGetDevCapsW)(
                            uDeviceID,
                            pwoc,
                            cbwoc);    
}

/*++

 This stub function fixes calls with the uDeviceID equal to 0xFFFF, which was 
 the constant for MIDI Mapper under 16-bit windows. 

--*/

MMRESULT 
APIHOOK(midiOutOpen)(
    LPHMIDIOUT phmo, 
    UINT       uDeviceID, 
    DWORD_PTR  dwCallback, 
    DWORD_PTR  dwInstance, 
    DWORD      fdwOpen
    )
{
    if (uDeviceID == 0xffff) {
        LOGN(
            eDbgLevelError,
            "[midiOutOpen] Fixed invalid MIDI Mapper device ID.");
        
        uDeviceID = (UINT)-1;
    }
    
    return ORIGINAL_API(midiOutOpen)(
                            phmo, 
                            uDeviceID, 
                            dwCallback, 
                            dwInstance, 
                            fdwOpen);
}

/*++

 This stub function fixes calls with the uDeviceID equal to 0xFFFF, which was 
 the constant for MIDI Mapper under 16-bit windows. 

--*/

MMRESULT 
APIHOOK(midiOutGetDevCapsA)(
    UINT_PTR       uDeviceID,
    LPMIDIOUTCAPSA pmoc,
    UINT           cbmoc
    )
{
    if (uDeviceID == 0xffff) {
        LOGN(
            eDbgLevelError,
            "[midiOutGetDevCapsA] Fixed invalid MIDI Mapper device ID.");
        
        uDeviceID = (UINT)-1;
    }
    
    return ORIGINAL_API(midiOutGetDevCapsA)(
                            uDeviceID, 
                            pmoc, 
                            cbmoc);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, waveOutOpen)
    APIHOOK_ENTRY(WINMM.DLL, waveOutGetDevCapsA)
    APIHOOK_ENTRY(WINMM.DLL, waveOutGetDevCapsW)
    APIHOOK_ENTRY(WINMM.DLL, midiOutOpen)
    APIHOOK_ENTRY(WINMM.DLL, midiOutGetDevCapsA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\duplicatehandlefix.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    DuplicateHandleFix.cpp

 Abstract:

    DuplicateHandle was changed to always NULL the destination handle, even if 
    errors were generated.  THis shim ensures that the DestinationHandle is 
    not modified if the duplication was not successful.

 History:

    10/11/2001  robkenny        Created.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DuplicateHandleFix)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DuplicateHandle)
APIHOOK_ENUM_END

typedef BOOL (WINAPI *_pfn_DuplicateHandle)(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions );

/*++

 Don't allow DestinationHandle to change of DuplicateHandle generates an error.

--*/

BOOL
APIHOOK(DuplicateHandle)(
    HANDLE hSourceProcessHandle,  // handle to source process
    HANDLE hSourceHandle,         // handle to duplicate
    HANDLE hTargetProcessHandle,  // handle to target process
    LPHANDLE lpTargetHandle,      // duplicate handle
    DWORD dwDesiredAccess,        // requested access
    BOOL bInheritHandle,          // handle inheritance option
    DWORD dwOptions               // optional actions
    )
{
    // Save the original value
    HANDLE origHandle = *lpTargetHandle;

    BOOL bSuccess = ORIGINAL_API(DuplicateHandle)(hSourceProcessHandle, 
        hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess,
        bInheritHandle, dwOptions);

    if (!bSuccess)  {
        DWORD dwLastError = GetLastError();

        //
        // DuplicateHandle has set *lpTargetHandle to NULL, revert to it's previous value.
        //
        LOGN(eDbgLevelError, "DuplicateHandle failed, reverting *lpTargetHandle to previous value");
        *lpTargetHandle = origHandle;
    }

    return bSuccess;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, DuplicateHandle)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatebitmapstride.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateBitmapStride.cpp

 Abstract:

    When GetObjectA is called, modify the returned width of scan lines
    so that it is DWORD aligned for Bitmaps.  This is a bug in GetObjectA
    that will be fixed in whistler, but this shim is still needed for
    win2k.

    If a program is using the width of scan lines to determine if the bitmap
    is mono, 16, 24 bit, etc... it may cause the program to incorrectly display
    the bitmap.  Symptoms will be a skewed bitmap with colors shifted.

 Notes:

    This is a general purpose shim. 
    This bug is fixed in Whistler, so this shim is for Win2k.

 History:

    10/16/2000   mnikkel     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateBitmapStride)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetObjectA)
APIHOOK_ENUM_END

/*++

 Hook GetObjectA and align the stride if required.

--*/

int 
APIHOOK(GetObjectA)(
    HGDIOBJ hgdiobj,    // handle to graphics object
    int cbBuffer,       // size of buffer for object information
    LPVOID lpvObject    // buffer for object information
    )
{
    int  iRet= 0;

    iRet = ORIGINAL_API(GetObjectA)( 
        hgdiobj,  
        cbBuffer, 
        lpvObject);

    // If the call failed or the object is not a bitmap, pass through
    if (iRet != 0 &&
        GetObjectType(hgdiobj) == OBJ_BITMAP &&
        lpvObject != NULL)
    {
        BITMAP *pBitmap;
        LONG  lOrgSize, lSizeMod;

        // Check to see if the is a compatible bitmap or a DIB
        if (cbBuffer == sizeof(BITMAP))
        {
            pBitmap= (PBITMAP)lpvObject;
        }
        else
        {
            pBitmap= &(((PDIBSECTION)lpvObject)->dsBm);
        }

        // Check the width of scan lines to see if it is DWORD aligned
        lOrgSize = pBitmap->bmWidthBytes;
        lSizeMod = 4 - (lOrgSize & 3);
        if (lSizeMod == 4) 
        {
            lSizeMod = 0;
        }

        // If a change is necessary mod the size and log it.
        if (lSizeMod > 0)
        {
            pBitmap->bmWidthBytes += lSizeMod;
            LOGN( eDbgLevelInfo, "[GetObjectA] width of scan lines from %d to %d",
                        lOrgSize, pBitmap->bmWidthBytes );
        }

    }

    return iRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(GDI32.DLL, GetObjectA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\directplayenumorder.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   DirectPlayEnumOrder.cpp

 Abstract:

   Certain applications (Midtown Madness) expects the DPLAY providers to enumerate in a specific order.

 History:

   04/25/2000 robkenny

--*/


#include "precomp.h"
#include "CharVector.h"

#include <Dplay.h>

IMPLEMENT_SHIM_BEGIN(DirectPlayEnumOrder)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

// A class that makes it easy to store DPlay::EnumConnections information.
class DPlayConnectionsInfo
{
public:
    BOOL            m_beenUsed;
    GUID            m_lpguidSP;
    LPVOID          m_lpConnection;
    DWORD           m_dwConnectionSize;
    DPNAME          m_lpName;
    DWORD           m_dwFlags;
    LPVOID          m_lpContext;

    // Construct our object, saveing all these values.
    DPlayConnectionsInfo(
            LPCGUID lpguidSP,
            LPVOID lpConnection,
            DWORD dwConnectionSize,
            LPCDPNAME lpName,
            DWORD dwFlags,
            LPVOID lpContext
        )
    {
        m_beenUsed              = FALSE;
        m_lpguidSP              = *lpguidSP;
        m_lpConnection          = malloc(dwConnectionSize);

        memcpy(m_lpConnection, lpConnection, dwConnectionSize);

        m_dwConnectionSize      = dwConnectionSize;
        m_lpName                = *lpName;
        m_lpName.lpszShortNameA = StringDuplicateA(lpName->lpszShortNameA);
        m_dwFlags               = dwFlags;
        m_lpContext             = lpContext;
    }

    // Free our allocated space, and erase values.
    void Erase()
    {
        free(m_lpConnection);
        free(m_lpName.lpszShortNameA);
        m_lpConnection          = NULL;
        m_dwConnectionSize      = 0;
        m_lpName.lpszShortNameA = NULL;
        m_dwFlags               = 0;
        m_lpContext             = 0;
    }

    // Do we match this GUID?
    BOOL operator == (const GUID & guidSP)
    {
        return IsEqualGUID(guidSP, m_lpguidSP);
    }

    // Call the callback routine with this saved information
    void CallEnumRoutine(LPDPENUMCONNECTIONSCALLBACK lpEnumCallback)
    {
        lpEnumCallback(
            &m_lpguidSP,
            m_lpConnection,
            m_dwConnectionSize,
            &m_lpName,
            m_dwFlags,
            m_lpContext
            );

        m_beenUsed = TRUE;
    }

};

// A list of DPlay connections
class DPlayConnectionsInfoVector : public VectorT<DPlayConnectionsInfo>
{
    static DPlayConnectionsInfoVector * g_DPlayConnectionsInfoVector;

public:

    // Get us a pointer to the one and only DPlayConnectionsInfoVector
    static DPlayConnectionsInfoVector * GetVector()
    {
        if (g_DPlayConnectionsInfoVector == NULL)
            g_DPlayConnectionsInfoVector = new DPlayConnectionsInfoVector;
        return g_DPlayConnectionsInfoVector;
    };

    // Deconstruct the elements, then Erase the list
    void FreeAndErase()
    {
        for (int i = 0; i < Size(); ++i)
        {
            DPlayConnectionsInfo & deleteMe = Get(i);
            deleteMe.Erase();
        }
        Erase();
    }

    // Find an entry that matches this GUID
    DPlayConnectionsInfo * Find(const GUID & guidSP)
    {
        const int size = Size();
#if DBG
        DPFN( 
            eDbgLevelInfo, 
            "Find             GUID(%08x-%08x-%08x-%08x) Size(%d).", 
            guidSP.Data1, 
            guidSP.Data2, 
            guidSP.Data3, 
            guidSP.Data4, 
            size);
#endif
        for (int i = 0; i < size; ++i)
        {
            DPlayConnectionsInfo & dpci = Get(i);
#if DBG
            DPFN( 
                eDbgLevelInfo, 
                "   Compare[%02d] = GUID(%08x-%08x-%08x-%08x) (%s).", 
                i,
                dpci.m_lpguidSP.Data1, 
                dpci.m_lpguidSP.Data2, 
                dpci.m_lpguidSP.Data3, 
                dpci.m_lpguidSP.Data4, 
                dpci.m_lpName.lpszShortNameA);
#endif
            if (dpci == guidSP)
            {
#if DBG
                DPFN( 
                    eDbgLevelInfo, 
                    "FOUND(%s).", 
                    dpci.m_lpName.lpszShortNameA);
#endif
                return &dpci;
            }
        }
#if DBG
        DPFN( 
            eDbgLevelInfo, 
            "NOT FOUND.");
#endif
        return NULL;
    }

    // Lookup the GUID and if found, call the callback routine.
    void CallEnumRoutine(const GUID & guidSP, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback)
    {
#if DBG
        DPFN( 
            eDbgLevelInfo, 
            "CallEnumRoutine(%08x) Find GUID(%08x-%08x-%08x-%08x).", 
            lpEnumCallback, 
            guidSP.Data1, 
            guidSP.Data2, 
            guidSP.Data3, 
            guidSP.Data4);
#endif
        DPlayConnectionsInfo * dpci = DPlayConnectionsInfoVector::GetVector()->Find(guidSP);
        if (dpci)
        {
            dpci->CallEnumRoutine(lpEnumCallback);
        }
    }
};

// The global list of DPlay Connections
DPlayConnectionsInfoVector * DPlayConnectionsInfoVector::g_DPlayConnectionsInfoVector = NULL;


/*++

  Our private callback for IDirectPlay4::EnumConnections.  We simply save all
  the connections in our private list for later use.

--*/

BOOL FAR PASCAL EnumConnectionsCallback(
  LPCGUID lpguidSP,
  LPVOID lpConnection,
  DWORD dwConnectionSize,
  LPCDPNAME lpName,
  DWORD dwFlags,
  LPVOID lpContext
)
{
    // Only add it to the list if it is not already there
    // App calls EnumConnections from inside Enum callback routine.
    if (!DPlayConnectionsInfoVector::GetVector()->Find(*lpguidSP))
    {
#if DBG
        LOGN( 
            eDbgLevelError, 
            "EnumConnectionsCallback Add(%d) (%s).",
            DPlayConnectionsInfoVector::GetVector()->Size(),
            lpName->lpszShortName );
#endif

        // Store the info for later
        DPlayConnectionsInfo dpci(lpguidSP, lpConnection, dwConnectionSize, lpName, dwFlags, lpContext);

        DPlayConnectionsInfoVector::GetVector()->Append(dpci);
    }
#if DBG
    else
    {
        DPFN( 
            eDbgLevelInfo, 
            "EnumConnectionsCallback Already in the list(%s).",
            lpName->lpszShortName );
    }
#endif

    return TRUE;
}

/*++

  Win9x Direct play enumerates hosts in this order:
    DPSPGUID_IPX,
    DPSPGUID_TCPIP,
    DPSPGUID_MODEM,
    DPSPGUID_SERIAL,

  IXP, TCP, Modem, Serial.  Have EnumConnections call our callback
  routine to gather the host list, sort it, then call the app's callback routine.

--*/

HRESULT 
COMHOOK(IDirectPlay4A, EnumConnections)(
    PVOID pThis,
    LPCGUID lpguidApplication,
    LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,
    LPVOID lpContext,
    DWORD dwFlags
)
{
#if DBG
    DPFN( eDbgLevelInfo, "======================================");
    DPFN( eDbgLevelInfo, "COMHOOK IDirectPlay4A EnumConnections" );
#endif
    HRESULT hResult = DPERR_CONNECTIONLOST;

    typedef HRESULT   (*_pfn_IDirectPlay4_EnumConnections)( PVOID pThis, LPCGUID lpguidApplication, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback, LPVOID lpContext, DWORD dwFlags);

    _pfn_IDirectPlay4A_EnumConnections EnumConnections = ORIGINAL_COM(
        IDirectPlay4A,
        EnumConnections, 
        pThis);

    if (EnumConnections)
    {
        static bool alreadyHere = false;
        if (!alreadyHere)
        {
            alreadyHere = true;

#if DBG
            LOGN( eDbgLevelError, "EnumConnections(%08x)\n", EnumConnections );
#endif
            // Enumerate connections to our own routine.        
            hResult = EnumConnections(pThis, lpguidApplication, EnumConnectionsCallback, lpContext, dwFlags);
        
#if DBG
            LOGN( eDbgLevelError, 
                "Done EnumConnections Start calling app Size(%d).", 
                DPlayConnectionsInfoVector::GetVector()->Size());
#endif

            // Call the application's callback routine with the GUID in the order it expects
            if (hResult == DP_OK)
            {
                DPlayConnectionsInfoVector::GetVector()->CallEnumRoutine(DPSPGUID_IPX, lpEnumCallback);
                DPlayConnectionsInfoVector::GetVector()->CallEnumRoutine(DPSPGUID_TCPIP, lpEnumCallback);
                DPlayConnectionsInfoVector::GetVector()->CallEnumRoutine(DPSPGUID_MODEM, lpEnumCallback);
                DPlayConnectionsInfoVector::GetVector()->CallEnumRoutine(DPSPGUID_SERIAL, lpEnumCallback);

                // Now loop over the list and enum any remaining providers
                for (int i = 0; i < DPlayConnectionsInfoVector::GetVector()->Size(); ++i)
                {
                    DPlayConnectionsInfo & dpci = DPlayConnectionsInfoVector::GetVector()->Get(i);
                    if (!dpci.m_beenUsed)
                    {
                        dpci.CallEnumRoutine(lpEnumCallback);
                        dpci.m_beenUsed = TRUE;
                    }
                }
            }

            alreadyHere = false;
        }
#if DBG
        else
        {
            DPFN( eDbgLevelInfo, "EnumConnections Recursive." );
        }
#endif
    }
    // All done with the list, clean up.
    DPlayConnectionsInfoVector::GetVector()->FreeAndErase();

    return hResult;
}


/*++

  Do the same thing for DirectPlay3

--*/

HRESULT 
COMHOOK(IDirectPlay3A, EnumConnections)(
    PVOID pThis,
    LPCGUID lpguidApplication,
    LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,
    LPVOID lpContext,
    DWORD dwFlags
)
{
#if DBG
    DPFN( eDbgLevelInfo, "======================================");
    DPFN( eDbgLevelInfo, "COMHOOK IDirectPlay3A EnumConnections" );
#endif
    HRESULT hResult = DPERR_CONNECTIONLOST;

    typedef HRESULT   (*_pfn_IDirectPlay3A_EnumConnections)( PVOID pThis, LPCGUID lpguidApplication, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback, LPVOID lpContext, DWORD dwFlags);

    _pfn_IDirectPlay3A_EnumConnections EnumConnections = ORIGINAL_COM(
        IDirectPlay3A,
        EnumConnections, 
        pThis);

    if (EnumConnections)
    {
        static bool alreadyHere = false;
        if (!alreadyHere)
        {
            alreadyHere = true;

#if DBG
            LOGN( eDbgLevelError, "EnumConnections(%08x).", EnumConnections );
#endif
            // Enumerate connections to our own routine.        
            hResult = EnumConnections(pThis, lpguidApplication, EnumConnectionsCallback, lpContext, dwFlags);
        
#if DBG
            LOGN( eDbgLevelError, 
                "Done EnumConnections Start calling app Size(%d).", 
                DPlayConnectionsInfoVector::GetVector()->Size());
#endif

            // Call the application's callback routine with the GUID in the order it expects
            if (hResult == DP_OK)
            {
                DPlayConnectionsInfoVector::GetVector()->CallEnumRoutine(DPSPGUID_IPX, lpEnumCallback);
                DPlayConnectionsInfoVector::GetVector()->CallEnumRoutine(DPSPGUID_TCPIP, lpEnumCallback);
                DPlayConnectionsInfoVector::GetVector()->CallEnumRoutine(DPSPGUID_MODEM, lpEnumCallback);
                DPlayConnectionsInfoVector::GetVector()->CallEnumRoutine(DPSPGUID_SERIAL, lpEnumCallback);

                // Now loop over the list and enum any remaining providers
                for (int i = 0; i < DPlayConnectionsInfoVector::GetVector()->Size(); ++i)
                {
                    DPlayConnectionsInfo & dpci = DPlayConnectionsInfoVector::GetVector()->Get(i);
                    if (!dpci.m_beenUsed)
                    {
                        dpci.CallEnumRoutine(lpEnumCallback);
                        dpci.m_beenUsed = TRUE;
                    }
                }
            }

            alreadyHere = false;
        }
#if DBG
        else
        {
            DPFN( eDbgLevelInfo, "EnumConnections Recursive." );
        }
#endif
    }
    // All done with the list, clean up.
    DPlayConnectionsInfoVector::GetVector()->FreeAndErase();

    return hResult;
}

/*++

  Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()

    COMHOOK_ENTRY(DirectPlay, IDirectPlay4A, EnumConnections, 35)
    COMHOOK_ENTRY(DirectPlay, IDirectPlay3A, EnumConnections, 35)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatecdfs.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateCDFS.cpp

 Abstract:

    Removes read only attributes from CD directories: just like Win9x.

    This shim has gone through several revisions. Originally it was thought 
    that win9x simply ignored the ReadOnly, DesiredAccess and ShareMode 
    parameters, but after some testing, it turns out that this is only true 
    for the CDRom drive.

    Unfortunately we have to check every file to see if it's on the CD first, 
    just in case someone opens with exclusive access and then tries to open 
    again.

 Notes:

    This is a general purpose shim.

 History:

    01/03/2000 a-jamd   Created
    12/02/2000 linstev  Separated into 2 shims: RemoveReadOnlyAttribute and this one
                        Added CreateFile hooks

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(EmulateCDFS)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OpenFile)
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(CreateFileMappingA)
    APIHOOK_ENUM_ENTRY(MapViewOfFile)
    APIHOOK_ENUM_ENTRY(MapViewOfFileEx)
    APIHOOK_ENUM_ENTRY(DuplicateHandle)
    APIHOOK_ENUM_ENTRY(CloseHandle)
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)        
    APIHOOK_ENUM_ENTRY(FindFirstFileW)         
    APIHOOK_ENUM_ENTRY(FindFirstFileA)             
    APIHOOK_ENUM_ENTRY(FindNextFileW)             
    APIHOOK_ENUM_ENTRY(FindNextFileA)              
    APIHOOK_ENUM_ENTRY(GetFileInformationByHandle)
    APIHOOK_ENUM_ENTRY(GetDiskFreeSpaceA) 
APIHOOK_ENUM_END

typedef struct _FINDFILE_HANDLE 
{
    HANDLE DirectoryHandle;
    PVOID FindBufferBase;
    PVOID FindBufferNext;
    ULONG FindBufferLength;
    ULONG FindBufferValidLength;
    RTL_CRITICAL_SECTION FindBufferLock;
} FINDFILE_HANDLE, *PFINDFILE_HANDLE;


class RO_FileMappingList
{
private:
    VectorT<HANDLE>             hROHandles;     // File mapping handles that we have forced to Read only
    mutable CRITICAL_SECTION    critSec;

    inline int     GetIndex(HANDLE handle) const;

public:
    RO_FileMappingList();
    ~RO_FileMappingList();
    void    Add(HANDLE roHandle);
    void    Remove(HANDLE roHandle);
    BOOL    Exist(HANDLE handle) const;
};

RO_FileMappingList::RO_FileMappingList()
{
    InitializeCriticalSection(&critSec);
}

RO_FileMappingList::~RO_FileMappingList()
{
    DeleteCriticalSection(&critSec);
}

void RO_FileMappingList::Add(HANDLE roHandle)
{
    if (roHandle != NULL)
    {
        EnterCriticalSection(&critSec);
        int index = GetIndex(roHandle); 
        if (index == -1) // not found
        {
            DPFN(eDbgLevelSpew, "[RO_FileMappingList::Add] Handle 0x%08x", roHandle);
            hROHandles.Append(roHandle);    
        }
        LeaveCriticalSection(&critSec);
    }
}

void RO_FileMappingList::Remove(HANDLE roHandle)
{
    if (roHandle != NULL)
    {
        EnterCriticalSection(&critSec);
        int index = GetIndex(roHandle); 
        if (index >= 0) // found it
        {
            DPFN(eDbgLevelSpew, "[RO_FileMappingList::Remove] Handle 0x%08x", roHandle);
            hROHandles.Remove(index);    
        }
        LeaveCriticalSection(&critSec);
    }
}

inline int RO_FileMappingList::GetIndex(HANDLE handle) const
{
    int index = hROHandles.Find(handle);
    return index;
}

BOOL RO_FileMappingList::Exist(HANDLE handle) const
{
    EnterCriticalSection(&critSec);
    BOOL bExist = GetIndex(handle) >= 0;
    LeaveCriticalSection(&critSec);

    return bExist;
}

// A global list of file mapping handles that we have forced to readonly
RO_FileMappingList *g_RO_Handles = NULL;

/*++

 Remove write attributes for read-only devices.

--*/

HFILE 
APIHOOK(OpenFile)(
    LPCSTR lpFileName,        // file name
    LPOFSTRUCT lpReOpenBuff,  // file information
    UINT uStyle               // action and attributes
    )
{
    if ((uStyle & OF_READWRITE) && IsOnCDRomA(lpFileName))
    {
        // Remove the Read/Write bits
        uStyle &= ~OF_READWRITE;
        uStyle |= OF_READ;
        
        LOGN(eDbgLevelInfo, "[OpenFile] \"%s\": attributes modified for read-only device", lpFileName);
    }

    HFILE returnValue = ORIGINAL_API(OpenFile)(lpFileName, lpReOpenBuff, uStyle);

    return returnValue;
}

/*++

 Remove write attributes for read-only devices.

--*/

HANDLE 
APIHOOK(CreateFileA)(
    LPSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    if (((dwCreationDisposition == OPEN_EXISTING) || 
         (dwCreationDisposition == OPEN_ALWAYS)) &&
        ((dwDesiredAccess & GENERIC_WRITE) || 
         (dwShareMode != FILE_SHARE_READ)) &&
        IsOnCDRomA(lpFileName)) 
    {
        dwDesiredAccess &= ~GENERIC_WRITE;
        dwShareMode = FILE_SHARE_READ;
        
        LOGN(eDbgLevelInfo, "[CreateFileA] \"%s\": attributes modified for read-only device", lpFileName);
    }

    if (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING)
    {
        dwFlagsAndAttributes &= ~FILE_FLAG_NO_BUFFERING;
        LOGN(eDbgLevelInfo, "[CreateFileA] \"%s\": removed NO_BUFFERING flag", lpFileName);
    }

    HANDLE hRet = ORIGINAL_API(CreateFileA)(
                        lpFileName, 
                        dwDesiredAccess, 
                        dwShareMode, 
                        lpSecurityAttributes, 
                        dwCreationDisposition, 
                        dwFlagsAndAttributes, 
                        hTemplateFile);

    DPFN(eDbgLevelSpew,
        "[CreateFileA] -File: \"%s\" -GENERIC_WRITE:%c -FILE_SHARE_WRITE:%c%s",
        lpFileName,
        (dwDesiredAccess & GENERIC_WRITE) ? 'Y' : 'N',
        (dwShareMode & FILE_SHARE_WRITE) ? 'Y' : 'N',
        (hRet == INVALID_HANDLE_VALUE) ? "\n\t***********Failed***********" : "");
    
    return hRet;
}

/*++

 Remove write attributes for read-only devices.

--*/

HANDLE 
APIHOOK(CreateFileW)(
    LPWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    if (((dwCreationDisposition == OPEN_EXISTING) || 
         (dwCreationDisposition == OPEN_ALWAYS)) &&
        ((dwDesiredAccess & GENERIC_WRITE) || 
         (dwShareMode != FILE_SHARE_READ)) &&
        IsOnCDRomW(lpFileName)) 
    {
        dwDesiredAccess &= ~GENERIC_WRITE;
        dwShareMode = FILE_SHARE_READ;
        
        LOGN(eDbgLevelError, "[CreateFileW] \"%S\": attributes modified for read-only device", lpFileName);
    }

    if (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING)
    {
        dwFlagsAndAttributes &= ~FILE_FLAG_NO_BUFFERING;
        LOGN(eDbgLevelInfo, "[CreateFileW] \"%S\": removed NO_BUFFERING flag", lpFileName);
    }

    HANDLE hRet = ORIGINAL_API(CreateFileW)(
                        lpFileName, 
                        dwDesiredAccess, 
                        dwShareMode, 
                        lpSecurityAttributes, 
                        dwCreationDisposition, 
                        dwFlagsAndAttributes, 
                        hTemplateFile);

    DPFN(eDbgLevelSpew, 
        "[CreateFileW] -File: \"%S\" -GENERIC_WRITE:%c -FILE_SHARE_WRITE:%c%s",
        lpFileName,
        (dwDesiredAccess & GENERIC_WRITE) ? 'Y' : 'N',
        (dwShareMode & FILE_SHARE_WRITE) ? 'Y' : 'N',
        (hRet == INVALID_HANDLE_VALUE) ? "\n\t***********Failed***********" : "");
    
    return hRet;
}

HANDLE
APIHOOK(CreateFileMappingA)(
    HANDLE hFile,                       // handle to file
    LPSECURITY_ATTRIBUTES lpAttributes, // security
    DWORD flProtect,                    // protection
    DWORD dwMaximumSizeHigh,            // high-order DWORD of size
    DWORD dwMaximumSizeLow,             // low-order DWORD of size
    LPCSTR lpName                       // object name
    )
{
    BOOL bChangedProtect = FALSE;
    if (!(flProtect & PAGE_READONLY) && IsOnCDRom(hFile)) 
    {
        // This handle is on a CD-ROM, force the protection to READONLY
        flProtect       = PAGE_READONLY;
        bChangedProtect = TRUE;

        LOGN(eDbgLevelError, "[CreateFileMappingA] Handle 0x%08x: attributes modified for read-only device", hFile);
    }

    HANDLE hRet = ORIGINAL_API(CreateFileMappingA)(
                        hFile,
                        lpAttributes,
                        flProtect,
                        dwMaximumSizeHigh,
                        dwMaximumSizeLow,
                        lpName);
               
    // If the handle is on a CD-ROM, rember it
    if (bChangedProtect) 
    {
        g_RO_Handles->Add(hRet);
    }

    DPFN(eDbgLevelSpew,
        "[CreateFileMappingA] Handle 0x%08x -PAGE_READWRITE:%c -PAGE_WRITECOPY:%c%s",
        lpName,
        (flProtect & PAGE_READWRITE) ? 'Y' : 'N',
        (flProtect & PAGE_WRITECOPY) ? 'Y' : 'N',
        (hRet == INVALID_HANDLE_VALUE) ? "\n\t***********Failed***********" : "");
    
    return hRet;
}

LPVOID  
APIHOOK(MapViewOfFile)(
    HANDLE hFileMappingObject,   // handle to file-mapping object
    DWORD dwDesiredAccess,       // access mode
    DWORD dwFileOffsetHigh,      // high-order DWORD of offset
    DWORD dwFileOffsetLow,       // low-order DWORD of offset
    SIZE_T dwNumberOfBytesToMap  // number of bytes to map
    )
{
    //
    // Check to see if we need to force Read access for CD-ROM files
    // Only the FILE_MAP_READ bit may be enabled for CD-ROM access
    //
    if ((dwDesiredAccess != FILE_MAP_READ) &&
         g_RO_Handles->Exist(hFileMappingObject))
    {
        dwDesiredAccess = FILE_MAP_READ;
        LOGN(eDbgLevelError, "[MapViewOfFile] Handle 0x%08x: attributes modified for read-only device", hFileMappingObject);
    }

    HANDLE hRet = ORIGINAL_API(MapViewOfFile)(
        hFileMappingObject,
        dwDesiredAccess,
        dwFileOffsetHigh,
        dwFileOffsetLow,
        dwNumberOfBytesToMap);

    return hRet;
}

LPVOID  
APIHOOK(MapViewOfFileEx)(
    HANDLE hFileMappingObject,   // handle to file-mapping object
    DWORD dwDesiredAccess,       // access mode
    DWORD dwFileOffsetHigh,      // high-order DWORD of offset
    DWORD dwFileOffsetLow,       // low-order DWORD of offset
    SIZE_T dwNumberOfBytesToMap, // number of bytes to map
    LPVOID lpBaseAddress         // starting addres
    )
{
    //
    // Check to see if we need to force Read access for CD-ROM files
    // Only the FILE_MAP_READ bit may be enabled for CD-ROM access
    //
    if ((dwDesiredAccess != FILE_MAP_READ) &&
         g_RO_Handles->Exist(hFileMappingObject))
    {
        dwDesiredAccess = FILE_MAP_READ;
        LOGN(eDbgLevelError,
            "[MapViewOfFile] Handle 0x%08x: attributes modified for read-only device", hFileMappingObject);
    }

    HANDLE hRet = ORIGINAL_API(MapViewOfFileEx)(
        hFileMappingObject,
        dwDesiredAccess,
        dwFileOffsetHigh,
        dwFileOffsetLow,
        dwNumberOfBytesToMap,
        lpBaseAddress);

    return hRet;
}

/*++

 If hSourceHandle has been mucked with, add the duplicated handle to our list

--*/

BOOL   
APIHOOK(DuplicateHandle)(
    HANDLE hSourceProcessHandle,  // handle to source process
    HANDLE hSourceHandle,         // handle to duplicate
    HANDLE hTargetProcessHandle,  // handle to target process
    LPHANDLE lpTargetHandle,      // duplicate handle
    DWORD dwDesiredAccess,        // requested access
    BOOL bInheritHandle,          // handle inheritance option
    DWORD dwOptions               // optional actions
    )
{
    BOOL retval = ORIGINAL_API(DuplicateHandle)(
        hSourceProcessHandle,
        hSourceHandle,
        hTargetProcessHandle,
        lpTargetHandle,
        dwDesiredAccess,
        bInheritHandle,
        dwOptions);

     if (retval && g_RO_Handles->Exist(hSourceHandle))
     {
        g_RO_Handles->Add(hTargetProcessHandle);
     }

     return retval;
}

/*++

 If hObject has been mucked with, remove it from the list.

--*/

BOOL  
APIHOOK(CloseHandle)(
    HANDLE hObject   // handle to object
    )
{
    g_RO_Handles->Remove(hObject);

    return ORIGINAL_API(CloseHandle)(hObject);
}

/*++

 Remove read only attribute if it's a directory

--*/

DWORD 
APIHOOK(GetFileAttributesA)(LPCSTR lpFileName)
{    
    DWORD dwFileAttributes = ORIGINAL_API(GetFileAttributesA)(lpFileName);
    
    // Check for READONLY and DIRECTORY attributes
    if ((dwFileAttributes != INT_PTR(-1)) &&
        (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRomA(lpFileName))
    {
        // Flip the read-only bit.
        LOGN(eDbgLevelWarning, "[GetFileAttributesA] Removing FILE_ATTRIBUTE_READONLY");
        dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return dwFileAttributes;
}

/*++

 Remove read only attribute if it's a directory

--*/

DWORD 
APIHOOK(GetFileAttributesW)(LPCWSTR wcsFileName)
{
    DWORD dwFileAttributes = ORIGINAL_API(GetFileAttributesW)(wcsFileName);
    
    // Check for READONLY and DIRECTORY attributes
    if ((dwFileAttributes != INT_PTR(-1)) &&
        (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRomW(wcsFileName))
    {
        // Flip the read-only bit.
        LOGN(eDbgLevelWarning, "[GetFileAttributesW] Removing FILE_ATTRIBUTE_READONLY");
        dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return dwFileAttributes;
}

/*++

 Remove read only attribute if it's a directory

--*/

HANDLE 
APIHOOK(FindFirstFileA)(
    LPCSTR lpFileName, 
    LPWIN32_FIND_DATAA lpFindFileData
    )
{    
    HANDLE hFindFile = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

    if ((hFindFile != INVALID_HANDLE_VALUE) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRom(((PFINDFILE_HANDLE) hFindFile)->DirectoryHandle))
    {
        // Flip the read-only bit
        LOGN(eDbgLevelWarning, "[FindFirstFileA] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return hFindFile;
}

/*++

 Remove read only attribute if it's a directory.

--*/

HANDLE 
APIHOOK(FindFirstFileW)(
    LPCWSTR wcsFileName, 
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    HANDLE hFindFile = ORIGINAL_API(FindFirstFileW)(wcsFileName, lpFindFileData);

    if ((hFindFile != INVALID_HANDLE_VALUE) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRom(((PFINDFILE_HANDLE) hFindFile)->DirectoryHandle))
    {
        // It's a directory: flip the read-only bit
        LOGN(eDbgLevelInfo, "[FindFirstFileW] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return hFindFile;
}

/*++

 Remove read only attribute if it's a directory.

--*/

BOOL 
APIHOOK(FindNextFileA)(
    HANDLE hFindFile, 
    LPWIN32_FIND_DATAA lpFindFileData 
    )
{    
    BOOL bRet = ORIGINAL_API(FindNextFileA)(hFindFile, lpFindFileData);

    if (bRet &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRom(((PFINDFILE_HANDLE) hFindFile)->DirectoryHandle))
    {
        // Flip the read-only bit.
        LOGN(eDbgLevelWarning, "[FindNextFileA] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return bRet;
}

/*++

 Remove read only attribute if it's a directory.

--*/

BOOL 
APIHOOK(FindNextFileW)(
    HANDLE hFindFile, 
    LPWIN32_FIND_DATAW lpFindFileData 
    )
{
    BOOL bRet = ORIGINAL_API(FindNextFileW)(hFindFile, lpFindFileData);

    if (bRet &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRom(((PFINDFILE_HANDLE) hFindFile)->DirectoryHandle))
    {
        // Flip the read-only bit
        LOGN(eDbgLevelWarning, "[FindNextFileW] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return bRet;
}

/*++

 Remove read only attribute if it's a directory.

--*/

BOOL 
APIHOOK(GetFileInformationByHandle)( 
    HANDLE hFile, 
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation 
    )
{
    BOOL bRet = ORIGINAL_API(GetFileInformationByHandle)(hFile, lpFileInformation);

    if (bRet &&
        (lpFileInformation->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFileInformation->dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRom(hFile))
    {
        // It's a CDROM: flip the read-only bit.
        LOGN(eDbgLevelWarning, "[GetFileInformationByHandle] Removing FILE_ATTRIBUTE_READONLY");
        lpFileInformation->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return bRet;
}

/*++

 If the disk is a CDROM, return the same wrong numbers as Win9x

--*/

BOOL 
APIHOOK(GetDiskFreeSpaceA)(
    LPCSTR  lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )
{
    if (IsOnCDRomA(lpRootPathName)) 
    {
        // Hard code values to match Win9x (wrong) description of CDROM
        *lpSectorsPerCluster        = 0x10;
        *lpBytesPerSector           = 0x800;
        *lpNumberOfFreeClusters     = 0;
        *lpTotalNumberOfClusters    = 0x2b7;

        return TRUE;
    } 
    else 
    {
        // Call the original API
        BOOL lRet = ORIGINAL_API(GetDiskFreeSpaceA)(
            lpRootPathName, 
            lpSectorsPerCluster, 
            lpBytesPerSector, 
            lpNumberOfFreeClusters, 
            lpTotalNumberOfClusters);

        return lRet;
    }
}

/*++

 Initialize all the registry hooks 

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        // Allocate our structure, if it fails, bail on the shim
        g_RO_Handles = new RO_FileMappingList;
    }
    return g_RO_Handles != NULL;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, OpenFile)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileMappingA)
    APIHOOK_ENTRY(KERNEL32.DLL, MapViewOfFile)
    APIHOOK_ENTRY(KERNEL32.DLL, MapViewOfFileEx)
    APIHOOK_ENTRY(KERNEL32.DLL, DuplicateHandle)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesW)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileInformationByHandle)
    APIHOOK_ENTRY(KERNEL32.DLL, GetDiskFreeSpaceA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatedeleteobject.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateDeleteObject.cpp

 Abstract:

    This shim returns TRUE when the DeleteObject API is called regardless of 
    actual result: just like Win9x.

 Notes:

    This is a general purpose shim.

 History:

    10/10/1999 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateDeleteObject)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DeleteObject)
APIHOOK_ENUM_END

/*++

 Force DeleteObject to return TRUE.

--*/

BOOL 
APIHOOK(DeleteObject)(
    HGDIOBJ hObject
    )
{
    ORIGINAL_API(DeleteObject)(hObject);

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(GDI32.DLL, DeleteObject)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatedrawtext.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateDrawText.cpp

 Abstract:

    Win9x DrawText modified the rectangle coordinates if they were
    out of range.  With Win2000 the text will not appear on the
    screen with out of range formatting dimensions. The solution
    is to toggle the high order bit for out of range coordinates.

    We also cast nCount to 16-bits for apps which pass 0x0000ffff 
    instead of a true -1, because the Win9x thunk does this.

 Notes:
    
    This is a general purpose shim.

 History:

    05/03/2000 a-michni  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateDrawText)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DrawTextA)
    APIHOOK_ENUM_ENTRY(DrawTextW)
APIHOOK_ENUM_END


/*++

 Correct the formatting dimensions if necessary.

--*/
long 
Fix_Coordinate(
    long nCoord
    )
{
    if ((nCoord & 0x80000000) && ((nCoord & 0x40000000) == 0)) {
        nCoord &= 0x7FFFFFFF;
    } else if (((nCoord & 0x80000000) == 0) && (nCoord & 0x40000000)) {
        nCoord |= 0x10000000;
    }

    return nCoord;
}


LPRECT 
Fix_Coordinates(
    LPRECT lpRect
    )
{
    //
    // Check bit 32, if it is on and bit 31 is off or bit 32 is off and
    // bit 31 is on, flip bit 32.
    //
    lpRect->left  = Fix_Coordinate(lpRect->left);
    lpRect->right = Fix_Coordinate(lpRect->right);
    lpRect->top   = Fix_Coordinate(lpRect->top);
    lpRect->bottom= Fix_Coordinate(lpRect->bottom);

    return lpRect;
}


int 
APIHOOK(DrawTextA)(
    HDC     hDC,        // handle to DC
    LPCSTR  lpString,   // text to draw
    int     nCount,     // text length
    LPRECT  lpRect,     // formatting dimensions
    UINT    uFormat     // text-drawing options
    )
{
    return ORIGINAL_API(DrawTextA)(
                            hDC,
                            lpString,
                            (__int16) nCount,
                            Fix_Coordinates(lpRect),
                            uFormat);
}

int 
APIHOOK(DrawTextW)(
    HDC     hDC,        // handle to DC
    LPCWSTR lpString,   // text to draw
    int     nCount,     // text length
    LPRECT  lpRect,     // formatting dimensions
    UINT    uFormat     // text-drawing options
    )
{
    return ORIGINAL_API(DrawTextW)(
                            hDC,
                            lpString,
                            (__int16) nCount,
                            Fix_Coordinates(lpRect),
                            uFormat);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, DrawTextA)
    APIHOOK_ENTRY(USER32.DLL, DrawTextW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatedirectdrawsync.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateDirectDrawSync.cpp

 Abstract:

    DirectDraw uses per-thread exclusive mode arbitration on NT. On Win9x this 
    is done per process. What this means is that if an app releases exclusive 
    mode from a different thread than that which acquired it, it will be in a 
    permanently bad state.
  
    This shim ensures that the mutex is obtained and released on the same 
    thread. During DLL_PROCESS_ATTACH, a new thread is started: this thread 
    manages the acquisition and release of the mutex.

    Note we can't get the mutex by catching CreateMutex because it's called 
    from the dllmain of ddraw.dll: so it wouldn't work on win2k.
  
 Notes:

    This is a general purpose shim.

 History:

    09/11/2000 prashkud  Created
    10/28/2000 linstev   Rewrote to work on win2k
    02/23/2001 linstev   Modified to handle cases where DirectDraw was used 
                         inside DllMains

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateDirectDrawSync)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WaitForSingleObject)
    APIHOOK_ENUM_ENTRY(ReleaseMutex)
    APIHOOK_ENUM_ENTRY(CloseHandle)
APIHOOK_ENUM_END

// Enum used to tell our thread what to do
enum {sNone, sWaitForSingleObject, sReleaseMutex};

// Events we use to signal our thread to do work and wait until its done
HANDLE g_hWaitEvent;
HANDLE g_hDoneEvent;
HANDLE g_hThread = NULL;

//
// Parameters that are passed between the caller thread and our thread
// Access is synchronized with a critical section
//

CRITICAL_SECTION g_csSync;
DWORD g_dwWait;
DWORD g_dwWaitRetValue;
DWORD g_dwTime;
BOOL g_bRetValue;

// Store the DirectDraw mutex handle
HANDLE g_hDDMutex = 0;

// Thread tracking data so we can identify degenerate cases
DWORD g_dwMutexOwnerThreadId = 0;

// Find the DirectDraw mutex
DWORD g_dwFindMutexThread = 0;

/*++

 Unfortunately we don't get in early enough on Win2k to get the mutex from the
 ddraw call to CreateMutex, so we have to make use of a special hack that knows
 about the ddraw internals.

 Ddraw has an export called GetOLEThunkData. The name is chosen to prevent 
 people from calling it. It is designed to be used by the test harness. One of 
 the things it can do, is release the exclusive mode mutex. This is the hack 
 we're exploiting so we can determine the mutex handle.

--*/

BOOL
FindMutex()
{
    typedef VOID (WINAPI *_pfn_GetOLEThunkData)(ULONG_PTR dwOrdinal);

    HMODULE hMod;
    _pfn_GetOLEThunkData pfnGetOLEThunkData;

    hMod = GetModuleHandleA("ddraw");
    if (!hMod) {
        DPFN( eDbgLevelError, "[FindMutex] DirectDraw not loaded");
        return FALSE;
    }

    pfnGetOLEThunkData = (_pfn_GetOLEThunkData) GetProcAddress(hMod, "GetOLEThunkData");
    if (!pfnGetOLEThunkData) {
        DPFN( eDbgLevelError, "[FindMutex] Failed to get GetOLEThunkData API");
        return FALSE;
    }

    //
    // Now we plan to go and find the mutex by getting Ddraw to call 
    // ReleaseMutex.
    //

    EnterCriticalSection(&g_csSync); 

    //
    // Set the mutex to the current thread so it can be picked up in the 
    // ReleaseMutex hook
    //

    g_dwFindMutexThread = GetCurrentThreadId();

    //
    // Call to the hard-coded (in ddraw) ReleaseMutex hack which releases the 
    // mutex
    //

    pfnGetOLEThunkData(6);

    g_dwFindMutexThread = 0;

    LeaveCriticalSection(&g_csSync);

    return (g_hDDMutex != 0);
}

/*++

 Hook WaitForSingleObject to determine when DirectDraw is testing or acquiring 
 the mutex. If we haven't got the mutex yet, we attempt to find it using our 
 hack.

--*/

DWORD
APIHOOK(WaitForSingleObject)(
    HANDLE hHandle,
    DWORD dwMilliSeconds
    )
{
    if (g_hThread) {

        //
        // Hack to find the DirectDraw mutex
        //
        if (!g_hDDMutex) {
            FindMutex();
        }
    
        if (g_hDDMutex && (hHandle == g_hDDMutex)) {

            //
            // Use our thread to acquire the mutex. We synchronize since we're
            // accessing globals to communicate with our thread.
            //
            DWORD dwRet;

            EnterCriticalSection(&g_csSync); 

            // Set globals to communicate with our thread
            g_dwTime = dwMilliSeconds;
            g_dwWait = sWaitForSingleObject;
        
            ResetEvent(g_hDoneEvent);

            // Signal our thread to obtain the mutex
            SetEvent(g_hWaitEvent);

            // Wait until the state of the mutex has been determined
            WaitForSingleObject(g_hDoneEvent, INFINITE); 

            // Code to detect the degenerate
            if (g_dwWaitRetValue == WAIT_OBJECT_0) {
                g_dwMutexOwnerThreadId = GetCurrentThreadId();
            }

            dwRet = g_dwWaitRetValue;

            LeaveCriticalSection(&g_csSync);

            return dwRet;
        }
    }

    return ORIGINAL_API(WaitForSingleObject)(hHandle, dwMilliSeconds);
}

/*++

 Hook ReleaseMutex and release the mutex on our thread.

--*/

BOOL   
APIHOOK(ReleaseMutex)(
    HANDLE hMutex
    )
{
    if (g_hThread && (g_dwFindMutexThread == GetCurrentThreadId())) {

        //
        // We're using our hack to find the DirectDraw mutex
        // 
        DPFN( eDbgLevelInfo, "DDraw exclusive mode mutex found");
        g_hDDMutex = hMutex;
        
        // Don't release it, since we never acquired it
        return TRUE;
    }

    //
    // First try to release it on the current thread. This will only succeed if 
    // it was obtained on this thread.
    //

    BOOL bRet = ORIGINAL_API(ReleaseMutex)(hMutex);

    if (!bRet && g_hThread && g_hDDMutex && (hMutex == g_hDDMutex)) {

        //
        // Use our thread to release the mutex. We synchronize since we're
        // accessing globals to communicate with our thread.
        //
   
        EnterCriticalSection(&g_csSync);
    
        // Set globals to communicate with our thread
        g_dwWait = sReleaseMutex;

        ResetEvent(g_hDoneEvent);

        // Wait until our thread returns
        SetEvent(g_hWaitEvent);

        // Signal our thread to release the mutex
        WaitForSingleObject(g_hDoneEvent, INFINITE);

        // Detect degenerate case
        if (GetCurrentThreadId() != g_dwMutexOwnerThreadId) {
            LOGN( eDbgLevelError, "[ReleaseMutex] DirectDraw synchronization error - correcting");
        }

        if (g_bRetValue) {
            g_dwMutexOwnerThreadId = 0;
        }

        bRet = g_bRetValue;

        LeaveCriticalSection(&g_csSync);

    }

    return bRet;
}

/*++

 Clear our handle in case the app frees ddraw and reloads it.

--*/    

BOOL 
APIHOOK(CloseHandle)(HANDLE hObject)
{
    if (g_hThread && (hObject == g_hDDMutex))
    {
        DPFN( eDbgLevelInfo, "DDraw exclusive mode mutex closed");
        g_hDDMutex = 0;
    }

    return ORIGINAL_API(CloseHandle)(hObject);
}

/*++

 Thread used to do all the mutex operations so we can guarantee that the thread
 that acquired the mutex is the same one that releases it.

--*/

VOID 
WINAPI 
ThreadSyncMutex(
    LPVOID lpParameter
    )
{
    while (1) {
        // Wait until we need to acquire or release the mutex
        WaitForSingleObject(g_hWaitEvent, INFINITE);
        
        if (g_dwWait == sWaitForSingleObject) {
            // WaitForSingleobject() has been called on the Mutex object 
            g_dwWaitRetValue = ORIGINAL_API(WaitForSingleObject)(
                g_hDDMutex, g_dwTime);
        }  
        else if (g_dwWait == sReleaseMutex) {
            // ReleaseMutex has been called
            g_bRetValue = ORIGINAL_API(ReleaseMutex)(g_hDDMutex);
        }

        g_dwWait = sNone;

        ResetEvent(g_hWaitEvent);

        SetEvent(g_hDoneEvent);
    }
}

/*++

 Register hooked functions

--*/    

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {

        //
        // We need the critical section all the time
        //
        InitializeCriticalSection(&g_csSync);

        //
        // Create Events that will be used for the thread synchronization, i.e 
        // to synchronize this thread and the one we will be creating ahead. We 
        // don't clean these up by design. We have to do this stuff here, rather
        // than in the process attach, since OpenGL apps and others do DirectX 
        // stuff in their dllmains.
        // 

        g_hWaitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!g_hWaitEvent) {
            DPFN( eDbgLevelInfo, "Failed to create Event 1");
            return FALSE;
        }

        g_hDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!g_hDoneEvent) {
            DPFN( eDbgLevelInfo, "Failed to create Event 2");
            return FALSE;
        }

        // Create our thread
        g_hThread = CreateThread(NULL, 0, 
            (LPTHREAD_START_ROUTINE) ThreadSyncMutex, NULL, 0, 
            NULL);

        if (!g_hThread) {
            DPFN( eDbgLevelInfo, "Failed to create Thread");
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, WaitForSingleObject)
    APIHOOK_ENTRY(KERNEL32.DLL, ReleaseMutex)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateenvironmentblock.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateEnvironmentBlock.cpp

 Abstract:
    
    Shrink the enviroment strings to avoid memory corruption experienced by 
    some apps when they get a larger than expected enviroment.

 Notes:

    This is a general purpose shim.

 History:

    01/19/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateEnvironmentBlock)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(GetEnvironmentStrings)
    APIHOOK_ENUM_ENTRY(GetEnvironmentStringsA)
    APIHOOK_ENUM_ENTRY(GetEnvironmentStringsW)
    APIHOOK_ENUM_ENTRY(FreeEnvironmentStringsA)
    APIHOOK_ENUM_ENTRY(FreeEnvironmentStringsW)

APIHOOK_ENUM_END

#define MAX_ENV 1024

CHAR  g_szBlockA[MAX_ENV];
WCHAR g_szBlockW[MAX_ENV];

WCHAR *g_szEnv[] = {
    L"TMP=%TMP%",
    L"TEMP=%TEMP%",
    L"PROMPT=%PROMPT%",
    L"winbootdir=%WINDIR%",
    L"PATH=%WINDIR%",
    L"COMSPEC=%COMSPEC%",
    L"WINDIR=%WINDIR%",
    NULL
};

/*++

 Build a reasonable looking environment block

--*/

BOOL BuildEnvironmentStrings()
{
    DWORD dwSize;
    WCHAR szTmp[MAX_PATH];
    LPWSTR lpCurr = &g_szBlockW[0];

    DPFN( eDbgLevelError, "Building Environment Block");
    
    //
    // Run g_szEnv, expand all the strings and cat them together to form the 
    // new block
    //
    
    DWORD i = 0;
    while (g_szEnv[i])
    {
        dwSize = ExpandEnvironmentStringsW(g_szEnv[i], szTmp, MAX_PATH);
        if ((dwSize > 0) && (dwSize < MAX_PATH))
        {
            if (lpCurr + wcslen(szTmp) - g_szBlockW < MAX_ENV)
            {
                wcscat(lpCurr, szTmp);
                lpCurr += wcslen(lpCurr) + 1;
                DPFN( eDbgLevelError, "\tAdding: %S", szTmp);
            }
            else
            {
                DPFN( eDbgLevelError, "Enviroment > %08lx, ignoring %S", MAX_ENV, szTmp);
            }
        }

        i++;
    }

    //
    // Calculate the size of the new block
    //
     
    dwSize = lpCurr - g_szBlockW;

    // 
    // ANSI conversion for the A functions
    // 

    WideCharToMultiByte(
        CP_ACP, 
        0, 
        (LPWSTR) g_szBlockW, 
        dwSize, 
        (LPSTR) g_szBlockA, 
        dwSize,
        0, 
        0);

    return TRUE;
}

/*++

 Return our block

--*/

LPVOID 
APIHOOK(GetEnvironmentStrings)()
{
    return (LPVOID) g_szBlockA;
}

/*++

 Return our block

--*/

LPVOID 
APIHOOK(GetEnvironmentStringsA)()
{
    return (LPVOID) g_szBlockA;
}

/*++

 Return our block

--*/

LPVOID 
APIHOOK(GetEnvironmentStringsW)()
{
    return (LPVOID) g_szBlockW;
}

/*++

 Check for our block.

--*/

BOOL 
APIHOOK(FreeEnvironmentStringsA)(
    LPSTR lpszEnvironmentBlock
    )
{
    if ((lpszEnvironmentBlock == (LPSTR)&g_szBlockA[0]) ||
        (lpszEnvironmentBlock == (LPSTR)&g_szBlockW[0]))
    {
        return TRUE;
    }
    else
    {
        return ORIGINAL_API(FreeEnvironmentStringsA)(lpszEnvironmentBlock);
    }
}

/*++

 Check for our block.

--*/

BOOL 
APIHOOK(FreeEnvironmentStringsW)(
    LPWSTR lpszEnvironmentBlock
    )
{
    if ((lpszEnvironmentBlock == (LPWSTR)&g_szBlockA[0]) ||
        (lpszEnvironmentBlock == (LPWSTR)&g_szBlockW[0]))
    {
        return TRUE;
    }
    else
    {
        return ORIGINAL_API(FreeEnvironmentStringsW)(lpszEnvironmentBlock);
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return BuildEnvironmentStrings();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, GetEnvironmentStrings)
    APIHOOK_ENTRY(KERNEL32.DLL, GetEnvironmentStringsA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetEnvironmentStringsW)
    APIHOOK_ENTRY(KERNEL32.DLL, FreeEnvironmentStringsA)
    APIHOOK_ENTRY(KERNEL32.DLL, FreeEnvironmentStringsW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateclipboarddibformat.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    EmulateClipboardDIBFormat.cpp

 Abstract:

    On Win9x when you copy a high color bitmap onto the clipboard, it always
    gets converted to a 24-bit DIB when you ask the clipboard for CF_DIB 
    format. On NT the conversion doesn't happen. So some apps are only 
    designed to handle 8-bit and 24-bit DIBs (example, Internet Commsuite).
    So we convert the high-color (16-bit and 32-bit) DIBs to 24-bit DIBs
    - we don't need to handle 24-bit ones as they should already be handled
    by the app itself (or it won't work on 9x).

 Notes:

    This is a general purpose shim.

 History:

    01/24/2001 maonis  Created

--*/
#include "precomp.h"
//#include <userenv.h>

IMPLEMENT_SHIM_BEGIN(EmulateClipboardDIBFormat)
#include "ShimHookMacro.h"

typedef HANDLE (*_pfn_GetClipboardData)(UINT);
typedef BOOL (*_pfn_CloseClipboard)(VOID);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetClipboardData)
    APIHOOK_ENUM_ENTRY(CloseClipboard)
APIHOOK_ENUM_END

BITMAPINFOHEADER* g_pv = NULL;

DWORD CalcBitmapSize(BITMAPINFOHEADER* pbih)
{
    return pbih->biWidth * pbih->biHeight * pbih->biBitCount / 8;
}

HANDLE 
APIHOOK(GetClipboardData)(
    UINT uFormat   // clipboard format
    )
{
    if (uFormat == CF_DIB)
    {
        BITMAPINFO* pbmiOriginal = (BITMAPINFO*)ORIGINAL_API(GetClipboardData)(uFormat);

        if ((pbmiOriginal->bmiHeader.biBitCount > 8) && (pbmiOriginal->bmiHeader.biBitCount != 24))
        {
            HDC hdc = CreateCompatibleDC(NULL);

            if (hdc)
            {
                VOID* pvOriginal;

                HBITMAP hbmpOriginal = CreateDIBSection(hdc, pbmiOriginal, DIB_RGB_COLORS, &pvOriginal, NULL, 0);

                if (hbmpOriginal)
                {
                    DWORD* pdwOriginal = (DWORD *)(pbmiOriginal + 1) +
                        ((pbmiOriginal->bmiHeader.biCompression == BI_BITFIELDS) ? 2 : -1);

                    // Fill in the data.
                    memcpy(pvOriginal, pdwOriginal, CalcBitmapSize(&(pbmiOriginal->bmiHeader)));

                    BITMAPINFOHEADER bmi;
                    memcpy(&bmi, pbmiOriginal, sizeof(BITMAPINFOHEADER));
                    bmi.biBitCount = 24;
                    bmi.biSizeImage = 0;
                    bmi.biCompression = BI_RGB;

                    if (GetDIBits(hdc, hbmpOriginal, 0, bmi.biHeight, NULL, (BITMAPINFO*)&bmi, DIB_RGB_COLORS))
                    {
                        // We need to allocate a contiguous block of memory to hold both the 
                        // bitmap header and the data.
                        g_pv = (BITMAPINFOHEADER*) new BYTE [sizeof(BITMAPINFOHEADER) + bmi.biSizeImage];

                        if (g_pv)
                        {
                            memcpy(g_pv, &bmi, sizeof(BITMAPINFOHEADER));

                            if (GetDIBits(hdc, hbmpOriginal, 0, bmi.biHeight, g_pv + 1, (BITMAPINFO*)&bmi, DIB_RGB_COLORS))
                            {
                                return (HANDLE)g_pv;
                            }
                        }
                    }

                    DeleteObject(hbmpOriginal);
                }

                DeleteDC(hdc);
            }
        }
    }

    return ORIGINAL_API(GetClipboardData)(uFormat);
}

BOOL 
APIHOOK(CloseClipboard)(
    VOID
    )
{
    if (g_pv)
    {
        delete g_pv;
        g_pv = NULL;   
    }
    
    return ORIGINAL_API(CloseClipboard)();
}

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, GetClipboardData)
    APIHOOK_ENTRY(USER32.DLL, CloseClipboard)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatecreatefilemapping.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateCreateFileMapping.cpp

 Abstract:

    Win9x defaults to SEC_COMMIT when the SEC_NOCACHE flag is set. 
    NT fails the call.

    File mapping names, can't contain backslashes.

 Notes:

    This is a general purpose shim.

 History:
        
    02/17/2000  linstev     Created
    05/26/2001  robkenny    Replace all \ to _ in map names.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateCreateFileMapping)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileMappingA)
    APIHOOK_ENUM_ENTRY(CreateFileMappingW)
    APIHOOK_ENUM_ENTRY(OpenFileMappingA)
    APIHOOK_ENUM_ENTRY(OpenFileMappingW)
APIHOOK_ENUM_END


/*++

 Correct the flag and name

--*/

HANDLE 
APIHOOK(CreateFileMappingW)(
    HANDLE hFile,              
    LPSECURITY_ATTRIBUTES lpAttributes,
    DWORD flProtect,           
    DWORD dwMaximumSizeHigh,   
    DWORD dwMaximumSizeLow,    
    LPCWSTR lpName             
    )
{
    HANDLE hRet = ORIGINAL_API(CreateFileMappingW)(hFile, lpAttributes, 
        flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

    if (!hRet) {
        //
        // The call failed, so try correcting the parameters
        //

        DWORD flNewProtect = flProtect;
        if ((flProtect & SEC_NOCACHE) && 
            (!((flProtect & SEC_COMMIT) || (flProtect & SEC_RESERVE)))) {
            // Add the SEC_COMMIT flag
            flNewProtect |= SEC_COMMIT;
        }

        CSTRING_TRY {
            // Replace backslashes
            CString csName(lpName);
            int nCount = csName.Replace(L'\\', '_');
            LPCWSTR lpCorrectName = csName;
    
            if (nCount || (flProtect != flNewProtect)) {
                // Something happened, so log it
                if (nCount) {
                    LOGN(eDbgLevelError, 
                        "[CreateFileMapping] Corrected event name from (%S) to (%S)", lpName, lpCorrectName);
                }
                if (flProtect != flNewProtect) {
                    LOGN(eDbgLevelError, "[CreateFileMapping] Adding SEC_COMMIT flag");
                }
        
                // Call again with fixed parameters
                hRet = ORIGINAL_API(CreateFileMappingW)(hFile, lpAttributes, flNewProtect, 
                    dwMaximumSizeHigh, dwMaximumSizeLow, lpCorrectName);
            }
        }
        CSTRING_CATCH {
            // Do nothing
        }
    }

    return hRet;
}

/*++

 Pass through to CreateFileMappingW.

--*/

HANDLE 
APIHOOK(CreateFileMappingA)(
    HANDLE hFile,              
    LPSECURITY_ATTRIBUTES lpAttributes,
    DWORD flProtect,           
    DWORD dwMaximumSizeHigh,   
    DWORD dwMaximumSizeLow,    
    LPCSTR lpName             
    )
{
    HANDLE hRet;

    CSTRING_TRY {
        // Convert to unicode
        CString csName(lpName);
        LPCWSTR lpwName = csName;

        hRet = APIHOOK(CreateFileMappingW)(hFile, lpAttributes, flProtect, 
            dwMaximumSizeHigh, dwMaximumSizeLow, lpwName);
    }
    CSTRING_CATCH {
        // Fall back as gracefully as possible
        hRet = ORIGINAL_API(CreateFileMappingA)(hFile, lpAttributes, flProtect, 
            dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
    }

    return hRet;
}

/*++

 Correct the name

--*/

HANDLE
APIHOOK(OpenFileMappingW)(
    DWORD dwDesiredAccess,  
    BOOL bInheritHandle,    
    LPCWSTR lpName          
    )
{
    HANDLE hRet = ORIGINAL_API(OpenFileMappingW)(dwDesiredAccess, bInheritHandle, 
        lpName);
    
    if (!hRet) {
        //
        // The call failed, so try correcting the parameters
        //

        CSTRING_TRY {
            // Replace backslashes
            CString csName(lpName);
            int nCount = csName.Replace(L'\\', '_');
            LPCWSTR lpCorrectName = csName;
    
            if (nCount) {
                // Something happened, so log it
                LOGN(eDbgLevelError, 
                    "OpenFileMappingW corrected event name from (%S) to (%S)", lpName, lpCorrectName);

                // Call again with fixed parameters
                hRet = ORIGINAL_API(OpenFileMappingW)(dwDesiredAccess, bInheritHandle, 
                    lpCorrectName);
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return hRet;
}

/*++

 Pass through to OpenFileMappingW.

--*/

HANDLE
APIHOOK(OpenFileMappingA)(
    DWORD dwDesiredAccess,  
    BOOL bInheritHandle,    
    LPCSTR lpName          
    )
{
    HANDLE hRet;

    CSTRING_TRY {
        // Convert to unicode
        CString csName(lpName);
        LPCWSTR lpwName = csName;

        hRet = APIHOOK(OpenFileMappingW)(dwDesiredAccess, bInheritHandle,
            lpwName);
    }
    CSTRING_CATCH {
        // Fall back as gracefully as possible
        hRet = ORIGINAL_API(OpenFileMappingA)(dwDesiredAccess, bInheritHandle, 
            lpName);
    }

    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileMappingA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileMappingW)
    APIHOOK_ENTRY(KERNEL32.DLL, OpenFileMappingA)
    APIHOOK_ENTRY(KERNEL32.DLL, OpenFileMappingW)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatecreateprocess.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    EmulateCreateProcess.cpp

 Abstract:

    This shim cleans up the StartupInfo data structure to prevent NT from
    access violating due to uninitialized members.

    It also performs a little cleanup of lpApplicationName and lpCommandLine

    Win9x uses short file names internally, so applications do not
    have any problem skipping the application name (first arg) on the command line;
    they typically skip to the first blank.


 History:

    11/22/1999  v-johnwh    Created
    04/11/2000  a-chcoff    Updated to quote lpCommandLine Properly.
    05/03/2000  robkenny    Skip leading white space in lpApplicationName and lpCommandLine
    10/09/2000  robkenny    Shim was placing quotes around lpCommandLine if it contained spaces,
                            this is totally wrong.  Since I could not find the app that required this,
                            I removed it entirely from the shim.
    03/09/2001  robkenny    Merged in CorrectCreateProcess16Bit
    03/15/2001  robkenny    Converted to CString
    05/21/2001  pierreys    Changes to DOS file handling to match 9X more precisely

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateCreateProcess)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(WinExec)
APIHOOK_ENUM_END

BOOL g_bShortenExeOnCommandLine = FALSE;

/*++

 Clean parameters so we don't AV

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                lpApplicationName,
    LPSTR                 lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPCSTR                lpCurrentDirectory,
    LPSTARTUPINFOA        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    DPFN(
        eDbgLevelSpew,
        "[CreateProcessA] (%s) (%s)\n",
        (lpApplicationName ? lpApplicationName : "null"),
        (lpCommandLine ? lpCommandLine : "null"));
    
    BOOL    bStat = FALSE;
    DWORD   dwBinaryType;

    CSTRING_TRY
    {
        CString csOrigAppName(lpApplicationName);
        CString csOrigCommand(lpCommandLine);

        CString csAppName(csOrigAppName);
        CString csCommand(csOrigCommand);
        
        // Skip leading blanks.
        csAppName.TrimLeft();
        csCommand.TrimLeft();
        
        // Clean up lpStartupInfo
        if (lpStartupInfo)
        {
            if (lpStartupInfo->lpReserved ||
                lpStartupInfo->cbReserved2 ||
                lpStartupInfo->lpReserved2 ||
                lpStartupInfo->lpDesktop ||
                ((lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) == 0 &&
                (lpStartupInfo->hStdInput ||
                lpStartupInfo->hStdOutput ||
                lpStartupInfo->hStdError)))
                {
    
                LOGN(
                    eDbgLevelError,
                    "[CreateProcessA] Bad params. Sanitized.");
            }
            
            //
            // Make sure that the parameters that can cause an access violation are
            // set correctly
            //
            lpStartupInfo->lpReserved  = NULL;
            lpStartupInfo->cbReserved2 = 0;
            lpStartupInfo->lpReserved2 = NULL;
    
            if ((lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) == 0)
            {
                lpStartupInfo->hStdInput   = NULL;
                lpStartupInfo->hStdOutput  = NULL;
                lpStartupInfo->hStdError   = NULL;
            }
    
            lpStartupInfo->lpDesktop = NULL;
        }
    
        AppAndCommandLine acl(csAppName, csCommand);
    
        // Win9X has a rather weird behavihor: if the app is non-Win32 (Non-Console
        // and non GUI), it will use CreateProcessNonWin32. This will first check
        // if it is for a batch file, and if so it will prepend "command /c" and
        // continue on. Then there is going to be some weird creation of a 
        // REDIR32.EXE process, but that is just to make sure we have a new win32 
        // context. It will then use ExecWin16Program. The biggest weirdness is in
        // its QuoteAppName call. This procedure make sure that if the appname has
        // a space and is in the cmdline, it gets quoted. The appname, in all cases,
        // is then discarded (it is expected that the first part of the command line
        // contains the app name). So if someone like in b#373980 passes ("command", 
        // "setup", ... then 9X ends up dropping the command portion entirely since
        // it is not part of the commandline.


        
        // 16-bit process must have NULL lpAppName
        if (!csAppName.IsEmpty() &&
            GetBinaryTypeW(csAppName.Get(), &dwBinaryType) == TRUE)
        {
            switch (dwBinaryType)
            {
                case SCS_DOS_BINARY:

                    // Implementing the process.c's QuoteAppName check.
                    // If this function would return NULL, then only
                    // the cmdline would be used. Otherwise the new
                    // pszCmdFinal is used.

                    // QuoteAppName
                    // Look for white space in app name.  If we find any then we have to
                    // quote the app name portion of cmdline.
                    //
                    // LPSTR
                    // KERNENTRY
                    // QuoteAppName(
                    //    LPCSTR pszAppName,
                    //    LPCSTR pszCmdLine)
                    // {
                    //    LPSTR   pch;
                    //    LPSTR   pszApp;
                    //    LPSTR   pszCmdFinal = NULL;
                    //
                    //    // Check that there is an app name, not already quoted in the cmd line.
                    //    if( pszAppName && pszCmdLine && (*pszCmdLine != '\"')) {
                    //        // search for white space
                    //        for( pszApp = (LPSTR)pszAppName; *pszApp > ' '; pszApp++) ;
                    //
                    //        if( *pszApp) {  // found white space
                    //            // make room for the original cmd line plus 2 '"' + 0 terminator
                    //            pch = pszCmdFinal = HeapAlloc( hheapKernel, 0,
                    //                                           CbSizeSz( pszCmdLine)+3);
                    //            if( pch) { 
                    //                *pch++ = '\"'; // beginning dbl-quote
                    //                for( pszApp = (LPSTR)pszAppName; 
                    //                        *pszApp && *pszApp == *pszCmdLine;
                    //                         pszCmdLine++)
                    //                    *pch++ = *pszApp++;
                    //                if( !( *pszApp)) {
                    //                    *pch++ = '\"'; // trailing dbl-quote
                    //                     strcpy( pch, pszCmdLine);
                    //                } else {
                    //                    // app name and cmd line did not match
                    //                    HeapFree( hheapKernel, 0, pszCmdFinal);
                    //                    pszCmdFinal = NULL;
                    //                }
                    //            }
                    //        }
                    //    }
                    //    return pszCmdFinal;
                    //}

                    if ( /* app name already checked to be non empty */ !csCommand.IsEmpty() && (csCommand.Get())[0]!='\"')
                    {
                        if (csAppName.Find(L' ')!=-1)
                        {
                            int iAppLength=csAppName.GetLength();

                            if (csCommand.Find(csAppName)==0)
                            {
                                CString csCmdFinal=L"\"";
                                csCmdFinal += csAppName;
                                csCmdFinal += L"\"";
                                csCmdFinal += csCommand.Mid(iAppLength);

                                csCommand = csCmdFinal;

                                LOGN(   eDbgLevelSpew,
                                        "[CreateProcessA] Weird quoted case: cmdline %s converted to %S",
                                         lpCommandLine,
                                         csCommand.Get());
                            }

                        }
                    }

                    LOGN(   eDbgLevelSpew,
                            "[CreateProcessA] DOS file case: not using appname %s, just cmdline %s, converted to %S",
                             lpApplicationName,
                             lpCommandLine,
                             csCommand.Get());

                    csAppName.Empty();
                
                    //
                    // The old code in non-WOW case would do this.
                    //
                    if (g_bShortenExeOnCommandLine)
                    {
                        csCommand = acl.GetShortCommandLine();
                    }
                    break;

                case SCS_WOW_BINARY:
                    //
                    // This is the old code. Accoring to 9X, we should be doing
                    // the same as DOS, but we obviously found an app that 
                    // needed this.
                    //
                    csCommand = csAppName;    
                    csCommand.GetShortPathNameW();
                    csCommand += L' ';
                    csCommand += acl.GetCommandlineNoAppName();
        
                    csAppName.Empty();
                    break;

                default:
                    //
                    // The old code in non-WOW case would do this.
                    //
                    if (g_bShortenExeOnCommandLine)
                    {
                        csCommand = acl.GetShortCommandLine();
                    }
                    break;
                }
        }
        else if (g_bShortenExeOnCommandLine)
        {
            csCommand = acl.GetShortCommandLine();
        }
    
        LPCSTR  lpNewApplicationName = csAppName.GetAnsiNIE();
        LPSTR   lpNewCommandLine     = csCommand.GetAnsiNIE();
    
        // Log any changes
        if (csOrigAppName != csAppName)
        {
            LOGN(
                eDbgLevelError,
                "[CreateProcessA] Sanitized lpApplicationName (%s) to (%s)",
                lpApplicationName, lpNewApplicationName);
        }
        if (csOrigCommand != csCommand)
        {
            LOGN(
                eDbgLevelError,
                "[CreateProcessA] Sanitized lpCommandLine     (%s) to (%s)",
                lpCommandLine, lpNewCommandLine);
        }
    
        bStat = ORIGINAL_API(CreateProcessA)(
                                lpNewApplicationName,
                                lpNewCommandLine,
                                lpProcessAttributes,
                                lpThreadAttributes,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                lpStartupInfo,
                                lpProcessInformation);
    }
    CSTRING_CATCH
    {
        bStat = ORIGINAL_API(CreateProcessA)(
                                lpApplicationName,
                                lpCommandLine,
                                lpProcessAttributes,
                                lpThreadAttributes,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                lpStartupInfo,
                                lpProcessInformation);
    }

    
    return bStat;
}

/*++

 Clean parameters so we don't AV

--*/

BOOL
APIHOOK(CreateProcessW)(
    LPCWSTR               lpApplicationName,
    LPWSTR                lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPCWSTR               lpCurrentDirectory,
    LPSTARTUPINFOW        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    DPFN(
        eDbgLevelSpew,
        "[CreateProcessW] (%S) (%S)\n",
        (lpApplicationName ? lpApplicationName : L"null"),
        (lpCommandLine ? lpCommandLine : L"null"));

    BOOL bStat = FALSE;

    CSTRING_TRY
    {
        CString csAppName(lpApplicationName);
        CString csCommand(lpCommandLine);
        
        // Skip leading blanks.
        csAppName.TrimLeft();
        csCommand.TrimLeft();
        
        // Clean up lpStartupInfo
        if (lpStartupInfo)
        {
            if (lpStartupInfo->lpReserved ||
                lpStartupInfo->cbReserved2 ||
                lpStartupInfo->lpReserved2 ||
                lpStartupInfo->lpDesktop ||
                ((lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) == 0 &&
                (lpStartupInfo->hStdInput ||
                lpStartupInfo->hStdOutput ||
                lpStartupInfo->hStdError)))
                {
    
                LOGN(
                    eDbgLevelError,
                    "[CreateProcessW] Bad params. Sanitized.");
            }
            
            //
            // Make sure that the parameters that can cause an access violation are
            // set correctly
            //
            lpStartupInfo->lpReserved  = NULL;
            lpStartupInfo->cbReserved2 = 0;
            lpStartupInfo->lpReserved2 = NULL;
    
            if ((lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) == 0)
            {
                lpStartupInfo->hStdInput   = NULL;
                lpStartupInfo->hStdOutput  = NULL;
                lpStartupInfo->hStdError   = NULL;
            }
    
            lpStartupInfo->lpDesktop = NULL;
        }
    
        AppAndCommandLine acl(csAppName, csCommand);
        // 16-bit process must have NULL lpAppName
        if (!csAppName.IsEmpty() && IsImage16BitW(csAppName.Get()))
        {
            csCommand = csAppName;    
            csCommand.GetShortPathNameW();
            csCommand += L' ';
            csCommand += acl.GetCommandlineNoAppName();
            
            csAppName.Empty();
        }
        else if (g_bShortenExeOnCommandLine)
        {
            csCommand = acl.GetShortCommandLine();
        }
   
        LPCWSTR  lpNewApplicationName = csAppName.GetNIE();
        LPWSTR   lpNewCommandLine     = (LPWSTR) csCommand.GetNIE(); // stupid api doesn't take const
    
        // Log any changes
        if (lpApplicationName && lpNewApplicationName && _wcsicmp(lpApplicationName, lpNewApplicationName) != 0)
        {
            LOGN(
                eDbgLevelError,
                "[CreateProcessW] Sanitized lpApplicationName (%S) to (%S)",
                lpApplicationName, lpNewApplicationName);
        }
        if (lpCommandLine && lpNewCommandLine && _wcsicmp(lpCommandLine, lpNewCommandLine) != 0)
        {
            LOGN(
                eDbgLevelError,
                "[CreateProcessW] Sanitized lpCommandLine     (%S) to (%S)",
                lpCommandLine, lpNewCommandLine);
        }
    
        bStat = ORIGINAL_API(CreateProcessW)(
                                lpNewApplicationName,
                                lpNewCommandLine,
                                lpProcessAttributes,
                                lpThreadAttributes,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                lpStartupInfo,
                                lpProcessInformation);
    }
    CSTRING_CATCH
    {
        bStat = ORIGINAL_API(CreateProcessW)(
                                lpApplicationName,
                                lpCommandLine,
                                lpProcessAttributes,
                                lpThreadAttributes,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                lpStartupInfo,
                                lpProcessInformation);
    }
    
    return bStat;
}


/*++

 Clean up the command line

--*/

UINT
APIHOOK(WinExec)(
    LPCSTR lpCommandLine,  // command line
    UINT   uCmdShow        // window style
    )
{
    CSTRING_TRY
    {
        CString csOrigCommand(lpCommandLine);
        CString csCommand(csOrigCommand);
        csCommand.TrimLeft();

        LPCSTR lpNewCommandLine = csCommand.GetAnsi();
        
        if (csOrigCommand != csCommand)
        {
            LOGN(
                eDbgLevelError,
                "[WinExec] Sanitized lpCommandLine (%s) (%s)",
                lpCommandLine, lpNewCommandLine);
        }
    
        return ORIGINAL_API(WinExec)(lpNewCommandLine, uCmdShow);
    }
    CSTRING_CATCH
    {
        return ORIGINAL_API(WinExec)(lpCommandLine, uCmdShow);
    }
}

/*++

    Create the appropriate g_PathCorrector

--*/
void
ParseCommandLine(
    const char* commandLine
    )
{
    //
    // Force the default values.
    //
    g_bShortenExeOnCommandLine = FALSE;

    CString csCL(commandLine);
    if (csCL.CompareNoCase(L"+ShortenExeOnCommandLine") == 0)
    {
        g_bShortenExeOnCommandLine = TRUE;
    }
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        ParseCommandLine(COMMAND_LINE);
    }

    return TRUE;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)
    APIHOOK_ENTRY(KERNEL32.DLL, WinExec)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulategetcommandline.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    EmulateGetCommandLine.cpp

 Abstract:

    This app uses GetCommandLine() to figure out what the drive letter of the 
    CD-ROM is. Unfortunately the behaviour of this API is different from Win9x 
    to NT:

    Original command line:                          
        E:\Final Doom\Doom95.exe -dm -cdrom

    NT's GetCommandLine() returns:              
        Doom95.exe -dm -cdrom

    Win9x's GetCommandLine() returns:       
        E:\FINALD~1\DOOM95.EXE -dm -cdrom

    This app returns short pathnames for GetCommandLine and GetModuleFileName.

 Notes:

    This is a general purpose shim.

 Created:

    01/03/2000  markder     Created
    09/26/2000  mnikkel     GetModuleFileName added
    11/10/2000  robkenny    Fixed PREFIX bugs, removed W routines.
    11/21/2000  prashkud    Fixed the GetCommandLineA hook bug when the CommandLine
                            had the executable name/path with spaces. Used 
                            AppAndCommandLine functions.
    02/27/2001  robkenny    Converted to use CString
    05/02/2001  pierreys    If buffer is too small, GetModuleFileNameA puts \0 at end of it like 9X.


--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetCommandLine)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA)
    APIHOOK_ENUM_ENTRY(GetModuleFileNameA)
APIHOOK_ENUM_END


char     * g_lpszCommandLine = NULL;

/*++

 This stub function appends the commandline returned from GetCommandLine() to a 
 pre-determined path to emulate Win9x behavior.

--*/

LPSTR 
APIHOOK(GetCommandLineA)(
    void
    )
{
    // Been here, done that
    if (g_lpszCommandLine)
    {
        return g_lpszCommandLine;
    }

    LPSTR lpszOrig = ORIGINAL_API(GetCommandLineA)();
    
    // Seperate the app name and command line
    AppAndCommandLine AppCmdLine(NULL, lpszOrig);

    CSTRING_TRY
    { 
        // retrieve the original command line
        CString csAppName(AppCmdLine.GetApplicationName());

        if (csAppName.Find(L' ') == -1)
        {
            // If no spaces in app name, return the original command line.
            g_lpszCommandLine = lpszOrig;
        }
        else
        {
            // Spaces found so return short app path name
            // and rest of original command line
            csAppName.GetShortPathName();
            csAppName += L" ";
            csAppName += AppCmdLine.GetCommandlineNoAppName();
            g_lpszCommandLine = csAppName.ReleaseAnsi();

            LOGN( eDbgLevelError,
                "[GetCommandLineA] Changed Command Line from <%s> to <%s>.",
                lpszOrig, g_lpszCommandLine);
        }
    }
    CSTRING_CATCH
    {
        g_lpszCommandLine = lpszOrig;
    }

    return g_lpszCommandLine;
}

/*++

 This stub function returns the short pathname on the call to GetModuleFileName
 to emulate Win9x behavior.

--*/

DWORD 
APIHOOK(GetModuleFileNameA)(
    HMODULE hModule,      // handle to module
    LPSTR   lpFilename,   // file name of module
    DWORD   nSize         // size of buffer
    )
{
    CHAR  szExeFileNameLong[MAX_PATH];
    CHAR  szExeFileNameLong2[MAX_PATH];
    DWORD len;

    len=ORIGINAL_API(GetModuleFileNameA)(
                        hModule,
                        szExeFileNameLong,
                        sizeof(szExeFileNameLong));

    CSTRING_TRY
    {
        CString csAppName(szExeFileNameLong);

        if (csAppName.Find(L' ') > -1)
        {
            // Spaces found so return short app path name
            len = GetShortPathNameA( szExeFileNameLong,
                                     szExeFileNameLong2,
                                     sizeof(szExeFileNameLong2));

            LOGN(
                eDbgLevelError,
                "[GetModuleFileNameA] Changed <%s> to <%s>.",
                 szExeFileNameLong, szExeFileNameLong2);

            RtlCopyMemory(szExeFileNameLong, szExeFileNameLong2, len+1);
       }

        
        //
        // From 9X's PELDR.C. If the buffer has no room for the '\0', 9X stuff the 0 at the
        // last byte.
        //
        if (nSize) {
            //        len = pmte->iFileNameLen;
            if (len >= nSize) {
                len = nSize - 1;
                LOGN(eDbgLevelError,
                     "[GetModuleFileNameA] Will shorten <%s> to %d characters.",
                     szExeFileNameLong, len);
            }

            RtlCopyMemory(lpFilename, szExeFileNameLong /* pmte->cfhid.lpFilename */, len);
            lpFilename[len] = 0;      
        }

        
        // Returned the double buffered name len.
        return len;
    }
    CSTRING_CATCH
    {
         // If error return original api.
        return ORIGINAL_API(GetModuleFileNameA)(
                            hModule,
                            lpFilename,
                            nSize);

    } 
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetModuleFileNameA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatefindhandles.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   EmulateFindHandles.cpp

 Abstract:

    If an application calls FindFirstFile on a directory, then attempts to 
    remove that directory without first closing the FindFirstFile handle, the 
    directory will be in use; The RemoveDirectory call will return an 
    ERROR_SHARING_VIOLATION error.  This shim will force the FindFirstFile 
    handle closed to ensure the directory is removed.

    This shim also ensures the FindFirstFile handles are valid before calling
    FindNext or FindClose.

    The FindFirstFile handle will not be forced closed unless the directory
    is empty.

 History:

    04/12/2000  robkenny    Created
    11/13/2000  robkenny    Fixed PREFIX bugs, mostly by removing the W routines.
    11/20/2000  maonis      Added FindNextFile and renamed from RemoveDirectoryInUse.
    02/27/2001  robkenny    Converted to use CString
    04/26/2001  robkenny    FindFileInfo now normalizes the names for comparisons
                            Moved all AutoLockFFIV outside of the exception handlers
                            to ensure they are deconstructed correctly.

--*/

#include "precomp.h"

#include "CharVector.h"
#include "parseDDE.h"

IMPLEMENT_SHIM_BEGIN(EmulateFindHandles)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileExA)
    APIHOOK_ENUM_ENTRY(FindNextFileA)
    APIHOOK_ENUM_ENTRY(FindClose)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(DdeClientTransaction)
APIHOOK_ENUM_END

BOOL g_bHookDDE = TRUE; // default to hooking DDE

//---------------------------------------------------------------------------
// A class that automatically locks/unlocks the FFIV
class AutoLockFFIV
{
public:
    AutoLockFFIV();
    ~AutoLockFFIV();
};

//---------------------------------------------------------------------------
/*++

    HANDLE Vector type class.

--*/
class FindFileInfo
{
public:
    HANDLE             m_hFindHandle;
    CString            m_csFindName;

    FindFileInfo(HANDLE findHandle, LPCSTR lpFileName)
    {
        Init(findHandle, lpFileName);
    }

    // Convert csFileName into a fully qualified, long path to the *directory*
    // c:\Program Files\Some App\*.exe      should get changed to c:\Program Files\Some App
    // c:\Progra~1\Some~1\*.exe             should get changed to c:\Program Files\Some App
    // .\*.exe                              should get changed to c:\Program Files\Some App
    // *.exe                                should get changed to *.exe
    static void NormalizeName(CString & csFileName)
    {
        DWORD dwAttr = GetFileAttributesW(csFileName);
        if (dwAttr == -1)
        {
            CString csDirPart;
            csFileName.GetNotLastPathComponent(csDirPart);
            csFileName = csDirPart;
        }
    
        csFileName.GetFullPathName();
        csFileName.GetLongPathName();
    }
    // Init the values, we store the full path for safe compares
    void Init(HANDLE findHandle, LPCSTR lpFileName)
    {
        m_hFindHandle = findHandle;
        m_csFindName = lpFileName;

        NormalizeName(m_csFindName);
    }

    bool operator == (HANDLE findHandle) const
    {
        return findHandle == m_hFindHandle;
    }

    // Only compare up to the length of lpFileName
    bool operator == (LPCSTR lpFileName) const
    {
        // We need to convert lpFileName the same way as done in Init()
        CString csFileName(lpFileName);
        NormalizeName(csFileName);

        return m_csFindName.CompareNoCase(csFileName) == 0;
    }
};

class FindFileInfoVector : public VectorT<FindFileInfo *>
{
protected:
    static FindFileInfoVector * g_TheHandleVector;
    CRITICAL_SECTION            m_Lock;

public:
    FindFileInfoVector()
    {
        InitializeCriticalSection(&m_Lock);
    }

    void Lock()
    {
        EnterCriticalSection(&m_Lock);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_Lock);
    }

    // Search through the list of open FindFirstFile handles for a match to hMember
    FindFileInfo * Find(HANDLE hMember)
    {
        if (hMember != INVALID_HANDLE_VALUE)
        {
            DPF(g_szModuleName,
                eDbgLevelSpew,
                "FindFileInfoVector::Find(0x%08x)\n",
                hMember);
            for (int i = 0; i < Size(); ++i)
            {
                FindFileInfo * ffi = Get(i);
                if (*ffi == hMember)
                {
                    DPF(g_szModuleName,
                        eDbgLevelSpew,
                        "FindFileInfoVector: FOUND handle 0x%08x (%S)\n",
                        ffi->m_hFindHandle, ffi->m_csFindName.Get());
                    return ffi;
                }
            }
        }
        return NULL;
    }

    // Search through the list of open FindFirstFile handles for a match to lpFileName
    FindFileInfo * Find(LPCSTR lpFileName)
    {
        if (lpFileName != NULL)
        {
            DPF(g_szModuleName,
                eDbgLevelSpew,
                "FindFileInfoVector::Find(%s)\n",
                lpFileName);
            for (int i = 0; i < Size(); ++i)
            {
                FindFileInfo * ffi = Get(i);
                if (*ffi == lpFileName)
                {
                    DPF(g_szModuleName,
                        eDbgLevelSpew,
                        "FindFileInfoVector: FOUND handle 0x%08x (%S)\n",
                        ffi->m_hFindHandle, ffi->m_csFindName.Get());
                    return ffi;
                }
#if 0
                else
                {
                    DPF(g_szModuleName,
                        eDbgLevelSpew,
                        "FindFileInfoVector: NOT FOUND handle 0x%08x (%S)\n",
                        ffi.m_hFindHandle, ffi.m_csFindName.Get());
                }

#endif
            }
        }
        return NULL;
    }

    // Remove the FindFileInfo,
    // return true if the handle was actually removed.
    bool Remove(FindFileInfo * ffi)
    {
        for (int i = 0; i < Size(); ++i)
        {
            if (Get(i) == ffi)
            {
                DPF(g_szModuleName,
                    eDbgLevelSpew,
                    "FindFileInfoVector: REMOVED handle 0x%08x (%S)\n",
                    ffi->m_hFindHandle, ffi->m_csFindName.Get());

                // Remove the entry by copying the last entry over this index

                // Only move if this is not the last entry.
                if (i < Size() - 1)
                {
                    CopyElement(i, Get(Size() - 1));
                }
                nVectorList -= 1;
            }
        }
        return false;
    }

    // Return a pointer to the global FindFileInfoVector
    static FindFileInfoVector * GetHandleVector()
    {
        if (g_TheHandleVector == NULL)
        {
            g_TheHandleVector = new FindFileInfoVector;
        }
        return g_TheHandleVector;
    }
};

FindFileInfoVector * FindFileInfoVector::g_TheHandleVector = NULL;
FindFileInfoVector * OpenFindFileHandles;

AutoLockFFIV::AutoLockFFIV()
{
    FindFileInfoVector::GetHandleVector()->Lock();
}
AutoLockFFIV::~AutoLockFFIV()
{
    FindFileInfoVector::GetHandleVector()->Unlock();
}

//---------------------------------------------------------------------------

/*++
    Call FindFirstFileA, if it fails because the file doesn't exist,
    correct the file path and try again.
--*/
HANDLE 
APIHOOK(FindFirstFileA)(
  LPCSTR lpFileName,               // file name
  LPWIN32_FIND_DATAA lpFindFileData  // data buffer
)
{
    HANDLE returnValue = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

    if (returnValue != INVALID_HANDLE_VALUE)
    {
        DPF(g_szModuleName,
            eDbgLevelSpew,
            "FindFirstFileA: adding   handle 0x%08x (%s)\n",
            returnValue, lpFileName);

        AutoLockFFIV lock;
        CSTRING_TRY
        {
            // Save the handle for later.
            FindFileInfo *ffi = new FindFileInfo(returnValue, lpFileName);
            FindFileInfoVector::GetHandleVector()->Append(ffi);
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return returnValue;
}

/*++

 Add the file handle to our list.

--*/

HANDLE
APIHOOK(FindFirstFileExA)(
    LPCSTR lpFileName,     
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,  
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,  
    DWORD dwAdditionalFlags 
    )
{
    HANDLE returnValue = ORIGINAL_API(FindFirstFileExA)(
                        lpFileName, 
                        fInfoLevelId,
                        lpFindFileData,
                        fSearchOp,
                        lpSearchFilter,
                        dwAdditionalFlags);

    if (returnValue != INVALID_HANDLE_VALUE)
    {
        DPF(g_szModuleName,
            eDbgLevelSpew,
            "FindFirstFileA: adding   handle 0x%08x (%s)\n",
            returnValue, lpFileName);

        AutoLockFFIV lock;
        CSTRING_TRY
        {
            // Save the handle for later.
            FindFileInfo *ffi = new FindFileInfo(returnValue, lpFileName);
            FindFileInfoVector::GetHandleVector()->Append(ffi);
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return returnValue;
}

/*++

 Validates the FindFirstFile handle before calling FindNextFileA.
 
--*/
BOOL 
APIHOOK(FindNextFileA)(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    BOOL returnValue = FALSE;

    AutoLockFFIV lock;
    CSTRING_TRY
    {
        // Only call FindNextFileA if the handle is actually open
        FindFileInfo * ffi = FindFileInfoVector::GetHandleVector()->Find(hFindFile);
        if (ffi)
        {
            returnValue = ORIGINAL_API(FindNextFileA)(hFindFile, lpFindFileData);

            DPF(g_szModuleName,
            eDbgLevelSpew,
            "FindNextFile: using handle 0x%08x (%ls)\n",
            hFindFile, ffi->m_csFindName.Get());
        }
    }
    CSTRING_CATCH
    {
        returnValue = ORIGINAL_API(FindNextFileA)(hFindFile, lpFindFileData);
    }

    return returnValue;
}

/*++

 Remove the file handle to our list.
 
--*/
BOOL 
APIHOOK(FindClose)(
  HANDLE hFindFile   // file search handle
)
{
    BOOL returnValue = FALSE;

    AutoLockFFIV lock;
    CSTRING_TRY
    {
        // Only call FindClose if the handle is actually open
        FindFileInfo * ffi = FindFileInfoVector::GetHandleVector()->Find(hFindFile);
        if (ffi)
        {
            returnValue = ORIGINAL_API(FindClose)(hFindFile);

            DPF(g_szModuleName,
            eDbgLevelSpew,
            "FindClose: removing   handle 0x%08x (%S)\n",
            hFindFile, ffi->m_csFindName.Get());

            // Remove this entry from the list of open FindFirstFile handles.
            FindFileInfoVector::GetHandleVector()->Remove(ffi);
        }
    }
    CSTRING_CATCH
    {
        returnValue = ORIGINAL_API(FindClose)(hFindFile);
    }

    return returnValue;
}



/*++
    Call RemoveDirectoryA, if it fails because the directory is in use,
    make sure all FindFirstFile handles are closed, then try again.
--*/

BOOL 
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpFileName   // directory name
    )
{
    FindFileInfo * ffi;

    BOOL returnValue = ORIGINAL_API(RemoveDirectoryA)(lpFileName);
    if (!returnValue)
    {
        AutoLockFFIV lock;

        CSTRING_TRY
        {
            DWORD dwLastError = GetLastError();
    
            // NOTE:
            // ERROR_DIR_NOT_EMPTY error takes precedence over ERROR_SHARING_VIOLATION,
            // so we will not forcably to free the FindFirstFile handles unless the directory is empty.
    
            // If the directory is in use, check to see if the app left a FindFirstFileHandle open.
            if (dwLastError == ERROR_SHARING_VIOLATION)
            {
                // Close all FindFirstFile handles open to this directory.
                while(ffi = FindFileInfoVector::GetHandleVector()->Find(lpFileName))
                {
                    DPF(g_szModuleName,
                        eDbgLevelError,
                        "[RemoveDirectoryA] Forcing closed FindFirstFile (%S).",
                        ffi->m_csFindName.Get());
                    
                    // Calling FindClose here would not, typically, get hooked, so we call
                    // our hook routine directly to ensure we close the handle and remove it from the list
                    // If we don't remove it from the list we'll never get out of this loop :-)
                    APIHOOK(FindClose)(ffi->m_hFindHandle);
                }
    
                // Last chance
                returnValue = ORIGINAL_API(RemoveDirectoryA)(lpFileName);
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return returnValue;
}

// A list of DDE commands that we are interested in.
const char * c_sDDECommands[] =
{
    "DeleteGroup",
    NULL,
} ;

// Parse the DDE Command looking for DeleteGroup,
// If the command is found, make sure that we do not have any open FindFirstFile handles
// on that directory.
// This needs to be aware of "User"  vs.  "All Users" syntax of DDE
void CloseHandleIfDeleteGroup(LPBYTE pData)
{
    if (pData)
    {
        // Now we need to parse the string, looking for a DeleteGroup command
        // Format "[DeleteGroup(GroupName, CommonGroupFlag)]"
        // CommonGroupFlag is optional

        char * pszBuf = StringDuplicateA((const char *)pData);
        if (!pszBuf)
            return;

        UINT * lpwCmd = GetDDECommands(pszBuf, c_sDDECommands, FALSE);
        if (lpwCmd)
        {
            // Store off lpwCmd so we can free the correect addr later
            UINT *lpwCmdTemp = lpwCmd;

            // Execute a command.
            while (*lpwCmd != (UINT)-1)
            {
                UINT wCmd = *lpwCmd++;
                // Subtract 1 to account for the terminating NULL
                if (wCmd < ARRAYSIZE(c_sDDECommands)-1)
                {

                    // We found a command--it must be DeleteGroup--since there is only 1

                    BOOL iCommonGroup = -1;

                    // From DDE_DeleteGroup
                    if (*lpwCmd < 1 || *lpwCmd > 3)
                    {
                        goto Leave;
                    }
                    if (*lpwCmd == 2)
                    {
                        //
                        // Need to check for common group flag
                        //
                        if (pszBuf[*(lpwCmd + 2)] == TEXT('1')) {
                            iCommonGroup = 1;
                        } else {
                            iCommonGroup = 0;
                        }
                    }
                    const char * groupName = pszBuf + lpwCmd[1];

                    // Build a path to the directory
                    CHAR  szGroupName[MAX_PATH];
                    GetGroupPath(groupName, szGroupName, 0, iCommonGroup);

                    AutoLockFFIV lock;

                    CSTRING_TRY
                    {
                        // Attempt to delete the directory, since we are calling our hooked
                        // routine, it will detect if the directory is in use and do the dirty work.
    
                        // Close all FindFirstFile handles open to this directory.
                        FindFileInfo * ffi;
    
                        while( ffi = FindFileInfoVector::GetHandleVector()->Find(szGroupName))
                        {
                            DPF(g_szModuleName,
                                eDbgLevelError,
                                "[DdeClientTransaction] %s Forcing closed FindFirstFile (%S).",
                                pData, ffi->m_csFindName.Get());
                            // Calling FindClose here would not, typically, get hooked, so we call
                            // our hook routine directly to ensure we close the handle and remove it from the list
                            // If we don't remove it from the list we'll never get out of this loop :-)
                            APIHOOK(FindClose)(ffi->m_hFindHandle);
                        }
                    }
                    CSTRING_CATCH
                    {
                        // Do nothing
                    }
                }

                // Next command.
                lpwCmd += *lpwCmd + 1;
            }

    Leave:
            // Tidyup...
            GlobalFree(lpwCmdTemp);
        }

        free(pszBuf);
    }
}
//==============================================================================
//==============================================================================

HDDEDATA 
APIHOOK(DdeClientTransaction)( IN LPBYTE pData, IN DWORD cbData,
        IN HCONV hConv, IN HSZ hszItem, IN UINT wFmt, IN UINT wType,
        IN DWORD dwTimeout, OUT LPDWORD pdwResult)
{
#if 0
    // Allow a longer timeout for debugging purposes.
    dwTimeout = 0x0fffffff;
#endif

    CloseHandleIfDeleteGroup(pData);

    HDDEDATA returnValue = ORIGINAL_API(DdeClientTransaction)(
                        pData,
                        cbData,
                        hConv, 
                        hszItem, 
                        wFmt, 
                        wType,
                        dwTimeout, 
                        pdwResult);

    return returnValue;
}

/*++

    Parse the command line, looking for the -noDDE switch

--*/
void ParseCommandLine(const char * commandLine)
{
    CString csCL(commandLine);

    // if (-noDDE) then g_bHookDDE = FALSE;
    g_bHookDDE = csCL.CompareNoCase(L"-noDDE") != 0;
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        // This forces the allocation of the array:
        FindFileInfoVector * ffiv = FindFileInfoVector::GetHandleVector();

        ParseCommandLine(COMMAND_LINE);

        return ffiv != NULL;
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindClose)
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryA)
    if (g_bHookDDE)
    {
        APIHOOK_ENTRY(USER32.DLL, DdeClientTransaction)
    }

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulategetprofilestring.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateGetProfileString.cpp

 Abstract:

    GetPrivateProfileString no longer stops parsing at a space or tab 
    character. When users leave what used to be comments on the tail of the 
    string the comments are now passed to the app resulting in errors.

 Notes:

    This is a general purpose shim

 History:

    12/30/1999 a-chcoff Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetProfileString)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA)
APIHOOK_ENUM_END


/*++

 This stub function cleans up when users leave what used to be comments on 
 the tail of the string the comments were passed to the app resulting in 
 errors.  Now the string is terminated before the comments therefore 
 alleviating the errors.

--*/

DWORD 
APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR  lpReturnedString,
    DWORD  nSize,
    LPCSTR lpFileName
    )
{
    DWORD dwRet;

    char* pTemp1 = (char*)lpReturnedString;
    char* pTemp2 = (char*)lpReturnedString;

    //
    //  First just go get the string.
    //
    dwRet = ORIGINAL_API(GetPrivateProfileStringA)(
                            lpAppName, 
                            lpKeyName, 
                            lpDefault, 
                            lpReturnedString, 
                            nSize,
                            lpFileName);

    //
    // Look for comment.
    //
    while (*pTemp1 != ';' && *pTemp1) {
        pTemp1++;
    }

    if ((pTemp1 != pTemp2) && *pTemp1) {        
        LOGN(
            eDbgLevelError,
            "[GetPrivateProfileStringA] Comment after data in file \"%s\". Eliminated.",
            lpFileName);
        
        //
        // Did not make it to end of line better trim it
        // back up to ';' char
        pTemp1--;                               

        //
        // Back up past interposing whitespace.
        //
        while ((*pTemp1==' ') || (*pTemp1=='\t')) {   
           pTemp1--;                            
        }

        pTemp1++;

        //
        // Set new length.
        //
        dwRet = (DWORD)((ULONG_PTR)pTemp1 - (ULONG_PTR)pTemp2); 

        //
        // and NULL term string
        //
        *pTemp1 = '\0';                                   
    }
        
    return dwRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStringA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulategetdevicecaps.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateGetDeviceCaps.cpp

 Abstract:

    Fix known incompatibilities in GetDeviceCaps.     

    Currently we know of:

        1. NUMRESERVED always returns 20 on NT, but on win9x returns 0 in non-
           palettized modes. This was considered too great a regression risk to
           change the behavior of NT.

 Notes:

    This is a general purpose shim.

    (t-adams) MSDN states that along with NUMRESERVED, both SIZEPALETTE and 
    COLORRES are valid only if the display is in paletted mode.  I've 
    experimentally determined that SIZEPALETTE always returns 0 in non-paletted 
    modes, and that COLORRES seems to follow BITSPIXEL.  These behaviors don't 
    seem like they will present any problems since SIZEPALETTE * COLORRES will 
    be 0.

 History:
        
    02/17/2000 linstev  Created
    09/13/2000 t-adams  Added to Notes

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetDeviceCaps)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetDeviceCaps)
APIHOOK_ENUM_END

/*++

 Check for known problems.

--*/

int 
APIHOOK(GetDeviceCaps)(
    HDC hdc,     
    int nIndex   
    )
{
    int iRet = ORIGINAL_API(GetDeviceCaps)(hdc, nIndex);

    switch (nIndex) 
    {
    case NUMRESERVED:
        if (ORIGINAL_API(GetDeviceCaps)(hdc, BITSPIXEL) > 8) {
            iRet = 0;
        }
    }

    return iRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, GetDeviceCaps)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateheap.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateHeap.cpp

 Abstract:
     
    This SHIM is for the layer and it emulates the Win9x heap manager. In fact, 
    much of the code is adapted from the Win9x sources .\heap.c and .\lmem.c.
    
    This SHIM hooks all the heap allocation/deallocation functions including 
    the local/global functions.
     
 Notes:

    This is a general purpose shim.

 History:
           
    11/16/2000 prashkud & linstev Created 
   
--*/

#include "precomp.h"
 
IMPLEMENT_SHIM_BEGIN(EmulateHeap)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(HeapCreate)
    APIHOOK_ENUM_ENTRY(HeapDestroy)
    APIHOOK_ENUM_ENTRY(HeapValidate)
    APIHOOK_ENUM_ENTRY(HeapCompact)
    APIHOOK_ENUM_ENTRY(HeapWalk)
    APIHOOK_ENUM_ENTRY(HeapLock)
    APIHOOK_ENUM_ENTRY(HeapUnlock)
    APIHOOK_ENUM_ENTRY(GetProcessHeap)

    APIHOOK_ENUM_ENTRY(LocalAlloc)
    APIHOOK_ENUM_ENTRY(LocalFree)
    APIHOOK_ENUM_ENTRY(LocalReAlloc)
    APIHOOK_ENUM_ENTRY(LocalLock)
    APIHOOK_ENUM_ENTRY(LocalUnlock)
    APIHOOK_ENUM_ENTRY(LocalHandle)
    APIHOOK_ENUM_ENTRY(LocalSize)
    APIHOOK_ENUM_ENTRY(LocalFlags)

    APIHOOK_ENUM_ENTRY(GlobalAlloc)
    APIHOOK_ENUM_ENTRY(GlobalFree)
    APIHOOK_ENUM_ENTRY(GlobalReAlloc)
    APIHOOK_ENUM_ENTRY(GlobalLock)
    APIHOOK_ENUM_ENTRY(GlobalUnlock)
    APIHOOK_ENUM_ENTRY(GlobalHandle)
    APIHOOK_ENUM_ENTRY(GlobalSize)
    APIHOOK_ENUM_ENTRY(GlobalFlags)

    APIHOOK_ENUM_ENTRY(RtlAllocateHeap)
    APIHOOK_ENUM_ENTRY(RtlReAllocateHeap)
    APIHOOK_ENUM_ENTRY(RtlFreeHeap)
    APIHOOK_ENUM_ENTRY(RtlSizeHeap)
APIHOOK_ENUM_END

extern "C" {
BOOL   _HeapInit();
HANDLE _HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
BOOL   _HeapDestroy(HANDLE hHeap);
LPVOID _HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
LPVOID _HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
BOOL   _HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
DWORD  _HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
HLOCAL APIENTRY _LocalAlloc(UINT dwFlags, UINT dwBytes);
HLOCAL APIENTRY _LocalFree(HLOCAL hMem);
LPVOID _LocalReAlloc(LPVOID lpMem, SIZE_T dwBytes, UINT uFlags);
LPVOID _LocalLock(HLOCAL hMem);
BOOL   _LocalUnlock(HLOCAL hMem);
HANDLE _LocalHandle(LPCVOID hMem);
UINT   _LocalSize(HLOCAL hMem);
UINT   _LocalFlags(HLOCAL hMem);
HANDLE _GetProcessHeap(void);
BOOL   _IsOurHeap(HANDLE hHeap);
BOOL   _IsOurLocalHeap(HANDLE hMem);
BOOL   _IsOnOurHeap(LPCVOID lpMem);
}

/*++

  Helper functions so as not to bloat the stubs.

--*/

BOOL UseOurHeap(HANDLE hHeap, LPCVOID lpMem)
{
    return (_IsOurHeap(hHeap) || ((hHeap == RtlProcessHeap()) && _IsOnOurHeap(lpMem)));
}

BOOL ValidateNTHeap(HANDLE hHeap, LPCVOID lpMem)
{
    BOOL bRet = FALSE;
    __try
    {
        bRet = ORIGINAL_API(HeapValidate)(hHeap, 0, lpMem);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        LOGN( eDbgLevelError, "[ValidateHeap] %08lx:%08lx is invalid", hHeap, lpMem);
    }

    return bRet;
}

/*++

  Stub APIs.

--*/

LPVOID 
APIHOOK(RtlAllocateHeap)(
    HANDLE hHeap,
    DWORD dwFlags,     
    SIZE_T dwBytes
    )
{
    if (_IsOurHeap(hHeap))
    {
        return _HeapAlloc(hHeap, dwFlags, dwBytes);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: RtlAllocateHeap");
        return ORIGINAL_API(RtlAllocateHeap)(hHeap, dwFlags, dwBytes);
    }
}

HANDLE 
APIHOOK(HeapCreate)(
    DWORD flOptions,
    SIZE_T dwInitialSize,
    SIZE_T dwMaximumSize
    )
{
    return _HeapCreate(flOptions, dwInitialSize, dwMaximumSize);
}

LPVOID 
APIHOOK(RtlReAllocateHeap)(
    HANDLE hHeap, 
    DWORD dwFlags,     
    LPVOID lpMem,
    SIZE_T dwBytes
    )
{
    LPVOID uRet = FALSE;

    if (UseOurHeap(hHeap, lpMem))
    {
        uRet = _HeapReAlloc(hHeap, dwFlags, lpMem, dwBytes);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: RtlReAllocateHeap");

        if (ValidateNTHeap(hHeap, lpMem))
        {
            uRet = ORIGINAL_API(RtlReAllocateHeap)(hHeap, dwFlags, lpMem, dwBytes);
        }
    }
    return uRet;
}

BOOL 
APIHOOK(RtlFreeHeap)(
    HANDLE hHeap,
    DWORD dwFlags,    
    LPVOID lpMem
    )
{
    BOOL bRet = FALSE;

    if (UseOurHeap(hHeap, lpMem))
    {
        bRet = _HeapFree(hHeap, dwFlags, lpMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: RtlFreeHeap");

        if (ValidateNTHeap(hHeap, lpMem))
        {
            bRet = ORIGINAL_API(RtlFreeHeap)(hHeap, dwFlags, lpMem);
        }
    }
    return bRet;
}

HANDLE 
APIHOOK(GetProcessHeap)(VOID)
{
    return _GetProcessHeap();
}
 
BOOL 
APIHOOK(HeapDestroy)(HANDLE hHeap)
{
    if (_IsOurHeap(hHeap))
    {
        return _HeapDestroy(hHeap);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: HeapDestroy");
        return ORIGINAL_API(HeapDestroy)(hHeap);
    }
}

DWORD
APIHOOK(RtlSizeHeap)(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    )
{  
    BOOL bRet = FALSE;

    if (UseOurHeap(hHeap, lpMem))
    {
        bRet = _HeapSize(hHeap, dwFlags, lpMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: RtlSizeHeap");

        if (ValidateNTHeap(hHeap, lpMem))
        {
            bRet = ORIGINAL_API(RtlSizeHeap)(hHeap, dwFlags, lpMem);
        }        
    }

    return bRet;
}

BOOL
APIHOOK(HeapValidate)(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    )
{
    BOOL bRet = FALSE;

    if (UseOurHeap(hHeap, lpMem))
    {
        // Win9x return values
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        bRet = -1;
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: HeapValidate");

        __try
        {
            bRet = ORIGINAL_API(HeapValidate)(hHeap, dwFlags, lpMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError, "[HeapValidate] %08lx:%08lx is invalid", hHeap, lpMem);
        }
    }
   return bRet;
}

HLOCAL 
APIHOOK(LocalAlloc)(
    UINT uFlags,
    SIZE_T uBytes
    )
{
    return _LocalAlloc(uFlags, uBytes);
}

HLOCAL
APIHOOK(LocalFree)(
    HLOCAL hMem
    )
{
    HLOCAL hRet = NULL;

    if (_IsOurLocalHeap(hMem))
    {
        hRet = _LocalFree(hMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalFree %08lx", hMem);
        __try
        {
            hRet = ORIGINAL_API(LocalFree)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalFree] Exception: Invalid Pointer %08lx", hMem);
        }       
    }

    return hRet;
}

HLOCAL 
APIHOOK(LocalReAlloc)(
    HLOCAL hMem,
    SIZE_T uBytes,
    UINT uFlags
    )
{
    HLOCAL hRet = NULL;

    if (_IsOurLocalHeap(hMem))
    {
         hRet = _LocalReAlloc(hMem, uBytes, uFlags);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalReAlloc %08lx", hMem);
        
        __try
        {
            hRet = ORIGINAL_API(LocalReAlloc)(hMem, uBytes, uFlags);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalReAlloc] Exception: Invalid Pointer %08lx", hMem);
        }              
    }

    return hRet;
}

LPVOID
APIHOOK(LocalLock)(
    HLOCAL hMem
    )
{
    LPVOID pRet = NULL;

    if (_IsOurLocalHeap(hMem))
    {
         pRet = _LocalLock(hMem);
    }
    else    
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalLock %08lx", hMem);

        __try
        {
            pRet = ORIGINAL_API(LocalLock)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalLock] Exception: Invalid Pointer %08lx", hMem);
        }                      
    }

    return pRet;
}

BOOL
APIHOOK(LocalUnlock)(
    HLOCAL hMem
    )
{
    BOOL bRet = FALSE;

    if (_IsOurLocalHeap(hMem))
    {
         bRet = _LocalUnlock(hMem);
    }
    else    
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalUnlock %08lx", hMem);

        __try
        {
            bRet = ORIGINAL_API(LocalUnlock)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalUnLock] Exception: Invalid Pointer %08lx", hMem);
        }                          
    }

    return bRet;
}

HANDLE
APIHOOK(LocalHandle)(
    LPCVOID hMem
    )
{
    HANDLE hRet = NULL;

    if (_IsOurLocalHeap((HANDLE)hMem))
    {
         hRet = _LocalHandle(hMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalHandle %08lx", hMem);
        __try
        {
            hRet = ORIGINAL_API(LocalHandle)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalHandle] Exception: Invalid Pointer %08lx", hMem);
        }                                  
    }

    return hRet;
}

UINT
APIHOOK(LocalSize)(
    HLOCAL hMem
    )
{
    UINT uRet = 0;

    if (_IsOurLocalHeap(hMem))
    {
         uRet = _LocalSize(hMem);
    }
    else    
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalSize %08lx", hMem);
        __try
        {
            uRet = ORIGINAL_API(LocalSize)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalSize] Exception: Invalid Pointer %08lx", hMem);
        }                   
    }

    return uRet;
}

UINT
APIHOOK(LocalFlags)(
    HLOCAL hMem
    )
{
    UINT uRet = 0;

    if (_IsOurLocalHeap(hMem))
    {
        uRet = _LocalFlags(hMem);
    }
    else    
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalFlags %08lx", hMem);

        __try
        {
            uRet = ORIGINAL_API(LocalFlags)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalFlags] Exception: Invalid Pointer %08lx", hMem);
        }                  
    }

    return uRet;
}

HGLOBAL 
APIHOOK(GlobalAlloc)(
    UINT uFlags,
    SIZE_T uBytes
    )
{
    uFlags = (((uFlags & GMEM_ZEROINIT) ? LMEM_ZEROINIT : 0 ) |
              ((uFlags & GMEM_MOVEABLE) ? LMEM_MOVEABLE : 0 ) |
              ((uFlags & GMEM_FIXED) ? LMEM_FIXED : 0 ));

    return _LocalAlloc(uFlags, uBytes);
}

HGLOBAL
APIHOOK(GlobalFree)(
    HGLOBAL hMem
    )
{
    HGLOBAL hRet = NULL;

    if (_IsOurLocalHeap(hMem))
    {
         hRet = _LocalFree(hMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalFree %08lx", hMem);

        __try
        {
            hRet = ORIGINAL_API(GlobalFree)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalFree] Exception: Invalid Pointer %08lx", hMem);
        }               
    }

    return hRet;
}

HGLOBAL 
APIHOOK(GlobalReAlloc)(
    HGLOBAL hMem,
    SIZE_T uBytes,
    UINT uFlags
    )
{
    UINT uLocalFlags = 
        (((uFlags & GMEM_ZEROINIT) ? LMEM_ZEROINIT : 0 ) |
        ((uFlags & GMEM_MOVEABLE) ? LMEM_MOVEABLE : 0 ) |
        ((uFlags & GMEM_FIXED) ? LMEM_FIXED : 0 ));

    HLOCAL hRet = NULL;

    if (_IsOurLocalHeap(hMem))
    {
        hRet = _LocalReAlloc(hMem, uBytes, uLocalFlags);
    }    
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalReAlloc %08lx", hMem);

        __try
        {
            hRet = ORIGINAL_API(GlobalReAlloc)(hMem, uBytes, uFlags);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalReAlloc] Exception: Invalid Pointer %08lx", hMem);
        }                       
    }

    return hRet;
}

LPVOID
APIHOOK(GlobalLock)(
    HGLOBAL hMem
    )
{
    LPVOID pRet = NULL;

    if (_IsOurLocalHeap(hMem))
    {
        pRet = _LocalLock(hMem);
    }
    else    
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalLock %08lx", hMem);
        
        __try
        {
            pRet = ORIGINAL_API(GlobalLock)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalLock] Exception: Invalid Pointer %08lx", hMem);
        }                          
    }

    return pRet;
}

BOOL
APIHOOK(GlobalUnlock)(
    HGLOBAL hMem
    )
{
    BOOL bRet = FALSE;

    if (_IsOurLocalHeap(hMem))
    {
        bRet = _LocalUnlock(hMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalUnlock %08lx", hMem);

        __try
        {
            bRet = ORIGINAL_API(GlobalUnlock)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalUnLock] Exception: Invalid Pointer %08lx", hMem);
        }            
    }

    return bRet;
}

HANDLE
APIHOOK(GlobalHandle)(
    LPCVOID hMem
    )
{
    HANDLE hRet = NULL;

    if (_IsOurLocalHeap((HANDLE)hMem))
    {
         hRet = _LocalHandle(hMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalHandle %08lx", hMem);
        __try
        {
            hRet = ORIGINAL_API(GlobalHandle)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalHandle] Exception: Invalid Pointer %08lx for Heap",
                hMem);
        }                    
    }

    return hRet;
}

UINT
APIHOOK(GlobalSize)(
    HGLOBAL hMem
    )
{
    UINT uRet = 0;

    if (_IsOurLocalHeap(hMem))
    {
        uRet = _LocalSize(hMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalSize %08lx", hMem);
        __try
        {
            uRet = ORIGINAL_API(GlobalSize)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalSize] Exception: Invalid Pointer %08lx for Heap",
                hMem);
        }            
    }

    return uRet;
}

UINT
APIHOOK(GlobalFlags)(
    HGLOBAL hMem
    )
{
    UINT uRet = 0;

    if (_IsOurLocalHeap(hMem))
    {
        uRet = _LocalFlags(hMem);
        // Convert the flags
        UINT uNewRet = uRet;

        uRet = 0;

        if (uNewRet & LMEM_DISCARDABLE)
        {
            uRet |= GMEM_DISCARDABLE;
        }

        if (uNewRet & LMEM_DISCARDED)
        {
            uRet |= GMEM_DISCARDED;
        }

    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalFlags %08lx", hMem);
        __try
        {
            uRet = ORIGINAL_API(GlobalFlags)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalFlags] Exception: Invalid Pointer %08lx for Heap",
                hMem);
        }           
    }

    return uRet;
}

UINT
APIHOOK(HeapCompact)(
    HANDLE hHeap,
    DWORD dwFlags
    )
{
   if (_IsOurHeap(hHeap))
   {
        // Win9x return values
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return 0;
   }
   else
   {
        DPFN( eDbgLevelInfo, "NTHEAP: HeapCompact");
        return ORIGINAL_API(HeapCompact)(hHeap, dwFlags);
   }
}

BOOL
APIHOOK(HeapWalk)(
    HANDLE hHeap,
    LPPROCESS_HEAP_ENTRY pEntry
    )
{
   if (_IsOurHeap(hHeap))
   {
        // Win9x return values
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return 0;
   }
   else
   {
        DPFN( eDbgLevelInfo, "NTHEAP: HeapWalk");
        return ORIGINAL_API(HeapWalk)(hHeap, pEntry);
   }
}

BOOL
APIHOOK(HeapLock)(
    HANDLE hHeap
    )
{
   if (_IsOurHeap(hHeap))
   {
        // Win9x return values
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return 0;
   }
   else
   {
        DPFN( eDbgLevelInfo, "NTHEAP: HeapLock");
        return ORIGINAL_API(HeapLock)(hHeap);
   }
}

BOOL
APIHOOK(HeapUnlock)(
    HANDLE hHeap
    )
{
   if (_IsOurHeap(hHeap))
   {
        // Win9x return values
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return 0;
   }
   else
   {
        DPFN( eDbgLevelInfo, "NTHEAP: HeapUnlock");
        return ORIGINAL_API(HeapUnlock)(hHeap);
   }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    BOOL bRet = TRUE;
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        bRet = _HeapInit();
        if (bRet) 
        {
            LOGN(eDbgLevelInfo, "[NotifyFn] Win9x heap manager initialized");
        }
        else
        {
            LOGN(eDbgLevelError, "[NotifyFn] Win9x heap manager initialization failed!");
        }
    }

    return bRet;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, HeapCreate)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapDestroy)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapValidate)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapCompact)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapWalk)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapLock)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapUnlock)
    APIHOOK_ENTRY(KERNEL32.DLL, GetProcessHeap)

    APIHOOK_ENTRY(KERNEL32.DLL, LocalAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalFree)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalReAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalLock)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalUnlock)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalHandle)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalSize)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalFlags)

    APIHOOK_ENTRY(KERNEL32.DLL, GlobalAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalFree)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalReAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalLock)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalUnlock)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalHandle)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalSize)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalFlags)

    APIHOOK_ENTRY(NTDLL.DLL, RtlAllocateHeap)
    APIHOOK_ENTRY(NTDLL.DLL, RtlReAllocateHeap)
    APIHOOK_ENTRY(NTDLL.DLL, RtlFreeHeap)
    APIHOOK_ENTRY(NTDLL.DLL, RtlSizeHeap)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateheap_heap.c ===
/***	HEAP.C
 *
 *      (C) Copyright Microsoft Corp., 1988-1994
 *
 *      Heap management
 *
 *	If you are having trouble getting errors from this code, you might
 *	want to try setting one of the following variables to non-zero:
 *
 *		mmfErrorStop - enables stopping whenever there is an
 *			error returned from a memory manager function
 *
 *		hpfWalk - enables some verification of the entire heap when
 *			coming into heap functions.  Enabling heap walking
 *			can dramatically slow down heap functions
 *			but system-wide performance doesn't change too much.
 *
 *		hpfParanoid - enables even more checking during heap walking
 *			(hpfWalk must also be set) and enables heap walking
 *			coming in and out of every heap call.
 *
 *		hpfTrashStop - enables stopping in the debugger whenever
 *			we detect a trashed heap block during hpfWalk
 *			and it attempts to print the trashed address
 *
 *  Origin: Chicago
 *
 *  Change history:
 *
 *  Date       Who        Description
 *  ---------  ---------  -------------------------------------------------
 *  ?/91       BrianSm	  Created
 *  3/94       BrianSm	  Added heaps that can grow beyond initial max size
 *  6/94       BrianSm	  Decommit pages within free heap blocks
 */
#ifdef WIN32
#include <EmulateHeap_kernel32.h>
#endif

#pragma hdrstop("kernel32.pch")

#ifndef WIN32

#include <basedef.h>
#include <winerror.h>
#include <vmmsys.h>
#include <mmlocal.h>
#include <sched.h>
#include <thrdsys.h>
#include <schedsys.h>
#include <schedc.h>
#include <heap.h>

#define pthCur pthcbCur
#define hpGetTID()	(pthCur->thcb_ThreadId)
char INTERNAL hpfWalk = 1;		/* enable some heap walking */

#ifdef HPDEBUG
#define dprintf(x) dprintf##x
#define DebugStop()	mmFatalError(0)
#else
#define dprintf(x)
#endif

#define HeapFree(hheap, flags, lpMem)	HPFree(hheap, lpMem)
#define HeapSize(hheap, flags, lpMem)	HPSize(hheap, lpMem)
#define hpTakeSem(hheap, pblock, flags) hpTakeSem2(hheap, pblock)
#define hpClearSem(hheap, flags) hpClearSem2(hheap)

#else	/* WIN32 */

#define pthCur (*pptdbCur)
#define hpGetTID() (pthCur ? (((struct tcb_s *)(pthCur->R0ThreadHandle))->TCB_ThreadId) : 0);
char	mmfErrorStop = 1;		/* enable stopping for all errors */
char    INTERNAL hpfWalk = 0;		/* disable heap walking */

#ifdef HPMEASURE
BOOL PRIVATE hpMeasureItem(HHEAP hheap, unsigned uItem);
#endif

#endif /* WIN32 */

#ifdef HPDEBUG
#define hpTrash(s)	    dprintf((s));dprintf((("\nheap handle=%x\n", hheap)));if (hpfTrashStop) DebugStop()
char INTERNAL hpfParanoid = 0;		/* disable very strict walking */
char INTERNAL hpfTrashStop = 1;		/* enable stopping for trashed heap */
char INTERNAL hpWalkCount = 0;		/* keep count of times hpWalk called*/
#endif


/***LD	hpFreeSizes - the block sizes for the different free list heads
 */
unsigned long hpFreeSizes[hpFREELISTHEADS] = {32, 128, 512, (ULONG)-1};

#ifndef WIN32
#pragma VMM_PAGEABLE_DATA_SEG
#pragma VxD_VMCREATE_CODE_SEG
#endif

#ifdef DEBUG
/***EP	HeapSetFlags - set heap error flags
 *
 *	ENTRY:	dwFlags - flags to change
 *              dwFlagValues - new flag values
 *
 *      EXIT:   old values of the flags
 *              (on RETAIL, this is a stub which returns -1)
 */
#define HSF_MMFERRORSTOP    0x00000001
#define HSF_HPFPARANOID     0x00000002
#define HSF_VALIDMASK       0x00000003

DWORD APIENTRY
HeapSetFlags( DWORD  dwFlags, DWORD dwFlagValues)
{
    DWORD       dwOldFlagValues;

    dwOldFlagValues = (mmfErrorStop ? HSF_MMFERRORSTOP : 0) |
                      (hpfParanoid  ? HSF_HPFPARANOID  : 0);

    if( dwFlags & ~HSF_VALIDMASK) {
        OutputDebugString( "HeapSetFlags: invalid flags, ignored\n");
        return (DWORD)-1;     // error
    }

    if( dwFlags & HSF_MMFERRORSTOP) {
        if( dwFlagValues & HSF_MMFERRORSTOP)
            mmfErrorStop = 1;
        else
            mmfErrorStop = 0;
    }

    if( dwFlags & HSF_HPFPARANOID) {
        if( dwFlagValues & HSF_HPFPARANOID) {
	    hpfTrashStop = 1;
	    hpfWalk = 1;
	    hpfParanoid = 1;
        } else {
            hpfParanoid = 0;
	}
    }

    return dwOldFlagValues;
}
#endif


/***EP	HPInit - initialize a memory block as a heap
 *
 *	ENTRY:	hheap - heap handle for heap (same as pmem unless HP_INITSEGMENT)
 *		pmem - pointer to chunk of memory (must be page aligned)
 *		cbreserve - number of bytes reserved in block (must be PAGESIZE
 *			    multiple)
 *		flags - HP_NOSERIALIZE: don't serialize heap operations
 *			(if not, caller MUST serialize)
 *			HP_EXCEPT: generate exceptions instead of errors
 *			HP_GROWABLE: heap can grow infinitely beyond cbreserve
 *			HP_LOCKED: commit pages as fixed to heap
 *			HP_INITSEGMENT: initialize the block as an growable
 *					heap segment
 *			HP_GROWUP: waste last page in heap so heap allocs
 *				   will grow monotonically upwards from base
 *	EXIT:	handle to new heap or 0 if error.
 */
HHEAP INTERNAL
HPInit(struct heapinfo_s *hheap,
       struct heapinfo_s *pmem,
       unsigned long cbreserve,
       unsigned long flags)
{
    struct freelist_s *pfreelist;
    struct freelist_s *pfreelistend;
    unsigned *psizes;
    struct busyheap_s *pfakebusy;
    unsigned cbheader, cbmainfree;

    mmAssert(((unsigned)pmem & PAGEMASK) == 0 && cbreserve != 0 &&
	     (cbreserve & PAGEMASK) == 0, "HPInit: invalid parameter\n");


    /*
     *	Commit enough space at the beginning of the heap to hold a
     *	heapinfo_s structure and a minimal free list.
     */
    if (hpCommit((unsigned)pmem / PAGESIZE,
		 (sizeof(struct heapinfo_s)+sizeof(struct freeheap_s)+PAGEMASK)
								    / PAGESIZE,
		 flags) == 0) {
	goto error;
    }

    /*
     *	This next block of initialization stuff we only have to do if
     *	we are creating a brand new heap, not just a heap segment.
     */
    if ((flags & HP_INITSEGMENT) == 0) {
	cbheader = sizeof(struct heapinfo_s);

	/*
	 *  Fill in the heapinfo_s structure (per-heap information).
	 */
#ifdef WIN32
	pmem->hi_procnext = 0;
#endif
	pmem->hi_psegnext = 0;
	pmem->hi_signature = HI_SIGNATURE;
	pmem->hi_flags = (unsigned char)flags;

#ifdef HPDEBUG
	pmem->hi_cbreserve = cbreserve; /* this is also done below, here for sum */
	pmem->hi_sum = hpSum(pmem, HI_CDWSUM);
	pmem->hi_eip = hpGetAllocator();
	pmem->hi_tid = hpGetTID();
	pmem->hi_thread = 0;
#endif

	/*
	 *  If the caller requested that we serialize access to the heap,
	 *  create a critical section to do that.
	 */
	if ((flags & HP_NOSERIALIZE) == 0) {
	    hpInitializeCriticalSection(pmem);
	}

	/*
	 *  Initialize the free list heads.
	 *  In the future we might want to have the user pass in the
	 *  size of the free lists he would like, but for now just copy
	 *  them from the static list hpFreeSizes.
	 */
	pfreelist = pmem->hi_freelist;
	pfreelistend = pfreelist + hpFREELISTHEADS;
	psizes = hpFreeSizes;
	for (; pfreelist < pfreelistend; ++pfreelist, ++psizes) {
	    pfreelist->fl_cbmax = *psizes;
	    hpSetFreeSize(&pfreelist->fl_header, 0);
	    pfreelist->fl_header.fh_flink = &(pfreelist+1)->fl_header;
	    pfreelist->fl_header.fh_blink = &(pfreelist-1)->fl_header;
#ifdef HPDEBUG
	    pfreelist->fl_header.fh_signature = FH_SIGNATURE;
	    pfreelist->fl_header.fh_sum = hpSum(&pfreelist->fl_header, FH_CDWSUM);
#endif
	}

	/*
	 *  Make the list circular by fusing the start and beginning
	 */
	pmem->hi_freelist[0].fl_header.fh_blink =
		    &(pmem->hi_freelist[hpFREELISTHEADS - 1].fl_header);
	pmem->hi_freelist[hpFREELISTHEADS - 1].fl_header.fh_flink =
		    &(pmem->hi_freelist[0].fl_header);
#ifdef HPDEBUG
	pmem->hi_freelist[0].fl_header.fh_sum =
	    hpSum(&(pmem->hi_freelist[0].fl_header), FH_CDWSUM);
	pmem->hi_freelist[hpFREELISTHEADS - 1].fl_header.fh_sum =
	    hpSum(&(pmem->hi_freelist[hpFREELISTHEADS - 1].fl_header), FH_CDWSUM);
#endif
    } else {
	cbheader = sizeof(struct heapseg_s);
    }
    pmem->hi_cbreserve = cbreserve;

    /*
     *	Put a tiny busy heap header at the very end of the heap
     *	so we can free the true last block and mark the following
     *	block as HP_PREVFREE without worrying about falling off the
     *	end of the heap.  Give him a size of 0 so we can also use
     *	him to terminate heap-walking functions.
     *	We also might need to commit a page to hold the thing.
     */
    pfakebusy = (struct busyheap_s *)((unsigned long)pmem + cbreserve) - 1;
    if (cbreserve > PAGESIZE) {
	if (hpCommit((unsigned)pfakebusy / PAGESIZE,
	    (sizeof(struct busyheap_s) + PAGEMASK) / PAGESIZE, flags) == 0) {
	    goto errordecommit;
	}
    }
    hpSetBusySize(pfakebusy, 0);
#ifdef HPDEBUG
    pfakebusy->bh_signature = BH_SIGNATURE;
    pfakebusy->bh_sum = hpSum(pfakebusy, BH_CDWSUM);
#endif


    /*
     *	Link the interior of the heap into the free list.
     *	If we create one big free block, the page at the end of the heap will
     *	be wasted because it will be committed (to hold the end sentinel) but
     *	it will won't be touched for allocations until every other page in the
     *	heap has been used.  To avoid this, we create two free blocks, one for
     *	main body of the heap and another block which has most of the last
     *	page in it.  We need to insert the last page first because hpFreeSub
     *	looks at the following block to see if we need to coalesce.
     *	The caller can force us to waste the last page by passing in HP_GROWUP.
     *	It is used by some ring 3 components who would waste tiled selectors
     *	if we had blocks being allocated from an outlying end page.
     */
    if ((flags & HP_GROWUP) == 0 && cbreserve > PAGESIZE) {
	cbmainfree = cbreserve - cbheader - PAGESIZE +	/* size of main block */
		     sizeof(struct freeheap_s *);

	/*
	 *  Put a little busy heap block at the front of the final page
	 *  to keep the final page from getting coalesced into the main free
	 *  block.
	 */
	pfakebusy = (struct busyheap_s *)((char *)pmem + cbmainfree + cbheader);
	hpSetBusySize(pfakebusy, sizeof(struct busyheap_s));
#ifdef HPDEBUG
	pfakebusy->bh_signature = BH_SIGNATURE;
	pfakebusy->bh_sum = hpSum(pfakebusy, BH_CDWSUM);
#endif

	/*
	 *  Free the rest of the last page (minus the various little bits
	 *  we have taken out)
	 */
	hpFreeSub(hheap, pfakebusy + 1,
		  PAGESIZE -			/* entire page, less... */
		  sizeof(struct freeheap_s *) - /*  back-pointer to prev free*/
		  sizeof(struct busyheap_s) -	/*  anti-coalescing busy block*/
		  sizeof(struct busyheap_s),	/*  end sentinel */
		  0);

    /*
     *	Otherwise, make the entirety of our heap between the end of the header
     *	end the end sentinel into a free block.
     */
    } else {
	cbmainfree = cbreserve - sizeof(struct busyheap_s) - cbheader;
    }

    /*
     *	Now put the main body of the heap onto the free list
     */
    hpFreeSub(hheap, (char *)pmem + cbheader, cbmainfree, 0);


#ifdef HPDEBUG
    /*
     *	Verify the heap is ok.	Note, a new heap segment will fail the test
     *	until we hook it up properly in HPAlloc, so skip the check for them.
     */
    if (hpfParanoid && hheap == pmem) {
	hpWalk(hheap);
    }
#endif

    /*
     *	Return a pointer to the start of the heap as the heap handle
     */
  exit:
    return(pmem);

  errordecommit:
    PageDecommit((unsigned)pmem / PAGESIZE,
		 (sizeof(struct heapinfo_s)+sizeof(struct freeheap_s)+PAGEMASK)
								    / PAGESIZE,
		 PC_STATIC);
  error:
    pmem = 0;
    goto exit;
}


#ifndef WIN32
/***EP	HPClone - make a duplicate of an existing heap
 *
 *	This routine is used to create a new heap that has heap blocks
 *	allocated and free in the same places as another heap.	However,
 *	the contents of the blocks will be zero-initialized, rather than
 *	the same as the other heap.
 *
 *	If this routine fails, it is the responsibility of the caller
 *	to free up any memory that might have been committed (as well as
 *	the original reserved object).
 *
 *	ENTRY:	hheap - handle to existing heap to duplicate
 *		pmem - pointer to new memory block to turn into duplicate heap
 *		       (the address must be reserved and not committed)
 *	EXIT:	handle to new heap if success, else 0 if failure
 */
HHEAP INTERNAL
HPClone(struct heapinfo_s *hheap, struct heapinfo_s *pmem)
{
    struct freeheap_s *ph;
    struct freeheap_s *phend;
#ifdef HPDEBUG
    struct freeheap_s *phnew;
#endif

    /*
     *	We need to take the heap semaphore for the old heap so no one
     *	changes its contents while we clone it (that could confuse the
     *	walking code).
     */
    if (hpTakeSem(hheap, 0, 0) == 0) {
	pmem = 0;
	goto exit;
    }

    /*
     *	First call HPInit on the new block to get it a header
     */
    if (HPInit(pmem, pmem, hheap->hi_cbreserve, (unsigned)hheap->hi_flags) == 0) {
	goto error;
    }

    /*
     *	Ring 0 heaps are layed out in the following general areas:
     *
     *	      1 heap header
     *	      2 mix of allocated and free heap blocks
     *	      3 giant free heap block (remains of initial free block)
     *	      4 a single minimum size busy heap block
     *	      5 mix of allocated and free heap blocks
     *	      6 end sentinel
     *
     *	The general method for cloning a heap is to walk the entire source
     *	heap and allocate blocks on the new heap corresponding to all
     *	the blocks on the source heap, busy or free.  Then go back through
     *	the source free list and free the corresponding blocks on the
     *	new heap.  You will then have two heaps with the same lay-out of
     *	free and busy blocks.  However, doing this will cause a huge overcommit
     *	spike when block (3) gets allocated and then freed.  To avoid this,
     *	when allocating the blocks we first allocate the blocks from area (5)
     *	then the blocks in (2) which will naturally leave us with a big
     *	free block at (3) like there should be without causing a spike.
     *	This scheme will only work if (3) is the last block on the free
     *	list, otherwise the free list will not be in the correct order when
     *	we are done.  "phend" will be pointed to block (3) if it is
     *	in the correct place for us to do our trick, otherwise we set it to (4).
     *	"ph" will start just past (4).
     */
    ph = (struct freeheap_s *)((char *)hheap + hheap->hi_cbreserve - PAGESIZE +
			       sizeof(struct freeheap_s *) +
			       sizeof(struct busyheap_s));
    phend = hheap->hi_freelist[0].fl_header.fh_blink;

    /*
     *	If the last block on the free list isn't just before (4) then
     *	reset our variables as per comment above.
     */
    if ((char *)phend + hpSize(phend)+sizeof(struct busyheap_s) != (char *)ph) {
	phend = (struct freeheap_s *)((char *)ph - sizeof(struct busyheap_s));
	mmAssert(hpIsBusySignatureValid((struct busyheap_s *)ph) &&
		 hpSize(ph) == sizeof(struct busyheap_s),
		 "HPClone: bad small busy block");
    }

    /*
     *	Now walk through the old heap and allocate corresponding blocks
     *	on the new heap.  First we allocate the blocks on the last page.
     */
    for (; hpSize(ph) != 0; (char *)ph += hpSize(ph)) {
	if (HPAlloc(pmem,hpSize(ph)-sizeof(struct busyheap_s),HP_ZEROINIT)==0){
	    mmAssert(0, "HPClone: alloc off last page failed"); /* already committed */
	}
    }

    /*
     *	Then allocate the blocks in the first part of heap, except maybe
     *	the big free block (3) if we are set up that way from above.
     */
    ph = (struct freeheap_s *)(hheap + 1);
    for (; ph != phend; (char *)ph += hpSize(ph)) {
	if (HPAlloc(pmem, hpSize(ph) - sizeof(struct busyheap_s),
		    HP_ZEROINIT) == 0) {
	    goto error;
	}
    }

    /*
     *	How go back through the heap and free up all the blocks that are
     *	free on the old heap.  We have to do this by walking the old
     *	heap's free list backwards, so the free blocks are in the same
     *	order on both heaps.
     */
    ph = hheap->hi_freelist[0].fl_header.fh_blink;
    for (; ph != &(hheap->hi_freelist[0].fl_header); ph = ph->fh_blink) {

	mmAssert(hpIsFreeSignatureValid(ph), "HPClone: bad block on free list");

	/*
	 *  Skip freeing any list heads and the "pfhbigfree" if we are
	 *  special casing him
	 */
	if (hpSize(ph) != 0 && ph != phend) {
	    if (HPFree(pmem, (char *)pmem + sizeof(struct busyheap_s) +
		       (unsigned long)ph - (unsigned long)hheap) == 0) {
		mmAssert(0, "HPClone: HPFree failed");
	    }
	}
    }

#ifdef HPDEBUG
    /*
     *	Now let's verify that they really came out the same
     */
    for (ph = (struct freeheap_s *)(hheap+1),
	 phnew = (struct freeheap_s *)(pmem + 1);
	 hpSize(ph) != 0;
	 (char *)phnew += hpSize(ph), (char *)ph += hpSize(ph)) {

	mmAssert(ph->fh_size == phnew->fh_size, "HPClone: mis-compare");
    }
#endif

  clearsem:
    hpClearSem(hheap, 0);

  exit:
    return(pmem);

  error:
    pmem = 0;
    goto clearsem;
}

#ifndef WIN32
#pragma VMM_PAGEABLE_DATA_SEG
#pragma VxD_W16_CODE_SEG
#endif

/***LP	hpWhichHeap - figure out which Dos386 heap a pointer came from
 *
 *	ENTRY:	p - pointer to heap block
 *	EXIT:	handle to appropriate heap or 0 if invalid address
 */
HHEAP INTERNAL
hpWhichHeap(ULONG p)
{
    struct heapseg_s *pseg;

    /*
     *	Check the fixed heap first, because it is sadly the most commonly used
     */
    pseg = (struct heapseg_s *)hFixedHeap;
    do {
	if (p > (ULONG)pseg && p < (ULONG)pseg + pseg->hs_cbreserve) {
	    return(hFixedHeap);
	}
	pseg = pseg->hs_psegnext;
    } while (pseg != 0);

    /*
     *	Then check the swappable heap
     */
    pseg = (struct heapseg_s *)hSwapHeap;
    do {
	if (p > (ULONG)pseg && p < (ULONG)pseg + pseg->hs_cbreserve) {
	    return(hSwapHeap);
	}
	pseg = pseg->hs_psegnext;
    } while (pseg != 0);

    /*
     *	Finally the init heap.	Note that the init heap isn't growable, so we
     *	can just do a simple range check rather than the segment looping we
     *	do for the other heaps.
     */
    if (p > (ULONG)hInitHeap && p < InitHeapEnd) {
	return(hInitHeap);
    }

    /*
     *	If we fall down to here, the address wasn't on any of the heaps
     */
    mmError(ERROR_INVALID_ADDRESS, "hpWhichHeap: block not on heap");
    return(0);
}
#endif


/***EP	HeapFree or HPFree - free a heap block
 *
 *	Mark the passed in block as free and insert it on the appropriate
 *	free list.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		flags (ring 3 only) - HP_NOSERIALIZE
 *		pblock - pointer to data of block to free (i.e., just past
 *			 busyheap_s structure)
 *	EXIT:	0 if error (bad hheap or pblock) or 1 if success
 */
#ifdef WIN32
BOOL APIENTRY
HeapFreeInternal(HHEAP hheap, DWORD flags, LPSTR lpMem)
#else
unsigned INTERNAL
HPFree(HHEAP hheap, void *lpMem)
#endif
{
    unsigned long cb;
    struct freeheap_s *pblock;
    

    pblock = (struct freeheap_s *)((struct busyheap_s *)lpMem - 1);
						/* point to heap header */

    if (hpTakeSem(hheap, pblock, flags) == 0) {
	return(0);
    }
    cb = hpSize(pblock);
    pblock->fh_size |= 0xf0000000;

#ifdef HPMEASURE
    if (hheap->hi_flags & HP_MEASURE) {
       hpMeasureItem(hheap, cb | HPMEASURE_FREE);
    }
#endif

    /*
     *	If the previous block is free, coalesce with it.
     */
    if (pblock->fh_size & HP_PREVFREE) {
	(unsigned)pblock = *((unsigned *)pblock - 1); /* point to prev block */
	cb += hpSize(pblock);

	/*
	 *  Remove the previous block from the free list so we can re-insert
	 *  the combined block in the right place later
	 */
	hpRemove(pblock);
    }

    /*
     *	Build a free header for the block and insert him on the appropriate
     *	free list.  This routine also marks the following block as HP_PREVFREE
     *	and performs coalescing with the following block.
     */
    hpFreeSub(hheap, pblock, cb, HP_DECOMMIT);

    hpClearSem(hheap, flags);
    return(1);
}


/***EP	HPAlloc - allocate a heap block
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		cb - size of block requested
 *		flags - HP_ZEROINIT - zero initialize new block
 *	EXIT:	none
 */
void * INTERNAL
HPAlloc(HHEAP hheap, unsigned long cb, unsigned long flags)
{
    struct freelist_s *pfreelist;
    struct freeheap_s *pfh;
    struct freeheap_s *pfhend;
    struct heapseg_s *pseg;
    unsigned cbreserve;

    /*
     *	Detect really big sizes here so that we don't have to worry about
     *	rounding up big numbers to 0
     */
    if (cb > hpMAXALLOC) {
	mmError(ERROR_NOT_ENOUGH_MEMORY, "HPAlloc: request too big\n\r");
	goto error;
    }

    if (hpTakeSem(hheap, 0, flags) == 0) {
	goto error;
    }
    cb = hpRoundUp(cb);

#ifdef HPMEASURE
    if (hheap->hi_flags & HP_MEASURE) {
       hpMeasureItem(hheap, cb);
    }
#endif

  restart:
    /*
     *	Find the first free list header that will contain a block big
     *	enough to satisfy this allocation.
     *
     *	NOTE: at the cost of heap fragmentation, we could change this
     *	to allocate from the first free list that is guaranteed to
     *	have a block big enough as its first entry.  That would
     *	cut down paging on swappable heaps.
     */
    for (pfreelist=hheap->hi_freelist; cb > pfreelist->fl_cbmax; ++pfreelist) {
    }


    /*
     *	Look for a block big enough for us on the list head returned.
     *	Even if we follow the advice of the NOTE above and pick a list
     *	that will definitely contain a block big enough for us we still
     *	have to do this scan to pass by any free list heads in the
     *	way (they have a size of 0, so we will never try to allocate them).
     *
     *	We know we have reached the end of the free list when we get to
     *	to the first free list head (since the list is circular).
     */
    pfh = pfreelist->fl_header.fh_flink;
    pfhend = &(hheap->hi_freelist[0].fl_header);
    for (; pfh != pfhend; pfh = pfh->fh_flink) {

	/*
	 *  Did we find a block big enough to hold our request?
	 */
	if (hpSize(pfh) >= cb) {

	    /*
	     *	At this point we have a block of free memory big enough to
	     *	use in pfh.
	     */
	    {
		struct busyheap_s *pbh = (struct busyheap_s *)pfh;

		if ((cb = hpCarve(hheap, pfh, cb, flags)) == 0) {
		    goto errorclearsem;
		}
		hpSetBusySize(pbh, cb);
#ifdef HPDEBUG
		pbh->bh_signature = BH_SIGNATURE;
		pbh->bh_eip = hpGetAllocator();
		pbh->bh_tid = hpGetTID();
		pbh->bh_sum = hpSum(pbh, BH_CDWSUM);
#endif
		hpClearSem(hheap, flags);
		return(pbh + 1);
	    }
	}
    }

    /*
     *	If we fall out of the above loop, there are no blocks available
     *	of the correct size.
     */

    /*
     *	If the heap isn't there is nothing we can do but return error.
     */
    if ((hheap->hi_flags & HP_GROWABLE) == 0) {
	mmError(ERROR_NOT_ENOUGH_MEMORY,"HPAlloc: not enough room on heap\n");
	goto errorclearsem;
    }

    /*
     *	The heap is growable but all the existing heap segments are full.
     *	So reserve a new segment here.	The "PAGESIZE*2" below will take care
     *	of the header on the new segment and the special final page, leaving
     *	a big enough free block for the actual request.
     */
    cbreserve = max(((cb + PAGESIZE*2) & ~PAGEMASK), hpCBRESERVE);

    if (((unsigned)pseg =
#ifdef WIN32
	PageReserve(((unsigned)hheap >= MINSHAREDLADDR) ? PR_SHARED : PR_PRIVATE,
		    cbreserve / PAGESIZE, PR_STATIC)) == -1) {

	mmError(ERROR_NOT_ENOUGH_MEMORY, "HPAlloc: reserve failed\n");
#else
	PageReserve(PR_SYSTEM, cbreserve / PAGESIZE, PR_STATIC |
		    ((hheap->hi_flags & HP_LOCKED) ? PR_FIXED :0))) == -1) {
#endif
	goto errorclearsem;
    }

    /*
     *	Initialize the new segment as a heap (including linking its initial
     *	free block into the heap).
     */
    if (HPInit(hheap, (HHEAP)pseg, cbreserve, hheap->hi_flags | HP_INITSEGMENT) == 0) {
	goto errorfree;
    }

    /*
     *	Link the new heap segment onto the list of segments.
     */
    pseg->hs_psegnext = hheap->hi_psegnext;
    hheap->hi_psegnext = pseg;

    /*
     *	Now go back up to restart our search, we should find the new segment
     *	to satisfy the request.
     */
    goto restart;


    /*
     *	Code below this comment is used only in the error path.
     */
  errorfree:
    PageFree((unsigned)pseg, PR_STATIC);

  errorclearsem:
    hpClearSem(hheap, flags);
#ifdef WIN32
    if ((flags | hheap->hi_flags)  & HP_EXCEPT) {
	RaiseException(STATUS_NO_MEMORY, 0, 1, &cb);
    }
#endif
  error:
    return(0);
}


/***EP	HPReAlloc - reallocate a heap block
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		pblock - pointer to data of block to reallocate
 *			 (just past the busyheap_s structure)
 *		cb - new size requested (in bytes)
 *		flags - HP_ZEROINIT - on grows, fill new area with 0s
 *			HP_MOVEABLE - on grows, moving of block is allowed
 *			HP_NOCOPY - don't preserve old block's contents
 *	EXIT:	pointer to reallocated block or 0 if failure
 */
void * INTERNAL
HPReAlloc(HHEAP hheap, void *pblock, unsigned long cb, unsigned long flags)
{
    void *pnew;
    unsigned oldsize;
    struct freeheap_s *pnext;
    struct busyheap_s *pbh;

    /*
     *	Detect really big sizes here so that we don't have to worry about
     *	rounding up big numbers to 0
     */
    if (cb > hpMAXALLOC) {
	mmError(ERROR_NOT_ENOUGH_MEMORY, "HPReAlloc: request too big\n\r");
	goto error;
    }

    pbh = (struct busyheap_s *)pblock - 1;   /* point to heap block header */
    if (hpTakeSem(hheap, pbh, flags) == 0) {
	goto error;
    }
    cb = hpRoundUp(cb); 		     /* convert to heap block size */
    oldsize = hpSize(pbh);

    /*
     *	Is this a big enough shrink to cause us to carve off the end of
     *	the block?
     */
    if (cb + hpMINSIZE <= oldsize) {
	hpFreeSub(hheap, (char *)pbh + cb, oldsize - cb, HP_DECOMMIT);
	hpSetSize(pbh, cb);
#ifdef HPDEBUG
	pbh->bh_sum = hpSum(pbh, BH_CDWSUM);
#endif


    /*
     *	Is this a grow?
     */
    } else if (cb > oldsize) {
	/*
	 *  See if there is a next door free block big enough for us
	 *  grow into so we can realloc in place.
	 */
	pnext = (struct freeheap_s *)((char *)pbh + oldsize);
	if ((pnext->fh_size & HP_FREE) == 0 || hpSize(pnext) < cb - oldsize) {
	    /*
	     *	We have to move the object in order to grow it.
	     *	Make sure that is ok with the caller first.
	     */
	    if (flags & HP_MOVEABLE) {
#ifdef HPDEBUG
		/*
		 *  On a debug system, remember who allocated this memory
		 *  so we don't lose the info when we allocate the new block
		 */
		ULONG eip;
		USHORT tid;

		eip = pbh->bh_eip;
		tid = pbh->bh_tid;
#endif
		/*
		 *  The size we have computed in cb includes a heap header.
		 *  Remove that since our call to HPAlloc bellow will
		 *  also add on a header.
		 */
		cb -= sizeof(struct busyheap_s);

		/*
		 *  If the caller doesn't care about the contents of the
		 *  memory block, just allocate a new chunk and free old one
		 */
		if (flags & HP_NOCOPY) {
		    HeapFree(hheap, HP_NOSERIALIZE, pblock);
		    if ((pblock = HPAlloc(hheap, cb,
					  flags | HP_NOSERIALIZE)) == 0) {
			dprintf(("HPReAlloc: HPAlloc failed 1\n"));
			goto errorclearsem;
		    }

		/*
		 *  If the caller cares about his data, allocate a new
		 *  block and copy the old stuff into it
		 */
		} else {

		    if ((pnew = HPAlloc(hheap, cb, flags | HP_NOSERIALIZE))==0){
			dprintf(("HPReAlloc: HPAlloc failed 2\n"));
			goto errorclearsem;
		    }
		    memcpy(pnew, pblock, oldsize - sizeof(struct busyheap_s));
		    HeapFree(hheap, HP_NOSERIALIZE, pblock);
		    pblock = pnew;
		}

#ifdef HPDEBUG
		/*
		 *  Put back in the original owner
		 */
		pbh = (((struct busyheap_s *)pblock) - 1);
		pbh->bh_eip = eip;
		pbh->bh_tid = tid;
		pbh->bh_sum = hpSum(pbh, BH_CDWSUM);
#endif

	    /*
	     *	Moving of the block is not allowed.  Return error.
	     */
	    } else {
		mmError(ERROR_LOCKED,"HPReAlloc: fixed block\n");
		goto errorclearsem;
	    }

	/*
	 *  We can grow in place into the following block
	 */
	} else {
	    if ((cb = hpCarve(hheap, pnext, cb - oldsize, flags)) == 0) {
		goto errorclearsem;
	    }
	    hpSetSize(pbh, oldsize + cb);
#ifdef HPDEBUG
	    pbh->bh_sum = hpSum(pbh, BH_CDWSUM);
#endif
	}

    /*
     *	This is place to put code for nop realloc if we ever have any.
     */
    } else {

    }

    hpClearSem(hheap, flags);
 exit:
    return(pblock);

 errorclearsem:
    hpClearSem(hheap, flags);

 error:
    pblock = 0;
    goto exit;
}

#ifndef WIN32
#pragma VMM_PAGEABLE_DATA_SEG
#pragma VxD_RARE_CODE_SEG
#endif

/***EP	HeapSize or HPSize - return size of a busy heap block (less any header)
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		flags (ring 3 only) - HP_NOSERIALIZE
 *		pdata - pointer to heap block (just past busyheap_s struct)
 *	EXIT:	size of block in bytes, or 0 if error
 */
#ifdef WIN32
DWORD APIENTRY
HeapSize(HHEAP hheap, DWORD flags, LPSTR lpMem)
#else
unsigned INTERNAL
HPSize(HHEAP hheap, void *lpMem)
#endif
{
    struct busyheap_s *pblock;
    unsigned long cb;

    pblock = ((struct busyheap_s *)lpMem) - 1;	/* point to heap block header*/

    if (hpTakeSem(hheap, pblock, flags) == 0) {
	return(0);
    }

    cb = hpSize(pblock) - sizeof(struct busyheap_s);

    hpClearSem(hheap, flags);
    return(cb);
}

#ifndef WIN32
#pragma VMM_PAGEABLE_DATA_SEG
#pragma VxD_W16_CODE_SEG
#endif

/***LP	hpCarve - carve off a chunk from the top of a free block
 *
 *	This is a low level worker routine and several very specific
 *	entry conditions must be true:
 *
 *	    The free block is valid.
 *	    The free block is at least as big as the chunk you want to carve.
 *	    The heap semaphore is taken.
 *
 *	No header is created for the carved-off piece.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		pfh - pointer to header of free block to carve from
 *		cb - size of block to carve out
 *		flags - HP_ZEROINIT
 *	EXIT:	count of bytes in carved off block (may differ from cb if
 *		free block wasn't big enough to make a new free block from
 *		its end) or 0 if error (out of memory on commit)
 */
unsigned INTERNAL
hpCarve(HHEAP hheap, struct freeheap_s *pfh, unsigned cb, unsigned flags)
{
    unsigned cbblock = hpSize(pfh);
    unsigned pgcommit, pgnextcommit, pglastcommit;
    unsigned fcommitzero;

    /*
     *	For multi-page HP_ZEROINIT blocks, it would be nice to commit
     *	zero-filled pages rather than use memset because then we wouldn't have
     *	to make the new pages in the block present and dirty unless and until
     *	the app really wanted to use them (saving on working set and page outs).
     *	This could be a huge win if someone is allocating big objects.
     *	However, we have the problem of what to do about a new partial page at
     *	the end of a heap block.  If we commit it as zero-filled, then we are
     *	zeroing more than we have to (the part of the page not used for this
     *	block).  If we commit it un-initialized, then we have to make two
     *	separate commit calls, one for the zero-filled pages and one for the
     *	last page.  Rather than spend the time of two commit calls and the logic
     *	to figure out when to make them, we always commit zero-filled pages for
     *	everything.  Better to zero too much than too little by mistake.  We
     *	reduce the percentage cost of the mistake case by only doing this
     *	optimization for large blocks.
     *	Here we decide if the block is big enough to commit zero-filled pages.
     */
    if ((flags & HP_ZEROINIT) && cb > 4*PAGESIZE) {
	fcommitzero = HP_ZEROINIT;
    } else {
	fcommitzero = 0;
    }

    mmAssert(cbblock >= cb, "hpCarve: carving out too big a block\n");
    mmAssert((pfh->fh_size & HP_FREE), "hpCarve: target not free\n");

    /*
     *	Since pfh points to a valid free block header, we know we have
     *	committed memory up through the end of the fh structure.  However,
     *	the page following the one containing the last byte of the fh
     *	structure might not be committed.  We set "pgcommit" to that
     *	possibly uncommitted page.
     */
		   /*last byte in fh*/ /*next pg*/   /*its pg #*/
    pgcommit = ((((unsigned)(pfh+1)) - 1 + PAGESIZE) / PAGESIZE);

    /*
     *	pgnextcommit is the page number of the page just past this free block
     *	that we know is already committed.  Since free blocks have a
     *	pointer back to the header in the last dword of the free block,
     *	we know that the first byte of this dword is where we are guaranteed
     *	to have committed memory.
     */
    pgnextcommit = ((unsigned)pfh + cbblock -
		    sizeof(struct freeheap_s *)) / PAGESIZE;

    /*
     *	If the block we found is too big, carve off the end into
     *	a new free block.
     */
    if (cbblock >= cb + hpMINSIZE) {

	/*
	 *  We need to commit the memory for the new block we are allocating
	 *  plus enough space on the end for the following free block header
	 *  that hpFreeSub will make.  The page number for that last page
	 *  we need to commit is pglastcommit.	If we know that pglastcommit
	 *  is already committed because it sits on the same page as
	 *  the start of the next block (pgnextcommit), back it up one.
	 */
	pglastcommit = ((unsigned)pfh + cb + sizeof(struct freeheap_s) - 1) / PAGESIZE;
	if (pglastcommit == pgnextcommit) {
	    pglastcommit--;
	}
	if (hpCommit(pgcommit, pglastcommit - pgcommit + 1,
		     fcommitzero | hheap->hi_flags) == 0) {
	    goto error;
	}

	/*
	 *  Remove the original free block from the free list.	We need to do
	 *  this before the hpFreeSub below because it might trash our current
	 *  free links.
	 */
	hpRemove(pfh);

	/*
	 *  Link the portion we are not using onto the free list
	 */
	hpFreeSub(hheap, (struct freeheap_s *)((char *)pfh + cb), cbblock-cb,0);

    /*
     *	We are using the whole free block for our purposes.
     */
    } else {
	if (hpCommit(pgcommit, pgnextcommit - pgcommit,
		     fcommitzero | hheap->hi_flags) == 0) {
	    goto error;
	}

	/*
	 *  Remove the original free block from the free list.
	 */
	hpRemove(pfh);

	/*
	 *  Clear the PREVFREE bit from the next block since we are no longer
	 *  free.
	 */
	cb = cbblock;
	((struct busyheap_s *)((char *)pfh + cb))->bh_size &= ~HP_PREVFREE;
#ifdef HPDEBUG
	((struct busyheap_s *)((char *)pfh + cb))->bh_sum =
		     hpSum((struct busyheap_s *)((char *)pfh + cb), BH_CDWSUM);
#endif
    }

    /*
     *	Zero-fill the block if requested and return
     */
    if (flags & HP_ZEROINIT) {
	/*
	 *  If fcommitzero is set, we have multi-page heap object with the
	 *  newly committed pages already set up to be zero-filled.
	 *  So we only have to memset the partial page at the start of the
	 *  block (up to the first page we committed) and maybe the partial
	 *  page at the end.
	 */
	if (fcommitzero) {
	    memset(pfh, 0, (pgcommit * PAGESIZE) - (unsigned)pfh);

	    /*
	     *	We have to zero the partial end page of this block if we didn't
	     *	commit the page freshly this time.
	     */
	    if ((unsigned)pfh + cb > pgnextcommit * PAGESIZE) {
		memset((PVOID)(pgnextcommit * PAGESIZE), 0,
		       (unsigned)pfh + cb - (pgnextcommit * PAGESIZE));
	    }

	/*
	 *  If the block fits on one page, just fill the whole thing
	 */
	} else {
	    memset(pfh, 0, cb);
	}
#ifdef HPDEBUG
    } else {
	memset(pfh, 0xcc, cb);
#endif
    }
  exit:
    return(cb);

  error:
    cb = 0;
    goto exit;
}


/***LP	hpCommit - commit new pages of the right type into the heap
 *
 *	The new pages aren't initialized in any way.
 *	The pages getting committed must currently be uncommitted.
 *	Negative values are allowed for the "npages" parameter, they
 *	are treated the same as 0 (a nop).
 *
 *	ENTRY:	page - starting page number to commit
 *		npages - number of pages to commit (may be negative or zero)
 *		flags - HP_LOCKED: commit the new pages as fixed (otherwise
 *				   they will be swappable)
 *			HP_ZEROINIT: commit the new pages as zero-initialized
 *	EXIT:	non-zero if success, else 0 if error
 */
unsigned INTERNAL
hpCommit(unsigned page, int npages, unsigned flags)
{
    unsigned rc = 1;	/* assume success */

    if (npages > 0) {
#ifdef HPDEBUG
	MEMORY_BASIC_INFORMATION mbi;

	/*
	 *  All the pages should be currently reserved but not committed
	 *  or else our math in hpCarve is off.
	 */
	PageQuery(page * PAGESIZE, &mbi, sizeof(mbi));
#ifdef WIN32
	mmAssert(mbi.State == MEM_RESERVE &&
		 mbi.RegionSize >= (unsigned)npages * PAGESIZE,
		 "hpCommit: range not all reserved\n");
#else
	mmAssert(mbi.mbi_State == MEM_RESERVE &&
		 mbi.mbi_RegionSize >= (unsigned)npages * PAGESIZE,
		 "hpCommit: range not all reserved");
#endif
#endif
	rc = PageCommit(page, npages,
			(
#ifndef WIN32
			 (flags & HP_LOCKED) ? PD_FIXED :
#endif
							 PD_NOINIT) -
			((flags & HP_ZEROINIT) ? (PD_NOINIT - PD_ZEROINIT) : 0),
			0,
#ifndef WIN32
			((flags & HP_LOCKED) ? PC_FIXED : 0) |
			PC_PRESENT |
#endif
			PC_STATIC | PC_USER | PC_WRITEABLE);
#ifdef WIN32
	if (rc == 0) {
	    mmError(ERROR_NOT_ENOUGH_MEMORY, "hpCommit: commit failed\n");
	}
#endif
    }
    return(rc);
}


/***LP	hpFreeSub - low level block free routine
 *
 *	This routine inserts a block of memory on the free list with no
 *	checking for block validity.  It handles coalescing with the
 *	following block but not the previous one.  The block must also
 *	be big enough to hold a free header.  The heap semaphore must
 *	be taken already.  Any existing header information is ignored and
 *	overwritten.
 *
 *	This routine also marks the following block as HP_PREVFREE.
 *
 *	Enough memory must be committed at "pblock" to hold a free header and
 *	a dword must committed at the very end of "pblock".  Any whole pages
 *	in between those areas will be decommitted by this routine.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		pblock - pointer to memory block
 *		cb - count of bytes in block
 *		flags - HP_DECOMMIT: decommit pages entirely within heap block
 *				     (must be specified unless pages are known
 *				     to be already decommitted)
 *	EXIT:	none
 */
void INTERNAL
hpFreeSub(HHEAP hheap, struct freeheap_s *pblock, unsigned cb, unsigned flags)
{
    struct freelist_s *pfreelist;
    struct freeheap_s *pnext;
    struct freeheap_s *pfhprev;
    struct freeheap_s **ppnext;
    unsigned pgdecommit, pgdecommitmax;
    unsigned cbfree;
    int cpgdecommit;

    mmAssert(cb >= hpMINSIZE, "hpFreeSub: bad param\n");

    /*
     *	If the following block is free, coalesce with it.
     */
    pnext = (struct freeheap_s *)((char *)pblock + cb);
    if (pnext->fh_size & HP_FREE) {
	cb += hpSize(pnext);

	/*
	 *  Remove the following block from the free list.  We will insert
	 *  the combined block in the right place later.
	 *  Here we also set "pgdecommitmax" which is the page just past the
	 *  header of the following free block we are coalescing with.
	 */
	hpRemove(pnext);
	pgdecommitmax = ((unsigned)(pnext+1) + PAGEMASK) / PAGESIZE;
	pnext = (struct freeheap_s *)((char *)pblock + cb); /* recompute */

    } else {
	pgdecommitmax = 0x100000;
    }

#ifdef HPDEBUG
    /*
     *	In debug we fill the free block with here with the byte
     *	0xfe which happens to be nice invalid value either if excecuted
     *	or referenced as a pointer.  We only fill up through the first
     *	page boundary because I don't want to deal with figuring out
     *	which pages are committed and which not.
     */
     memset(pblock, 0xfe, min(cb, (PAGESIZE - ((unsigned)pblock & PAGEMASK))));
#endif

    /*
     *	Decommit any whole pages within this free block.  We need to be
     *	careful not to decommit either part of our heap header for this block
     *	or the back-pointer to the header we store at the end of the block.
     *	It would be nice if we could double check our math by making sure
     *	that all of the pages we are decommitting are currently committed
     *	but we can't because we might be either carving off part of a currently
     *	free block or we might be coalescing with other already free blocks.
     */
    ppnext = (struct freeheap_s **)pnext - 1;

    if (flags & HP_DECOMMIT) {
			   /*last byte in fh*/ /*next pg*/  /*its pg #*/
	pgdecommit = ((unsigned)(pblock+1) - 1 + PAGESIZE) / PAGESIZE;

	/*
	 *  This max statement will keep us from re-decommitting the pages
	 *  of any block we may have coalesced with above.
	 */
	pgdecommitmax = min(pgdecommitmax, ((unsigned)ppnext / PAGESIZE));
	cpgdecommit = pgdecommitmax - pgdecommit;
	if (cpgdecommit > 0) {
#ifdef HPDEBUG
	    unsigned tmp =
#endif
	    PageDecommit(pgdecommit, cpgdecommit, PC_STATIC);
#ifdef HPDEBUG
	    mmAssert(tmp != 0, "hpFreeSub: PageDecommit failed\n");
#endif
	}

#ifdef HPDEBUG
    /*
     *	If the caller didn't specify HP_DECOMMIT verify that all the pages
     *	are already decommitted.
     */
    } else {
	pgdecommit = ((unsigned)(pblock+1) - 1 + PAGESIZE) / PAGESIZE;
	cpgdecommit = ((unsigned)ppnext / PAGESIZE) - pgdecommit;
	if (cpgdecommit > 0) {
	    MEMORY_BASIC_INFORMATION mbi;

	    PageQuery(pgdecommit * PAGESIZE, &mbi, sizeof(mbi));
#ifdef WIN32
	    mmAssert(mbi.State == MEM_RESERVE &&
		     mbi.RegionSize >= (unsigned)cpgdecommit * PAGESIZE,
		     "hpFreeSub: range not all reserved\n");
#else
	    mmAssert(mbi.mbi_State == MEM_RESERVE &&
		     mbi.mbi_RegionSize >= (unsigned)cpgdecommit * PAGESIZE,
		     "hpFreeSub: range not all reserved");
#endif /*WIN32*/
	}
#endif /*HPDEBUG*/
    }

    /*
     *	Point the last dword of the new free block to its header and
     *	mark the following block as HP_PREVFREE;
     */
    *ppnext = pblock;
    pnext->fh_size |= HP_PREVFREE;
#ifdef HPDEBUG
    ((struct busyheap_s *)pnext)->bh_sum = hpSum(pnext, BH_CDWSUM);
#endif

    /*
     *	Find the appropriate free list to insert the block on.
     *	The last free list node should have a size of -1 so don't
     *	have to count to make sure we don't fall off the end of the list
     *	heads.
     */
    for (pfreelist=hheap->hi_freelist; cb > pfreelist->fl_cbmax; ++pfreelist) {
    }

    /*
     *	Now walk starting from that list head and insert it into the list in
     *	sorted order.
     */
    pnext = &(pfreelist->fl_header);
    do {
	pfhprev = pnext;
	pnext = pfhprev->fh_flink;
	cbfree = hpSize(pnext);
    } while (cb > cbfree && cbfree != 0);

    /*
     *	Insert the block on the free list just after the list head and
     *	mark the header as free
     */
    hpInsert(pblock, pfhprev);
    hpSetFreeSize(pblock, cb);
#ifdef HPDEBUG
    pblock->fh_signature = FH_SIGNATURE;
    pblock->fh_sum = hpSum(pblock, FH_CDWSUM);
#endif
    return;
}


/***LP	hpTakeSem - get exclusive access to a heap
 *
 *	This routine verifies that the passed in heap header is valid
 *	and takes the semaphore for that heap (if HP_NOSERIALIZE wasn't
 *	specified when the heap was created).  Optionally, it will
 *	also verify the validity of a busy heap block header.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		pbh - pointer to busy heap block header (for validation)
 *		      or 0 if there is no block to verify
 *		flags (ring 3 only) - HP_NOSERIALIZE
 *	EXIT:	0 if error (bad heap or block header), else 1
 */
#ifdef WIN32
unsigned INTERNAL
hpTakeSem(HHEAP hheap, struct busyheap_s *pbh, unsigned htsflags)
#else
unsigned INTERNAL
hpTakeSem2(HHEAP hheap, struct busyheap_s *pbh)
#endif
{
    struct heapseg_s *pseg;
#ifdef HPDEBUG
    unsigned cb;
#endif

#ifndef WIN32
#define htsflags	0

    mmAssert(!mmIsSwapping(),
	     "hpTakeSem: heap operation attempted while swapping\n");
#endif

#ifdef HPNOTTRUSTED
    /*
     * Verify the heap header.
     */
    if (hheap->hi_signature != HI_SIGNATURE) {
	mmError(ERROR_INVALID_PARAMETER,"hpTakeSem: bad header\n");
	goto error;
    }
#else
    pbh;		/* dummy reference to keep compiler happy */
    cb; 		/* dummy reference to keep compiler happy */
#endif

    /*
     *	Do the actual semaphore taking
     */
    if (((htsflags | hheap->hi_flags) & HP_NOSERIALIZE) == 0) {
#ifdef WIN32
	EnterMustComplete();
#endif
	hpEnterCriticalSection(hheap);
    }

#ifndef WIN32
    /*
     *	This is make sure that if we block while committing or decommitting
     *	pages we will not get reentered.
     */
    mmEnterPaging("hpTakeSem: bogus thcb_Paging");
#endif

#ifdef HPNOTTRUSTED

    /*
     *	If the caller wanted us to verify a heap block header, do so here.
     */
    if (pbh) {

	/*
	 *  First check that the pointer is within the specified heap
	 */
	pseg = (struct heapseg_s *)hheap;
	do {
	    if ((char *)pbh > (char *)pseg &&
		(char *)pbh < (char *)pseg + pseg->hs_cbreserve) {

		/*
		 *  We found the segment containing the block.	Validate that
		 *  it actually points to a heap block.
		 */
		if (!hpIsBusySignatureValid(pbh)
#ifdef HPDEBUG
		    || ((unsigned)pbh & hpGRANMASK) ||
		    (pbh->bh_size & HP_FREE) ||
		    (char *)pbh+(cb = hpSize(pbh)) > (char *)pseg+pseg->hs_cbreserve||
		    (int)cb < hpMINSIZE
		    || pbh->bh_signature != BH_SIGNATURE
#endif
							) {
		    goto badaddress;
		} else {
		    goto pointerok;
		}
	    }
	    pseg = pseg->hs_psegnext;	/* on to next heap segment */
	} while (pseg);

	/*
	 *  If we fell out of loop, we couldn't find the heap block on this
	 *  heap.
	 */
	goto badaddress;
    }
#endif

  pointerok:

#ifdef HPDEBUG
    /*
     *	Make sure that only one thread gets in the heap at a time
     */
    if (hheap->hi_thread && hheap->hi_thread != (unsigned)pthCur) {
	dprintf(("WARNING: two threads are using heap %x at the same time.\n",
		hheap));
	mmError(ERROR_BUSY, "hpTakeSem: re-entered\n\r");
	goto clearsem;
    }
    hheap->hi_thread = (unsigned)pthCur;

    /*
     *	Verify the heap is ok.	If hpfParanoid isn't set, only walk the heap
     *	every 4th time.
     */
    if (hpfParanoid || (hpWalkCount++ & 0x03) == 0) {
	if (hpWalk(hheap) == 0) {
	    mmError(ERROR_INVALID_PARAMETER,"Heap trashed outside of heap code -- someone wrote outside of their block!\n");
	    goto clearsem;
	}
    }
#endif
    return(1);

  badaddress:
    mmError(ERROR_INVALID_PARAMETER,"hpTakeSem: invalid address passed to heap API\n");
    goto clearsem;
  clearsem:
    hpClearSem(hheap, htsflags);
  error:
    return(0);
}

/***LP	hpClearSem - give up exclusive access to a heap
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		flags (ring 3 only) - HP_NOSERIALIZE
 *	EXIT:	none
 */
#ifdef WIN32
void INTERNAL
hpClearSem(HHEAP hheap, unsigned flags)
#else
void INTERNAL
hpClearSem2(HHEAP hheap)
#endif
{

    /*
     *	Verify the heap is ok
     */
#ifdef HPDEBUG
    if (hpfParanoid) {
	hpWalk(hheap);
    }
    hheap->hi_thread = 0;
#endif
#ifndef WIN32
    mmExitPaging("hpClearSem: bogus thcb_Paging");
#endif

    /*
     *	Free the semaphore
     */
    if (((
#ifdef WIN32
	  flags |
#endif
	  hheap->hi_flags) & HP_NOSERIALIZE) == 0) {
	hpLeaveCriticalSection(hheap);
	
#ifdef WIN32
	LeaveMustComplete();
#endif
    }
}

#ifdef HPDEBUG

#ifndef WIN32
#pragma VMM_LOCKED_DATA_SEG
#pragma VMM_LOCKED_CODE_SEG
#endif

/***LP	hpWalk - walk a heap to verify everthing is OK
 *
 *	This routine is "turned-on" if the hpfWalk flag is non-zero.
 *
 *	If hpWalk is detecting an error, you might want to set
 *	hpfTrashStop which enables stopping in the debugger whenever
 *	we detect a trashed heap block	and it attempts to print the
 *	trashed address.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *	EXIT:	1 if the heap is OK, 0 if it is trashed
 */
unsigned INTERNAL
hpWalk(HHEAP hheap)
{
    struct heapseg_s *pseg;
    struct freeheap_s *pfh;
    struct freeheap_s *pend;
    struct freeheap_s *pstart;
    struct freeheap_s *pfhend;
    struct busyheap_s *pnext;
    struct freeheap_s *pprev;
    unsigned cbmax;
    unsigned cheads;


    if (hpfWalk) {
	/*
	 *  First make a sanity check of the header
	 */
	if (hheap->hi_signature != HI_SIGNATURE) {
	    dprintf(("hpWalk: bad header signature\n"));
	    hpTrash(("trashed at %x\n", &hheap->hi_signature));
	    goto error;
	}
	if (hheap->hi_sum != hpSum(hheap, HI_CDWSUM)) {
	    dprintf(("hpWalk: bad header checksum\n"));
	    hpTrash(("trashed between %x and %x\n", hheap, &hheap->hi_sum));
	    goto error;
	}

	/*
	 *  Walk through all the blocks and make sure we get to the end.
	 *  The last block in the heap should be a busy guy of size 0.
	 */
	(unsigned)pfh = (unsigned)hheap + sizeof(struct heapinfo_s);
	pseg = (struct heapseg_s *)hheap;
	for (;;) {
	    pprev = pstart = pfh;
	    (unsigned)pend = (unsigned)pseg + pseg->hs_cbreserve;
	    for (;; (unsigned)pfh += hpSize(pfh)) {

		if (pfh < pstart || pfh >= pend) {
		    dprintf(("hpWalk: bad block address\n"));
		    hpTrash(("trashed addr %x\n", pprev));
		    goto error;
		}

		/*
		 *  If the block is free...
		 */
		if (pfh->fh_signature == FH_SIGNATURE) {

		    if (pfh->fh_sum != hpSum(pfh, FH_CDWSUM)) {
			dprintf(("hpWalk: bad free block checksum\n"));
			hpTrash(("trashed addr between %x and %x\n",
				 pfh, &pfh->fh_sum));
			goto error;
		    }
		    mmAssert(hpIsFreeSignatureValid(pfh),
			     "hpWalk: bad tiny free sig\n");

		    if (hpfParanoid) {
			/*
			 *  Free blocks should be marked as HP_FREE and the following
			 *  block should be marked HP_PREVFREE and be busy.
			 *  But skip this check if the following block is 4 bytes
			 *  into a page boundary so we don't accidentally catch
			 *  the moment in  HPInit where we have two adjacent
			 *  free blocks for a minute.  Any real errors that this
			 *  skips will probably be caught later on.
			 */
			pnext = (struct busyheap_s *)((char *)pfh + hpSize(pfh));
			if (((unsigned)pnext & PAGEMASK) != sizeof(struct freeheap_s *) &&
			    ((pfh->fh_size & HP_FREE) == 0 ||
			     (pnext->bh_size & HP_PREVFREE) == 0 ||
			      pnext->bh_signature != BH_SIGNATURE)) {

			    dprintf(("hpWalk: bad free block\n"));
			    hpTrash(("trashed addr near %x or %x or %x\n",pprev, pfh, pnext));
			    goto error;
			}

			/*
			 *  Also verify that a free block is linked on the free list
			 */
			if ((pfh->fh_flink->fh_size & HP_FREE) == 0 ||
			    pfh->fh_flink->fh_blink != pfh ||
			    (pfh->fh_blink->fh_size & HP_FREE) == 0 ||
			    pfh->fh_blink->fh_flink != pfh) {

			    dprintf(("hpWalk: free block not in free list properly\n"));
			    hpTrash(("trashed addr probably near %x or %x or %x\n", pfh, pfh->fh_blink, pfh->fh_flink));
			    goto error;
			}
		    }

		/*
		 *  Busy blocks should not be marked HP_FREE and if they are
		 *  marked HP_PREVFREE the previous block better be free.
		 */
		} else if (pfh->fh_signature == BH_SIGNATURE) {

		    if (((struct busyheap_s *)pfh)->bh_sum != hpSum(pfh, BH_CDWSUM)) {
			dprintf(("hpWalk: bad busy block checksum\n"));
			hpTrash(("trashed addr between %x and %x\n",
				 pfh, &((struct busyheap_s *)pfh)->bh_sum));
			goto error;
		    }
		    mmAssert(hpIsBusySignatureValid((struct busyheap_s *)pfh),
			     "hpWalk: bad tiny busy sig\n");

		    if (hpfParanoid) {
			if (pfh->fh_size & HP_FREE) {
			    dprintf(("hpWalk: busy block marked free\n"));
			    hpTrash(("trashed addr %x\n", pfh));
			    goto error;
			}


			/*
			 *  Verify that the HP_PREVFREE bit is set only when
			 *  the previous block is free, and vice versa
			 *  But skip this check if the following block is 4 bytes
			 *  into a page boundary so we don't accidentally catch
			 *  the moment in  HPInit where we have two adjacent
			 *  free blocks for a minute.  Any real errors that this
			 *  skips will probably be caught later on.
			 */
			if (pfh->fh_size & HP_PREVFREE) {
			    if (pprev->fh_signature == FH_SIGNATURE) {
				if (*((struct freeheap_s **)pfh - 1) != pprev) {
				    dprintf(("hpWalk: free block tail doesn't point to head\n"));
				    hpTrash(("trashed at %x\n", (unsigned)pfh - 4));
				    goto error;
				}
			    } else {
				dprintf(("HP_PREVFREE erroneously set\n"));
				hpTrash(("trashed at %x\n", pfh));
				goto error;
			    }
			} else if (pprev->fh_signature == FH_SIGNATURE &&
				   ((unsigned)pfh & PAGEMASK) != sizeof(struct freeheap_s *)) {
			    dprintf(("hpWalk: HP_PREVFREE not set\n"));
			    hpTrash(("trashed addr %x\n", pfh));
			    goto error;
			}
		    }
		/*
		 *  The block should have had one of these signatures!
		 */
		} else {
		    dprintf(("hpWalk: bad block signature\n"));
		    hpTrash(("trashed addr %x\n",pfh));
		    goto error;
		}

		/*
		 *  We are at the end of the heap blocks when we hit one with
		 *  a size of 0 (the end sentinel).
		 */
		if (hpSize(pfh) == 0) {
		    break;
		}

		pprev = pfh;
	    }
	    if ((unsigned)pfh != (unsigned)pend - sizeof(struct busyheap_s) ||
		pfh->fh_signature != BH_SIGNATURE) {
		dprintf(("hpWalk: bad end sentinel\n"));
		hpTrash(("trashed addr between %x and %x\n", pfh, pend));
		goto error;
	    }

	    /*
	     *	We are done walking this segment.  If there is another one, go
	     *	on to it, otherwise, terminate the walk
	     */
	    pseg = pseg->hs_psegnext;
	    if (pseg == 0) {
		break;
	    }
	    pfh = (struct freeheap_s *)(pseg + 1);
	}

	if (hpfParanoid) {
	    /*
	     *	Walk through the free list.
	     *	cbmax is the maximum size of block we should find considering
	     *	the last free list header we ran into.
	     *	cheads is the number of list heads we found.
	     */
	    pprev = pfh = hheap->hi_freelist[0].fl_header.fh_flink;
	    cbmax = hheap->hi_freelist[0].fl_cbmax;
	    cheads = 1;
	    pfhend = &(hheap->hi_freelist[0].fl_header);
	    for (; pfh != pfhend; pfh = pfh->fh_flink) {

		if (pfh->fh_sum != hpSum(pfh, FH_CDWSUM)) {
		    dprintf(("hpWalk: bad free block checksum 2\n"));
		    hpTrash(("trashed addr between %x and %x\n",
			     pfh, &pfh->fh_sum));
		    goto error;
		}
		mmAssert(hpIsFreeSignatureValid(pfh),
			 "hpWalk: bad tiny free sig 2\n");

		/*
		 *  Keep track of the list heads we find (so we know all of them
		 *  are on the list) and make sure they are in acsending order.
		 */
		if ((HHEAP)pfh >= hheap && (HHEAP)pfh < hheap + 1) {
		    if (hpSize(pfh) != 0) {
			dprintf(("hpWalk: bad size of free list head\n"));
			hpTrash(("trashed addr near %x or %x\n", pfh, pprev));
		    }
		    if (&(hheap->hi_freelist[cheads].fl_header) != pfh) {
			dprintf(("hpWalk: free list head out of order\n"));
			hpTrash(("trashed addr probably near %x or %x\n", pfh, &(hheap->hi_freelist[cheads].fl_header)));
			goto error;
		    }
		    cbmax = hheap->hi_freelist[cheads].fl_cbmax;
		    cheads++;

		/*
		 *  Normal free heap block
		 */
		} else {
		    /*
		     *	Look through each segment for the block
		     */
		    for (pseg = (struct heapseg_s *)hheap;
			 pseg != 0; pseg = pseg->hs_psegnext) {

			if ((unsigned)pfh > (unsigned)pseg &&
			    (unsigned)pfh < (unsigned)pseg + pseg->hs_cbreserve) {

			    goto addrok;  /* found the address */
			}
		    }

		    /* If we fall out pfh isn't within any of our segments */
		    dprintf(("hpWalk: free list pointer points outside heap bounds\n"));
		    hpTrash(("trashed addr probably %x\n", pprev));
		    goto error;

		  addrok:
		    if (pfh->fh_signature != FH_SIGNATURE ||
			hpSize(pfh) > cbmax) {

			dprintf(("hpWalk: bad free block on free list\n"));
			hpTrash(("trashed addr probably %x or %x\n", pfh, pprev));
			goto error;
		    }

		    /*
		     *	Since the free list is in sorted order, this block
		     *	should be bigger than the previous one.  This check
		     *	will also pass ok for list heads since they have
		     *	size 0 and everything is bigger than that.
		     */
		    if (hpSize(pprev) > hpSize(pfh)) {
			dprintf(("hpWalk: free list not sorted right\n"));
			hpTrash(("trashed addr probably %x or %x\n", pfh, pprev));
		    }
		}
		pprev = pfh;
	    }
	    if (cheads != hpFREELISTHEADS) {
	       dprintf(("hpWalk: bad free list head count\n"));
	       hpTrash(("trashed somewhere between %x and %x\n", hheap, pend));
	       goto error;
	    }
	}
    }
    return(1);

  error:
    return(0);
}


/***LP	hpSum - compute checksum for a block of memory
 *
 *	This routine XORs all of the DWORDs in a block together and
 *	then XORs that value with a constant.
 *
 *	ENTRY:	p - pointer to block to checksum
 *		cdw - number of dwords to sum
 *	EXIT:	computed sum
 */
unsigned long INTERNAL
hpSum(unsigned long *p, unsigned long cdw)
{
    unsigned long sum;

    for (sum = 0; cdw > 0; cdw--, p++) {
	sum ^= *p;
    }
    return(sum ^ 0x17761965);
}


#ifdef WIN32

/***LP	hpGetAllocator - walk the stack to find who allocated a block
 *
 *	This routine is used by HPAlloc to figure out who owns a block of
 *	memory that is being allocated.  We determine the owner by walking
 *	up the stack and finding the first eip that is not inside the
 *	memory manager or inside any other module that obfuscates who
 *	the real allocator is (such as HMGR, which all GDI allocations
 *	go through).
 *
 *	ENTRY:	none
 *	EXIT:	eip of interesting caller
 */
extern HANDLE APIENTRY LocalAllocNG(UINT dwFlags, UINT dwBytes);

ULONG INTERNAL
hpGetAllocator(void)
{
    ULONG Caller = 0;
    _asm {
	mov	edx,[ebp]	; (edx) = HPAlloc ebp
	mov	eax,[edx+4]	; (eax) = HPAlloc caller

;	See if HPAlloc was called directly or from LocalAlloc or HeapAlloc
;	or PvKernelAlloc

	cmp	eax,offset LocalAllocNG
	jb	hga4		; jump to exit if called directly
	cmp	eax,offset LocalAllocNG + 0x300
	jb	hga20

hga4:
	cmp	eax,offset HeapAlloc
	jb	hga6		; jump to exit if called directly
	cmp	eax,offset HeapAlloc + 0x50
	jb	hga20

hga6:
	cmp	eax,offset PvKernelAlloc
	jb	hga8
	cmp	eax,offset PvKernelAlloc + 0x50
	jb	hga20

hga8:
	cmp	eax,offset PvKernelAlloc0
	jb	hgax
	cmp	eax,offset PvKernelAlloc + 0x50
	ja	hgax

;	When we get here, we know HPAlloc was called by LocalAlloc or HeapAlloc
;	or PvKernelAlloc.  See if PvKernelAlloc was called by NewObject or
;	PlstNew.

hga20:
	mov	edx,[edx]	; (edx) = Local/HeapAlloc ebp
	mov	eax,[edx+4]	; (eax) = Local/HeapAlloc caller

	cmp	eax,offset NewObject
	jb	hga34
	cmp	eax,offset NewObject + 0x50
	jb	hga40

hga34:
	cmp	eax,offset LocalAlloc
	jb	hga36
	cmp	eax,offset LocalAlloc+ 0x200
	jb	hga40

hga36:
	cmp	eax,offset PlstNew
	jb	hgax
	cmp	eax,offset PlstNew + 0x50
	ja	hgax

hga40:
	mov	edx,[edx]	; (edx) = PlstNew/NewObject ebp
	mov	eax,[edx+4]	; (eax) = PlstNew/NewObject caller

	cmp	eax,offset NewNsObject
	jb	hga50
	cmp	eax,offset NewNsObject + 0x50
	jb	hga60
hga50:
	cmp	eax,offset NewPDB
	jb	hga55
	cmp	eax,offset NewPDB + 0x50
	jb	hga60
hga55:
        cmp     eax,offset NewPevt
	jb	hgax
        cmp     eax,offset NewPevt + 0x50
	ja	hgax
hga60:
        mov     edx,[edx]       ; (edx) = NewNsObject/NewPDB/NewPevt ebp
        mov     eax,[edx+4]     ; (eax) = NewNsObject/NewPDB/NewPevt caller
hgax:
	mov	Caller, eax
    }
    return Caller;
}

#ifdef HPMEASURE

#define  FIRSTBLOCK(hheap) ((unsigned)(hheap + 1) + sizeof(struct busyheap_s))

/***EP	HPMeasure - enable measurement of heap activity.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *    pszFile - name of file to place measurement data in.
 *	EXIT:	FALSE if error (couldn't allocate buffer)
 */
BOOL APIENTRY
HPMeasure(HHEAP hheap, LPSTR pszFile)
{
   struct measure_s *pMeasure;
   HANDLE hFile;
   BOOL bSuccess = FALSE;

   if (!hpTakeSem(hheap, NULL, 0)) return FALSE;

   /* Allocate the structure & ensure it is the first block in the heap! */
   pMeasure = (struct measure_s *)HPAlloc(hheap, sizeof(struct measure_s), 0);
   if ((unsigned)pMeasure != (unsigned)FIRSTBLOCK(hheap)) {
      mmError(0, "HPMeasure: Must be called before first heap allocation.\n");
      goto cleanup;
   }

   /* verify the filename is valid and transfer the filename to the buffer */
   hFile = CreateFile(pszFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL, NULL);
   if ((long)hFile == -1) {
      mmError(0, "HPMeasure: The specified file is invalid.\n");
      goto cleanup;
   }
   CloseHandle(hFile);
   lstrcpy(pMeasure->szFile, pszFile);

   /* initialize the buffer variables */
   pMeasure->iCur = 0;

   /* set the measure flag in the heap header */
   hheap->hi_flags |= HP_MEASURE;

   /* Success. */
   bSuccess = TRUE;

cleanup:
   hpClearSem(hheap, 0);
   return bSuccess;
}

/***EP	HPFlush - write out contents of sample buffer.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *	EXIT:	FALSE if error (couldn't write data)
 */
BOOL APIENTRY
HPFlush(HHEAP hheap)
{
   BOOL bResult, bSuccess = FALSE;
   HANDLE hFile;
   unsigned uBytesWritten;
   struct measure_s *pMeasure = (struct measure_s *)FIRSTBLOCK(hheap);

   if (!hpTakeSem(hheap, NULL, 0)) return FALSE;

   /* open the file & seek to the end */
   hFile = CreateFile(pMeasure->szFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, NULL);
   if ((long)hFile == -1) {
      mmError(0, "HPFlush: could not open file.\n");
      goto cleanup;
   }
   SetFilePointer(hFile, 0, 0, FILE_END);

   /* write the data out. */
   bResult = WriteFile(hFile, pMeasure->uSamples,
                       pMeasure->iCur * sizeof(unsigned),
                       &uBytesWritten, NULL);
   CloseHandle(hFile);

   if (!bResult) {
      mmError(0, "HPFlush: could not write to file.\n");
      goto cleanup;
   }

   /* Success. */
   bSuccess = TRUE;

cleanup:
   /* clear the buffer */
   pMeasure->iCur = 0;

   hpClearSem(hheap, 0);
   return bSuccess;
}

/***LP	hpMeasureItem - add item to measurement data
 *
 *	ENTRY:	hheap - pointer to base of heap
 *    uItem - piece of data to record 
 *	EXIT:	FALSE if error (couldn't write buffer)
 */
BOOL PRIVATE
hpMeasureItem(HHEAP hheap, unsigned uItem)
{
   struct measure_s *pMeasure = (struct measure_s *)FIRSTBLOCK(hheap);

   /* empty buffer if it's full */
   if (pMeasure->iCur == SAMPLE_CACHE_SIZE) {
      if (!HPFlush(hheap))
         return FALSE;
   }

   /* Add data to the list */
   pMeasure->uSamples[pMeasure->iCur++] = uItem;

   return TRUE;
}

#endif


/* routine by DonC to help debug heap leaks */
void KERNENTRY
hpDump(HHEAP hheap, char *where) {
    struct freeheap_s *pfh;
    unsigned avail = 0, acnt = 0;
    unsigned used = 0, ucnt = 0;


	/*
	 *  Walk through all the blocks and make sure we get to the end.
	 *  The last block in the heap should be a busy guy of size 0.
	 */
	(unsigned)pfh = (unsigned)hheap + sizeof(struct heapinfo_s);

	for (;; (unsigned)pfh += hpSize(pfh)) {

	    /*
	     *	If the block is free...
	     */
	    if (pfh->fh_signature == FH_SIGNATURE) {

		avail += hpSize(pfh);
		acnt++;

	    /*
	     *	Busy blocks should not be marked HP_FREE and if they are
	     *	marked HP_PREVFREE the previous block better be free.
	     */
	    } else if (pfh->fh_signature == BH_SIGNATURE) {

		used += hpSize(pfh);
		ucnt++;

	    /*
	     *	The block should have had one of these signatures!
	     */
	    } else {
		dprintf(("hpWalk: bad block signature\n"));
		hpTrash(("trashed addr %x\n",pfh));
	    }

	    /*
	     *	We are at the end of the heap blocks when we hit one with
	     *	a size of 0 (the end sentinel).
	     */
	    if (hpSize(pfh) == 0) {
		break;
	    }

	}

	DebugOut((DEB_WARN, "%ld/%ld used, %ld/%ld avail (%s)", used, ucnt, avail, acnt, where));

}
#endif

#endif /* HPDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulategetdiskfreespace.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    EmulateGetDiskFreeSpace.cpp

 Abstract:

    This shim APIHooks GetDiskFreeSpace and determines the true free space on 
    FAT32/NTFS systems. If it is larger than 2GB, the stub will return 2GB as 
    the available free space. If it is smaller than 2GB, it will return the 
    actual free space.

 History:

    10-Nov-99 v-johnwh  Created
    04-Oct-00 linstev   Sanitized for layer

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetDiskFreeSpace)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetDiskFreeSpaceA)
    APIHOOK_ENUM_ENTRY(GetDiskFreeSpaceW)
APIHOOK_ENUM_END

#define WIN9X_TRUNCSIZE 2147483648   // 2 GB


// Has this module called DPF yet, prevents millions of DPF calls
BOOL g_bDPF = FALSE;

BOOL 
APIHOOK(GetDiskFreeSpaceA)(
    LPCSTR  lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )
/*++

 This stub function calls GetDiskFreeSpaceEx to determine the true free space 
 on FAT32/NTFS systems. If it is larger than 2GB, the stub will return 2GB as 
 the available free space. If it is smaller than 2GB, it will return the actual
 free space.

--*/
{
    LONG            lRet;
    ULARGE_INTEGER  liFreeBytesAvailableToCaller;
    ULARGE_INTEGER  liTotalNumberOfBytes;
    ULARGE_INTEGER  liTotalNumberOfFreeBytes;
    DWORD           dwFreeClusters;
    DWORD           dwOldSectorsPerClusters;
    DWORD           dwOldBytesPerSector;
        
    //
    // Call the original API
    //
    lRet = ORIGINAL_API(GetDiskFreeSpaceA)(
                    lpRootPathName, 
                    lpSectorsPerCluster, 
                    lpBytesPerSector, 
                    lpNumberOfFreeClusters, 
                    lpTotalNumberOfClusters);

    //
    // Find out how big the drive is.
    //
    if (GetDiskFreeSpaceExA(lpRootPathName,
                            &liFreeBytesAvailableToCaller,
                            &liTotalNumberOfBytes,
                            &liTotalNumberOfFreeBytes) == FALSE) {        
        return lRet;
    }

    if ((liFreeBytesAvailableToCaller.LowPart > (DWORD) WIN9X_TRUNCSIZE) ||
        (liFreeBytesAvailableToCaller.HighPart > 0)) {
        //
        // Drive bigger than 2GB. Give them the 2gb limit from Win9x
        //
        *lpSectorsPerCluster     = 0x00000040;
        *lpBytesPerSector        = 0x00000200;
        *lpNumberOfFreeClusters  = 0x0000FFF6;
        *lpTotalNumberOfClusters = 0x0000FFF6;

        lRet = TRUE;
    } else {
        //
        // For drives less than 2gb, convert the disk geometry so it looks like Win9x.
        //
        dwOldSectorsPerClusters = *lpSectorsPerCluster;
        dwOldBytesPerSector     = *lpBytesPerSector;

        *lpSectorsPerCluster = 0x00000040;
        *lpBytesPerSector    = 0x00000200;

        //
        // Calculate the free and used cluster values now.
        //
        *lpNumberOfFreeClusters = (*lpNumberOfFreeClusters * 
            dwOldSectorsPerClusters * 
            dwOldBytesPerSector) / (0x00000040 * 0x00000200);
        
        *lpTotalNumberOfClusters = (*lpTotalNumberOfClusters * 
            dwOldSectorsPerClusters * 
            dwOldBytesPerSector) / (0x00000040 * 0x00000200);
    }

    if (!g_bDPF)
    {
        g_bDPF = TRUE;

        LOGN(
            eDbgLevelInfo,
            "[GetDiskFreeSpaceA] Called. Returning <=2GB free space");
    }

    return lRet;
}

BOOL 
APIHOOK(GetDiskFreeSpaceW)(
    LPCWSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )
/*++

 This stub function calls GetDiskFreeSpaceEx to determine the true free space 
 on FAT32/NTFS systems. If it is larger than 2GB, the stub will return 2GB as 
 the available free space. If it is smaller than 2GB, it will return the actual
 free space.

--*/
{
    LONG            lRet;
    ULARGE_INTEGER  liFreeBytesAvailableToCaller;
    ULARGE_INTEGER  liTotalNumberOfBytes;
    ULARGE_INTEGER  liTotalNumberOfFreeBytes;
    DWORD           dwFreeClusters;
    DWORD           dwOldSectorsPerClusters;
    DWORD           dwOldBytesPerSector;
        
    //
    // Call the original API
    //
    lRet = ORIGINAL_API(GetDiskFreeSpaceW)(
                    lpRootPathName, 
                    lpSectorsPerCluster, 
                    lpBytesPerSector, 
                    lpNumberOfFreeClusters, 
                    lpTotalNumberOfClusters);

    //
    // Find out how big the drive is.
    //
    if (GetDiskFreeSpaceExW(lpRootPathName,
                            &liFreeBytesAvailableToCaller,
                            &liTotalNumberOfBytes,
                            &liTotalNumberOfFreeBytes) == FALSE) {        
        return lRet;
    }

    if ((liFreeBytesAvailableToCaller.LowPart > (DWORD) WIN9X_TRUNCSIZE) ||
        (liFreeBytesAvailableToCaller.HighPart > 0)) {
        //
        // Drive bigger than 2GB. Give them the 2gb limit from Win9x
        //
        *lpSectorsPerCluster     = 0x00000040;
        *lpBytesPerSector        = 0x00000200;
        *lpNumberOfFreeClusters  = 0x0000FFF6;
        *lpTotalNumberOfClusters = 0x0000FFF6;

        lRet = TRUE;
    } else {
        //
        // For drives less than 2gb, convert the disk geometry so it looks like Win9x.
        //
        dwOldSectorsPerClusters = *lpSectorsPerCluster;
        dwOldBytesPerSector     = *lpBytesPerSector;

        *lpSectorsPerCluster = 0x00000040;
        *lpBytesPerSector    = 0x00000200;

        //
        // Calculate the free and used cluster values now.
        //
        *lpNumberOfFreeClusters = (*lpNumberOfFreeClusters * 
            dwOldSectorsPerClusters * 
            dwOldBytesPerSector) / (0x00000040 * 0x00000200);
        
        *lpTotalNumberOfClusters = (*lpTotalNumberOfClusters * 
            dwOldSectorsPerClusters * 
            dwOldBytesPerSector) / (0x00000040 * 0x00000200);
    }

    if (!g_bDPF)
    {
        g_bDPF = TRUE;

        LOGN(
            eDbgLevelInfo,
            "[GetDiskFreeSpaceW] Called. Returning <=2GB free space");
    }

    return lRet;
}



/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetDiskFreeSpaceA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetDiskFreeSpaceW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateheap_heap.h ===
/*
 *	heap.h - structures and equates for the Windows 32-bit heap
 *
 *  Origin: Chicago
 *
 *  Change history:
 *
 *  Date       Who	  Description
 *  ---------  ---------  -------------------------------------------------
 *  1991       BrianSm	  Created
 */

#ifdef DEBUG
#define HPDEBUG 1
#endif
#ifdef PM386
#define WIN32
#endif

#define HPNOTTRUSTED 1	/* enable parameter checking */

/***LT	busyblock_s - busy heap block header structure
 *
 *	This structure is stored at the head of every busy (not free) heap
 *	block.
 *
 *	The bh_size field is in bytes and includes the size of the
 *	heap header and any slop at the end of the block that might have
 *	been included because of the heap granularity, or to keep us
 *	from leaving a block too small to hold a free heap header.
 *
 *	bh_size is also used as a forward link to the next heap block.
 *
 *	The low two bits of the bh_size field are used to hold flags
 *	(BP_FREE must be clear and HP_PREVFREE is optionally set).
 */
#ifndef HPDEBUG
struct busyheap_s {
	unsigned long	bh_size;	/* block size + flags in low 2 bits */
};
#else
struct busyheap_s {
	unsigned long	bh_size;	/* block size + flags in low 2 bits */
	unsigned long	bh_eip; 	/* EIP of allocator */
	unsigned short	bh_tid; 	/* thread id of allocator */
	unsigned short	bh_signature;	/* signature (should be BH_SIGNATURE)*/
	unsigned long	bh_sum; 	/* checksum of this structure */
};
#endif

/*XLATOFF*/
#define BH_SIGNATURE	0x4842		/* busy heap block signature (BH) */
/*XLATON*/

#define BH_CDWSUM	3		/* count of dwords to sum in struct */


/***LT	freeblock_s - free heap block header structure
 *
 *	This structure is stored at the head of every free block on the
 *	heap.  In the last dword of every free heap block is a pointer
 *	the this structure.
 *
 *	The fh_size field is in bytes and includes the size of the
 *	heap header and any slop at the end of the block that might have
 *	been included because of the heap granularity, or to keep us
 *	from leaving a block too small to hold a free heap header.
 *
 *	fh_size is also used as a forward link to the next heap block.
 *
 *	The low two bits of the fh_size field are used to hold flags
 *	(HP_FREE must be set and HP_PREVFREE must be clear).
 */
#ifndef HPDEBUG
struct freeheap_s {
	unsigned long	   fh_size;	/* block size + flags in low 2 bits */
	struct freeheap_s *fh_flink;	/* forward link to next free block */
	struct freeheap_s *fh_blink;	/* back link to previous free block */
};
#else
struct freeheap_s {
	unsigned long	   fh_size;	/* block size + flags in low 2 bits */
	struct freeheap_s *fh_flink;	/* forward link to next free block */
	unsigned short	   fh_pad;	/* unused */
	unsigned short	   fh_signature;/* signature (should be FH_SIGNATURE)*/
	struct freeheap_s *fh_blink;	/* back link to previous free block */
	unsigned long	   fh_sum;	/* checksum of this structure */
};
#endif

/*XLATOFF*/
#define FH_SIGNATURE	0x4846		/* free heap block signature (FH) */
/*XLATON*/

#define FH_CDWSUM	4		/* count of dwords to sum in struct */

/*
 *	Equates common to all heap blocks.
 *
 *	HP_FREE and HP_PREVFREE (HP_FLAGS) are stored in the low two
 *	bits of the fh_ and bh_size field.
 *	The signature is stored in the high three bits of the size.
 */
#define HP_FREE 	0x00000001	/* block is free */
#define HP_PREVFREE	0x00000002	/* previous block is free */
#define HP_FLAGS	0x00000003	/* mask for all the flags */
#define HP_SIZE 	0x0ffffffc	/* mask for clearing flags */
#define HP_SIGBITS	0xf0000000	/* bits used for signature */
#define HP_SIGNATURE	0xa0000000	/* valid value of signature */

/*
 *	Misc heap equates
 */
#define hpGRANULARITY	4		/* granularity for heap allocations */
#define hpGRANMASK	(hpGRANULARITY - 1)		/* for rounding */
/*XLATOFF*/
#define hpMINSIZE	(sizeof(struct freeheap_s)+sizeof(struct freeheap_s *))
			/* min block size */

#define hpMAXALLOC	(HP_SIZE - 100) /* biggest allocatable heap block */

/* overhead for a new heap segment (header plus end sentinel) */
#define hpSEGOVERHEAD	(sizeof(struct busyheap_s) + sizeof(struct heapseg_s))

/* default reserved size of new segments added to growable heaps */
#define hpCBRESERVE	(4*1024*1024)


/*XLATON*/


/*
 * Exported flags for heap calls
 */
#ifdef WIN32
#define HP_ZEROINIT	0x40	/* zero initialize block on HP(Re)Alloc */
#define HP_MOVEABLE	0x02	/* block can be moved (HP(Re)Alloc) */
#define HP_NOCOPY	0x20	/* don't copy data on HPReAlloc */
#define HP_NOSERIALIZE	0x01	/* don't serialize heap access */
#define HP_EXCEPT	0x04	/* generate exceptions on error */
#ifdef HPMEASURE     
#define HP_MEASURE	0x80	/* enable heap measurement */
#endif

#else

#define HP_ZEROINIT	0x01	/* zero initialize block on HP(Re)Alloc */
#define HP_NOSERIALIZE	0x08	/* don't serialize heap access (HPInit) */
#define HP_NOCOPY	0x04	/* don't copy data on HPReAlloc */
#define HP_MOVEABLE	0x10	/* allow moving on HPReAlloc */
#define HP_LOCKED	0x80	/* put heap in locked memory (HPInit) */
#endif
#define HP_FIXED	0x00	/* block is at a fixed address (HPAlloc) */
#define HP_GROWABLE	0x40	/* heap can grow beyond cbreserve (HPInit) */
/*
 *  Note that flags above 0x80 will not be stored into the heap header in
 *  HPInit calls because the flags field in the header is only a byte
 */
#define HP_INITSEGMENT 0x100	/* just initialize a heap segment (HPInit) */
#define HP_DECOMMIT    0x200	/* decommit pages in free block (hpFreeSub) */
#define HP_GROWUP      0x400	/* waste last page of heap (HPInit) */

/*XLATOFF*/

/***LP	hpSize - pull size field from heap header
 *
 *	This routine depends on the size field being the first
 *	dword in the header.
 *
 *	ENTRY:	ph - pointer to heap header
 *	EXIT:	count of bytes in block (counting header).
 */
#define hpSize(ph) (*((unsigned long *)(ph)) & HP_SIZE)

/***LP	hpSetSize - set the size parameter in a heap header
 *
 *	This routine depends on the size field being the first
 *	dword in the header.
 *
 *	ENTRY:	ph - pointer to busy heap header
 *		cb - count of bytes (should be rounded using hpRoundUp)
 *	EXIT:	size is set in heap header
 */
#define hpSetSize(ph, cb) (((struct busyheap_s *)(ph))->bh_size =  \
		     ((((struct busyheap_s *)(ph))->bh_size & ~HP_SIZE) | (cb)))

/* the compiler used to do a better version with this macro than the above,
 * but not any more
#define hpSetSize2(ph, cb) *(unsigned long *)(ph) &= ~HP_SIZE; \
			   *(unsigned long *)(ph) |= (cb);
 */

/***LP	hpSetBusySize - set the entire bh_size dword for a busy block
 *
 *	This macro will set the bh_size field of the given heap header
 *	to the given size as well as setting the HP_SIGNATURE and clearing
 *	any HP_FREE or HP_PREVFREE bits.
 *
 *	ENTRY:	ph - pointer to busy heap header
 *		cb - count of bytes (should be rounded using hpRoundUp)
 *	EXIT:	bh_size field is initialized
 */
#define hpSetBusySize(ph, cb)	((ph)->bh_size = ((cb) | HP_SIGNATURE))


/***LP	hpSetFreeSize - set the entire fh_size dword for a free block
 *
 *	This macro will set the fh_size field of the given heap header
 *	to the given size as well as setting the HP_SIGNATURE and HP_FREE
 *	and clearing HP_PREVFREE.
 *
 *	ENTRY:	ph - pointer to free heap header
 *		cb - count of bytes (should be rounded using hpRoundUp)
 *	EXIT:	bh_size field is initialized
 */
#define hpSetFreeSize(ph, cb)	((ph)->fh_size = ((cb) | HP_SIGNATURE | HP_FREE))


/***LP	hpIsBusySignatureValid - check a busy heap block's signature
 *
 *	This macro checks the tiny signature (HP_SIGNATURE) in the bh_size
 *	field to see if it is set properly and makes sure that the HP_FREE
 *	bit is clear.
 *
 *	ENTRY:	ph - pointer to a busy heap header
 *	EXIT:	TRUE if signature is ok, else FALSE
 */
#define hpIsBusySignatureValid(ph) \
		    (((ph)->bh_size & (HP_SIGBITS | HP_FREE)) == HP_SIGNATURE)


/***LP	hpIsFreeSignatureValid - check a free heap block's signature
 *
 *	This macro checks the tiny signature (HP_SIGNATURE) in the fh_size
 *	field to see if it is set properly and makes sure that the HP_FREE
 *	bit is also set and HP_PREVFREE is clear.
 *
 *	ENTRY:	ph - pointer to a free heap header
 *	EXIT:	TRUE if signature is ok, else FALSE
 */
#define hpIsFreeSignatureValid(ph) \
	  (((ph)->fh_size & (HP_SIGBITS | HP_FREE | HP_PREVFREE)) == \
						     (HP_SIGNATURE | HP_FREE))


/***LP	hpRoundUp - round up byte count to appropriate heap block size
 *
 *	Heap blocks have a minimum size of hpMINSIZE and hpGRANULARITY
 *	granularity.  This macro also adds on size for the heap header.
 *
 *	ENTRY:	cb - count of bytes
 *	EXIT:	count rounded up to hpGANULARITY boundary
 */
#define hpRoundUp(cb)	\
      max(hpMINSIZE,	\
	  (((cb) + sizeof(struct busyheap_s) + hpGRANMASK) & ~hpGRANMASK))


/*XLATON*/

/***LK	freelist_s - heap free list head
 */
struct freelist_s {
	unsigned long	  fl_cbmax;	/* max size block in this free list */
	struct freeheap_s fl_header;	/* pseudo heap header as list head */
};
#define hpFREELISTHEADS 4	/* number of free list heads in heapinfo_s */

/***LK	heapinfo_s - per-heap information (stored at start of heap)
 *
 */
struct heapinfo_s {

	/* These first three fields must match the fields of heapseg_s */
	unsigned long	hi_cbreserve;		/* bytes reserved for heap */
	struct heapseg_s *hi_psegnext;		/* pointer to next heap segment*/

	struct freelist_s hi_freelist[hpFREELISTHEADS]; /* free list heads */
#ifdef WIN32
	struct heapinfo_s *hi_procnext; 	/* linked list of process heaps */
        CRST    *hi_pcritsec;                   /* pointer to serialization obj*/
	CRST    hi_critsec;		        /* serialize access to heap */
#ifdef HPDEBUG
	unsigned char	hi_matchring0[(76-sizeof(CRST))]; /* pad so .mh command works */
#endif
#else
	struct _MTX    *hi_pcritsec;		/* pointer to serialization obj*/
	struct _MTX	hi_critsec;		/* serialize access to heap */
#endif
#ifdef HPDEBUG
	unsigned long	hi_thread;		/* thread pointer of thread
						 * inside heap code */
	unsigned long	hi_eip; 		/* EIP of heap's creator */
	unsigned long	hi_sum; 		/* checksum of this structure*/
	unsigned short	hi_tid; 		/* thread ID of heap's creator*/
	unsigned short	hi_pad1;		/* unused */
#endif
	unsigned char	hi_flags;		/* HP_SERIALIZE, HP_LOCKED */
	unsigned char	hi_pad2;		/* unused */
	unsigned short	hi_signature;		/* should be HI_SIGNATURE */
};

/*
 * Heap Measurement functions
 */
#define  HPMEASURE_FREE    0x8000000L

#define  SAMPLE_CACHE_SIZE 1024

struct measure_s {
   char  szFile[260];
   unsigned iCur;
   unsigned uSamples[SAMPLE_CACHE_SIZE];
};

/*XLATOFF*/
#define HI_SIGNATURE  0x4948	    /* heapinfo_s signature (HI) */
/*XLATON*/

#define HI_CDWSUM  1		    /* count of dwords to sum */

typedef struct heapinfo_s *HHEAP;


/***LK	heapseg_s - per-heap segment structure
 *
 *	Growable heaps can have multiple discontiguous sections of memory
 *	allocated to them.  Each is headed by one of these structures.	The
 *	first segment is special, in that it has a full heapinfo_s structure,
 *	but the first fields of heapinfo_s match heapseg_s, so it can be
 *	treated as just another segment when convenient.
 */
struct heapseg_s {
	unsigned long	hs_cbreserve;	/* bytes reserved for this segment */
	struct heapseg_s *hs_psegnext;	/* pointer to next heap segment*/
};
/* XLATOFF */

/* smallest possible heap */
#define hpMINHEAPSIZE	(sizeof(struct heapinfo_s) + hpMINSIZE + \
			 sizeof(struct busyheap_s))

/***LP	hpRemove - remove item from free list
 *
 *	ENTRY:	pfh - pointer to free heap block to remove from list
 *	EXIT:	none
 */
#define hpRemoveNoSum(pfh)				\
	(pfh)->fh_flink->fh_blink = (pfh)->fh_blink;	\
	(pfh)->fh_blink->fh_flink = (pfh)->fh_flink;

#ifdef HPDEBUG
#define hpRemove(pfh)	hpRemoveNoSum(pfh);			\
			(pfh)->fh_flink->fh_sum =		\
			    hpSum((pfh)->fh_flink, FH_CDWSUM);	\
			(pfh)->fh_blink->fh_sum =		\
			    hpSum((pfh)->fh_blink, FH_CDWSUM);
#else
#define hpRemove(pfh)	hpRemoveNoSum(pfh)
#endif

/***LP	hpInsert - insert item onto the free list
 *
 *	ENTRY:	pfh - free heap block to insert onto the list
 *		pfhprev - insert pfh after this item
 *	EXIT:	none
 */
#define hpInsertNoSum(pfh, pfhprev)		\
	(pfh)->fh_flink = (pfhprev)->fh_flink;	\
	(pfh)->fh_flink->fh_blink = (pfh);	\
	(pfh)->fh_blink = (pfhprev);		\
	(pfhprev)->fh_flink = (pfh)

#ifdef HPDEBUG
#define hpInsert(pfh, pfhprev)	hpInsertNoSum(pfh, pfhprev);	\
			(pfh)->fh_flink->fh_sum =		\
			    hpSum((pfh)->fh_flink, FH_CDWSUM);	\
			(pfhprev)->fh_sum =			\
			    hpSum((pfhprev), FH_CDWSUM)
#else
#define hpInsert(pfh, pfhprev)	hpInsertNoSum(pfh, pfhprev)
#endif

#ifdef WIN32
#define INTERNAL
#endif

/*
 * critical section macros to be used by all internal heap functions
 */
#ifndef WIN32
    #define hpEnterCriticalSection(hheap) mmEnterMutex(hheap->hi_pcritsec)
    #define hpLeaveCriticalSection(hheap) mmLeaveMutex(hheap->hi_pcritsec)
    #define hpInitializeCriticalSection(hheap) \
        hheap->hi_pcritsec = &(hheap->hi_critsec); \
        mmInitMutex(hheap->hi_pcritsec)
#else
    #define hpEnterCriticalSection(hheap) EnterCrst(hheap->hi_pcritsec)
    #define hpLeaveCriticalSection(hheap) LeaveCrst(hheap->hi_pcritsec)
    //BUGBUG: removed special case hheapKernel code
    #define hpInitializeCriticalSection(hheap)              \
        {                                        \
            hheap->hi_pcritsec = &(hheap->hi_critsec);  \
            InitCrst(hheap->hi_pcritsec);               \
        }
#endif

/*
 * Exported heap functions
 */
extern HHEAP INTERNAL HPInit(void *hheap, void *pmem, unsigned long cbreserve,
			     unsigned long flags);
extern void * INTERNAL HPAlloc(HHEAP hheap, unsigned long cb,
			     unsigned long flags);

extern void * INTERNAL HPReAlloc(HHEAP hheap, void *pblock, unsigned long cb,
			       unsigned long flags);
#ifndef WIN32
extern unsigned INTERNAL HPFree(HHEAP hheap, void *lpMem);
extern unsigned INTERNAL HPSize(HHEAP hheap, void *lpMem);
extern HHEAP INTERNAL  HPClone(struct heapinfo_s *hheap, struct heapinfo_s *pmem);
#endif


/*
 * Local heap functions
 */
extern void INTERNAL hpFreeSub(HHEAP hheap, void *pblock, unsigned cb,
			       unsigned flags);
extern unsigned INTERNAL hpCommit(unsigned page, int npages, unsigned flags);
extern unsigned INTERNAL hpCarve(HHEAP hheap, struct freeheap_s *pfh,
				unsigned cb, unsigned flags);
#ifdef WIN32
extern unsigned INTERNAL hpTakeSem(HHEAP hheap, void *pbh, unsigned flags);
extern void INTERNAL hpClearSem(HHEAP hheap, unsigned flags);
#else
extern unsigned INTERNAL hpTakeSem2(HHEAP hheap, void *pbh);
extern void INTERNAL hpClearSem2(HHEAP hheap);
#endif

/*
 * Debug functions
 */
#ifdef HPDEBUG

extern unsigned INTERNAL hpWalk(HHEAP hheap);
extern char INTERNAL hpfWalk;
extern char INTERNAL hpfTrashStop;
extern char INTERNAL hpfParanoid;
extern char	    mmfErrorStop;
extern unsigned long INTERNAL hpGetAllocator(void);
extern unsigned long INTERNAL hpSum(PVOID p, unsigned long cdw);

#else

#define hpWalk(hheap) 1

#endif

#ifdef WIN32
#ifdef HPDEBUG
#define DebugStop() { _asm int 3 }
#define mmError(rc, string)    vDebugOut(mmfErrorStop ? DEB_ERR : DEB_WARN, string);SetError(rc)
#define mmAssert(exp, psz)     if (!(exp)) vDebugOut(DEB_ERR, psz)
#else
#define mmError(rc, string) SetError(rc)
#define mmAssert(exp, psz)
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateheap_kernel32.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    kernel32.h

 Abstract:
     
    The heap manager is identical (exactly) to the Win9x heap manager. The code 
    is the same and the corresponding conversion code and defines are in 
    support.c and kernel32.h The exact win9x sources are in heap.c and lmem.c. 
    All the heap functions come in heap.c and the local/global functions come 
    in lmem.c.

    The SHIM code comes in EmulateHeap.cpp. This hooks the heap calls and calls 
    the Win9x code to emulate the Win9x heap. After the heap management by the 
    Win9x heap, the underneath calls to the Virtual memory functions are handled 
    in support.c. The only difference comes in the way Win9x handles 'SHARED' 
    and "PRIVATE' heaps.Win9x creates the process default heap as a SHARED heap 
    and uses it in kernel mode too. We also create it as a SHARED heap but do 
    not share it with the kernel. Win9x links all the PRIVATE heaps for the 
    process in the PDB data structure. We fake this structure with only the 
    required elements and allow the Win9x code to handle this structure.
     
 Notes:

    None.    

 History:
           
    11/16/2000 prashkud & linstev Created 
 
--*/

#ifndef _KERNEL32_H_
#define _KERNEL32_H_

#include "windows.h"

#define INTERNAL
#define EXTERNAL
#define KERNENTRY       WINAPI

#define PAGESHIFT	12
#define PAGESIZE	(1 << PAGESHIFT)
#define PAGEMASK	(PAGESIZE - 1)

#define CRST            CRITICAL_SECTION

//BUGBUG - did this to prevent build error, but should make no difference
#define typObj          LockCount
#define typObjCrst      0

#define InitCrst(_x_)   InitializeCriticalSection(_x_)
#define DestroyCrst(_x_) DeleteCriticalSection(_x_)
#define EnterCrst(_x_)  EnterCriticalSection(_x_)
#define LeaveCrst(_x_)  LeaveCriticalSection(_x_)
#define Assert(_x_)     

/* PageReserve flags */
#define PR_FIXED        0x00000008	/* don't move during PageReAllocate */
#define PR_4MEG         0x00000001	/* allocate on 4mb boundary */
#define PR_STATIC       0x00000010	/* see PageReserve documentation */

/* PageCommit default pager handle values */
#define PD_ZEROINIT     0x00000001	/* swappable zero-initialized pages */
#define PD_NOINIT       0x00000002	/* swappable uninitialized pages */
#define PD_FIXEDZERO	0x00000003      /* fixed zero-initialized pages */
#define PD_FIXED        0x00000004	/* fixed uninitialized pages */

/* PageCommit flags */
#define PC_FIXED        0x00000008	/* pages are permanently locked */
#define PC_LOCKED       0x00000080	/* pages are made present and locked*/
#define PC_LOCKEDIFDP	0x00000100      /* pages are locked if swap via DOS */
#define PC_WRITEABLE	0x00020000      /* make the pages writeable */
#define PC_USER         0x00040000	/* make the pages ring 3 accessible */
#define PC_INCR         0x40000000	/* increment "pagerdata" each page */
#define PC_PRESENT      0x80000000	/* make pages initially present */
#define PC_STATIC       0x20000000	/* allow commit in PR_STATIC object */
#define PC_DIRTY        0x08000000      /* make pages initially dirty */
#define PC_CACHEDIS     0x00100000      /* Allocate uncached pages - new for WDM */
#define PC_CACHEWT      0x00080000      /* Allocate write through cache pages - new for WDM */
#define PC_PAGEFLUSH    0x00008000      /* Touch device mapped pages on alloc - new for WDM */

/* PageReserve arena values */
#define PR_PRIVATE      0x80000400	/* anywhere in private arena */
#define PR_SHARED       0x80060000	/* anywhere in shared arena */
#define PR_SYSTEM       0x80080000	/* anywhere in system arena */

// This can be anything since it only affects flags which are ignored
#define MINSHAREDLADDR  1
// This is used for validation, which is identical on NT - no allocation can be at > 0x7fffffff
#define MAXSHAREDLADDR	0x7fffffff
// This is used for validation, old value was 0x00400000, but now just make it 1
#define MINPRIVATELADDR	1
// Used to determine if a heap is private, was 0x3fffffff, but now make it 0x7fffffff
#define MAXPRIVATELADDR	0x7fffffff

extern ULONG PageCommit(ULONG page, ULONG npages, ULONG hpd, ULONG pagerdata, ULONG flags);
extern ULONG PageDecommit(ULONG page, ULONG npages, ULONG flags);
extern ULONG PageReserve(ULONG page, ULONG npages, ULONG flags);
#define PageFree(_x_, _y_) VirtualFree((LPVOID) _x_, 0, MEM_RELEASE)

#define PvKernelAlloc0(_x_) VirtualAlloc(0, _x_, MEM_COMMIT, PAGE_READWRITE)
#define FKernelFree(_x_)    VirtualFree((LPVOID) _x_, 0, MEM_RELEASE)

extern CRITICAL_SECTION *NewCrst();
extern VOID DisposeCrst(CRITICAL_SECTION *lpcs);

#define FillBytes(a, b, c)    memset(a, c, b)

#define SetError(_x_)   SetLastError(_x_)
#define dprintf(_x_)    OutputDebugStringA(_x_)
#define DebugOut(_x_) 
#define DEB_WARN        0
#define DEB_ERR         1

#include "EmulateHeap_heap.h"

#define HeapSize         _HeapSize
#define HeapCreate       _HeapCreate
#define HeapDestroy      _HeapDestroy
#define HeapReAlloc      _HeapReAlloc
#define HeapAlloc        _HeapAlloc
#define HeapFree         _HeapFree
#define HeapFreeInternal _HeapFree
#define LocalReAlloc     _LocalReAlloc
#define LocalAllocNG     _LocalAlloc
#define LocalFreeNG      _LocalFree 
#define LocalLock        _LocalLock
#define LocalCompact     _LocalCompact
#define LocalShrink      _LocalShrink
#define LocalUnlock      _LocalUnlock
#define LocalSize        _LocalSize
#define LocalHandle      _LocalHandle
#define LocalFlags       _LocalFlags

//BUGBUG: don't think we need these - looks like they're required for kernel heap support
#define EnterMustComplete()
#define LeaveMustComplete()

// For lmem.c
typedef struct _pdb {
    struct heapinfo_s *hheapLocal;	// DON'T MOVE THIS!!! handle to heap in private memeory
    struct lhandle_s *plhFree;		// Local heap free handle list head ptr
    struct heapinfo_s *hhi_procfirst;	// linked list of heaps for this process
    struct lharray_s *plhBlock;		// local heap lhandle blocks
} PDB, *PPDB;

extern PDB **pppdbCur;
#define GetCurrentPdb() (*pppdbCur)

extern HANDLE hheapKernel;
extern HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
extern DWORD APIENTRY HeapSize(HHEAP hheap, DWORD flags, LPSTR lpMem);
extern BOOL APIENTRY HeapFreeInternal(HHEAP hheap, DWORD flags, LPSTR lpMem);

#define HEAP_SHARED  0x04000000              // put heap in shared memory
#define HEAP_LOCKED  0x00000080              // put heap in locked memory

#ifdef WINBASEAPI 
    #undef WINBASEAPI 
    #define WINBASEAPI 
#endif

#endif // _KERNEL32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateheap_support.c ===
#include "EmulateHeap_kernel32.h"

HANDLE hheapKernel = 0;

PDB pdbCur;
PDB *ppdbCur = &pdbCur;
PDB **pppdbCur = &ppdbCur;

/***SN	PageCommit - commit physical pages to a specified linear address
 *
 *	The entire target region must have been reserved by a single previous
 *	call to PageReserve.
 *
 *	If PC_LOCKED, PC_LOCKEDIFDP, or PC_FIXED are passed into PageCommit,
 *	then all of the pages in the specified range must currently uncommitted.
 *	If none of those flags are specified, then any existing
 *	committed pages in the range will be unaffected by this call and an
 *	error will not be returned.  However, even though it is allowed,
 *	calling PageCommit on a range containing already committed memory
 *	should be avoided because it is waste of time.
 *
 *	ENTRY:	page - base virtual page number to start commit at
 *		npages - number of pages to commit
 *		hpd - handle to pager descriptor (returned from PagerRegister)
 *		      or one of these special value:
 *			PD_ZEROINIT - swappable zero-initialized
 *			PD_NOINIT - swappable uninitialized
 *			PD_FIXED - fixed uninitialized (must also pass in
 *				   PC_FIXED flag)
 *			PD_FIXEDZERO - fixed zero-initialized (must also pass
 *				       in PC_FIXED flag)
 *		pagerdata - a single dword to be stored with the page(s) for
 *			    use by the pager.  If one of the special pagers
 *			    listed above is used for the "hpd" parameter, then
 *			    this parameter is reserved and should be zero.
 *		flags - PC_FIXED - page are created permanently locked
 *			PC_LOCKED - pages are created present and locked
 *			PC_LOCKEDIFDP - page are locked if swapping is via DOS
 *			PC_STATIC - allow commit in AR_STATIC object
 *			PC_USER - make the pages ring 3 accessible
 *			PC_WRITEABLE - make the pages writeable
 *			PC_INCR - increment "pagerdata" once for each page.  If
 *				  one of the special pagers listed above is used
 *				  for the "hpd" parameter, then this flags
 *				  should not be specified.
 *			PC_PRESENT - make the pages present as they are committed
 *				(not needed with PC_FIXED or PC_LOCKED)
 *			PC_DIRTY - mark the pages as dirty as they are committed
 *				(ignored if PC_PRESENT, PC_FIXED or PC_LOCKED
 *				 isn't specified)
 *	EXIT:	non-zero if success, 0 if failure
 */
ULONG EXTERNAL
PageCommit(ULONG page, ULONG npages, ULONG hpd, ULONG pagerdata, ULONG flags)
{
    return (ULONG_PTR) VirtualAlloc((LPVOID)(page * PAGESIZE), npages * PAGESIZE, MEM_COMMIT, PAGE_READWRITE);
}

/***SN	PageDecommit - decommit physical pages from a specific address
 *
 *	The pages must be within an address range previously allocated
 *	by a single call to PageReserve.  Though it is not an error to
 *	call PageDecommit on a range including pages which are already
 *	decommitted, such behavoir is discouraged because it is a waste of time.
 *
 *	ENTRY:	page - virtual page number of first page to decommit
 *		npages - number of pages to decommit
 *		flags - PC_STATIC - allow decommit in AR_STATIC object
 *	EXIT:	non-zero if success, else 0 if failure
 */
ULONG EXTERNAL
PageDecommit(ULONG page, ULONG npages, ULONG flags)
{
    // PREFAST - This generates a PREFAST error asking us to use the MEM_RELEASE flag
    //           We do not want that and hence this error can be ignored.
    return (ULONG) VirtualFree((LPVOID)(page * PAGESIZE), npages * PAGESIZE, MEM_DECOMMIT);
}
    
/***SN	PageReserve - allocate linear address space in the current context
 *
 *	The address range allocated by PageReserve is not backed by any
 *	physical memory.  PageCommit, PageCommitPhys, or PageCommitContig
 *	should be called before actually touching a reserved region.
 *
 *	Optionally, page permission flags (PC_WRITEABLE and PC_USER) may be
 *	passed into this service.  The flags are not acted on in any way
 *	(because uncommitted memory is always inaccessible) but they are stored
 *	internally by the memory manager.  The PageQuery service returns these
 *	permissions in the mbi_AllocationProtect field of its information
 *	structure.
 *
 *	ENTRY:	page - requested base address of object (virtual page number)
 *		       or a special value:
 *			PR_PRIVATE - anywhere in current ring 3 private region
 *			PR_SHARED - anywhere in the ring 3 shared region
 *			PR_SYSTEM - anywhere in the system region
 *		npages - number of pages to reserve
 *		flags - PR_FIXED - so PageReAllocate will not move object
 *			PR_STATIC - don't allow commits, decommits or frees
 *				    unless *_STATIC flag is passed in
 *			PR_4MEG - returned address must be 4mb aligned
 *				  (this flag is ignored if a specific address
 *				   is requested by the "page" parameter)
 *			PC_WRITEABLE, PC_USER - optional, see above
 *
 *	EXIT:	linear address of allocated object or -1 if error
 */
ULONG EXTERNAL
PageReserve(ULONG page, ULONG npages, ULONG flags)
{
    ULONG uRet;

    if ((page == PR_PRIVATE) ||
        (page == PR_SHARED) ||
        (page == PR_SYSTEM))
    {
        page = 0;
    }

    uRet = (ULONG) VirtualAlloc((LPVOID)(page * PAGESIZE), npages * PAGESIZE, MEM_RESERVE, PAGE_READWRITE);

    if (!uRet)
    {
        uRet = -1;
    }

    return uRet;
}

/***SO	PageFree - De-reserved and de-commit an entire memory object
 *
 *	ENTRY:	laddr - linear address (handle) of base of object to free
 *		flags - PR_STATIC - allow freeing of AR_STATIC object
 *	EXIT:	non-0 if success, 0 if failure
 *
 */
ULONG EXTERNAL
_PageFree(ULONG laddr, ULONG flags)
{
    return VirtualFree((LPVOID) laddr, 0, MEM_RELEASE);
}


KERNENTRY 
HouseCleanLogicallyDeadHandles(VOID)
{
    return 0;
}

CRITICAL_SECTION *
NewCrst()
{
    CRITICAL_SECTION *lpcs = (CRITICAL_SECTION *) VirtualAlloc(0, sizeof(CRITICAL_SECTION), MEM_COMMIT, PAGE_READWRITE);
    
    if (lpcs)
    {
        InitializeCriticalSection(lpcs);
    }

    return lpcs;
}

VOID
DisposeCrst(CRITICAL_SECTION *lpcs)
{
    if (lpcs)
    {
        DeleteCriticalSection(lpcs);
        VirtualFree(lpcs, 0, MEM_RELEASE);
    }
}

DWORD KERNENTRY 
GetAppCompatFlags(VOID)
{
    return 0;
}

VOID APIENTRY 
MakeCriticalSectionGlobal(LPCRITICAL_SECTION lpcsCriticalSection)
{
}

BOOL KERNENTRY
ReadProcessMemoryFromPDB(
    PPDB ppdb,
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    return ReadProcessMemory(
        GetCurrentProcess(), 
        lpBaseAddress,
        lpBuffer,
        nSize,
        lpNumberOfBytesRead);
}

BOOL WINAPI 
vHeapFree(
    HANDLE hHeap, 
    DWORD dwFlags, 
    LPVOID lpMem
    )
{
    return HeapFree((HHEAP)hHeap, dwFlags, (LPSTR) lpMem);
}

BOOL
_HeapInit()
{
    ZeroMemory(&pdbCur, sizeof(PDB));
    pdbCur.hheapLocal = _HeapCreate(HEAP_SHARED, 0, 0);
    hheapKernel = pdbCur.hheapLocal;
    return (BOOL)(pdbCur.hheapLocal);
}

HANDLE
_GetProcessHeap(void)
{
    return GetCurrentPdb()->hheapLocal;
}

BOOL 
_IsOurHeap(HANDLE hHeap) 
{
    if (!IsBadReadPtr(hHeap, sizeof(HANDLE)))
    {
        return ((struct heapinfo_s *) hHeap)->hi_signature == HI_SIGNATURE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatejoystick.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    CheckJoyCaps.cpp

 Abstract:

    Check for error return value in joyGetDevCaps and joyGetPos and if found 
    make the structure (2nd parameter to routines) look just like it does under
    Win9x.  It also looks for handles applications that are passing in a size 
    parameter (3rd parameter) to joyGetDevCaps smaller than the current 
    structure size.  Not checking for this condition results in having the 
    applications stack stomped on.

 Notes:

    This is general shim that could be used for any application with WINMM 
    joystick problems.

 History:

    10/02/2000 a-brienw Created
    02/21/2002 mnikkel  Corrected possible buffer overrun when copying in data

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(EmulateJoystick)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(joyGetDevCapsA)
    APIHOOK_ENUM_ENTRY(joyGetPos)
APIHOOK_ENUM_END

/*++

 Hooked joyGetDevCapsA to make sure the JOYCAPS structure matched Win9x when 
 an error was the result of a call to the OS. Also make sure that the call to 
 joyGetDevCaps doesn't stomp on the applications stack by not paying attention 
 to the size passed in by the application. Check the routine joyGetDevCapsA in 
 joy.c in the WINMM code to see what it does.

--*/

MMRESULT
APIHOOK(joyGetDevCapsA)( 
    UINT uJoyID, 
    LPJOYCAPS pjc, 
    UINT cbjc 
    )
{
    MMRESULT ret = JOYERR_PARMS;
    JOYCAPSA JoyCaps;

    static const BYTE val[] = {0x00,0x70,0x6A,0x00,0x18,0xFD,0x6A,0x00,0xF8,0x58,
                               0xF9,0xBF,0x08,0x00,0x00,0x00,0xD0,0x5A,0x00,0x80,
                               0x00,0x00,0x00,0x00,0xC4,0x2F,0x73,0x81,0x00,0x00,
                               0x5A,0x00,0x18,0xFD,0x6A,0x00,0xF8,0x58,0xF9,0xBF,
                               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,
                               0x00,0x00,0x52,0xD7,0x40,0x00,0x00,0x00,0x00,0x00,
                               0xC4,0x2F,0x73,0x81,0x00,0x00,0x5A,0x00,0x03};

    if (!IsBadWritePtr(pjc, cbjc) && cbjc > 0)
    {
        ret = ORIGINAL_API(joyGetDevCapsA)(
                    uJoyID, (JOYCAPS *)&JoyCaps, sizeof(JOYCAPSA));
        
        if (ret == JOYERR_NOERROR)
        {
            // make sure the joycaps will fit in the supplied buffer
            DWORD dwSize = sizeof(JOYCAPSA);
            if (cbjc < dwSize)
            {
                dwSize = cbjc;
                LOGN( eDbgLevelWarning, "[APIHook_joyGetDevCapsA] Buffer too small, fixing");
            }

            memcpy(pjc, &JoyCaps, dwSize);
        }
        else
        {
            // make sure the joycaps will fit in the supplied buffer
            DWORD dwSize = ARRAYSIZE(val);
            if (cbjc < dwSize)
            {
                dwSize = cbjc;
                LOGN( eDbgLevelWarning, "[APIHook_joyGetDevCapsA] Buffer too small, fixing");
            }        
            //
            // Make the return structure look just like Win9x under error 
            // conditions without this CandyLand Adventure from Hasbro Interactive 
            // will do a divide by 0 during start up. Note these values were copied
            // verbatim from Win9x.
            //
            memcpy(pjc, &val, dwSize);
            DPFN( eDbgLevelSpew, "[APIHook_joyGetDevCapsA] Joystick error, returning Win9x buffer");
        }
    }
    else
    {
        DPFN( eDbgLevelError, "[APIHook_joyGetDevCapsA] Invalid buffer");
    }

    return ret;
}

/*++

 Hooked joyGetPos to make sure the JOYINFO structure matched Win9x when an error 
 was the result of a call to the OS. 
 
--*/

MMRESULT
APIHOOK(joyGetPos)(
    UINT uJoyID,
    LPJOYINFO pji
    )
{
    BYTE *bp;
    MMRESULT ret;
    
    ret = ORIGINAL_API(joyGetPos)(uJoyID, pji);

    if (ret != JOYERR_NOERROR)
    {
        if (!IsBadWritePtr(pji, sizeof(JOYINFO)))
        {
            //
            // Make the return structure look just like Win9x under error 
            // conditions.
            // 

            bp = (BYTE *)pji;

            memset(bp, 0, sizeof(JOYINFO));

            bp[0] = 0x01;
            bp[5] = 0x30;

            DPFN( eDbgLevelSpew, "[APIHook_joyGetPos] Joystick error, returning Win9x buffer");
        }
        else
        {
            DPFN( eDbgLevelError, "[APIHook_joyGetPos] Invalid buffer");
        }
    }

    return ret;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(WINMM.DLL, joyGetDevCapsA)
    APIHOOK_ENTRY(WINMM.DLL, joyGetPos)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateheap_lmem.c ===
//  LMEM.C
//
//      (C) Copyright Microsoft Corp., 1988-1994
//
//      Win32 wrappers for heap functions (Local* and some Heap*)
//
//  Origin: <Chicago>
//
//  Change history:
//
//  Date       Who        Description
//  ---------  ---------  -------------------------------------------------
//	       BrianSm	  Local* and Heap* APIs
//	       AtsushiK   Toolhelp
//  15-Feb-94  JonT       Code cleanup and precompiled headers

#include <EmulateHeap_kernel32.h>
#pragma hdrstop("kernel32.pch")

#include <tlhelp32.h>


#define GACF_HEAPSLACK 0x400000	// Copied from windows.h (16-bit)

SetFile();
/*
 *  Structure and equates for LocalAlloc handle management.  Some things
 *  to remember:
 *
 *  When a handle is returned to the user, we really pass him the address
 *  of the lh_pdata field because some bad apps like Excel just dereference the
 *  handle to find the pointer, rather than call LocalLock.
 *
 *  It is important that the handle value returned also be word aligned but not
 *  dword aligned (ending in a 2,6,a, or e).  We use the 0x2 bit to detect
 *  that a value is a handle and not a pointer (which will always be dword
 *  aligned).
 *
 *  If the data block get discarded, the lh_pdata field will be set to 0.
 *
 *  Free handles are kept on a free list linked through the lh_freelink
 *  field which overlays some other fields.  You can tell if a handle is free
 *  and has a valid freelink by checking that lh_sig == LH_FREESIG
 *
 *  The handles themselves are kept in heap blocks layed out as a
 *  lharray_s. We link these blocks on a per-process list so that
 *  the heap-walking functions can enumerate them.
 */


#pragma pack(1)
    
struct lhandle_s {
	unsigned short lh_signature;	/* signature (LH_BUSYSIG or LH_FREESIG)*/
	void	      *lh_pdata;	/* pointer to data for heap block */
	unsigned char  lh_flags;	/* flags (LH_DISCARDABLE) */
	unsigned char  lh_clock;	/* lock count */
};
#define lh_freelink	lh_pdata	/* free list overlays first field */
					/*    if LH_FREE is set in lh_flags */
#define LH_BUSYSIG	'SB'		/* signature for allocated handle */
#define LH_FREESIG	'SF'		/* signature for free handle */
#define LH_DISCARDABLE	0x02		/* lh_flags value for discardable mem */

#define LH_CLOCKMAX	0xff		/* maximum possible lock count */

#define LH_HANDLEBIT	 2		/* bit that is set on handles but not */
					            /*    pointers */

#define CLHGROW 	8
#define CBLHGROW	(sizeof(struct lhandle_s) * CLHGROW)


struct lharray_s {
    unsigned short lha_signature;	/* signature (LHA_SIG) */
    unsigned short lha_membercount;	/* position in linked list (for detecting loops) */
    struct lharray_s *lha_next;		/* ptr to next lharray_s */
//!!! This array *must* be dword aligned so that the handles will be 
//    *not* dword-aligned.
    struct lhandle_s lha_lh[CLHGROW];
};

#define LHA_SIGNATURE    'AL'		/* signature for lhaarray_s blocks */


#define TH32_MEMBUFFERSIZE (max(CBLHGROW,1024))

// A pointer to this private block of state info is kept in the dwResvd
// field of the HEAPENTRY32 structure.
typedef struct {
    CRST	*pcrst;		// Pointer to critical section (unencoded)

// !!! pcrst must be the first field!!!    
    PDB		*ppdb;		// PDB of process
    HHEAP	hHeap;		// Real Heap handle
    DWORD	lpbMin;		// Lowest allowed address for a heap block
    DWORD	nlocalHnd;	// # of lhandle_s structures allocated in heap
    struct heapinfo_s hi;	// Snapshot of heapinfo_s    

    
    DWORD	nSuppAvail;	// size of lpdwSuppress array in dwords
    DWORD	nSuppUsed;	// # of lpdwSuppress array dwords used.
    DWORD	*lpdwSuppress;	// Either NULL or a pointer to a NULL-terminated
				//  array of heap blocks to suppress.

    
    DWORD	dwMode;		// Current mode
    DWORD	nNextLH;	// 0 based index of next lhandle to read in curlha (THM_LHANDLES)
    
    DWORD	lpHBlock;	// Address of next heap block to read (THM_FIXEDHANDLES)
    DWORD	dwBlkAddr;	// Address of start of block data
    DWORD	dwBlkSize;	// Size of heap block (including header)
    DWORD	dwBlkFlags;	// HP_ flags.

    DWORD	curlhaaddr;	// Actual base address of curlha.
    struct lharray_s  curlha;   // Snapshot of current lharray_s

} THSTATE, *LPTHSTATE;

#define THM_INIT			0  //Init state
#define THM_LHANDLES			1  //Next object is an lhandle
#define THM_FIXEDHANDLES		2  //Next object is a fixed handle
#define THM_DONE			3  //Normal end
#define THM_ERROR			4  //Found heap error in previous advance


/*
 * these externs are needed to know whether we should destroy or dispose heap
 * critical sections
 */
extern  HANDLE  hheapKernel;		/* heap handle for the kernel heap */
VOID APIENTRY MakeCriticalSectionGlobal( LPCRITICAL_SECTION lpcsCriticalSection );

/*
 * The HP_* flags and LMEM_* flags should be interchangeable
 */
#if ((HP_ZEROINIT - LMEM_ZEROINIT) || (HP_MOVEABLE - LMEM_MOVEABLE) || (HP_FIXED - LMEM_FIXED))
# error Equates busted
#endif



extern ULONG INTERNAL VerifyOnHeap(HHEAP hheap, PVOID p);
extern KERNENTRY HouseCleanLogicallyDeadHandles(VOID);
extern BOOL KERNENTRY ReadProcessMemoryFromPDB(PPDB   ppdb,
					       LPVOID lpBaseAddress,
					       LPVOID lpBuffer,
					       DWORD nSize,
					       LPDWORD lpNumberOfBytesRead);
extern DWORD KERNENTRY GetAppCompatFlags(VOID);
extern HANDLE _GetProcessHeap(void);

/* 
     Utility function to check the local memory handle
 */

BOOL
_IsValidHandle(HANDLE hMem)
{
    BOOL bRet = FALSE;
    struct lhandle_s *plh;

	plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);

	/*
	 *  Do our own little parameter validation here because the normal
	 *  validation layer can't handle the odd-ball error return of hMem
	 */
	{
	    volatile UCHAR tryerror = 0;

	    _try {
		    tryerror &= (plh->lh_clock + (UCHAR)plh->lh_signature);
	    } _except (EXCEPTION_EXECUTE_HANDLER) {
		    tryerror = 1;
	    }

	    if (tryerror) {		
		    goto error;
	    }
	}

	if ((plh->lh_signature != LH_BUSYSIG) &&
       (plh->lh_signature != LH_FREESIG)){
	    	    goto error;
	}
    // Set the return value to TRUE
    bRet = TRUE;

error:
    return bRet;
}

/* 
     Utility function to check whether the passed memory
     is in the memory range. Uses VerifyOnHeap function.
 */
BOOL
_IsOnOurHeap(LPCVOID lpMem)
{
    HANDLE hHeap = _GetProcessHeap();
    return (VerifyOnHeap(hHeap, (PVOID)lpMem));
}

/* 
     Utility function to check the local memory handle
     and the memory range. Uses VerifyOnHeap function.
 */

BOOL
_IsOurLocalHeap(HANDLE hMem)
{
    BOOL bRet = FALSE;
    HANDLE hHeap = _GetProcessHeap();

    if ((ULONG)hMem & LH_HANDLEBIT)
    {
        // This is a handle
        bRet = (VerifyOnHeap(hHeap, hMem)) &&
               (_IsValidHandle(hMem));
    }
    else
    {
        bRet = VerifyOnHeap(hHeap, hMem);
    }
    return bRet;
}


/***EP	LocalAllocNG - allocate a block from the current process's default heap
 *
 *	ENTRY:	flags - LMEM_FIXED, LMEM_MOVEABLE, LMEM_DISCARDABLE, LMEM_ZEROINIT
 *		dwBytes - counts of bytes to allocate
 *	EXIT:	flat pointer to block allocated, or 0 if failure
 *
 *  Special entry point used by the handle-grouping code to avoid unwanted
 *  recursion.
 */
HANDLE APIENTRY
LocalAllocNG(UINT dwFlags, UINT dwBytes)
{
    void *pmem;
    struct lhandle_s *plh;
    struct lhandle_s *plhend;

    
    dwFlags &= ~( ((DWORD)GMEM_DDESHARE) |
		  ((DWORD)GMEM_NOTIFY)   |
		  ((DWORD)GMEM_NOT_BANKED) );

    /*
     *	Enter the heap critical section which serializes access to the handle
     *	tables as well as the heap.
     */
    hpEnterCriticalSection(((*pppdbCur)->hheapLocal));

    /*
     *	Make sure there are no extra flags
     */
    if (dwFlags & ~(LMEM_MOVEABLE | LMEM_DISCARDABLE | LMEM_ZEROINIT |
		    LMEM_NOCOMPACT | LMEM_NODISCARD)) {
	mmError(ERROR_INVALID_PARAMETER, "LocalAlloc: invalid flags\n");
	goto error;
    }

    /*
     *	If they want moveable memory, adjust dwBytes to leave room for a back
     *	pointer to the handle structure and allocate a handle structure.
     */
    if (dwFlags & LMEM_MOVEABLE) {

	/*
	 *  Allocate a handle structure.  If there aren't any on the free
	 *  list, allocate another block of memory to hold some more handles.
	 */
	if ((*pppdbCur)->plhFree == 0) {
	    struct lharray_s *plha;
	    
	    if ((plha = HPAlloc((HHEAP)(*pppdbCur)->hheapLocal, 
				sizeof(struct lharray_s),
				HP_NOSERIALIZE)) == 0) {
		goto error;
	    }
	    plha->lha_signature = LHA_SIGNATURE;
	    plha->lha_membercount = 
		(*pppdbCur)->plhBlock ? 
		    (*pppdbCur)->plhBlock->lha_membercount + 1 : 
		    0;
	    plh = &(plha->lha_lh[0]);

	    /*
	     *	If the allocation worked, put the handle structures on the free
	     *	list and null terminate the list.  Actually, we put all of the
	     *	new blocks on the list but one, who is the guy we are trying
	     *	to allocate (he will be in plh when we are done).
	     */
	    (*pppdbCur)->plhFree = plh;
	    for (plhend = plh + CLHGROW - 1; plh < plhend; plh++) {
		plh->lh_freelink = plh + 1;
		plh->lh_signature = LH_FREESIG;
	    }
	    (plh-1)->lh_freelink = 0;
	    
	    plha->lha_next = (*pppdbCur)->plhBlock;
	    (*pppdbCur)->plhBlock = plha;

	/*
	 *  If there is something on the free list, just take the guy off of it
	 */
	} else {
	    plh = (*pppdbCur)->plhFree;
	    mmAssert(plh->lh_signature == LH_FREESIG,
		     "LocalAlloc: bad handle free list 2\n");
	    (*pppdbCur)->plhFree = plh->lh_freelink;
	}

	/*
	 *  Initialize the handle structure
	 */
	plh->lh_clock = 0;
	plh->lh_signature = LH_BUSYSIG;
	plh->lh_flags = (dwFlags & LMEM_DISCARDABLE) ? LH_DISCARDABLE : 0;

	/*
	 *  Now actually allocate the memory unless the caller wanted the
	 *  block initially discarded (dwBytes == 0)
	 */
	if (dwBytes != 0) {
	    /*
	     *	Need to check for wacky size here to make sure adding on
	     *	the 4 bytes below to the size doesn't bring it from negative
	     *	to positive.
	     */
	    if (dwBytes > hpMAXALLOC) {
		mmError(ERROR_NOT_ENOUGH_MEMORY,
			"LocalAlloc: requested size too big\n");
		goto errorfreehandle;
	    }

	    if ((pmem = HPAlloc((HHEAP)(*pppdbCur)->hheapLocal,
				dwBytes+sizeof(struct lhandle_s *),
				dwFlags | HP_NOSERIALIZE)) == 0) {
		goto errorfreehandle;
	    }
	    plh->lh_pdata = (char *)pmem + sizeof(struct lhandle_s *);

	    /*
	     *	Initialize the back pointer to the handle structure at the
	     *	front of the data block.
	     */
	    *((struct lhandle_s **)pmem) = plh;

	} else {
	    plh->lh_pdata = 0;
	}

	/*
	 *  Set "pmem" (the return value) to the lh_pdata field in the
	 *  handle structure.
	 *
	 *  When a handle is returned to the user, we really pass him the address
	 *  of the lh_pdata field because some bad apps like Excel just dereference the
	 *  handle to find the pointer, rather than call LocalLock.
	 *
	 *  It is important that the handle value returned also be word aligned but not
	 *  dword aligned (ending in a 2,6,a, or e).  We use the 0x2 bit to detect
	 *  that a value is a handle and not a pointer (which will always be dword
	 *  aligned).
	 */
	pmem = &plh->lh_pdata;
	mmAssert(((ULONG)pmem & LH_HANDLEBIT),
		 "LocalAlloc: handle value w/o LH_HANDLEBIT set\n");

    /*
     *	For fixed memory, just allocate the sucker
     */
    } else {
	if ((pmem = HPAlloc((HHEAP)(*pppdbCur)->hheapLocal, dwBytes,
			    dwFlags | HP_NOSERIALIZE)) == 0) {
	    goto errorfreehandle;
	}
	mmAssert(((ULONG)pmem & LH_HANDLEBIT) == 0,
		 "LocalAlloc: pointer value w/ LH_HANDLEBIT set\n");
    }

  exit:
    hpLeaveCriticalSection(((*pppdbCur)->hheapLocal));
    return(pmem);

    /*
     *	Error paths.
     */
  errorfreehandle:
    if (dwFlags & LMEM_MOVEABLE) {
	plh->lh_freelink = (*pppdbCur)->plhFree;
	(*pppdbCur)->plhFree = plh;
	plh->lh_signature = LH_FREESIG;
    }
  error:
    pmem = 0;
    goto exit;
}


/***EP	LocalReAlloc - resize a memory block on the default heap
 *
 *	ENTRY:	hMem - pointer to block to resize
 *		dwBytes - new size requested
 *		dwFlags - LMEM_MOVEABLE: ok to move the block if needed
 *	EXIT:	flat pointer to resized block, or 0 if failure
 *
 */
HANDLE APIENTRY
LocalReAlloc(HANDLE hMem, UINT dwBytes, UINT dwFlags)
{
    struct heapinfo_s *hheap;
    struct lhandle_s *plh;
    void *pmem;
    
    
    dwFlags &= ~((DWORD)GMEM_DDESHARE);
    HouseCleanLogicallyDeadHandles();

    hheap = (*pppdbCur)->hheapLocal;

    /*
     *	Enter the heap critical section which serializes access to the handle
     *	tables as well as the heap.
     */
    hpEnterCriticalSection(hheap);

    /*
     *	Make sure there are no extra flags
     */
    if ((dwFlags & ~(LMEM_MOVEABLE | LMEM_DISCARDABLE | LMEM_ZEROINIT |
		    LMEM_NOCOMPACT | LMEM_MODIFY)) ||
	((dwFlags & LMEM_DISCARDABLE) && (dwFlags & LMEM_MODIFY) == 0)) {
	mmError(ERROR_INVALID_PARAMETER, "LocalReAlloc: invalid flags\n");
	goto error;
    }


    /*
     *	Figure out if this is a handle by checking if the adress is aligned
     *	in the right (wrong) way.
     */
    if ((ULONG)hMem & LH_HANDLEBIT) {

	/*
	 *  The handle value is aligned like a handle, but is it really one?
	 *  Verify it by making sure it is within the address range of the heap
	 *  and that it's signature is set right.  HPReAlloc will verify things
	 *  more by checking that the pmem is valid.
	 */
	if (VerifyOnHeap(hheap, hMem) == 0) {
	    mmError(ERROR_INVALID_HANDLE, "LocalReAlloc: hMem out of range\n");
	    goto error;
	}
	plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);
	if (plh->lh_signature != LH_BUSYSIG) {
	    mmError(ERROR_INVALID_HANDLE,
		    "LocalReAlloc: invalid hMem, bad signature\n");
	    goto error;
	}
	pmem = (char *)plh->lh_pdata - sizeof(struct lhandle_s *);

	/*
	 *  If the caller just wanted to change the flags for the block,
	 *  do it here.
	 */
	if (dwFlags & LMEM_MODIFY) {
	    plh->lh_flags &= ~LH_DISCARDABLE;
	    plh->lh_flags |= (dwFlags & LMEM_DISCARDABLE) ? LH_DISCARDABLE : 0;

	/*
	 *  If someone wants to realloc the block to size 0 (meaning discard the
	 *  sucker) do so here.  For discarding, we free the actual heap block
	 *  and store null in the lh_pdata field.
	 */
	} else if (dwBytes == 0) {

	    /*
	     *	If the lock count is not zero, you aren't allow to discard
	     */
	    if (plh->lh_clock != 0) {
		mmError(ERROR_INVALID_HANDLE,
			"LocalReAlloc: discard of locked block\n");
		goto error;
	    }

	    /*
	     *	Don't bother discarding the block if it is already discarded
	     */
	    if (plh->lh_pdata != 0) {
		if (HeapFree(hheap, HP_NOSERIALIZE, pmem) == 0) {
		    goto error;
		}
		plh->lh_pdata = 0;
	    }

	/*
	 *  If we get here, the caller actually wanted to reallocate the block
	 */
	} else {

	    dwBytes += sizeof(struct lhandle_s *);

	    /*
	     *	If the block is currently discarded, then we need to allocate
	     *	a new memory chunk for it, otherwise, do a realloc
	     */
	    if (plh->lh_pdata == 0) {
		if (dwBytes != 0) {
		    if ((pmem = HPAlloc(hheap, dwBytes,
					dwFlags | HP_NOSERIALIZE)) == 0) {
			goto error;
		    }
		    *((struct lhandle_s **)pmem) = plh;
		}
	    } else {
		if (plh->lh_clock == 0) {
		    dwFlags |= LMEM_MOVEABLE;
		}
		if ((pmem = HPReAlloc(hheap, pmem, dwBytes,
				      dwFlags | HP_NOSERIALIZE)) == 0) {
		    goto error;
		}
	    }

	    /*
	     *	Update the lh_pdata field in the handle to point to the new
	     *	memory.
	     */
	    plh->lh_pdata = (char *)pmem + sizeof(struct lhandle_s *);
	}

    /*
     *	The caller did not pass in a handle.  Treat the value as a pointer.
     *	HPReAlloc will do parameter validation on it.
     */
    } else if ((dwFlags & LMEM_MODIFY) == 0) {
	hMem = HPReAlloc(hheap, hMem, dwBytes, dwFlags | HP_NOSERIALIZE);

    } else {
	mmError(ERROR_INVALID_PARAMETER,
		"LocalReAlloc: can't use LMEM_MODIFY on fixed block\n");
	goto error;
    }

  exit:
    hpLeaveCriticalSection(hheap);
    return(hMem);

  error:
    hMem = 0;
    goto exit;
}


/***EP	LocalLock - lock a local memory handle on the default heap
 *
 *	ENTRY:	hMem - handle to block
 *	EXIT:	flat pointer to block or 0 if error
 */
LPVOID APIENTRY
LocalLock(HANDLE hMem)
{
    LPSTR pmem;
    struct heapinfo_s *hheap;
    struct lhandle_s *plh;

    hheap = (*pppdbCur)->hheapLocal;

    hpEnterCriticalSection(hheap);

    /*
     *	Verify hMem is within the address range of the heap
     */
    if (VerifyOnHeap(hheap, hMem) == 0) {
	/*
	 *  We don't want this error to break into the debugger by default
	 *  user can call this with random address in some dialog routine
	 *  that it doesn't know if it has a handle or a pointer
	 */
	DebugOut((DEB_WARN, "LocalLock: hMem out of range"));
	SetError(ERROR_INVALID_HANDLE);
//	  mmError(ERROR_INVALID_HANDLE, "LocalLock: hMem out of range\n");
	goto error;
    }

    /*
     *	Figure out if this is a handle by checking if the adress is aligned
     *	in the right (wrong) way.
     */
    if ((ULONG)hMem & LH_HANDLEBIT) {

	/*
	 *  The handle value is aligned like a handle, but is it really one?
	 *  Verify it by checking the signature.
	 */
	plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);
	if (plh->lh_signature != LH_BUSYSIG) {
	    mmError(ERROR_INVALID_HANDLE,
		    "LocalLock: invalid hMem, bad signature\n");
	    goto error;
	}

	/*
	 *  Increment the lock count unless we are already at the max
	 */
#ifdef HPDEBUG
	if (plh->lh_clock == LH_CLOCKMAX - 1) {
	    dprintf(("LocalLock: lock count overflow, handle cannot be unlocked\n"));
	}
#endif
	if (plh->lh_clock != LH_CLOCKMAX) {
	    plh->lh_clock++;
	}
	pmem = plh->lh_pdata;

    /*
     *	If the hMem passed in isn't a handle, it is supposed to be the
     *	base address of a fixed block.	We should validate that more, but NT
     *	doesn't and I would hate to be incompatible.  So instead, just
     *	return the parameter except for the obvious error case of the block
     *	being free.
     */
    } else {
	if (hpIsFreeSignatureValid((struct freeheap_s *)
				   (((struct busyheap_s *)hMem) - 1))) {
	    mmError(ERROR_INVALID_HANDLE,
		    "LocalLock: hMem is pointer to free block\n");
	    goto error;
	}
	pmem = hMem;
    }

  exit:
    hpLeaveCriticalSection(hheap);
    return(pmem);

  error:
    pmem = 0;
    goto exit;
}


/***	LocalCompact - obsolete function
 *
 *	ENTRY:	uMinFree - ignored
 *	EXIT:	0
 */

UINT APIENTRY
LocalCompact(UINT uMinFree)
{
    return(0);
}


/***	LocalShrink - obsolete function
 *
 *	ENTRY:	hMem - ignored
 *		cbNewSize - ignored
 *	EXIT:	reserved size of the local heap
 */
UINT APIENTRY
LocalShrink(HANDLE hMem, UINT cbNewSize)
{
    return((*pppdbCur)->hheapLocal->hi_cbreserve);
}

/***	LocalUnlock - unlock a local memory handle on the default heap
 *
 *	ENTRY:	hMem - handle to block
 *	EXIT:	0 if unlocked or 1 is still locked
 */
BOOL APIENTRY
LocalUnlock(HANDLE hMem)
{
    struct lhandle_s *plh;
    struct heapinfo_s *hheap;
    BOOL rc = 0;

    hheap = (*pppdbCur)->hheapLocal;

    hpEnterCriticalSection(hheap);

    /*
     *	Verify hMem is within the address range of the heap
     */
    if (VerifyOnHeap(hheap, hMem) == 0) {
	mmError(ERROR_INVALID_HANDLE, "LocalUnlock: hMem out of range\n");
	goto exit;
    }

    /*
     *	Figure out if this is a handle by checking if the adress is aligned
     *	in the right (wrong) way.
     */
    if ((ULONG)hMem & LH_HANDLEBIT) {

	/*
	 *  Validate handle signature
	 */
	plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);
	if (plh->lh_signature != LH_BUSYSIG) {
	    mmError(ERROR_INVALID_HANDLE,
		    "LocalUnlock: invalid hMem, bad signature\n");
	    goto exit;
	}

	/*
	 *  Decrement the lock count unless we are at the max
	 */
	if (plh->lh_clock != LH_CLOCKMAX) {
	    if (plh->lh_clock == 0) {

		/*
		 *  Just do a DebugOut since this is not an error per se,
		 *  though it probably indicates a bug in the app.
		 */
	        DebugOut((DEB_WARN, "LocalUnlock: not locked"));
		goto exit;
	    }
	    if (--plh->lh_clock != 0) {
		rc++;
	    }
	}
    }

  exit:
    hpLeaveCriticalSection(hheap);
    return(rc);
}

/***	LocalSize - return the size of a memory block on the default heap
 *
 *	ENTRY:	hMem - handle (pointer) to block
 *	EXIT:	size in bytesof the block (not including header) or 0 if error
 */
UINT APIENTRY
LocalSize(HANDLE hMem)
{
    struct heapinfo_s *hheap;
    struct lhandle_s *plh;
    DWORD rc = 0;
    DWORD delta = 0;

    hheap = (*pppdbCur)->hheapLocal;

    hpEnterCriticalSection(hheap);

    /*
     *	Figure out if this is a handle by checking if the adress is aligned
     *	in the right (wrong) way.
     */
    if ((ULONG)hMem & LH_HANDLEBIT) {

	/*
	 *  Verify hMem is within the address range of the heap
	 */
	if (VerifyOnHeap(hheap, hMem) == 0) {
	    mmError(ERROR_INVALID_HANDLE, "LocalSize: hMem out of range\n");
	    goto error;
	}

	/*
	 *  Validate handle signature
	 */
	plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);
	if (plh->lh_signature != LH_BUSYSIG) {
	    mmError(ERROR_INVALID_HANDLE,
		    "LocalSize: invalid hMem, bad signature\n");
	    goto error;
	}

	/*
	 *  Discarded handles have no size
	 */
	if (plh->lh_pdata == 0) {
	    goto error;
	}

	/*
	 *  Load up hMem with pointer to data for HeapSize call below
	 */
	delta = sizeof(struct lhandle_s *);
	hMem = (char *)plh->lh_pdata - sizeof(struct lhandle_s *);
    }

    /*
     *	Either this is a fixed block or we just loaded up the data address
     *	above if it was moveable.  Call HeapSize to do the real work.
     */
    rc = HeapSize(hheap, HP_NOSERIALIZE, hMem);

    /*
     *	If this was a moveable block, subtract the 4 bytes for the back pointer
     */
    rc -= delta;

  exit:
    hpLeaveCriticalSection(hheap);
    return(rc);

  error:
    rc = 0;
    goto exit;
}


/***	LocalFlags - return the flags and lock count of block of def heap
 *
 *	ENTRY:	hMem - handle (pointer) to block on default heap
 *	EXIT:	flags in high 3 bytes, lock count in low byte (always 1)
 */
UINT APIENTRY
LocalFlags(HANDLE hMem)
{
    struct heapinfo_s *hheap;
    struct lhandle_s *plh;
    DWORD rc = LMEM_INVALID_HANDLE;

    hheap = (*pppdbCur)->hheapLocal;

    hpEnterCriticalSection(hheap);

    /*
     *	Verify hMem is within the address range of the heap
     */
    if (VerifyOnHeap(hheap, hMem) == 0) {
	mmError(ERROR_INVALID_HANDLE, "LocalFlags: hMem out of range\n");
	goto exit;
    }

    /*
     *	We have to do our own pointer validation because the normal validation
     *	layer doesn't support returning LMEM_INVALID_HANDLE for errors.
     */
    _try {
	/*
	 *  Figure out if this is a handle by checking if the adress is aligned
	 *  in the right (wrong) way.
	 */
	if ((ULONG)hMem & LH_HANDLEBIT) {

	    /*
	     *	Validate handle signature
	     */
	    plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);
	    if (plh->lh_signature != LH_BUSYSIG) {
		mmError(ERROR_INVALID_HANDLE,
			"LocalFlags: invalid hMem, bad signature\n");
	    } else {

		rc = (ULONG)plh->lh_clock;

		if (plh->lh_pdata == 0) {
		    rc |= LMEM_DISCARDED;
		}
		if (plh->lh_flags & LH_DISCARDABLE) {
		    rc |= LMEM_DISCARDABLE;
		}
	    }

	/*
	 *  For fixed blocks, validate the signature.  NT always returns
	 *  0 for most fixed-like values even if they aren't really
	 *  the start of blocks.  If this causes an incompatibility we
	 *  can change this later.
	 */
	} else {
	    if (hpIsBusySignatureValid(((struct busyheap_s *)hMem) - 1)) {
		rc = 0;
	    } else {
		mmError(ERROR_INVALID_HANDLE, "LocalFlags: invalid hMem\n");
	    }
	}
    } _except (EXCEPTION_EXECUTE_HANDLER) {

	mmError(ERROR_INVALID_HANDLE, "LocalFlags: bad hMem");
    }
  exit:
    hpLeaveCriticalSection(hheap);
    return(rc);
}


/***	LocalHandle - return the handle for a block given its start address
 *
 *	ENTRY:	pMem - pointer to block on default heap
 *	EXIT:	handle for the block
 */
HANDLE APIENTRY
LocalHandle(PVOID pMem)
{
    struct heapinfo_s *hheap;
    struct busyheap_s *pbh;
    unsigned long prevdword;
    struct lhandle_s *plh;
    HANDLE rc;

    hheap = (*pppdbCur)->hheapLocal;

    hpEnterCriticalSection(hheap);

    /*
     *	Verify pMem is within the address range of the heap and aligned like
     *	a heap block should be.
     */
    if (VerifyOnHeap(hheap, pMem) == 0) {
	mmError(ERROR_INVALID_HANDLE, "LocalHandle: pMem out of range\n");
	goto error;
    }

    /*
     *	Figure out if this is a moveable block by seeing if the previous
     *	dword points back to a handle.
     */
    prevdword = *(((unsigned long *)pMem) - 1);
    if (VerifyOnHeap(hheap, (PVOID)prevdword) != 0) {

	if (((struct lhandle_s *)prevdword)->lh_signature == LH_BUSYSIG) {

	    /*
	     *	This sure looks like a moveable block with a handle.  Return it.
	     */
	    rc = (HANDLE)(prevdword + LH_HANDLEBIT);
	    goto exit;
	}
    }

    /*
     * Did they pass in a Handle???
     */

    if ((ULONG)pMem & LH_HANDLEBIT) {
	plh = (struct lhandle_s *)((char *)pMem - LH_HANDLEBIT);
	if (plh->lh_signature == LH_BUSYSIG) {
	    rc = (HANDLE)pMem;
	    SetError(ERROR_INVALID_HANDLE); /* NT Compat */
	    goto exit;
	}
    }


    /*
     *	If we get to here, the block is not preceded by a handle back pointer.
     *	So either it is an invalid address or a fixed block.
     */
    pbh = (struct busyheap_s *)pMem - 1;
    if (hpIsBusySignatureValid(pbh) == 0) {

	/*
	 *  Not a heap block.  Return error.
	 */
	mmError(ERROR_INVALID_HANDLE, "LocalHandle: address not a heap block\n");
	goto error;

    /*
     *	If we get here, we passed all the tests.  Looks like we have a fixed
     *	heap block, so just return the pointer as the handle.
     */
    } else {
	rc = pMem;
    }

  exit:
    hpLeaveCriticalSection(hheap);
    return(rc);

  error:
    rc = 0;
    goto exit;
}

extern WINBASEAPI BOOL WINAPI vHeapFree(HANDLE hHeap, DWORD dwFlags,
					LPVOID lpMem);


/***EP	LocalFreeNG - free a block on the default heap
 *
 *	ENTRY:	hMem - handle (pointer) to block to free
 *	EXIT:	NULL if success, else hMem if failure
 *
 *  Special entry point used by the handle-grouping code to avoid unwanted
 *  recursion.
 */
HANDLE APIENTRY
LocalFreeNG(HANDLE hMem)
{
    struct heapinfo_s *hheap;
    struct lhandle_s *plh;
    void *pmem;

    /*
     *	The spec says to ignore null pointers
     */
    if (hMem == 0) {
	goto exit;
    }

    hheap = (*pppdbCur)->hheapLocal;

    /*
     *	Enter the heap critical section which serializes access to the handle
     *	tables as well as the heap.
     */
    hpEnterCriticalSection(hheap);

    /*
     *	Figure out if this is a handle by checking if the adress is aligned
     *	in the right (wrong) way.
     */
    if ((ULONG)hMem & LH_HANDLEBIT) {

	/*
	 *  The handle value is aligned like a handle, but is it really one?
	 *  Verify it by making sure it is within the address range of the heap
	 *  and that it's signature is set right.  HeapFree will verify things
	 *  more by checking that the pmem is valid.
	 */
	if (VerifyOnHeap(hheap, hMem) == 0) {
	    mmError(ERROR_INVALID_HANDLE, "LocalFree: hMem out of range\n");
	    goto error;
	}
	plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);

	/*
	 *  Do our own little parameter validation here because the normal
	 *  validation layer can't handle the odd-ball error return of hMem
	 */
	{
	    volatile UCHAR tryerror = 0;

	    _try {
		tryerror &= (plh->lh_clock + (UCHAR)plh->lh_signature);
	    } _except (EXCEPTION_EXECUTE_HANDLER) {
		tryerror = 1;
	    }
	    if (tryerror) {
		mmError(ERROR_INVALID_HANDLE, "LocalFree: invalid handle");
		goto error;
	    }
	}

	if (plh->lh_signature != LH_BUSYSIG) {
	    mmError(ERROR_INVALID_HANDLE,
		    "LocalFree: invalid hMem, bad signature\n");
	    goto error;
	}

	/*
	 *  You can't free a locked block
	 */

// Commenting out to keep MFC apps from ripping under debug. 
// Not that I'm a fan of shooting the messenger, but this particular
// case seems to happen a lot because of the way Win3.x defined
// GlobalLock. See Win95C:#12103 for the non-technical reasons for
// this being a pri-1.
//
#if 0
#ifdef HPDEBUG
	if (plh->lh_clock) {
	    mmError(ERROR_INVALID_HANDLE, "LocalFree: locked\n");
	}
#endif
#endif


	/*
	 *  Don't bother freeing the block if it is already discarded.
	 *  When freeing we zero out the back pointer to the handle so
	 *  we don't get confused if someone tried to free a block twice.
	 */
    if (plh->lh_pdata != 0) {
	    pmem = (char *)plh->lh_pdata - sizeof(struct lhandle_s *);
	    /*
	     *  Under some conditions with Office, this pointer can get trashed. We
	     *  need to make sure we don't AV
	     */
        if (!IsBadWritePtr(pmem, sizeof(unsigned long))) {
            *((unsigned long *)pmem) = 0;
    	    if (HeapFree(hheap, HP_NOSERIALIZE, pmem) == 0) {
	        	goto error;
            }
        }
	}

	/*
	 *  Now free the handle structure and we are done.
	 */
	plh->lh_freelink = (*pppdbCur)->plhFree;
	(*pppdbCur)->plhFree = plh;
	plh->lh_signature = LH_FREESIG;


    /*
     *	The caller did not pass in a handle.  Treat the value as a pointer.
     *	HeapFree will do parameter validation on it.
     */
    } else {
	if (vHeapFree(hheap, HP_NOSERIALIZE, hMem) == 0) {
	    goto error;
	}
    }

    hMem = 0;		/* success */

  error:
    hpLeaveCriticalSection(hheap);
  exit:
    return(hMem);
}


/***EP	HeapCreate - initialize a memory block as a flat heap
 *
 *	ENTRY:	flOptions - HEAP_NO_SERIALIZE: don't serialize access within process
 *			    (caller MUST)
 *			    HEAP_LOCKED: make memory fixed
 *			    HEAP_SHARED: put it in shared arena
 *		dwInitialSize - initial committed memory in heap
 *		dwMaximumSize - reserved size of heap memory
 *	EXIT:	handle to new heap, or 0 if error
 */
HANDLE APIENTRY
HeapCreate(DWORD flOptions, DWORD dwInitialSize, DWORD dwMaximumSize)
{
    char	      *pmem;
    ULONG	       rc = 0;	/* assume failure */

    /*
     *	Don't allowed shared heaps - this only works on Win9x because there is a shared arena.
     */
    if (flOptions & HEAP_SHARED) {
        flOptions &= ~HEAP_SHARED;
    }

    /*
     *	Although we don't really use InitialSize any more (except in growable
     *	heaps) we should still enforce its sanity so apps don't get lazy
     */
    if (dwInitialSize > dwMaximumSize && dwMaximumSize != 0) {
	mmError(ERROR_INVALID_PARAMETER,
		"HeapCreate: dwInitialSize > dwMaximumSize\n");
	goto exit;
    }

    /*
     *	Round the sizes up to the nearest page boundary
     */
    dwMaximumSize = (dwMaximumSize + PAGEMASK) & ~PAGEMASK;

    /*
     *	A maximum size of 0 means growable.  Start him out with 1meg, but allow
     *	more.
     */
    if (dwMaximumSize == 0) {
	flOptions |= HP_GROWABLE;
	dwMaximumSize = 1*1024*1024 + (dwInitialSize & ~PAGEMASK);
    }

    /*
     *	Allocate memory for the heap.  Use PageCommit etc... rather than
     *	VirtualAlloc for committing so we don't get zero-initialized stuff
     *	and also we can commit fixed pages and reserve shared memory.
     */
    if (((ULONG)pmem =
	 PageReserve((flOptions & HEAP_SHARED) ? PR_SHARED : PR_PRIVATE,
		   dwMaximumSize / PAGESIZE,
		   PR_STATIC |
		   ((flOptions & HEAP_LOCKED) ? PR_FIXED : 0))) == -1) {
	mmError(ERROR_NOT_ENOUGH_MEMORY, "HeapCreate: reserve failed\n");
	goto exit;
    }

    /*
     *	Call HPInit to initialize the heap structures within the new memory
     */
    #if HEAP_NO_SERIALIZE - HP_NOSERIALIZE
    # error HEAP_NO_SERIALIZE != HP_NOSERIALIZE
    #endif
    #if HEAP_GENERATE_EXCEPTIONS - HP_EXCEPT
    # error HEAP_GENERATE_EXCEPTIONS != HP_EXCEPT
    #endif
    if (((PVOID)rc = HPInit(pmem, pmem, dwMaximumSize,
			    (flOptions &
			     (HP_EXCEPT|HP_NOSERIALIZE|HP_GROWABLE)))) == 0) {
	goto free;
    }

    // if this is a shared heap and not the kernel heap, we don't
    // want the critical section to go away until the heap is destroyed
    if ( (flOptions & HEAP_SHARED) && hheapKernel ) {
        MakeCriticalSectionGlobal( (CRITICAL_SECTION *)(&(((HHEAP)pmem)->hi_critsec)) );
    }

    /*
     *	Link private heaps onto the per-process heap list.
     */
    if ((flOptions & HEAP_SHARED) == 0) {
	mmAssert(pppdbCur, "HeapCreate: private heap created too early");

	((struct heapinfo_s *)pmem)->hi_procnext = GetCurrentPdb()->hhi_procfirst;
	GetCurrentPdb()->hhi_procfirst = (struct heapinfo_s *)pmem;
    }

  exit:
    return((HANDLE)rc);

  free:
    PageFree(pmem, PR_STATIC);
    goto exit;
}


/***EP	HeapDestroy - free a heap allocated with HeapCreate
 *
 *	ENTRY:	hHeap - handle to heap to free
 *	EXIT:	non-0 if success, or 0 if failure
 */
BOOL APIENTRY
HeapDestroy(HHEAP hHeap)
{
    ULONG	       rc;
    struct heapinfo_s **ppheap;
    struct heapseg_s *pseg;
    struct heapseg_s *psegnext;

    EnterMustComplete();

    if ((rc = hpTakeSem(hHeap, 0, 0)) == 0) {
	goto exit;
    }

    /*
     *	We now hold the heap's semaphore.  Quickly clear the semaphore and
     *	delete the semaphore.  If someone comes in and blocks on the semaphore
     *	between the time we clear it and destroy it, tough luck.  They will
     *	probably fault in a second.
     */
    hpClearSem(hHeap, 0);
    if ((hHeap->hi_flags & HP_NOSERIALIZE) == 0) {
        if (hHeap == hheapKernel) {
	    DestroyCrst(hHeap->hi_pcritsec);
	} else {
            Assert(hHeap->hi_pcritsec->typObj == typObjCrst);
            if (hHeap->hi_pcritsec->typObj == typObjCrst) {
	        DisposeCrst(hHeap->hi_pcritsec);
            }
	}
    }

    /*
     *	For private heaps, find it on the per-process heap list and remove it.
     */
    if ((ULONG)hHeap < MAXPRIVATELADDR) {
	ppheap = &(GetCurrentPdb()->hhi_procfirst);
	for (; *ppheap != hHeap; ppheap = &((*ppheap)->hi_procnext)) {
	    mmAssert(*ppheap != 0, "HeapDestroy: heap not on list");
	}
	*ppheap = hHeap->hi_procnext;		/* remove from list */
    }

    /*
     *	Free the heap memory
     */
    pseg = (struct heapseg_s *)hHeap;
    do {
	psegnext = pseg->hs_psegnext;
	PageFree(pseg, PR_STATIC);
	pseg = psegnext;
    } while (pseg != 0);
  exit:
    LeaveMustComplete();
    return(rc);
}


/***EP	HeapAlloc - allocate a fixed/zero-init'ed block from the specified heap
 *
 *	ENTRY:	hHeap - heap handle (pointer to base of heap)
 *		dwFlags - HEAP_ZERO_MEMORY
 *		dwBytes - count of bytes to allocate
 *	EXIT:	pointer to block or 0 if failure
 */
LPVOID APIENTRY
HeapAlloc(HANDLE hHeap, DWORD dwFlags, DWORD dwBytes)
{
    // WordArt (32) overwrites some of his local heap blocks. So
    // we pad his allocations some. Slacker.
    if (GetAppCompatFlags() & GACF_HEAPSLACK) {
	if (hHeap == GetCurrentPdb()->hheapLocal) {
	    dwBytes += 16;
	}
    }
    
    return(HPAlloc((HHEAP)hHeap, dwBytes, (dwFlags & HEAP_GENERATE_EXCEPTIONS) |
		   ((dwFlags & HEAP_ZERO_MEMORY) ? HP_ZEROINIT : 0)));
}


/***EP	HeapReAlloc - resize a memory block on a specified heap
 *
 *	ENTRY:	hHeap - heap handle (pointer to base of heap)
 *		dwFlags - HEAP_REALLOC_IN_PLACE_ONLY
 *			  HEAP_ZERO_MEMORY
 *		lpMem - pointer to block to resize
 *		dwBytes - new size requested
 *	EXIT:	flat pointer to resized block, or 0 if failure
 */
LPVOID APIENTRY
HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPSTR lpMem, DWORD dwBytes)
{
    return((HANDLE)HPReAlloc((HHEAP)hHeap,
		       lpMem,
		       dwBytes,
		       (dwFlags & (HEAP_NO_SERIALIZE | HP_EXCEPT)) |
		       ((dwFlags & HEAP_REALLOC_IN_PLACE_ONLY) ? 0 : HP_MOVEABLE) |
		       ((dwFlags & HEAP_ZERO_MEMORY) ? HP_ZEROINIT : 0)));
}



//--------------------------------------------------------------------------
// ToolHelp32 heapwalking code.
//--------------------------------------------------------------------------

/*---------------------------------------------------------------------------
 * BOOL SafeReadProcessMemory(PPDB   ppdb,
 *			      LPVOID lpBuffer,
 *			      DWORD  cbSizeOfBuffer,
 *			      DWORD  cbBytesToRead);
 *
 * Reads memory from another process's context.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY SafeReadProcessMemory(PPDB   ppdb,
				     DWORD  dwBaseAddr,
				     LPVOID lpBuffer,
				     DWORD  cbSizeOfBuffer,
				     DWORD  cbBytesToRead)
{
    BOOL fRes;
#ifdef DEBUG
    
    if (cbSizeOfBuffer != 0) {
	FillBytes(lpBuffer, cbSizeOfBuffer, 0xcc);
    }
    
    if (cbSizeOfBuffer < cbBytesToRead) {
	DebugOut((DEB_ERR, "SafeReadProcessMemory: Input buffer too small."));
	return FALSE;
    }
#endif
    
    if (!(fRes = ReadProcessMemoryFromPDB(ppdb,
					  (LPVOID)dwBaseAddr,
					  lpBuffer,
					  cbBytesToRead,
					  NULL))) {
#ifdef DEBUG
	DebugOut((DEB_WARN, "SafeReadProcessMemory: Failed ReadProcessMemory()"));
#endif	
	return FALSE;
    }
    
    return TRUE;
    
} 

/*---------------------------------------------------------------------------
 * Make sure the caller initialized HEAPENTRY32 properly.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY ValidateHeapEntry32(LPHEAPENTRY32 lphe32)
{
    if ((lphe32 == NULL) || (lphe32->dwSize != sizeof(HEAPENTRY32))) {
	DebugOut((DEB_ERR, "HEAPENTRY32: Wrong version or dwSize."));
	return FALSE;
    }
    
    return TRUE;
}


/*---------------------------------------------------------------------------
 * Test if a linear address could plausibly be the start of a block header.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY IsValidBlockHdrAddr(LPHEAPENTRY32 lphe32, DWORD dwAddr)
{
    LPTHSTATE lpts;
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    /*
     *	A good block is always in the user address space and dword aligned
     */
    if ((dwAddr & 0x3) || dwAddr < MINPRIVATELADDR || dwAddr >= MAXSHAREDLADDR) {
	return FALSE;
    }
    return TRUE;
}

/*---------------------------------------------------------------------------
 * Test if a linear address could plausibly be the start of  block data.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY IsValidBlockDataAddr(LPHEAPENTRY32 lphe32, DWORD dwAddr)
{
    return(IsValidBlockHdrAddr(lphe32, dwAddr));
}


/*---------------------------------------------------------------------------
 * Read in and validate a lharray_s.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY SafeRdCurLHA(LPHEAPENTRY32 lphe32, DWORD dwBaseAddr)
{
    LPTHSTATE lpts;
    struct lharray_s lha;
    
    if (!(ValidateHeapEntry32(lphe32))) {
	return FALSE;
    }

    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    if (!IsValidBlockDataAddr(lphe32, dwBaseAddr)) {
	return FALSE;
    }
    
    
    if (!SafeReadProcessMemory(lpts->ppdb,
			       dwBaseAddr,
			       &lha,
			       sizeof(lha),
			       sizeof(lha))) {

	return FALSE;
    }	

    // Check signature.
    if (lha.lha_signature != LHA_SIGNATURE) {
        DebugOut((DEB_WARN, "lharray_s (%lx) has bad signature.", dwBaseAddr));
	return FALSE;
    }
    if (lha.lha_next && !IsValidBlockDataAddr(lphe32, (DWORD)lha.lha_next)) {
        DebugOut((DEB_WARN, "lharray_s (%lx) has bad next link.", dwBaseAddr));
	return FALSE;
    }
	
    lpts->curlha = lha;
    lpts->curlhaaddr = dwBaseAddr;
    return TRUE;	
    
} 








/*---------------------------------------------------------------------------
 * Insert a handle value to be suppressed when reading fixed blocks later.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY InsertSuppress(LPHEAPENTRY32 lphe32, DWORD dwSupp)
{
    LPTHSTATE lpts;
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    if (!(lpts->lpdwSuppress)) {
#ifdef DEBUG
	DebugOut((DEB_ERR, "Internal error: lpdwSuppress == NULL."));
#endif
	return FALSE;
    }
    if (lpts->nSuppUsed >= lpts->nSuppAvail) {
#ifdef DEBUG
	DebugOut((DEB_ERR, "Internal error: lpdwSuppress too small."));
#endif
	return FALSE;
    }
    lpts->lpdwSuppress[lpts->nSuppUsed++] = dwSupp;
    return TRUE;

}


/*---------------------------------------------------------------------------
 * Validate and decode a heap block header.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY DissectBlockHdr(LPHEAPENTRY32 lphe32,
			       DWORD	     dwAddr,
			       DWORD	  *lpdwSize,
			       DWORD	  *lpdwFlags,
			       DWORD      *lpdwAddr)
{
    DWORD dwHdr;
    LPTHSTATE lpts;
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    if (!IsValidBlockHdrAddr(lphe32, dwAddr)) {
	return FALSE;
    }
    
    *lpdwFlags = HP_SIGNATURE ^ ((DWORD)0xffffffff);
    
    if (!SafeReadProcessMemory(lpts->ppdb,
			       dwAddr,
			       &dwHdr,
			       sizeof(dwHdr),
			       sizeof(DWORD))) {
	return FALSE;
    }
    
    if ( (dwHdr & HP_SIGBITS) != HP_SIGNATURE ) {
	return FALSE;
    }
    
    *lpdwSize  = dwHdr & HP_SIZE;
    *lpdwFlags = dwHdr & HP_FLAGS;
    *lpdwAddr  = dwAddr + ( (dwHdr & HP_FREE) ? 
			   sizeof(struct freeheap_s) :
			   sizeof(struct busyheap_s) );
    
    if (*lpdwSize != 0 &&
	!IsValidBlockHdrAddr(lphe32, dwAddr + (*lpdwSize))) {
	return FALSE;
    }
    
    
    return TRUE;

}


/*---------------------------------------------------------------------------
 * Check if we're at the end of the heap (heap is terminated by a 
 * busy block of size 0).
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY AtEndOfHeap32(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    if (lpts->dwMode != THM_FIXEDHANDLES) {
	return FALSE;
    }
    
    return (!((lpts->dwBlkFlags) & HP_FREE) && 
	    (lpts->dwBlkSize) == 0);
}



/*---------------------------------------------------------------------------
 * Internal routine (maybe make it an api?). Deallocate all internal
 * state used for heap-walking.
 *---------------------------------------------------------------------------*/
VOID KERNENTRY RealHeap32End(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;

    if (!(ValidateHeapEntry32(lphe32))) {
	return;
    }
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    // In case someone calls this after they've fallen off the end.
    if (lpts == NULL) {
	return;
    }
    EnterMustComplete();
    if (lpts->pcrst) {
	DisposeCrst(lpts->pcrst);
	lpts->pcrst = NULL;
    }
    LeaveMustComplete();
    if (lpts->lpdwSuppress) {
	FKernelFree(lpts->lpdwSuppress);
	lpts->lpdwSuppress = NULL;
    }
    FKernelFree(lpts);
    lphe32->dwResvd = 0;
    
    FillBytes(( (char*)lphe32 ) + 4, sizeof(HEAPENTRY32) - 4, 0);

}


/*---------------------------------------------------------------------------
 * Copy current heap object into HEAPENTRY32 for caller's consumption.
 * To skip this object, set *pfInteresting to FALSE.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY CopyIntoHeap32Entry(LPHEAPENTRY32 lphe32, BOOL *pfInteresting)
{
    LPTHSTATE lpts;
    
    *pfInteresting = TRUE;
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    switch (lpts->dwMode) {
	
	case THM_LHANDLES: {
	    DWORD     dwSize;
	    DWORD     dwFlags;
	    DWORD     dwAddr;
	    DWORD     dwHnd;

	    struct lhandle_s *plh;
	    
	    plh = &(lpts->curlha.lha_lh[lpts->nNextLH]);
	    
	    if (plh->lh_signature == LH_FREESIG) {
		*pfInteresting = FALSE;
		return TRUE;
	    }
	    
	    if (plh->lh_signature != LH_BUSYSIG) {
                DebugOut((DEB_WARN, "lhandle_s has bad signature."));
		return FALSE;
	    }
	    
	    dwHnd = ( (DWORD)(&(plh->lh_pdata)) ) - 
		    ( (DWORD)(&(lpts->curlha)) ) +
		    lpts->curlhaaddr;
	    

	    
	    if (!plh->lh_pdata) {
		// Discarded handle.
		lphe32->hHandle       = (HANDLE)dwHnd;
		lphe32->dwAddress     = 0;
		lphe32->dwBlockSize   = 0;
		lphe32->dwFlags       = LF32_MOVEABLE;
		lphe32->dwLockCount   = (DWORD)(plh->lh_clock);
		return TRUE;
	    }
	    if (!DissectBlockHdr(lphe32, 
				 ( (DWORD)(plh->lh_pdata) ) - 4 - sizeof(struct busyheap_s),
				 &dwSize,
				 &dwFlags,
				 &dwAddr
				 )) {
		return FALSE;   // This will be caught someplace else.
	    }
	    if (dwFlags & HP_FREE) {
                DebugOut((DEB_WARN, "Local handle points to freed block!"));
		return FALSE;
	    }
	    
	    if (!InsertSuppress(lphe32,
				dwAddr-sizeof(struct busyheap_s))) {
		return FALSE;
	    }
	    
	    lphe32->hHandle       = (HANDLE)dwHnd;
	    lphe32->dwAddress     = dwAddr + 4;
	    lphe32->dwBlockSize   = dwSize - sizeof(struct busyheap_s) - 4;
	    lphe32->dwFlags       = LF32_MOVEABLE;
	    lphe32->dwLockCount   = (DWORD)(plh->lh_clock);
			     
	    return TRUE;

	    
	}

	case THM_FIXEDHANDLES: {
	    
	    
	    if ((lpts->dwBlkFlags) & HP_FREE) {
		lphe32->hHandle     = NULL;
		lphe32->dwAddress   = lpts->dwBlkAddr;
		lphe32->dwBlockSize = lpts->dwBlkSize - sizeof(struct freeheap_s);
		lphe32->dwFlags     = LF32_FREE;
		lphe32->dwLockCount = 0;
	    } else {
		
		// Supress if it's a lharray_s or the target of
		// an lhandle. Opt: we could check the first dword
		// to rule out lots of blocks.
		if (lpts->lpdwSuppress) {
		    DWORD *lpdw, *lpdwEnd;
		    DWORD dwHdrAddr = lpts->lpHBlock;
		    
		    lpdwEnd = &(lpts->lpdwSuppress[lpts->nSuppUsed]);
		    for (lpdw = lpts->lpdwSuppress; lpdw < lpdwEnd; lpdw++) {
			if (dwHdrAddr == *lpdw) {
			    *pfInteresting = FALSE;
			    return TRUE;
			}
		    }
		}
		
		
		lphe32->hHandle     = (HANDLE)(lpts->dwBlkAddr);
		lphe32->dwAddress   = lpts->dwBlkAddr;
		lphe32->dwBlockSize = lpts->dwBlkSize - sizeof(struct busyheap_s);
		lphe32->dwFlags     = LF32_FIXED;
		lphe32->dwLockCount = 0;

	    }
	    
	    return TRUE;
	}
	    
	
	case THM_ERROR:
	  DebugOut((DEB_ERR, "Internal error: Can't get here"));
	  return FALSE;
	
	case THM_DONE:
	  DebugOut((DEB_ERR, "Internal error: Can't get here"));
	  return FALSE;
	    
	
	default:
	  DebugOut((DEB_ERR, "Internal error: Bad lpthstate.dwmode"));
	  return FALSE;
	    
    }
}

/*---------------------------------------------------------------------------
 * Worker routine for AdvanceHeap32(): handles the init case.
 *
 * If the heap is the owning pdb's default heap (determined by
 * comparing hHeap with ppdb->hHeapLocal), point the state to
 * the first lharray_s. Otherwise, point the state to the first heap block.
 * 
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY AdvanceHeap32Init(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    struct lharray_s *lpha;
    DWORD dwNumSupp;
    

    lpts = (LPTHSTATE)(lphe32->dwResvd);

    lpha = lpts->ppdb->plhBlock;
    if (lpts->ppdb->hheapLocal != lpts->hHeap || lpha == NULL) {
	lpts->dwMode = THM_FIXEDHANDLES;
	lpts->lpHBlock = lpts->lpbMin;
 	if (!DissectBlockHdr(lphe32,
			     lpts->lpHBlock,
			     &(lpts->dwBlkSize),
			     &(lpts->dwBlkFlags),
			     &(lpts->dwBlkAddr))) {
	    return FALSE;
	}

	return TRUE;
    }
    
    if (!SafeRdCurLHA(lphe32, (DWORD)lpha)) {
	return FALSE;
    }

    dwNumSupp = (lpts->curlha.lha_membercount + 1) * (1 + CLHGROW);
    if (!(lpts->lpdwSuppress = PvKernelAlloc0(dwNumSupp * sizeof(DWORD)))) {
	return FALSE;
    }
    lpts->nSuppAvail = dwNumSupp * sizeof(DWORD);
    lpts->nSuppUsed  = 0;
    
    if (!(InsertSuppress(lphe32, ((DWORD)lpha) - sizeof(struct busyheap_s)))) {
	return FALSE;
    }
    
    lpts->nNextLH = 0;
    lpts->dwMode = THM_LHANDLES;


    return TRUE;


    
}


/*---------------------------------------------------------------------------
 * Worker routine for AdvanceHeap32(): handles the lhandle case.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY AdvanceHeap32Movable(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    WORD wOldMemberCnt;
    DWORD dwAddrNext;
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    if (lpts->nNextLH < CLHGROW-1) {
	lpts->nNextLH++;
	return TRUE;
    }
    
    // End of current lhandle clump reached. Any new ones?
    if (lpts->curlha.lha_next == NULL) {
	// Nope. Go on to fixed handles.
	lpts->dwMode = THM_FIXEDHANDLES;
	lpts->lpHBlock = lpts->lpbMin;
 	if (!DissectBlockHdr(lphe32,
			     lpts->lpHBlock,
			     &(lpts->dwBlkSize),
			     &(lpts->dwBlkFlags),
			     &(lpts->dwBlkAddr))) {
	    return FALSE;
	}
	return TRUE;


    }
    
    // Get next lhandle clump.
    wOldMemberCnt = lpts->curlha.lha_membercount;
    dwAddrNext = (DWORD)(lpts->curlha.lha_next);
    if (!SafeRdCurLHA(lphe32, dwAddrNext)) {
	return FALSE;
    }
    if (lpts->curlha.lha_membercount >= wOldMemberCnt) {
        DebugOut((DEB_WARN, "lha_array clusters in wrong order."));
	return FALSE;
    }
    lpts->nNextLH = 0;


    return TRUE;
    
}


/*---------------------------------------------------------------------------
 * Worker routine for AdvanceHeap32(): handles the fixed block case.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY AdvanceHeap32Fixed(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);

    // Diassect block has already checked monotonocity and range.
    lpts->lpHBlock += lpts->dwBlkSize;
    
    if (!DissectBlockHdr(lphe32, 
			 lpts->lpHBlock,
			 &(lpts->dwBlkSize),
			 &(lpts->dwBlkFlags),
			 &(lpts->dwBlkAddr)
			 )) {
	return FALSE;
    }

    return TRUE;
    
}


/*---------------------------------------------------------------------------
 * Advance the internal state to the next heap object. Validate the
 * next heap object.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY AdvanceHeap32(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    switch (lpts->dwMode) {
	case THM_INIT:
	    return AdvanceHeap32Init(lphe32);
	case THM_LHANDLES:
	    return AdvanceHeap32Movable(lphe32);
	case THM_FIXEDHANDLES:
	    return AdvanceHeap32Fixed(lphe32);
	default:
	    DebugOut((DEB_ERR, "Illegal or unexpected THM mode."));
	    return FALSE;
    }
    
}


/*---------------------------------------------------------------------------
 * Does the real work of heap32next().
 *---------------------------------------------------------------------------*/
VOID KERNENTRY Heap32NextWorker(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    BOOL      fInteresting;
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    
    do {
	if (!AdvanceHeap32(lphe32)) {
	    goto rh_error;
	}
	if (AtEndOfHeap32(lphe32)) {
	    /*
	     *	We might be at the end of the heap, or just at the end of
	     *	this heap segment.  If there is another segment, read its
	     *	header in and process its blocks.
	     */
	    if (lpts->hi.hi_psegnext) {

		lpts->lpbMin = ((DWORD)lpts->hi.hi_psegnext) + sizeof(struct heapseg_s);

		/*
		 *  Read in the next heap segment header and setup our bounds to
		 *  refer to it
		 */
		if (!(SafeReadProcessMemory(lpts->ppdb,
					    (DWORD)lpts->hi.hi_psegnext,
					    &(lpts->hi),
					    sizeof(struct heapseg_s),
					    sizeof(struct heapseg_s)))) {
#ifdef DEBUG
                    DebugOut((DEB_WARN, "Heap32NextWorker(): Invalid or corrupt psegnext: %lx\n", lpts->hi.hi_psegnext));
#endif
		    goto rh_error;
		}


		if (lpts->hi.hi_cbreserve > hpMAXALLOC ||
		    ((lpts->hi.hi_cbreserve) & PAGEMASK)) {
#ifdef DEBUG
                    DebugOut((DEB_WARN, "Heap32NextWorker(): Invalid or corrupt psegnext (3): %lx\n", lpts->lpbMin - sizeof(struct heapseg_s)));
#endif
		    goto rh_error;
		}

		/*
		 *  Setup first block on new segment
		 */
		lpts->lpHBlock = lpts->lpbMin;
		if (!DissectBlockHdr(lphe32,
				     lpts->lpHBlock,
				     &(lpts->dwBlkSize),
				     &(lpts->dwBlkFlags),
				     &(lpts->dwBlkAddr))) {
		    goto rh_error;
		}

	    /*
	     *	If we really are at the end of the heap, we are all done
	     */
	    } else {
		lpts->dwMode = THM_DONE;
		return;
	    }
	}
	fInteresting = TRUE;
	if (!CopyIntoHeap32Entry(lphe32, &fInteresting)) {
	    goto rh_error;
	}
	
    } while (!fInteresting);
    return;
    
    

    
  rh_error:
    lpts->dwMode = THM_ERROR;
    return;
}




/*---------------------------------------------------------------------------
 * Does the real work of Heap32Next(). 
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY RealHeap32Next(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    DWORD     dwMode;
    
    
    if (!(ValidateHeapEntry32(lphe32))) {
	SetError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }
    
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    // In case someone calls this after they've fallen off the end.
    if (lpts == NULL) {
	SetError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }

    EnterCrst(lpts->pcrst);
    Heap32NextWorker(lphe32);
    dwMode = lpts->dwMode;
    LeaveCrst(lpts->pcrst);

    
    if (dwMode == THM_ERROR ||
	dwMode == THM_DONE) {

	if (dwMode == THM_ERROR) {
	    DebugOut((DEB_WARN, "Heap32Next detected corrupted or moving heap. Bailing."));
	    SetError(ERROR_INVALID_DATA);
	} else {
	    SetError(ERROR_NO_MORE_FILES);
	}
	RealHeap32End(lphe32);
	return FALSE;
	
    }

    return TRUE;
    
}



/*---------------------------------------------------------------------------
 * Create the internal state used inside HEAPENTRY32.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY InitHeapEntry32(PPDB ppdb,
			       HANDLE hHeap,
			       LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts = NULL;
    CRST     *pcrst = NULL;
    
    if (!ValidateHeapEntry32(lphe32)) {
	return FALSE;
    }

    EnterMustComplete();

    if (!(lphe32->dwResvd = (DWORD)PvKernelAlloc0(sizeof(THSTATE)))) {
	goto ih_error;
    }
    lpts = (LPTHSTATE)(lphe32->dwResvd);

    if (!(pcrst = lpts->pcrst = NewCrst())) {
	goto ih_error;
    }
    
    lpts->ppdb = ppdb;
    lpts->hHeap = hHeap;
    
    if (!(SafeReadProcessMemory(ppdb,
				(DWORD)hHeap,
				&(lpts->hi),
				sizeof(lpts->hi),
				sizeof(struct heapinfo_s)))) {
#ifdef DEBUG
        DebugOut((DEB_WARN, "Heap32First(): Invalid hHeap: %lx\n", hHeap));
#endif
	goto ih_error;
    }
    
    if (lpts->hi.hi_signature != HI_SIGNATURE) {
#ifdef DEBUG
        DebugOut((DEB_WARN, "Heap32First(): Invalid or corrupt hHeap: %lx\n", hHeap));
#endif
	goto ih_error;
    }
    
    lpts->lpbMin = ( (DWORD)hHeap ) + sizeof(struct heapinfo_s);
    
    if (lpts->hi.hi_cbreserve > hpMAXALLOC ||
	((lpts->hi.hi_cbreserve) & PAGEMASK)) {
#ifdef DEBUG
        DebugOut((DEB_WARN, "Heap32First(): Invalid or corrupt hHeap: %lx\n", hHeap));
#endif
	goto ih_error;
    }
    
    lpts->dwMode = THM_INIT;
    LeaveMustComplete();
    return TRUE;
    

  ih_error:
    if (lpts) {
	FKernelFree(lpts);
    }
    if (pcrst) {
	DisposeCrst(pcrst);
    }
    lphe32->dwResvd = 0;
    LeaveMustComplete();
    return FALSE;
    
}


/***LP	VerifyOnHeap - verifies a given address is on a given heap
 *
 *	Note that no validation is done on the given address except
 *	to check that it is in the range of the heap.
 *
 *	ENTRY:	hheap - heap handle
 *		p - address to verify
 *	EXIT:	0 if not within specified heap, non-zero if on
 */
ULONG INTERNAL
VerifyOnHeap(HHEAP hheap, PVOID p)
{
    struct heapseg_s *pseg;

    /*
     *	Loop through each heap segment and see if the specified address
     *	is within it.
     */
    pseg = (struct heapseg_s *)hheap;
    do {

	if ((unsigned)p > (unsigned)pseg &&
	    (unsigned)p < (unsigned)pseg + pseg->hs_cbreserve) {

	    return(1);	/* found it */
	}
	pseg = pseg->hs_psegnext;
    } while (pseg != 0);

    return(0); /* didn't find it */
}


/***LP  CheckHeapFreeAppHack - See if CVPACK app-hack applies
 *
 *	Check to see if an absolutely sick, disgusting and vomit-inducing
 *	app-hack for link.exe (msvc 1.5) is needed. msvc 1.5. Link.exe
 *	uses the contents of a heap block after it has freed it. 
 *      This routine stack-traces and reads the caller's code
 *	to see if it matches the offending profile. This part is written
 *	in C so we can use try-except.
 */
BOOL KERNENTRY
CheckHeapFreeAppHack(DWORD *lpdwESP, DWORD *lpdwEBP, DWORD dwESI)
{
    BOOL fDoAppHack = FALSE;
    
    _try {
	DWORD *lpdwEIPCaller;
	
	lpdwEIPCaller = (DWORD*)(*lpdwESP);
	if (0xc35de58b == *lpdwEIPCaller) {  // "mov esp,ebp;pop ebp; retd"
	    DWORD *lpdwEIPCallersCaller;
	    lpdwEIPCallersCaller = (DWORD*)(*(lpdwEBP + 1));
	    if (0x8b04c483 == *lpdwEIPCallersCaller &&
		0xf60b0876 == *(lpdwEIPCallersCaller+1)) {
		//"add esp,4; mov esi, [esi+8]; or esi,esi"
		if (dwESI == *(lpdwESP+3)) {
		    fDoAppHack = TRUE;
		}
	    }
	}
    } _except (EXCEPTION_EXECUTE_HANDLER) {
    }
    
    return fDoAppHack;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateprinter.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   EmulatePrinter.cpp

 Abstract:

    This is a general purpose shim to fix all problems we have seen
    that are remotely connected with printers.  The shim fixes the
    following:

    1) Apps call EnumPrinters passing only PRINTER_ENUM_LOCAL but expect to see
       network printers as well. For some reason Win9x enumerates network
       printers as well when this API is called with only PRINTER_ENUM_LOCAL set.

    2) Apps call EnumPrinters passing only PRINTER_ENUM_DEFAULT.  This works
       properly in win98, however the option does not exist in w2k.  This
       API performs the equivalent.

    3) EnumPrinters Level 5 is not really supported on NT.  This API calls
       Level 2 and munges the data into a level 5 structure.

    4) Win9x ignores pDefault parameter for OpenPrinter. Some native Win9x apps
       are unaware about this and assume it is safe to use PRINTER_ALL_ACCESS
       value for DesiredAccess flag, member of pDefault parameter, to open either
       local printer or remote printer server. But Windows NT requires
       SERVER_ALL_ACCESS set for this flag to access remote printer server.
       To emulate Win9x behavior, we override pDefault with NULL value.

    5) If an app calls one of several print APIs with a NULL printer name,
       looks up and supplies the default printer name, or derives it from other params.

    6) Verifies a correct handle was passed to SetPrinter.  Win98 does this
       at the start and if its a bad handle never uses the passed Information,
       however w2k does not check the handle till after looking at the information.
       This can cause an error if Level is 2 and the print buffer is null due to
       a missing check in SetPrinterA. (note: this was fixed in whistler).

    7) Verifies that the stack is correct after the proc set in SetAbortProc is
       called.

    8) Verifies that an initialized DEVMODEA has been passed to ResetDCA.

    9) Checks GetProfileStringA for a WINDOWS DEVICE (i.e. printer).  If one is
       requested then make sure the string is not being truncated, if it is then
       save the full printer name for later use.

   10) Checks for a -1 in the nFromPage for PrintDlgA and corrects it to a zero.
       Note: the OS should handle this as per the manual, however print team no-fixed it
             as too risky to change since -1 is a special value in their code.

 Notes:

    This is a general purpose shim.  This code from this shim was originally
    in two seperate shims enumnetworkprinters and handlenullprintername.

    Also added another SHIM EmulateStartPage to this.

 History:

    11/08/00   mnikkel       created
    12/07/00   prashkud      Added StartPage to this.
    01/25/01   mnikkel       Removed W routines, they were causing problems
                             and were not needed.
    02/07/01   mnikkel       Added check for too long a string, removed fixed printer
                             name sizes.
   02/27/2001  robkenny      Converted to use tcs.h
   05/21/2001  mnikkel       Added PrintDlgA check
   09/13/2001  mnikkel       Changed so that level 5 data being created from Level 2
                             data is only done on win2k.  Level 5 data was fixed for XP.
                             Also added check so shim works with printers shared out on
                             win9X while running on XP.
   12/15/2001  mnikkel       Corrected bug in shim where default printer flag was not
                             being set in enumprintersa.

--*/

#include "precomp.h"
#include <commdlg.h>

// This file and its assumptions need to be verified on an Intl version
#include "LegalStr.h" // BUGBUG

IMPLEMENT_SHIM_BEGIN(EmulatePrinter)
#include "ShimHookMacro.h"

#define MAX_PRINTER_NAME    221
#define MAX_DRIVERPORT_NAME  50

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DocumentPropertiesA)
    APIHOOK_ENUM_ENTRY(OpenPrinterA)
    APIHOOK_ENUM_ENTRY(SetPrinterA)
    APIHOOK_ENUM_ENTRY(CreateDCA)
    APIHOOK_ENUM_ENTRY(ResetDCA)
    APIHOOK_ENUM_ENTRY(EnumPrintersA)
    APIHOOK_ENUM_ENTRY(GetProfileStringA)
    APIHOOK_ENUM_ENTRY(SetAbortProc)
    APIHOOK_ENUM_ENTRY(StartPage)
    APIHOOK_ENUM_ENTRY(DeviceCapabilitiesA)
    APIHOOK_ENUM_ENTRY(AddPrinterConnectionA)
    APIHOOK_ENUM_ENTRY(DeletePrinterConnectionA)
    APIHOOK_ENUM_ENTRY(PrintDlgA)
APIHOOK_ENUM_END

typedef int   (WINAPI *_pfn_SetAbortProc)( HDC hdc, ABORTPROC lpAbortProc );

LPSTR g_pszFullPrinterName = NULL;
LPSTR g_pszPartialPrinterName = NULL;
CRITICAL_SECTION g_critSec;
BOOL g_bWin2k = FALSE;


/*++
    These functions munge data from a Level 2 Information structure
    into a Level 5 information structure.
--*/

BOOL
MungeInfo2TOInfo5_A(
    PRINTER_INFO_2A* pInfo2,
    DWORD cbBuf,
    DWORD dwInfo2Returned,
    PRINTER_INFO_5A* pInfo5,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned)
{
    DWORD dwStringBufferSize = 0;
    LPSTR lpStringBuffer = NULL;

    // First calculate buffer size needed
    for (DWORD i = 0; i < dwInfo2Returned; i++)
    {
        if (pInfo2[i].Attributes & PRINTER_ATTRIBUTE_NETWORK  &&
            !(pInfo2[i].Attributes & PRINTER_ATTRIBUTE_LOCAL) &&
            pInfo2[i].pServerName != NULL &&
            pInfo2[i].pShareName  != NULL)
        {
            if (pInfo2[i].pServerName)
            {
                dwStringBufferSize += strlen(pInfo2[i].pServerName) + 1;
            }

            if (pInfo2[i].pPrinterName)
            {
                dwStringBufferSize += strlen(pInfo2[i].pPrinterName) + 1;
            }

            if (pInfo2[i].pShareName)
            {
                dwStringBufferSize += strlen(pInfo2[i].pShareName) + 1;
            }
        }
        else
        {
            if (pInfo2[i].pPrinterName)
            {
                dwStringBufferSize += strlen(pInfo2[i].pPrinterName) + 1;
            }

            if (pInfo2[i].pPortName)
            {
                dwStringBufferSize += strlen(pInfo2[i].pPortName) + 1;
            }
        }
    }

    // set the buffer size needed
    *pcbNeeded = dwInfo2Returned * sizeof(PRINTER_INFO_5A)
               + dwStringBufferSize;

    // verify that buffer passed in is big enough.
    if (cbBuf < *pcbNeeded)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Allocate the Level 5 information structure
    lpStringBuffer = ((LPSTR) pInfo5)
                     + dwInfo2Returned * sizeof(PRINTER_INFO_5A);

    // Munge the Level 2 information into the Level 5 structure
    for (i = 0; i < dwInfo2Returned; i++)
    {
        if (pInfo2[i].Attributes & PRINTER_ATTRIBUTE_NETWORK  &&
            !(pInfo2[i].Attributes & PRINTER_ATTRIBUTE_LOCAL) &&
            pInfo2[i].pServerName != NULL &&
            pInfo2[i].pShareName  != NULL)
        {
            // Copy over strings
            strcpy( lpStringBuffer, pInfo2[i].pPrinterName );
            pInfo5[i].pPrinterName = lpStringBuffer;
            lpStringBuffer += strlen(pInfo2[i].pPrinterName) + 1;

            strcpy( lpStringBuffer, pInfo2[i].pServerName );
            strcat( lpStringBuffer, "\\" );
            strcat( lpStringBuffer, pInfo2[i].pShareName );

            pInfo5[i].pPortName = lpStringBuffer;
            lpStringBuffer += strlen(pInfo2[i].pServerName) + strlen(pInfo2[i].pShareName) + 2;

            pInfo5[i].Attributes = pInfo2[i].Attributes;
            pInfo5[i].DeviceNotSelectedTimeout = 15000; // Use defaults here
            pInfo5[i].TransmissionRetryTimeout = 45000; // Use defaults here
        }
        else
        {
            // Copy over strings
            strcpy( lpStringBuffer, pInfo2[i].pPrinterName );
            pInfo5[i].pPrinterName = lpStringBuffer;
            lpStringBuffer += strlen(pInfo2[i].pPrinterName) + 1;

            strcpy( lpStringBuffer, pInfo2[i].pPortName );

            pInfo5[i].pPortName = lpStringBuffer;
            lpStringBuffer += strlen(pInfo2[i].pPortName) + 1;

            pInfo5[i].Attributes = pInfo2[i].Attributes;
            pInfo5[i].DeviceNotSelectedTimeout = 15000; // Use defaults here
            pInfo5[i].TransmissionRetryTimeout = 45000; // Use defaults here
        }
    }

    // Set the number of structures munged
    *pcbReturned = dwInfo2Returned;

    return TRUE;
}


/*++

   Our Callback routine for SetAbortProc, this routine
   verifies that the stack is correct.

--*/
DWORD g_dwGuardNum = 0xABCD8765;
DWORD g_dwFailed = 0;

BOOL CALLBACK
AbortProcHook(
    ABORTPROC   pfnOld,     // address of old ABORTPROC
    HDC         hdc,        // handle to DC
    int         iError      // error value
    )
{
    DWORD dwRet= 0;


    // Flag to track whether the stack was corrected.
    g_dwFailed = 0;

    // Push a Guard number on the stack, call their
    // abort procedure, then pop the stack till we
    // find our guard number
    __asm
    {
        push ebx
        push ecx

        push g_dwGuardNum
        push iError
        push hdc

        call pfnOld      ; make call to their abort proc

        mov  ecx,16
    loc1:
        dec  ecx
        pop  ebx
        cmp  ebx, g_dwGuardNum
        jne  loc1

        cmp  ecx, 15
        jz   loc2
        mov  g_dwFailed, 1
    loc2:

        pop  ecx
        pop  ebx

        mov  dwRet, eax
    }

    if (g_dwFailed)
    {
        LOGN( eDbgLevelError, "[AbortProcHook] Fixing incorrect calling convention for AbortProc");
    }

    return (BOOL) dwRet;
}

/*++

 This stub function looks up the device name if pDeviceName is NULL

--*/

LONG
APIHOOK(DocumentPropertiesA)(
    HWND        hWnd,
    HANDLE      hPrinter,
    LPSTR       pDeviceName,
    PDEVMODEA   pDevModeOutput,
    PDEVMODEA   pDevModeInput,
    DWORD       fMode
    )
{
    LONG lRet = -1;
    PRINTER_INFO_2A *pPrinterInfo2A = NULL;

    // if they didn't supply a device name, we need to supply it.
    if (!pDeviceName) {
        LOGN( eDbgLevelError, "[DocumentPropertiesW] App passed NULL for pDeviceName.");

        if (hPrinter) {
            DWORD dwSizeNeeded = 0;
            DWORD dwSizeUsed = 0;

            // get the size
            GetPrinterA(hPrinter, 2, NULL, 0, &dwSizeNeeded);

            if (dwSizeNeeded != 0) {

                // allocate memory for the info
                pPrinterInfo2A = (PRINTER_INFO_2A*) malloc(dwSizeNeeded);
                if (pPrinterInfo2A) {

                    // get the info
                    if (GetPrinterA(hPrinter, 2, (LPBYTE)pPrinterInfo2A, dwSizeNeeded, &dwSizeUsed)) {
                        pDeviceName = pPrinterInfo2A->pPrinterName;
                    }
                }
            }
        }
    }

    if (!pDeviceName) {
        DPFN( eDbgLevelError, "[DocumentPropertiesA] Unable to gather correct pDeviceName."
                 "Problem not fixed.\n");
    }

    lRet = ORIGINAL_API(DocumentPropertiesA)(
        hWnd,
        hPrinter,
        pDeviceName,
        pDevModeOutput,
        pDevModeInput,
        fMode
        );

    if (pPrinterInfo2A) {
        free(pPrinterInfo2A);
    }

    return lRet;
}


/*++
    These functions handle the case of EnumPrinters being called with the
    PRINTER_ENUM_DEFAULT flag.
--*/

BOOL
EnumDefaultPrinterA(
    PRINTER_INFO_2A* pInfo2,
    LPBYTE  pPrinterEnum,
    DWORD cbBuf,
    DWORD Level,
    PRINTER_INFO_5A* pInfo5,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned
    )
{
    LPSTR  pszName = NULL;
    DWORD dwSize = 0;
    HANDLE hPrinter = NULL;
    BOOL bRet= FALSE;
    DWORD dwInfo2Needed = 0;
    DWORD dwDummy;
    BOOL bDefaultFail = TRUE;

    *pcbNeeded = 0;
    *pcbReturned = 0;

    // get the default printer name
    if (GetDefaultPrinterA(NULL, &dwSize) < 1)
    {
        // Now that we have the right size, allocate a buffer
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            pszName = (LPSTR) ShimMalloc( dwSize );
            if (pszName)
            {
                // Now get the default printer with the right buffer size.
                if (GetDefaultPrinterA( pszName, &dwSize ) > 0 )
                {
                    if ( OpenPrinterA( pszName, &hPrinter, NULL ) )
                    {
                        bDefaultFail = FALSE;
                    }
                }
                ShimFree(pszName);
            }
        }
    }

    if ( bDefaultFail )
    {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    // Printer Level 5 is not really supported on win2k.
    // We'll call Level 2 and munge the data into a level 5 structure.
    if ( g_bWin2k &&
         Level == 5 &&
         pcbNeeded != NULL &&
         pcbReturned != NULL)
    {

        LOGN( eDbgLevelError, "[EnumPrintersA] EnumPrintersA called with Level 5 set."
                 "  Fixing up Level 5 information.");

        // get the size needed for the info2 data
        if (GetPrinterA(hPrinter, 2, NULL, 0, &dwInfo2Needed) == 0 &&
            GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            pInfo2 = (PRINTER_INFO_2A *) ShimMalloc( dwInfo2Needed );

            // get the info2 data and munge into level 5 structure
            if (pInfo2 &&
                GetPrinterA(hPrinter, 2, (LPBYTE)pInfo2, dwInfo2Needed, &dwDummy))
            {
                bRet= MungeInfo2TOInfo5_A( pInfo2, cbBuf, 1, pInfo5, pcbNeeded, pcbReturned);
            }

            if (pInfo2)
                ShimFree(pInfo2);
        }
    }

    // Not win2k or not Level 5 so just get info
    else
    {
        *pcbReturned = 1;
        bRet = GetPrinterA(hPrinter, Level, pPrinterEnum, cbBuf, pcbNeeded);
    }

    // Close the printer
    ClosePrinter(hPrinter);

    return bRet;
}


/*++

 These stub functions check for PRINTER_ENUM_DEFAULT, PRINTER_ENUM_LOCAL
 and Level 5 information structures.

--*/

BOOL
APIHOOK(EnumPrintersA)(
    DWORD   Flags,
    LPSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned
    )
{
    BOOL bRet = FALSE;

    DWORD dwInfo2Needed = 0;
    DWORD dwInfo2Returned = 0;
    DWORD dwDummy;

    PRINTER_INFO_2A* pInfo2 = NULL;
    PRINTER_INFO_5A* pInfo5 = (PRINTER_INFO_5A *) pPrinterEnum;

    // Win2k doesn't handle DEFAULT case like win98 did, so we get
    // to do it for them.
    if (Flags == PRINTER_ENUM_DEFAULT )
    {
        LOGN( eDbgLevelError, "[EnumPrintersA] Called with PRINTER_ENUM_DEFAULT flag."
                "  Providing Default printer.");

        bRet = EnumDefaultPrinterA(
                    pInfo2,
                    pPrinterEnum,
                    cbBuf,
                    Level,
                    pInfo5,
                    pcbNeeded,
                    pcbReturned);

        return bRet;
    }

    // For LOCAL also add in CONNECTIONS
    if (Flags == PRINTER_ENUM_LOCAL)
    {
        LOGN( eDbgLevelInfo, "[EnumPrintersA] Called only for "
            "PRINTER_ENUM_LOCAL. Adding PRINTER_ENUM_CONNECTIONS\n");

        Flags = (PRINTER_ENUM_CONNECTIONS | PRINTER_ENUM_LOCAL);
    }

    // Printer Level 5 is not really supported on win2k.
    // We'll call Level 2 and munge the data into a level 5 structure.
    if ( g_bWin2k &&
         Level == 5 &&
         pcbNeeded != NULL &&
         pcbReturned != NULL)
    {
        // get the size needed for the info2 data
        ORIGINAL_API(EnumPrintersA)(Flags,
                                      Name,
                                      2,
                                      NULL,
                                      0,
                                      &dwInfo2Needed,
                                      &dwInfo2Returned);

        if (dwInfo2Needed > 0)
        {
            // Printers found, get the info2 data and convert it to info5
            pInfo2 = (PRINTER_INFO_2A *) ShimMalloc( dwInfo2Needed );

            if (pInfo2 &&
                ORIGINAL_API(EnumPrintersA)(Flags,
                                              Name,
                                              2,
                                              (LPBYTE) pInfo2,
                                              dwInfo2Needed,
                                              &dwDummy,
                                              &dwInfo2Returned) )
            {
                bRet = MungeInfo2TOInfo5_A( pInfo2,
                                           cbBuf,
                                           dwInfo2Returned,
                                           pInfo5,
                                           pcbNeeded,
                                           pcbReturned);
            }


            if(pInfo2)
                ShimFree( pInfo2 );
        }
    }
    else
    {
        bRet = ORIGINAL_API(EnumPrintersA)(Flags,
                                           Name,
                                           Level,
                                           pPrinterEnum,
                                           cbBuf,
                                           pcbNeeded,
                                           pcbReturned);
    }

    // For level 2 and level 5 there are some win95 only attributes
    // that need to be emulated.
    if ( (Level == 2 || Level == 5) &&
         bRet &&
         pPrinterEnum != NULL )
    {
        DWORD dwSize;

        GetDefaultPrinterA(NULL, &dwSize);

        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            // Now that we have the right size, allocate a buffer
            LPSTR pszName = (LPSTR) ShimMalloc( dwSize );

            if (pszName)
            {
                // Now get the default printer with the right buffer size.
                if (GetDefaultPrinterA( pszName, &dwSize ) > 0 )
                {
                    if (Level == 2)
                    {
                        if (strcmp( pszName, ((PRINTER_INFO_2A*)pPrinterEnum)->pPrinterName) == 0)
                        {
                            ((PRINTER_INFO_2A*)pPrinterEnum)->Attributes |= PRINTER_ATTRIBUTE_DEFAULT;
                        }
                    }
                    else
                    {
                        if (strcmp( pszName, ((PRINTER_INFO_5A*)pPrinterEnum)->pPrinterName) == 0)
                            ((PRINTER_INFO_5A*)pPrinterEnum)->Attributes |= PRINTER_ATTRIBUTE_DEFAULT;
                    }
                }

                ShimFree(pszName);
            }
        }
    }

    return bRet;
}


/*++
   These stub functions substitute the default printer if the pPrinterName is NULL,
   also they set pDefault to NULL to emulate win9x behavior
--*/

BOOL
APIHOOK(OpenPrinterA)(
    LPSTR pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTSA pDefault
    )
{
    LPSTR  pszName = NULL;
    DWORD dwSize;
    BOOL bDefaultFail = TRUE;
    BOOL bRet;

    if (!pPrinterName)
    {
        LOGN( eDbgLevelError, "[OpenPrinterA] App passed NULL for pPrinterName, using default printer.");

        // get the default printer name
        if (GetDefaultPrinterA(NULL, &dwSize) < 1)
        {
            // Now that we have the right size, allocate a buffer
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                pszName = (LPSTR) ShimMalloc( dwSize );
                if (pszName)
                {
                    // Now get the default printer with the right buffer size.
                    if (GetDefaultPrinterA( pszName, &dwSize ) > 0 )
                    {
                        pPrinterName = pszName;
                        bDefaultFail = FALSE;
                    }
                }
            }
        }

        if ( bDefaultFail )
        {
            DPFN( eDbgLevelError, "[OpenPrinterA] Unable to gather default pPrinterName.\n");
        }
    }
    else
    {
        if ( pPrinterName && g_pszPartialPrinterName && g_pszFullPrinterName &&
             0 == strcmp(g_pszPartialPrinterName, pPrinterName) )
        {
            pPrinterName = g_pszFullPrinterName;
        }
    }

    if ( pPrinterName )
    {
        DPFN( eDbgLevelInfo, "[OpenPrinterA] APIHOOK(OpenPrinterA: pPrinterName: %s\n", pPrinterName);
    }
    DPFN( eDbgLevelInfo, "[OpenPrinterA] APIHOOK(OpenPrinterA: pDefault: %x\n", pDefault);
    DPFN( eDbgLevelInfo, "[OpenPrinterA] APIHOOK(OpenPrinterA: overriding pDefault with NULL value\n");

    bRet = ORIGINAL_API(OpenPrinterA)(
                pPrinterName,
                phPrinter,
                NULL);

    ShimFree(pszName);

    return bRet;
}

/*++
   This stub function checks to see if the app is asking for the default printer
   string.  If it is it will be returned as follows:

          PrinterName, Driver, Port

    On Win9x, if the printer is a network printer, Port is \\server\share and
    local printers are Port: (ex. LPT1:).
    On Win2k, if the printer is a network printer, Port is NeXX: and local printers
    are Port: .
    We must query EnumPrinters in order to emulate Win9x.  Note:  If the printer
    name is to large for the input buffer we trim it and keep track of the full
    name for later us in other printer APIs.
--*/
DWORD
APIHOOK(GetProfileStringA)(
  LPCSTR lpAppName,        // section name
  LPCSTR lpKeyName,        // key name
  LPCSTR lpDefault,        // default string
  LPSTR lpReturnedString,  // destination buffer
  DWORD nSize               // size of destination buffer
)
{
    if ( lpAppName &&
         lpKeyName &&
         0 == _stricmp(lpAppName, "windows") &&
         0 == _stricmp(lpKeyName, "device" ) )
    {
        LPSTR pszProfileString = NULL;
        DWORD dwSize = 0;
        BOOL bDefaultFail = TRUE;
        DWORD dwProfileStringLen;
        LPSTR pszPrinterDriver = NULL;
        LPSTR pszPrinterPort = NULL;
        LPSTR pszName = NULL;
        DWORD dwPrinterNameSize = 0;
        DWORD dwDelimiterCount = 0;
        LPSTR pszPtr;

        // get the default printer name
        if (GetDefaultPrinterA(NULL, &dwSize) <1)
        {
            // Now that we have the right size, allocate a buffer
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                pszName = (LPSTR) ShimMalloc( dwSize );
                if (pszName)
                {
                    // Now get the default printer with the right buffer size.
                    if (GetDefaultPrinterA( pszName, &dwSize ) > 0 )
                    {
                        bDefaultFail = FALSE;
                    }
                }
            }
        }

        ShimFree(pszName);

        if ( bDefaultFail )
        {
            // Unable to get the default printername.  Fall back to the max
            // size printer name that the UI allows plus a pad for the driver
            // and port names.
            dwSize = MAX_PRINTER_NAME + MAX_DRIVERPORT_NAME;
        }
        else
        {
            // We have the printer name size add in a pad for the driver and
            // port names.
            dwSize += MAX_DRIVERPORT_NAME;
        }

        // Allocate the string
        pszProfileString = (LPSTR) ShimMalloc(dwSize);

        // Retrieve the profile string
        dwProfileStringLen = ORIGINAL_API(GetProfileStringA)( lpAppName,
                                                              lpKeyName,
                                                              lpDefault,
                                                              pszProfileString,
                                                              dwSize );

        if (dwProfileStringLen != NULL)
        {
            // Find the first and second commas.
            pszPtr = pszProfileString;
            while (*pszPtr)
            {
                if (*pszPtr == ',')
                {
                    dwDelimiterCount++;

                    if (dwDelimiterCount == 1 && *(pszPtr+1))
                    {
                        pszPrinterDriver= pszPtr;
                    }
                    else if (dwDelimiterCount == 2 && *(pszPtr+1))
                    {
                        pszPrinterPort = pszPtr + 1;
                        break;
                    }
                }

                pszPtr++;
            }

            DPFN( eDbgLevelError, "[GetProfileStringA] Profilestring <%s>\n Driver <%s>\n Port <%s>", pszProfileString, pszPrinterDriver,pszPrinterPort);

            // Check to see if this is a network printer
            if ( strstr(pszProfileString, ",Ne") )
            {
                PRINTER_INFO_2A* pInfo2 = NULL;
                DWORD dwInfo2Needed = 0;
                DWORD dwInfo2Returned = 0;
                DWORD dwDummy = 0;
                DWORD i;
                BOOL  bEnumPrintersSuccess;
                BOOL  bDefaultFound = FALSE;

                // Get the size of the Level 2 structure needed.
                bEnumPrintersSuccess = EnumPrintersA( PRINTER_ENUM_CONNECTIONS | PRINTER_ENUM_LOCAL,
                                                      NULL,
                                                      2,
                                                      NULL,
                                                      0,
                                                      &dwInfo2Needed,
                                                      &dwInfo2Returned );

                // Get the Level 2 Info structure for the printer.
                pInfo2 = (PRINTER_INFO_2A *) ShimMalloc( dwInfo2Needed );

                bEnumPrintersSuccess = EnumPrintersA( PRINTER_ENUM_CONNECTIONS | PRINTER_ENUM_LOCAL,
                                                      NULL,
                                                      2,
                                                      (LPBYTE) pInfo2,
                                                      dwInfo2Needed,
                                                      &dwDummy,
                                                      &dwInfo2Returned );

                if (bEnumPrintersSuccess)
                {
                    // Search for default printer in PRINTER_INFO_2 array
                    for (i = 0; i < dwInfo2Returned; i++)
                    {
                        if (0 != strstr(pszProfileString, pInfo2[i].pPrinterName))
                        {
                            bDefaultFound = TRUE;
                            break;
                        }
                    }

                    if ( bDefaultFound )
                    {
                        // Double check that this is a network printer and does not have
                        // local attribute
                        if (pInfo2[i].Attributes & PRINTER_ATTRIBUTE_NETWORK  &&
                            !(pInfo2[i].Attributes & PRINTER_ATTRIBUTE_LOCAL) &&
                            pInfo2[i].pServerName != NULL &&
                            pInfo2[i].pShareName  != NULL)
                        {
                            // Modify the Port to conform with Win9x standards.
                            LOGN( eDbgLevelInfo, "[GetProfileStringA] Altering default printer string returned by GetProfileStringA.\n");
                            DPFN( eDbgLevelInfo, "[GetProfileStringA] Old: %s\n", pszProfileString);

                            strcpy(pszPrinterPort, pInfo2[i].pServerName);
                            strcat(pszPrinterPort, "\\");
                            strcat(pszPrinterPort, pInfo2[i].pShareName);
                        }
                        else
                        {
                            // Just copy in the port
                            strcpy( pszPrinterPort, pInfo2[i].pPortName );
                        }
                        dwProfileStringLen = strlen(pszProfileString);
                    }
                }

                ShimFree(pInfo2);
            }

            // If the size they give is big enough, then return.
            dwPrinterNameSize = pszPrinterDriver - pszProfileString;
            if ( dwProfileStringLen < nSize )
            {
                strcpy( lpReturnedString, pszProfileString );
                DPFN( eDbgLevelInfo, "[GetProfileStringA] Default Printer: %s  Size: %d\n",
                    lpReturnedString, strlen(lpReturnedString));
                return strlen(lpReturnedString);
            }

            // Modify the printer name and keep a global of the original if the printer
            // name causes the profile string output buffer to overflow.
            // If the size we need to reduce it by is greater than the size of
            // the printer name we're screwed, pass through.
            dwPrinterNameSize -= (dwProfileStringLen - nSize);
            if ( dwPrinterNameSize > 0 )
            {
                DPFN( eDbgLevelInfo, "[GetProfileStringA] Reducing printer name by %d characters.\n",
                     dwProfileStringLen - nSize );
                LOGN( eDbgLevelInfo, "[GetProfileStringA] Reducing printer name by %d characters.\n",
                     dwProfileStringLen - nSize );

                // copy in the truncated printer name.
                strncpy( lpReturnedString, pszProfileString, dwPrinterNameSize );
                strcat( lpReturnedString, pszPrinterDriver );

                EnterCriticalSection(&g_critSec);

                // Release any previous allocations.
                if (g_pszPartialPrinterName && g_pszFullPrinterName)
                {
                    ShimFree(g_pszPartialPrinterName);
                    ShimFree(g_pszFullPrinterName);
                }

                // save the partial and full printer names for later use.
                g_pszPartialPrinterName = (LPSTR)ShimMalloc(dwPrinterNameSize+1);
                strncpy( g_pszPartialPrinterName, pszProfileString, dwPrinterNameSize );
                g_pszPartialPrinterName[dwPrinterNameSize] = '\0';

                g_pszFullPrinterName = (LPSTR)ShimMalloc(pszPrinterDriver-pszProfileString+1);
                strncpy( g_pszFullPrinterName, pszProfileString, (pszPrinterDriver - pszProfileString) );
                g_pszFullPrinterName[pszPrinterDriver - pszProfileString] = '\0';

                LeaveCriticalSection(&g_critSec);

                DPFN( eDbgLevelInfo, "[GetProfileStringA] Partial: %s   Full: %s\n",
                    g_pszPartialPrinterName, g_pszFullPrinterName );
                DPFN( eDbgLevelInfo, "[GetProfileStringA] New: %s  Size: %d\n",
                    lpReturnedString, strlen(lpReturnedString));

                // return the modified string size.
                return strlen(lpReturnedString);
            }
        }
    }

    // Either an error occurred or its not asking for default printer.
    // pass through.
    return ORIGINAL_API(GetProfileStringA)( lpAppName,
                                            lpKeyName,
                                            lpDefault,
                                            lpReturnedString,
                                            nSize);
}


/*++

 This stub function pulls the device name from the DEVMODE if pszDevice is NULL
 and the DC is not for DISPLAY

--*/


HDC
APIHOOK(CreateDCA)(
    LPCSTR     pszDriver,
    LPCSTR     pszDevice,
    LPCSTR     pszPort,
    CONST DEVMODEA *pdm
    )
{
    // if they've used a NULL device, but included a printer devmode,
    // fill in the device name from the printer devmode
    if (!pszDevice && pdm && (!pszDriver || _stricmp(pszDriver, "DISPLAY") != 0)) {
        LOGN( eDbgLevelError, "[CreateDCA] App passed NULL for pszDevice. Fixing.");
        pszDevice = (LPCSTR)pdm->dmDeviceName;
    }

    return ORIGINAL_API(CreateDCA)(
        pszDriver,
        pszDevice,
        pszPort,
        pdm
        );
}


/*++

 This stub function verifies that ResetDCA hasn't been handed an
 uninitialized InitData.

--*/
HDC
APIHOOK(ResetDCA)(
  HDC hdc,
  CONST DEVMODEA *lpInitData
)
{
    // Sanity checks to make sure we aren't getting garbage
    // or bad values.
    if ( lpInitData &&
         lpInitData->dmSize > sizeof( DEVMODEA ) ||
         ( lpInitData->dmSpecVersion != 0x401 &&
           lpInitData->dmSpecVersion != 0x400 &&
           lpInitData->dmSpecVersion != 0x320 ) )
    {
        LOGN( eDbgLevelError, "[ResetDCA] App passed bad DEVMODE structure, nulling.");
        return ORIGINAL_API(ResetDCA)( hdc, NULL );
    }

    return ORIGINAL_API(ResetDCA)( hdc, lpInitData );
}


/*++

 These stub functions verify that SetPrinter has a valid handle
 before proceeding.

--*/
BOOL
APIHOOK(SetPrinterA)(
    HANDLE hPrinter,  // handle to printer object
    DWORD Level,      // information level
    LPBYTE pPrinter,  // printer data buffer
    DWORD Command     // printer-state command
    )
{
    BOOL bRet;

    if (hPrinter == NULL)
    {
        LOGN( eDbgLevelError, "[SetPrinterA] Called with null handle.");
        if (pPrinter == NULL)
            LOGN( eDbgLevelError, "[SetPrinterA] Called with null printer data buffer.");
        return FALSE;
    }
    else if (pPrinter == NULL)
    {
        LOGN( eDbgLevelError, "[SetPrinterA] Called with null printer data buffer.");
        return FALSE;
    }

    bRet= ORIGINAL_API(SetPrinterA)(
                    hPrinter,
                    Level,
                    pPrinter,
                    Command);

    DPFN( eDbgLevelSpew, "[SetPrinterA] Level= %d  Command= %d  Ret= %d\n",
         Level, Command, bRet );

    return bRet;
}


/*++

   This routine hooks the SetAbortProc and replaces their
   callback with ours.
--*/

int
APIHOOK(SetAbortProc)(
    HDC hdc,                // handle to DC
    ABORTPROC lpAbortProc   // abort function
    )
{
    lpAbortProc = (ABORTPROC) HookCallback(lpAbortProc, AbortProcHook);

    return ORIGINAL_API(SetAbortProc)( hdc, lpAbortProc );
}

/*++
    When  apps start printing, they set a viewport
    on the printDC. They then call StartPage which has a different behaviour
    on 9x and WinNT. On 9x, a next call to StartPage resets the DC attributes
    to the default values.However on NT, the next call to StartPage does not
    reset the DC attributes.
        So, on 9x all subsequent output setup and drawing calls are carried
    out with a (0,0) viewport but on NT the viewport is leftover from its
    initial call. Since some apps(eg. Quicken 2000 and 2001) expect the API
    setting the (0,0) viewport,the result will be that the text and the
    lines are clipped on the left and top of the page.

    Here we hook StartPage and call SetViewportOrgEx(hdc, 0, 0, NULL) to
    set the viewport to (0,0) on every call to StartPage to emulate
    the 9x behaviour.

--*/

BOOL
APIHOOK(StartPage)(
    HDC hdc
    )
{

    if (SetViewportOrgEx(hdc, 0, 0, NULL))
    {
        // We have now made the device point(viewport) map to (0, 0).
        LOGN( eDbgLevelInfo, "[StartPage] Setting the device point map to (0,0).");
    }
    else
    {
        LOGN( eDbgLevelError, "[StartPage] Unable to set device point map to (0,0)."
                                              "Failed in a call to SetViewportOrgEx");
    }

    return ORIGINAL_API(StartPage)(hdc);

}

/*++
 This stub function verifies that DeviceCapabilities is using a correct
 printer name.
--*/
DWORD
APIHOOK(DeviceCapabilitiesA)(
  LPCSTR pDevice,
  LPCSTR pPort,
  WORD fwCapability,
  LPSTR pOutput,
  CONST DEVMODE *pDevMode
)
{
    DWORD dwRet;

    if ( pDevice && g_pszPartialPrinterName && g_pszFullPrinterName &&
         0 == strcmp(g_pszPartialPrinterName, pDevice) )
    {
        pDevice = g_pszFullPrinterName;
    }

    dwRet= ORIGINAL_API(DeviceCapabilitiesA)( pDevice,
                                             pPort,
                                             fwCapability,
                                             pOutput,
                                             pDevMode );

    if ( pDevice && pPort )
    {
        DPFN( eDbgLevelSpew, "[DeviceCapabilitiesA] pDevice= %s  pPort= %s  fwC= %d  Out= %x  RC= %d\n",
             pDevice, pPort, fwCapability, pOutput, dwRet );
    }
    else
    {
        DPFN( eDbgLevelSpew, "[DeviceCapabilitiesA] fwC= %d  Out= %x  RC= %d\n",
             fwCapability, pOutput, dwRet );
    }

    return dwRet;
}

/*++
 This stub function verifies that AddPrinterConnection is using a correct
 printer name.
--*/
BOOL
APIHOOK(AddPrinterConnectionA)(
  LPSTR pName
)
{
    if ( pName && g_pszPartialPrinterName && g_pszFullPrinterName &&
         0 == strcmp(g_pszPartialPrinterName, pName) )
    {
        pName = g_pszFullPrinterName;
    }

    return ORIGINAL_API(AddPrinterConnectionA)( pName );
}

/*++
 This stub function verifies that DeletePrinterConnection is using a correct
 printer name.
--*/
BOOL
APIHOOK(DeletePrinterConnectionA)(
  LPSTR pName
)
{
    if ( pName && g_pszPartialPrinterName && g_pszFullPrinterName &&
         0 == strcmp(g_pszPartialPrinterName, pName) )
    {
        pName = g_pszFullPrinterName;
    }

    return ORIGINAL_API(DeletePrinterConnectionA)( pName );
}

/*++
 This stub function verifies that PrintDlgA is using a correct
 nFromPage and nToPage.
--*/

BOOL
APIHOOK(PrintDlgA)(
  LPPRINTDLG lppd
)
{
    // check nFromPage and nToPage for legal values.
    if ( lppd )
    {
        DPFN( eDbgLevelSpew, "[PrintDlgA] nFromPage = %d  nToPage = %d",
              lppd->nFromPage, lppd->nToPage);

        if ( lppd->nFromPage == 0xffff )
        {
            lppd->nFromPage = 0;
            DPFN( eDbgLevelInfo, "[PrintDlgA] Setting nFromPage to 0." );
        }

        if ( lppd->nToPage == 0xffff)
        {
            lppd->nToPage = lppd->nFromPage;
            DPFN( eDbgLevelInfo, "[PrintDlgA] Setting nToPage to %d.", lppd->nFromPage );
        }
    }

    return ORIGINAL_API(PrintDlgA)(lppd);
}


/*++

 Register hooked functions

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        OSVERSIONINFOEX osvi;
        BOOL bOsVersionInfoEx;

        InitializeCriticalSection(&g_critSec);

        // Check to see if we are under win2k
        ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi);

        if(bOsVersionInfoEx)
        {
            if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
                 osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0 )
            {
                g_bWin2k = TRUE;
            }
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(WINSPOOL.DRV, DocumentPropertiesA);
    APIHOOK_ENTRY(WINSPOOL.DRV, OpenPrinterA);
    APIHOOK_ENTRY(WINSPOOL.DRV, SetPrinterA);
    APIHOOK_ENTRY(WINSPOOL.DRV, EnumPrintersA);
    APIHOOK_ENTRY(WINSPOOL.DRV, OpenPrinterA);
    APIHOOK_ENTRY(WINSPOOL.DRV, DeviceCapabilitiesA);
    APIHOOK_ENTRY(WINSPOOL.DRV, AddPrinterConnectionA);
    APIHOOK_ENTRY(WINSPOOL.DRV, DeletePrinterConnectionA);

    APIHOOK_ENTRY(COMDLG32.DLL, PrintDlgA);

    APIHOOK_ENTRY(KERNEL32.DLL,GetProfileStringA);

    APIHOOK_ENTRY(GDI32.DLL, CreateDCA);
    APIHOOK_ENTRY(GDI32.DLL, ResetDCA);
    APIHOOK_ENTRY(GDI32.DLL, SetAbortProc);
    APIHOOK_ENTRY(GDI32.DLL, StartPage);

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateplaysound.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulatePlaySound.cpp

 Abstract:

    If an app calls PlaySound with a SND_LOOP flag, the sould plays 
    continuously until PlaySound is called with a NULL sound name.  Win9x will 
    automatically stop the sound if a different sound is played.  This shim 
    will catch all PlaySound calls, remember the current sound and 
    automatically stop it if a different sound is to be played.

 History:

    04/05/1999 robkenny

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulatePlaySound)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(PlaySoundA)
    APIHOOK_ENUM_ENTRY(PlaySoundW)
    APIHOOK_ENUM_ENTRY(sndPlaySoundA)
    APIHOOK_ENUM_ENTRY(sndPlaySoundW)
APIHOOK_ENUM_END

/*++

 Fix the flags

--*/

BOOL
APIHOOK(PlaySoundA)(
    LPCSTR  pszSound,  
    HMODULE hmod,     
    DWORD   fdwSound    
    )
{
    //
    // Force the flags to 0 if they want to stop the current sound.
    //

    if (pszSound == NULL) {
        fdwSound = 0;
    }

    return ORIGINAL_API(PlaySoundA)(pszSound, hmod, fdwSound);
}

/*++

 Fix the flags

--*/

BOOL
APIHOOK(PlaySoundW)(
    LPCWSTR pszSound,  
    HMODULE hmod,     
    DWORD   fdwSound    
    )
{
    //
    // Force the flags to 0 if they want to stop the current sound.
    //

    if (pszSound == NULL) {
        fdwSound = 0;
    }

    return ORIGINAL_API(PlaySoundW)(pszSound, hmod, fdwSound);
}

/*++

 Fix the flags

--*/

BOOL
APIHOOK(sndPlaySoundA)(
    LPCSTR pszSound,  
    UINT   fuSound       
    )
{
    //
    // Force the flags to 0 if they want to stop the current sound.
    //

    if (pszSound == NULL) {
        fuSound = 0;
    }

    return ORIGINAL_API(sndPlaySoundA)(pszSound, fuSound);
}

/*++

 Fix the flags.

--*/

BOOL
APIHOOK(sndPlaySoundW)(
    LPCWSTR pszSound,  
    UINT    fuSound       
    )
{
    //
    // Force the flags to 0 if they want to stop the current sound.
    //

    if (pszSound == NULL) {
        fuSound = 0;
    }

    return ORIGINAL_API(sndPlaySoundW)(pszSound, fuSound);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, PlaySoundA)
    APIHOOK_ENTRY(WINMM.DLL, PlaySoundW)
    APIHOOK_ENTRY(WINMM.DLL, sndPlaySoundA)
    APIHOOK_ENTRY(WINMM.DLL, sndPlaySoundW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatemissingexe.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateMissingEXE.cpp

 Abstract:

    Win9x had scandskw.exe and defrag.exe in %windir%, NT does not.
    Whistler has a hack in the shell32 for scandisk for app compatability
    purposes.  Whistler can also invoke defrag via 
    "%windir%\system32\mmc.exe %windir%\system32\dfrg.msc".

    This shim redirects CreateProcess and Winexec to execute these two
    substitutes, as well as FindFile to indicate their presence.

 Notes:

    This is a general purpose shim.

 History:

    01/02/2001  prashkud Created
    02/18/2001  prashkud Merged HandleStartKeyword SHIM with this.
    02/21/2001  prashkud Replaced most strings with CString class.                   

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateMissingEXE)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(WinExec)
    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileW)
    APIHOOK_ENUM_ENTRY_COMSERVER(SHELL32)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(SHELL32)

// Type for the functions that builds the New EXES
typedef BOOL (*_pfn_STUBFUNC)(CString&, CString&, BOOL);

// Main Data structure to hold the New strings
struct REPLACEENTRY {
    WCHAR *OrigExeName;                 // original EXE to be replaced
    _pfn_STUBFUNC pfnFuncName;          // function to call to correct the name
};

CRITICAL_SECTION g_CritSec;
WCHAR g_szSysDir[MAX_PATH];             // system directory for stubs to use

BOOL StubScandisk(CString&, CString&, BOOL);
BOOL StubDefrag(CString&, CString&, BOOL);
BOOL StubStart(CString&, CString&, BOOL);
BOOL StubControl(CString&, CString&, BOOL);
BOOL StubDxDiag(CString&, CString&, BOOL);
BOOL StubWinhlp(CString&, CString&, BOOL);
BOOL StubRundll(CString&, CString&, BOOL);
BOOL StubPbrush(CString&, CString&, BOOL);

// Add variations of these missing Exes like in HandleStartKeyword                             
// Start has been put at the top of the list as there seem to be more apps
// that need the SHIM for this EXE than others. In fact there was a 
// seperate SHIM HandleStartKeyword that was merged with this.
REPLACEENTRY g_ReplList[] = {
    {L"start",        StubStart    },
    {L"start.exe",    StubStart    },    
    {L"scandskw",     StubScandisk },
    {L"scandskw.exe", StubScandisk },
    {L"defrag",       StubDefrag   },
    {L"defrag.exe",   StubDefrag   },
    {L"control",      StubControl  },
    {L"control.exe",  StubControl  },
    {L"dxdiag",       StubDxDiag   },
    {L"dxdiag.exe",   StubDxDiag   },
    {L"winhelp",      StubWinhlp   },
    {L"winhelp.exe",  StubWinhlp   },
    {L"rundll",       StubRundll   },
    {L"rundll.exe",   StubRundll   },
    {L"Pbrush",       StubPbrush   },    
    {L"Pbrush.exe",   StubPbrush   },    
    // Always the last one
    {L"",             NULL         }
};

// Added to merge HandleStartKeyword
// Link list of shell link object this pointers.
struct THISPOINTER
{
    THISPOINTER *next;
    LPCVOID pThisPointer;
};

THISPOINTER *g_pThisPointerList;

/*++

 Function Description:

    Add a this pointer to the linked list of pointers. Does not add if the
    pointer is NULL or a duplicate.

 Arguments:

    IN  pThisPointer - the pointer to add.

 Return Value:

    None

 History:

    12/14/2000 maonis Created

--*/

VOID 
AddThisPointer(
    IN LPCVOID pThisPointer
    )
{
    EnterCriticalSection(&g_CritSec);

    if (pThisPointer)
    {
        THISPOINTER *pPointer = g_pThisPointerList;
        while (pPointer)
        {
            if (pPointer->pThisPointer == pThisPointer)
            {
                return;
            }
            pPointer = pPointer->next;
        }

        pPointer = (THISPOINTER *) malloc(sizeof THISPOINTER);

        if (pPointer)
        {
            pPointer->pThisPointer = pThisPointer;
            pPointer->next = g_pThisPointerList;
            g_pThisPointerList = pPointer;
        }      
    }

    LeaveCriticalSection(&g_CritSec);
}

/*++

 Function Description:

    Remove a this pointer if it can be found in the linked list of pointers. 

 Arguments:

    IN  pThisPointer - the pointer to remove.

 Return Value:

    TRUE if the pointer is found.
    FALSE if the pointer is not found.

 History:

    12/14/2000 maonis Created

--*/

BOOL 
RemoveThisPointer(
    IN LPCVOID pThisPointer
    )
{
    THISPOINTER *pPointer = g_pThisPointerList;
    THISPOINTER *last = NULL;
    BOOL lRet = FALSE;
    
    EnterCriticalSection(&g_CritSec);

    while (pPointer)
    {
        if (pPointer->pThisPointer == pThisPointer)
        {
            if (last)
            {
                last->next = pPointer->next;
            }
            else
            {
                g_pThisPointerList = pPointer->next;
            }

            free(pPointer);
            lRet = TRUE;    
            break;
        }

        last = pPointer;
        pPointer = pPointer->next;
    }

    LeaveCriticalSection(&g_CritSec);
    return lRet;
}


/*++

 We are here because the application name: scandskw.exe, matches the one in the 
 static array. Fill the News for scandskw.exe as: 

    rundll32.exe shell32.dll,AppCompat_RunDLL SCANDSKW

--*/

BOOL
StubScandisk(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL bExists
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\rundll32.exe";
    csNewCommandLine     = L"shell32.dll,AppCompat_RunDLL SCANDSKW";

    return TRUE;

}

/*++

 We are here because the application name: defrag.exe, matches the one in the 
 static array. Fill the News for .exe as:
    
    %windir%\\system32\\mmc.exe %windir%\\system32\\dfrg.msc

--*/

BOOL
StubDefrag(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL bExists
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\mmc.exe";

    csNewCommandLine =  g_szSysDir;
    csNewCommandLine += L"\\dfrg.msc";
    return TRUE;
}

/*++

 We are here because the application name: start.exe, matches the one in the 
 static array. Fill the News for .exe as: 
 
    %windir%\\system32\\cmd.exe" "/c start"

 Many applications have a "start.exe" in their current working directories 
 which needs to take precendence over any New we make.

--*/

BOOL
StubStart(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL bExists
    )
{
    //
    // First check the current working directory for start.exe
    //

    if (bExists) {
        return FALSE;
    }

    // 
    // There is no start.exe in the current working directory
    //
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\cmd.exe";
    csNewCommandLine     = L"/d /c start \"\"";

    return TRUE;
}

/*++

 We are here because the application name: control.exe, matches the one in the 
 static array. Fill the News for .exe as:
 
    %windir%\\system32\\control.exe

--*/

BOOL
StubControl(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL bExists
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\control.exe";
    csNewCommandLine     = L"";        

    return TRUE;

}

/*++

 We are here because the application name: dxdiag.exe, matches the one in the 
 static array. Fill the News for .exe as:
 
    %windir%\system32\dxdiag.exe

--*/

BOOL
StubDxDiag(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL bExists
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\dxdiag.exe";
    csNewCommandLine     = L"";

    return TRUE;
}

/*++

 We are here because the application name: Winhlp.exe, matches the one in the 
 static array. Fill the News for .exe as:
 
    %windir%\system32\winhlp32.exe

--*/

BOOL
StubWinhlp(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL bExists
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\winhlp32.exe";
    // Winhlp32.exe needs the app name to be in the commandline.
    csNewCommandLine = csNewApplicationName;        

    return TRUE;
}

/*++

 We are here because the application name: rundll.exe matches the one in the 
 static array. Fill the News for .exe as:
 
    %windir%\system32\rundll32.exe

--*/

BOOL
StubRundll(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL bExists
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\rundll32.exe";
    csNewCommandLine     = L"";

    return TRUE;
}

/*++

 We are here because the application name: Pbrush.exe matches the one in the 
 static array. Fill the New for .exe as:
 
    %windir%\system32\mspaint.exe

--*/

BOOL
StubPbrush(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL bExists
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\mspaint.exe";
    csNewCommandLine     = L"";

    return TRUE;
}

/*++

 GetTitle takes the app path and returns just the EXE name.

--*/

VOID
GetTitle(CString& csAppName,CString& csAppTitle)
{
    csAppTitle = csAppName;
    int len = csAppName.ReverseFind(L'\\');
    if (len)
    {
        csAppTitle.Delete(0, len+1);
    }    
}

/*++

 This is the main function where the New logic happens. This function 
 goes through the static array and fills the suitable New appname and 
 the commandline.

--*/

BOOL
Redirect(
    const CString& csApplicationName, 
    const CString& csCommandLine,
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL  bJustCheckExePresence
    )
{
    BOOL bRet = FALSE;
    CSTRING_TRY
    {    

        CString csOrigAppName;
        CString csOrigCommandLine;
        BOOL bExists = FALSE;

        AppAndCommandLine AppObj(csApplicationName, csCommandLine);
        csOrigAppName = AppObj.GetApplicationName();
        csOrigCommandLine = AppObj.GetCommandlineNoAppName();

        if (csOrigAppName.IsEmpty())
        {
            goto Exit;
        }

        //
        // Loop through the list of redirectors 
        //
    
        REPLACEENTRY *rEntry = &g_ReplList[0];
        CString csAppTitle;
        GetTitle(csOrigAppName, csAppTitle);    

        while (rEntry && rEntry->OrigExeName[0])
        {
            if (_wcsicmp(rEntry->OrigExeName, csAppTitle) == 0)
            {
                //
                // This final parameter has been added for the merger
                // of HandleStartKeyword Shim. If this is TRUE, we don't
                // go any further but just return.
                //
                if (bJustCheckExePresence)
                {
                    bRet = TRUE;
                    goto Exit;
                }

                //
                // Check if the current working directory contains the exe in question
                //
                WCHAR szCurrentDirectory[MAX_PATH];
                if (szCurrentDirectory && 
                    GetCurrentDirectoryW(MAX_PATH, szCurrentDirectory))
                {
                    CString csFullAppName(szCurrentDirectory);
                    csFullAppName += L"\\";
                    csFullAppName += csAppTitle;
                    
                    // Check if the file exists and is not a directory
                    DWORD dwAttr = GetFileAttributesW(csFullAppName);
                    if ((dwAttr != 0xFFFFFFFF) && 
                        !(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
                    {
                        DPFN( eDbgLevelInfo,
                            "[Redirect] %s found in current working directory");
                        bExists = TRUE;
                    }
                }            
           
                //
                // We have a match, so call the corresponding function
                //            

                if (bRet = (*(rEntry->pfnFuncName))(csNewApplicationName,
                        csNewCommandLine, bExists)) 
                {                
                    //
                    // Append the original command line 
                    //
                    csNewCommandLine += L" ";
                    csNewCommandLine += csOrigCommandLine;                
                }

                // We matched an EXE, so we're done
                break;            
            }

            rEntry++;
        }

        if (bRet) 
        {
            DPFN( eDbgLevelWarning, "Redirected:");
            DPFN( eDbgLevelWarning, "\tFrom: %S %S", csApplicationName, csCommandLine);
            DPFN( eDbgLevelWarning, "\tTo:   %S %S", csNewApplicationName, csNewCommandLine);
        }
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "Not Redirecting: Exception encountered");
        bRet = FALSE;     
    }

Exit:
    return bRet;
}

/*++

 Hooks the CreateProcessA function to see if any News need to be 
 substituted. 

--*/

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if ((NULL == lpApplicationName) &&
       (NULL == lpCommandLine))
    {
        // If both are NULL, return FALSE.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    CSTRING_TRY
    {    
        CString csNewApplicationName;
        CString csNewCommandLine;
        CString csPassedAppName(lpApplicationName);
        CString csPassedCommandLine(lpCommandLine);
        
        if ((csPassedAppName.IsEmpty()) &&
            (csPassedCommandLine.IsEmpty()))
        {
            goto exit;
        }

        // 
        // Run the list of New stubs: call to the main New routine
        //
        if (Redirect(csPassedAppName, csPassedCommandLine, csNewApplicationName, 
                csNewCommandLine, FALSE))
        {
            LOGN(
                eDbgLevelWarning,
                "[CreateProcessA] \" %s %s \": changed to \" %s %s \"",
                lpApplicationName, lpCommandLine, 
                csNewApplicationName.GetAnsi(), csNewCommandLine.GetAnsi());
        }
        else
        {
            csNewApplicationName = lpApplicationName;
            csNewCommandLine = lpCommandLine;
        }


        // Convert back to ANSI using the GetAnsi() method exposed by the CString class.
        return ORIGINAL_API(CreateProcessA)(
            csNewApplicationName.IsEmpty() ? NULL : csNewApplicationName.GetAnsi(), 
            csNewCommandLine.IsEmpty() ? NULL : csNewCommandLine.GetAnsi(),  
            lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
            dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,             
            lpProcessInformation);

    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "[CreateProcessA]:Original API called.Exception occured!");
        
    }

exit:
    return ORIGINAL_API(CreateProcessA)(lpApplicationName, lpCommandLine,
                lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
                dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,             
                lpProcessInformation);
}

/*++

 Hooks the CreateProcessW function to see if any News need to be 
 substituted. 

--*/

BOOL 
APIHOOK(CreateProcessW)(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if ((NULL == lpApplicationName) &&
       (NULL == lpCommandLine))
    {
        // If both are NULL, return FALSE.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;        
    }

    CSTRING_TRY
    {    
        CString csNewApplicationName;
        CString csNewCommandLine;
        CString csApplicationName(lpApplicationName);
        CString csCommandLine(lpCommandLine);

        if ((csApplicationName.IsEmpty()) &&
            (csCommandLine.IsEmpty()))
        {
            goto exit;
        }

        // 
        // Run the list of New stubs
        //

        if (Redirect(csApplicationName, csCommandLine, csNewApplicationName, 
                csNewCommandLine, FALSE)) 
        {    
            LOGN(
                eDbgLevelWarning,
                "[CreateProcessW] \" %S %S \": changed to \" %S %S \"",
                lpApplicationName, lpCommandLine, csNewApplicationName, csNewCommandLine);            
        }
        else
        {
            csNewApplicationName = lpApplicationName;
            csNewCommandLine = lpCommandLine;
        }


        return ORIGINAL_API(CreateProcessW)(
            csNewApplicationName.IsEmpty() ? NULL : csNewApplicationName.Get(), 
            csNewCommandLine.IsEmpty() ? NULL : (LPWSTR)csNewCommandLine.Get(),  
            lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
            dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,
            lpProcessInformation);
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "[CreateProcessW] Original API called. Exception occured!");
    }

exit:
    return ORIGINAL_API(CreateProcessW)(lpApplicationName, lpCommandLine, 
                lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
                dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,
                lpProcessInformation);
}

/*++

 Hooks WinExec to redirect if necessary. 

--*/

UINT
APIHOOK(WinExec)(
    LPCSTR lpCmdLine,
    UINT uCmdShow
    )
{
    if (NULL == lpCmdLine)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return ERROR_PATH_NOT_FOUND;
    }

    CSTRING_TRY
    {            
        CString csNewApplicationName;
        CString csNewCommandLine;
        CString csAppName;
        CString csNewCmdLine;
        CString csCommandLine(lpCmdLine);
        
        if (csCommandLine.IsEmpty())
        {
            goto exit;
        }
        // Check for redirection
        if (Redirect(csAppName, csCommandLine, csNewApplicationName,
                csNewCommandLine, FALSE))
        {
            // Modification for the WinHlp32 strange behaviour
            if (csNewCommandLine.Find(csNewApplicationName.Get()) == -1)
            {
                // If the new Command line does not contain the new application
                // name as the substring, we are here.
                csNewCmdLine = csNewApplicationName;                        
                csNewCmdLine += L" ";
            }
            csNewCmdLine += csNewCommandLine;  

            // Assign to csCommandLine as this can be commonly used      
            csCommandLine = csNewCmdLine;

            LOGN(
                eDbgLevelInfo,
                "[WinExec] \" %s \": changed to \" %s \"",
                lpCmdLine, csCommandLine.GetAnsi());       
        }

        return ORIGINAL_API(WinExec)(csCommandLine.GetAnsi(), uCmdShow);

    }
    CSTRING_CATCH
    {            
        DPFN( eDbgLevelError, "[WinExec]:Original API called.Exception occured!");        
    }

exit:
    return ORIGINAL_API(WinExec)(lpCmdLine, uCmdShow);
}

/*++

 Hooks the FindFirstFileA function to see if any replacements need to be 
 substituted. This is a requirement for cmd.exe.

--*/

HANDLE
APIHOOK(FindFirstFileA)(
    LPCSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    CSTRING_TRY
    {            
        CString csNewApplicationName;
        CString csNewCommandLine;
        CString csFileName(lpFileName);
        CString csAppName;

        // Call the main replacement routine.
        if (Redirect(csFileName, csAppName, csNewApplicationName, csNewCommandLine, FALSE)) 
        {     
            // Assign to csFileName
            csFileName = csNewApplicationName;
            LOGN(
                eDbgLevelInfo,
                "[FindFirstFileA] \" %s  \": changed to \" %s \"",
                lpFileName, csFileName.GetAnsi());
        }

        return ORIGINAL_API(FindFirstFileA)(csFileName.GetAnsi(), lpFindFileData);
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "[FindFirstFileA]:Original API called.Exception occured!");        
        return ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);
    }
}

/*++

 Hooks the FindFirstFileW function to see if any replacements need to be 
 substituted. This is a requirement for cmd.exe.

--*/

HANDLE
APIHOOK(FindFirstFileW)(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    CSTRING_TRY
    {    
        CString csNewApplicationName(lpFileName);
        CString csNewCommandLine;
        CString csFileName(lpFileName);
        CString csAppName;
    
        // Call the main replacement routine.
        if (Redirect(csFileName, csAppName, csNewApplicationName, 
                csNewCommandLine, FALSE))
        {
            LOGN(
                eDbgLevelInfo,
                "[FindFirstFileW] \" %S \": changed to \" %S \"",
                lpFileName, (const WCHAR*)csNewApplicationName);
        }

        return ORIGINAL_API(FindFirstFileW)(csNewApplicationName, lpFindFileData);
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "[FindFirstFileW]:Original API called.Exception occured!");
        return ORIGINAL_API(FindFirstFileW)(lpFileName, lpFindFileData);
    }
}

// Added for the merge of HandleStartKeyword

/*++

 Hook IShellLinkA::SetPath - check if it's start, if so change it to cmd and add the 
 this pointer to the list.

--*/

HRESULT STDMETHODCALLTYPE
COMHOOK(IShellLinkA, SetPath)(
    PVOID pThis,
    LPCSTR pszFile
    )
{
    _pfn_IShellLinkA_SetPath pfnSetPath = ORIGINAL_COM( IShellLinkA, SetPath, pThis);

    CSTRING_TRY
    {   
        CString csExeName;
        CString csCmdLine;
        CString csNewAppName;
        CString csNewCmdLine;
        CString cscmdCommandLine(pszFile);

        // Assign the ANSI string to the WCHAR CString
        csExeName = pszFile;
        csExeName.TrimLeft();
        
        // Check to see whether the Filename conatains the "Start" keyword.
        // The last parameter to the Rediect function controls this.
        if (Redirect(csExeName, csCmdLine,  csNewAppName, csNewCmdLine, TRUE))
        {
            // Found a match. We add the this pointer to the list.
            AddThisPointer(pThis);
            DPFN( eDbgLevelInfo, "[SetPath] Changing start.exe to cmd.exe\n");

            // Prefix of new "start" command line, use full path to CMD.EXE                  
            // Append the WCHAR global system directory path to ANSI CString
            cscmdCommandLine = g_szSysDir;
            cscmdCommandLine += L"\\cmd.exe";                   
        }

        return (*pfnSetPath)(pThis, cscmdCommandLine.GetAnsi());
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "[SetPath] Original API called. Exception occured!");
        return (*pfnSetPath)(pThis, pszFile);
    }
}

/*++

 Hook IShellLinkA::SetArguments - if the this pointer can be found in the list, remove it
 from the list and add "/d /c start" in front of the original argument list.

--*/

HRESULT STDMETHODCALLTYPE
COMHOOK(IShellLinkA, SetArguments)(
    PVOID pThis,
    LPCSTR pszFile 
    )
{
    _pfn_IShellLinkA_SetArguments pfnSetArguments = ORIGINAL_COM(IShellLinkA, SetArguments, pThis);

    CSTRING_TRY
    {    
        CString csNewFile(pszFile);        
        if (RemoveThisPointer(pThis))
        {
            csNewFile = "/d /c start \"\" ";
            csNewFile += pszFile;

            DPFN( eDbgLevelInfo, "[SetArguments] Arg list is now %S", csNewFile);        
        }

        return (*pfnSetArguments)( pThis, csNewFile.GetAnsi());
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "[SetArguments]:Original API called.Exception occured!");
        return (*pfnSetArguments)( pThis, pszFile );
    }  
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        if (!GetSystemDirectory(g_szSysDir, MAX_PATH))
        {
            DPFN( eDbgLevelError, "[Notify] GetSystemDirectory failed");
            return FALSE;
        }

        InitializeCriticalSection(&g_CritSec);
    }
    
    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)
    APIHOOK_ENTRY(KERNEL32.DLL, WinExec)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileW)
    APIHOOK_ENTRY_COMSERVER(SHELL32)
    COMHOOK_ENTRY(ShellLink, IShellLinkA, SetPath, 20)
    COMHOOK_ENTRY(ShellLink, IShellLinkA, SetArguments, 11)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatetextcolor.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateTextColor.cpp

 Abstract:

    Win9x contained a hack that allowed the programmer to specify a 16 bit 
    value inside a COLORREF which would be used 'as is' for whatever GDI 
    functions were subsequenctly called. We can't have this behaviour on NT
    because the driver gets the Colorref unconverted.

    The solution is to break out the 16 bit portion and expand it to 24 bit 
    color.

 Notes:
    
    This is a general purpose shim.

 History:

    01/10/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateTextColor)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetTextColor)
    APIHOOK_ENUM_ENTRY(SetBkColor)
APIHOOK_ENUM_END

COLORREF 
ColorConvert(
    IN HDC hdc,
    IN COLORREF crColor
    )
/*++

 Converts the DWORD from a 16 bit to a colorref

 Arguments:

    IN crColor - DWORD 16 bit color 

 Return Value: 
    
    Normal COLORREF

--*/
{
    DWORD dwCol = crColor;

    if (GetDeviceCaps(hdc, BITSPIXEL) == 16) {
        if ((dwCol & 0xFFFF0000) == 0x10FF0000) {
            LOGN(
                eDbgLevelError,
                "[ColorConvert] Fixed up bogus 16 bit COLORREF.");

            dwCol = (crColor & 0xf800) <<  8;
                    dwCol |= (crColor & 0x001f) <<  3;
                    dwCol |= (crColor >> 5) & 0x00070007L;
                    dwCol |= (crColor & 0x07e0) <<  5;
                    dwCol |= (crColor & 0x0600) >>  1;
        }
    }

    if (dwCol == 0xFFFFFFFF) {
        LOGN(
            eDbgLevelError,
            "[ColorConvert] Fixed up bogus 24 bit COLORREF.");

        dwCol = 0xFFFFFF;
    }
    
    return dwCol;
}

/*++

 Set text color to a usable one

--*/

COLORREF 
APIHOOK(SetTextColor)( 
    HDC hdc,
    COLORREF crColor
    )
{
    return ORIGINAL_API(SetTextColor)(hdc, ColorConvert(hdc, crColor));
}

/*++

 Set background color to the converted one

--*/

COLORREF 
APIHOOK(SetBkColor)(
    HDC hdc,
    COLORREF crColor
    )
{
    return ORIGINAL_API(SetBkColor)(hdc, ColorConvert(hdc, crColor));
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, SetTextColor)
    APIHOOK_ENTRY(GDI32.DLL, SetBkColor)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatetoolhelp32.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   EmulateToolHelp32.cpp

 Abstract:

   We've discovered 2 incompatibilities between the 9x and NT Toolhelp implementation so far that affect
   apps.

   1) On 9x for the szExeFile field in PROCESSENTRY32 it simply uses the name of the executable
      module (which includes the full path and the executable name); on NT this is the image name.
      Nuclear Strike looks for '\' in szExeFile. 

   2) On 9x the cntUsage field of PROCESSENTRY32 is always non-zero while on NT it's always 0. We
      make it 1.

   there are others (like on NT the th32ModuleID is always 1 while on 9x it's unique for each module)
   but we haven't seen any apps having problems with those so we aren't putting them in.

 Notes:

   This is a general purpose shim.

 History:

    11/14/2000 maonis  Created

--*/

#include "precomp.h"
#include "LegalStr.h"

// The toolhelp APIs are lame - they define all the APIs to the W version when UNICODE is defined.
// We want to hook the ANSI version so undefine UNICODE.
#ifdef UNICODE
#undef UNICODE
#include <Tlhelp32.h>
#endif

typedef BOOL (WINAPI *_pfn_Process32First)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
typedef BOOL (WINAPI *_pfn_Process32Next)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);

IMPLEMENT_SHIM_BEGIN(EmulateToolHelp32)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(Process32First)
    APIHOOK_ENUM_ENTRY(Process32Next)
APIHOOK_ENUM_END

/*++

  MSDN says the szExeFile field of PROCESSENTRY32 is supposed to contain the "Path and filename 
  of the executable file for the process". But really, a process doesn't really have a path - only
  modules in the process do. NT does it right (it takes the image name), 9x doesn't.

--*/

BOOL GetProcessNameFullPath(DWORD dwPID, LPSTR szExeName)
{
    BOOL bRet = FALSE;

    HANDLE hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);

    if (hModuleSnap != (HANDLE)-1) {
        MODULEENTRY32 me32;
        me32.dwSize = sizeof(MODULEENTRY32); 

        // The first module in the process is the one we want.
        if (Module32First(hModuleSnap, &me32)) {
            strcpy(szExeName, me32.szExePath);
            bRet = TRUE;
        }

        CloseHandle (hModuleSnap);
    }

    return bRet;
}

/*++

  This stub function skips the first few processes that don't apply in 9x and returns the first
  9x-like process with the full path and name of the executable in lppe->szExeFile.

--*/

BOOL 
APIHOOK(Process32First)(
    HANDLE hSnapshot, 
    LPPROCESSENTRY32 lppe
    )
{
    // Skip till we find the first one we can get the module path and name.
    BOOL bRet = ORIGINAL_API(Process32First)(hSnapshot, lppe);

    // The 1st process in [System Process], we ignore it.
    if (!bRet) {
        return bRet;
    }

    // We can't get the first (or first few) process's module list - we return the first one we can.
    while (bRet = ORIGINAL_API(Process32Next)(hSnapshot, lppe)) {
        if (GetProcessNameFullPath(lppe->th32ProcessID, lppe->szExeFile)) {
            DPFN(eDbgLevelInfo, "[APIHook_Process32First] the 1st process name is %s\n", lppe->szExeFile);

            lppe->cntUsage = 1;

            return TRUE;
        }
    }

    return bRet;
}

/*++

  This stub function calls the API and get the full path and the name of the executable
  and put it in lppe->szExeFile.

--*/

BOOL 
APIHOOK(Process32Next)(
    HANDLE hSnapshot, 
    LPPROCESSENTRY32 lppe
    )
{
    BOOL bRet;

    if (bRet = ORIGINAL_API(Process32Next)(hSnapshot, lppe)) {
        if (!GetProcessNameFullPath(lppe->th32ProcessID, lppe->szExeFile)) {
            return FALSE;
        }

        DPFN(eDbgLevelInfo, "[APIHook_Process32Next] process name is %s\n", lppe->szExeFile);

        lppe->cntUsage = 1;
    }

    return bRet;
}

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, Process32First)
    APIHOOK_ENTRY(KERNEL32.DLL, Process32Next)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateslowcpu.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    EmulateSlowCPU.cpp

 Abstract:

    Modify performance testing routines to emulate slower processors.

 Notes:

    This is a general purpose shim.

 History:

    07/16/2002  mnikkel   Created.

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(EmulateSlowCPU)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(timeGetTime)
    APIHOOK_ENUM_ENTRY(QueryPerformanceCounter)
    APIHOOK_ENUM_ENTRY(QueryPerformanceFrequency)
APIHOOK_ENUM_END

typedef BOOL (*_pfn_QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
typedef BOOL (*_pfn_QueryPerformanceFrequency)(LARGE_INTEGER *lpPerformanceFreq);

DWORD g_dwDivide = 1;
BOOL g_btimeGetTime = FALSE;

/*++

 Don't allow the current time to be equal to the prev time.

--*/

DWORD
APIHOOK(timeGetTime)(VOID)
{
    if (g_btimeGetTime) {

		LARGE_INTEGER PerfFreq;
		LARGE_INTEGER PerfCount1, PerfCount2;

		if (QueryPerformanceFrequency(&PerfFreq) &&
            QueryPerformanceCounter(&PerfCount1)) {
		    do {
			    if (!QueryPerformanceCounter(&PerfCount2)) break;
		    } while (((double)(PerfCount2.QuadPart - PerfCount1.QuadPart) / PerfFreq.QuadPart) < 0.0001);
        }
    }

    return ORIGINAL_API(timeGetTime)();
}

BOOL 
APIHOOK(QueryPerformanceCounter)(
    LARGE_INTEGER *lpPerformanceCount
    )
{
    BOOL bRet = ORIGINAL_API(QueryPerformanceCounter)(lpPerformanceCount);
    if (lpPerformanceCount) {
        lpPerformanceCount->QuadPart /= g_dwDivide;
    }

    return bRet;
}

BOOL 
APIHOOK(QueryPerformanceFrequency)(
    LARGE_INTEGER *lpPerformanceFreq
    )
{
    BOOL bRet = ORIGINAL_API(QueryPerformanceFrequency)(lpPerformanceFreq);
    if (lpPerformanceFreq) {
        lpPerformanceFreq->QuadPart /= g_dwDivide;
    }
    return bRet;
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        
        g_btimeGetTime = COMMAND_LINE && (_stricmp(COMMAND_LINE, "+timeGetTime") == 0);

        INT64 l1, l2;
        if (QueryPerformanceCounter((LARGE_INTEGER *)&l1) &&
            QueryPerformanceCounter((LARGE_INTEGER *)&l2)) {
            
            // Calculate the divide factor
            g_dwDivide = (DWORD_PTR)((l2 - l1)) / 5;

            if (g_dwDivide == 0) {
                g_dwDivide = 1;
            }
        
            LOGN(eDbgLevelInfo, "[NotifyFn] EmulateSlowCPU initialized with divisor %d", g_dwDivide);

            return TRUE;
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(WINMM.DLL, timeGetTime)
    APIHOOK_ENTRY(KERNEL32.DLL, QueryPerformanceCounter)
    APIHOOK_ENTRY(KERNEL32.DLL, QueryPerformanceFrequency)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateverqueryvalue.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateVerQueryValue.cpp

 Abstract:

    This shim fixes a null version length buffer pointer.

 Notes:

    This is a general purpose shim.

 History:

    01/03/2000 jdoherty     Revised coding style.
    11/28/2000 jdoherty     Converted to framework version 2

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateVerQueryValue)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(VerQueryValueA) 
    APIHOOK_ENUM_ENTRY(VerQueryValueW) 
APIHOOK_ENUM_END

/*++

 Fix the null version length buffer pointer.

--*/

BOOL 
APIHOOK(VerQueryValueA)(
    const LPVOID pBlock, 
    LPSTR lpSubBlock, 
    LPVOID *lplpBuffer, 
    PUINT puLen 
    )
{
    BOOL bRet;
    UINT nLen;

    if (!puLen) {
        puLen = &nLen;
        DPFN( eDbgLevelError, "[APIHook_VerQueryValueA] Null puLen param. Fixed.\n");
    }

    bRet = ORIGINAL_API(VerQueryValueA)( 
        pBlock, 
        lpSubBlock, 
        lplpBuffer, 
        puLen);

    return bRet;
}

/*++

 Fix the null version length buffer pointer. Unicode version.

--*/

BOOL 
APIHOOK(VerQueryValueW)(
    const LPVOID pBlock,
    LPWSTR lpSubBlock,
    LPVOID *lplpBuffer,
    PUINT puLen
    )
{
    BOOL bRet;
    UINT nLen;

    if (!puLen) {
        puLen = &nLen;
        DPFN( eDbgLevelError, "[APIHook_VerQueryValueW] Null puLen param. Fixed.\n");
    }

    bRet = ORIGINAL_API(VerQueryValueW)( 
        pBlock, 
        lpSubBlock, 
        lplpBuffer, 
        puLen);
    
    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(VERSION.DLL, VerQueryValueA)
    APIHOOK_ENTRY(VERSION.DLL, VerQueryValueW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulatewritefile.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateWriteFile.cpp

 Abstract:

    On NT, WriteFile requires the buffer passed in to be non-null. But Win9x
    assumes you want to write zeroes if the buffer is NULL. This shim emulates
    the Win9x behavior.

 Notes:

    This is a general purpose shim.

 History:

    01/21/2000 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateWriteFile)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WriteFile)
    APIHOOK_ENUM_ENTRY(AVIStreamWrite)
APIHOOK_ENUM_END

typedef HRESULT (*_pfn_AVIStreamWrite)(PAVISTREAM pavi, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer, DWORD dwFlags, LONG * plSampWritten, LONG * plBytesWritten);

/*++

 Allocate a buffer as required.

--*/

BOOL
APIHOOK(WriteFile)(
    HANDLE       hFile,              
    LPCVOID      lpBuffer,        
    DWORD        nNumberOfBytesToWrite,
    LPDWORD      lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped    
    )
{
    BOOL bRet;

    if (!lpBuffer) {
        
        void* pBuf = malloc(nNumberOfBytesToWrite);

        if (pBuf == NULL) {
            LOGN(eDbgLevelError, "[WriteFile] Failed to allocate %d bytes.", nNumberOfBytesToWrite);
        } else {
            ZeroMemory(pBuf, nNumberOfBytesToWrite);
        }

        bRet = ORIGINAL_API(WriteFile)(hFile, pBuf, nNumberOfBytesToWrite, 
            lpNumberOfBytesWritten, lpOverlapped);

        free(pBuf);

        LOGN(eDbgLevelError, "[WriteFile] - null buffer of size %d.", nNumberOfBytesToWrite);

    } else {
        bRet = ORIGINAL_API(WriteFile)(hFile, lpBuffer, nNumberOfBytesToWrite,
            lpNumberOfBytesWritten, lpOverlapped);
    }

    return bRet;
}

/*++

 Allocate a buffer as required.

--*/

HRESULT
APIHOOK(AVIStreamWrite)(
    PAVISTREAM pavi,       
    LONG lStart,           
    LONG lSamples,         
    LPVOID lpBuffer,       
    LONG cbBuffer,         
    DWORD dwFlags,         
    LONG * plSampWritten,  
    LONG * plBytesWritten  
    )
{
    HRESULT hRet;

    if (!lpBuffer) {
        
        void* pBuf = malloc(cbBuffer);

        if (pBuf == NULL) {
            LOGN(eDbgLevelError, "[AVIStreamWrite] Failed to allocate %d bytes.", cbBuffer);
        } else {
            ZeroMemory(pBuf, cbBuffer);
        }

        hRet = ORIGINAL_API(AVIStreamWrite)(pavi, lStart, lSamples, pBuf, 
            cbBuffer, dwFlags, plSampWritten,  plBytesWritten);

        free(pBuf);

        LOGN(eDbgLevelError, "[AVIStreamWrite] - null buffer of size %d", cbBuffer);

    } else {
        hRet = ORIGINAL_API(AVIStreamWrite)(pavi, lStart, lSamples, lpBuffer, 
            cbBuffer, dwFlags, plSampWritten,  plBytesWritten);
    }

    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, WriteFile)
    APIHOOK_ENTRY(AVIFIL32.DLL, AVIStreamWrite)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\enablerestarts.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EnableRestarts.cpp

 Abstract:

    This DLL APIHooks ExitWindowsEx and gives the process enough privileges to
    restart the computer.

 Notes:

    This is a general purpose shim.

 History:

    11/10/1999 v-johnwh Created.
    10/19/2000 andyseti Close process option added with command line to handle 
                        a case where A process cancel ExitWindowsEx request by 
                        B process because A process is waiting for process B to 
                        quit while process B never quit. In Win9x, process B 
                        quit as soon as it calls ExitWindowsEx so process A can 
                        quit also and the system restarts.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EnableRestarts)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ExitWindowsEx)
APIHOOK_ENUM_END

/*++

 This stub function enables appropriate privileges for the process so that it 
 can restart the machine.

--*/

BOOL 
APIHOOK(ExitWindowsEx)(
    UINT  uFlags, 
    DWORD dwReserved
    )
{
    BOOL             bRet;
    HANDLE           hToken;
    TOKEN_PRIVILEGES structPtr;
    LUID             luid;

    if (uFlags & (EWX_POWEROFF | EWX_REBOOT | EWX_SHUTDOWN)) {
        
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) {
            structPtr.PrivilegeCount = 1;
            
            if (LookupPrivilegeValueW(NULL, SE_SHUTDOWN_NAME, &luid)) {
                structPtr.Privileges[0].Luid = luid;
                structPtr.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                LOGN(
                    eDbgLevelError,
                    "[ExitWindowsEx] Adding process privileges for restart.");
                
                AdjustTokenPrivileges(hToken, FALSE, &structPtr, 0, NULL, NULL);
            }
        }

        CSTRING_TRY
        {
            CString csCL(COMMAND_LINE);
            if (csCL.CompareNoCase(L"CLOSE_PROCESS") == 0) {
                LOGN(
                    eDbgLevelError,
                    "[ExitWindowsEx] Closing process.");
            
                ExitProcess(1);
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return ORIGINAL_API(ExitWindowsEx)(uFlags, dwReserved);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, ExitWindowsEx)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\emulateuser.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateUSER.cpp

 Abstract:

    EmulateSetWindowsHook:

        Handles a behaviour difference on the arguments passed to 
        SetWindowsHook, for the case where:

        (hMod == NULL) && (dwThreadId == 0)

        According to MSDN:

            An error may occur if the hMod parameter is NULL and the dwThreadId 
            parameter is zero or specifies the identifier of a thread created 
            by another process. 

        So the NT behaviour is correct. However, on win9x, hMod was assumed to 
        be the current module if NULL and dwThreadId == 0. 

        Note: this doesn't affect the case where the thread belongs to another 
        process.

    ForceTemporaryModeChange:

        A hack for several apps that permanently change the display mode and 
        fail to restore it correctly. Some of these apps do restore the 
        resolution, but not the refresh rate. 1024x768 @ 60Hz looks really bad.

        Also includes a hack for cursors: the cursor visibility count is not 
        persistent through mode changes.

    CorrectWndProc:

        When you specify a NULL window proc we make it DefWindowProc instead to 
        mimic the 9x behavior.

    EmulateToASCII:
   
        Remove stray characters from ToAscii. This usually manifests itself as 
        a locked keyboard since this is the API that's used to convert the scan 
        codes to actual characters.

    EmulateShowWindow:

        Win9x didn't use the high bits of nCmdShow, which means they got 
        stripped off.

    EmulateGetMessage:

        Check wMsgFilterMax in GetMessage and PeekMessage for bad values and if 
        found change them to 0x7FFF.

    PaletteRestore:

        Persist palette state through mode switches. This includes the entries 
        themselves and the usage flag (see SetSystemPaletteUse).

 Notes:

    This is a general purpose shim.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateUSER)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(SetWindowsHookExA)
    APIHOOK_ENUM_ENTRY(SetWindowLongA)
    APIHOOK_ENUM_ENTRY(RegisterClassA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExA)
    APIHOOK_ENUM_ENTRY(ToAscii)
    APIHOOK_ENUM_ENTRY(ToAsciiEx)
    APIHOOK_ENUM_ENTRY(ShowWindow) 
    APIHOOK_ENUM_ENTRY(PeekMessageA)
    APIHOOK_ENUM_ENTRY(GetMessageA)
    APIHOOK_ENUM_ENTRY(SetSystemPaletteUse)
    APIHOOK_ENUM_ENTRY(AnimatePalette)
    APIHOOK_ENUM_ENTRY(RealizePalette)

APIHOOK_ENUM_END

CRITICAL_SECTION g_csPalette;
UINT g_uPaletteLastUse = SYSPAL_STATIC;
DWORD g_peTable[256] =
{
    0x00000000, 0x00000080, 0x00008000, 0x00008080,
    0x00800000, 0x00800080, 0x00808000, 0x00C0C0C0,
    0x00C0DCC0, 0x00F0CAA6, 0x00081824, 0x00142830,
    0x0018303C, 0x00304D61, 0x0051514D, 0x004D7161,
    0x00826D61, 0x000C1414, 0x00597582, 0x00759E08,
    0x00303438, 0x00AA6938, 0x00203428, 0x00496161,
    0x0049869E, 0x007D9A6D, 0x000869CB, 0x008E8682,
    0x0075615D, 0x000061EB, 0x00000871, 0x002C3830,
    0x000471EF, 0x008E92AA, 0x00306DF7, 0x0004C3C3,
    0x0092AAB2, 0x00101814, 0x00040C08, 0x000C7110,
    0x00CFA282, 0x000008AA, 0x0028412C, 0x00498EB2,
    0x00204D61, 0x00555955, 0x0004D3D3, 0x001C3C4D,
    0x0020A6F7, 0x0010A210, 0x0018241C, 0x005DAEF3,
    0x00719EAA, 0x00B2E720, 0x00102871, 0x0086C3D3,
    0x00288A2C, 0x000C51BA, 0x0059716D, 0x00494D4D,
    0x00AAB6C3, 0x00005100, 0x0020CBF7, 0x004D8A51,
    0x00BEC7B2, 0x00043CBA, 0x00101C18, 0x000851DF,
    0x00A6E7A6, 0x009ECF24, 0x00797592, 0x00AE7559,
    0x009E8269, 0x00CFE3DF, 0x000C2030, 0x0028692C,
    0x009EA2A2, 0x00F7C782, 0x0034617D, 0x00B6BEBE,
    0x00969E86, 0x00DBFBD3, 0x00655149, 0x0065EF65,
    0x00AED3D3, 0x00E7924D, 0x00B2BEB2, 0x00D7DBDB,
    0x00797571, 0x00344D59, 0x0086B2CF, 0x00512C14,
    0x00A6FBFB, 0x00385965, 0x00828E92, 0x001C4161,
    0x00595961, 0x00002000, 0x003C6D7D, 0x005DB2D7,
    0x0038EF3C, 0x0051CB55, 0x001C2424, 0x0061C3F3,
    0x0008A2A2, 0x0038413C, 0x00204951, 0x00108A14,
    0x00103010, 0x007DE7F7, 0x00143449, 0x00B2652C,
    0x00F7EBAA, 0x003C7192, 0x0004FBFB, 0x00696151,
    0x00EFC796, 0x000441D7, 0x00000404, 0x00388AF7,
    0x008AD3F3, 0x00006500, 0x000004E3, 0x00DBFFFF,
    0x00F7AE69, 0x00CF864D, 0x0055A2D3, 0x00EBEFE3,
    0x00EB8A41, 0x00CF9261, 0x00C3F710, 0x008E8E82,
    0x00FBFFFF, 0x00104110, 0x00040851, 0x0082FBFB,
    0x003CC734, 0x00088A8A, 0x00384545, 0x00514134,
    0x003C7996, 0x001C6161, 0x00EBB282, 0x00004100,
    0x00715951, 0x00A2AAA6, 0x00B2B6B2, 0x00C3FBFB,
    0x00000834, 0x0028413C, 0x00C7C7CF, 0x00CFD3D3,
    0x00824520, 0x0008CB0C, 0x001C1C1C, 0x00A6B29A,
    0x0071A6BE, 0x00CF9E6D, 0x006D7161, 0x00008A04,
    0x005171BE, 0x00C7D3C3, 0x00969E96, 0x00798696,
    0x002C1C10, 0x00385149, 0x00BE7538, 0x0008141C,
    0x00C3C7C7, 0x00202C28, 0x00D3E3CF, 0x0071826D,
    0x00653C1C, 0x0004EF08, 0x00345575, 0x006D92A6,
    0x00797979, 0x0086F38A, 0x00925528, 0x00E3E7E7,
    0x00456151, 0x001C499A, 0x00656961, 0x008E9EA2,
    0x007986D3, 0x00204151, 0x008AC7E3, 0x00007100,
    0x00519EBE, 0x0010510C, 0x00A6AAAA, 0x002C3030,
    0x00D37934, 0x00183030, 0x0049828E, 0x00CBFBC3,
    0x006D7171, 0x000428A6, 0x004D4545, 0x00040C14,
    0x00087575, 0x0071CB79, 0x004D6D0C, 0x00FBFBD3,
    0x00AAB2AE, 0x00929292, 0x00F39E55, 0x00005D00,
    0x00E3D7B2, 0x00F7FBC3, 0x003C5951, 0x0004B2B2,
    0x0034658E, 0x000486EF, 0x00F7FBE3, 0x00616161,
    0x00DFE3DF, 0x001C100C, 0x0008100C, 0x0008180C,
    0x00598600, 0x0024FBFB, 0x00346171, 0x00042CC7,
    0x00AEC79A, 0x0045AE4D, 0x0028A62C, 0x00EFA265,
    0x007D8282, 0x00F7D79A, 0x0065D3F7, 0x00E3E7BA,
    0x00003000, 0x00245571, 0x00DF823C, 0x008AAEC3,
    0x00A2C3D3, 0x00A6FBA2, 0x00F3FFF3, 0x00AAD7E7,
    0x00EFEFC3, 0x0055F7FB, 0x00EFF3F3, 0x00BED3B2,
    0x0004EBEB, 0x00A6E3F7, 0x00F0FBFF, 0x00A4A0A0,
    0x00808080, 0x000000FF, 0x0000FF00, 0x0000FFFF,
    0x00FF0000, 0x00FF00FF, 0x00FFFF00, 0x00FFFFFF
};

#define MODE_MASK (CDS_UPDATEREGISTRY | CDS_TEST | CDS_FULLSCREEN | CDS_GLOBAL | CDS_SET_PRIMARY | CDS_VIDEOPARAMETERS | CDS_RESET | CDS_NORESET)

/*++

 Handle NULL for hModule

--*/

HHOOK 
APIHOOK(SetWindowsHookExA)(
    int       idHook,        
    HOOKPROC  lpfn,     
    HINSTANCE hMod,    
    DWORD     dwThreadId   
    )
{
    if (!hMod && !dwThreadId) {
        LOGN(
            eDbgLevelError,
            "[SetWindowsHookExA] hMod is NULL - correcting.");

        hMod = GetModuleHandle(NULL);
    }
    
    return ORIGINAL_API(SetWindowsHookExA)(
                            idHook,
                            lpfn,
                            hMod,
                            dwThreadId);
}

/*++

 Set the WndProc to DefWndProc if it's NULL.

--*/

LONG
APIHOOK(SetWindowLongA)(
    HWND hWnd,       
    int nIndex,      
    LONG dwNewLong   
    )
{
    if ((nIndex == GWL_WNDPROC) && (dwNewLong == 0)) {
        LOGN(eDbgLevelError, "[SetWindowLongA] Null WndProc specified - correcting.");
        dwNewLong = (LONG) DefWindowProcA;
    }
    
    return ORIGINAL_API(SetWindowLongA)(hWnd, nIndex, dwNewLong);
}

/*++

 Set the WndProc to DefWndProc if it's NULL.

--*/

ATOM 
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  
    )
{
    if (!(lpWndClass->lpfnWndProc)) {
        WNDCLASSA wcNewWndClass = *lpWndClass;
        
        LOGN(eDbgLevelError, "[RegisterClassA] Null WndProc specified - correcting.");

        wcNewWndClass.lpfnWndProc = DefWindowProcA;

        return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
    }
    else
    {
        return ORIGINAL_API(RegisterClassA)(lpWndClass);
    }
}

/*++

 Change the palette entries if applicable.

--*/

void
FixPalette()
{
    EnterCriticalSection(&g_csPalette);

    //
    // We realized a palette before this, so let's have a go at restoring 
    // all the palette state.
    // 

    HDC hdc = GetDC(GetActiveWindow());

    if (hdc) {
        if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) {
            //
            // We're now in a palettized mode
            //
            SetSystemPaletteUse(hdc, g_uPaletteLastUse);

            LPLOGPALETTE plogpal = (LPLOGPALETTE) malloc(sizeof(LOGPALETTE) + sizeof(g_peTable));

            if (plogpal) {
                //
                // Create a palette we can realize
                //
                HPALETTE hPal;

                plogpal->palVersion = 0x0300;
                plogpal->palNumEntries = 256;
                MoveMemory(&plogpal->palPalEntry[0], &g_peTable[0], sizeof(g_peTable));

                if (hPal = CreatePalette(plogpal)) {
                    //
                    // Realize the palette
                    //
                    HPALETTE hOld = SelectPalette(hdc, hPal, FALSE);
                    RealizePalette(hdc);
                    SelectPalette(hdc, hOld, FALSE);
                    DeleteObject(hPal);
                }
        
                free(plogpal);
            }
        }

        ReleaseDC(0, hdc);
    }

    LeaveCriticalSection(&g_csPalette);
}

/*++

 Force temporary change, fixup cursor and palette.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsA)(
    LPDEVMODEA lpDevMode,
    DWORD      dwFlags
    )
{
    dwFlags &= MODE_MASK;
    if (dwFlags == 0 || dwFlags == CDS_UPDATEREGISTRY) {
        dwFlags = CDS_FULLSCREEN;
        LOGN(eDbgLevelError,
             "[ChangeDisplaySettingsA] Changing flags to CDS_FULLSCREEN.");
    }

    ShowCursor(FALSE);
    INT iCntOld = ShowCursor(TRUE);

    LONG lRet = ORIGINAL_API(ChangeDisplaySettingsA)(
        lpDevMode,
        dwFlags);

    INT iCntNew = ShowCursor(FALSE);
    while (iCntNew != iCntOld) {
        iCntNew = ShowCursor(iCntNew < iCntOld ? TRUE : FALSE);
    }

    FixPalette();

    return lRet;
}

/*++

 Force temporary change, fixup cursor and palette.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsExA)(
    LPCSTR     lpszDeviceName,
    LPDEVMODEA lpDevMode,
    HWND       hwnd,
    DWORD      dwFlags,
    LPVOID     lParam
    )
{
    dwFlags &= MODE_MASK;
    if (dwFlags == 0 || dwFlags == CDS_UPDATEREGISTRY) {
        dwFlags = CDS_FULLSCREEN;
        LOGN(eDbgLevelError,
             "[ChangeDisplaySettingsExA] Changing flags to CDS_FULLSCREEN.");
    }

    ShowCursor(FALSE);
    INT iCntOld = ShowCursor(TRUE);

    LONG lRet = ORIGINAL_API(ChangeDisplaySettingsExA)(
        lpszDeviceName, 
        lpDevMode, 
        hwnd, 
        dwFlags, 
        lParam);

    INT iCntNew = ShowCursor(FALSE);
    while (iCntNew != iCntOld) {
        iCntNew = ShowCursor(iCntNew < iCntOld ? TRUE : FALSE);
    }

    FixPalette();

    return lRet;
}

/*++

 Remove stray characters from the end of a translation. 

--*/

int
APIHOOK(ToAscii)(
    UINT   wVirtKey,
    UINT   wScanCode,
    PBYTE  lpKeyState,
    LPWORD lpChar,
    UINT   wFlags
    )
{
    int iRet = ORIGINAL_API(ToAscii)(
        wVirtKey,
        wScanCode,
        lpKeyState,
        lpChar,
        wFlags);

    LPBYTE p = (LPBYTE)lpChar;
    
    p[iRet] = '\0';

    return iRet;
}

/*++

 Remove stray characters from the end of a translation.

--*/

int
APIHOOK(ToAsciiEx)(
    UINT   wVirtKey,
    UINT   wScanCode,
    PBYTE  lpKeyState,
    LPWORD lpChar,
    UINT   wFlags,
    HKL    dwhkl
    )
{
    int iRet = ORIGINAL_API(ToAsciiEx)(
        wVirtKey,
        wScanCode,
        lpKeyState,
        lpChar,
        wFlags,
        dwhkl);

    LPBYTE p = (LPBYTE) lpChar;
    
    p[iRet] = '\0';

    return iRet;
}

/*++

 Strip the high bits off nCmdShow

--*/

LONG 
APIHOOK(ShowWindow)(
    HWND hWnd,
    int nCmdShow
    )
{
    if (nCmdShow & 0xFFFF0000) {
        LOGN( eDbgLevelWarning, "[ShowWindow] Fixing invalid parameter");

        // Remove high bits
        nCmdShow &= 0xFFFF;
    }

    return ORIGINAL_API(ShowWindow)(hWnd, nCmdShow);
}

/*++

 This fixes the bad wMsgFilterMax parameter.

--*/

BOOL
APIHOOK(PeekMessageA)( 
    LPMSG lpMsg, 
    HWND hWnd, 
    UINT wMsgFilterMin, 
    UINT wMsgFilterMax, 
    UINT wRemoveMsg 
    )
{
    if ((wMsgFilterMin == 0) && (wMsgFilterMax == 0xFFFFFFFF)) {
        LOGN( eDbgLevelWarning, "[PeekMessageA] Correcting parameters");
        wMsgFilterMax = 0;
    }

    return ORIGINAL_API(PeekMessageA)( 
        lpMsg, 
        hWnd, 
        wMsgFilterMin, 
        wMsgFilterMax, 
        wRemoveMsg);
}

/*++

 This fixes the bad wMsgFilterMax parameter.

--*/

BOOL
APIHOOK(GetMessageA)( 
    LPMSG lpMsg, 
    HWND hWnd, 
    UINT wMsgFilterMin, 
    UINT wMsgFilterMax 
    )
{
    if ((wMsgFilterMin == 0) && (wMsgFilterMax == 0xFFFFFFFF)) {
        LOGN( eDbgLevelWarning, "[GetMessageA] Correcting parameters");
        wMsgFilterMax = 0;
    }

    return ORIGINAL_API(GetMessageA)( 
        lpMsg, 
        hWnd, 
        wMsgFilterMin, 
        wMsgFilterMax);
}

/*++

 Track the system palette use

--*/

UINT 
APIHOOK(SetSystemPaletteUse)(
    HDC hdc,      
    UINT uUsage   
    )
{
    EnterCriticalSection(&g_csPalette);
    
    g_uPaletteLastUse = uUsage;

    UINT uRet = ORIGINAL_API(SetSystemPaletteUse)(hdc, uUsage);

    LeaveCriticalSection(&g_csPalette);
    
    return uRet;
}

/*++

 Fill in the last known palette if anything was realized

--*/

UINT 
APIHOOK(RealizePalette)(
    HDC hdc   
    )
{
    EnterCriticalSection(&g_csPalette);

    UINT uRet = ORIGINAL_API(RealizePalette)(hdc);

    if (uRet) {
        //
        // Copy the current logical palette to our global store
        //
        HPALETTE hPal = (HPALETTE) GetCurrentObject(hdc, OBJ_PAL);

        if (hPal) {
            GetPaletteEntries(hPal, 0, 256, (PALETTEENTRY *)&g_peTable);
        }
    }

    LeaveCriticalSection(&g_csPalette);

    return uRet;
}

/*++

 Update our private palette with the new entries.

--*/

BOOL 
APIHOOK(AnimatePalette)(
    HPALETTE hPal,            
    UINT iStartIndex,         
    UINT cEntries,            
    CONST PALETTEENTRY *ppe   
    )
{
    EnterCriticalSection(&g_csPalette);

    BOOL bRet = ORIGINAL_API(AnimatePalette)(hPal, iStartIndex, cEntries, ppe);

    if (bRet) {
        //
        // We have to populate our global settings 
        //
        PALETTEENTRY peTable[256];

        if (GetPaletteEntries(hPal, iStartIndex, cEntries, &peTable[iStartIndex]) == cEntries) {
            //
            // Replace all the entries in our global table that are reserved 
            // for animation.
            //
            for (UINT i=iStartIndex; i<iStartIndex + cEntries; i++) {
                LPPALETTEENTRY p = (LPPALETTEENTRY)&g_peTable[i];
                if (p->peFlags & PC_RESERVED) {
                    //
                    // This entry is being animated
                    //
                    p->peRed = peTable[i].peRed;
                    p->peGreen = peTable[i].peGreen;
                    p->peBlue = peTable[i].peBlue;
                }
            }
        }
    }

    LeaveCriticalSection(&g_csPalette);

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Critical section for palette globals
        //
        InitializeCriticalSection(&g_csPalette);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL, SetWindowsHookExA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsA)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExA)
    APIHOOK_ENTRY(USER32.DLL, ToAscii)
    APIHOOK_ENTRY(USER32.DLL, ToAsciiEx)
    APIHOOK_ENTRY(USER32.DLL, ShowWindow)
    APIHOOK_ENTRY(USER32.DLL, PeekMessageA)
    APIHOOK_ENTRY(USER32.DLL, GetMessageA)
    APIHOOK_ENTRY(GDI32.DLL, SetSystemPaletteUse);
    APIHOOK_ENTRY(GDI32.DLL, AnimatePalette);
    APIHOOK_ENTRY(GDI32.DLL, RealizePalette);

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\force8bitcolor.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Force8BitColor.cpp

 Abstract:

    This shim is for games that require 256 colors (8 bit).

 Notes:

    This is a general purpose shim.

 History:

    02/13/2001 dmunsil  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Force8BitColor)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

#define CDS_BITS    8

VOID
Force8BitColor_ChangeMode()
{
    DEVMODEA dm;

    __try { 
        EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dm);
        if ((dm.dmBitsPerPel != CDS_BITS))
        {
            dm.dmBitsPerPel = CDS_BITS;
            ChangeDisplaySettingsA(&dm, CDS_FULLSCREEN);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DPFN( eDbgLevelWarning, "Exception trying to change mode");
    };
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        Force8BitColor_ChangeMode();
    }
    
    return TRUE;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END
IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\feedbackreport.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    DisableThemes.cpp

 Abstract:

    This shim is for apps that don't support themes.

 Notes:

    This is a general purpose shim.

 History:

    01/15/2001 clupu      Created

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(FeedbackReport)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

void
LaunchFeedbackUI(
    void
    )
{
    STARTUPINFOW        si;
    PROCESS_INFORMATION pi;
    WCHAR               szCmdLine[MAX_PATH];
    WCHAR               szExeName[MAX_PATH];

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));
    
    si.cb = sizeof(si);

    GetModuleFileNameW(NULL, szExeName, MAX_PATH);

    swprintf(szCmdLine, L"ahui.exe feedback \"%s\"", szExeName);

    CreateProcessW(NULL,
                   szCmdLine,
                   NULL,
                   NULL,
                   FALSE,
                   0,
                   NULL,
                   NULL,
                   &si,
                   &pi);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_PROCESS_DYING) {
        LaunchFeedbackUI();
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\force640x480.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Force640x480.cpp

 Abstract:

    This shim is for games that assume the start resolution is 640x480.

 Notes:

    This is a general purpose shim.

 History:

    02/13/2001 dmunsil  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Force640x480)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

#define CDS_WIDTH   640
#define CDS_HEIGHT  480

VOID
Force640x480_ChangeMode()
{
    DEVMODEA dm;

    __try { 
        EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dm);
        if ((dm.dmPelsWidth != CDS_WIDTH) ||
            (dm.dmPelsHeight != CDS_HEIGHT))
        {
            dm.dmPelsWidth = CDS_WIDTH;
            dm.dmPelsHeight = CDS_HEIGHT;
            ChangeDisplaySettingsA(&dm, CDS_FULLSCREEN);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DPFN( eDbgLevelWarning, "Exception trying to change mode");
    };
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        Force640x480_ChangeMode();
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END
IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\forceansigetdisplaynameof.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceAnsiGetDisplayNameOf.cpp

 Abstract:

    This shim force the routine IShellFolder::GetDisplayNameOf to return
    an Ascii string whenever it detects that GetDisplayNameOf returned
    a unicode string.

 Notes:

    This is an app is generic.

 History:

    07/26/2000 mnikkel Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceAnsiGetDisplayNameOf)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SHGetDesktopFolder) 
    APIHOOK_ENUM_ENTRY_COMSERVER(SHELL32)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(SHELL32)

/*++

 Hook SHGetDesktopFolder to get the IShellFolder Interface Pointer.

--*/

HRESULT
APIHOOK(SHGetDesktopFolder)(
    IShellFolder **ppshf
    )
{
    HRESULT hReturn;
    
    hReturn = ORIGINAL_API(SHGetDesktopFolder)(ppshf);

    if (SUCCEEDED(hReturn))
    {
        HookObject(
            NULL, 
            IID_IShellFolder, 
            (PVOID*)ppshf, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook GetDisplayName of and when it returns a unicode string convert it over to
 an ANSI string.

--*/

HRESULT
COMHOOK(IShellFolder, GetDisplayNameOf)(
    PVOID pThis,
    LPCITEMIDLIST pidl,
    DWORD uFlags,
    LPSTRRET lpName
    )
{
    HRESULT hrReturn = E_FAIL;

    _pfn_IShellFolder_GetDisplayNameOf pfnOld = 
                ORIGINAL_COM(IShellFolder, GetDisplayNameOf, pThis);

    if (pfnOld)
    { 
        hrReturn = (*pfnOld)(pThis, pidl, uFlags, lpName);

        // Check for unicode string and validity
        if ((S_OK == hrReturn) && (lpName->uType == STRRET_WSTR) && lpName->pOleStr)
        {
            LPMALLOC pMalloc;
            LPWSTR pTemp;

            // Unicode found, convert it to ANSI and free the original unicode string.
            if (SUCCEEDED(SHGetMalloc(&pMalloc)))
            {
                // Save OleStr ptr.  The OleStr ptr and the cStr are unioned together
                // so when we fill the cStr it will wipe out the OleStr ptr.
                pTemp = lpName->pOleStr;
                WideCharToMultiByte(CP_ACP, 0, pTemp, -1, lpName->cStr, MAX_PATH, NULL, NULL);

                // set the uType to CSTR and free the old unicode string.
                lpName->uType = STRRET_CSTR;
                pMalloc->Free(pTemp);

                LOGN(
                    eDbgLevelError,
                    "[IShellFolder_GetDisplayNameOf] Converted string from Unicode to ANSI: %s", 
                    lpName->cStr);
            }
        }
    }

    return hrReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_COMSERVER(SHELL32)
    APIHOOK_ENTRY(SHELL32.DLL, SHGetDesktopFolder)
    COMHOOK_ENTRY(ShellDesktop, IShellFolder, GetDisplayNameOf, 11)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\fileversioninfolie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    FileVersionInfoLie.cpp

 Abstract:

    This shim replaces the info returned from calls to GetFileVersionInfoSize and
    GetFileVersionInfo with information stored in resource files.  The default
    is to replace file info with stored info obtained from DirectX ver 7a.
    This can be overridden with command line input.  For example:

    COMMAND_LINE("D3drgbxf.dll,IDR_D3DRGBXFINFO;dsound.vxd,IDR_DSOUNDVXDINFO")

    this would intercept the info calls for D3drgbxf.dll and dsounc.vxd and replace
    their info with the info stored in the resources named. Note: All spaces within
    the command line are considered part of the filename or resource name, only the
    commas and semicolons are delimeters.

 Notes:

    This is a general purpose shim.

 History:

    01/03/2000 a-jamd   Created
    03/28/2000 a-jamd   Added resource for ddraw16.dll
    04/04/2000 a-michni Added resource for D3drgbxf.dll
    04/07/2000 linstev  Added resource for dsound.vxd
    04/10/2000 markder  Removed GetModuleHandle("_DDRAW6V") calls -- use g_hinstDll
    04/18/2000 a-michni Modified DDraw6Versionlie to be command line input driven and
                        renamed to FileVersionInfoLie
    04/26/2000 a-batjar GetFileVersionInfo should return truncated result if passed
                        in buffer size is smaller than infosize
    07/19/2000 andyseti Added resource for shdocvw.bin
    08/11/2000 a-brienw changed g_nNumDirectX6 to 7 and added entry for dsound.dll
                        made it the same as dsound.vxd
    08/15/2000 a-vales  Added resource for dsound.dll
    11/08/2000 a-brienw changed dsound.dll entry to return dsound.vxd version info.
                        a-vales changed it from my previous entry which caused MAX2
                        to no longer work.  I changed it back and checked it with
                        MAX2 and his app Golden Nugget and it is fine with both.
    12/06/2000 mnikkel  Added resources for all directx7a dlls and also for any
                        dlls that existed in previous versions of directx but
                        were deleted.  NOTE: the resources for these files are
                        in win98 format so that apps which directly read the version
                        info will receive them in the way they are expecting.
--*/
#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FileVersionInfoLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoA)
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoSizeA)
APIHOOK_ENUM_END

   
// Keep a list of files to version lie.
struct LIELIST
{
    struct LIELIST * next;
    CString         szFileName;
    CString         szResource;
};

LIELIST *g_pLieList = NULL;

// DirectX 7a default files go here.
const INT   g_nNumDirectX7a = 67;

WCHAR  *g_szDirectX7aFiles[g_nNumDirectX7a] =
    { L"dplay.dll",      L"d3dim.dll",        L"d3dim700.dll",
      L"d3dpmesh.dll",   L"d3dramp.dll",      L"d3drampf.dll",
      L"d3dref.dll",     L"d3drg16f.dll",     L"d3drg24f.dll",
      L"d3drg24x.dll",   L"d3dhalf.dll",      L"d3drg32f.dll",
      L"d3drg32x.dll",   L"d3drg55x.dll",     L"d3drg56x.dll",
      L"d3drg8f.dll",    L"d3drg8x.dll",      L"d3drgbf.dll",
      L"d3drgbxf.dll",   L"d3drm.dll",        L"d3drm16f.dll",
      L"d3drm24f.dll",   L"d3drm32f.dll",     L"d3drm8f.dll",
      L"d3dxof.dll",     L"ddhelp.exe",       L"ddraw.dll",
      L"ddraw16.dll",    L"ddrawex.dll",      L"devnode1.dll",
      L"devnode2.dll",   L"dinput.dll",       L"dmband.dll",
      L"dmcompos.dll",   L"dmime.dll",        L"dmloader.dll",
      L"dmstyle.dll",    L"dmsynth.dll",      L"dmusic.dll",
      L"dmusic16.dll",   L"dmusic32.dll",     L"dplayx.dll",
      L"dpmodemx.dll",   L"dpserial.dll",     L"dpwsock.dll",
      L"dpwsockx.dll",   L"dsetup.dll",       L"dsetup16.dll",
      L"dsetup32.dll",   L"dsetup6e.dll",     L"dsetup6j.dll",
      L"dsetupe.dll",    L"dsetupj.dll",      L"dsound.dll",
      L"dsound3d.dll",   L"dx7vb.dll",        L"dxmigr.dll",
      L"gcdef.dll",      L"gchand.dll",       L"msvcrt.dll",
      L"pid.dll",        L"vjoyd.vxd",        L"dinput.vxd",
      L"dsound.vxd",     L"joyhid.vxd",       L"mtrr.vxd",
      L"ddraw.vxd"
    };

// NOTE: These are 16 bit resources!!!  This is necessary in case
// they index into the data themselves.  If they do a verqueryvalue
// the data is converted before its returned by verqueryvalue.
WCHAR  * g_szDirectX7aResource[g_nNumDirectX7a] =
    { L"IDR_dplay",      L"IDR_d3dim",        L"IDR_d3dim700",
      L"IDR_d3dpmesh",   L"IDR_d3dramp",      L"IDR_d3drampf",
      L"IDR_d3dref",     L"IDR_d3drg16f",     L"IDR_d3drg24f",
      L"IDR_d3drg24x",   L"IDR_d3dhalf",      L"IDR_d3drg32f",
      L"IDR_d3drg32x",   L"IDR_d3drg55x",     L"IDR_d3drg56x",
      L"IDR_d3drg8f",    L"IDR_d3drg8x",      L"IDR_d3drgbf",
      L"IDR_d3drgbxf",   L"IDR_d3drm",        L"IDR_d3drm16f",
      L"IDR_d3drm24f",   L"IDR_d3drm32f",     L"IDR_d3drm8f",
      L"IDR_d3dxof",     L"IDR_ddhelp",       L"IDR_ddraw",
      L"IDR_ddraw16",    L"IDR_ddrawex",      L"IDR_devnode1",
      L"IDR_devnode2",   L"IDR_dinput",       L"IDR_dmband",
      L"IDR_dmcompos",   L"IDR_dmime",        L"IDR_dmloader",
      L"IDR_dmstyle",    L"IDR_dmsynth",      L"IDR_dmusic",
      L"IDR_dmusic16",   L"IDR_dmusic32",     L"IDR_dplayx",
      L"IDR_dpmodemx",   L"IDR_dpserial",     L"IDR_dpwsock",
      L"IDR_dpwsockx",   L"IDR_dsetup",       L"IDR_dsetup16",
      L"IDR_dsetup32",   L"IDR_dsetup6e",     L"IDR_dsetup6j",
      L"IDR_dsetupe",    L"IDR_dsetupj",      L"IDR_dsound",
      L"IDR_dsound3d",   L"IDR_dx7vb",        L"IDR_dxmigr",
      L"IDR_gcdef",      L"IDR_gchand",       L"IDR_msvcrt",
      L"IDR_pid",        L"IDR_vjoydvxd",     L"IDR_dinputvxd",
      L"IDR_dsoundvxd",  L"IDR_joyhidvxd",    L"IDR_mtrrvxd",
      L"IDR_ddrawvxd"
    };


/*++

 return the size from the resource.

--*/
DWORD 
APIHOOK(GetFileVersionInfoSizeA)(
    LPSTR lpstrFilename,  
    LPDWORD lpdwHandle      
    )
{
    DWORD dwRet = 0;

    CSTRING_TRY
    {
        HRSRC hrsrcManifest = NULL;
        LIELIST *pLiePtr = g_pLieList;
        DPFN( eDbgLevelSpew, "[GetFileVersionInfoSizeA] size requested for %s\n", lpstrFilename );

        CString csFileName(lpstrFilename);
        CString csFilePart;
        csFileName.GetLastPathComponent(csFilePart);

        // Search through the list of files with their matching IDR's
        while( pLiePtr )
        {
            if (csFilePart.CompareNoCase(pLiePtr->szFileName) == 0)
            {
                hrsrcManifest = FindResourceW( g_hinstDll, pLiePtr->szResource, L"FILES");
                break;
            }
            pLiePtr = pLiePtr->next;
        }

        // If a match was found, get the resource size
        if( hrsrcManifest )
        {
            dwRet = SizeofResource(g_hinstDll, hrsrcManifest);
            *lpdwHandle = NULL;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    if (dwRet == 0)
    {
        dwRet = ORIGINAL_API(GetFileVersionInfoSizeA)(lpstrFilename, lpdwHandle);
    }
    
    return dwRet;
}


/*++

  Return the version for the modules that shipped with Win98SE.

--*/
BOOL 
APIHOOK(GetFileVersionInfoA)(
    LPSTR lpstrFilename,
    DWORD dwHandle,
    DWORD dwLen,
    LPVOID lpData
    )
{
    BOOL bRet = FALSE;

    CSTRING_TRY
    {
        HRSRC hrsrcManifest = NULL;
        LIELIST *pLiePtr = g_pLieList;
        DPFN( eDbgLevelSpew, "[GetFileVersionInfoA] info requested for %s\n", lpstrFilename );

        CString csFileName(lpstrFilename);
        CString csFilePart;
        csFileName.GetLastPathComponent(csFilePart);

        // Search through the list of files with their matching IDR's
        while( pLiePtr )
        {
            if (csFilePart.CompareNoCase(pLiePtr->szFileName) == 0)
            {
                hrsrcManifest = FindResourceW( g_hinstDll, pLiePtr->szResource, L"FILES");
                break;
            }
            pLiePtr = pLiePtr->next;
        }

        // If a match was found, get the resource size
        if( hrsrcManifest )
        {
            LOGN( eDbgLevelError, "[GetFileVersionInfoA] Getting legacy version for %s.", lpstrFilename);

            DWORD   dwManifestSize = SizeofResource(g_hinstDll, hrsrcManifest);
            HGLOBAL hManifestMem   = LoadResource (g_hinstDll, hrsrcManifest);
            PVOID   lpManifestMem  = LockResource (hManifestMem);

            memcpy(lpData, lpManifestMem, dwLen >= dwManifestSize ? dwManifestSize:dwLen );
            bRet = TRUE;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    if (!bRet)
    {
        bRet = ORIGINAL_API(GetFileVersionInfoA)( 
                    lpstrFilename, 
                    dwHandle, 
                    dwLen, 
                    lpData);
    }
    
   return bRet;
}


/*++

 Parse the command line inputs.

--*/
BOOL ParseCommandLine(const char * commandLine)
{
    CSTRING_TRY
    {
        CString csCmdLine(commandLine);
    
        // if there are no command line inputs then default to
        // the DirectX 7a files needed.
        if (csCmdLine.IsEmpty())
        {
            DPFN( eDbgLevelSpew, "Defaulting to DirectX7a\n" );
    
            for(int i = 0; i < g_nNumDirectX7a; i++)
            {
                LIELIST * pLiePtr = new LIELIST;
                pLiePtr->szFileName =  g_szDirectX7aFiles[i];
                pLiePtr->szResource =  g_szDirectX7aResource[i];
                pLiePtr->next = g_pLieList;
                g_pLieList = pLiePtr;
            }
        }
        else
        {
            CStringToken csTokenList(csCmdLine, L";");
            CString      csEntryTok;
        
            while (csTokenList.GetToken(csEntryTok))
            {
                CStringToken csEntry(csEntryTok, L",");
                
                CString csLeft;
                CString csRight;
        
                csEntry.GetToken(csLeft);
                csEntry.GetToken(csRight);
        
                if (!csLeft.IsEmpty() && !csRight.IsEmpty())
                {
                    LIELIST * pLiePtr = new LIELIST;
                    pLiePtr->szFileName = csLeft;
                    pLiePtr->szResource = csRight;
                    pLiePtr->next = g_pLieList;
                    g_pLieList = pLiePtr;
                }
            }
        }
    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    return TRUE;
}



/*++

 Register hooked functions

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return ParseCommandLine(COMMAND_LINE);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(VERSION.DLL, GetFileVersionInfoA)
    APIHOOK_ENTRY(VERSION.DLL, GetFileVersionInfoSizeA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\forcecoinitialize.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceCoInitialize.cpp

 Abstract:

    Makes sure we call CoInitialize on this thread if nobody else has.

 Notes:

    This is a general purpose shim.

 History:

    02/22/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceCoInitialize)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CoCreateInstance)
APIHOOK_ENUM_END

/*++

 Call CoInitialize if nobody else has
 
--*/

STDAPI 
APIHOOK(CoCreateInstance)(
    REFCLSID  rclsid,     
    LPUNKNOWN pUnkOuter, 
    DWORD     dwClsContext,  
    REFIID    riid,         
    LPVOID*   ppv
    )
{
    HRESULT hr = ORIGINAL_API(CoCreateInstance)(
                                rclsid,     
                                pUnkOuter, 
                                dwClsContext,  
                                riid,         
                                ppv);

    if (hr == CO_E_NOTINITIALIZED) {
        if (CoInitialize(NULL) == S_OK) {
            DPFN(
                eDbgLevelInfo,
                "[CoCreateInstance] Success: Initialized previously uninitialized COM.\n");
        }

        hr = ORIGINAL_API(CoCreateInstance)(
                                rclsid,     
                                pUnkOuter, 
                                dwClsContext,  
                                riid,         
                                ppv);
    }
    
    return hr;
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(OLE32.DLL, CoCreateInstance)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\forcecdstop.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceCDStop.cpp

 Abstract:

    This shim is used to fix the problem of contention with the CD Drive.
    Some applications try and access the CD even if they are in the middle of 
    playing a movie or sound via MCI. Note that this shim assumes the app
    is running off of a single CDRom drive at a time.

 Notes:

    This is a general purpose shim.

 History:

    04/10/2000 linstev  Created
    04/12/2000 a-michni Added _hread, ReadFile and _lseek capability.
    04/28/2000 a-michni changed logic to check for IsACDRom before
                        checking for a bad handle, this way CD letter
                        is set for those routines which only have a
                        handle and no way of finding the drive letter.
    05/30/2000 a-chcoff Changed logic to do a cd stop only if error was device busy..
                        we were checking every failed access and plane crazy was making
                        lots of calls that would fail as file not found. as such the cd was
                        getting stopped when it did not need to be, causing a CD not found.
                        This shim should be changed to a faster model. maybe later..
                         
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceCDStop)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileW)
    APIHOOK_ENUM_ENTRY(FindFirstFileExA)
    APIHOOK_ENUM_ENTRY(FindFirstFileExW)
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(ReadFile)
    APIHOOK_ENUM_ENTRY(_hread)
    APIHOOK_ENUM_ENTRY(_lseek)
APIHOOK_ENUM_END


// Include these so we can get to the IOCTLs

#include <devioctl.h>
#include <ntddcdrm.h>

//
// We have to store the first opened CD drive, so that if ReadFile fails, we 
// know which drive to stop. Note, we don't need to protect this variable with
// a critical section, since it's basically atomic.
//

WCHAR g_wLastCDDrive = L'\0';

/*++

 Initialize the global CD letter variable if required. 

--*/

VOID
InitializeCDA(
    LPSTR lpFileName
    )
{
    CHAR cDrive;
    
    if (!g_wLastCDDrive) {
        if (GetDriveTypeFromFileNameA(lpFileName, &cDrive) == DRIVE_CDROM) {
            g_wLastCDDrive = (WCHAR)cDrive;
        }
    }
}

/*++

 Initialize the global CD letter variable if required.

--*/

VOID 
InitializeCDW(
    LPWSTR lpFileName
    )
{
    WCHAR wDrive;
    
    if (!g_wLastCDDrive) {
        if (GetDriveTypeFromFileNameW(lpFileName, &wDrive) == DRIVE_CDROM) {
            g_wLastCDDrive = wDrive;
        }
    }
}

/*++

 Send a STOP IOCTL to the specified drive.

--*/

BOOL 
StopDrive(
    WCHAR wDrive
    )
{
    BOOL   bRet = FALSE;
    HANDLE hDrive;
    WCHAR  wzCDROM[7] = L"\\\\.\\C:";

    wzCDROM[4] = wDrive;

    hDrive = CreateFileW(wzCDROM,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);

    if (hDrive != INVALID_HANDLE_VALUE) {
        DWORD dwBytesRead;

        // Attempt to stop the audio 
        bRet = DeviceIoControl(hDrive,
                               IOCTL_CDROM_STOP_AUDIO,
                               NULL,
                               0,
                               NULL,
                               0,
                               &dwBytesRead,
                               NULL);

        CloseHandle(hDrive);

        if (bRet) {
            DPFN( eDbgLevelInfo,
                "[StopDrive] Successfully stopped drive.\n");
        } else {
            DPFN( eDbgLevelError,
                "[StopDrive] Failed to stop drive. Error %d.\n", GetLastError());
        }
    } else {
        DPFN( eDbgLevelError,
            "[StopDrive] Unable to create cd device handle. %S Error %d.\n",
            wzCDROM, GetLastError());
    }   
    
    return bRet;
}


/*++

 Attempts to stop the CD if filename is a file on a CDROM drive.
 Returns true on a successful stop.

--*/

BOOL
StopCDA(
    LPCSTR lpFileName
    )
{
    CHAR c;
    
    if (GetDriveTypeFromFileNameA(lpFileName, &c) == DRIVE_CDROM) {
        return StopDrive((WCHAR)c);
    } else {
        return FALSE;
    }
}

/*++

 Attempts to stop the CD if filename is a file on a CDROM drive.
 Returns true on a successful stop.

--*/

BOOL
StopCDW(
    LPCWSTR lpFileName
    )
{
    WCHAR w;
    
    if (GetDriveTypeFromFileNameW(lpFileName, &w) == DRIVE_CDROM) {
        return StopDrive(w);
    } else {
        return FALSE;
    }
}

/*++

 Attempts to stop the CD on the last opened CDROM Drive.
 Returns true on a successful stop.

--*/

BOOL
StopCDH(
    HANDLE hFile
    )
{
    if (g_wLastCDDrive) {
        return StopDrive(g_wLastCDDrive);
    } else {
        return FALSE;
    }
}

/*++

 Check for CD file.

--*/

HANDLE
APIHOOK(FindFirstFileA)(
    LPCSTR             lpFileName, 
    LPWIN32_FIND_DATAA lpFindFileData 
    )
{
    HANDLE hRet = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

    if ((hRet == INVALID_HANDLE_VALUE) && (ERROR_BUSY == GetLastError())) {
        
        StopCDA(lpFileName);

        hRet = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

        if (hRet == INVALID_HANDLE_VALUE) {
            DPFN( eDbgLevelWarning,
                "[FindFirstFileA] failure \"%s\" Error %d.\n",
                lpFileName, GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[FindFirstFileA] Success after CD stop: \"%s\".", lpFileName);
        }
    }

    return hRet;
}

/*++

 Check for CD file.

--*/

HANDLE
APIHOOK(FindFirstFileW)(
    LPCWSTR            lpFileName, 
    LPWIN32_FIND_DATAW lpFindFileData 
    )
{
    HANDLE hRet = ORIGINAL_API(FindFirstFileW)(lpFileName, lpFindFileData);

    if ((hRet == INVALID_HANDLE_VALUE) && (ERROR_BUSY == GetLastError())) {
        
        StopCDW(lpFileName);
        
        hRet = ORIGINAL_API(FindFirstFileW)(lpFileName, lpFindFileData);

        if (hRet == INVALID_HANDLE_VALUE) {
            DPFN( eDbgLevelWarning,
                "[FindFirstFileW] failure \"%S\" Error %d.\n",
                lpFileName, GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[FindFirstFileW] Success after CD stop: \"%S\".", lpFileName);
        }
    }

    return hRet;
}

/*++

 Check for CD file.

--*/

HANDLE
APIHOOK(FindFirstFileExA)(
    LPCSTR              lpFileName,
    FINDEX_INFO_LEVELS  fInfoLevelId,
    LPVOID              lpFindFileData,
    FINDEX_SEARCH_OPS   fSearchOp,
    LPVOID              lpSearchFilter,
    DWORD               dwAdditionalFlags
    )
{
    HANDLE hRet = ORIGINAL_API(FindFirstFileExA)(
                            lpFileName, 
                            fInfoLevelId,
                            lpFindFileData,
                            fSearchOp,
                            lpSearchFilter,
                            dwAdditionalFlags);

    if ((hRet == INVALID_HANDLE_VALUE) && (ERROR_BUSY == GetLastError())) {
        
        StopCDA(lpFileName);

        hRet = ORIGINAL_API(FindFirstFileExA)(
                            lpFileName, 
                            fInfoLevelId,
                            lpFindFileData,
                            fSearchOp,
                            lpSearchFilter,
                            dwAdditionalFlags);

        if (hRet == INVALID_HANDLE_VALUE) {
            DPFN( eDbgLevelWarning,
                "[FindFirstFileExA] failure \"%s\" Error %d.\n",
                lpFileName, GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[FindFirstFileExA] Success after CD stop: \"%s\".", lpFileName);
        }
    }

    return hRet;
}

/*++

 Check for CD file.
 
--*/

HANDLE
APIHOOK(FindFirstFileExW)(
    LPCWSTR             lpFileName,
    FINDEX_INFO_LEVELS  fInfoLevelId,
    LPVOID              lpFindFileData,
    FINDEX_SEARCH_OPS   fSearchOp,
    LPVOID              lpSearchFilter,
    DWORD               dwAdditionalFlags
    )
{
    HANDLE hRet = ORIGINAL_API(FindFirstFileExW)(
                            lpFileName, 
                            fInfoLevelId,
                            lpFindFileData,
                            fSearchOp,
                            lpSearchFilter,
                            dwAdditionalFlags);

    if ((hRet == INVALID_HANDLE_VALUE) && (ERROR_BUSY == GetLastError())) {
        
        StopCDW(lpFileName);

        hRet = ORIGINAL_API(FindFirstFileExW)(
                            lpFileName, 
                            fInfoLevelId,
                            lpFindFileData,
                            fSearchOp,
                            lpSearchFilter,
                            dwAdditionalFlags);

        if (hRet == INVALID_HANDLE_VALUE) {
            DPFN( eDbgLevelWarning,
                "[FindFirstFileExW] failure \"%S\" Error %d.\n",
                lpFileName, GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[FindFirstFileExW] Success after CD stop: \"%S\".", lpFileName);
        }
    }

    return hRet;
}

/*++

 Check for CD file.

--*/

HANDLE 
APIHOOK(CreateFileA)(
    LPSTR                   lpFileName,
    DWORD                   dwDesiredAccess,
    DWORD                   dwShareMode,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    DWORD                   dwCreationDisposition,
    DWORD                   dwFlagsAndAttributes,
    HANDLE                  hTemplateFile
    )
{
    HANDLE hRet = ORIGINAL_API(CreateFileA)(
                            lpFileName, 
                            dwDesiredAccess, 
                            dwShareMode, 
                            lpSecurityAttributes, 
                            dwCreationDisposition, 
                            dwFlagsAndAttributes, 
                            hTemplateFile);
    
    InitializeCDA(lpFileName);
    
    if ((INVALID_HANDLE_VALUE == hRet) && (ERROR_BUSY == GetLastError())) {
        StopCDA(lpFileName);
        
        hRet = ORIGINAL_API(CreateFileA)(
                            lpFileName, 
                            dwDesiredAccess, 
                            dwShareMode, 
                            lpSecurityAttributes, 
                            dwCreationDisposition, 
                            dwFlagsAndAttributes, 
                            hTemplateFile);

        if (hRet == INVALID_HANDLE_VALUE) {
            DPFN( eDbgLevelWarning,
                "[CreateFileA] failure \"%s\" Error %d.\n",
                lpFileName, GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[CreateFileA] Success after CD stop: \"%s\".", lpFileName);
        }
    }
    
    return hRet;
}

/*++

 Check for CD file.

--*/

HANDLE 
APIHOOK(CreateFileW)(
    LPWSTR                  lpFileName,
    DWORD                   dwDesiredAccess,
    DWORD                   dwShareMode,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    DWORD                   dwCreationDisposition,
    DWORD                   dwFlagsAndAttributes,
    HANDLE                  hTemplateFile
    )
{
    HANDLE hRet = ORIGINAL_API(CreateFileW)(
                            lpFileName, 
                            dwDesiredAccess, 
                            dwShareMode, 
                            lpSecurityAttributes, 
                            dwCreationDisposition, 
                            dwFlagsAndAttributes, 
                            hTemplateFile);
    
    InitializeCDW(lpFileName);
    
    if ((INVALID_HANDLE_VALUE == hRet) && (ERROR_BUSY == GetLastError())) {
        StopCDW(lpFileName);
        
        hRet = ORIGINAL_API(CreateFileW)(
                            lpFileName, 
                            dwDesiredAccess, 
                            dwShareMode, 
                            lpSecurityAttributes, 
                            dwCreationDisposition, 
                            dwFlagsAndAttributes, 
                            hTemplateFile);

        if (hRet == INVALID_HANDLE_VALUE) {
            DPFN( eDbgLevelWarning,
                "[CreateFileW] failure \"%S\" Error %d.\n",
                lpFileName, GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[CreateFileW] Success after CD stop: \"%S\".", lpFileName);
        }
    }
    
    return hRet;
}

/*++

 Check for _lseek error.
 
--*/

long 
APIHOOK(_lseek)(
    int  handle,
    long offset,
    int  origin
    )
{
    long iRet = ORIGINAL_API(_lseek)(handle, offset, origin);

    if (iRet == -1L  && IsOnCDRom((HANDLE)handle)) {
        
        StopCDH((HANDLE)handle);
        
        iRet = ORIGINAL_API(_lseek)(handle, offset, origin);

        if (iRet == -1L) {
            DPFN( eDbgLevelWarning,
                "[_lseek] failure: Error %d.\n", GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[_lseek] Success after CD stop.");
        }
    }

    return iRet;
}


/*++

 Check for _hread error.
 
--*/

long 
APIHOOK(_hread)(
    HFILE  hFile,
    LPVOID lpBuffer,
    long   lBytes
    )
{
    long iRet = ORIGINAL_API(_hread)(hFile, lpBuffer, lBytes);

    if (iRet == HFILE_ERROR && IsOnCDRom((HANDLE)hFile)) {
        StopCDH((HANDLE)hFile);

        iRet = ORIGINAL_API(_hread)(hFile, lpBuffer, lBytes);

        if (iRet == HFILE_ERROR) {
            DPFN( eDbgLevelWarning,
                "[_hread] failure: Error %d.\n", GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[_hread] Success after CD stop.");
        }
    }

    return iRet;
}

/*++

 Check for ReadFile error.
 
--*/

BOOL 
APIHOOK(ReadFile)(
    HANDLE       hFile,
    LPVOID       lpBuffer,
    DWORD        nNumberOfBytesToRead,
    LPDWORD      lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )
{
    BOOL bRet = ORIGINAL_API(ReadFile)(
                            hFile,
                            lpBuffer,
                            nNumberOfBytesToRead,
                            lpNumberOfBytesRead,
                            lpOverlapped);

    if ((bRet == FALSE) && (ERROR_BUSY == GetLastError()) && IsOnCDRom(hFile)) {
        
        StopCDH(hFile);

        bRet = ORIGINAL_API(ReadFile)(
                            hFile,
                            lpBuffer,
                            nNumberOfBytesToRead,
                            lpNumberOfBytesRead,
                            lpOverlapped);

        if (bRet == FALSE) {
            DPFN( eDbgLevelWarning,
                "[ReadFile] failure Error %d.\n", GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[ReadFile] Success after CD stop.");
        }
    }

    return bRet;
}


/*++

 Register hooked functions

--*/


HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileExW)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, ReadFile)
    APIHOOK_ENTRY(KERNEL32.DLL, _hread)
    APIHOOK_ENTRY(LIBC.DLL, _lseek)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\forcedxsetupsuccess.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    ForceDXSetupSuccess.cpp

 Abstract:

    This DLL APIHooks LoadLibrary calls and checks to see if dsetup.dll or 
    dsetup32.dll are being loaded.  If dsetup.dll or dsetup32.dll are being 
    loaded return this module, so that subsequent calls to that dll can be 
    intercepted and stubbed out. If not dsetup.dll or dsetup32.dll then just 
    do what is expected.

 Notes:
    
    This is a general purpose shim.

 History:

    11/10/1999 v-johnwh     Created
    03/29/2000 a-michni     Added DirectXSetupGetVersion hook to return
                            a command line specified version number for
                            apps which look for a specific version.
                            example :           
                            <DLL NAME="ForceDXSetupSuccess.dll" COMMAND_LINE="0x00040005;0x0000009B"/>
   04/2000     a-batjar     check for null in input params for directxsetupgetversion
   06/30/2000  a-brienw     I added a check for dsetup32.dll to APIHook_LoadLibraryA
                            and APIHook_LoadLibraryW. Previously the routines were
                            only looking for dsetup.dll.  This was added to fix a
                            problem in the install for Earthworm Jim 3D.
   02/27/2001  robkenny     Converted to use CString

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(ForceDXSetupSuccess)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA)
    APIHOOK_ENUM_ENTRY(LoadLibraryW)
    APIHOOK_ENUM_ENTRY(LoadLibraryExA)
    APIHOOK_ENUM_ENTRY(LoadLibraryExW)
    APIHOOK_ENUM_ENTRY(GetProcAddress)
    APIHOOK_ENUM_ENTRY(FreeLibrary)
APIHOOK_ENUM_END

/*++

 This function simply returns 0, success, when called upon.

--*/

int 
DirectXSetup( 
    HWND  /*hWnd*/, 
    LPSTR /*lpszRootPath*/, 
    DWORD /*dwFlags*/
    )
{
    LOGN(
        eDbgLevelError,
        "[DirectXSetup] Returning SUCCESS.");
    
    return 0; // SUCCESS
}

int 
DirectXSetupA( 
    HWND  /*hWnd*/, 
    LPSTR /*lpszRootPath*/, 
    DWORD /*dwFlags*/
    )
{
    LOGN(
        eDbgLevelError,
        "[DirectXSetupA] Returning SUCCESS.");
    
    return 0; // SUCCESS
}

int 
DirectXSetupW( 
    HWND   hWnd, 
    LPWSTR lpszRootPath, 
    DWORD  dwFlags
    )
{
    LOGN(
        eDbgLevelError,
        "[DirectXSetupW] Returning SUCCESS.");
    
    return 0; // SUCCESS
}

/*++

 This Function returns either a COMMAND_LINE parsed value for the version and 
 rev or, if no command line is present, it returns version 7 rev 1792

--*/

int
DirectXSetupGetVersion( 
    DWORD* pdwVersion,
    DWORD* pdwRevision
    )
{
    DWORD dwVersion  = 0x00040007;
    DWORD dwRevision = 0x00000700;

    //
    // If no seperator is present or there is nothing after 
    //   seperator then return a default value of ver 7 rev 1792 
    // Otherwise parse the command line, it should contain a
    //   10 char hex version and a 10 char hex revision 
    //

    CSTRING_TRY
    {
        CStringToken csTokenizer(COMMAND_LINE, ";");

        CString csVersion;
        CString csRevision;

        if (csTokenizer.GetToken(csVersion) && csTokenizer.GetToken(csRevision))
        {
            sscanf(csVersion.GetAnsi(),  "%x", &dwVersion);
            sscanf(csRevision.GetAnsi(), "%x", &dwRevision);
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    
    if (pdwVersion)
    {
        *pdwVersion = dwVersion;
    }
    if (pdwRevision)
    {
        *pdwRevision = dwRevision;
    }
    return 1;
}

/*++

 These stub functions break into LoadLibraryA and check to see if lpLibFileName 
 equals dsetup.dll.  If so return FAKE_MODULE.  If lpLibFileName does not 
 contain dsetup.dll return the original value of lpLibFileName.

--*/

HINSTANCE 
APIHOOK(LoadLibraryA)(
    LPCSTR lpLibFileName
    )
{
    HINSTANCE hInstance = NULL;
    CSTRING_TRY
    {
        CString csName(lpLibFileName);
        CString csFilePart;
        csName.GetLastPathComponent(csFilePart);

        if (
            csFilePart.CompareNoCase(L"dsetup.dll")   == 0 ||
            csFilePart.CompareNoCase(L"dsetup")       == 0 ||
            csFilePart.CompareNoCase(L"dsetup32.dll") == 0 ||
            csFilePart.CompareNoCase(L"dsetup32")     == 0
            )
        {
            LOGN(
                eDbgLevelError,
                "[LoadLibraryA] Caught %s attempt - returning %08lx", lpLibFileName, g_hinstDll);

            return g_hinstDll;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    hInstance = ORIGINAL_API(LoadLibraryA)(lpLibFileName);
    return hInstance;
}

HINSTANCE 
APIHOOK(LoadLibraryW)(
    LPCWSTR lpLibFileName
    )
{
    HINSTANCE hInstance = NULL;
    CSTRING_TRY
    {
        CString csName(lpLibFileName);
        CString csFilePart;
        csName.GetLastPathComponent(csFilePart);

        if (
            csFilePart.CompareNoCase(L"dsetup.dll")   == 0 ||
            csFilePart.CompareNoCase(L"dsetup")       == 0 ||
            csFilePart.CompareNoCase(L"dsetup32.dll") == 0 ||
            csFilePart.CompareNoCase(L"dsetup32")     == 0
            )
        {
            LOGN(
                eDbgLevelError,
                "[LoadLibraryW] Caught %S attempt - returning %08lx", lpLibFileName, g_hinstDll);

            return g_hinstDll;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    hInstance = ORIGINAL_API(LoadLibraryW)(lpLibFileName);
    return hInstance;
}

HINSTANCE 
APIHOOK(LoadLibraryExA)(
    LPCSTR lpLibFileName,
    HANDLE hFile,
    DWORD  dwFlags
    )
{
    HINSTANCE hInstance = NULL;
    CSTRING_TRY
    {
        CString csName(lpLibFileName);
        CString csFilePart;
        csName.GetLastPathComponent(csFilePart);

        if (
            csFilePart.CompareNoCase(L"dsetup.dll")   == 0 ||
            csFilePart.CompareNoCase(L"dsetup")       == 0 ||
            csFilePart.CompareNoCase(L"dsetup32.dll") == 0 ||
            csFilePart.CompareNoCase(L"dsetup32")     == 0
            )
        {
            LOGN(
                eDbgLevelError,
                "[LoadLibraryExA] Caught %s attempt - returning %08lx", lpLibFileName, g_hinstDll);

            return g_hinstDll;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    hInstance = ORIGINAL_API(LoadLibraryExA)(lpLibFileName, hFile, dwFlags);
    return hInstance;
}

HINSTANCE 
APIHOOK(LoadLibraryExW)(
    LPCWSTR lpLibFileName,
    HANDLE  hFile,
    DWORD   dwFlags
    )
{
    HINSTANCE hInstance = NULL;
    CSTRING_TRY
    {
        CString csName(lpLibFileName);
        CString csFilePart;
        csName.GetLastPathComponent(csFilePart);

        if (
            csFilePart.CompareNoCase(L"dsetup.dll")   == 0 ||
            csFilePart.CompareNoCase(L"dsetup")       == 0 ||
            csFilePart.CompareNoCase(L"dsetup32.dll") == 0 ||
            csFilePart.CompareNoCase(L"dsetup32")     == 0
            )
        {
            LOGN(
                eDbgLevelError,
                "[LoadLibraryExW] Caught %S attempt - returning %08lx", lpLibFileName, g_hinstDll);

            return g_hinstDll;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    hInstance = ORIGINAL_API(LoadLibraryExW)(lpLibFileName, hFile, dwFlags);
    return hInstance;
}


/*++

  Just a simple routine to make GetProcAddress look cleaner.

++*/

BOOL CheckProc(const CString & csProcName, const WCHAR * lpszCheckName)
{
    if (csProcName.Compare(lpszCheckName) == 0)
    {
        DPFN(
            eDbgLevelInfo,
            "[GetProcAddress] Caught %S query. Returning stubbed function at 0x%08X",
            lpszCheckName, DirectXSetup);
        return TRUE;
    }
    return FALSE;
}

/*++

 This stub function breaks into GetProcAddress and checks to see if hModule is 
 equal to FAKE_MODULE.  If so, and pResult contains the string "DirectXSetupA" 
 set pRet to the return value of DirectXSetup.

--*/

FARPROC 
APIHOOK(GetProcAddress)(
    HMODULE hModule, 
    LPCSTR  lpProcName 
    )
{
    if (hModule == g_hinstDll)
    {
        CSTRING_TRY
        {
            CString csProcName(lpProcName);
            csProcName.MakeLower();

            if (CheckProc(csProcName, L"directxsetup"))
            {
                return (FARPROC) DirectXSetup;
            }
            else if (CheckProc(csProcName, L"directxsetupa"))
            {
                return (FARPROC) DirectXSetupA;
            }
            else if (CheckProc(csProcName, L"directxsetupw"))
            {
                return (FARPROC) DirectXSetupW;
            }
            else if (CheckProc(csProcName, L"directxsetupgetversion"))
            {
                return (FARPROC) DirectXSetupGetVersion;
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }
    return ORIGINAL_API(GetProcAddress)(hModule, lpProcName);
}

/*++

 This stub function breaks into FreeLibrary and checks to see if hLibModule 
 equals FAKE_MODULE.  If so return TRUE.  If hLibModule does not contain 
 FAKE_MODULE return the original argument.

--*/

BOOL 
APIHOOK(FreeLibrary)(
    HMODULE hLibModule
    )
{
    BOOL bRet;

    if (hLibModule == g_hinstDll)
    {
        DPFN(
            eDbgLevelInfo,
            "[FreeLibrary] Caught DSETUP.DLL/DSETUP32.DLL free attempt. Returning TRUE");
        bRet = TRUE;
    }
    else
    {
        bRet = ORIGINAL_API(FreeLibrary)(hLibModule);
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryW)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryExA)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetProcAddress)
    APIHOOK_ENTRY(KERNEL32.DLL, FreeLibrary)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\forcemessageboxfocus.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ForceMessageBoxFocus.cpp

 Abstract:

   This APIHooks MessageBox and adds the MB_SETFOREGROUND style
   so as to force the messagebox to foreground.
   
 Notes:

 History:

   01/15/2000 a-leelat Created
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceMessageBoxFocus)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MessageBoxA) 
    APIHOOK_ENUM_ENTRY(MessageBoxW) 
    APIHOOK_ENUM_ENTRY(MessageBoxExA) 
    APIHOOK_ENUM_ENTRY(MessageBoxExW) 
APIHOOK_ENUM_END



int
APIHOOK(MessageBoxA)(
    HWND hWnd,          // handle to owner window
    LPCSTR lpText,      // text in message box
    LPCSTR lpCaption,   // message box title
    UINT uType          // message box style
    )
{
    int iReturnValue;

    //Add the foreground style
    uType |= MB_SETFOREGROUND;

    iReturnValue = ORIGINAL_API(MessageBoxA)( 
        hWnd,
        lpText,
        lpCaption,
        uType);

    return iReturnValue;
}

int
APIHOOK(MessageBoxW)(
    HWND hWnd,          // handle to owner window
    LPCWSTR lpText,     // text in message box
    LPCWSTR lpCaption,  // message box title
    UINT uType          // message box style
    )
{
    int iReturnValue;


    //Add the foreground style
    uType |= MB_SETFOREGROUND;

    iReturnValue = ORIGINAL_API(MessageBoxW)( 
        hWnd,
        lpText,
        lpCaption,
        uType);

    return iReturnValue;
}

int
APIHOOK(MessageBoxExA)(
    HWND hWnd,          // handle to owner window
    LPCSTR lpText,      // text in message box
    LPCSTR lpCaption,   // message box title
    UINT uType,         // message box style
    WORD wLanguageId    // language identifier
    )
{
    int iReturnValue;

    //Add the foreground style
    uType |= MB_SETFOREGROUND;

    iReturnValue = ORIGINAL_API(MessageBoxExA)( 
        hWnd,
        lpText,
        lpCaption,
        uType,
        wLanguageId);

    return iReturnValue;
}

int
APIHOOK(MessageBoxExW)(
    HWND hWnd,          // handle to owner window
    LPCWSTR lpText,     // text in message box
    LPCWSTR lpCaption,  // message box title
    UINT uType,         // message box style
    WORD wLanguageId    // language identifier
    )
{
    int iReturnValue;
    
    //Add the foreground style
    uType |= MB_SETFOREGROUND;
    
    iReturnValue = ORIGINAL_API(MessageBoxExW)( 
        hWnd,
        lpText,
        lpCaption,
        uType,
        wLanguageId);

    
    return iReturnValue;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, MessageBoxA)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxW)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxExA)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\forceshelllinkresolvenoui.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ForceShellLinkResolveNoUI.cpp

 Abstract:

   This shim prevents any sort of UI on the IShellLink::Resolve
   API by NULLing out the passed in HWND if SLR_NO_UI is specified
   in fFlags.

 Notes:

   This is a general purpose shim.

 History:

   04/05/2000 markder  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceShellLinkResolveNoUI)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_ENTRY_COMSERVER(SHELL32)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(SHELL32)

/*++

 This stub function prevents any sort of UI on the IShellLink::Resolve API by 
 NULLing out the passed in HWND if SLR_NO_UI is specified in fFlags.

--*/

HRESULT 
COMHOOK(IShellLinkA, Resolve)( PVOID pThis, HWND hwnd, DWORD fFlags )
{
    HRESULT                  hrReturn        = E_FAIL;
    _pfn_IShellLinkA_Resolve pfnOld;

    pfnOld = (_pfn_IShellLinkA_Resolve) ORIGINAL_COM(IShellLinkA, Resolve, pThis);

    if( fFlags & SLR_NO_UI )
    {
        hwnd = NULL;
    }

    if( pfnOld )
    {
        hrReturn = (*pfnOld)( pThis, hwnd, fFlags );
    }

    return hrReturn;
}

HRESULT 
COMHOOK(IShellLinkW, Resolve)( PVOID pThis, HWND hwnd, DWORD fFlags )
{
    HRESULT                  hrReturn        = E_FAIL;
    _pfn_IShellLinkW_Resolve pfnOld;

    pfnOld = (_pfn_IShellLinkW_Resolve) ORIGINAL_COM(IShellLinkW, Resolve, pThis);

    if( fFlags & SLR_NO_UI )
    {
        hwnd = NULL;
    }

    if( pfnOld )
    {
        hrReturn = (*pfnOld)( pThis, hwnd, fFlags );
    }

    return hrReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY_COMSERVER(SHELL32)

    COMHOOK_ENTRY(ShellLink, IShellLinkA, Resolve, 19)
    COMHOOK_ENTRY(ShellLink, IShellLinkW, Resolve, 19)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\handleapiexceptions.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    HandleAPIExceptions.cpp

 Abstract:

    Handle exceptions thrown by APIs that used to simply fail on Win9x. So far
    we have:

      1. BackupSeek: AVs if hFile == NULL 
      2. CreateEvent passed bad lpEventAttributes and/or lpName
      3. GetFileAttributes 

    Also emulate the win9x behavior for VirtualProtect, whereby the last 
    parameter can be NULL.

    GetTextExtentPoint32 AV's when a large/uninitialized value is passed for
    the string length. This API now emulates Win9x.

    Add sanity checks to pointers in the call to GetMenuItemInfo. This is to match 9x, as
    some apps to pass bogus pointers and it AV on NT.

    When wsprintf receives lpFormat argument as NULL, no AV on 9x.
    But it AV on XP.Shim verifies format string, if it is NULL return the call don't forward
    
 Notes:

    This is a general purpose shim.

 History:

    04/03/2000 linstev  Created
    04/01/2001 linstev  Munged with other exception handling shims
    07/11/2001 prashkud Added handling for GetTextExtentPoint32
    04/24/2002 v-ramora Added handling for wsprintfA

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(HandleAPIExceptions)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(BackupSeek) 
    APIHOOK_ENUM_ENTRY(CreateEventA) 
    APIHOOK_ENUM_ENTRY(CreateEventW) 
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(VirtualProtect) 
    APIHOOK_ENUM_ENTRY(GetTextExtentPoint32A)
    APIHOOK_ENUM_ENTRY(GetMenuItemInfoA)
    APIHOOK_ENUM_ENTRY(wsprintfA) 
APIHOOK_ENUM_END

#define MAX_WIN9X_STRSIZE   8192

/*++

 Stub returns for bad parameters.

--*/

BOOL 
APIHOOK(BackupSeek)(
    HANDLE  hFile,
    DWORD   dwLowBytesToSeek,
    DWORD   dwHighBytesToSeek,
    LPDWORD lpdwLowBytesSeeked,
    LPDWORD lpdwHighBytesSeeked,
    LPVOID *lpContext
    )
{
    if (!hFile) {
        LOGN(
            eDbgLevelError,
            "[BackupSeek] Bad parameter, returning NULL");

        return NULL;
    }

    DWORD dwLowSeeked, dwHighSeeked;

    if (IsBadWritePtr(lpdwLowBytesSeeked, 4)) {
        LOGN(
            eDbgLevelError,
            "[BackupSeek] Bad parameter, fixing");

        lpdwLowBytesSeeked = &dwLowSeeked;
    }

    if (IsBadWritePtr(lpdwHighBytesSeeked, 4)) {
        LOGN(
            eDbgLevelError,
            "[BackupSeek] Bad parameter, fixing");

        lpdwHighBytesSeeked = &dwHighSeeked;
    }
    
    return ORIGINAL_API(BackupSeek)(hFile, dwLowBytesToSeek, dwHighBytesToSeek,
        lpdwLowBytesSeeked, lpdwHighBytesSeeked, lpContext);
}

/*++

 Validate parameters

--*/

HANDLE 
APIHOOK(CreateEventA)(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,  
    BOOL bInitialState, 
    LPCSTR lpName      
    )
{
    if (lpEventAttributes &&
        IsBadReadPtr(lpEventAttributes, sizeof(*lpEventAttributes))) {

        LOGN(
            eDbgLevelError,
            "[CreateEventA] Bad parameter, returning NULL");

        return NULL;
    }

    if (lpName &&
        IsBadStringPtrA(lpName, MAX_PATH)) {

        LOGN(
            eDbgLevelError,
            "[CreateEventA] Bad parameter, returning NULL");
        return NULL;
    }

    return (ORIGINAL_API(CreateEventA)(lpEventAttributes, bManualReset, 
        bInitialState, lpName));
}
 
/*++

 Validate parameters

--*/

HANDLE 
APIHOOK(CreateEventW)(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,  
    BOOL bInitialState, 
    LPCWSTR lpName      
    )
{
    if (lpEventAttributes &&
        IsBadReadPtr(lpEventAttributes, sizeof(*lpEventAttributes))) {

        LOGN(
            eDbgLevelError,
            "[CreateEventW] Bad parameter, returning NULL");

        return NULL;
    }

    if (lpName &&
        IsBadStringPtrW(lpName, MAX_PATH)) {

        LOGN(
            eDbgLevelError,
            "[CreateEventW] Bad parameter, returning NULL");
        return NULL;
    }

    return (ORIGINAL_API(CreateEventW)(lpEventAttributes, bManualReset, 
        bInitialState, lpName));
}

/*++

 This function to emulate Win9x behaviour when getting file attributes.

--*/

DWORD 
APIHOOK(GetFileAttributesA)(
    LPCSTR lpFileName
    )
{
    DWORD dwFileAttributes = INVALID_FILE_ATTRIBUTES;

    if (!IsBadStringPtrA(lpFileName, MAX_PATH)) {
        dwFileAttributes = ORIGINAL_API(GetFileAttributesA)(
                                lpFileName);
    } else {
        LOGN(
            eDbgLevelError,
            "[GetFileAttributesA] Bad parameter - returning INVALID_FILE_ATTRIBUTES.");
    }

    return dwFileAttributes;
}

/*++

 This function is used to emulate Win9x behaviour when getting file attributes.

--*/

DWORD 
APIHOOK(GetFileAttributesW)(
    LPCWSTR lpFileName
    )
{
    DWORD dwFileAttributes = INVALID_FILE_ATTRIBUTES; 

    if (!IsBadStringPtrW(lpFileName, MAX_PATH)) {
        dwFileAttributes = ORIGINAL_API(GetFileAttributesW)(
                                lpFileName);
    } else {
        LOGN(
            eDbgLevelError,
            "[GetFileAttributesW] Bad parameter - returning INVALID_FILE_ATTRIBUTES.");
    }

    return dwFileAttributes;
}

/*++

 Win9x allowed the last parameter to be NULL.

--*/

BOOL
APIHOOK(VirtualProtect)(
    LPVOID lpAddress,     
    SIZE_T dwSize,        
    DWORD flNewProtect,   
    PDWORD lpflOldProtect 
    )
{
    DWORD dwOldProtect = 0;

    if (!lpflOldProtect) {
        //
        // Detected a bad last parameter, fix it.
        //
        LOGN(eDbgLevelError, "[VirtualProtect] Bad parameter - fixing");
        lpflOldProtect = &dwOldProtect;
    }
    
    return ORIGINAL_API(VirtualProtect)(lpAddress, dwSize, flNewProtect, lpflOldProtect);
}

/*++

 Win9x only allows 8192 for the size of the string

--*/

BOOL
APIHOOK(GetTextExtentPoint32A)(
    HDC hdc,
    LPCSTR lpString,
    int cbString,
    LPSIZE lpSize
    )
{
   
    if (cbString > MAX_WIN9X_STRSIZE) {
        //
        // Detected a bad string size, fix it.
        //

        if (!IsBadStringPtrA(lpString, cbString)) {                    
            cbString = strlen(lpString);
            LOGN(eDbgLevelError, "[GetTextExtentPoint32A] Bad parameter - fixing");
        } else {
           LOGN(eDbgLevelError, "[GetTextExtentPoint32A] Bad parameter - returning FALSE");
           return FALSE;
        }
    }

    return ORIGINAL_API(GetTextExtentPoint32A)(hdc, lpString, cbString, lpSize);
}

/*++

 Emulate Win9x bad pointer protection.

--*/

BOOL
APIHOOK(GetMenuItemInfoA)(
    HMENU hMenu,          // handle to menu
    UINT uItem,           // menu item
    BOOL fByPosition,     // meaning of uItem
    LPMENUITEMINFO lpmii  // menu item information
    )
{
    if (IsBadWritePtr(lpmii, sizeof(*lpmii))) {
        LOGN(eDbgLevelInfo, "[GetMenuItemInfoA] invalid lpmii pointer, returning FALSE");
        return FALSE;
    }

    if ((lpmii->fMask & MIIM_STRING || lpmii->fMask & MIIM_TYPE) && (lpmii->cch !=0)) {
        MENUITEMINFO MyMII={0};
        ULONG cch;

        MyMII.cbSize = sizeof(MyMII);
        MyMII.fMask = MIIM_STRING;

        if (ORIGINAL_API(GetMenuItemInfoA)(hMenu, uItem, fByPosition, &MyMII)) {
            cch = min(lpmii->cch, MyMII.cch + 1);

            if (IsBadWritePtr(lpmii->dwTypeData, cch)) {
                LOGN(eDbgLevelInfo, "[GetMenuItemInfoA] invalid pointer for string, clearing it");
                lpmii->dwTypeData = 0;
            }
        } else {
            DPFN(eDbgLevelError, "[GetMenuItemInfoA] Internal call to find string size fail (%08X)", GetLastError());
        }
    }

    return ORIGINAL_API(GetMenuItemInfoA)(hMenu, uItem, fByPosition, lpmii);
}

/*++

 Make sure format string for wsprintfA is not NULL

--*/

//Avoid wvsprintfA deprecated warning/error
#pragma warning(disable : 4995)

int 
APIHOOK(wsprintfA)(
    LPSTR lpOut,
    LPCSTR lpFmt,
    ...)
{
    int iRet = 0;

    //
    //  lpFmt can't be NULL, wvsprintfA  throw AV
    //
    if (lpFmt == NULL) {
        if (!IsBadWritePtr(lpOut, 1)) {
            *lpOut = '\0';
        }
        DPFN( eDbgLevelInfo, "[wsprintfA] received NULL as format string");
        return iRet;
    }

    va_list arglist;

    va_start(arglist, lpFmt);
    iRet = wvsprintfA(lpOut, lpFmt, arglist);
    va_end(arglist);

    return iRet;
}

//Enable back deprecated warning/error
#pragma warning(default : 4995)

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, BackupSeek)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateEventA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateEventW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesW)
    APIHOOK_ENTRY(KERNEL32.DLL, VirtualProtect)
    APIHOOK_ENTRY(GDI32.DLL, GetTextExtentPoint32A)
    APIHOOK_ENTRY(USER32.DLL, GetMenuItemInfoA)
    APIHOOK_ENTRY(USER32.DLL, wsprintfA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\hidedisplaymodes.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RestrictDisplayModes.cpp

 Abstract:

    Restrict the mode list enumerated by EnumDisplaySettings. This shim was 
    built for an application that enumerated only 10 modes and was hoping to 
    find 800x600 in that list. However, other applications that have fixed 
    size buffers for mode tables may also find this shim useful.

 Notes:

    This is a general purpose shim.

 History:

    05/05/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HideDisplayModes)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(EnumDisplaySettingsA)
    APIHOOK_ENUM_ENTRY(EnumDisplaySettingsW)
APIHOOK_ENUM_END

//
// Data needed in mode table
//

typedef struct _MODE
{
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    DWORD dmDisplayFlags;
    DWORD dmDisplayFrequency;
    DWORD dwActualIndex;
    DWORD bIgnore;
} MODE;

// Permanent mode table
MODE* g_pModeTable = NULL;

// Number of entries in the mode table
DWORD g_dwCount = 0;

// Build the mode table on first call
BOOL g_bInit = FALSE;
void BuildModeList(void);

/*++

 Lookup from the sanitized mode table.

--*/

BOOL 
APIHOOK(EnumDisplaySettingsA)(
    LPCSTR     lpszDeviceName,
    DWORD      iModeNum,
    LPDEVMODEA lpDevMode
    )
{
    BuildModeList();
    
    BOOL bRet = FALSE;

    if (lpszDeviceName || ((LONG)iModeNum < 0) || !g_pModeTable) {
        bRet = ORIGINAL_API(EnumDisplaySettingsA)(
                                lpszDeviceName,
                                iModeNum,
                                lpDevMode);
    } else if (iModeNum < g_dwCount) {
        MODE* pmode = g_pModeTable + iModeNum;

        bRet = ORIGINAL_API(EnumDisplaySettingsA)(
                                lpszDeviceName,
                                pmode->dwActualIndex,
                                lpDevMode);

        if (bRet) {
            LOGN(
                eDbgLevelError,
                "[EnumDisplaySettingsA] Returning shorter list of display modes.");
            
            lpDevMode->dmBitsPerPel = pmode->dmBitsPerPel;
            lpDevMode->dmPelsWidth = pmode->dmPelsWidth;
            lpDevMode->dmPelsHeight = pmode->dmPelsHeight;
            lpDevMode->dmDisplayFlags = pmode->dmDisplayFlags;
            lpDevMode->dmDisplayFrequency = pmode->dmDisplayFrequency;
        }
    }

    return bRet;
}

/*++

 Lookup from the sanitized mode table.

--*/

BOOL 
APIHOOK(EnumDisplaySettingsW)(
    LPCWSTR    lpszDeviceName,
    DWORD      iModeNum,
    LPDEVMODEW lpDevMode
    )
{
    BuildModeList();
    
    BOOL bRet = FALSE;

    if (lpszDeviceName || ((LONG)iModeNum < 0) || !g_pModeTable) {
        bRet = ORIGINAL_API(EnumDisplaySettingsW)(
                                lpszDeviceName,
                                iModeNum,
                                lpDevMode);
    } else if (iModeNum < g_dwCount) {
        MODE* pmode = g_pModeTable + iModeNum;

        bRet = ORIGINAL_API(EnumDisplaySettingsW)(
                                lpszDeviceName,
                                pmode->dwActualIndex,
                                lpDevMode);

        if (bRet) {
            LOGN(
                eDbgLevelError,
                "[EnumDisplaySettingsW] Returning shorter list of display modes.");
            
            lpDevMode->dmBitsPerPel = pmode->dmBitsPerPel;
            lpDevMode->dmPelsWidth = pmode->dmPelsWidth;
            lpDevMode->dmPelsHeight = pmode->dmPelsHeight;
            lpDevMode->dmDisplayFlags = pmode->dmDisplayFlags;
            lpDevMode->dmDisplayFrequency = pmode->dmDisplayFrequency;
        }
    }

    return bRet;
}

/*++

 Sort the table by Width+Height+BitsPerPel+Frequency in that order so that 
 they can be easily filtered.

--*/

int 
_cdecl
compare1(
    const void* a1,
    const void* a2
    )
{
    MODE* arg1 = (MODE*)a1;
    MODE* arg2 = (MODE*)a2;

    int d;

    d = arg1->dmPelsWidth - arg2->dmPelsWidth;

    if (d == 0) {
        d = arg1->dmPelsHeight - arg2->dmPelsHeight;
    }

    if (d == 0) {
        d = arg1->dmBitsPerPel - arg2->dmBitsPerPel;
    }

    if (d == 0) {
        d = arg1->dmDisplayFrequency - arg2->dmDisplayFrequency;
    }

    return d;
}

/*++

 Sort the table so it looks like a Win9x mode table, i.e. BitsPerPel is the
 primary sort key.

--*/

int 
_cdecl
compare2(
    const void* a1,
    const void* a2
    )
{
    MODE* arg1 = (MODE*)a1;
    MODE* arg2 = (MODE*)a2;

    int d;

    d = arg1->dmBitsPerPel - arg2->dmBitsPerPel;

    if (d == 0) {
        d = arg1->dmPelsWidth - arg2->dmPelsWidth;
    }

    if (d == 0) {
        d = arg1->dmPelsHeight - arg2->dmPelsHeight;
    }

    if (d == 0) {
        d = arg1->dmDisplayFrequency - arg2->dmDisplayFrequency;
    }

    return d;
}

/*++

 Create a new mode table based upon the sanitized existing table. To do this, 
 we do the following:
 
    1. Get the entire table
    2. Sort it - to allow efficient removal of duplicates
    3. Remove duplicates and unwanted modes
    4. Build a new table with only the modes that 'pass'

--*/

void
BuildModeList(
    void
    )
{
    if (g_bInit) {
        return;
    }

    DEVMODEA dm;
    ULONG    i, j;
    
    dm.dmSize = sizeof(DEVMODEA);

    //
    // Figure out how many modes there are.
    //

    i = 0;
    
    while (EnumDisplaySettingsA(NULL, i, &dm)) {
        i++;
    }

    //
    // Allocate the full mode table.
    //
    MODE* pTempTable = (MODE*)malloc(sizeof(MODE) * i);
    
    if (!pTempTable) {
        LOGN(
            eDbgLevelError,
            "[BuildModeList] Failed to allocate %d bytes.",
            sizeof(MODE) * i);
        
        return;
    }

    MODE* pmode = pTempTable;

    //
    // Get all the modes.
    //
    i = 0;
    
    while (EnumDisplaySettingsA(NULL, i, &dm)) {
        pmode->dmBitsPerPel       = dm.dmBitsPerPel;
        pmode->dmPelsWidth        = dm.dmPelsWidth;
        pmode->dmPelsHeight       = dm.dmPelsHeight;
        pmode->dmDisplayFlags     = dm.dmDisplayFlags;
        pmode->dmDisplayFrequency = 0; // dm.dmDisplayFrequency;
        pmode->dwActualIndex      = i;
        pmode->bIgnore            = FALSE;

        pmode++;
        i++;
    }
    
    //
    // Sort the full table so we can remove duplicates easily.
    //
    qsort((void*)pTempTable, (size_t)i, sizeof(MODE), compare1);

    //
    // Strip away bad modes by setting them as ignored.
    //
    pmode = pTempTable;
    
    MODE* pprev = NULL;

    for (j = 0; j < i; j++) {
        if ((pmode->dmBitsPerPel < 8) || 
            (pmode->dmPelsWidth < 640) ||
            (pmode->dmPelsHeight < 480) ||
            (pmode->dmPelsWidth > 1280) || 
            (pprev &&
            (pprev->dmBitsPerPel == pmode->dmBitsPerPel) &&
            (pprev->dmPelsWidth == pmode->dmPelsWidth) &&
            (pprev->dmPelsHeight == pmode->dmPelsHeight))) {
            
            //
            // Special-case 640x480x4bit.
            //
            if ((pmode->dmBitsPerPel == 4) && 
                (pmode->dmPelsWidth == 640) &&
                (pmode->dmPelsHeight == 480)) {
                
                g_dwCount++;
            } else {
                pmode->bIgnore = TRUE;
            }
        } else {
            g_dwCount++;
        }

        pprev = pmode;
        pmode++;
        
    }

    //
    // Build the new table with only the modes that passed.
    //
    g_pModeTable = (MODE*)malloc(sizeof(MODE) * g_dwCount);
    
    if (!g_pModeTable) {
        LOGN(
            eDbgLevelError,
            "[BuildModeList] Failed to allocate %d bytes.",
            sizeof(MODE) * g_dwCount);
        
        free(pTempTable);
        return;
    }

    MODE* pmoden = g_pModeTable;
    
    pmode = pTempTable;

    for (j = 0; j < i; j++) {
        if (!pmode->bIgnore) {
            MoveMemory(pmoden, pmode, sizeof(MODE));
            pmoden++;
        }
        pmode++;
    }

    //
    // Sort the full table so we can remove duplicates easily.
    //
    qsort((void*)g_pModeTable, (size_t)g_dwCount, sizeof(MODE), compare2);

    free(pTempTable);

    g_bInit = TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, EnumDisplaySettingsA)
    APIHOOK_ENTRY(USER32.DLL, EnumDisplaySettingsW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\handlewvsprintfexceptions.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   HandleWvsprintfExceptions.cpp

 Abstract:

   This fix provides a facility to fix argument list from LPSTR into va_list.

   Some native Win9x app use LPSTR (pointer of string) instead of 
   va_list (pointer to pointer of string). 
   Without properly checking the return value, these apps assume that it is safe
   to use wvsprintf like that because it doesn't cause AV.
   In NT, this will cause AV.

   This shim takes one command line: "arglistfix" (case insensitive).
   By default - if there is no command line - it will do exactly
   what Win9x's wvsprintfA has : 
   Do nothing inside the exception handler if there is an exception occurs.
   If arglistfix specified in command line, it will try to fix the argument
   list (va_list).

 History:

    09/29/2000  andyseti    Created
    11/28/2000  jdoherty    Converted to framework version 2
    03/15/2001  robkenny    Converted to CString

--*/

#include "precomp.h"


int   g_iWorkMode = 0;

enum
{
    WIN9X_MODE = 0,
    ARGLISTFIX_MODE
} TEST;

IMPLEMENT_SHIM_BEGIN(HandleWvsprintfExceptions)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(wvsprintfA) 
APIHOOK_ENUM_END

int Fix_wvsprintf_ArgList(
    LPSTR lpOut,
    LPCSTR lpFmt,
    ...)
{
    int iRet;

    va_list argptr;
    va_start( argptr, lpFmt );

    iRet = ORIGINAL_API(wvsprintfA)(
        lpOut,                         
        lpFmt,                     
        argptr);

    va_end( argptr );
    return iRet;
}

int 
APIHOOK(wvsprintfA)(
    LPSTR lpOut,
    LPCSTR lpFmt,
    va_list arglist)
{
    int iRet = 0;

    __try {
        iRet = ORIGINAL_API(wvsprintfA)(
                lpOut,                         
                lpFmt,                     
                arglist);
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {
        
        if (g_iWorkMode == ARGLISTFIX_MODE)
        {
            DPFN( eDbgLevelInfo,
                "Exception occurs in wvsprintfA. \narglist contains pointer to string: %s.\n" , arglist);
            iRet = Fix_wvsprintf_ArgList(lpOut,lpFmt,arglist);
        }
        else
        {
            // Copied from Win9x's wvsprintfA
            __try {
                // tie off the output
                *lpOut = 0;
            } 
            
            __except( EXCEPTION_EXECUTE_HANDLER) {
                // Do nothing
            }

            iRet = 0;
        }

    }

    return iRet;
}

    
void ParseCommandLine()
{
    CString csCmdLine(COMMAND_LINE);

    if (csCmdLine.CompareNoCase(L"arglistfix") == 0)
    {
        DPFN( eDbgLevelInfo,
            "HandleWvsprintfExceptions called with argument: %S.\n", csCmdLine.Get());
        DPFN( eDbgLevelInfo,
            "HandleWvsprintfExceptions mode: Argument List Fix.\n");
        g_iWorkMode = ARGLISTFIX_MODE;
    }
    else
    {
        DPFN( eDbgLevelInfo,
            "HandleWvsprintfExceptions called with no argument.\n");
        DPFN( eDbgLevelInfo,
            "HandleWvsprintfExceptions mode: Win9x.\n");
        g_iWorkMode = WIN9X_MODE;
    }
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.

 IMPORTANT: Make sure you ONLY call NTDLL, KERNEL32 and MSVCRT APIs during
 DLL_PROCESS_ATTACH notification. No other DLLs are initialized at that
 point.
 
--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DPFN( eDbgLevelInfo, "HandleWvsprintfExceptions initialized.");
        ParseCommandLine();
    } 
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, wvsprintfA)
    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\forcekeepfocus.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceKeepFocus.cpp

 Abstract:

    Some applications destroy windows that are topmost. In this case, focus 
    falls to the next topmost window. Of course, that window might be a window
    from another application. If that is that case, then the app will 
    unexpectedly lose focus.

    The fix is to make sure that another app window has focus before we destroy
    the top one.

    An additional fix is included in this shim: after a window is created, we
    send a WM_TIMECHANGE message because Star Trek Generations blocked it's thread
    waiting for a message. On Win9x a WM_COMMAND comes through, but I haven't been
    able to repro this on other applications.

 Notes:

    This is a general purpose shim.

 History:

    06/09/2000 linstev     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceKeepFocus)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateWindowExA)
    APIHOOK_ENUM_ENTRY(CreateWindowExW)
    APIHOOK_ENUM_ENTRY(CreateDialogParamA)
    APIHOOK_ENUM_ENTRY(CreateDialogParamW)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamW)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamAorW)
    APIHOOK_ENUM_ENTRY(DestroyWindow)    
APIHOOK_ENUM_END

//
// List of all app windows
//

struct HWNDITEM
{
    HWND hWndParent;
    HWND hWnd;
    HWNDITEM *next;
};
HWNDITEM *g_hWndList = NULL;

//
// Critical section for list access
//

CRITICAL_SECTION g_csList;

/*++

 Add a window to our list.

--*/

void
AddItem(
    HWND hWndParent,
    HWND hWnd
    )
{
    if (IsWindow(hWnd) && IsWindowVisible(hWndParent))
    {
        EnterCriticalSection(&g_csList);

        HWNDITEM *hitem = (HWNDITEM *) malloc(sizeof(HWNDITEM));

        if (hitem)
        {
            hitem->hWndParent = hWndParent;
            hitem->hWnd = hWnd;
            hitem->next = g_hWndList;
            g_hWndList = hitem;
            
            DPFN( eDbgLevelInfo, "Adding window %08lx with parent %08lx", 
                hWnd, 
                hWndParent);
        }
        else
        {
            DPFN( eDbgLevelError, "Failed to allocate list item");
        }

        LeaveCriticalSection(&g_csList);
    }

    //
    // Some apps get stuck waiting for a message: not really part of this
    // shim, but shouldn't be harmful
    //
    
    if (IsWindow(hWnd))
    {
        PostMessageA(hWnd, WM_TIMECHANGE, 0, 0);
    }
}

/*++

 Remove a window from the list and return another visible window that will 
 become the next top window.
 
--*/

HWND
RemoveItem(
    HWND hWnd
    )
{
    HWND hRet = NULL;

    EnterCriticalSection(&g_csList);

    //
    // Remove the window and all it's children
    //

    HWNDITEM *hcurr = g_hWndList;
    HWNDITEM *hprev = NULL;

    while (hcurr)
    {
        if ((hcurr->hWndParent == hWnd) ||
            (hcurr->hWnd == hWnd))
        {
            HWNDITEM *hfree;

            DPFN( eDbgLevelInfo, "Removing %08lx", hcurr->hWnd);

            if (hprev)
            {
                hprev->next = hcurr->next;
            }
            else
            {
                g_hWndList = hcurr->next;
            }

            hfree = hcurr;
            hcurr = hcurr->next;
            free(hfree);
            continue;
        }
        hprev = hcurr;
        hcurr = hcurr->next;
    }

    // 
    // Find another window to get focus
    //

    hcurr = g_hWndList;
    while (hcurr)
    {
        if (IsWindowVisible(hcurr->hWnd))
        {
            hRet = hcurr->hWnd;
            break;
        }
        hcurr = hcurr->next;
    }

    if (hRet)
    {
        DPFN( eDbgLevelInfo, "Giving focus to %08lx", hRet);
    }

    LeaveCriticalSection(&g_csList);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,      
    LPCSTR lpClassName,  
    LPCSTR lpWindowName, 
    DWORD dwStyle,       
    int x,               
    int y,               
    int nWidth,          
    int nHeight,         
    HWND hWndParent,     
    HMENU hMenu,         
    HINSTANCE hInstance, 
    LPVOID lpParam       
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,      
        lpWindowName,     
        dwStyle,          
        x,                
        y,                
        nWidth,           
        nHeight,          
        hWndParent,       
        hMenu,            
        hInstance,        
        lpParam);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND 
APIHOOK(CreateWindowExW)(
    DWORD dwExStyle,      
    LPCWSTR lpClassName,  
    LPCWSTR lpWindowName, 
    DWORD dwStyle,        
    int x,                
    int y,                
    int nWidth,           
    int nHeight,          
    HWND hWndParent,      
    HMENU hMenu,          
    HINSTANCE hInstance,  
    LPVOID lpParam        
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateWindowExW)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,     
        x,           
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,     
        hInstance, 
        lpParam);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND
APIHOOK(CreateDialogParamA)(
    HINSTANCE hInstance,     
    LPCSTR lpTemplateName,   
    HWND hWndParent,         
    DLGPROC lpDialogFunc,    
    LPARAM dwInitParam       
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateDialogParamA)(  
        hInstance,
        lpTemplateName,
        hWndParent,
        lpDialogFunc,
        dwInitParam);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND
APIHOOK(CreateDialogParamW)(
    HINSTANCE hInstance,     
    LPCWSTR lpTemplateName,  
    HWND hWndParent,         
    DLGPROC lpDialogFunc,    
    LPARAM dwInitParam       
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateDialogParamW)(  
        hInstance,
        lpTemplateName,
        hWndParent,
        lpDialogFunc,
        dwInitParam);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND
APIHOOK(CreateDialogIndirectParamA)(
    HINSTANCE hInstance,        
    LPCDLGTEMPLATE lpTemplate,  
    HWND hWndParent,            
    DLGPROC lpDialogFunc,       
    LPARAM lParamInit           
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateDialogIndirectParamA)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND
APIHOOK(CreateDialogIndirectParamW)(
    HINSTANCE hInstance,       
    LPCDLGTEMPLATE lpTemplate, 
    HWND hWndParent,           
    DLGPROC lpDialogFunc,      
    LPARAM lParamInit          
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateDialogIndirectParamW)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND
APIHOOK(CreateDialogIndirectParamAorW)(
    HINSTANCE hInstance,        
    LPCDLGTEMPLATE lpTemplate,  
    HWND hWndParent,            
    DLGPROC lpDialogFunc,       
    LPARAM lParamInit           
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateDialogIndirectParamAorW)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Destroy the window and make sure the focus falls to another app window, 
 rather than another app altogether.

--*/

BOOL 
APIHOOK(DestroyWindow)(
    HWND hWnd   
    )
{
    HWND hWndNew = RemoveItem(hWnd);

    if (hWndNew)
    {
        SetForegroundWindow(hWndNew);
    }

    BOOL bRet = ORIGINAL_API(DestroyWindow)(hWnd);

    if (hWndNew)
    {
        SetForegroundWindow(hWndNew);
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        InitializeCriticalSection(&g_csList);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamAorW)
    APIHOOK_ENTRY(USER32.DLL, DestroyWindow)

HOOK_END



IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\handleregexpandszregistrykeys.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   HandleRegExpandSzRegistryKeys.cpp

 Abstract:

   This DLL catches REG_EXPAND_SZ registry keys and converts them to REG_SZ by 
   expanding the embedded environment strings.

 History:

   04/05/2000 markder  Created
   10/30/2000 maonis   Bug fix

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HandleRegExpandSzRegistryKeys)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)
APIHOOK_ENUM_END


/*++

 Expand REG_EXPAND_SZ strings.

--*/

LONG 
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,         // handle to key
    LPCSTR  lpValueName,  // value name
    LPDWORD lpReserved,   // reserved
    LPDWORD lpType,       // dwType buffer
    LPBYTE  lpData,       // data buffer
    LPDWORD lpcbData      // size of data buffer
    )
{
    DWORD dwType;
    LONG  uRet;
    DWORD cbPassedInBuffer = 0, cbExpandedBuffer = 0;
    LPSTR szLocalBuffer = NULL;
    
    if (lpcbData) {
        cbPassedInBuffer = *lpcbData;
        cbExpandedBuffer = *lpcbData;
    }

    uRet = ORIGINAL_API(RegQueryValueExA)(
        hKey, lpValueName, lpReserved, &dwType, lpData, &cbExpandedBuffer);

    if (lpcbData) {
        *lpcbData = cbExpandedBuffer;
    }

    if (lpType) {
        *lpType = dwType;
    }

    if (dwType != REG_EXPAND_SZ) {
        return uRet;
    }

    //
    // The type is REG_EXPAND_SZ. Change to REG_SZ so app doesn't try to expand
    // the string itself.
    //

    if (lpType) {
        *lpType = REG_SZ;
    }

    if ((uRet != ERROR_SUCCESS) && (uRet != ERROR_MORE_DATA)) {
        return uRet;
    }

    LOGN(
        eDbgLevelInfo,
        "[RegQueryValueExA] Caught REG_EXPAND_SZ key: \"%s\".", lpValueName);
    
    //
    // Allocate a local buffer and get the value.
    //
    szLocalBuffer = (LPSTR) malloc(cbExpandedBuffer);
    
    if (!szLocalBuffer) {
        LOGN( eDbgLevelError, "Out of memory.\n");

        // The shim failed, so revert to the original behavior
        *lpType = REG_EXPAND_SZ;
        return uRet;
    }
    
    ORIGINAL_API(RegQueryValueExA)(
        hKey, lpValueName, lpReserved, NULL, (LPBYTE) szLocalBuffer, 
        &cbExpandedBuffer);

    DPFN(
        eDbgLevelInfo,
        "[RegQueryValueExA] Value: \"%s\"", szLocalBuffer);

    //
    // Query for length of expanded string.
    //
    cbExpandedBuffer = ExpandEnvironmentStringsA((LPSTR)szLocalBuffer, NULL, 0);

    if (lpcbData) {
        *lpcbData = cbExpandedBuffer;
    }

    if (lpData != NULL) {
        if (cbExpandedBuffer > cbPassedInBuffer) {
            //
            // Buffer not big enough.
            //
            LOGN(
                eDbgLevelError,
                "[RegQueryValueExA] Buffer too small - Passed in: %d Needed: %d",
                cbPassedInBuffer, cbExpandedBuffer );
            
            free(szLocalBuffer);
            
            //
            // We're pretending the value is already expanded, so to be 
            // consistent, we must fail as if that were the case. If we simply
            // returned uRet here, the app would get inconsistent return 
            // values, e.g. if the buffer is big enough then REG_SZ is returned
            // otherwise REG_EXPAND_SZ is returned - this doesn't make sense. 
            //

            return ERROR_MORE_DATA;
        }

        //
        // If data buffer was passed in (and is big enough), copy the data into it.
        //
        ExpandEnvironmentStringsA(szLocalBuffer, (LPSTR)lpData, cbPassedInBuffer);

        DPFN(
            eDbgLevelInfo,
            "[RegQueryValueExA]              Expanded to: \"%s\"\n",
            lpData);

        uRet = ERROR_SUCCESS;
    }

    free(szLocalBuffer);

    return uRet;
}

/*++

 Expand REG_EXPAND_SZ strings.

--*/

LONG
APIHOOK(RegQueryValueExW)(
    HKEY    hKey,         // handle to key
    LPCWSTR lpValueName,  // value name
    LPDWORD lpReserved,   // reserved
    LPDWORD lpType,       // dwType buffer
    LPBYTE  lpData,       // data buffer
    LPDWORD lpcbData      // size of data buffer
    )
{
    DWORD  dwType;
    LONG   uRet;
    DWORD  cbPassedInBuffer = 0, cbExpandedBuffer = 0;
    LPWSTR szLocalBuffer = NULL;

    if (lpcbData) {
        cbPassedInBuffer = *lpcbData;
        cbExpandedBuffer = *lpcbData;
    }

    uRet = ORIGINAL_API(RegQueryValueExW)(
        hKey, lpValueName, lpReserved, &dwType, lpData, &cbExpandedBuffer);

    if (lpcbData) {
        *lpcbData = cbExpandedBuffer;
    }

    if (lpType) {
        *lpType = dwType;
    }

    if (dwType != REG_EXPAND_SZ) {
        return uRet;
    }

    //
    // The type is REG_EXPAND_SZ. Change to REG_SZ so app doesn't try to expand
    // the string itself.
    //

    if (lpType) {
        *lpType = REG_SZ;
    }

    if ((uRet != ERROR_SUCCESS) && (uRet != ERROR_MORE_DATA)) {
        return uRet;
    }

    LOGN(
        eDbgLevelInfo,
        "[RegQueryValueExW] Caught REG_EXPAND_SZ key: \"%ws\".",
        lpValueName);

    //
    // Allocate a local buffer and get the value.
    //
    szLocalBuffer = (LPWSTR) malloc(cbExpandedBuffer);
    
    if (!szLocalBuffer) {
        LOGN( eDbgLevelError, "Out of memory.\n");

        // The shim failed, so revert to the original behavior
        *lpType = REG_EXPAND_SZ;
        return uRet;
    }

    ORIGINAL_API(RegQueryValueExW)(
        hKey, lpValueName, lpReserved, NULL, (LPBYTE) szLocalBuffer, 
        &cbExpandedBuffer);

    DPFN(
        eDbgLevelInfo,
        "[RegQueryValueExW]                    Value: \"%ws\".\n",
        szLocalBuffer);

    //
    // Query for length of expanded string.
    //
    cbExpandedBuffer = ExpandEnvironmentStringsW((LPWSTR)szLocalBuffer, NULL, 0) * sizeof(WCHAR);

    if (lpcbData) {
        *lpcbData = cbExpandedBuffer;
    }

    if (lpData != NULL) {
        if (cbExpandedBuffer > cbPassedInBuffer) {
            //
            // Buffer not big enough.
            //
            LOGN(
                eDbgLevelInfo,
                "[RegQueryValueExW] Buffer too small - Passed in: %d Needed: %d",
                cbPassedInBuffer, cbExpandedBuffer);
            
            free(szLocalBuffer);
            
            //
            // We're pretending the value is already expanded, so to be 
            // consistent, we must fail as if that were the case. If we simply
            // returned uRet here, the app would get inconsistent return 
            // values, e.g. if the buffer is big enough then REG_SZ is returned
            // otherwise REG_EXPAND_SZ is returned - this doesn't make sense. 
            //
            
            return ERROR_MORE_DATA;
        }

        //
        // If data buffer was passed in (and is big enough), copy the data into it.
        //
        ExpandEnvironmentStringsW(szLocalBuffer, (LPWSTR)lpData, cbPassedInBuffer / sizeof(WCHAR));

        DPFN(
            eDbgLevelInfo,
            "[RegQueryValueExW]              Expanded to: \"%ws\".\n",
            lpData);

        uRet = ERROR_SUCCESS;
    }

    free(szLocalBuffer);

    return uRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\ignoreoleuninitialize.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreOleUninitialize.cpp

 Abstract:

     HTML Editor 8.7 calls ole32!OleUnitialize after the ExitProcess
     in the DllMain of hhctrl.ocx. This worked on Windows 2000
     but does not any more on Whistler.

    This is an general purpose shim.

 History:
 
    01/25/2001 prashkud  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreOleUninitialize)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OleUninitialize)
APIHOOK_ENUM_END


/*++

    This hooks Ole32!OleUninitialize and returns
    immediately as this is being called from 
    DllMain in hhctrl.ocx

--*/

void
APIHOOK(OleUninitialize)()
{
    return;    
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(OLE32.DLL, OleUninitialize)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\ignoreloadlibrary.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreLoadLibrary.cpp

 Abstract:

    This shim allows the user to specified a list of libraries it tries to ignore and 
    optionally the return values of the LoadLibrary call. Some apps try to load libraries
    they don't use but expect the LoadLibrary call to succeed.

    Use ; as the delimeter of the item and optionally use : to specify the return value.
    If you don't specify a return value we'll make the return value NULL.
    Eg:

    video_3dfx.dll;video_3dfx
    helper32.dll:1234;helper.dll

 Notes:
    
    This is a general purpose shim.

 History:

    04/13/2000 a-jamd   Created
    10/11/2000 maonis   Added support for specifying return values and renamed it from 
                        FailLoadLibrary to IgnoreLoadLibrary.
    11/16/2000 linstev  Added SetErrorMode emulation

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreLoadLibrary)
#include "ShimHookMacro.h"

// Globals are zero initialized by default. see c++ spec 3.6.2.
CString *   g_csIgnoreLib;
int         g_csIgnoreLibCount;
DWORD *     g_rgReturnValues;

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
    APIHOOK_ENUM_ENTRY(LoadLibraryExA) 
    APIHOOK_ENUM_ENTRY(LoadLibraryW) 
    APIHOOK_ENUM_ENTRY(LoadLibraryExW) 
APIHOOK_ENUM_END


/*++

 This function parses the COMMAND_LINE for the libraries you wish to ignore.

--*/

BOOL ParseCommandLine(LPCSTR lpszCommandLine)
{
    CSTRING_TRY
    {
        DPF(g_szModuleName, eDbgLevelInfo, "[ParseCommandLine] CommandLine(%s)\n", lpszCommandLine);

        CString csCl(lpszCommandLine);
        CStringParser csParser(csCl, L" ;");
    
        g_csIgnoreLibCount  = csParser.GetCount();
        g_csIgnoreLib       = csParser.ReleaseArgv();
        g_rgReturnValues    = (DWORD *)malloc(sizeof(*g_rgReturnValues) * g_csIgnoreLibCount);
    
        if (g_csIgnoreLibCount && !g_rgReturnValues)
        {
            return FALSE;
        }
    
        // Iterate over all strings looking for a return value
        for (int i = 0; i < g_csIgnoreLibCount; ++i)
        {
            CStringToken csIgnore(g_csIgnoreLib[i], L":");
            CString csLib;
            CString csValue;
            
            csIgnore.GetToken(csLib);
            csIgnore.GetToken(csValue);
            
            if (!csValue.IsEmpty())
            {
                WCHAR *unused;
    
                g_csIgnoreLib[i]    = csLib;   
                g_rgReturnValues[i] = wcstol(csValue, &unused, 10);
            }
            
            DPF(g_szModuleName, eDbgLevelInfo, "[ParseCommandLine] library (%S) return value(%d)\n", g_csIgnoreLib[i].Get(), g_rgReturnValues[i]);
        }

        return TRUE;
    }
    CSTRING_CATCH
    {
        // Do nothing.
    }
    return FALSE;
}


/*++

 These stub functions break into LoadLibrary and check to see if lpLibFileName equals 
 one of the specified dll's.  If so return the specified return value.  If not call LoadLibrary on it.

--*/

HINSTANCE 
APIHOOK(LoadLibraryA)(LPCSTR lpLibFileName)
{
    CSTRING_TRY
    {
        CString csFilePath(lpLibFileName);
        CString csFileName;
        csFilePath.GetLastPathComponent(csFileName);
    
        for (int i = 0; i < g_csIgnoreLibCount; i++)
        {
            if (g_csIgnoreLib[i].CompareNoCase(csFileName) == 0)
            {
                LOG(g_szModuleName,eDbgLevelError, "[LoadLibraryA] Caught attempt loading %s, return %d\n", g_csIgnoreLib[i].Get(), g_rgReturnValues[i]);
                return (HINSTANCE) g_rgReturnValues[i];
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    DPF(g_szModuleName, eDbgLevelSpew, "LoadLibraryA Allow(%s)", lpLibFileName);
    
    UINT uLastMode;
    HINSTANCE hRet;
    uLastMode = SetErrorMode(SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    hRet = ORIGINAL_API(LoadLibraryA)(lpLibFileName);
    
    SetErrorMode(uLastMode);
    return hRet;
}

HINSTANCE 
APIHOOK(LoadLibraryExA)(
    LPCSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )
{
    CSTRING_TRY
    {
        CString csFilePath(lpLibFileName);
        CString csFileName;
        csFilePath.GetLastPathComponent(csFileName);
    
        for (int i = 0; i < g_csIgnoreLibCount; i++)
        {
            if (g_csIgnoreLib[i].CompareNoCase(csFileName) == 0)
            {
                LOG(g_szModuleName,eDbgLevelError, "[LoadLibraryExA] Caught attempt loading %s, return %d\n", g_csIgnoreLib[i].Get(), g_rgReturnValues[i]);
                return (HINSTANCE) g_rgReturnValues[i];
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    DPF(g_szModuleName, eDbgLevelSpew, "LoadLibraryExA Allow(%s)", lpLibFileName);
    
    UINT uLastMode;
    HINSTANCE hRet;
    uLastMode = SetErrorMode(SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    hRet = ORIGINAL_API(LoadLibraryExA)(lpLibFileName, hFile, dwFlags);

    SetErrorMode(uLastMode);
    return hRet;
}

HINSTANCE 
APIHOOK(LoadLibraryW)(LPCWSTR lpLibFileName)
{
    CSTRING_TRY
    {
        CString csFilePath(lpLibFileName);
        CString csFileName;
        csFilePath.GetLastPathComponent(csFileName);
    
        for (int i = 0; i < g_csIgnoreLibCount; i++)
        {
            if (g_csIgnoreLib[i].CompareNoCase(csFileName) == 0)
            {
                LOG(g_szModuleName,eDbgLevelError, "[LoadLibraryW] Caught attempt loading %s, return %d\n", g_csIgnoreLib[i].Get(), g_rgReturnValues[i]);
                return (HINSTANCE) g_rgReturnValues[i];
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    DPF(g_szModuleName, eDbgLevelSpew,"LoadLibraryW Allow(%S)", lpLibFileName);
    
    UINT uLastMode;
    HINSTANCE hRet;
    uLastMode = SetErrorMode(SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    hRet = ORIGINAL_API(LoadLibraryW)(lpLibFileName);

    SetErrorMode(uLastMode);
    return hRet;
}

HINSTANCE 
APIHOOK(LoadLibraryExW)(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )
{
    CSTRING_TRY
    {
        CString csFilePath(lpLibFileName);
        CString csFileName;
        csFilePath.GetLastPathComponent(csFileName);
    
        for (int i = 0; i < g_csIgnoreLibCount; i++)
        {
            if (g_csIgnoreLib[i].CompareNoCase(csFileName) == 0)
            {
                LOG(g_szModuleName,eDbgLevelError, "[LoadLibraryExW] Caught attempt loading %s, return %d\n", g_csIgnoreLib[i].Get(), g_rgReturnValues[i]);
                return (HINSTANCE) g_rgReturnValues[i];
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    DPF(g_szModuleName, eDbgLevelSpew,"APIHook_LoadLibraryExW Allow(%S)", lpLibFileName);
    
    UINT uLastMode;
    HINSTANCE hRet;
    uLastMode = SetErrorMode(SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    hRet = ORIGINAL_API(LoadLibraryExW)(lpLibFileName, hFile, dwFlags);

    SetErrorMode(uLastMode);
    return hRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        ParseCommandLine(COMMAND_LINE);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryExA)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryW)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryExW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\ignoreexception_86dis.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    86dis.cpp

 Abstract:

    Used to find out how long (in bytes) an instruction is: X86 only

 Notes:

    This is largely undocumented since it's based entirely on the original 
    implementation by Gerd Immeyer.

 History:

    10/19/1989 Gerd Immeyer  Original version
    01/09/2000 linstev       Dumbed down for a shim

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreException)
#include "ShimHookMacro.h"

#ifdef _X86_

#pragma pack(1)

#define BIT20(b)            (b & 0x07)
#define BIT53(b)            (b >> 3 & 0x07)
#define BIT76(b)            (b >> 6 & 0x03)

#define MRM                 0x40
#define COM                 0x80
#define END                 0xc0
#define SECTAB_OFFSET_1     256
#define SECTAB_OFFSET_2     236
#define SECTAB_OFFSET_3     227
#define SECTAB_OFFSET_4     215
#define SECTAB_OFFSET_5     199
#define SECTAB_OFFSET_UNDEF 260

#define O_DoDB              0
#define O_NoOperands        0
#define O_NoOpAlt5          O_NoOperands+1
#define O_NoOpAlt4          O_NoOpAlt5+2
#define O_NoOpAlt3          O_NoOpAlt4+2
#define O_NoOpAlt1          O_NoOpAlt3+2
#define O_NoOpAlt0          O_NoOpAlt1+2
#define O_NoOpStrSI         O_NoOpAlt0+2
#define O_NoOpStrDI         O_NoOpStrSI+2
#define O_NoOpStrSIDI       O_NoOpStrDI+2
#define O_bModrm_Reg        O_NoOpStrSIDI+2
#define O_vModrm_Reg        O_bModrm_Reg+3
#define O_Modrm_Reg         O_vModrm_Reg+3
#define O_bReg_Modrm        O_Modrm_Reg+3
#define O_fReg_Modrm        O_bReg_Modrm+3
#define O_Reg_Modrm         O_fReg_Modrm+3
#define O_AL_Ib             O_Reg_Modrm+3
#define O_AX_Iv             O_AL_Ib+2
#define O_sReg2             O_AX_Iv+2
#define O_oReg              O_sReg2+1
#define O_DoBound           O_oReg+1
#define O_Iv                O_DoBound+3
#define O_wModrm_Reg        O_Iv+1
#define O_Ib                O_wModrm_Reg+3
#define O_Imulb             O_Ib+1
#define O_Imul              O_Imulb+4
#define O_Rel8              O_Imul+4
#define O_bModrm_Ib         O_Rel8+1
#define O_Modrm_Ib          O_bModrm_Ib+3
#define O_Modrm_Iv          O_Modrm_Ib+3
#define O_Modrm_sReg3       O_Modrm_Iv+3
#define O_sReg3_Modrm       O_Modrm_sReg3+3
#define O_Modrm             O_sReg3_Modrm+3
#define O_FarPtr            O_Modrm+2
#define O_AL_Offs           O_FarPtr+1
#define O_Offs_AL           O_AL_Offs+2
#define O_AX_Offs           O_Offs_AL+2
#define O_Offs_AX           O_AX_Offs+2
#define O_oReg_Ib           O_Offs_AX+2
#define O_oReg_Iv           O_oReg_Ib+2
#define O_Iw                O_oReg_Iv+2
#define O_Enter             O_Iw+1
#define O_Ubyte_AL          O_Enter+2
#define O_Ubyte_AX          O_Ubyte_AL+2
#define O_AL_Ubyte          O_Ubyte_AX+2
#define O_AX_Ubyte          O_AL_Ubyte+2
#define O_DoInAL            O_AX_Ubyte+2
#define O_DoInAX            O_DoInAL+3
#define O_DoOutAL           O_DoInAX+3
#define O_DoOutAX           O_DoOutAL+3
#define O_Rel16             O_DoOutAX+3
#define O_ADR_OVERRIDE      O_Rel16+1
#define O_OPR_OVERRIDE      O_ADR_OVERRIDE+1
#define O_SEG_OVERRIDE      O_OPR_OVERRIDE+1
#define O_DoInt3            O_SEG_OVERRIDE+1
#define O_DoInt             117
#define O_OPC0F             O_DoInt+1
#define O_GROUP11           O_OPC0F+1
#define O_GROUP13           O_GROUP11+5
#define O_GROUP12           O_GROUP13+5
#define O_GROUP21           O_GROUP12+5
#define O_GROUP22           O_GROUP21+5
#define O_GROUP23           O_GROUP22+5
#define O_GROUP24           O_GROUP23+6
#define O_GROUP25           O_GROUP24+6
#define O_GROUP26           O_GROUP25+6
#define O_GROUP4            O_GROUP26+6
#define O_GROUP6            O_GROUP4+4
#define O_GROUP8            O_GROUP6+4
#define O_GROUP31           O_GROUP8+5
#define O_GROUP32           O_GROUP31+3
#define O_GROUP5            O_GROUP32+3
#define O_GROUP7            O_GROUP5+3
#define O_x87_ESC           O_GROUP7+3
#define O_bModrm            O_x87_ESC+2
#define O_wModrm            O_bModrm+2
#define O_dModrm            O_wModrm+2
#define O_fModrm            O_dModrm+2
#define O_vModrm            O_fModrm+2
#define O_vModrm_Iv         O_vModrm+2
#define O_Reg_bModrm        O_vModrm_Iv+3
#define O_Reg_wModrm        O_Reg_bModrm+3
#define O_Modrm_Reg_Ib      O_Reg_wModrm+3
#define O_Modrm_Reg_CL      O_Modrm_Reg_Ib+4
#define O_ST_iST            O_Modrm_Reg_CL+5
#define O_iST               O_ST_iST+2
#define O_iST_ST            O_iST+2
#define O_qModrm            O_iST_ST+2
#define O_tModrm            O_qModrm+2
#define O_DoRep             O_tModrm+2
#define O_Modrm_CReg        O_DoRep+1
#define O_CReg_Modrm        O_Modrm_CReg+3
#define O_AX_oReg           O_CReg_Modrm+3
#define O_MmReg_qModrm      O_AX_oReg+2
#define O_qModrm_MmReg      O_MmReg_qModrm+3
#define O_MmReg_dModrm      O_qModrm_MmReg+3
#define O_dModrm_MmReg      O_MmReg_dModrm+3
#define O_qModrm_Ib         O_dModrm_MmReg+3
#define O_PSHimw            O_qModrm_Ib+3
#define O_PSHimd            O_PSHimw+5
#define O_PSHimq            O_PSHimd+5
#define O_length            O_PSHimq+5

typedef unsigned short ActionIndex;

typedef struct Tdistbl
{
    ActionIndex opr;
} Tdistbl;

typedef struct _ADDR 
{
    USHORT      type;
    USHORT      seg;
    ULONG       off;
    union 
    {
        ULONG flat;
        ULONGLONG flat64;
    };
} ADDR, *PADDR;


typedef struct _DECODEDATA
{
  int              mod;            // mod of mod/rm byte 
  int              rm;             // rm of mod/rm byte 
  int              ttt;            // return reg value (of mod/rm) 
  unsigned char    *pMem;          // current position in instruction 
  ADDR             EAaddr[2];      // offset of effective address
  int              EAsize[2];      // size of effective address item
  BOOL             fMovX;          // indicates a MOVSX or MOVZX
  BOOL             fMmRegEa;       // Use mm? registers in reg-only EA.
} DECODEDATA;

enum oprtyp { ADDRP,  ADR_OVR, ALSTR,   ALT,     AXSTR,  BOREG,
              BREG,   BRSTR,   xBYTE,   CHR,     CREG,   xDWORD,
              EDWORD, EGROUPT, FARPTR,  GROUP,   GROUPT, IB,
              IST,    IST_ST,  IV,      IW,      LMODRM, MODRM,
              NOP,    OFFS,    OPC0F,   OPR_OVR, QWORD,  REL16,
              REL8,   REP,     SEG_OVR, SREG2,   SREG3,  ST_IST,
              STROP,  xTBYTE,  UBYTE,   VAR,     VOREG,  VREG,
              xWORD,  WREG,    WRSTR,   MMWREG,  MMQWORD
            };

unsigned char actiontbl[] = {
/* NoOperands  */ NOP+END,
/* NoOpAlt5    */ ALT+END,   5,
/* NoOpAlt4    */ ALT+END,   4,
/* NoOpAlt3    */ ALT+END,   3,
/* NoOpAlt1    */ ALT+END,   1,
/* NoOpAlt0    */ ALT+END,   0,
/* NoOpStrSI   */ STROP+END, 1,
/* NoOpStrDI   */ STROP+END, 2,
/* NoOpStrSIDI */ STROP+END, 3,
/* bModrm_Reg  */ xBYTE+MRM, MODRM+COM,  BREG+END,
/* vModrm_Reg  */ VAR+MRM,   LMODRM+COM, BREG+END,
/* Modrm_Reg   */ VAR+MRM,   MODRM+COM,  VREG+END,
/* bReg_Modrm  */ xBYTE+MRM, BREG+COM,   MODRM+END,
/* fReg_Modrm  */ FARPTR+MRM,VREG+COM,   MODRM+END,
/* Reg_Modrm   */ VAR+MRM,   VREG+COM,   MODRM+END,
/* AL_Ib       */ ALSTR+COM, IB+END,
/* AX_Iv       */ AXSTR+COM, IV+END,
/* sReg2       */ SREG2+END,
/* oReg        */ VOREG+END,
/* DoBound     */ VAR+MRM,   VREG+COM,   MODRM+END,
/* Iv          */ IV+END,
/* wModrm_Reg  */ xWORD+MRM, LMODRM+COM, WREG+END,
/* Ib          */ IB+END,
/* Imulb       */ VAR+MRM,   VREG+COM,   MODRM+COM, IB+END,
/* Imul        */ VAR+MRM,   VREG+COM,   MODRM+COM, IV+END,
/* REL8        */ REL8+END,
/* bModrm_Ib   */ xBYTE+MRM, LMODRM+COM, IB+END,
/* Modrm_Ib    */ VAR+MRM,   LMODRM+COM, IB+END,
/* Modrm_Iv    */ VAR+MRM,   LMODRM+COM, IV+END,
/* Modrm_sReg3 */ xWORD+MRM, MODRM+COM,  SREG3+END,
/* sReg3_Modrm */ xWORD+MRM, SREG3+COM,  MODRM+END,
/* Modrm       */ VAR+MRM,   MODRM+END,
/* FarPtr      */ ADDRP+END,
/* AL_Offs     */ ALSTR+COM, OFFS+END,
/* Offs_AL     */ OFFS+COM,  ALSTR+END,
/* AX_Offs     */ AXSTR+COM, OFFS+END,
/* Offs_AX     */ OFFS+COM,  AXSTR+END,
/* oReg_Ib     */ BOREG+COM, IB+END,
/* oReg_Iv     */ VOREG+COM, IV+END,
/* Iw          */ IW+END,
/* enter       */ IW+COM,    IB+END,
/* Ubyte_AL    */ UBYTE+COM, ALSTR+END,
/* Ubyte_AX    */ UBYTE+COM, AXSTR+END,
/* AL_Ubyte    */ ALSTR+COM, UBYTE+END,
/* AX_Ubyte    */ AXSTR+COM, UBYTE+END,
/* DoInAL      */ ALSTR+COM, WRSTR+END,  2,
/* DoInAX      */ AXSTR+COM, WRSTR+END,  2,
/* DoOutAL     */ WRSTR+COM, 2,          ALSTR+END,
/* DoOutAX     */ WRSTR+COM, 2,          AXSTR+END,
/* REL16       */ REL16+END,
/* ADR_OVERRIDE*/ ADR_OVR,
/* OPR_OVERRIDE*/ OPR_OVR,
/* SEG_OVERRIDE*/ SEG_OVR,
/* DoInt3      */ CHR+END,   '3',
/* DoInt       */ UBYTE+END,
/* Opcode0F    */ OPC0F,
/* group1_1    */ xBYTE+MRM, GROUP,      0,         LMODRM+COM, IB+END,
/* group1_3    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IB+END,
/* group1_2    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IV+END,
/* group2_1    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, IB+END,
/* group2_2    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, IB+END,
/* group2_3    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_4    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_5    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group2_6    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group4      */ xBYTE+MRM, GROUP,      2,         LMODRM+END,
/* group6      */ xWORD+MRM, GROUP,      3,         LMODRM+END,
/* group8      */ xWORD+MRM, GROUP,      4,         LMODRM+COM, IB+END,
/* group3_1    */ xBYTE+MRM, GROUPT,     20,
/* group3_2    */ VAR+MRM,   GROUPT,     21,
/* group5      */ VAR+MRM,   GROUPT,     22,
/* group7      */ NOP+MRM,   GROUPT,     23,
/* x87_ESC     */ NOP+MRM,   EGROUPT,
/* bModrm      */ xBYTE+MRM, LMODRM+END,
/* wModrm      */ xWORD+MRM, LMODRM+END,
/* dModrm      */ xDWORD+MRM,LMODRM+END,
/* fModrm      */ FARPTR+MRM,LMODRM+END,
/* vModrm      */ VAR+MRM,   LMODRM+END,
/* vModrm_Iv   */ VAR+MRM,   LMODRM+COM, IV+END,
/* reg_bModrm  */ xBYTE+MRM, VREG+COM,   LMODRM+END,
/* reg_wModrm  */ xWORD+MRM, VREG+COM,   LMODRM+END,
/* Modrm_Reg_Ib*/ VAR+MRM,   MODRM+COM,  VREG+COM,   IB+END,
/* Modrm_Reg_CL*/ VAR+MRM,   MODRM+COM,  VREG+COM,   BRSTR+END, 1,
/* ST_iST      */ NOP+MRM,   ST_IST+END,
/* iST         */ NOP+MRM,   IST+END,
/* iST_ST      */ NOP+MRM,   IST_ST+END,
/* qModrm      */ QWORD+MRM, LMODRM+END,
/* tModrm      */ xTBYTE+MRM, LMODRM+END,
/* REP         */ REP,
/* Modrm_CReg  */ EDWORD+MRM,MODRM+COM,  CREG+END,
/* CReg_Modrm  */ EDWORD+MRM,CREG+COM,   MODRM+END,
/* AX_oReg     */ AXSTR+COM, VOREG+END,
/* MmReg_qModrm*/ MMQWORD+MRM, MMWREG+COM, LMODRM+END,
/* qModrm_MmReg*/ MMQWORD+MRM, MODRM+COM,  MMWREG+END,
/* MmReg_dModrm*/ xDWORD+MRM, MMWREG+COM,LMODRM+END,
/* dModrm_MmReg*/ xDWORD+MRM, MODRM+COM, MMWREG+END,
/* qModrm_Ib   */ MMQWORD+MRM, MODRM+COM,IB+END,
/* PSHimw      */ MMQWORD+MRM, GROUP,    5,          LMODRM+COM, IB+END,
/* PSHimd      */ MMQWORD+MRM, GROUP,    6,          LMODRM+COM, IB+END,
/* PSHimq      */ MMQWORD+MRM, GROUP,    7,          LMODRM+COM, IB+END,
};

Tdistbl distbl[] = {
    O_bModrm_Reg,             /* 00 ADD mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 01 ADD mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 02 ADD reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 03 ADD reg, mem/reg (word)    */
    O_AL_Ib,                  /* 04 ADD AL, I                  */
    O_AX_Iv,                  /* 05 ADD AX, I                  */
    O_sReg2,                  /* 06 PUSH ES                    */
    O_sReg2,                  /* 07 POP ES                     */
    O_bModrm_Reg,             /* 08 OR mem/reg, reg (byte)     */
    O_Modrm_Reg,              /* 09 OR mem/reg, reg (word)     */
    O_bReg_Modrm,             /* 0A OR reg, mem/reg (byte)     */
    O_Reg_Modrm,              /* 0B OR reg, mem/reg (word)     */
    O_AL_Ib,                  /* 0C OR AL, I                   */
    O_AX_Iv,                  /* 0D OR AX, I                   */
    O_sReg2,                  /* 0E PUSH CS                    */
    O_OPC0F,                  /* 0F CLTS & protection ctl(286) */
    O_bModrm_Reg,             /* 10 ADC mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 11 ADC mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 12 ADC reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 13 ADC reg, mem/reg (word)    */
    O_AL_Ib,                  /* 14 ADC AL, I                  */
    O_AX_Iv,                  /* 15 ADC AX, I                  */
    O_sReg2,                  /* 16 PUSH SS                    */
    O_sReg2,                  /* 17 POP SS                     */
    O_bModrm_Reg,             /* 18 SBB mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 19 SBB mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 1A SBB reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 1B SBB reg, mem/reg (word)    */
    O_AL_Ib,                  /* 1C SBB AL, I                  */
    O_AX_Iv,                  /* 1D SBB AX, I                  */
    O_sReg2,                  /* 1E PUSH DS                    */
    O_sReg2,                  /* 1F POP DS                     */
    O_bModrm_Reg,             /* 20 AND mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 21 AND mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 22 AND reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 23 AND reg, mem/reg (word)    */
    O_AL_Ib,                  /* 24 AND AL, I                  */
    O_AX_Iv,                  /* 25 AND AX, I                  */
    O_SEG_OVERRIDE,           /* 26 SEG ES:                    */
    O_NoOperands,             /* 27 DAA                        */
    O_bModrm_Reg,             /* 28 SUB mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 29 SUB mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 2A SUB reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 2B SUB reg, mem/reg (word)    */
    O_AL_Ib,                  /* 2C SUB AL, I                  */
    O_AX_Iv,                  /* 2D SUB AX, I                  */
    O_SEG_OVERRIDE,           /* 2E SEG CS:                    */
    O_NoOperands,             /* 2F DAS                        */
    O_bModrm_Reg,             /* 30 XOR mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 31 XOR mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 32 XOR reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 33 XOR reg, mem/reg (word)    */
    O_AL_Ib,                  /* 34 XOR AL, I                  */
    O_AX_Iv,                  /* 35 XOR AX, I                  */
    O_SEG_OVERRIDE,           /* 36 SEG SS:                    */
    O_NoOperands,             /* 37 AAA                        */
    O_bModrm_Reg,             /* 38 CMP mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 39 CMP mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 3A CMP reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 3B CMP reg, mem/reg (word)    */
    O_AL_Ib,                  /* 3C CMP AL, I                  */
    O_AX_Iv,                  /* 3D CMP AX, I                  */
    O_SEG_OVERRIDE,           /* 3E SEG DS:                    */
    O_NoOperands,             /* 3F AAS                        */
    O_oReg,                   /* 40 INC AX                     */
    O_oReg,                   /* 41 INC CX                     */
    O_oReg,                   /* 42 INC DX                     */
    O_oReg,                   /* 43 INC BX                     */
    O_oReg,                   /* 44 INC SP                     */
    O_oReg,                   /* 45 INC BP                     */
    O_oReg,                   /* 46 INC SI                     */
    O_oReg,                   /* 47 INC DI                     */
    O_oReg,                   /* 48 DEC AX                     */
    O_oReg,                   /* 49 DEC CX                     */
    O_oReg,                   /* 4A DEC DX                     */
    O_oReg,                   /* 4B DEC BX                     */
    O_oReg,                   /* 4C DEC SP                     */
    O_oReg,                   /* 4D DEC BP                     */
    O_oReg,                   /* 4E DEC SI                     */
    O_oReg,                   /* 4F DEC DI                     */
    O_oReg,                   /* 50 PUSH AX                    */
    O_oReg,                   /* 51 PUSH CX                    */
    O_oReg,                   /* 52 PUSH DX                    */
    O_oReg,                   /* 53 PUSH BX                    */
    O_oReg,                   /* 54 PUSH SP                    */
    O_oReg,                   /* 55 PUSH BP                    */
    O_oReg,                   /* 56 PUSH SI                    */
    O_oReg,                   /* 57 PUSH DI                    */
    O_oReg,                   /* 58 POP AX                     */
    O_oReg,                   /* 59 POP CX                     */
    O_oReg,                   /* 5A POP DX                     */
    O_oReg,                   /* 5B POP BX                     */
    O_oReg,                   /* 5C POP SP                     */
    O_oReg,                   /* 5D POP BP                     */
    O_oReg,                   /* 5E POP SI                     */
    O_oReg,                   /* 5F POP DI                     */
    O_NoOpAlt5,               /* 60 PUSHA (286) / PUSHAD (386) */
    O_NoOpAlt4,               /* 61 POPA (286) / POPAD (286)   */
    O_DoBound,                /* 62 BOUND reg, Modrm (286)     */
    O_Modrm_Reg,              /* 63 ARPL Modrm, reg (286)      */
    O_SEG_OVERRIDE,           /* 64                            */
    O_SEG_OVERRIDE,           /* 65                            */
    O_OPR_OVERRIDE,           /* 66                            */
    O_ADR_OVERRIDE,           /* 67                            */
    O_Iv,                     /* 68 PUSH word (286)            */
    O_Imul,                   /* 69 IMUL (286)                 */
    O_Ib,                     /* 6A PUSH byte (286)            */
    O_Imulb,                  /* 6B IMUL (286)                 */
    O_NoOperands,             /* 6C INSB (286)                 */
    O_NoOpAlt3,               /* 6D INSW (286) / INSD (386)    */
    O_NoOperands,             /* 6E OUTSB (286)                */
    O_NoOpAlt4,               /* 6F OUTSW (286) / OUTSD (386)  */
    O_Rel8,                   /* 70 JO                         */
    O_Rel8,                   /* 71 JNO                        */
    O_Rel8,                   /* 72 JB or JNAE or JC           */
    O_Rel8,                   /* 73 JNB or JAE or JNC          */
    O_Rel8,                   /* 74 JE or JZ                   */
    O_Rel8,                   /* 75 JNE or JNZ                 */
    O_Rel8,                   /* 76 JBE or JNA                 */
    O_Rel8,                   /* 77 JNBE or JA                 */
    O_Rel8,                   /* 78 JS                         */
    O_Rel8,                   /* 79 JNS                        */
    O_Rel8,                   /* 7A JP or JPE                  */
    O_Rel8,                   /* 7B JNP or JPO                 */
    O_Rel8,                   /* 7C JL or JNGE                 */
    O_Rel8,                   /* 7D JNL or JGE                 */
    O_Rel8,                   /* 7E JLE or JNG                 */
    O_Rel8,                   /* 7F JNLE or JG                 */
    O_GROUP11,                /* 80                            */
    O_GROUP12,                /* 81                            */
    O_DoDB,                   /* 82                            */
    O_GROUP13,                /* 83                            */
    O_bModrm_Reg,             /* 84 TEST reg, mem/reg (byte)   */
    O_Modrm_Reg,              /* 85 TEST reg, mem/reg (word)   */
    O_bModrm_Reg,             /* 86 XCHG reg, mem/reg (byte)   */
    O_Modrm_Reg,              /* 87 XCHG reg, mem/reg (word)   */
    O_bModrm_Reg,             /* 88 MOV mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 89 MOV mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 8A MOV reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 8B MOV reg, mem/reg (word)    */
    O_Modrm_sReg3,            /* 8C MOV mem/reg, segreg        */
    O_Reg_Modrm,              /* 8D LEA reg, mem               */
    O_sReg3_Modrm,            /* 8E MOV segreg, mem/reg        */
    O_Modrm,                  /* 8F POP mem/reg                */
    O_NoOperands,             /* 90 NOP                        */
    O_AX_oReg,                /* 91 XCHG AX,CX                 */
    O_AX_oReg,                /* 92 XCHG AX,DX                 */
    O_AX_oReg,                /* 93 XCHG AX,BX                 */
    O_AX_oReg,                /* 94 XCHG AX,SP                 */
    O_AX_oReg,                /* 95 XCHG AX,BP                 */
    O_AX_oReg,                /* 96 XCHG AX,SI                 */
    O_AX_oReg,                /* 97 XCHG AX,DI                 */
    O_NoOpAlt0,               /* 98 CBW / CWDE (386)           */
    O_NoOpAlt1,               /* 99 CWD / CDQ (386)            */
    O_FarPtr,                 /* 9A CALL seg:off               */
    O_NoOperands,             /* 9B WAIT                       */
    O_NoOpAlt5,               /* 9C PUSHF / PUSHFD (386)       */
    O_NoOpAlt4,               /* 9D POPF / POPFD (386)         */
    O_NoOperands,             /* 9E SAHF                       */
    O_NoOperands,             /* 9F LAHF                       */
    O_AL_Offs,                /* A0 MOV AL, mem                */
    O_AX_Offs,                /* A1 MOV AX, mem                */
    O_Offs_AL,                /* A2 MOV mem, AL                */
    O_Offs_AX,                /* A3 MOV mem, AX                */
    O_NoOpStrSIDI,            /* A4 MOVSB                      */
    O_NoOpStrSIDI,            /* A5 MOVSW / MOVSD (386)        */
    O_NoOpStrSIDI,            /* A6 CMPSB                      */
    O_NoOpStrSIDI,            /* A7 CMPSW / CMPSD (386)        */
    O_AL_Ib,                  /* A8 TEST AL, I                 */
    O_AX_Iv,                  /* A9 TEST AX, I                 */
    O_NoOpStrDI,              /* AA STOSB                      */
    O_NoOpStrDI,              /* AB STOSW / STOSD (386)        */
    O_NoOpStrSI,              /* AC LODSB                      */
    O_NoOpStrSI,              /* AD LODSW / LODSD (386)        */
    O_NoOpStrDI,              /* AE SCASB                      */
    O_NoOpStrDI,              /* AF SCASW / SCASD (386)        */
    O_oReg_Ib,                /* B0 MOV AL, I                  */
    O_oReg_Ib,                /* B1 MOV CL, I                  */
    O_oReg_Ib,                /* B2 MOV DL, I                  */
    O_oReg_Ib,                /* B3 MOV BL, I                  */
    O_oReg_Ib,                /* B4 MOV AH, I                  */
    O_oReg_Ib,                /* B5 MOV CH, I                  */
    O_oReg_Ib,                /* B6 MOV DH, I                  */
    O_oReg_Ib,                /* B7 MOV BH, I                  */
    O_oReg_Iv,                /* B8 MOV AX, I                  */
    O_oReg_Iv,                /* B9 MOV CX, I                  */
    O_oReg_Iv,                /* BA MOV DX, I                  */
    O_oReg_Iv,                /* BB MOV BX, I                  */
    O_oReg_Iv,                /* BC MOV SP, I                  */
    O_oReg_Iv,                /* BD MOV BP, I                  */
    O_oReg_Iv,                /* BE MOV SI, I                  */
    O_oReg_Iv,                /* BF MOV DI, I                  */
    O_GROUP21,                /* C0 shifts & rotates (286)     */
    O_GROUP22,                /* C1 shifts & rotates (286)     */
    O_Iw,                     /* C2 RET Rel16                  */
    O_NoOperands,             /* C3 RET                        */
    O_fReg_Modrm,             /* C4 LES reg, mem               */
    O_fReg_Modrm,             /* C5 LDS reg, mem               */
    O_bModrm_Ib,              /* C6 MOV mem/reg, I(byte)       */
    O_Modrm_Iv,               /* C7 MOV mem/reg, I(word)       */
    O_Enter,                  /* C8 ENTER (286)                */
    O_NoOperands,             /* C9 LEAVE (286)                */
    O_Iw,                     /* CA RETF I(word)               */
    O_NoOperands,             /* CB RETF                       */
    O_DoInt3,                 /* CC INT 3                      */
    O_DoInt,                  /* CD INT                        */
    O_NoOperands,             /* CE INTO                       */
    O_NoOpAlt4,               /* CF IRET / IRETD (386)         */
    O_GROUP23,                /* D0 shifts & rotates,1 (byte)  */
    O_GROUP24,                /* D1 shifts & rotates,1 (word)  */
    O_GROUP25,                /* D2 shifts & rotates,CL (byte) */
    O_GROUP26,                /* D3 shifts & rotates,CL (word) */
    O_Ib,                     /* D4 AAM                        */
    O_Ib,                     /* D5 AAD                        */
    O_DoDB,                   /* D6                            */
    O_NoOperands,             /* D7 XLAT                       */
    O_x87_ESC,                /* D8 ESC                        */
    O_x87_ESC,                /* D9 ESC                        */
    O_x87_ESC,                /* DA ESC                        */
    O_x87_ESC,                /* DB ESC                        */
    O_x87_ESC,                /* DC ESC                        */
    O_x87_ESC,                /* DD ESC                        */
    O_x87_ESC,                /* DE ESC                        */
    O_x87_ESC,                /* DF ESC                        */
    O_Rel8,                   /* E0 LOOPNE or LOOPNZ           */
    O_Rel8,                   /* E1 LOOPE or LOOPZ             */
    O_Rel8,                   /* E2 LOOP                       */
    O_Rel8,                   /* E3 JCXZ / JECXZ (386)         */
    O_AL_Ubyte,               /* E4 IN AL, I                   */
    O_AX_Ubyte,               /* E5 IN AX, I                   */
    O_Ubyte_AL,               /* E6 OUT I, AL                  */
    O_Ubyte_AX,               /* E7 OUT I, AX                  */
    O_Rel16,                  /* E8 CALL Rel16                 */
    O_Rel16,                  /* E9 JMP Rel16                  */
    O_FarPtr,                 /* EA JMP seg:off                */
    O_Rel8,                   /* EB JMP Rel8                   */
    O_DoInAL,                 /* EC IN AL, DX                  */
    O_DoInAX,                 /* ED IN AX, DX                  */
    O_DoOutAL,                /* EE OUT DX, AL                 */
    O_DoOutAX,                /* EF OUT DX, AX                 */
    O_DoRep,                  /* F0 LOCK                       */
    O_DoDB,                   /* F1                            */
    O_DoRep,                  /* F2 REPNE or REPNZ             */
    O_DoRep,                  /* F3 REP or REPE or REPZ        */
    O_NoOperands,             /* F4 HLT                        */
    O_NoOperands,             /* F5 CMC                        */
    O_GROUP31,                /* F6 TEST, NOT, NEG, MUL, IMUL, */
    O_GROUP32,                /* F7 DIv, IDIv F6=Byte F7=Word  */
    O_NoOperands,             /* F8 CLC                        */
    O_NoOperands,             /* F9 STC                        */
    O_NoOperands,             /* FA CLI                        */
    O_NoOperands,             /* FB STI                        */
    O_NoOperands,             /* FC CLD                        */
    O_NoOperands,             /* FD STD                        */
    O_GROUP4,                 /* FE INC, DEC mem/reg (byte)    */
    O_GROUP5,                 /* FF INC, DEC, CALL, JMP, PUSH  */

    // secondary opcode table begins. Only "filled" locations are stored
    // to compress the secondary table. Hence while disassembling
    // opcode needs to be displaced appropriately to account for the.
    // The displacements are defined in 86dis.c and need to be reevaluated
    // if new opcodes are added here.

    O_GROUP6,                 /* 0 MULTI                       */
    O_GROUP7,                 /* 1 MULTI                       */
    O_Reg_Modrm,              /* 2 LAR                         */
    O_Reg_Modrm,              /* 3 LSL                         */
    O_DoDB,                   /* 4                             */
    O_NoOperands,             /* 5 LOADALL                     */
    O_NoOperands,             /* 6 CLTS                        */
    O_GROUP7,                 /* 7 MULTI                       */
    O_NoOperands,             /* 8 INVD                        */
    O_NoOperands,             /* 9 WBINVD                      */
    O_DoDB,                   /* A                             */
    O_NoOperands,             /* B UD2 undefined               */
    O_Modrm_CReg,             /* 20 MOV Rd,Cd                  */
    O_Modrm_CReg,             /* 21 MOV Rd,Dd                  */
    O_CReg_Modrm,             /* 22 MOV Cd,Rd                  */
    O_CReg_Modrm,             /* 23 MOV Dd,Rd                  */
    O_Modrm_CReg,             /* 24 MOV Rd,Td                  */
    O_DoDB,                   /* 25                            */
    O_CReg_Modrm,             /* 26 MOV Td,Rd                  */

    O_NoOperands,             /* 30 WRMSR                      */
    O_NoOperands,             /* 31 RDTSC                      */
    O_NoOperands,             /* 32 RDMSR                      */
    O_NoOperands,             /* 33 RDPMC                      */

    O_Reg_Modrm,              /* 40 CMOVO                      */
    O_Reg_Modrm,              /* 41 CMOVNO                     */
    O_Reg_Modrm,              /* 42 CMOVB                      */
    O_Reg_Modrm,              /* 43 CMOVNB                     */
    O_Reg_Modrm,              /* 44 CMOVE                      */
    O_Reg_Modrm,              /* 45 CMOVNE                     */
    O_Reg_Modrm,              /* 46 CMOVBE                     */
    O_Reg_Modrm,              /* 47 CMOVNBE                    */
    O_Reg_Modrm,              /* 48 CMOVS                      */
    O_Reg_Modrm,              /* 49 CMOVNS                     */
    O_Reg_Modrm,              /* 4A CMOVP                      */
    O_Reg_Modrm,              /* 4B CMOVNP                     */
    O_Reg_Modrm,              /* 4C CMOVL                      */
    O_Reg_Modrm,              /* 4D CMOVGE                     */
    O_Reg_Modrm,              /* 4E CMOVLE                     */
    O_Reg_Modrm,              /* 4F CMOVNLE                    */ 

    O_MmReg_qModrm,           /* 60 PUNPCKLBW                  */
    O_MmReg_qModrm,           /* 61 PUNPCKLWD                  */
    O_MmReg_qModrm,           /* 62 PUNPCKLDQ                  */
    O_MmReg_qModrm,           /* 63 PACKSSWB                   */
    O_MmReg_qModrm,           /* 64 PCMPGTB                    */
    O_MmReg_qModrm,           /* 65 PCMPGTW                    */
    O_MmReg_qModrm,           /* 66 PCMPGTD                    */
    O_MmReg_qModrm,           /* 67 PACKUSWB                   */
    O_MmReg_qModrm,           /* 68 PUNPCKHBW                  */
    O_MmReg_qModrm,           /* 69 PUNPCKHWD                  */
    O_MmReg_qModrm,           /* 6A PUNPCKHDQ                  */
    O_MmReg_qModrm,           /* 6B PACKSSDW                   */
    O_DoDB,                   /* 6C                            */
    O_DoDB,                   /* 6D                            */
    O_MmReg_dModrm,           /* 6E MOVD                       */
    O_MmReg_qModrm,           /* 6F MOVQ                       */
    O_DoDB,                   /* 70                            */
    O_PSHimw,                 /* 71 PS[LR][AL]W immediate      */
    O_PSHimd,                 /* 72 PS[LR][AL]D immediate      */
    O_PSHimq,                 /* 73 PS[LR]LQ immediate         */
    O_MmReg_qModrm,           /* 74 PCMPEQB                    */
    O_MmReg_qModrm,           /* 75 PCMPEQW                    */
    O_MmReg_qModrm,           /* 76 PCMPEQD                    */
    O_NoOperands,             /* 77 EMMS                       */
    O_DoDB,                   /* 78                            */
    O_DoDB,                   /* 79                            */
    O_DoDB,                   /* 7A                            */
    O_DoDB,                   /* 7B                            */
    O_DoDB,                   /* 7C                            */
    O_bModrm,                 /* 7D SETNL                      */
    O_dModrm_MmReg,           /* 7E MOVD                       */
    O_qModrm_MmReg,           /* 7F MOVQ                       */
    O_Rel16,                  /* 80 JO                         */
    O_Rel16,                  /* 81 JNO                        */
    O_Rel16,                  /* 82 JB                         */
    O_Rel16,                  /* 83 JNB                        */
    O_Rel16,                  /* 84 JE                         */
    O_Rel16,                  /* 85 JNE                        */
    O_Rel16,                  /* 86 JBE                        */
    O_Rel16,                  /* 87 JNBE                       */
    O_Rel16,                  /* 88 JS                         */
    O_Rel16,                  /* 89 JNS                        */
    O_Rel16,                  /* 8A JP                         */
    O_Rel16,                  /* 8B JNP                        */
    O_Rel16,                  /* 8C JL                         */
    O_Rel16,                  /* 8D JNL                        */
    O_Rel16,                  /* 8E JLE                        */
    O_Rel16,                  /* 8F JNLE                       */
    O_bModrm,                 /* 90 SETO                       */
    O_bModrm,                 /* 91 SETNO                      */
    O_bModrm,                 /* 92 SETB                       */
    O_bModrm,                 /* 93 SETNB                      */
    O_bModrm,                 /* 94 SETE                       */
    O_bModrm,                 /* 95 SETNE                      */
    O_bModrm,                 /* 96 SETBE                      */
    O_bModrm,                 /* 97 SETNBE                     */
    O_bModrm,                 /* 98 SETS                       */
    O_bModrm,                 /* 99 SETNS                      */
    O_bModrm,                 /* 9A SETP                       */
    O_bModrm,                 /* 9B SETNP                      */
    O_bModrm,                 /* 9C SETL                       */
    O_bModrm,                 /* 9D SETGE                      */
    O_bModrm,                 /* 9E SETLE                      */
    O_bModrm,                 /* 9F SETNLE                     */
    O_sReg2,                  /* A0 PUSH FS                    */
    O_sReg2,                  /* A1 POP FS                     */
    O_NoOperands,             /* A2 CPUID                      */
    O_Modrm_Reg,              /* A3 BT                         */
    O_Modrm_Reg_Ib,           /* A4 SHLD                       */
    O_Modrm_Reg_CL,           /* A5 SHLD                       */
    O_DoDB,                   /* A6                            */
    O_DoDB,                   /* A7                            */
    O_sReg2,                  /* A8 PUSH GS                    */
    O_sReg2,                  /* A9 POP GS                     */
    O_NoOperands,             /* AA RSM                        */
    O_vModrm_Reg,             /* AB BTS                        */
    O_Modrm_Reg_Ib,           /* AC SHRD                       */
    O_Modrm_Reg_CL,           /* AD SHRD                       */
    O_DoDB,                   /* AE                            */
    O_Reg_Modrm,              /* AF IMUL                       */
    O_bModrm_Reg,             /* B0 CMPXCH                     */
    O_Modrm_Reg,              /* B1 CMPXCH                     */
    O_fReg_Modrm,             /* B2 LSS                        */
    O_Modrm_Reg,              /* B3 BTR                        */
    O_fReg_Modrm,             /* B4 LFS                        */
    O_fReg_Modrm,             /* B5 LGS                        */
    O_Reg_bModrm,             /* B6 MOVZX                      */
    O_Reg_wModrm,             /* B7 MOVZX                      */
    O_DoDB,                   /* B8                            */
    O_DoDB,                   /* B9                            */
    O_GROUP8,                 /* BA MULTI                      */
    O_Modrm_Reg,              /* BB BTC                        */
    O_Reg_Modrm,              /* BC BSF                        */
    O_Reg_Modrm,              /* BD BSR                        */
    O_Reg_bModrm,             /* BE MOVSX                      */
    O_Reg_wModrm,             /* BF MOVSX                      */
    O_bModrm_Reg,             /* C0 XADD                       */
    O_Modrm_Reg,              /* C1 XADD                       */
    O_DoDB,                   /* C2                            */
    O_DoDB,                   /* C3                            */
    O_DoDB,                   /* C4                            */
    O_DoDB,                   /* C5                            */
    O_DoDB,                   /* C6                            */
    O_qModrm,                 /* C7 CMPXCHG8B                  */
    O_oReg,                   /* C8 BSWAP                      */
    O_oReg,                   /* C9 BSWAP                      */
    O_oReg,                   /* CA BSWAP                      */
    O_oReg,                   /* CB BSWAP                      */
    O_oReg,                   /* CC BSWAP                      */
    O_oReg,                   /* CD BSWAP                      */
    O_oReg,                   /* CE BSWAP                      */
    O_oReg,                   /* CF BSWAP                      */
    O_DoDB,                   /* D0                            */
    O_MmReg_qModrm,           /* D1 PSRLW                      */
    O_MmReg_qModrm,           /* D2 PSRLD                      */
    O_MmReg_qModrm,           /* D3 PSRLQ                      */
    O_DoDB,                   /* D4                            */
    O_MmReg_qModrm,           /* D5 PMULLW                     */
    O_DoDB,                   /* D6                            */
    O_DoDB,                   /* D7                            */
    O_MmReg_qModrm,           /* D8 PSUBUSB                    */
    O_MmReg_qModrm,           /* D9 PSUBUSW                    */
    O_DoDB,                   /* DA                            */
    O_MmReg_qModrm,           /* DB PAND                       */
    O_MmReg_qModrm,           /* DC PADDUSB                    */
    O_MmReg_qModrm,           /* DD PADDUSW                    */
    O_DoDB,                   /* DE                            */
    O_MmReg_qModrm,           /* DF PANDN                      */
    O_DoDB,                   /* E0                            */
    O_MmReg_qModrm,           /* E1 PSRAW                      */
    O_MmReg_qModrm,           /* E2 PSRAD                      */
    O_DoDB,                   /* E3                            */
    O_DoDB,                   /* E4                            */
    O_MmReg_qModrm,           /* E5 PMULHW                     */
    O_DoDB,                   /* E6                            */
    O_DoDB,                   /* E7                            */
    O_MmReg_qModrm,           /* E8 PSUBSB                     */
    O_MmReg_qModrm,           /* E9 PSUBSW                     */
    O_DoDB,                   /* EA                            */
    O_MmReg_qModrm,           /* EB POR                        */
    O_MmReg_qModrm,           /* EC PADDSB                     */
    O_MmReg_qModrm,           /* ED PADDSW                     */
    O_DoDB,                   /* EE                            */
    O_MmReg_qModrm,           /* EF PXOR                       */
    O_DoDB,                   /* F0                            */
    O_MmReg_qModrm,           /* F1 PSLLW                      */
    O_MmReg_qModrm,           /* F2 PSLLD                      */
    O_MmReg_qModrm,           /* F3 PSLLQ                      */
    O_DoDB,                   /* F4                            */
    O_MmReg_qModrm,           /* F5 PMADDWD                    */
    O_DoDB,                   /* F6                            */
    O_DoDB,                   /* F7                            */
    O_MmReg_qModrm,           /* F8 PSUBB                      */
    O_MmReg_qModrm,           /* F9 PSUBW                      */
    O_MmReg_qModrm,           /* FA PSUBD                      */
    O_DoDB,                   /* FB                            */
    O_MmReg_qModrm,           /* FC PADDB                      */
    O_MmReg_qModrm,           /* FD PADDW                      */
    O_MmReg_qModrm,           /* FE PADDD                      */
};

Tdistbl groupt[][8] = {
/* 00  00                     x87-D8-1                   */
        { O_dModrm,     /* D8-0 FADD    */
          O_dModrm,     /* D8-1 FMUL    */
          O_dModrm,     /* D8-2 FCOM    */
          O_dModrm,     /* D8-3 FCOMP   */
          O_dModrm,     /* D8-4 FSUB    */
          O_dModrm,     /* D8-5 FSUBR   */
          O_dModrm,     /* D8-6 FDIV    */
          O_dModrm },   /* D8-7 FDIVR   */
/* 01                         x87-D8-2                   */
        { O_ST_iST,     /* D8-0 FADD    */
          O_ST_iST,     /* D8-1 FMUL    */
          O_iST,        /* D8-2 FCOM    */
          O_iST,        /* D8-3 FCOMP   */
          O_ST_iST,     /* D8-4 FSUB    */
          O_ST_iST,     /* D8-5 FSUBR   */
          O_ST_iST,     /* D8-6 FDIV    */
          O_ST_iST },   /* D8-7 FDIVR   */

/* 02   01                    x87-D9-1                   */
        { O_dModrm,     /* D9-0 FLD     */
          O_DoDB,       /* D9-1         */
          O_dModrm,     /* D9-2 FST     */
          O_dModrm,     /* D9-3 FSTP    */
          O_Modrm,      /* D9-4 FLDENV  */
          O_Modrm,      /* D9-5 FLDCW   */
          O_Modrm,      /* D9-6 FSTENV  */
          O_Modrm },    /* D9-7 FSTCW   */

/* 03   01                    x87-D9-2 TTT=0,1,2,3       */
        { O_iST,        /* D9-0 FLD     */
          O_iST,        /* D9-1 FXCH    */
          O_NoOperands, /* D9-2 FNOP    */
          O_iST,        /* D9-3 FSTP    */
          O_DoDB,       /* D9-4         */
          O_DoDB,       /* D9-5         */
          O_DoDB,       /* D9-6         */
          O_DoDB   },   /* D9-7         */

/* 04  02                     x89-DA-1                   */
        { O_dModrm,     /* DA-0 FIADD   */
          O_dModrm,     /* DA-1 FIMUL   */
          O_dModrm,     /* DA-2 FICOM   */
          O_dModrm,     /* DA-3 FICOMP  */
          O_dModrm,     /* DA-4 FISUB   */
          O_dModrm,     /* DA-5 FISUBR  */
          O_dModrm,     /* DA-6 FIDIV   */
          O_dModrm },   /* DA-7 FIDIVR  */

/* 05                         x87-DA-2                   */
        { O_ST_iST,     /* DA-0 FCMOVB  */
          O_ST_iST,     /* DA-1 FCMOVE  */
          O_ST_iST,     /* DA-2 FCMOVBE */
          O_ST_iST,     /* DA-3 FCMOVU  */
          O_DoDB,       /* DA-4         */
          O_NoOperands, /* DA-5         */
          O_DoDB,       /* DA-6         */
          O_DoDB },     /* DA-7         */

/* 06  03                     x87-DB-1                   */
        { O_dModrm,     /* DB-0 FILD    */
          O_DoDB,       /* DB-1         */
          O_dModrm,     /* DB-2 FIST    */
          O_dModrm,     /* DB-3 FISTP   */
          O_DoDB,       /* DB-4         */
          O_tModrm,     /* DB-5 FLD     */
          O_DoDB,       /* DB-6         */
          O_tModrm },   /* DB-7 FSTP    */

/* 07                      x87-DB-2 ttt=4        */
        { O_NoOperands, /* DB-0 FENI    */
          O_NoOperands, /* DB-1 FDISI   */
          O_NoOperands, /* DB-2 FCLEX   */
          O_NoOperands, /* DB-3 FINIT   */
          O_DoDB,       /* DB-4 FSETPM  */
          O_DoDB,       /* DB-5         */
          O_DoDB,       /* DB-6         */
          O_DoDB },     /* DB-7         */

/* 08 04                      x87-DC-1                   */
        { O_qModrm,     /* DC-0 FADD    */
          O_qModrm,     /* DC-1 FMUL    */
          O_qModrm,     /* DC-2 FCOM    */
          O_qModrm,     /* DC-3 FCOMP   */
          O_qModrm,     /* DC-4 FSUB    */
          O_qModrm,     /* DC-5 FSUBR   */
          O_qModrm,     /* DC-6 FDIV    */
          O_qModrm },   /* DC-7 FDIVR   */

/* 09                         x87-DC-2                   */
        { O_iST_ST,     /* DC-0 FADD    */
          O_iST_ST,     /* DC-1 FMUL    */
          O_iST,        /* DC-2 FCOM    */
          O_iST,        /* DC-3 FCOMP   */
          O_iST_ST,     /* DC-4 FSUB    */
          O_iST_ST,     /* DC-5 FSUBR   */
          O_iST_ST,     /* DC-6 FDIVR   */
          O_iST_ST },   /* DC-7 FDIV    */

/* 10  05                     x87-DD-1                   */
        { O_qModrm,     /* DD-0 FLD     */
          O_DoDB,       /* DD-1         */
          O_qModrm,     /* DD-2 FST     */
          O_qModrm,     /* DD-3 FSTP    */
          O_Modrm,      /* DD-4 FRSTOR  */
          O_DoDB,       /* DD-5         */
          O_Modrm,      /* DD-6 FSAVE   */
          O_Modrm },    /* DD-7 FSTSW   */

/* 11                         x87-DD-2                   */
        { O_iST,        /* DD-0 FFREE   */
          O_iST,        /* DD-1 FXCH    */
          O_iST,        /* DD-2 FST     */
          O_iST,        /* DD-3 FSTP    */
          O_iST,        /* DD-4 FUCOM   */
          O_iST,        /* DD-5 FUCOMP  */
          O_DoDB,       /* DD-6         */
          O_DoDB },     /* DD-7         */

/* 12  06                     x87-DE-1                   */
        { O_wModrm,     /* DE-0 FIADD   */
          O_wModrm,     /* DE-1 FIMUL   */
          O_wModrm,     /* DE-2 FICOM   */
          O_wModrm,     /* DE-3 FICOMP  */
          O_wModrm,     /* DE-4 FISUB   */
          O_wModrm,     /* DE-5 FISUBR  */
          O_wModrm,     /* DE-6 FIDIV   */
          O_wModrm },   /* DE-7 FIDIVR  */

/* 13                         x87-DE-2                   */
        { O_iST_ST,     /* DE-0 FADDP   */
          O_iST_ST,     /* DE-1 FMULP   */
          O_iST,        /* DE-2 FCOMP   */
          O_NoOperands, /* DE-3 FCOMPP  */
          O_iST_ST,     /* DE-4 FSUBP   */
          O_iST_ST,     /* DE-5 FSUBRP  */
          O_iST_ST,     /* DE-6 FDIVP   */
          O_iST_ST },   /* DE-7 FDIVRP  */

/* 14  07                     x87-DF-1                   */
        { O_wModrm,     /* DF-0 FILD    */
          O_DoDB,       /* DF-1         */
          O_wModrm,     /* DF-2 FIST    */
          O_wModrm,     /* DF-3 FISTP   */
          O_tModrm,     /* DF-4 FBLD    */
          O_qModrm,     /* DF-5 FILD    */
          O_tModrm,     /* DF-6 FBSTP   */
          O_qModrm },   /* DF-7 FISTP   */

/* 15                         x87-DF-2                   */
        { O_iST,        /* DF-0 FFREE   */
          O_iST,        /* DF-1 FXCH    */
          O_iST,        /* DF-2 FST     */
          O_iST,        /* DF-3 FSTP    */
          O_NoOperands, /* DF-4 FSTSW   */
          O_ST_iST,     /* DF-5 FUCOMIP */
          O_ST_iST,     /* DF-6 FCOMIP  */
          O_DoDB },     /* DF-7         */

/* 16   01            x87-D9 Mod=3 TTT=4                 */
        { O_NoOperands, /* D9-0 FCHS    */
          O_NoOperands,  /* D9-1 FABS   */
          O_DoDB,       /* D9-2         */
          O_DoDB,       /* D9-3         */
          O_NoOperands, /* D9-4 FTST    */
          O_NoOperands, /* D9-5 FXAM    */
          O_DoDB,       /* D9-6         */
          O_DoDB },     /* D9-7         */

/* 17   01            x87-D9 Mod=3 TTT=5                 */
        { O_NoOperands, /* D9-0 FLD1    */
          O_NoOperands, /* D9-1 FLDL2T  */
          O_NoOperands, /* D9-2 FLDL2E  */
          O_NoOperands, /* D9-3 FLDPI   */
          O_NoOperands, /* D9-4 FLDLG2  */
          O_NoOperands, /* D9-5 FLDLN2  */
          O_NoOperands, /* D9-6 FLDZ    */
          O_DoDB },     /* D9-7         */

/* 18   01            x87-D9 Mod=3 TTT=6                   */
        { O_NoOperands,   /* D9-0 F2XM1   */
          O_NoOperands,   /* D9-1 FYL2X   */
          O_NoOperands,   /* D9-2 FPTAN   */
          O_NoOperands,   /* D9-3 FPATAN  */
          O_NoOperands,   /* D9-4 FXTRACT */
          O_NoOperands,   /* D9-5 FPREM1  */
          O_NoOperands,   /* D9-6 FDECSTP */
          O_NoOperands }, /* D9-7 FINCSTP */

/* 19   01            x87-D9 Mod=3 TTT=7                   */
        { O_NoOperands,   /* D9-0 FPREM   */
          O_NoOperands,   /* D9-1 FYL2XP1 */
          O_NoOperands,   /* D9-2 FSQRT   */
          O_NoOperands,   /* D9-3 FSINCOS */
          O_NoOperands,   /* D9-4 FRNDINT */
          O_NoOperands,   /* D9-5 FSCALE  */
          O_NoOperands,   /* D9-6 FSIN    */
          O_NoOperands }, /* D9-7 FCOS    */

/* 20                  group 3                             */
        { O_bModrm_Ib,    /* F6-0 TEST    */
          O_DoDB,         /* F6-1         */
          O_bModrm,       /* F6-2 NOT     */
          O_bModrm,       /* F6-3 NEG     */
          O_bModrm,       /* F6-4 MUL     */
          O_bModrm,       /* F6-5 IMUL    */
          O_bModrm,       /* F6-6 DIV     */
          O_bModrm },     /* F6-7 IDIV    */

/* 21                  group 3                             */
        { O_vModrm_Iv,    /* F7-0 TEST    */
          O_DoDB,         /* F7-1         */
          O_vModrm,       /* F7-2 NOT     */
          O_vModrm,       /* F7-3 NEG     */
          O_vModrm,       /* F7-4 MUL     */
          O_vModrm,       /* F7-5 IMUL    */
          O_vModrm,       /* F7-6 DIV     */
          O_vModrm },     /* F7-7 IDIV    */

/* 22                  group 5                             */
        { O_vModrm,     /* FF-0 INC       */
          O_vModrm,     /* FF-1 DEC       */
          O_vModrm,     /* FF-2 CALL      */
          O_fModrm,     /* FF-3 CALL      */
          O_vModrm,     /* FF-4 JMP       */
          O_fModrm,     /* FF-5 JMP       */
          O_vModrm,     /* FF-6 PUSH      */
          O_DoDB },     /* FF-7           */

/* 23                  group 7                             */
        { O_Modrm,      /* 0F-0 SGDT      */
          O_Modrm,      /* 0F-1 SIDT      */
          O_Modrm,      /* 0F-2 LGDT      */
          O_Modrm,      /* 0F-3 LIDT      */
          O_wModrm,     /* 0F-4 MSW       */
          O_DoDB,       /* 0F-5           */
          O_wModrm,     /* 0F-6 LMSW      */
          O_Modrm },    /* 0F-7 INVLPG    */

/* 24                 x87-DB Mod=3 TTT != 4                */
        { O_ST_iST,     /* DB-0 FCMOVNB   */
          O_ST_iST,     /* DB-1 FCMOVNE   */
          O_ST_iST,     /* DB-2 FCMOVNBE  */
          O_ST_iST,     /* DB-3 FCMOVNU   */
          O_DoDB,       /* DB-4           */
          O_ST_iST,     /* DB-5 FUCOMI    */
          O_ST_iST,     /* DB-6 FCOMI     */
          O_DoDB }      /* DB-7           */
        };

DWORD 
GetInstructionLengthFromAddress(LPBYTE pEip)
{
    
    int     G_mode_32;
    int     mode_32;                    // local addressing mode indicator 
    int     opsize_32;                  // operand size flag 
    int     opcode;                     // current opcode 
    int     olen = 2;                   // operand length 
    int     alen = 2;                   // address length 
    int     end = FALSE;                // end of instruction flag 
    int     mrm = FALSE;                // indicator that modrm is generated
    unsigned char *action;              // action for operand interpretation
    long    tmp;                        // temporary storage field 
    int     indx;                       // temporary index 
    int     action2;                    // secondary action 
    int     instlen;                    // instruction length 
    int     segOvr = 0;                 // segment override opcode 
    unsigned char BOPaction;
    int     subcode;                    // bop subcode 
    DECODEDATA decodeData;

    decodeData.mod = 0;
    decodeData.ttt = 0;
    decodeData.fMovX = FALSE;
    decodeData.fMmRegEa = FALSE;
    decodeData.EAsize[0] = decodeData.EAsize[1] = 0;          //  no effective address

    G_mode_32 = 1;

    mode_32 = opsize_32 = (G_mode_32 == 1); // local addressing mode 
    olen = alen = (1 + mode_32) << 1;   // set operand/address lengths
                                        // 2 for 16-bit and 4 for 32-bit
    decodeData.pMem = pEip;             // point to begin of instruction 
    opcode = *(decodeData.pMem)++;      // get opcode 
    
    if (opcode == 0xc4 && *(decodeData.pMem) == 0xC4) 
    {
        (decodeData.pMem)++;
        action = &BOPaction;
        BOPaction = IB | END;
        subcode =  *(decodeData.pMem);
        if (subcode == 0x50 || subcode == 0x52 || 
            subcode == 0x53 || subcode == 0x54 || 
            subcode == 0x57 || subcode == 0x58 || 
            subcode == 0x58) 
        {
            BOPaction = IW | END;
        }
    } else 
    {
        action = actiontbl + distbl[opcode].opr; /* get operand action */
    }

    // loop through all operand actions

    do {
        action2 = (*action) & 0xc0;
        switch((*action++) & 0x3f) {
            case ALT:                   // alter the opcode if 32-bit 
                if (opsize_32) 
                {
                    indx = *action++;
                }
                break;

            case STROP:
                //  compute size of operands in indx
                //  also if dword operands, change fifth
                //  opcode letter from 'w' to 'd'.

                if (opcode & 1) 
                {
                    if (opsize_32) 
                    {
                        indx = 4;
                    }
                    else
                    {
                        indx = 2;
                    }
                }
                else
                {
                    indx = 1;
                }

                break;

            case CHR:                   // insert a character 
                action++;
                break;

            case CREG:                  // set debug, test or control reg 
                break;

            case SREG2:                 // segment register 
                // Handle special case for fs/gs (OPC0F adds SECTAB_OFFSET_5
                // to these codes)
                if (opcode > 0x7e)
                {
                    decodeData.ttt = BIT53((opcode-SECTAB_OFFSET_5));
                }
                else
                {
                    decodeData.ttt = BIT53(opcode);    //  set value to fall through
                }

            case SREG3:                 // segment register 
                break;

            case BRSTR:                 // get index to register string 
                decodeData.ttt = *action++;        //    from action table 
                goto BREGlabel;

            case BOREG:                 // byte register (in opcode) 
                decodeData.ttt = BIT20(opcode);    // register is part of opcode 
                goto BREGlabel;

            case ALSTR:
                decodeData.ttt = 0;     // point to AL register 
    BREGlabel:
            case BREG:                  // general register 
                break;

            case WRSTR:                 // get index to register string 
                decodeData.ttt = *action++;        //    from action table 
                goto WREGlabel;

            case VOREG:                 // register is part of opcode 
                decodeData.ttt = BIT20(opcode);
                goto VREGlabel;

            case AXSTR:
                decodeData.ttt = 0;     // point to eAX register 
    VREGlabel:
            case VREG:                  // general register 
    WREGlabel:
            case WREG:                  // register is word size 
                break;

            case MMWREG:
                break;

            case IST_ST:
                break;

            case ST_IST:
                ;
            case IST:
                ;
                break;

            case xBYTE:                 // set instruction to byte only 
                decodeData.EAsize[0] = 1;
                break;

            case VAR:
                if (opsize_32)
                    goto DWORDlabel;

            case xWORD:
                decodeData.EAsize[0] = 2;
                break;

            case EDWORD:
                opsize_32 = 1;          //  for control reg move, use eRegs
            case xDWORD:
DWORDlabel:
                decodeData.EAsize[0] = 4;
                break;

            case MMQWORD:
                decodeData.fMmRegEa = TRUE;

            case QWORD:
                decodeData.EAsize[0] = 8;
                break;

            case xTBYTE:
                decodeData.EAsize[0] = 10;
                break;

            case FARPTR:
                if (opsize_32) {
                    decodeData.EAsize[0] = 6;
                    }
                else {
                    decodeData.EAsize[0] = 4;
                    }
                break;

            case LMODRM:                //  output modRM data type
                if (decodeData.mod != 3)
                    ;
                else
                    decodeData.EAsize[0] = 0;

            case MODRM:                 // output modrm string 
                if (segOvr)             // in case of segment override 
                    0;
                break;

            case ADDRP:                 // address pointer 
                decodeData.pMem += olen + 2;
                break;

            case REL8:                  // relative address 8-bit 
                tmp = (long)*(char *)(decodeData.pMem)++; // get the 8-bit rel offset 
                goto DoRelDispl;

            case REL16:                 // relative address 16-/32-bit 
                tmp = 0;
                if (mode_32)
                    MoveMemory(&tmp,decodeData.pMem,sizeof(long));
                else
                    MoveMemory(&tmp,decodeData.pMem,sizeof(short));
                decodeData.pMem += alen;           // skip over offset 
DoRelDispl:
                break;

            case UBYTE:                 //  unsigned byte for int/in/out
                decodeData.pMem++;
                break;

            case IB:                    // operand is immediate byte 
                if ((opcode & ~1) == 0xd4) {  // postop for AAD/AAM is 0x0a
                    if (*(decodeData.pMem)++ != 0x0a) // test post-opcode byte
                        0;
                    break;
                    }
                olen = 1;               // set operand length 
                goto DoImmed;

            case IW:                    // operand is immediate word 
                olen = 2;               // set operand length 

            case IV:                    // operand is word or dword 
DoImmed:
                decodeData.pMem += olen;
                break;

            case OFFS:                  // operand is offset 
                decodeData.EAsize[0] = (opcode & 1) ? olen : 1;

                if (segOvr)             // in case of segment override 
                   0;

                decodeData.pMem += alen;
                break;

            case GROUP:                 // operand is of group 1,2,4,6 or 8 
                action++;               // output opcode symbol 
                break;

            case GROUPT:                // operand is of group 3,5 or 7 
                indx = *action;         // get indx into group from action 
                goto doGroupT;

            case EGROUPT:               // x87 ESC (D8-DF) group index 
                indx = BIT20(opcode) * 2; // get group index from opcode 
                if (decodeData.mod == 3) 
                {                       // some operand variations exists 
                                        // for x87 and mod == 3 
                    ++indx;             // take the next group table entry 
                    if (indx == 3) 
                    {                   // for x87 ESC==D9 and mod==3 
                        if (decodeData.ttt > 3) 
                        {               // for those D9 instructions 
                            indx = 12 + decodeData.ttt; // offset index to table by 12 
                            decodeData.ttt = decodeData.rm;   // set secondary index to rm 
                        }
                    }
                    else if (indx == 7) 
                    { // for x87 ESC==DB and mod==3 
                        if (decodeData.ttt == 4) 
                        {               
                            decodeData.ttt = decodeData.rm;     // set secondary group table index 
                        } else if ((decodeData.ttt<4)||(decodeData.ttt>4 && decodeData.ttt<7)) 
                        {
                            // adjust for pentium pro opcodes
                            indx = 24;   // offset index to table by 24
                        }
                    }
                }
doGroupT:
                // handle group with different types of operands 
                action = actiontbl + groupt[indx][decodeData.ttt].opr;
                // get new action 

                break;
            //
            // The secondary opcode table has been compressed in the
            // original design. Hence while disassembling the 0F sequence,
            // opcode needs to be displaced by an appropriate amount depending
            // on the number of "filled" entries in the secondary table.
            // These displacements are used throughout the code.
            //

            case OPC0F:              // secondary opcode table (opcode 0F) 
                opcode = *(decodeData.pMem)++;    // get real opcode 
                decodeData.fMovX  = (BOOL)(opcode == 0xBF || opcode == 0xB7);
                if (opcode < 12) // for the first 12 opcodes 
                    opcode += SECTAB_OFFSET_1; // point to begin of sec op tab
                else if (opcode > 0x1f && opcode < 0x27)
                    opcode += SECTAB_OFFSET_2; // adjust for undefined opcodes
                else if (opcode > 0x2f && opcode < 0x34)
                    opcode += SECTAB_OFFSET_3; // adjust for undefined opcodes
                else if (opcode > 0x3f && opcode < 0x50)
                    opcode += SECTAB_OFFSET_4; // adjust for undefined opcodes
                else if (opcode > 0x5f && opcode < 0xff)
                    opcode += SECTAB_OFFSET_5; // adjust for undefined opcodes
                else
                    opcode = SECTAB_OFFSET_UNDEF; // all non-existing opcodes
                goto getNxtByte1;

            case ADR_OVR:               // address override 
                mode_32 = !G_mode_32;   // override addressing mode 
                alen = (mode_32 + 1) << 1; // toggle address length 
                goto getNxtByte;

            case OPR_OVR:               // operand size override 
                opsize_32 = !G_mode_32; // override operand size 
                olen = (opsize_32 + 1) << 1; // toggle operand length 
                goto getNxtByte;

            case SEG_OVR:               // handle segment override 
                segOvr = opcode;        // save segment override opcode 
                goto getNxtByte;

            case REP:                   // handle rep/lock prefixes 
    getNxtByte:
                opcode = *(decodeData.pMem)++;        // next byte is opcode 
    getNxtByte1:
                action = actiontbl + distbl[opcode].opr;

            default:                    // opcode has no operand 
                break;
            }

            switch (action2) 
            {              // secondary action 
                case MRM:                   // generate modrm for later use 
                    if (!mrm) 
                    {             // ignore if it has been generated 
                        //DIdoModrm(segOvr, &decodeData);

                        int     newmrm;                        // modrm byte 
                        int     sib;
                        int     ss;
                        int     ind;
                        int     oldrm;

                        newmrm = *(decodeData.pMem)++;                // get the mrm byte from instruction 
                        decodeData.mod = BIT76(newmrm);               // get mod 
                        decodeData.ttt = BIT53(newmrm);               // get reg - used outside routine 
                        decodeData.rm  = BIT20(newmrm);               // get rm 

                        if (decodeData.mod == 3) 
                        {                                             // register only mode 
                            decodeData.EAsize[0] = 0;                 //  no EA value to output
                        }
                        else
                        {

                            // 32-bit addressing mode 
                            oldrm = decodeData.rm;
                            if (decodeData.rm == 4) 
                            {                                               // rm == 4 implies sib byte 
                                sib = *(decodeData.pMem)++;                // get s_i_b byte 
                                decodeData.rm = BIT20(sib);                // return base 
                            }

                            if (decodeData.mod == 0 && decodeData.rm == 5) 
                            {
                                decodeData.pMem += 4;
                            }

                            if (oldrm == 4) 
                            {               
                                //  finish processing sib
                                ind = BIT53(sib);
                                if (ind != 4) 
                                {
                                    ss = 1 << BIT76(sib);
                                }
                            }

                            //  output any displacement
                            if (decodeData.mod == 1) 
                            {
                                decodeData.pMem++;
                            }
                            else if (decodeData.mod == 2) 
                            {
                                decodeData.pMem += 4;
                            }
                        }

                        mrm = TRUE;         // remember its generation 
                    }
                    break;

                case COM:                   // insert a comma after operand 
                    break;

                case END:                   // end of instruction 
                    end = TRUE;
                    break;
        }
    } 
    while (!end);                        // loop til end of instruction 

    instlen = (decodeData.pMem) - pEip;

    return instlen;   
}

#endif

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\precomp.h ===
#ifndef _GPSHIMS_PRECOMP_H_
#define _GPSHIMS_PRECOMP_H_

#include "ShimHook.h"

using namespace ShimLib;


#endif // _GPSHIMS_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\mapmemoryb0000.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MapMemoryB0000.cpp

 Abstract:

    Map memory at 0xB0000 for applications that use this memory. On Win9x, this 
    is always a valid memory block.
   
 Notes:

    This is a general purpose shim.

 History:

    05/11/2000 linstev  Created
    10/26/2000 linstev  Removed unnecessary free code

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MapMemoryB0000)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        if (VirtualAlloc((LPVOID)0xB0000, 0x10000, MEM_COMMIT, PAGE_READWRITE)) {
            
            LOGN(
                eDbgLevelInfo,
                "[NotifyFn] Created block at 0xB0000.");
        } else {
            LOGN(
                eDbgLevelError,
                "[NotifyFn] Failed to create block at 0xB0000.");
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\ignoreexception.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    IgnoreException.cpp

 Abstract:

    This shim is for handling exceptions that get thrown by bad apps.
    The primary causes of unhandled exceptions are:

        1. Priviliged mode instructions: cli, sti, out etc
        2. Access violations

    In most cases, ignoring an Access Violation will be fatal for the app,
    but it works in some cases, eg: 
    
        Deer Hunter 2 - their 3d algorithm reads too far back in a lookup 
        buffer. This is a game bug and doesn't crash win9x because that memory
        is usually allocated.

    Interstate 76 also requires a Divide by Zero exception to be ignored.

 Notes:

    This is a general purpose shim.

 History:

    02/10/2000  linstev     Created
    10/17/2000  maonis      Bug fix - now it ignores AVs correctly.
    02/27/2001  robkenny    Converted to use CString

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreException)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

// Exception code for OutputDebugString
#define DBG_EXCEPTION  0x40010000L

// Determine how to manage second chance exceptions
BOOL g_bWin2000 = FALSE;
DWORD g_dwLastEip = 0;

extern DWORD GetInstructionLengthFromAddress(LPBYTE pEip);

/*++

 This is the list of all the exceptions that this shim can handle. The fields are

    1. cName      - the name of the exception as accepted as a parameter and 
                    displayed in debug spew
    2. dwCode     - the exception code
    3. dwSubCode  - parameters specified by the exception: -1 = don't care
    4. dwIgnore   - ignore this exception: 
                    0 = don't ignore
                    1 = ignore 1st chance
                    2 = ignore 2nd chance
                    3 = exit process on 2nd chance.

--*/

typedef enum 
{
    eActive = 0, 
    eFirstChance, 
    eSecondChance,
    eExitProcess
} EMODE;

WCHAR * ToWchar(EMODE emode)
{
    switch (emode)
    {
    case eActive:
        return L"Active";

    case eFirstChance:
        return L"FirstChance";

    case eSecondChance:
        return L"SecondChance";

    case eExitProcess:
        return L"ExitProcess";
    };

    return L"ERROR";
}

// Convert a text version of EMODE to a EMODE value
EMODE ToEmode(const CString & csMode)
{
    if (csMode.Compare(L"0") == 0 || csMode.Compare(ToWchar(eActive)) == 0)
    {
        return eActive;
    }
    else if (csMode.Compare(L"1") == 0 || csMode.Compare(ToWchar(eFirstChance)) == 0)
    {
        return eFirstChance;
    }
    else if (csMode.Compare(L"2") == 0 || csMode.Compare(ToWchar(eSecondChance)) == 0)
    {
        return eSecondChance;
    }
    else if (csMode.Compare(L"3") == 0 || csMode.Compare(ToWchar(eExitProcess)) == 0)
    {
        return eExitProcess;
    }

    // Default value
    return eFirstChance;
}


struct EXCEPT
{
    WCHAR * cName;
    DWORD dwCode;
    DWORD dwSubCode;
    EMODE dwIgnore;
};

static EXCEPT g_eList[] =
{
    {L"ACCESS_VIOLATION_READ"    , (DWORD)EXCEPTION_ACCESS_VIOLATION        , 0 , eActive},
    {L"ACCESS_VIOLATION_WRITE"   , (DWORD)EXCEPTION_ACCESS_VIOLATION        , 1 , eActive},
    {L"ARRAY_BOUNDS_EXCEEDED"    , (DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED   , -1, eActive},
    {L"BREAKPOINT"               , (DWORD)EXCEPTION_BREAKPOINT              , -1, eActive},
    {L"DATATYPE_MISALIGNMENT"    , (DWORD)EXCEPTION_DATATYPE_MISALIGNMENT   , -1, eActive},
    {L"FLT_DENORMAL_OPERAND"     , (DWORD)EXCEPTION_FLT_DENORMAL_OPERAND    , -1, eActive},
    {L"FLT_DIVIDE_BY_ZERO"       , (DWORD)EXCEPTION_FLT_DIVIDE_BY_ZERO      , -1, eActive},
    {L"FLT_INEXACT_RESULT"       , (DWORD)EXCEPTION_FLT_INEXACT_RESULT      , -1, eActive},
    {L"FLT_INVALID_OPERATION"    , (DWORD)EXCEPTION_FLT_INVALID_OPERATION   , -1, eActive},
    {L"FLT_OVERFLOW"             , (DWORD)EXCEPTION_FLT_OVERFLOW            , -1, eActive},
    {L"FLT_STACK_CHECK"          , (DWORD)EXCEPTION_FLT_STACK_CHECK         , -1, eActive},
    {L"FLT_UNDERFLOW"            , (DWORD)EXCEPTION_FLT_UNDERFLOW           , -1, eActive},
    {L"ILLEGAL_INSTRUCTION"      , (DWORD)EXCEPTION_ILLEGAL_INSTRUCTION     , -1, eActive},
    {L"IN_PAGE_ERROR"            , (DWORD)EXCEPTION_IN_PAGE_ERROR           , -1, eActive},
    {L"INT_DIVIDE_BY_ZERO"       , (DWORD)EXCEPTION_INT_DIVIDE_BY_ZERO      , -1, eActive},
    {L"INT_OVERFLOW"             , (DWORD)EXCEPTION_INT_OVERFLOW            , -1, eActive},
    {L"INVALID_DISPOSITION"      , (DWORD)EXCEPTION_INVALID_DISPOSITION     , -1, eActive},
    {L"NONCONTINUABLE_EXCEPTION" , (DWORD)EXCEPTION_NONCONTINUABLE_EXCEPTION, -1, eActive},
    {L"PRIV_INSTRUCTION"         , (DWORD)EXCEPTION_PRIV_INSTRUCTION        , -1, eFirstChance},
    {L"SINGLE_STEP"              , (DWORD)EXCEPTION_SINGLE_STEP             , -1, eActive},
    {L"STACK_OVERFLOW"           , (DWORD)EXCEPTION_STACK_OVERFLOW          , -1, eActive},
    {L"INVALID_HANDLE"           , (DWORD)EXCEPTION_INVALID_HANDLE          , -1, eActive}
};

#define ELISTSIZE sizeof(g_eList) / sizeof(g_eList[0])

/*++

 Custom exception handler.

--*/

LONG 
ExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    DWORD dwCode = ExceptionInfo->ExceptionRecord->ExceptionCode;

    if ((dwCode & DBG_EXCEPTION) == DBG_EXCEPTION) // for the DebugPrints
    {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    CONTEXT *lpContext = ExceptionInfo->ContextRecord;
    WCHAR szException[64];
    BOOL bIgnore = FALSE;

    //
    // Run the list of exceptions to see if we're ignoring it
    //

    EXCEPT *pE = &g_eList[0];
    for (int i = 0; i < ELISTSIZE; i++, pE++)
    {
        // Matched the major exception code
        if (dwCode == pE->dwCode)
        {
            // See if we care about the subcode
            if ((pE->dwSubCode != -1) && 
                (ExceptionInfo->ExceptionRecord->ExceptionInformation[0] != pE->dwSubCode))
            {
                continue;
            }

            wcscpy(szException, pE->cName);
            
            // Determine how to handle the exception
            switch (pE->dwIgnore)
            {
            case eActive: 
                bIgnore = FALSE;
                break;
            
            case eFirstChance:
                bIgnore = TRUE;
                break;
            
            case eSecondChance:
                bIgnore = g_bWin2000 || (g_dwLastEip == lpContext->Eip);
                g_dwLastEip = lpContext->Eip;
                break;

            case eExitProcess:
                // Try using unhandled exception filters to catch this
                bIgnore = TRUE;//g_bWin2000 || IsBadCodePtr((FARPROC)lpContext->Eip);
                if (bIgnore)
                {
                    ExitProcess(0);
                    TerminateProcess(GetCurrentProcess(), 0);
                }
                g_dwLastEip = lpContext->Eip;
                break;
            }
            
            if (bIgnore) break;
        }
    }
    
    //
    //  Dump out the exception
    //

    DPFN( eDbgLevelWarning, "Exception %S (%08lx)\n", 
        szException,
        dwCode);

    #ifdef DBG
        DPFN( eDbgLevelWarning, "eip=%08lx\n", 
            lpContext->Eip);

        DPFN( eDbgLevelWarning, "eax=%08lx, ebx=%08lx, ecx=%08lx, edx=%08lx\n", 
            lpContext->Eax, 
            lpContext->Ebx, 
            lpContext->Ecx, 
            lpContext->Edx);

        DPFN( eDbgLevelWarning, "esi=%08lx, edi=%08lx, esp=%08lx, ebp=%08lx\n", 
            lpContext->Esi, 
            lpContext->Edi, 
            lpContext->Esp, 
            lpContext->Ebp);

        DPFN( eDbgLevelWarning, "cs=%04lx, ss=%04lx, ds=%04lx, es=%04lx, fs=%04lx, gs=%04lx\n", 
            lpContext->SegCs, 
            lpContext->SegSs, 
            lpContext->SegDs, 
            lpContext->SegEs,
            lpContext->SegFs,
            lpContext->SegGs);
    #endif

    LONG lRet;

    if (bIgnore) 
    {
        if ((DWORD)lpContext->Eip <= (DWORD)0xFFFF)
        {
            LOGN( eDbgLevelError, "[ExceptionFilter] Exception %S (%08X), stuck at bad address, killing current thread.", szException, dwCode);    
            lRet = EXCEPTION_CONTINUE_SEARCH;
            return lRet;
        }

        LOGN( eDbgLevelWarning, "[ExceptionFilter] Exception %S (%08X) ignored.", szException, dwCode);

        lpContext->Eip += GetInstructionLengthFromAddress((LPBYTE)lpContext->Eip);
        g_dwLastEip = 0;
        lRet = EXCEPTION_CONTINUE_EXECUTION;
    }
    else
    {
        DPFN( eDbgLevelWarning, "Exception NOT handled\n\n");
        lRet = EXCEPTION_CONTINUE_SEARCH;
    }

    return lRet;
}

/*++

 Parse the command line for particular exceptions. The format of the command
 line is:

    [EXCEPTION_NAME[:0|1|2]];[EXCEPTION_NAME[:0|1|2]]...

 or "*" which ignores all first chance exceptions.

 Eg:
    ACCESS_VIOLATION:2;PRIV_INSTRUCTION:0;BREAKPOINT

 Will ignore:
    1. Access violations            - second chance
    2. Priviliged mode instructions - do not ignore
    3. Breakpoints                  - ignore

--*/

BOOL 
ParseCommandLine(
    LPCSTR lpCommandLine
    )
{
    CSTRING_TRY
    {
        CStringToken csTok(lpCommandLine, L" ;");
        int iLast = -1;
    
        //
        // Run the string, looking for exception names
        //
        
        CString token;
    
        // Each cl token may be followed by a : and an exception type
        // Forms can be:
        // *
        // *:SecondChance
        // INVALID_DISPOSITION
        // INVALID_DISPOSITION:Active
        // INVALID_DISPOSITION:0
        //
 
        while (csTok.GetToken(token))
        {
            CStringToken csSingleTok(token, L":");

            CString csExcept;
            CString csType;

            // grab the exception name and the exception type
            csSingleTok.GetToken(csExcept);
            csSingleTok.GetToken(csType);
            
            // Convert ignore value to emode (defaults to eFirstChance)
            EMODE emode = ToEmode(csType);

            if (token.Compare(L"*") == 0)
            {
                for (int i = 0; i < ELISTSIZE; i++)
                {
                    g_eList[i].dwIgnore = emode;
                }
            }
            else
            {
                // Find the exception specified
                for (int i = 0; i < ELISTSIZE; i++)
                {
                    if (csExcept.CompareNoCase(g_eList[i].cName) == 0)
                    {
                        g_eList[i].dwIgnore = emode;
                        break;
                    }
                }
            }
        }
    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    //
    // Dump results of command line parse
    //

    DPFN( eDbgLevelInfo, "===================================\n");
    DPFN( eDbgLevelInfo, "          Ignore Exception         \n");
    DPFN( eDbgLevelInfo, "===================================\n");
    DPFN( eDbgLevelInfo, "  1 = First chance                 \n");
    DPFN( eDbgLevelInfo, "  2 = Second chance                \n");
    DPFN( eDbgLevelInfo, "  3 = ExitProcess on second chance \n");
    DPFN( eDbgLevelInfo, "-----------------------------------\n");
    for (int i = 0; i < ELISTSIZE; i++)
    {
        if (g_eList[i].dwIgnore != eActive)
        {
            DPFN( eDbgLevelInfo, "%S %S\n", ToWchar(g_eList[i].dwIgnore), g_eList[i].cName);
        }
    }

    DPFN( eDbgLevelInfo, "-----------------------------------\n");

    return TRUE;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        // Run the command line to check for adjustments to defaults
        if (!ParseCommandLine(COMMAND_LINE))
        {
            return FALSE;
        }
    
        // Try to find new exception handler
        _pfn_RtlAddVectoredExceptionHandler pfnExcept;
        pfnExcept = (_pfn_RtlAddVectoredExceptionHandler)
            GetProcAddress(
                GetModuleHandle(L"NTDLL.DLL"), 
                "RtlAddVectoredExceptionHandler");

        if (pfnExcept)
        {
            (_pfn_RtlAddVectoredExceptionHandler) pfnExcept(
                0, 
                (PVOID)ExceptionFilter);
            g_bWin2000 = FALSE;
        }
        else
        {
            // Windows 2000 reverts back to the old method which unluckily 
            // doesn't get called for C++ exceptions

            SetUnhandledExceptionFilter(ExceptionFilter);
            g_bWin2000 = TRUE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\main.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Main.cpp

 Abstract:

 Notes:

 History:

    15/11/2000 clupu Created

--*/

#include "precomp.h"

#include "ShimHookMacro.h"
                        
DECLARE_SHIM(AddWritePermissionsToDeviceFiles)
DECLARE_SHIM(ChangeAuthenticationLevel)
DECLARE_SHIM(CorrectBitmapHeader)
DECLARE_SHIM(CorrectCreateEventName)
DECLARE_SHIM(CorrectFilePaths)
DECLARE_SHIM(CorrectSoundDeviceId)
DECLARE_SHIM(DirectPlayEnumOrder)
DECLARE_SHIM(DuplicateHandleFix)
DECLARE_SHIM(EmulateBitmapStride)
DECLARE_SHIM(EmulateCDFS)
DECLARE_SHIM(EmulateClipboardDIBFormat)
DECLARE_SHIM(EmulateCreateFileMapping)
DECLARE_SHIM(EmulateCreateProcess)
DECLARE_SHIM(EmulateDeleteObject)
DECLARE_SHIM(EmulateDirectDrawSync)
DECLARE_SHIM(EmulateDrawText)
DECLARE_SHIM(EmulateEnvironmentBlock)
DECLARE_SHIM(EmulateFindHandles)
DECLARE_SHIM(EmulateGetCommandLine)
DECLARE_SHIM(EmulateGetDeviceCaps)
DECLARE_SHIM(EmulateGetDiskFreeSpace)
DECLARE_SHIM(EmulateJoystick)
DECLARE_SHIM(EmulateGetProfileString)
DECLARE_SHIM(EmulateHeap)
DECLARE_SHIM(EmulateMissingEXE)
DECLARE_SHIM(EmulatePlaySound)
DECLARE_SHIM(EmulatePrinter)
DECLARE_SHIM(EmulateSlowCPU)
DECLARE_SHIM(EmulateTextColor)
DECLARE_SHIM(EmulateToolHelp32)
DECLARE_SHIM(EmulateUSER);
DECLARE_SHIM(EmulateVerQueryValue)
DECLARE_SHIM(EmulateWriteFile)
DECLARE_SHIM(EnableRestarts)
DECLARE_SHIM(FileVersionInfoLie)
DECLARE_SHIM(FeedbackReport)
DECLARE_SHIM(Force640x480)
DECLARE_SHIM(Force8BitColor)
DECLARE_SHIM(ForceAnsiGetDisplayNameOf)
DECLARE_SHIM(ForceCDStop)
DECLARE_SHIM(ForceCoInitialize)
DECLARE_SHIM(ForceDXSetupSuccess)
DECLARE_SHIM(ForceKeepFocus)
DECLARE_SHIM(ForceMessageBoxFocus)
DECLARE_SHIM(ForceShellLinkResolveNoUI)
DECLARE_SHIM(HandleAPIExceptions)
DECLARE_SHIM(HandleRegExpandSzRegistryKeys)
DECLARE_SHIM(HandleWvsprintfExceptions)
DECLARE_SHIM(HideDisplayModes)
DECLARE_SHIM(IgnoreException)
DECLARE_SHIM(IgnoreLoadLibrary)
DECLARE_SHIM(IgnoreOleUninitialize)
DECLARE_SHIM(IgnoreScheduler)
DECLARE_SHIM(MapMemoryB0000)
DECLARE_SHIM(ProfilesEnvStrings)
DECLARE_SHIM(ProfilesGetFolderPath)
DECLARE_SHIM(ProfilesRegQueryValueEx)
DECLARE_SHIM(Shrinker)
DECLARE_SHIM(SingleProcAffinity)
DECLARE_SHIM(SyncSystemAndSystem32)
DECLARE_SHIM(VirtualRegistry)
DECLARE_SHIM(Win2000VersionLie)
DECLARE_SHIM(Win2000SP1VersionLie)
DECLARE_SHIM(Win95VersionLie)
DECLARE_SHIM(Win98VersionLie)
DECLARE_SHIM(WinExecRaceConditionFix)
DECLARE_SHIM(WinNT4SP5VersionLie)
DECLARE_SHIM(Win2kPropagateLayer)


VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPF("AcLayers", eDbgLevelSpew, "Layer Shims initialized.");
            break;
    
        case DLL_PROCESS_DETACH:
            DPF("AcLayers", eDbgLevelSpew, "Layer Shims uninitialized.");
            break;

        default:
            break;
    }
}

MULTISHIM_BEGIN()
    MULTISHIM_ENTRY(AddWritePermissionsToDeviceFiles)
    MULTISHIM_ENTRY(ChangeAuthenticationLevel)
    MULTISHIM_ENTRY(CorrectBitmapHeader)
    MULTISHIM_ENTRY(CorrectCreateEventName)
    MULTISHIM_ENTRY(CorrectFilePaths)
    MULTISHIM_ENTRY(CorrectSoundDeviceId)
    MULTISHIM_ENTRY(DirectPlayEnumOrder)
    MULTISHIM_ENTRY(DuplicateHandleFix)
    MULTISHIM_ENTRY(EmulateBitmapStride)
    MULTISHIM_ENTRY(EmulateCDFS)
    MULTISHIM_ENTRY(EmulateClipboardDIBFormat)
    MULTISHIM_ENTRY(EmulateCreateFileMapping)
    MULTISHIM_ENTRY(EmulateCreateProcess)
    MULTISHIM_ENTRY(EmulateDeleteObject)
    MULTISHIM_ENTRY(EmulateDirectDrawSync)
    MULTISHIM_ENTRY(EmulateDrawText)
    MULTISHIM_ENTRY(EmulateEnvironmentBlock)
    MULTISHIM_ENTRY(EmulateFindHandles)
    MULTISHIM_ENTRY(EmulateGetCommandLine)
    MULTISHIM_ENTRY(EmulateGetDeviceCaps)
    MULTISHIM_ENTRY(EmulateGetDiskFreeSpace)
    MULTISHIM_ENTRY(EmulateGetProfileString)
    MULTISHIM_ENTRY(EmulateJoystick)
    MULTISHIM_ENTRY(EmulateHeap)
    MULTISHIM_ENTRY(EmulateMissingEXE)
    MULTISHIM_ENTRY(EmulatePlaySound)
    MULTISHIM_ENTRY(EmulatePrinter)
    MULTISHIM_ENTRY(EmulateSlowCPU)
    MULTISHIM_ENTRY(EmulateTextColor)
    MULTISHIM_ENTRY(EmulateToolHelp32)
    MULTISHIM_ENTRY(EmulateUSER)
    MULTISHIM_ENTRY(EmulateVerQueryValue)
    MULTISHIM_ENTRY(EmulateWriteFile)
    MULTISHIM_ENTRY(EnableRestarts)
    MULTISHIM_ENTRY(FeedbackReport)
    MULTISHIM_ENTRY(FileVersionInfoLie)
    MULTISHIM_ENTRY(Force640x480)
    MULTISHIM_ENTRY(Force8BitColor)
    MULTISHIM_ENTRY(ForceAnsiGetDisplayNameOf)
    MULTISHIM_ENTRY(ForceCDStop)
    MULTISHIM_ENTRY(ForceCoInitialize)
    MULTISHIM_ENTRY(ForceDXSetupSuccess)
    MULTISHIM_ENTRY(ForceKeepFocus)
    MULTISHIM_ENTRY(ForceMessageBoxFocus)
    MULTISHIM_ENTRY(ForceShellLinkResolveNoUI)
    MULTISHIM_ENTRY(HandleAPIExceptions)
    MULTISHIM_ENTRY(HandleRegExpandSzRegistryKeys)
    MULTISHIM_ENTRY(HandleWvsprintfExceptions)
    MULTISHIM_ENTRY(HideDisplayModes)
    MULTISHIM_ENTRY(IgnoreException)
    MULTISHIM_ENTRY(IgnoreLoadLibrary)
    MULTISHIM_ENTRY(IgnoreOleUninitialize)
    MULTISHIM_ENTRY(IgnoreScheduler)
    MULTISHIM_ENTRY(MapMemoryB0000)
    MULTISHIM_ENTRY(ProfilesEnvStrings)
    MULTISHIM_ENTRY(ProfilesGetFolderPath)
    MULTISHIM_ENTRY(ProfilesRegQueryValueEx)
    MULTISHIM_ENTRY(Shrinker)
    MULTISHIM_ENTRY(SingleProcAffinity)
    MULTISHIM_ENTRY(SyncSystemAndSystem32)
    MULTISHIM_ENTRY(VirtualRegistry)
    MULTISHIM_ENTRY(Win2000VersionLie)
    MULTISHIM_ENTRY(Win2000SP1VersionLie)
    MULTISHIM_ENTRY(Win95VersionLie)
    MULTISHIM_ENTRY(Win98VersionLie)
    MULTISHIM_ENTRY(WinExecRaceConditionFix)
    MULTISHIM_ENTRY(WinNT4SP5VersionLie)
    MULTISHIM_ENTRY(Win2kPropagateLayer)


    CALL_MULTISHIM_NOTIFY_FUNCTION()
MULTISHIM_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\ignorescheduler.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreScheduler.cpp

 Abstract:

    Includes the following hooks:
    
    SetThreadPriority: Normalize the thread priority to prevent some application synchronization 
    issues.
    
    SetPriorityClass: Normalize process class. 
    
    SuspendThread:  Prevent a thread from suspending itself.
    
    ResumeThread: Prevent a thread from resumming itself.

 Notes:

    This is a general purpose shim.

 History:

    10/20/2000 jpipkins  Created: SetPriorityClass created and merged with SetThreadPriority(linstev),
    SuspendThread/ResumeThread(dmunsil/a-brienw).

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreScheduler)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(SetThreadPriority)
    APIHOOK_ENUM_ENTRY(SetPriorityClass)
    APIHOOK_ENUM_ENTRY(ResumeThread)
    APIHOOK_ENUM_ENTRY(SuspendThread)
APIHOOK_ENUM_END

/*++

 Remove any creation flags that specify process priority.

--*/

#define PRIORITYMASK (ABOVE_NORMAL_PRIORITY_CLASS | BELOW_NORMAL_PRIORITY_CLASS | HIGH_PRIORITY_CLASS | IDLE_PRIORITY_CLASS | REALTIME_PRIORITY_CLASS)

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if (dwCreationFlags & PRIORITYMASK) {
        LOGN(eDbgLevelInfo, "[CreateProcessA] Forcing priority class to normal");
    
        dwCreationFlags &= ~PRIORITYMASK;
        dwCreationFlags |= NORMAL_PRIORITY_CLASS;
    }
    
    return ORIGINAL_API(CreateProcessA)(lpApplicationName, lpCommandLine,
                lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
                dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,             
                lpProcessInformation);
}

/*++

 Remove any creation flags that specify process priority.

--*/

BOOL 
APIHOOK(CreateProcessW)(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if (dwCreationFlags & PRIORITYMASK) {
        LOGN(eDbgLevelInfo, "[CreateProcessW] Forcing priority class to normal");
    
        dwCreationFlags &= ~PRIORITYMASK;
        dwCreationFlags |= NORMAL_PRIORITY_CLASS;
    }

    return ORIGINAL_API(CreateProcessW)(lpApplicationName, lpCommandLine, 
                lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
                dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,
                lpProcessInformation);
}

/*++

 Normalize thread priority.

--*/

BOOL 
APIHOOK(SetThreadPriority)(
    HANDLE hThread, 
    int    nPriority   
    )
{
    if (nPriority != THREAD_PRIORITY_NORMAL) {
        LOGN(
            eDbgLevelInfo,
            "[SetThreadPriority] Forcing thread priority to normal.");
    }

    return ORIGINAL_API(SetThreadPriority)(hThread, THREAD_PRIORITY_NORMAL);
}

/*++

 Normalize Class priority.

--*/

BOOL 
APIHOOK(SetPriorityClass)(
    HANDLE hProcess, 
    DWORD  dwPriorityClass   
    )
{
    if (dwPriorityClass != NORMAL_PRIORITY_CLASS) {
        LOGN(
            eDbgLevelInfo,
            "[SetPriorityClass] Forcing priority class to normal.");
    }

    return ORIGINAL_API(SetPriorityClass)(hProcess, NORMAL_PRIORITY_CLASS);
}

/*++

 Get Thread ID for ResumeThread and SuspendThread Hooks

--*/


DWORD
dwGetThreadID(
    HANDLE hThread
    )
{
    THREAD_BASIC_INFORMATION ThreadBasicInfo;
    NTSTATUS                 Status;

    Status = NtQueryInformationThread(hThread,
                                      ThreadBasicInformation,
                                      &ThreadBasicInfo,
                                      sizeof(ThreadBasicInfo),
                                      NULL);

    if (NT_SUCCESS(Status)) {
        return (DWORD)ThreadBasicInfo.ClientId.UniqueThread;
    } else {
        LOGN(
            eDbgLevelError,
            "[dwGetThreadID] NtQueryInfomationThread failed.");
        return 0;
    }
}

/*++

 Disallow suspending self

--*/

DWORD
APIHOOK(SuspendThread)(
    HANDLE hThread   // handle to the thread
    )
{
    //
    // If we're trying to suspend our own thread, refuse.
    //
    if (dwGetThreadID(hThread) != dwGetThreadID(GetCurrentThread())) {
        return ORIGINAL_API(SuspendThread)(hThread);
    } else {
        return 0;
    }
}

/*++

 Disallow resuming self, for same reason

--*/

DWORD
APIHOOK(ResumeThread)(
    HANDLE hThread   // handle to the thread
    )
{
    //
    // If we're trying to resume our own thread, refuse.
    //
    if (dwGetThreadID(hThread) != dwGetThreadID(GetCurrentThread())) {
        return ORIGINAL_API(ResumeThread)(hThread);
    } else {
        return 0;
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)
    APIHOOK_ENTRY(KERNEL32.DLL, SetThreadPriority)
    APIHOOK_ENTRY(KERNEL32.DLL, SetPriorityClass)
    APIHOOK_ENTRY(KERNEL32.DLL, SuspendThread)
    APIHOOK_ENTRY(KERNEL32.DLL, ResumeThread)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\profilesenvstrings.cpp ===
/*

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ProfilesEnvStrings.cpp

 Abstract:

   This DLL hooks GetEnvironmentVariableA and ExpandEnvironmentStringsA. Any application
   that is looking for %USERPROFILE% will be told the location of %ALLUSERSPROFILE% instead.

   This shim is designed to fool install apps that use env variables obtain the users profile
   location.

 Notes:

 History:

    08/07/2000  reinerf Created
    02/28/2001  robkenny    Converted to CString
*/

#include "precomp.h"


IMPLEMENT_SHIM_BEGIN(ProfilesEnvStrings)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetEnvironmentVariableA)
    APIHOOK_ENUM_ENTRY(ExpandEnvironmentStringsA)
APIHOOK_ENUM_END


// if apps try to read the %USERPROFILE% env variable, we lie to them
DWORD
APIHOOK(GetEnvironmentVariableA)(
    LPCSTR lpName,      // environment variable name
    LPSTR  lpBuffer,    // buffer for variable value
    DWORD  nSize        // size of buffer
    )
{
    if (lstrcmpiA(lpName, "USERPROFILE") == 0) {
        LOGN(
            eDbgLevelInfo,
            "[GetEnvironmentVariableA] overriding USERPROFILE with ALLUSERSPROFILE.");
        
        return ORIGINAL_API(GetEnvironmentVariableA)("ALLUSERSPROFILE", lpBuffer, nSize);
    }

    return ORIGINAL_API(GetEnvironmentVariableA)(lpName, lpBuffer, nSize);
}


DWORD
APIHOOK(ExpandEnvironmentStringsA)(
    LPCSTR lpSrc,       // string with environment variables
    LPSTR lpDst,        // string with expanded strings 
    DWORD nSize         // maximum characters in expanded string
    )
{
    DWORD dwRet = 0;

    CSTRING_TRY
    {
        // replace UserProfile with AllUserProfile
        CString csEnvironments(lpSrc);
        csEnvironments.ReplaceI(L"%userprofile%", L"%alluserprofile%");
        dwRet = ORIGINAL_API(ExpandEnvironmentStringsA)(csEnvironments.GetAnsi(), lpDst, nSize);
    }
    CSTRING_CATCH
    {
        dwRet = ORIGINAL_API(ExpandEnvironmentStringsA)(lpSrc, lpDst, nSize);
    }

    return dwRet;
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        
        OSVERSIONINFOEX osvi = {0};
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        
        if (GetVersionEx((OSVERSIONINFO*)&osvi)) {
            
            if (!((VER_SUITE_TERMINAL & osvi.wSuiteMask) &&
                !(VER_SUITE_SINGLEUSERTS & osvi.wSuiteMask))) {
                
                //
                // Only install hooks if we are not on a "Terminal Server"
                // (aka "Application Server") machine.
                //
                APIHOOK_ENTRY(KERNEL32.DLL, GetEnvironmentVariableA);
                APIHOOK_ENTRY(KERNEL32.DLL, ExpandEnvironmentStringsA);
            }
        }
    }
    
    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\profilesgetfolderpath.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ProfilesGetFolderPath.cpp

 Abstract:

    This DLL hooks shell32!SHGetFolderLocation, shell32!SHGetSpecialFolderLocation, and
    shell32!SHGetFolderPathA. Any application that is looking for a per-user CSIDL will 
    be returned the corosponding all-users location instead.

    This shim is designed to fool install apps that call shell32.dll api's to obtain
    shell folder locations.

 History:

    08/07/2000  reinerf Created
    05/11/2001  markder Modified   Removed Desktop redirection as it makes the shim
                                   too invasive.
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ProfilesGetFolderPath)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SHGetFolderLocation)
    APIHOOK_ENUM_ENTRY(SHGetSpecialFolderLocation)
    APIHOOK_ENUM_ENTRY(SHGetFolderPathA)
APIHOOK_ENUM_END


int
TranslateCSIDL(
    int nFolder
    )
{
    switch (nFolder) {

    case CSIDL_STARTMENU:
        DPFN(
            eDbgLevelInfo,
            "[TranslateCSIDL] overriding CSIDL_STARTMENU with CSIDL_COMMON_STARTMENU\n");
        return CSIDL_COMMON_STARTMENU;
        break;

    case CSIDL_STARTUP:
        DPFN(
            eDbgLevelInfo,
            "[TranslateCSIDL] overriding CSIDL_STARTUP with CSIDL_COMMON_STARTUP\n");
        return CSIDL_COMMON_STARTUP;
        break;

    case CSIDL_PROGRAMS:
        DPFN(
            eDbgLevelInfo,
            "[TranslateCSIDL] overriding CSIDL_PROGRAMS with CSIDL_COMMON_PROGRAMS\n");
        return CSIDL_COMMON_PROGRAMS;
        break;

    default:
        return nFolder;
    }
}


HRESULT
APIHOOK(SHGetSpecialFolderLocation)(
    HWND          hwndOwner, 
    int           nFolder,
    LPITEMIDLIST* ppidl
    )
{
    return ORIGINAL_API(SHGetSpecialFolderLocation)(hwndOwner,
                                                    TranslateCSIDL(nFolder),
                                                    ppidl);
}


HRESULT
APIHOOK(SHGetFolderLocation)(
    HWND          hwndOwner,
    int           nFolder,
    HANDLE        hToken,
    DWORD         dwReserved,
    LPITEMIDLIST* ppidl
    )
{
    return ORIGINAL_API(SHGetFolderLocation)(hwndOwner,
                                             TranslateCSIDL(nFolder),
                                             hToken,
                                             dwReserved,
                                             ppidl);
}


HRESULT
APIHOOK(SHGetFolderPathA)(
    HWND   hwndOwner,
    int    nFolder,
    HANDLE hToken,
    DWORD  dwFlags,
    LPSTR  pszPath
    )
{
    return ORIGINAL_API(SHGetFolderPathA)(hwndOwner,
                                          TranslateCSIDL(nFolder),
                                          hToken,
                                          dwFlags,
                                          pszPath);
}


// Register hooked functions
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        
        OSVERSIONINFOEX osvi = {0};
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        if (GetVersionEx((OSVERSIONINFO*)&osvi)) {
            
            if (!((VER_SUITE_TERMINAL & osvi.wSuiteMask) &&
                  !(VER_SUITE_SINGLEUSERTS & osvi.wSuiteMask))) {
                //
                // Only install hooks if we are not on a "Terminal Server"
                // (aka "Application Server") machine.
                //
                APIHOOK_ENTRY(SHELL32.DLL, SHGetFolderLocation);
                APIHOOK_ENTRY(SHELL32.DLL, SHGetSpecialFolderLocation);
                APIHOOK_ENTRY(SHELL32.DLL, SHGetFolderPathA);
            }
        }
    }
    
    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\singleprocaffinity.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SingleProcAffinity.cpp

 Abstract:

    Make the process have single processor affinity to workaround bugs that
    are exposed in multi-processor environments.
   
 Notes:

    This is a general purpose shim.

 History:

    03/19/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SingleProcAffinity)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Set single processor affinity
        // 
        SetProcessAffinityMask(GetCurrentProcess(), 1);

        LOGN( eDbgLevelInfo, "[NotifyFn] Single processor affinity set");
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\shrinker.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Shrinker.cpp

 Abstract:

    Fix Shrinker library problem. This library is hacking some ntdll and kernel32 opcode
    with unreliable way to do it.

    First, they try to search the matching opcode within 32 bytes from the hacked 
    function (the function address retrieved from GetProcAddress and the opcode bytes
    retrieved via ReadProcessMemory).
    If they found it, then they replaced it with their opcode to redirect the call
    into their own routine.

    Unfortunately, opcode in Whistler has changed. So, the result will be unpredictable.
    They could be ended up with unexpected behavior from misreplacement of opcode
    or the app decided to terminated itself since the matching opcode can't be found.

    We fixed this by providing an exact matching opcode.

    Addition:  Shrinker also checks against ExitProcess for exact opcodes, these
    values have recently changed and no longer match against their hard coded
    values.  We now provide matching opcodes for ExitProcess also.
   
 Notes:

   Hooking ntdll!LdrAccessResource to emulate Win2K's version of it.
   Hooking Kernel32!ExitProcess to emulate Win2K's version of it.

 History:

   11/17/2000 andyseti  Created
   04/30/2001 mnikkel   Added ExitProcess
   05/01/2001 mnikkel   Corrected calls to ldraccessresource and exitprocess

--*/

#include "precomp.h"
#include <nt.h>


IMPLEMENT_SHIM_BEGIN(Shrinker)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LdrAccessResource) 
    APIHOOK_ENUM_ENTRY(ExitProcess) 
APIHOOK_ENUM_END

__declspec(naked)
NTSTATUS
APIHOOK(LdrAccessResource)(
    IN PVOID /*DllHandle*/,
    IN const IMAGE_RESOURCE_DATA_ENTRY* /*ResourceDataEntry*/,
    OUT PVOID * /*Address*/ OPTIONAL,
    OUT PULONG /*Size*/ OPTIONAL)
{
    _asm {
        push [esp+0x10]     // shrinker lib needs these opcode signature (found in Win2K), -
        push [esp+0x10]     // but the actual LdrAccessResource doesn't have them
        push [esp+0x10]
        push [esp+0x10]

        call dword ptr [LdrAccessResource]

        ret 0x10            // when exit, pop 16 bytes from stack.
    }
}

__declspec(naked)
VOID
APIHOOK(ExitProcess)(
    UINT uExitCode
    )
{
    _asm {
        push ebp             // shrinker is looking for these exact op codes in
        mov  ebp,esp         // ExitProcess, but the routine has changed.
        push 0xFFFFFFFF
        push 0x77e8f3b0

        push [ebp+4]
        call dword ptr [ExitProcess]

        pop  ebp
        ret  4 
    }
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(NTDLL.DLL, LdrAccessResource)
    APIHOOK_ENTRY(KERNEL32.DLL, ExitProcess)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

!ENDIF

INCLUDES=$(INCLUDES);                       \
         ..;                                \
         $(SHELL_INC_PATH);                 \
         $(BASE_INC_PATH);                  \
         $(WINDOWS_INC_PATH)

TARGETNAME=AcLayers

TARGETTYPE=DYNLINK

SOURCES=..\Layer.rc                                \
        ..\Main.cpp                                \
        ..\AddWritePermissionsToDeviceFiles.cpp    \
        ..\ChangeAuthenticationLevel.cpp           \
        ..\CorrectBitmapHeader.cpp                 \
        ..\CorrectCreateEventName.cpp              \
        ..\CorrectFilePaths.cpp                    \
        ..\CorrectSoundDeviceId.cpp                \
        ..\DirectPlayEnumOrder.cpp                 \
        ..\DuplicateHandleFix.cpp                  \
        ..\EmulateBitmapStride.cpp                 \
        ..\EmulateCDFS.cpp                         \
        ..\EmulateClipboardDIBFormat.cpp           \
        ..\EmulateCreateFileMapping.cpp            \
        ..\EmulateCreateProcess.cpp                \
        ..\EmulateDeleteObject.cpp                 \
        ..\EmulateDirectDrawSync.cpp               \
        ..\EmulateDrawText.cpp                     \
        ..\EmulateEnvironmentBlock.cpp             \
        ..\EmulateFindHandles.cpp                  \
        ..\EmulateGetCommandLine.cpp               \
        ..\EmulateGetDeviceCaps.cpp                \
        ..\EmulateGetDiskFreeSpace.cpp             \
        ..\EmulateGetProfileString.cpp             \
        ..\EmulateHeap.cpp                         \
        ..\EmulateHeap_support.c                   \
        ..\EmulateHeap_heap.c                      \
        ..\EmulateHeap_lmem.c                      \
        ..\EmulateJoystick.cpp                     \
        ..\EmulateMissingEXE.cpp                   \
        ..\EmulatePlaySound.cpp                    \
        ..\EmulatePrinter.cpp                      \
        ..\EmulateSlowCPU.cpp                      \
        ..\EmulateTextColor.cpp                    \
        ..\EmulateToolHelp32.cpp                   \
        ..\EmulateUSER.cpp                         \
        ..\EmulateVerQueryValue.cpp                \
        ..\EmulateWriteFile.cpp                    \
        ..\EnableRestarts.cpp                      \
        ..\FeedbackReport.cpp                      \
        ..\FileVersionInfoLie.cpp                  \
        ..\Force640x480.cpp                        \
        ..\Force8BitColor.cpp                      \
        ..\ForceAnsiGetDisplayNameOf.cpp           \
        ..\ForceCDStop.cpp                         \
        ..\ForceCoInitialize.cpp                   \
        ..\ForceDxSetupSuccess.cpp                 \
        ..\ForceKeepFocus.cpp                      \
        ..\ForceMessageBoxFocus.cpp                \
        ..\ForceShellLinkResolveNoUI.cpp           \
        ..\HandleAPIExceptions.cpp                 \
        ..\HandleRegExpandSzRegistryKeys.cpp       \
        ..\HandleWvsprintfExceptions.cpp           \
        ..\HideDisplayModes.cpp                    \
        ..\IgnoreException_86dis.cpp               \
        ..\IgnoreException.cpp                     \
        ..\IgnoreLoadLibrary.cpp                   \
        ..\IgnoreOleUninitialize.cpp               \
        ..\IgnoreScheduler.cpp                     \
        ..\MapMemoryB0000.cpp                      \
        ..\ProfilesEnvStrings.cpp                  \
        ..\ProfilesGetFolderPath.cpp               \
        ..\ProfilesRegQueryValueEx.cpp             \
        ..\Shrinker.cpp                            \
        ..\SingleProcAffinity.cpp                  \
        ..\SyncSystemAndSystem32.cpp               \
        ..\VRegistry_Custom.cpp                    \
        ..\VRegistry_DSound.cpp                    \
        ..\VRegistry_Worker.cpp                    \
        ..\VRegistry.cpp                           \
        ..\Win2000VersionLie.cpp                   \
        ..\Win2000SP1VersionLie.cpp                \
        ..\Win95VersionLie.cpp                     \
        ..\Win98VersionLie.cpp                     \
        ..\WinExecRaceConditionFix.cpp             \
        ..\WinNT4SP5VersionLie.cpp                 \
        ..\Win2kPropagateLayer.cpp                 \
        ..\Win2kPropagateLayer_Cleanup.cpp         \
        ..\Win2kPropagateLayer_Environment.cpp     \
        ..\Win2kPropagateLayer_WowTask.cpp


C_DEFINES=$(C_DEFINES) -DSHIM_HOOKDLL_VERSION2

TARGETPATH=$(_OBJ_DIR)

TARGETLIBS=$(TARGETLIBS)                        \
           $(SDK_LIB_PATH)\ntdll.lib            \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\gdi32.lib            \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\shell32.lib          \
           $(SDK_LIB_PATH)\shlwapi.lib          \
           $(SDK_LIB_PATH)\ole32.lib            \
           $(SDK_LIB_PATH)\userenv.lib          \
           $(SDK_LIB_PATH)\winspool.lib         \
           $(PROJECT_ROOT)\appcompat\sdbAPI\lib\$(O)\sdbapil.lib \
           $(SDK_LIB_PATH)\version.lib

DELAYLOAD = version.dll

DLOAD_ERROR_HANDLER=shell32.dll

DLLBASE=0x23000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\profilesregqueryvalueex.cpp ===
/*

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   RegQueryValueEx.cpp

 Abstract:

   This DLL hooks RegQueryValueExA so that we can return the "all-users" location
   for the StartMenu, Desktop and Startup folders instead of the per-user location.

   We also hook RegCreateKeyA/RegCreateKeyExA to make people who add entries to the
   HKCU "run" and "Uninstall" keys really add them to HKLM.

 Notes:

 History:

    08/07/2000  reinerf     Created
    02/27/2001  robkenny    Converted to use CString

*/

#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(ProfilesRegQueryValueEx)
#include "ShimHookMacro.h"

#include <shlwapi.h>    // for StrRStrIA

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
APIHOOK_ENUM_END


#ifndef MAX
#define MAX(x,y) (((x) > (y)) ? (x) : (y))
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

LPCSTR g_aBadKeys[] = 
{
    {"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"},
    {"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"},
};

LPCSTR g_aBadShellFolderKeys[] = 
{
    {"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"},
    {"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"},
};


// given an hkey, call NtQueryObject to lookup its name.
// returns strings in the format: "\REGISTRY\USER\S-1-5-xxxxx\Software\Microsoft\Windows\CurrentVersion"
BOOL GetKeyName(HKEY hk, LPSTR pszName, DWORD cchName)
{
    BOOL bRet = FALSE;
    ULONG cbSize = 0;

    // get the size needed for the name buffer
    NtQueryObject(hk, ObjectNameInformation, NULL, 0, &cbSize);

    if (cbSize)
    {
        POBJECT_NAME_INFORMATION pNameInfo = (POBJECT_NAME_INFORMATION)LocalAlloc(LPTR, cbSize);

        if (pNameInfo)
        {
            NTSTATUS status = NtQueryObject(hk, ObjectNameInformation, (void*)pNameInfo, cbSize, NULL);
        
            if (NT_SUCCESS(status) && WideCharToMultiByte(CP_ACP, 0, pNameInfo->Name.Buffer, -1, pszName, cchName, NULL, NULL))
            {
                bRet = TRUE;
            }

            LocalFree(pNameInfo);
        }
    }

    return bRet;
}


// If hk points underneath HKCU and matches pszSearchName, then return TRUE
BOOL DoesKeyMatch(HKEY hk, LPCSTR pszSearchName)
{
    BOOL bRet = FALSE;

    // make sure it is not one of the pre-defined keys (eg HKEY_LOCAL_MACHINE)
    if (!((LONG)((ULONG_PTR)hk) & 0x80000000))
    {
        CHAR szKeyName[MAX_PATH * 2];  // should be big enought to hold any registry key path

        if (GetKeyName(hk, szKeyName, ARRAYSIZE(szKeyName)))
        {
            // is the key under HKCU ?
            if (StrCmpNIA(szKeyName, "\\REGISTRY\\USER\\", ARRAYSIZE("\\REGISTRY\\USER\\")-1) == 0)
            {
                LPSTR psz = StrRStrIA(szKeyName, NULL, pszSearchName);

                if (psz && (lstrlenA(psz) == lstrlenA(pszSearchName)))
                {
                    // we found a substring and its the same length, so our hkey matches the search!
                    bRet = TRUE;
                }
            }
        }
    }

    return bRet;
}


BOOL IsBadHKCUKey(HKEY hk, LPCSTR* ppszNewKey)
{
    BOOL bRet = FALSE;
    int i;

    for (i=0; i < ARRAYSIZE(g_aBadKeys); i++)
    {
        if (DoesKeyMatch(hk, g_aBadKeys[i]))
        {
            *ppszNewKey = g_aBadKeys[i];
            bRet = TRUE;
            break;
        }
    }

    return bRet;
}


BOOL IsBadShellFolderKey(HKEY hk, LPCSTR* ppszNewKey)
{
    BOOL bRet = FALSE;
    int i;

    for (i=0; i < ARRAYSIZE(g_aBadShellFolderKeys); i++)
    {
        if (DoesKeyMatch(hk, g_aBadShellFolderKeys[i]))
        {
            *ppszNewKey = g_aBadShellFolderKeys[i];
            bRet = TRUE;
            break;
        }
    }

    return bRet;
}


LONG
APIHOOK(RegCreateKeyA)(
    HKEY   hKey,
    LPCSTR pszSubKey,
    PHKEY  phkResult
    )
{
    LPCSTR pszNewHKLMKey;
    LONG lRet = ORIGINAL_API(RegCreateKeyA)(hKey, pszSubKey, phkResult);

    if ((lRet == ERROR_SUCCESS) &&
        IsBadHKCUKey(*phkResult, &pszNewHKLMKey))
    {
        // its a bad HKCU key-- redirect to HKLM
        RegCloseKey(*phkResult);

        lRet = ORIGINAL_API(RegCreateKeyA)(HKEY_LOCAL_MACHINE, pszNewHKLMKey, phkResult);
        
        LOGN(eDbgLevelInfo, "[RegCreateKeyA] overriding \"%s\" create key request w/ HKLM value (return = %d)", pszSubKey, lRet);
    }

    return lRet;
}


LONG
APIHOOK(RegCreateKeyExA)(
    HKEY                  hKey,
    LPCSTR                pszSubKey,
    DWORD                 Reserved,
    LPSTR                 lpClass,
    DWORD                 dwOptions,
    REGSAM                samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,
    LPDWORD               lpdwDisposition
    )
{
    LPCSTR pszNewHKLMKey;
    LONG lRet = ORIGINAL_API(RegCreateKeyExA)(hKey,
                                              pszSubKey,
                                              Reserved,
                                              lpClass,
                                              dwOptions,
                                              samDesired,
                                              lpSecurityAttributes,
                                              phkResult,
                                              lpdwDisposition);

    if ((lRet == ERROR_SUCCESS) &&
        IsBadHKCUKey(*phkResult, &pszNewHKLMKey))
    {
        // its a bad HCKU key-- redirect to HKLM
        RegCloseKey(*phkResult);

        lRet = ORIGINAL_API(RegCreateKeyExA)(HKEY_LOCAL_MACHINE,
                                             pszNewHKLMKey,
                                             Reserved,
                                             lpClass,
                                             dwOptions,
                                             samDesired,
                                             lpSecurityAttributes,
                                             phkResult,
                                             lpdwDisposition);

        LOGN(eDbgLevelInfo, "[RegCreateKeyExA] overriding \"%s\" create key request w/ HKLM value (return = %d)", pszSubKey, lRet);
    }

    return lRet;
}


LONG
APIHOOK(RegOpenKeyA)(
    HKEY   hKey,
    LPCSTR pszSubKey,
    PHKEY  phkResult
    )
{
    LPCSTR pszNewHKLMKey;
    LONG lRet = ORIGINAL_API(RegOpenKeyA)(hKey, pszSubKey, phkResult);

    if ((lRet == ERROR_SUCCESS) &&
        IsBadHKCUKey(*phkResult, &pszNewHKLMKey))
    {
        // its a bad HCKU key-- redirect to HKLM
        RegCloseKey(*phkResult);

        lRet = ORIGINAL_API(RegOpenKeyA)(HKEY_LOCAL_MACHINE, pszNewHKLMKey, phkResult);

        LOGN(eDbgLevelInfo, "[RegOpenKeyA] overriding \"%s\" create key request w/ HKLM value (return = %d)", pszSubKey, lRet);
    }
    
    return lRet;
}


LONG
APIHOOK(RegOpenKeyExA)(
    HKEY   hKey,
    LPCSTR pszSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY  phkResult
    )
{
    LPCSTR pszNewHKLMKey;
    LONG lRet = ORIGINAL_API(RegOpenKeyExA)(hKey, pszSubKey, ulOptions, samDesired, phkResult);

    if ((lRet == ERROR_SUCCESS) &&
        IsBadHKCUKey(*phkResult, &pszNewHKLMKey))
    {
        // its a bad HCKU key-- redirect to HKLM
        RegCloseKey(*phkResult);

        lRet = ORIGINAL_API(RegOpenKeyExA)(HKEY_LOCAL_MACHINE, pszNewHKLMKey, ulOptions, samDesired, phkResult);
        
        LOGN(eDbgLevelInfo, "[RegOpenKeyExA] overriding \"%s\" create key request w/ HKLM value (return = %d)", pszSubKey, lRet);
    }

    return lRet;
}


LONG
GetAllUsersRegValueA(
    LPSTR  szRegValue,
    DWORD  cbOriginal,
    DWORD* pcbData,
    int    nFolder,
    int    nFolderCommon
    )
{
    LONG lRet = ERROR_SUCCESS;

    if (!szRegValue)
    {
        // if the caller is querying for the necessary size, return the "worst case" since we don't know if
        // we are going to have to lie or not
        *pcbData = MAX_PATH;
    }
    else if (szRegValue[0] != '\0')
    {
        CHAR szPath[MAX_PATH];

        if (SUCCEEDED(SHGetFolderPathA(NULL, nFolder, NULL, SHGFP_TYPE_CURRENT, szPath))) {
            CHAR szShortRegPath[MAX_PATH];
            CHAR szShortGSFPath[MAX_PATH];
            BOOL bUseLFN;
            BOOL bSame = FALSE;
        
            if (lstrcmpiA(szPath, szRegValue) == 0) {
                bSame = TRUE;
                bUseLFN = TRUE;
            } else if (GetShortPathNameA(szPath, szShortGSFPath, ARRAYSIZE(szShortGSFPath)) &&
                       GetShortPathNameA(szRegValue, szShortRegPath, ARRAYSIZE(szShortRegPath)) &&
                       (lstrcmpiA(szShortGSFPath, szShortRegPath) == 0)) {
                bSame = TRUE;
            
                //
                // Since the sfn was returned, use that to copy over the output buffer.
                //
                bUseLFN = FALSE;
            }

            if (bSame && SUCCEEDED(SHGetFolderPathA(NULL, nFolderCommon, NULL, SHGFP_TYPE_CURRENT, szPath))) {
                if (bUseLFN) {
                    if ((lstrlenA(szPath) + 1) <= (int)cbOriginal) {
                        LOGN(
                            eDbgLevelInfo,
                            "[GetAllUsersRegValueA] overriding per-user reg value w/ common value");
                        lstrcpyA(szRegValue, szPath);                    
                    } else {
                        LOGN(
                            eDbgLevelInfo,
                            "[GetAllUsersRegValueA] returning ERROR_MORE_DATA for special folder value");
                        lRet = ERROR_MORE_DATA;
                    }

                    //
                    // Either we used this much room, or this is how much we need to have.
                    //
                    *pcbData = lstrlenA(szPath) + 1;
            
                } else if (GetShortPathNameA(szPath, szShortGSFPath, ARRAYSIZE(szShortGSFPath))) {
                
                    if ((lstrlenA(szShortGSFPath) + 1) <= (int)cbOriginal) {
                        LOGN(
                            eDbgLevelInfo,
                            "[GetAllUsersRegValueA] overriding per-user reg value w/ common value");
                    
                        lstrcpyA(szRegValue, szShortGSFPath);                    
                    } else {
                        LOGN(
                            eDbgLevelInfo,
                            "[GetAllUsersRegValueA] returning ERROR_MORE_DATA for special folder value");
                        lRet = ERROR_MORE_DATA;
                    }

                    //
                    // Either we used this much room, or this is how much we need to have.
                    //
                    *pcbData = lstrlenA(szShortGSFPath) + 1;
                }
            }
        }
    }

    return lRet;
}


//
// If the app is asking for the per-user "Desktop", "Start Menu" or "Startup" values by
// groveling the registry, then redirect it to the proper per-machine values.
//
LONG
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,           // handle to key
    LPCSTR  lpValueName,    // value name
    LPDWORD lpReserved,     // reserved
    LPDWORD lpType,         // type buffer
    LPBYTE  lpData,         // data buffer
    LPDWORD lpcbData        // size of data buffer
    )
{
    DWORD cbOriginal = (lpcbData ? *lpcbData : 0);  // save off the original buffer size
    LPCSTR pszNewHKLMKey;
    LONG lRet = ORIGINAL_API(RegQueryValueExA)(hKey,
                                               lpValueName,
                                               lpReserved,
                                               lpType,
                                               lpData,
                                               lpcbData);

    if ((lpValueName && lpcbData) &&    // (not simply checking for existance of the value...)
        IsBadShellFolderKey(hKey, &pszNewHKLMKey))
    {
        CHAR  szTemp[MAX_PATH];
    
        if (lstrcmpiA(lpValueName, "Desktop") == 0) {
            
            DPFN(
                eDbgLevelInfo,
                "[RegQueryValueExA] querying for 'Desktop' value\n");

            if (lRet == ERROR_SUCCESS) {
                lRet = GetAllUsersRegValueA((LPSTR)lpData,
                                            cbOriginal,
                                            lpcbData,
                                            CSIDL_DESKTOP,
                                            CSIDL_COMMON_DESKTOPDIRECTORY);
            
            } else if (lRet == ERROR_MORE_DATA) {
                
                if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_CURRENT, szTemp))) {
                    *lpcbData = MAX(*lpcbData, (DWORD)((lstrlenA(szTemp) + 1) * sizeof(CHAR)));
                }
            }
        } else if (lstrcmpiA(lpValueName, "Start Menu") == 0) {
            
            DPFN(
                eDbgLevelInfo,
                "[RegQueryValueExA] querying for 'Start Menu' value\n");

            if (lRet == ERROR_SUCCESS) {
                lRet = GetAllUsersRegValueA((LPSTR)lpData,
                                            cbOriginal,
                                            lpcbData,
                                            CSIDL_STARTMENU,
                                            CSIDL_COMMON_STARTMENU);
            
            } else if (lRet == ERROR_MORE_DATA) {
                
                if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_COMMON_STARTMENU, NULL, SHGFP_TYPE_CURRENT, szTemp))) {
                    *lpcbData = MAX(*lpcbData, (DWORD)((lstrlenA(szTemp) + 1) * sizeof(CHAR)));
                }
            }
        
        } else if (lstrcmpiA(lpValueName, "Startup") == 0) {
            
            DPFN(
                eDbgLevelInfo,
                "[RegQueryValueExA] querying for 'Startup' value\n");

            if (lRet == ERROR_SUCCESS) {
                lRet = GetAllUsersRegValueA((LPSTR)lpData, cbOriginal, lpcbData, CSIDL_STARTUP, CSIDL_COMMON_STARTUP);
            
            } else if (lRet == ERROR_MORE_DATA) {
                
                if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_COMMON_STARTUP, NULL, SHGFP_TYPE_CURRENT, szTemp))) {
                    *lpcbData = MAX(*lpcbData, (DWORD)((lstrlenA(szTemp) + 1) * sizeof(CHAR)));
                }
            }
        
        } else if (lstrcmpiA(lpValueName, "Programs") == 0) {
            
            DPFN(
                eDbgLevelInfo,
                "[RegQueryValueExA] querying for 'Programs' value\n");

            if (lRet == ERROR_SUCCESS) {
                lRet = GetAllUsersRegValueA((LPSTR)lpData, cbOriginal, lpcbData, CSIDL_PROGRAMS, CSIDL_COMMON_PROGRAMS);
            
            } else if (lRet == ERROR_MORE_DATA) {
                
                if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_COMMON_PROGRAMS, NULL, SHGFP_TYPE_CURRENT, szTemp))) {
                    *lpcbData = MAX(*lpcbData, (DWORD)((lstrlenA(szTemp) + 1) * sizeof(CHAR)));
                }
            }
        }
    }

    return lRet;
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        OSVERSIONINFOEX osvi = {0};
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        
        if (GetVersionEx((OSVERSIONINFO*)&osvi)) {
            
            if (!((VER_SUITE_TERMINAL & osvi.wSuiteMask) &&
                !(VER_SUITE_SINGLEUSERTS & osvi.wSuiteMask))) {
                //
                // Only install hooks if we are not on a "Terminal Server"
                // (aka "Application Server") machine.
                //
                APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA);
                APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyA);
                APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExA);
                APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA);
                APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExA);
            }
        }
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\syncsystemandsystem32.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   SyncSystemAndSystem32.cpp

 Abstract:

   This shim takes a semi-colon delimited command line of filenames.
   At process termination, the DLL will parse the extract each filename
   from the command line and make sure that the file exists in both
   the System directory and System32 (if it exists in either).

   Some older apps expect certain DLLs to be in System when under NT they
   belong in System32 (and vice versa).

 History:

   03/15/2000 markder   Created
   10/18/2000 a-larrsh  Add Wild Card support for command line.

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(SyncSystemAndSystem32)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
   APIHOOK_ENUM_ENTRY(CreateFileA)
   APIHOOK_ENUM_ENTRY(CreateFileW)
   APIHOOK_ENUM_ENTRY(CloseHandle)
   APIHOOK_ENUM_ENTRY(CopyFileA)
   APIHOOK_ENUM_ENTRY(CopyFileW)
   APIHOOK_ENUM_ENTRY(CopyFileExA)
   APIHOOK_ENUM_ENTRY(CopyFileExW)
   APIHOOK_ENUM_ENTRY(GetFileVersionInfoSizeA)
   APIHOOK_ENUM_ENTRY(GetFileVersionInfoSizeW)
APIHOOK_ENUM_END


int                 g_nrgFilesToSync    = 0;
CString *           g_rgFilesToSync     = NULL;

CString *           g_csSystem          = NULL; // c:\windows\system
CString *           g_csSystem32        = NULL; // c:\windows\system32

VectorT<HANDLE> *   g_hCachedHandles    = NULL;


void 
SyncDir(const CString & csFileToSync, const CString & csSrc, const CString & csDest)
{
    // Don't need our own excpetion handler,
    // this routine is only called inside one already.
    CString csSrcFile(csSrc);
    csSrcFile.AppendPath(csFileToSync);
    
    WIN32_FIND_DATAW FindFileData;
  
    HANDLE hFind = FindFirstFileW(csSrcFile, &FindFileData);
    if (hFind != INVALID_HANDLE_VALUE) 
    {
        // csFileToSync might be a wildcard
        do
        {
            CString csDestFile(csDest);
            csDestFile.AppendPath(FindFileData.cFileName);

            if (GetFileAttributesW(csDestFile) == -1)
            {
                // In System but not System32, copy it over
                CopyFileW(csSrcFile, csDestFile, FALSE);

                DPFN( eDbgLevelInfo, "File found in System but not in System32: %S", FindFileData.cFileName);
                DPFN( eDbgLevelInfo, "Copied over");
            }
        }
        while (FindNextFileW(hFind, &FindFileData));
      
        FindClose(hFind);
    }

}

void 
SyncSystemAndSystem32(const CString & csFileToSync)
{
    SyncDir(csFileToSync, *g_csSystem, *g_csSystem32);
    SyncDir(csFileToSync, *g_csSystem32, *g_csSystem);
}


void 
SyncAllFiles()
{
    CSTRING_TRY
    {
        for (int nFileCount = 0; nFileCount < g_nrgFilesToSync; ++nFileCount)
        {
            SyncSystemAndSystem32(g_rgFilesToSync[nFileCount]);
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
}

BOOL
IsFileToSync(const CString & csFileName)
{
    CSTRING_TRY
    {
        CString csFilePart;
        csFileName.GetLastPathComponent(csFilePart);
    
        for (int i = 0; i < g_nrgFilesToSync; ++i)
        {
            if (csFilePart == g_rgFilesToSync[i])
            {
                LOGN( eDbgLevelWarning, "File to sync detected: %S", csFileName.Get());
                return TRUE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    return FALSE;
}

BOOL
IsFileToSync(LPCSTR szFileName)
{
    CSTRING_TRY
    {
        CString csFileName(szFileName);
        return IsFileToSync(csFileName);
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    return FALSE;
}

BOOL
IsFileToSync(LPCWSTR szFileName)
{
    CSTRING_TRY
    {
        CString csFileName(szFileName);
        return IsFileToSync(csFileName);
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    return FALSE;
}

HANDLE 
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,                          // file name
    DWORD dwDesiredAccess,                      // access mode
    DWORD dwShareMode,                          // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
    DWORD dwCreationDisposition,                // how to create
    DWORD dwFlagsAndAttributes,                 // file attributes
    HANDLE hTemplateFile                        // handle to template file
    )
{
    HANDLE hRet;
    LONG nHandleCount = 0;

    hRet = ORIGINAL_API(CreateFileA)(
        lpFileName,                         
        dwDesiredAccess,                     
        dwShareMode,                         
        lpSecurityAttributes,
        dwCreationDisposition,               
        dwFlagsAndAttributes,                
        hTemplateFile);

    if (hRet != INVALID_HANDLE_VALUE)
    {
        if (IsFileToSync(lpFileName)) 
        {
            g_hCachedHandles->AppendUnique(hRet);
        }
    }

    return hRet;
}

HANDLE 
APIHOOK(CreateFileW)(
    LPCWSTR lpFileName,                         // file name
    DWORD dwDesiredAccess,                      // access mode
    DWORD dwShareMode,                          // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
    DWORD dwCreationDisposition,                // how to create
    DWORD dwFlagsAndAttributes,                 // file attributes
    HANDLE hTemplateFile                        // handle to template file
    )
{
    HANDLE hRet;
    LONG nHandleCount = 0;

    hRet = ORIGINAL_API(CreateFileW)(
        lpFileName,                         
        dwDesiredAccess,                     
        dwShareMode,                         
        lpSecurityAttributes,
        dwCreationDisposition,               
        dwFlagsAndAttributes,                
        hTemplateFile);

    if (hRet != INVALID_HANDLE_VALUE)
    {
        if (IsFileToSync(lpFileName)) 
        {
            g_hCachedHandles->AppendUnique(hRet);
        }
    }

    return hRet;
}

BOOL 
APIHOOK(CloseHandle)(HANDLE hObject)
{
    int nIndex = g_hCachedHandles->Find(hObject);
    if (nIndex >= 0)
    {
        g_hCachedHandles->Remove(nIndex);
        SyncAllFiles();
    }

    return ORIGINAL_API(CloseHandle)(hObject);
}

BOOL 
APIHOOK(CopyFileA)(
    LPCSTR lpExistingFileName,  // name of an existing file
    LPCSTR lpNewFileName,       // name of new file
    BOOL bFailIfExists          // operation if file exists
    )
{
    BOOL bRet;

    bRet = ORIGINAL_API(CopyFileA)(
        lpExistingFileName,
        lpNewFileName,
        bFailIfExists);

    if (bRet)
    {
        if (IsFileToSync(lpNewFileName))
        {
            SyncAllFiles();
        }
    }

    return bRet;
}

BOOL 
APIHOOK(CopyFileW)(
    LPCWSTR lpExistingFileName, // name of an existing file
    LPCWSTR lpNewFileName,      // name of new file
    BOOL bFailIfExists          // operation if file exists
    )
{
    BOOL bRet;

    bRet = ORIGINAL_API(CopyFileW)(
        lpExistingFileName,
        lpNewFileName,
        bFailIfExists);

    if (bRet)
    {
        if (IsFileToSync(lpNewFileName))
        {
            SyncAllFiles();
        }
    }

    return bRet;
}

BOOL 
APIHOOK(CopyFileExA)(
    LPCSTR lpExistingFileName,            // name of existing file
    LPCSTR lpNewFileName,                 // name of new file
    LPPROGRESS_ROUTINE lpProgressRoutine, // callback function
    LPVOID lpData,                        // callback parameter
    LPBOOL pbCancel,                      // cancel status
    DWORD dwCopyFlags                     // copy options
    )
{
    BOOL bRet;

    bRet = ORIGINAL_API(CopyFileExA)(
        lpExistingFileName,
        lpNewFileName,     
        lpProgressRoutine, 
        lpData,            
        pbCancel,          
        dwCopyFlags);

    if (bRet)
    {
        if (IsFileToSync(lpNewFileName))
        {
            SyncAllFiles();
        }
    }

    return bRet;
}

BOOL 
APIHOOK(CopyFileExW)(
    LPCWSTR lpExistingFileName,           // name of existing file
    LPCWSTR lpNewFileName,                // name of new file
    LPPROGRESS_ROUTINE lpProgressRoutine, // callback function
    LPVOID lpData,                        // callback parameter
    LPBOOL pbCancel,                      // cancel status
    DWORD dwCopyFlags                     // copy options
    )
{
    BOOL bRet;

    bRet = ORIGINAL_API(CopyFileExW)(
        lpExistingFileName,
        lpNewFileName,     
        lpProgressRoutine, 
        lpData,            
        pbCancel,          
        dwCopyFlags);

    if (bRet)
    {
        if (IsFileToSync(lpNewFileName))
        {
            SyncAllFiles();
        }
    }

    return bRet;
}

//
// GetFileVersionInfoSize was added for the Madeline series.
// There was a specific point at which the sync had to occur.
//

DWORD 
APIHOOK(GetFileVersionInfoSizeA)(
    LPSTR lptstrFilename,   // file name
    LPDWORD lpdwHandle      // set to zero
    )
{
    if (IsFileToSync(lptstrFilename))
    {
        SyncAllFiles();
    }

    return ORIGINAL_API(GetFileVersionInfoSizeA)(lptstrFilename, lpdwHandle);
}

DWORD 
APIHOOK(GetFileVersionInfoSizeW)(
    LPWSTR lptstrFilename,  // file name
    LPDWORD lpdwHandle      // set to zero
    )
{
    if (IsFileToSync(lptstrFilename))
    {
        SyncAllFiles();
    }

    return ORIGINAL_API(GetFileVersionInfoSizeW)(lptstrFilename, lpdwHandle);
}

BOOL 
ParseCommandLine()
{
    CSTRING_TRY
    {
        g_hCachedHandles = new VectorT<HANDLE>;
        
        CString         csCl(COMMAND_LINE);
        CStringParser   csParser(csCl, L";");

        g_nrgFilesToSync    = csParser.GetCount();
        g_rgFilesToSync     = csParser.ReleaseArgv();

        // Create strings to %windir%\system and %windir%\system32
        g_csSystem   = new CString;
        g_csSystem->GetWindowsDirectoryW();
        g_csSystem->AppendPath(L"System");

        g_csSystem32 = new CString;
        g_csSystem32->GetWindowsDirectoryW();
        g_csSystem32->AppendPath(L"System32");
    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return ParseCommandLine();
    }
    else if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        SyncAllFiles();
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        SyncAllFiles();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA);
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW);
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle);
    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileA);
    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileW);
    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileExA);
    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileExW);
    APIHOOK_ENTRY(VERSION.DLL, GetFileVersionInfoSizeA);
    APIHOOK_ENTRY(VERSION.DLL, GetFileVersionInfoSizeW);

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\vregistry.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    VRegistry.cpp

 Abstract:

    A virtual registry for misbehaving registry readers.

    This engine has 5 main features:
        1. Key redirection
           Eg: HKLM\Software -> HKLM\Hardware
        2. Key and Value spoofing
           Eg: HKLM\Software\VersionNumber can be made to appear as a valid 
               value
               HKEY_DYN_DATA can appear valid
        3. Expansion of REG_EXPAND_SZ value type to REG_SZ
           Eg: %SystemRoot%\Media will result in C:\WINNT\Media
        4. Support for EnumKey, EnumValue and QueryInfoKey on virtual keys
        5. Support for CreateKey

    Other features:
        1. Strip leading '\' characters from keys
        2. Add MAXIMUM_ALLOWED security attributes to all keys
        3. Adjust parameters of QueryInfoKey to match Win95
        4. Enable key deletion for key which still has subkeys 
           in order to match Win95 behavior for RegDeleteKey
        5. Values and keys can be protected from modification and deletion
        6. Custom triggers on opening a key.
        7. Values that have extra data beyond end of string can be queried
           even though the provided buffer is too small for extra data.

    Known limitations:
        No support for RegSetValue and RegSetValueEx other than known parameter 
        error and value protection.

 Notes:

    This is for apps with registry problems

 History:

    01/06/2000  linstev     Created
    01/10/2000  linstev     Added support for RegEnumKey, RegEnumValue 
    01/10/2000  linstev     Added support for RegCreateKey
    05/05/2000  linstev     Parameterized
    10/03/2000  maonis      Bug fixes and got rid of the cleanup code in process detach.
    10/30/2000  andyseti    Added support for RegDeleteKey
    02/27/2001  robkenny    Converted to use CString
    08/07/2001  mikrause    Added protectors, enumeration of virtual & non-virtual keys & values,
                            triggers on opening a key, and querying values with extra data
                            and a too small buffer.
    10/12/2001  mikrause    Added support for custom callbacks on SetValue.
                            Reimplemented value protectors as do-nothing callbacks.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(VirtualRegistry)
#include "ShimHookMacro.h"
#include "VRegistry.h"
#include "VRegistry_Worker.h"


// Allows us to have only one code path for dumping all APIs or just the APIs 
// that had errors
#define ELEVEL(lRet) SUCCESS(lRet) ? eDbgLevelInfo : eDbgLevelError

CRITICAL_SECTION csRegCriticalSection;

// Global instance of Virtual Registry class
CVirtualRegistry VRegistry;

// Used to enable win9x only features
BOOL g_bWin9x = TRUE;

/*++

 Class Description:

    This class is designed to simplify locking logic. If an object of this 
    class is instantiated, then internal lock will be taken. As soon as object 
    is destroyed lock will be released. We also check if the registry has been 
    initialized. This has to happen late because we don't get notified after 
    we've been loaded.

 History:

    01/10/2000 linstev  Created

--*/

static BOOL g_bInitialized = FALSE;

BOOL ParseCommandLineA(LPCSTR lpCommandLine);

class CRegLock
{
public:
    CRegLock()
    {
        EnterCriticalSection(&csRegCriticalSection);
        if (!g_bInitialized)
        {

           VENTRY* ventry = g_pVList;
           while (ventry->pfnBuilder)
           {
              if (ventry->bShouldCall)
              {
                 DPFN( eDbgLevelInfo, "  %S", ventry->cName);
                 ventry->pfnBuilder(ventry->szParam);
                 if (ventry->szParam)
                 {
                    free(ventry->szParam);
                 }
                 ventry->bShouldCall = FALSE;
              }
              ventry++;
           }
           g_bInitialized = TRUE;           
        }
    }
    ~CRegLock()
    {
       LeaveCriticalSection(&csRegCriticalSection);     
    }
};

/*++

 Function Description:

    Remove leading slash from an Unicode string 

 Arguments:

    IN lpSubKey - path to string

 Return Value:

    Subkey without leading \

 History:

    01/06/2000 linstev  Created

--*/

LPCWSTR 
TrimSlashW(
    IN OUT LPCWSTR lpSubKey
    )     
{
    if (!lpSubKey)
    {
        return lpSubKey;
    }
    
    LPWSTR lpNew = (LPWSTR) lpSubKey;
    
    #define REG_MACHINE   L"\\Registry\\Machine"
    #define REG_USER      L"\\Registry\\User"

    //
    // Pull off the old NT4 legacy stuff. This only works on NT4, but we're 
    // making it for everyone since it's low risk.
    //
    if (wcsistr(lpNew, REG_MACHINE) == lpNew)
    {
        LOGN( eDbgLevelError, "[TrimSlashW] Bypass \\Registry\\Machine");
        lpNew += wcslen(REG_MACHINE);
    }
    else if (wcsistr(lpNew, REG_USER) == lpNew)
    {
        LOGN( eDbgLevelError, "[TrimSlashW] Bypass \\Registry\\User");
        lpNew += wcslen(REG_USER);
    }
    
    if (*lpNew == L'\\')
    {
        LOGN( eDbgLevelError, "[TrimSlashW] Removed slash from key beginning");
        lpNew++;
    }

    return lpNew;
}

/*++

 Function Description:

    Convert a key from registry format to virtual registry format. i.e.:
    HKEY, Path -> VPath. The VPath format has the base included as "HKLM" 
    instead of HKEY_LOCAL_MACHINE etc.

    Algorithm:
        1. Case the different keys and output a 4 letter string
        2. Append subkey if available

 Arguments:

    IN  hkBase   - Base key, eg: HKEY_LOCAL_MACHINE
    IN  lpSubKey - Subkey, eg: SOFTWARE
    OUT lpPath   - Output, eg: HKLM\SOFTWARE

 Return Value:

    A string path of the form HKLM\SOFTWARE

 History:

    01/06/2000 linstev  Created

--*/

LPWSTR 
MakePath(
    IN HKEY hkBase, 
    IN LPCWSTR lpKey,
    IN LPCWSTR lpSubKey
    )
{
    DWORD dwSize = 0;

    if (hkBase)
    {
        // Length of HKCU + NULL
        dwSize = 5;
    }
    if (lpKey)
    {
        dwSize += wcslen(lpKey) + 1;
    }
    if (lpSubKey)
    {
        dwSize += wcslen(lpSubKey) + 1;
    }

    LPWSTR lpPath = (LPWSTR) malloc((dwSize + 1) * sizeof(WCHAR));

    if (!lpPath)
    {
        if (dwSize)
        {
            DPFN( eDbgLevelError, szOutOfMemory);
        }
        return NULL;
    }
    
    *lpPath = L'\0';

    HRESULT hr;
    if (hkBase)
    {
        if (hkBase == HKEY_CLASSES_ROOT)
        {
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKCR");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }
        }
        else if (hkBase == HKEY_CURRENT_CONFIG)
        {        
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKCC");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }
        }           
        else if (hkBase == HKEY_CURRENT_USER)
        {        
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKCU");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }            
        }
        else if (hkBase == HKEY_LOCAL_MACHINE)
        {        
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKLM");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }            
        }            
        else if (hkBase == HKEY_USERS)
        {        
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKUS");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }            
        }           
        else if (hkBase == HKEY_PERFORMANCE_DATA)
        {        
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKPD");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }            
        }
        else if (hkBase == HKEY_DYN_DATA)
        {        
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKDD");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }            
        }            
        else
        {
            DPFN( eDbgLevelWarning, 
                "Key not found: %08lx - did not get an openkey or createkey", 
                hkBase);
        }
    }

    // Add the key 
    if (lpKey)
    {
        if (wcslen(lpPath) != 0)
        {
           hr = StringCchCatW(lpPath, dwSize + 1, L"\\");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }
        }
        hr = StringCchCatW(lpPath, dwSize + 1, lpKey);
        if (FAILED(hr))
        {
           goto ErrorCleanup;
        }        
    }

    // Add the subkey
    if (lpSubKey)
    {
        if (wcslen(lpPath) != 0)
        {
           hr = StringCchCatW(lpPath, dwSize + 1, L"\\");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }            
        }
        hr = StringCchCatW(lpPath, dwSize + 1, lpSubKey);
        if (FAILED(hr))
        {
           goto ErrorCleanup;
        }
    }

    // The key name can have a trailing slash, so we clean this up
    DWORD dwLen = wcslen(lpPath);
    if (dwLen && (lpPath[dwLen - 1] == L'\\'))
    {
        lpPath[dwLen - 1] = L'\0';
    }

    return lpPath;

ErrorCleanup:
   free(lpPath);
   return NULL;
}

/*++

 Function Description:

    Convert a key from Path format into key and subkey format.

    Algorithm:
        1. Case the different keys and output a 4 letter string
        2. Append subkey if available

 Arguments:

    IN lpPath    - Path,   eg: HKLM\Software
    OUT hkBase   - Key,    eg: HKEY_LOCAL_MACHINE
    OUT lpSubKey - Subkey, eg: Software

 Return Value:

    None

 History:

    01/06/2000 linstev  Created

--*/

LPWSTR
SplitPath(
    IN LPCWSTR lpPath,
    OUT HKEY *hkBase
    )
{
    LPWSTR p = (LPWSTR) lpPath;

    // Find first \ or NULL
    while (*p && (*p != L'\\')) p++;

    if (wcsncmp(lpPath, L"HKCR", 4) == 0)
        *hkBase = HKEY_CLASSES_ROOT;

    else if (wcsncmp(lpPath, L"HKCC", 4) == 0)
        *hkBase = HKEY_CURRENT_CONFIG;

    else if (wcsncmp(lpPath, L"HKCU", 4) == 0)
        *hkBase = HKEY_CURRENT_USER;

    else if (wcsncmp(lpPath, L"HKLM", 4) == 0)
        *hkBase = HKEY_LOCAL_MACHINE;

    else if (wcsncmp(lpPath, L"HKUS", 4) == 0)
        *hkBase = HKEY_USERS;

    else if (wcsncmp(lpPath, L"HKPD", 4) == 0)
        *hkBase = HKEY_PERFORMANCE_DATA;

    else if (wcsncmp(lpPath, L"HKDD", 4) == 0)
        *hkBase = HKEY_DYN_DATA;

    else
        *hkBase = 0;

    // Don't allow an invalid base key to get through.
    if (*hkBase && lpPath[4] != '\\')
    {
       *hkBase = 0;
    }

    if (*p)
    {
        p++;
    }

    return p;
}

/*++

 Function Description:
    
    Add a virtual key: a key contains other keys and values and will behave 
    like a normal registry key, but of course has no persistent storage.

    Algorithm:
        1. The input string is split apart and a tree is created recursively
        2. The key is created only if it doesn't already exist

 Arguments:

    IN lpPath - Path to key, eg: "HKLM\\Software"

 Return Value:

    Pointer to key or NULL

 History:

    01/06/2000 linstev  Created

--*/

VIRTUALKEY *
VIRTUALKEY::AddKey(
    IN LPCWSTR lpPath
    )
{
    VIRTUALKEY *key;
    LPWSTR p = (LPWSTR)lpPath;

    // Find first \ or NULL
    while (*p && (*p != L'\\')) p++;

    // Check if this part already exists 
    key = keys;
    while (key != NULL)
    {
        if (_wcsnicmp(lpPath, key->wName, p - lpPath) == 0)
        {
            if (*p == L'\\')     
            {
                // Continue the search
                return key->AddKey(p + 1);
            }
            else                
            {
                // We already added this key
                return key;
            }
        }
        key = key->next;
    }

    // Create a new key

    key = (VIRTUALKEY *) malloc(sizeof(VIRTUALKEY));
    if (!key)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    ZeroMemory(key, sizeof(VIRTUALKEY));
    
    //
    // Still use wcsncpy, because here it specifies number of characters
    // to copy, not size of the destination buffer.  Add in check
    // for destination buffer size.
    //
    if ( (p - lpPath) > sizeof(key->wName)/sizeof(WCHAR))
    {
       free (key);
       return NULL;
    }       
    wcsncpy((LPWSTR)key->wName, lpPath, p - lpPath);
    key->next = keys;
    keys = key;

    DPFN( eDbgLevelSpew, "Adding Key %S", key->wName);

    if (*p == L'\0')
    {
        // We are at the end of the chain, so just return this one
        return key;
    }
    else
    {
        // More subkeys to go
        return key->AddKey(p + 1);
    }
}

/*++

 Function Description:

    Add a value to a virtual key. The actual registry key may exist and the 
    value may even exist, but this value will override.

    Algorithm:
        1. If lpData is a string and cbData is 0, calculate the size 
        2. Add this value (no duplicate checking)

 Arguments:

    IN lpValueName - Value name
    IN dwType      - Type of key; eg: REG_SZ, REG_DWORD etc
    IN lpData      - Data, use unicode if string
    IN cbData      - Size of lpData

 Return Value:

    Pointer to value or NULL

 History:

    01/06/2000 linstev  Created

--*/

VIRTUALVAL *
VIRTUALKEY::AddValue(
    IN LPCWSTR lpValueName, 
    IN DWORD dwType, 
    IN BYTE *lpData, 
    IN DWORD cbData
    )
{
   // Parameter validation
   if (lpData == NULL && cbData != 0)
   {
      return NULL;
   }

    VIRTUALVAL *value = (VIRTUALVAL *) malloc(sizeof(VIRTUALVAL));
    if (!value)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    ZeroMemory(value, sizeof(VIRTUALVAL));
    
    // Auto calculate size if cbData is 0
    if (lpData && (cbData == 0))
    {
        switch (dwType)
        {
        case REG_SZ:
        case REG_EXPAND_SZ:
            cbData = wcslen((LPWSTR)lpData)*2 + sizeof(WCHAR);
            break;

        case REG_DWORD:
            cbData = sizeof(DWORD);
            break;
        }
    }

    // lpValueName can == NULL, which means default value
    if (lpValueName)
    {
       HRESULT hr = StringCchCopy(value->wName, sizeof(value->wName)/sizeof(WCHAR), lpValueName);
       if (FAILED(hr))
       {
          free(value);
          return NULL;
       }
    }

    if (cbData)
    {
        // Make a copy of the data if needed
        value->lpData = (BYTE *) malloc(cbData);

        if (!value->lpData)
        {
            DPFN( eDbgLevelError, szOutOfMemory);
            free(value);
            return NULL;
        }

        MoveMemory(value->lpData, lpData, cbData);
        value->cbData = cbData;
    }

    value->pfnQueryValue = NULL;
    value->pfnSetValue = NULL;
    value->dwType = dwType;
    value->next = values;
    values = value;

    if (lpData && ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ)))
    {
        DPFN( eDbgLevelSpew, "Adding Value %S\\%S = %S", wName, lpValueName, lpData);
    }
    else
    {
        DPFN( eDbgLevelSpew, "Adding Value %S\\%S", wName, lpValueName);
    }
    
    return value;
}

/*++

 Function Description:

    Add a dword value to a key. Calls off to AddValue.

 Arguments:

    IN lpValueName - Value name
    IN Value       - DWord value

 Return Value:

    Pointer to a virtual dword value

 History:

    05/25/2000 linstev  Created

--*/

VIRTUALVAL *
VIRTUALKEY::AddValueDWORD(
    IN LPCWSTR lpValueName,
    IN DWORD dwValue
    )
{
    return AddValue(lpValueName, REG_DWORD, (LPBYTE)&dwValue);
}

/*++

 Function Description:

    Add an expander to a key. An expander causes QueryValue to expand the 
    REG_EXPAND_SZ type to a REG_SZ type. The expander itself is just 
    a virtual value which allows us to intercept queries to it.

 Arguments:

    IN lpValueName - Value name

 Return Value:

    Pointer to a virtual value

 History:

    01/06/2000 linstev  Created

--*/

VIRTUALVAL *
VIRTUALKEY::AddExpander(
    IN LPCWSTR lpValueName
    )
{
    VIRTUALVAL *value = AddValue(lpValueName, REG_SZ, 0, 0);
    
    if (value)
    {
        value->pfnQueryValue = VR_Expand;
    }

    return value;
}

/*++

 Function Description:

    Add a protector on a value. A protector causes SetValue to
    be ignored.  This is implemented through a custom setvalue
    callback that does nothing.

 Arguments:

    IN lpValueName - Value name

 Return Value:

    Pointer to a virtual value

 History:

    10/12/2001 mikrause  Created

--*/

VIRTUALVAL *
VIRTUALKEY::AddProtector(
    IN LPCWSTR lpValueName
    )
{
    VIRTUALVAL *value = AddValue(lpValueName, REG_SZ, 0, 0);
    
    if (value)
    {
        value->pfnSetValue = VR_Protect;
    }

    return value;
}

/*++

 Function Description:

    Add a custom queryvalue routine

 Arguments:

    IN lpValueName - Value name
    IN pfnQueryValue - routine to call when this value is queried

 Return Value:

    Pointer to a virtual value

 History:

    07/18/2000 linstev  Created

--*/

VIRTUALVAL *
VIRTUALKEY::AddCustom(
    IN LPCWSTR lpValueName,
    _pfn_QueryValue pfnQueryValue
    )
{
    VIRTUALVAL *value = AddValue(lpValueName, REG_SZ, 0, 0);
    
    if (value)
    {
        value->pfnQueryValue = pfnQueryValue;
    }

    return value;
}

/*++

 Function Description:

    Add a custom setvalue routine

 Arguments:

    IN lpValueName - Value name
    IN pfnSetValue - routine to call when this value is set

 Return Value:

    Pointer to a virtual value

 History:

    11/06/2001 mikrause  Created

--*/

VIRTUALVAL *
VIRTUALKEY::AddCustomSet(
    IN LPCWSTR lpValueName,
    _pfn_SetValue pfnSetValue
    )
{
    VIRTUALVAL *value = AddValue(lpValueName, REG_SZ, 0, 0);
    
    if (value)
    {
        value->pfnSetValue = pfnSetValue;
    }

    return value;
}

/*++

 Function Description:

    Find a subkey of a key.

    Algorithm:
        1. Recursively search the tree for the matching subkey

 Arguments:

    IN lpKeyName - Name of key to find

 Return Value:

    Pointer to value or NULL

 History:

    01/06/2000 linstev  Created

--*/

VIRTUALKEY *
VIRTUALKEY::FindKey(
    IN LPCWSTR lpPath
    )
{
    VIRTUALKEY *key = keys;
    LPWSTR p = (LPWSTR)lpPath;

    if (!lpPath) 
    {
        return NULL;
    }
    
    // Find first \ or NULL
    while (*p && (*p != L'\\')) p++;

    // recursively look for the key
    while (key)
    {
        if (_wcsnicmp(
                lpPath, 
                key->wName, 
                max((DWORD_PTR)(p - lpPath), wcslen(key->wName))) == 0)
        {
            if (*p == L'\\')
            {
                key = key->FindKey(p + 1);
            }
            break;
        }

        key = key->next;
    }
    
    // We're at the end of the chain
    return key;
}

/*++

 Function Description:

    Find a value in a key. 

 Arguments:

    IN key         - Key used for expanders; unused at this time
    IN lpValueName - Value name

 Return Value:

    Pointer to value or NULL

 History:

    01/06/2000 linstev  Created

--*/

VIRTUALVAL *
VIRTUALKEY::FindValue(
    IN LPCWSTR lpValueName
    )
{
    VIRTUALVAL *value = values;
    WCHAR wDef[1] = L"";
    LPWSTR lpName;

    if (!lpValueName) 
    {
        lpName = (LPWSTR)wDef;
    }
    else
    {
        lpName = (LPWSTR)lpValueName;
    }

    // Find the value
    while (value)
    {
        if (_wcsicmp(lpName, value->wName) == 0)
        {
            LOGN( eDbgLevelWarning, "[FindValue] Using virtual value:  %S", value->wName);
            break;
        }
        value = value->next;
    }
    
    return value;
}

/*++

 Function Description:

    Free the subkeys and values belonging to a key

    Algorithm:
        1. Free all values belonging to a key, including any data
        2. Free all subkeys recursively

 Arguments:

    None

 Return Value:

    None

 History:

    01/06/2000 linstev  Created

--*/

VOID 
VIRTUALKEY::Free()
{
    VIRTUALVAL *value = values;
    VIRTUALKEY *key = keys;

    while (value)
    {
        values = value->next;
        if (value->lpData)
        {
            free((PVOID) value->lpData);
        }
        free((PVOID) value);
        value = values;
    }

    while (key)
    {
        keys = key->next;
        key->Free();
        free((PVOID) key);
        key = keys;
    }

    DPFN( eDbgLevelSpew, "Free keys and values from %S", wName);
}

/*++

 Function Description:

    Allocate a new enum entry

 Arguments:

    IN wzPath - Key path or value name of entry.
    IN next - Next entry in the list.    

 Return Value:

    Pointer to new entry or NULL

 History:

    08/21/2001 mikrause  Created

--*/

ENUMENTRY*
CreateNewEnumEntry(
    IN LPWSTR wzPath,
    IN ENUMENTRY* next)
{
    ENUMENTRY* enumEntry;
    enumEntry = (ENUMENTRY*)malloc(sizeof(ENUMENTRY));
    if (enumEntry == NULL)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    ZeroMemory(enumEntry, sizeof(ENUMENTRY));

    enumEntry->wzName = (LPWSTR)malloc((wcslen(wzPath) + 1)*sizeof(WCHAR));
    if (enumEntry->wzName == NULL)
    {
        free(enumEntry);
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    HRESULT hr = StringCchCopyW(enumEntry->wzName, wcslen(wzPath)+1, wzPath);
    if (FAILED(hr))
    {
       free(enumEntry->wzName);
       free(enumEntry);
       return NULL;
    }    

    enumEntry->next = next;

    return enumEntry;
}

/*++

 Function Description:

    Add enumeration entries to a list.  Templatized,
    so the same code works for keys or values.

 Arguments:

    IN entryHead - Head of the list containing virtual keys or values.
    IN enumFunc - Enumeration function to use.  Either RegEnumKey or RegEnumValue  

 Return Value:

    Pointer to the head of the entry list, or NULL.

 History:

    08/21/2001 mikrause  Created

--*/

template<class T>
ENUMENTRY*
OPENKEY::AddEnumEntries(T* entryHead, _pfn_EnumFunction enumFunc)
{
    LONG lRet;
    DWORD dwIndex;
    DWORD dwSize;
    WCHAR wzName[MAX_PATH + 1];
    ENUMENTRY* enumEntryList = NULL;
    ENUMENTRY* newEnumEntry = NULL;

    // Add virtual entries to the list.
    T* entry = entryHead;
    while (entry)
    {
        // Create a new entry.
        newEnumEntry = CreateNewEnumEntry(entry->wName, enumEntryList);

        if (newEnumEntry != NULL)
        {
            enumEntryList = newEnumEntry;         
        }
                
        entry = entry->next;
    }

    // Now non-virtuals.
    if (bVirtual == FALSE)
    {
        dwIndex = 0;

        for (;;)
        {
            dwSize = MAX_PATH * sizeof(WCHAR);
            lRet = enumFunc(hkOpen, dwIndex, wzName, &dwSize, NULL, NULL, NULL, NULL);

            // No more items, we're done.
            if (lRet == ERROR_NO_MORE_ITEMS)
            {
                break;
            }

            // 
            // Check for error.
            // On Win2K, this can return more data if there are additional keys.
            //
            if (lRet != ERROR_SUCCESS && lRet != ERROR_MORE_DATA)
            {
                break;
            }

            // Check if this key is a duplicate.
            entry = entryHead;
            while (entry)
            {
                if (_wcsicmp(entry->wName, wzName) == 0)
                {
                    break;
                }

                entry = entry->next;
            }

            // Add this key to the list, if it's not a duplicate.
            if (entry == NULL)
            {
                // Create a new entry.
                newEnumEntry = CreateNewEnumEntry(wzName, enumEntryList);
                if (newEnumEntry != NULL)
                {
                    enumEntryList = newEnumEntry;            
                }
            }
            dwIndex++;
        }
    }

    return enumEntryList;
}

/*++

 Function Description:

    Builds the list of enumerated keys and values.

 Arguments:

    None

 Return Value:

    None

 History:

    08/10/2001 mikrause  Created

--*/

VOID
OPENKEY::BuildEnumList()
{
    VIRTUALKEY* keyHead = NULL;
    VIRTUALVAL* valHead = NULL;

    if (vkey)
    {
        keyHead = vkey->keys;
        valHead = vkey->values;
    }

    enumKeys = AddEnumEntries(keyHead, (_pfn_EnumFunction)ORIGINAL_API(RegEnumKeyExW));
    enumValues = AddEnumEntries(valHead, (_pfn_EnumFunction)ORIGINAL_API(RegEnumValueW));
}

/*++

 Function Description:

    Flushes all enumerated data..

 Arguments:

    None

 Return Value:

    None

 History:

    08/10/2001 mikrause  Created

--*/

VOID
OPENKEY::FlushEnumList()
{
    ENUMENTRY *enumentry;

    DPFN(eDbgLevelInfo, "Flushing enumeration data for %S", wzPath);
    while (enumKeys)
    {
        enumentry = enumKeys;
        enumKeys = enumKeys->next;

        if (enumentry->wzName)
        {
            free(enumentry->wzName);
        }

        free(enumentry);
    }

    while (enumValues)
    {
        enumentry = enumValues;
        enumValues = enumValues->next;

        if (enumentry->wzName)
        {
            free(enumentry->wzName);
        }

        free(enumentry);
    }

    enumKeys = enumValues = NULL;
}

/*++

 Function Description:

    Initialize the virtual registry. This would ordinarily go into the 
    constructor, but because of the shim architecture, we need to explicity 
    initialize and free the virtual registry.

 Arguments:

    None

 Return Value:

    None

 History:

    01/06/2000 linstev  Created

--*/

BOOL 
CVirtualRegistry::Init()
{
    OpenKeys = NULL; 
    Redirectors = NULL;
    KeyProtectors = NULL;    
    OpenKeyTriggers = NULL;

    Root = (VIRTUALKEY *) malloc(sizeof(VIRTUALKEY));
    if (!Root)
    {
       DPFN(eDbgLevelError, szOutOfMemory);
       return FALSE;
    }
    ZeroMemory(Root, sizeof(VIRTUALKEY));
    HRESULT hr = StringCchCopyW(Root->wName, sizeof(Root->wName)/sizeof(WCHAR), L"ROOT");
    if (FAILED(hr))
    {
       return FALSE;
    }
    
    DPFN( eDbgLevelSpew, "Initializing Virtual Registry");
    return TRUE;
}

/*++

 Function Description:

    Free the lists contained by the virtual registry. This includes keys, 
    their values and redirectors.

    Algorithm:
        1. Free virtual root key which recursively frees subkeys and values
        2. Free open keys
        3. Free redirectors

 Arguments:

    None

 Return Value:

    None

 History:

    01/06/2000 linstev  Created

--*/

VOID 
CVirtualRegistry::Free()
{
    OPENKEY *key;
    REDIRECTOR *redirect;
    OPENKEYTRIGGER *trigger;
    PROTECTOR *protector;

    DPFN( eDbgLevelSpew, "Freeing Virtual Registry");

    // Free Root and all subkeys/values
    if (Root)
    {
        Root->Free();
        free(Root);
        Root = NULL;
    }
    
    // Delete all enumeration data.
    FlushEnumLists();

    // Free list of open registry keys
    key = OpenKeys;
    while (key)
    {
        OpenKeys = key->next;
        free(key->wzPath);
        free(key);
        key = OpenKeys;
    }

    // Free redirectors
    redirect = Redirectors;
    while (redirect)
    {
        Redirectors = redirect->next;
        free(redirect->wzPath);
        free(redirect->wzPathNew);
        free(redirect);
        redirect = Redirectors;
    }

    // Free open key triggers
    trigger = OpenKeyTriggers;
    while(trigger)
    {
        OpenKeyTriggers = trigger->next;
        free(trigger->wzPath);
        free(trigger);
        trigger = OpenKeyTriggers;
    }

    // Free Protectors
    protector = KeyProtectors;
    while(protector)
    {
        KeyProtectors = protector->next;
        free(protector->wzPath);
        free(protector);
        protector = KeyProtectors;
    }
}

/*++

 Function Description:

    Create a dummy key for use as a virtual key. We need to have unique handles
    in order to look up the keys, so by creating a key off HKLM, we can be 
    sure it won't fail. 
    
    We can't damage the registry like this because writes to this key will fail.
    Calls to QueryValue, QueryInfo and EnumKey will work correctly because the 
    virtual registry is used in preference to the real one.

 Arguments:

    None

 Return Value:

    Dummy key

 History:

    01/06/2000 linstev  Created

--*/

HKEY 
CVirtualRegistry::CreateDummyKey()
{
    HKEY key = NULL;

    LONG lRet = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"Software", 0, KEY_READ, &key);
    if (lRet != ERROR_SUCCESS)
    {
       return NULL;
    }
    
    return key;
}

/*++

 Function Description:

    Find an open key in the list of open keys.

    Algorithm:
        1. Search the list of open keys for a match

 Arguments:

    IN hKey - Open HKEY 

 Return Value:

    Pointer to a key or NULL

 History:

    01/06/2000 linstev  Created

--*/

OPENKEY *
CVirtualRegistry::FindOpenKey(
    IN HKEY hKey
    )
{
    OPENKEY *key = OpenKeys;

    while (key)
    {
        if (key->hkOpen == hKey) 
        {
            return key;
        }
        key = key->next;
    }        
    return NULL;
}

/*++

 Function Description:

    If this key is to be redirected, we adjust the path to the redirected 
    version. This works even if the requested path is a 'subpath' of a 
    redirector, eg: 
        Input       = HKLM\Software\Test
        Redirector  = HKLM\Software -> HKLM\Hardware
        Output      = HKLM\Hardware\Test
    If no redirector is present for this key/path, then lpPath is unchanged

    Algorithm:
        1. Find a key whose base is a redirector
        2. Substitute the new base for the key

 Arguments:

    IN OUT lpPath - Path to redirect

 Return Value:

    TRUE if redirected

 History:

    01/06/2000 linstev  Created

--*/

BOOL
CVirtualRegistry::CheckRedirect(
    IN OUT LPWSTR *lpPath
    )
{
    REDIRECTOR *redirect = Redirectors;
    DWORD sza = wcslen(*lpPath);

    // Go through the list of redirectors
    while (redirect)
    {
        DWORD szb = wcslen(redirect->wzPath);
 
        if ((szb <= sza) &&
            (_wcsnicmp(*lpPath, redirect->wzPath, szb) == 0) &&
            ((*lpPath)[szb] == L'\\' || (*lpPath)[szb] == L'\0'))
        {
            WCHAR *p = *lpPath + szb;
            
            DWORD cchPathSize = wcslen(redirect->wzPathNew) + wcslen(p) + 1;
            LPWSTR wzPathNew = (LPWSTR) malloc(cchPathSize * sizeof(WCHAR));
            if (wzPathNew)
            {
               HRESULT hr;
               hr = StringCchCopyW(wzPathNew, cchPathSize, redirect->wzPathNew);
               if (FAILED(hr))
               {
                  free (wzPathNew);
                  return FALSE;
               }
               hr = StringCchCatW(wzPathNew, cchPathSize, p);
               if (FAILED(hr))
               {
                  free(wzPathNew);
                  return FALSE;
               }                
                
               // return the new path
               LOGN( eDbgLevelWarning, "Redirecting: %S -> %S", *lpPath, wzPathNew);
               
               free(*lpPath);
               *lpPath = wzPathNew;
               
               return TRUE;
            }
            else
            {
                DPFN( eDbgLevelError, szOutOfMemory);
                return FALSE;
            }
        }
        redirect = redirect->next;
    }

    return FALSE;
}

/*++

 Function Description:


    Returns true if a protector guards this key.
    This will even work on a subkey of a protector.

 Arguments:

    IN lpPath - Path to protect

 Return Value:

    TRUE if protected

 History:

    08/07/2001 mikrause  Created

--*/

BOOL
CVirtualRegistry::CheckProtected(
    IN LPWSTR lpPath
    )
{
    PROTECTOR *protect;
        
    DWORD sza = wcslen(lpPath);
    DWORD szb;

    protect = KeyProtectors;
    while (protect)
    {
        szb = wcslen(protect->wzPath);

        // Check if we have a key or subkey match.
        if ((szb <= sza) &&
            (_wcsnicmp(protect->wzPath, lpPath, szb) == 0) &&
            (lpPath[szb] == L'\\' || lpPath[szb] == L'\0'))
        {
            // Protector found.
            LOGN( eDbgLevelWarning, "\tProtecting: %S", lpPath);
            return TRUE;                     
        }

        protect = protect->next;
    }

    // Fell through, no protector found.
    return FALSE;
}

/*++

 Function Description:

    Checks if any triggers should be called on this path,
    and calls them.

 Arguments:

    IN lpPath - Path to check triggers for.    

 Return Value:

    None

 History:

    08/09/2001 mikrause  Created

--*/

VOID
CVirtualRegistry::CheckTriggers(
    IN LPWSTR lpPath)
{
    OPENKEYTRIGGER *trigger;
    DWORD sza, szb;

    sza = wcslen(lpPath);
    trigger = OpenKeyTriggers;

    //
    // Loop through all triggers and check. Even after finding a match,
    // keep repeating, because a single OpenKey can cause multiple triggers.
    //
    while (trigger)
    {                
        szb = wcslen(trigger->wzPath);
        if ((szb <= sza) &&
            (_wcsnicmp(lpPath, trigger->wzPath, szb)==0) &&
            (lpPath[szb] == L'\\' || lpPath[szb] == L'\0'))
        {
            DPFN(eDbgLevelInfo, "Triggering %S on opening of %S", trigger->wzPath, lpPath);
            trigger->pfnTrigger(lpPath);
        }

        trigger = trigger->next;
    }
}

/*++

 Function Description:

    Flushes all enumerated lists.

 Arguments:

    IN lpPath    - Path to redirect, eg: HKLM\Software\Microsoft
    IN lpPathNew - Redirect to this path

 Return Value:

    None

 History:

    01/06/2000 linstev  Created

--*/

VOID
CVirtualRegistry::FlushEnumLists()
{
    OPENKEY *key;

    key = OpenKeys;
    while (key)
    {
        key->FlushEnumList();
        key = key->next;
    }
}

/*++

 Function Description:

    Add a redirector to the virtual registry. See CheckRedirect().

 Arguments:

    IN lpPath    - Path to redirect, eg: HKLM\Software\Microsoft
    IN lpPathNew - Redirect to this path

 Return Value:

    None

 History:

    01/06/2000 linstev  Created

--*/

REDIRECTOR *
CVirtualRegistry::AddRedirect(
    IN LPCWSTR lpPath, 
    IN LPCWSTR lpPathNew)
{
    REDIRECTOR *redirect = (REDIRECTOR *) malloc(sizeof(REDIRECTOR));
    
    if (!redirect)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    ZeroMemory(redirect, sizeof(REDIRECTOR));

    DWORD cchPath = wcslen(lpPath) + 1;
    DWORD cchNewPath = wcslen(lpPathNew) + 1;
    redirect->wzPath = (LPWSTR) malloc(cchPath * sizeof(WCHAR));
    redirect->wzPathNew = (LPWSTR) malloc(cchNewPath * sizeof(WCHAR));

    if (redirect->wzPath && redirect->wzPathNew)
    {
       HRESULT hr;
       hr = StringCchCopyW(redirect->wzPath, cchPath, lpPath);
       if (FAILED(hr))
       {
          goto ErrorCleanup;
       }
       hr = StringCchCopyW(redirect->wzPathNew, cchNewPath, lpPathNew);
       if (FAILED(hr))
       {
          goto ErrorCleanup;
       }        
    }
    else
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        goto ErrorCleanup;
        
    }

    redirect->next = Redirectors;
    Redirectors = redirect;

    DPFN( eDbgLevelSpew, "Adding Redirector:  %S ->\n  %S", lpPath, lpPathNew);

    return redirect;

ErrorCleanup:
   free(redirect->wzPath);
   free(redirect->wzPathNew);
   free(redirect);
   return NULL;   
}

/*++

 Function Description:

    Add a key protector to the virtual registry. See CheckProtected().

 Arguments:

    IN lpPath    - Path to protector, eg: HKLM\Software\Microsoft

 Return Value:

    None

 History:

    08/21/2001 mikrause  Created

--*/

PROTECTOR *
CVirtualRegistry::AddKeyProtector(
    IN LPCWSTR lpPath)
{
    PROTECTOR *protect = (PROTECTOR *) malloc(sizeof(PROTECTOR));
    
    if (!protect)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    ZeroMemory(protect, sizeof(PROTECTOR));

    DWORD cchPath = wcslen(lpPath) + 1;
    protect->wzPath = (LPWSTR) malloc(cchPath * sizeof(WCHAR));

    if (protect->wzPath)
    {
       HRESULT hr;
       hr = StringCchCopyW(protect->wzPath, cchPath, lpPath);
       if (FAILED(hr))
       {
          goto ErrorCleanup;
       } 
    }
    else
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        goto ErrorCleanup;
    }   

    DPFN( eDbgLevelSpew, "Adding Key Protector:  %S", lpPath);
    protect->next = KeyProtectors;
    KeyProtectors = protect;    

    return protect;

ErrorCleanup:
   free(protect->wzPath);
   free(protect);
   return NULL;
}

/*++

 Function Description:

    Add an open key trigger to the virtual registry.

 Arguments:

    IN lpPath    - Path to trigger on, eg: HKLM\Software\Microsoft
    IN pfnOpenKey - Function to be called when key is opened.

 Return Value:

    New open key trigger, or NULL on failure.

 History:

    08/07/2001 mikrause  Created

--*/

OPENKEYTRIGGER*
CVirtualRegistry::AddOpenKeyTrigger(
    IN LPCWSTR lpPath,
    IN _pfn_OpenKeyTrigger pfnOpenKey)
{
    OPENKEYTRIGGER *openkeytrigger = (OPENKEYTRIGGER *) malloc(sizeof(OPENKEYTRIGGER));
    
    if (!openkeytrigger)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    ZeroMemory(openkeytrigger, sizeof(OPENKEYTRIGGER));

    DWORD cchPath = wcslen(lpPath) + 1;
    openkeytrigger->wzPath = (LPWSTR) malloc(cchPath * sizeof(WCHAR));

    if (openkeytrigger->wzPath)
    {
       HRESULT hr = StringCchCopyW(openkeytrigger->wzPath, cchPath, lpPath);
       if (FAILED(hr))
       {
          goto ErrorCleanup;
       }        
    }
    else
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        goto ErrorCleanup;
    }

    openkeytrigger->pfnTrigger = pfnOpenKey;
    openkeytrigger->next = OpenKeyTriggers;
    OpenKeyTriggers = openkeytrigger;

    DPFN( eDbgLevelSpew, "Adding Open Key Trigger:  %S, func@0x%x", lpPath, pfnOpenKey);

    return openkeytrigger;

ErrorCleanup:
   free(openkeytrigger->wzPath);
   free(openkeytrigger);
   return NULL;
}

/*++

 Function Description:

    Allow user to specify VRegistry.AddKey instead of VRegistry.Root->AddKey.

 Arguments:

    IN lpPath - Path of key

 Return Value:

    Virtual key

 History:

    01/06/2000 linstev  Created

--*/

VIRTUALKEY *
CVirtualRegistry::AddKey(
    IN LPCWSTR lpPath
    )
{
    return Root->AddKey(lpPath);
}

/*++

 Function Description:

    Virtualized version of RegCreateKeyA, RegCreateKeyExA, RegOpenKeyA and RegOpenKeyExA
    See RegOpenKey* and RegCreateKey* for details

    Algorithm:
        1. Convert lpSubKey and lpClass to WCHAR
        2. Pass through to OpenKeyW

 Arguments:

    IN  hKey      - Handle to open key or HKLM etc
    IN  lpSubKey  - Subkey to open
    IN  lpClass   - Address of a class string
    IN  DWORD dwOptions - special options flag
    OUT phkResult       - Handle to open key if successful
    OUT lpdwDisposition - Address of disposition value buffer
    IN  bCreate   - Create the key if it doesn't exist

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG CVirtualRegistry::OpenKeyA(
    IN HKEY hKey, 
    IN LPCSTR lpSubKey, 
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES pSecurityAttributes,
    OUT HKEY *phkResult,
    OUT LPDWORD lpdwDisposition,
    IN BOOL bCreate
    )
{
    LONG lRet;
    LPWSTR wzSubKey = NULL; 
    LPWSTR wzClass = NULL;

    if (lpSubKey)
    {
        wzSubKey = ToUnicode(lpSubKey);
        if (!wzSubKey)
        {
            DPFN( eDbgLevelError, szOutOfMemory);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (lpClass)
    {
        wzClass = ToUnicode(lpClass);
        if (!wzClass)
        {
            free(wzSubKey);
            DPFN( eDbgLevelError, szOutOfMemory);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    lRet = OpenKeyW(
        hKey,
        wzSubKey,
        wzClass,
        dwOptions,
        samDesired,
        pSecurityAttributes,
        phkResult,
        lpdwDisposition,
        bCreate,
        FALSE,
        NULL);

    free(wzSubKey);
    free(wzClass);

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegOpenKeyExW, RegOpenKeyW, RegCreateKeyW and RegCreateKeyExW

    Algorithm:
       1. Strip leading '\' characters
       2. Inherit already open key data to get full key path
       3. Redirect if necessary
       4. RegOpenKeyEx with maximum possible security attributes
       5. If the open failed, check for virtual key
       6. If virtual, return a dummy key and succeed
       7. Find the virtual key if it exists and attach it to the open key

 Arguments:

    IN  hKey      - Handle to open key or HKLM etc
    IN  lpSubKey  - Subkey to open
    IN  lpClass   - Address of a class string
    IN  DWORD dwOptions - special options flag
    OUT phkResult       - Handle to open key if successful
    OUT lpdwDisposition - Address of disposition value buffer
    IN  bCreate   - Create the key if it doesn't exist
    IN  bRemote   - Opening the remote registry.
    IN  lpMachineName - Machine name.

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::OpenKeyW(
    IN HKEY hKey, 
    IN LPCWSTR lpSubKey, 
    IN LPWSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES pSecurityAttributes,
    OUT HKEY *phkResult,
    OUT LPDWORD lpdwDisposition,
    IN BOOL bCreate,
    IN BOOL bRemote,
    IN LPCWSTR lpMachineName
    )
{
    // Just a paranoid sanity check 
    if (!hKey)
    {
        DPFN( eDbgLevelError, "NULL handle passed to OpenKeyW");
        return ERROR_INVALID_HANDLE;
    }

    // Hack for Mavis Beacon which uses really old stack for this parameter
    if (lpdwDisposition && IsBadWritePtr(lpdwDisposition, sizeof(DWORD_PTR)))
    {
        DPFN( eDbgLevelError, "HACK: Ignoring bad lpdwDispostion pointer");
        lpdwDisposition = NULL;
    }

    LONG lRet;
    OPENKEY *key;
    BOOL bVirtual, bRedirected;
    VIRTUALKEY *vkey;
    LPWSTR wzPath = NULL;

    __try 
    {
        // Base error condition
         lRet = ERROR_INVALID_HANDLE;

        // Everybody AVs if this ones bad
        *phkResult = 0;

        samDesired &= (KEY_WOW64_64KEY | KEY_WOW64_32KEY);
        samDesired |= MAXIMUM_ALLOWED;

        // Win9x ignores the options parameter
        if (g_bWin9x)
        {
            if (dwOptions & REG_OPTION_VOLATILE)
            {
                LOGN( eDbgLevelWarning, "[OpenKeyW] Removing volatile flag");
            }
            dwOptions = REG_OPTION_NON_VOLATILE;
        }
        
        // Trim leading stuff, e.g. '\' character
        lpSubKey = TrimSlashW(lpSubKey);

        // Inherit from previously opened key
        key = FindOpenKey(hKey);
        if (key)
        {
            bVirtual = key->bVirtual;
            bRedirected = key->bRedirected;
            wzPath = MakePath(0, key->wzPath, lpSubKey);
        }
        else
        {
            bVirtual = FALSE;
            bRedirected = FALSE;
            wzPath = MakePath(hKey, NULL, lpSubKey);
        }
        
        if (!wzPath)
        {
            // Set the error code appropriately
            lRet = ERROR_NOT_ENOUGH_MEMORY;
        }
        // Check if we need to trigger on this key
        else
        {
            CheckTriggers(wzPath);
        }

        // Now that we have the full path, see if we want to redirect it
        if (!bRedirected && wzPath && CheckRedirect(&wzPath))
        {
            //
            // Turn off virtual mode - since we don't know anything about the
            // key we're redirecting to...
            // 

            bVirtual = FALSE;

            //
            // Make sure we know we've been redirected so we don't get into recursive 
            // problems if the destination is a subkey of the source.
            //

            bRedirected = TRUE;

            //
            // We've been redirected, so we can no longer open the key directly: 
            // we have to get the full path in order to open the right key.
            //

            lpSubKey = SplitPath(wzPath, &hKey);
        }

        // Try and open the key if it's not already virtual
        if (!bVirtual)
        {
            //
            // Since we aren't virtual yet, we need to try for the original 
            // key. If one of these fail, then we'll go ahead and try for a 
            // virtual key.
            //

            if (bCreate)
            {
                lRet = ORIGINAL_API(RegCreateKeyExW)(
                    hKey, 
                    lpSubKey, 
                    0, 
                    lpClass, 
                    dwOptions, 
                    samDesired,
                    pSecurityAttributes,
                    phkResult,
                    lpdwDisposition);

                if (lRet == ERROR_SUCCESS)
                {
                    // Possible change in enumeration data, flush lists.
                    FlushEnumLists();
                }
            }
            else
            {
                //
                // bRemote is only true when this is called by the 
                // RegConnectRegistry hook so bCreate can't be true.
                //

                if (bRemote)
                {
                    lRet = ORIGINAL_API(RegConnectRegistryW)(
                        lpMachineName, 
                        hKey, 
                        phkResult);
                }
                else
                {
                    lRet = ORIGINAL_API(RegOpenKeyExW)(
                        hKey, 
                        lpSubKey, 
                        0, 
                        samDesired,
                        phkResult);
                }
            }
        }

        //
        // We have to look up the virtual key even if we managed to open an 
        // actual key, because when we query, we look for virtual values 
        // first. i.e. the virtual values override existing values.
        //

        vkey = Root->FindKey(wzPath);

        // Check if our key is virtual, or may need to become virtual
        if (bVirtual || FAILURE(lRet))
        {
            if (vkey)
            {
                //
                // We have a virtual key, so create a dummy handle to hand back
                // to the app. 
                //

                *phkResult = CreateDummyKey();

                if (*phkResult)
                {
                   bVirtual = TRUE;
                   lRet = ERROR_SUCCESS;
                }
                else
                {
                   // Couldn't create the dummy key, something seriously wrong.
                   DPFN(eDbgLevelError, "Couldn't create dummy key in OpenKeyW");
                   lRet = ERROR_FILE_NOT_FOUND;
                }
                
            }
        }

        if (SUCCESS(lRet) && wzPath)
        {
            // Made it this far, so make a new key entry
            key = (OPENKEY *) malloc(sizeof(OPENKEY));
            if (key)
            {
                key->vkey = vkey;
                key->bVirtual = bVirtual;
                key->bRedirected = bRedirected;
                key->hkOpen = *phkResult;
                key->wzPath = wzPath;
                key->enumKeys = NULL;
                key->enumValues = NULL;
                key->next = OpenKeys;
                OpenKeys = key;
            }
            else
            {
                DPFN( eDbgLevelError, szOutOfMemory);
                
                 // Clean up the dummy key
                 RegCloseKey(*phkResult);

                 lRet = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
         
        DPFN( ELEVEL(lRet), "%08lx=OpenKeyW(Key=%04lx)", lRet, hKey);
        if (wzPath)
        {
            DPFN( ELEVEL(lRet), "    Path=%S", wzPath);
        }
        DPFN( ELEVEL(lRet), "    Result=%04lx", *phkResult);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPFN( eDbgLevelError, "Exception occurred in OpenKeyW");
        lRet = ERROR_BAD_ARGUMENTS;
    }

    if (FAILURE(lRet))
    {
        //
        // If we failed for any reason, we didn't create an OPENKEY and so we 
        // can kill wzPath which was allocated by MakePath.
        //
        free(wzPath);
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegQueryValueExA and RegQueryValue.
    See QueryValueW for more details.
    
    Algorithm:
        1. Call QueryValueW
        2. If it's a string, convert back to ANSI

    Note: this whole function is slightly more complex than it needs to be 
    because we don't want to query the value twice: once to get it's type 
    and the second time to get the value.

    Most of the complications are due to the strings: we have to make sure we 
    have a buffer large enough so we can figure out how large the (possibly
    DBCS) string is.

 Arguments:

    IN hKey         - Handle to open key 
    IN lpValueName  - Value to query
    IN lpType       - Type of data, eg: REG_SZ
    IN OUT lpData   - Buffer for queries data
    IN OUT lpcbData - Size of input buffer/size of returned data

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::QueryValueA(
    IN HKEY hKey, 
    IN LPSTR lpValueName, 
    IN LPDWORD lpType, 
    IN OUT LPBYTE lpData, 
    IN OUT LPDWORD lpcbData
    )
{
    LONG lRet;
    WCHAR wValueName[MAX_PATH];
    DWORD dwType;
    DWORD dwSize, dwOutSize;
    LPBYTE lpBigData = NULL;
    BOOL bText;

    __try
    {
        // Can't have this
        if (lpData && !lpcbData)
        {
            return ERROR_INVALID_PARAMETER;
        }

        // Convert the Value Name to WCHAR
        if (lpValueName)
        {
           if (MultiByteToWideChar(
              CP_ACP, 
              0, 
              lpValueName, 
              -1, 
              (LPWSTR)wValueName, 
              MAX_PATH) == 0)
           {
              return ERROR_INVALID_PARAMETER;
           }
        }
        else
        {
           wValueName[0] = L'\0';           
        }

        //
        // Get an initial size to use: if they sent us a buffer, we start with 
        // that size, otherwise, we try a reasonable string length
        //

        if (lpData && *lpcbData)
        {
            dwSize = *lpcbData;
        }
        else
        {
            dwSize = MAX_PATH;
        }        

Retry:
        //
        // We can't touch their buffer unless we're going to succeed, so we 
        // have to double buffer the call.
        //

        lpBigData = (LPBYTE) malloc(dwSize);

        if (!lpBigData)
        {
            DPFN( eDbgLevelError, szOutOfMemory);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        lRet = QueryValueW(hKey, wValueName, &dwType, lpBigData, &dwSize);

        //
        // We need to know if it's a string, since then we have to do extra 
        // work to calculate the real size of the buffer etc.
        //

        bText = (SUCCESS(lRet) || (lRet == ERROR_MORE_DATA)) &&
                ((dwType == REG_SZ) || 
                 (dwType == REG_EXPAND_SZ) || 
                 (dwType == REG_MULTI_SZ));

        if (bText && (lRet == ERROR_MORE_DATA))
        {
            //
            // The buffer wasn't big enough: we have to actually query the value 
            // so we can get the real length in case it's DBCS, so we retry. 
            // Note: dwSize now contains the required size, so it will succeed
            // this time around.
            //

            free(lpBigData);

            goto Retry;
        }

        //
        // Calculate the size of the output buffer: if it's text, it may be
        // a DBCS string, so we need to get the right size
        //

        if (bText)
        {
            dwOutSize = WideCharToMultiByte(
                CP_ACP, 
                0, 
                (LPWSTR) lpBigData, 
                dwSize / sizeof(WCHAR), 
                NULL, 
                NULL,
                0, 
                0);
        }
        else
        {
            // It's not text, so we just use the actual size
            dwOutSize = dwSize;
        }

        //
        // If they gave us a buffer, we fill it in with what we got back
        //

        if (SUCCESS(lRet) && lpData)
        {
            //
            // Make sure we have enough space: lpcbData is guaranteed to be 
            // valid since lpData is ok.
            //

            if (*lpcbData >= dwOutSize)
            {
                if (bText)
                {
                    //
                    // Convert the string back to ANSI. The buffer must have been big 
                    // enough since QueryValue succeeded.
                    // Note: we have to give the exact size to convert otherwise we 
                    // use more of the buffer than absolutely necessary. Some apps, 
                    // like NHL 98 say they have a 256 byte buffer, but only give us 
                    // a 42 byte buffer. On NT, everything is done in place on that 
                    // buffer: so we always use more than the exact string length.
                    // This shim gets around that because we use separate buffers.
                    //

                    if (WideCharToMultiByte(
                        CP_ACP, 
                        0, 
                        (LPWSTR)lpBigData, 
                        dwSize / 2, 
                        (LPSTR)lpData, 
                        dwOutSize, // *lpcbData, 
                        0, 
                        0) == 0)
                    {
                       free(lpBigData);
                       return ERROR_INVALID_PARAMETER;
                    }
                }
                else 
                {
                    MoveMemory(lpData, lpBigData, dwSize);
                }
            }
            else
            {
                lRet = ERROR_MORE_DATA;
            }
        }

        free(lpBigData);

        // Fill the output structures in if possible
        if (lpType)
        {
            *lpType = dwType;
        }

        if (lpcbData)
        {
            *lpcbData = dwOutSize;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPFN( eDbgLevelError, "Exception occurred in QueryValueA");
        lRet = ERROR_BAD_ARGUMENTS;
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegQueryValueExW and RegQueryValue. We first see if the value 
    is virtual because virtual values override actual values

    Algorithm:
        1. Check if it's a virtual value and if so, spoof it
        2. If it's not virtual, query registry normally

 Arguments:

    IN hKey         - Handle to open key 
    IN lpValueName  - Value to query
    IN lpType       - Type of data, eg: REG_SZ
    IN OUT lpData   - Buffer for queries data
    IN OUT lpcbData - Size of input buffer/size of returned data

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::QueryValueW(
    IN HKEY hKey, 
    IN LPWSTR lpValueName, 
    IN LPDWORD lpType, 
    IN OUT LPBYTE lpData, 
    IN OUT LPDWORD lpcbData
    )
{
    // Just a paranoid sanity check 
    if (!hKey)
    {
        DPFN( eDbgLevelError, "NULL handle passed to OpenKeyW");
        return ERROR_INVALID_HANDLE;
    }

    LONG lRet;
    OPENKEY *key;
    VIRTUALKEY *vkey;
    VIRTUALVAL *vvalue;
    DWORD dwType;
    WCHAR* lpBuffer;
    DWORD dwStringSize;
    DWORD cbData = 0;
    BOOL  bDataPresent = TRUE;

    __try
    {
        lRet = ERROR_FILE_NOT_FOUND;
        
        // Can't have this
        if (lpData && !lpcbData)
        {   
            return ERROR_INVALID_PARAMETER;
        }

        // We always need the type
        if (!lpType)
        {
            lpType = &dwType;
        }

        // Do we want to spoof this
        key = FindOpenKey(hKey);
        vkey = key ? key->vkey : NULL;
        vvalue = vkey ? vkey->FindValue(lpValueName) : NULL;        

        if (key && vkey && vvalue &&
            (vvalue->cbData != 0 || vvalue->pfnQueryValue))
        {
            // Use the callback if available
            if (vvalue->pfnQueryValue)
            {
                //
                // Note, the callback puts it's values into the vvalue field,
                // just as if we knew it all along. In addition, we can fail
                // the call... but that doesn't allow us defer to the original
                // value. 
                //

                lRet = (*vvalue->pfnQueryValue)(
                    key,
                    vkey,
                    vvalue);
            }
            else
            {
                lRet = ERROR_SUCCESS;
            }

            // Copy the virtual value into the buffer
            if (SUCCESS(lRet))
            {
                *lpType = vvalue->dwType;

                if (lpData)
                {
                    if (vvalue->cbData <= *lpcbData)
                    {
                        MoveMemory(lpData, vvalue->lpData, vvalue->cbData);
                    }
                    else 
                    {
                        lRet = ERROR_MORE_DATA;
                    }
                }

                if (lpcbData)
                {
                    *lpcbData = vvalue->cbData;
                }
            }
        }
        else if (key && vkey && vvalue &&
            (vvalue->cbData == 0))
        {
            bDataPresent = FALSE;
            lRet = ERROR_SUCCESS;
        }
        else
        {
            // Save the size of the data buffer.
            if (lpcbData)
            {
                cbData = *lpcbData;
            }

            //
            // Get the key normally as if it weren't virtual at all
            //

            lRet = ORIGINAL_API(RegQueryValueExW)(
                hKey, 
                lpValueName, 
                NULL, 
                lpType, 
                lpData, 
                lpcbData);

            //
            // Some apps store bogus data beyond the end of the string.
            // Attempt to fix.
            //

            // Only try this if it's a string.
            if (lRet == ERROR_MORE_DATA && (*lpType == REG_SZ || *lpType == REG_EXPAND_SZ))
            {
                //
                // Create a buffer large enough to hold the data
                // We read from lpcbData here, but this should be ok,
                // since RegQueryValueEx shouldn't return ERROR_MORE_DATA
                // if lpcbData is NULL.
                //
                lpBuffer = (WCHAR*)malloc(*lpcbData);
                if (lpBuffer)
                {
                    // Requery with new buffer.
                    lRet = ORIGINAL_API(RegQueryValueExW)(
                        hKey, 
                        lpValueName, 
                        NULL, 
                        lpType, 
                        (BYTE*)lpBuffer, 
                        lpcbData);

                    if (lRet == ERROR_SUCCESS)
                    {
                        dwStringSize = wcslen(lpBuffer)*sizeof(WCHAR) + sizeof(WCHAR);
                        // If size of dest buffer can hold the string . . .
                        if (cbData >= dwStringSize)
                        {
                            DPFN(eDbgLevelInfo, "\tTrimming data beyond end of string in Query for %S", lpValueName);

                            // Copy the data to the caller's buffer,                             
                            CopyMemory(lpData, lpBuffer, dwStringSize);

                            *lpcbData = dwStringSize;
                        }
                        else
                        {
                            // Set *lpcbData to the correct size, and return more data error
                            *lpcbData = dwStringSize;

                            lRet = ERROR_MORE_DATA;
                        }
                    }                                        

                    free(lpBuffer);
                }
            }

            //
            // Here's another hack for us: if the value is NULL or an empty string
            // Win9x defers to QueryValue...
            //

            if (g_bWin9x && (lRet == ERROR_FILE_NOT_FOUND) && 
                (!lpValueName || !lpValueName[0]))
            {
                lRet = ORIGINAL_API(RegQueryValueW)(
                    hKey,
                    NULL,
                    (LPWSTR)lpData,
                    (PLONG)lpcbData);

                if (SUCCESS(lRet))
                {
                    *lpType = REG_SZ;
                }
            }
        }

        DPFN( ELEVEL(lRet), "%08lx=QueryValueW(Key=%04lx)", 
            lRet,
            hKey);
    
        if (key)
        {
            DPFN( ELEVEL(lRet), "    Path=%S\\%S", key->wzPath, lpValueName);
        }
        else
        {
            DPFN( ELEVEL(lRet), "    Value=%S", lpValueName);
        }
        
        if (SUCCESS(lRet) && 
            ((*lpType == REG_SZ) || 
             (*lpType == REG_EXPAND_SZ))&&
             (bDataPresent == TRUE))
        {
            DPFN( eDbgLevelInfo, "    Result=%S", lpData);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPFN( eDbgLevelError, "Exception occurred in QueryValueW");
        lRet = ERROR_BAD_ARGUMENTS;    
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegEnumKeyA
    Call out to EnumKeyW and convert the name back to ANSI. Note we pass the
    size given to us (in lpcbName) down to EnumKeyW in case the lpName buffer
    is too small.

    Algoritm:
        1. EnumKeyW with a large buffer
        2. Convert the key back to ansi if it succeeds

 Arguments:

    IN hKey         - Handle to open key 
    IN dwIndex      - Index to enumerate
    OUT lpName      - Name of subkey
    IN OUT lpcbName - Size of name buffer

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::EnumKeyA(
    IN HKEY hKey,          
    IN DWORD dwIndex,      
    OUT LPSTR lpName,      
    OUT LPDWORD lpcbName
    )
{
    LONG lRet = ERROR_NO_MORE_ITEMS;
    WCHAR wKey[MAX_PATH + 1];
    DWORD dwcbName = MAX_PATH + 1;

    __try
    {
        lRet = EnumKeyW(hKey, dwIndex, (LPWSTR)wKey, &dwcbName);

        if (SUCCESS(lRet))
        {
            DWORD dwByte = WideCharToMultiByte(
                CP_ACP, 
                0, 
                (LPWSTR)wKey, 
                dwcbName, 
                (LPSTR)lpName, 
                *lpcbName, 
                0, 
                0);
            
            lpName[dwByte] = '\0'; 
            *lpcbName = dwByte;
            if (!dwByte)
            {
                lRet = GetLastError();
                
                // Generate a registry error code
                if (lRet == ERROR_INSUFFICIENT_BUFFER)
                {
                    lRet = ERROR_MORE_DATA;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        lRet = ERROR_BAD_ARGUMENTS;    
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegEnumKeyW. 
    
    Algorithm:
        1. Build enumeration list, if necessary.
        2. Iterate through enumeration list until index is found.
    
 Arguments:

    IN hKey      - Handle to open key 
    IN dwIndex   - Index to enumerate
    OUT lpName   - Name of subkey
    OUT lpcbName - Size of name buffer

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::EnumKeyW(
    HKEY hKey,          
    DWORD dwIndex,      
    LPWSTR lpName,      
    LPDWORD lpcbName
    )
{
    LONG lRet = ERROR_BAD_ARGUMENTS;
    OPENKEY *key;
    ENUMENTRY *enumkey;
    DWORD i;

    __try
    {
        key = FindOpenKey(hKey);
        if (key)
        {
            if (key->enumKeys == NULL)
            {
                key->BuildEnumList();
            }

            i = 0;
            enumkey = key->enumKeys;
            while (enumkey)
            {
                if (dwIndex == i)
                {
                    DWORD len = wcslen(enumkey->wzName);

                    if (*lpcbName > len)
                    {
                       HRESULT hr;
                       hr = StringCchCopyW(lpName, *lpcbName, enumkey->wzName);
                       if (FAILED(hr))
                       {
                          lRet = ERROR_MORE_DATA;
                       }
                       else
                       {
                          *lpcbName = len;
                          lRet = ERROR_SUCCESS;
                       }
                    }
                    else
                    {
                        lRet = ERROR_MORE_DATA;
                    }

                    break;
                }

                i++;
                enumkey = enumkey->next;
            }

            // No key found for index
            if (enumkey == NULL)
            {
                lRet = ERROR_NO_MORE_ITEMS;
            }    
        }
        else
        {
            lRet = ORIGINAL_API(RegEnumKeyExW)(
                hKey,
                dwIndex,
                lpName,
                lpcbName,
                0,
                0,
                0,
                0);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        lRet = ERROR_BAD_ARGUMENTS;    
    }

    DPFN( ELEVEL(lRet), "%08lx=EnumKeyW(hKey=%04lx,dwIndex=%d)", 
        lRet,
        hKey, 
        dwIndex);
    
    if (SUCCESS(lRet))
    {
        DPFN( eDbgLevelInfo, "    Result=%S", lpName);
    }
    
    return lRet;
}

/*++

 Function Description:

    Wrapper for RegEnumValueA. Thunks to QueryValueW.
    This function calls QueryValueA to get the data 
    out of the value, so most error handling is done by QueryValueA.

 Arguments:

    IN hKey              - Handle to open key 
    IN dwIndex           - Index of value to enumerate      
    IN OUT lpValueName   - Value name buffer
    IN OUT lpcbValueName - Sizeof value name buffer
    IN OUT lpType        - Type of data, eg: REG_SZ
    IN OUT lpData        - Buffer for queries data
    IN OUT lpcbData      - Size of input buffer/size of returned data

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/
 
LONG 
CVirtualRegistry::EnumValueA(
    IN HKEY hKey,          
    IN DWORD dwIndex,      
    IN OUT LPSTR lpValueName,      
    IN OUT LPDWORD lpcbValueName,
    IN OUT LPDWORD lpType,
    IN OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )
{
    LONG lRet;
    WCHAR wzValueName[MAX_PATH];
    DWORD dwValNameSize;
    

    __try
    {
        dwValNameSize = MAX_PATH;
        lRet = EnumValueW(hKey, dwIndex, wzValueName, &dwValNameSize, NULL, NULL, NULL);
        if (lRet == ERROR_SUCCESS)
        {
            dwValNameSize = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                wzValueName,
                                -1,
                                lpValueName,
                                *lpcbValueName,
                                NULL,
                                NULL);
            if (dwValNameSize != 0)
            {
                // Just do a normal query value for the remaining parameters.
                lRet = QueryValueA(hKey, lpValueName, lpType, lpData, lpcbData);
            }
            else
            {
                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                {
                    lRet = ERROR_MORE_DATA;
                    *lpcbValueName = WideCharToMultiByte(
                                        CP_ACP,
                                        0,
                                        wzValueName,
                                        -1,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL);
                }
                else
                {
                    lRet = GetLastError();
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        lRet = ERROR_BAD_ARGUMENTS;    
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegEnumValueW. This function calls QueryValueW to get the data 
    out of the value, so most error handling is done by QueryValueW.

    Algorithm:
        1. Check if key has virtual values, if not default to RegEnumValueW.
        2. Build enumeration list, if necessary.
        3. Iterate through enumeration list until index is found.

 Arguments:

    IN hKey              - Handle to open key 
    IN dwIndex           - Index of value to enumerate      
    IN OUT lpValueName   - Value name buffer
    IN OUT lpcbValueName - Sizeof value name buffer
    IN OUT lpType        - Type of data, eg: REG_SZ
    IN OUT lpData        - Buffer for queries data
    IN OUT lpcbData      - Size of input buffer/size of returned data

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/
 
LONG 
CVirtualRegistry::EnumValueW(
    IN HKEY hKey,          
    IN DWORD dwIndex,      
    IN OUT LPWSTR lpValueName,      
    IN OUT LPDWORD lpcbValueName,
    IN OUT LPDWORD lpType,
    IN OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )
{
    LONG lRet;
    OPENKEY *key;
    ENUMENTRY *enumval;
    
    // Check if it has virtual values . . .
    key = FindOpenKey(hKey);
    if (key && key->vkey && key->vkey->values)
    {
        DWORD i = 0;
        if (key->enumValues == NULL)
        {
            key->BuildEnumList();
        }

        enumval = key->enumValues;

        lRet = ERROR_NO_MORE_ITEMS;

        while (enumval)
        {
            if (dwIndex == i)
            {
                DWORD len = wcslen(enumval->wzName);

                if (*lpcbValueName > len)
                {
                   // Copy the name and query the data
                   HRESULT hr = StringCchCopyW(lpValueName, *lpcbValueName, enumval->wzName);
                   if (FAILED(hr))
                   {
                      lRet = ERROR_MORE_DATA;
                   }
                   else
                   {                  
                       *lpcbValueName = len;
                       lRet = QueryValueW(
                           hKey, 
                           enumval->wzName, 
                           lpType, 
                           lpData, 
                           lpcbData);
                   }
                }
                else
                {
                    // The buffer given for name wasn't big enough
                    lRet = ERROR_MORE_DATA;
                }
                
                break;
            }
            i++;
            enumval = enumval->next;
        }
    }
    // No virtual values, fall through to original API.
    else
    {
        lRet = ORIGINAL_API(RegEnumValueW)(
            hKey,
            dwIndex,
            lpValueName,
            lpcbValueName,
            0,
            lpType,
            lpData,
            lpcbData);
    }

    DPFN( ELEVEL(lRet), "%08lx=EnumValueW(hKey=%04lx,dwIndex=%d)", 
        lRet,
        hKey, 
        dwIndex);

    if (SUCCESS(lRet))
    {
        DPFN( eDbgLevelInfo, "    Result=%S", lpValueName);
    }
    
    return lRet;
}

/*++

 Function Description:

    Wrapper for RegQueryInfoKeyA. 
    We don't need to worry about the conversion of ansi->unicode in the sizes 
    of values and keys because they are defined as string lengths.
    
    Algorithm:
        1. Convert the class string to unicode
        2. Call QueryInfoW


 Arguments:

    IN hKey                     - handle to key to query
    OUT lpClass                 - address of buffer for class string
    OUT lpcbClass               - address of size of class string buffer
    OUT lpReserved              - reserved
    OUT lpcSubKeys              - address of buffer for number of subkeys
    OUT lpcbMaxSubKeyLen        - address of buffer for longest subkey  
    OUT lpcbMaxClassLen         - address of buffer for longest class string length
    OUT lpcValues               - address of buffer for number of value entries
    OUT lpcbMaxValueNameLen     - address of buffer for longest value name length
    OUT lpcbMaxValueLen         - address of buffer for longest value data length
    OUT lpcbSecurityDescriptor  - address of buffer for security descriptor length
    OUT lpftLastWriteTime       - address of buffer for last write time

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::QueryInfoA(
    IN HKEY hKey,                
    OUT LPSTR lpClass,           
    OUT LPDWORD lpcbClass,        
    OUT LPDWORD lpReserved,       
    OUT LPDWORD lpcSubKeys,       
    OUT LPDWORD lpcbMaxSubKeyLen, 
    OUT LPDWORD lpcbMaxClassLen,  
    OUT LPDWORD lpcValues,        
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,  
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime   
    )
{
    LONG lRet;

    if (lpClass && !lpcbClass)
    {
        LOGN( eDbgLevelError, "[QueryInfoA] NULL passed for lpClass but not lpcbClass. Fixing.");
        lpcbClass = NULL;
    }
    
    if (lpClass && lpcbClass)
    {
        WCHAR wClass[MAX_PATH];
        DWORD dwSize;
        
        if (MultiByteToWideChar(
            CP_ACP, 
            0, 
            lpClass, 
            -1, 
            (LPWSTR)wClass, 
            MAX_PATH) == 0)
        {
           return ERROR_INVALID_PARAMETER;
        }

        dwSize = *lpcbClass * 2;

        lRet = QueryInfoW(
            hKey, 
            wClass, 
            &dwSize, 
            lpReserved,       
            lpcSubKeys,       
            lpcbMaxSubKeyLen, 
            lpcbMaxClassLen,  
            lpcValues,        
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,  
            lpcbSecurityDescriptor,
            lpftLastWriteTime);


        if (SUCCESS(lRet))
        {
            if (WideCharToMultiByte(
                CP_ACP, 
                0, 
                (LPWSTR)wClass, 
                dwSize, 
                (LPSTR)lpClass, 
                *lpcbClass, 
                0, 
                0) == 0)
            {
               return ERROR_INVALID_PARAMETER;
            }
        }

        *lpcbClass = dwSize / 2;
    }
    else
    {
        lRet = QueryInfoW(
            hKey, 
            NULL, 
            NULL, 
            lpReserved,       
            lpcSubKeys,       
            lpcbMaxSubKeyLen, 
            lpcbMaxClassLen,  
            lpcValues,        
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,  
            lpcbSecurityDescriptor,
            lpftLastWriteTime);
    }

    return lRet;    
}

/*++

 Function Description:

    Wrapper for RegQueryInfoKeyW. 
    
    Algorithm:
        1. Revert to the old API if the key isn't virtual
        2. Calculate all the virtual key and value name lengths by going through
           them individually.
        3. Add all non-virtual key and value's that don't have overriding virtual's.

 Arguments:

    IN hKey                    - handle to key to query
    OUT lpClass                - address of buffer for class string
    OUT lpcbClass              - address of size of class string buffer
    OUT lpReserved             - reserved
    OUT lpcSubKeys             - address of buffer for number of subkeys
    OUT lpcbMaxSubKeyLen       - address of buffer for longest subkey  
    OUT lpcbMaxClassLen        - address of buffer for longest class string length
    OUT lpcValues              - address of buffer for number of value entries
    OUT lpcbMaxValueNameLen    - address of buffer for longest value name length
    OUT lpcbMaxValueLen        - address of buffer for longest value data length
    OUT lpcbSecurityDescriptor - address of buffer for security descriptor length
    OUT lpftLastWriteTime      - address of buffer for last write time

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created
    08/03/2001 mikrause Added support for counting both virtual & non-virtual keys & values.

--*/

LONG 
CVirtualRegistry::QueryInfoW(
    IN HKEY hKey,                
    OUT LPWSTR lpClass,           
    OUT LPDWORD lpcbClass,        
    OUT LPDWORD lpReserved,       
    OUT LPDWORD lpcSubKeys,       
    OUT LPDWORD lpcbMaxSubKeyLen, 
    OUT LPDWORD lpcbMaxClassLen,  
    OUT LPDWORD lpcValues,        
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,  
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime   
    )
{
    LONG lRet;
    OPENKEY *key;

    DWORD cbData = 0;
    ENUMENTRY *enumkey;
    ENUMENTRY *enumval;
    
    if (lpClass && !lpcbClass)
    {
        LOGN( eDbgLevelError, "[QueryInfoW] NULL passed for lpClass but not lpcbClass. Fixing.");
        lpcbClass = NULL;
    }
     
    key = FindOpenKey(hKey);
    if (key)
    {
        if (lpClass)
        {
           lpClass[0] = L'\0';            
        }

        if (lpcbClass)
        {
            *lpcbClass = 0;
        }

        if (lpcbMaxClassLen)
        {
            *lpcbMaxClassLen = 0;
        }

        if (lpReserved)
        {
            *lpReserved = 0;
        }

        if (lpcSubKeys || lpcbMaxSubKeyLen)
        {   
            DWORD i = 0;
            DWORD len = 0;

            // Count virtual keys.
            if (!key->enumKeys)
            {
                key->BuildEnumList();
            }

            enumkey = key->enumKeys;
            while (enumkey)
            {
                i++;
                len = max(len, wcslen(enumkey->wzName));
                enumkey = enumkey->next;
            }

            if (lpcSubKeys)
            {
                *lpcSubKeys = i;
            }
            if (lpcbMaxSubKeyLen)
            {
                *lpcbMaxSubKeyLen = len;
            }
        }

        if (lpcValues || lpcbMaxValueNameLen || lpcbMaxValueLen)
        {
            // Check if this key has virtual values or is virtual.
            if (key->bVirtual || (key->vkey && key->vkey->values))
            {
                DWORD i = 0; 
                DWORD lenA = 0, lenB = 0;

                if (key->enumValues == NULL)
                {
                    key->BuildEnumList();
                }

                enumval = key->enumValues;
                while (enumval)
                {
                    i++;
                    QueryValueW(key->hkOpen, enumval->wzName, NULL, NULL, &cbData);

                    lenA = max(lenA, cbData);
                    lenB = max(lenB, wcslen(enumval->wzName));
                    enumval = enumval->next;
                }

                if (lpcValues)
                {
                    *lpcValues = i;
                }
                if (lpcbMaxValueLen)
                {
                    *lpcbMaxValueLen = lenA;
                }
                if (lpcbMaxValueNameLen)
                {
                    *lpcbMaxValueNameLen = lenB;
                }
            }
            // No virtual values, do a normal query.
            else
            {
                lRet = ORIGINAL_API(RegQueryInfoKeyW)(
                    key->hkOpen,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    lpcValues,
                    lpcbMaxValueNameLen,
                    lpcbMaxValueLen,
                    NULL,
                    lpftLastWriteTime);

            }
        }
        if (lpcbSecurityDescriptor)
        {
            *lpcbSecurityDescriptor = NULL;
        }

        lRet = ERROR_SUCCESS;
    }
    else
    {
        lRet = ORIGINAL_API(RegQueryInfoKeyW)(
                    hKey, 
                    lpClass, 
                    lpcbClass, 
                    lpReserved,       
                    lpcSubKeys,       
                    lpcbMaxSubKeyLen, 
                    lpcbMaxClassLen,  
                    lpcValues,        
                    lpcbMaxValueNameLen,
                    lpcbMaxValueLen,  
                    lpcbSecurityDescriptor,
                    lpftLastWriteTime);
    }

    DPFN( ELEVEL(lRet), "%08lx=QueryInfoW(hKey=%04lx)", 
        lRet,
        hKey);

    if (key)
    {
        DPFN( ELEVEL(lRet), "    Path=%S", key->wzPath);
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegSetValueA.

    Algorithm:
    1. Convert value name and data (if string) to Unicode.
    2. Call SetValueW

 Arguments:

    hKey - Key to set value in.
    lpValueName - Name of value to set.
    dwType - Type of value (string, DWORD, etc.)
    lpData - Buffer containing data to write.
    cbData - Size of lpData in bytes.

 Return Value:

    ERROR_SUCCESS on success, failure code otherwise.

 History:

    08/07/2001 mikrause  Created

--*/

LONG
CVirtualRegistry::SetValueA(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    )
{
    LONG lRet;
    DWORD dwSize;
    WCHAR* wszValName = NULL;
    BYTE* lpExpandedData = (BYTE*)lpData;

    if (lpValueName != NULL)
    {
        dwSize = (DWORD)(lstrlenA(lpValueName) + 1);
        dwSize *= sizeof(WCHAR);
        wszValName = (WCHAR*)malloc(dwSize);
        if (wszValName == NULL)
        {
            DPFN( eDbgLevelError, szOutOfMemory);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (MultiByteToWideChar(
            CP_ACP, 
            0, 
            lpValueName, 
            -1, 
            (LPWSTR)wszValName, 
            dwSize/sizeof(WCHAR)) == 0)
        {
           return ERROR_INVALID_PARAMETER;
        }
    }

    dwSize = cbData;

    //
    // Expand text buffers
    //
    if (lpData && (dwType == REG_SZ || dwType == REG_EXPAND_SZ || dwType == REG_MULTI_SZ))
    {
        if ((dwType != REG_MULTI_SZ) && g_bWin9x)
        {
            dwSize = (DWORD)(lstrlenA((char*)lpData) + 1);
        }

        lpExpandedData = (BYTE*) malloc(dwSize * sizeof(WCHAR));
        if (lpExpandedData == NULL)
        {
            if (wszValName)
            {
                free(wszValName);
            }

            DPFN( eDbgLevelError, szOutOfMemory);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (MultiByteToWideChar(
            CP_ACP, 
            0, 
            (LPCSTR)lpData, 
            dwSize, 
            (LPWSTR)lpExpandedData, 
            dwSize) == 0)
        {
           return ERROR_INVALID_PARAMETER;
        }
        
        dwSize = dwSize * sizeof(WCHAR);
    }

    lRet = SetValueW(hKey, wszValName, dwType, lpExpandedData, dwSize);

    if (lpExpandedData != lpData)
    {
        free(lpExpandedData);
    }

    if (wszValName)
    {
        free(wszValName);
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegSetValueW.
    Also protects for non-zero buffer length with zero buffer AV.

    Algorithm:
    1. If non-protected key, write to registry using RegSetValueW

 Arguments:

    hKey - Key to set value in.
    lpValueName - Name of value to set.
    dwType - Type of value (string, DWORD, etc.)
    lpData - Buffer containing data to write.
    cbData - Size of lpData in bytes.

 Return Value:

    ERROR_SUCCESS on success, failure code otherwise.

 History:

    08/07/2001 mikrause  Created

--*/

LONG
CVirtualRegistry::SetValueW(
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    )
{
    LONG lRet;

    // Just a paranoid sanity check 
    if (!hKey)
    {
        DPFN( eDbgLevelError, "NULL handle passed to SetValueW");
        return ERROR_INVALID_HANDLE;
    }
    __try
    {
        lRet = ERROR_FILE_NOT_FOUND;

        // To duplicate Win95/win98 behavior automatically override
        // the cbData with the actual length of the lpData for REG_SZ.
        if (g_bWin9x && lpData && 
            ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ)))
        {
            cbData = (wcslen((WCHAR *)lpData)+1)*sizeof(WCHAR);
        }

        VIRTUALKEY *vkey;
        VIRTUALVAL *vvalue;
        OPENKEY* key = FindOpenKey(hKey);
        if (key)
        {
            // Check if we should execute a custom action.
            vkey = key->vkey;
            vvalue = vkey ? vkey->FindValue(lpValueName) : NULL;
            if (vkey && vvalue &&
                vvalue->pfnSetValue)
            {
                lRet = vvalue->pfnSetValue(key, vkey, vvalue,
                        dwType, lpData,cbData);
            }
            else
            {
                // No custom action, just set value as normal.
                lRet = ORIGINAL_API(RegSetValueExW)(
                    hKey,
                    lpValueName,
                    0,
                    dwType,
                    lpData,
                    cbData);
            }
            // Possible change in enumeration data, flush lists.
            if (lRet == ERROR_SUCCESS)
            {
                key->FlushEnumList();
            }
        }
        // No key, fall through to original API
        else
        {
            lRet = ORIGINAL_API(RegSetValueExW)(
                    hKey,
                    lpValueName,
                    0,
                    dwType,
                    lpData,
                    cbData);
        }
                    
        DPFN( ELEVEL(lRet), "%08lx=SetValueW(Key=%04lx)", 
            lRet,
            hKey);

        if (key)
        {
            DPFN( ELEVEL(lRet), "    Path=%S\\%S", key->wzPath, lpValueName);
        }
        else
        {
            DPFN( ELEVEL(lRet), "    Value=%S", lpValueName);
        }

        if (SUCCESS(lRet) && 
            ((dwType == REG_SZ) || 
            (dwType == REG_EXPAND_SZ)))
        {
            DPFN( eDbgLevelInfo, "    Result=%S", lpData);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPFN( eDbgLevelError, "Exception occurred in SetValueW");
        lRet = ERROR_BAD_ARGUMENTS;    
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegDeleteKeyA.

    Algorithm:
    1. Convert key name to Unicode.
    2. Call DeleteKeyW

 Arguments:

    hKey - Key that contains subkey to delete.    
    lpSubKey - Key name to delete.

 Return Value:

    ERROR_SUCCESS on success, failure code otherwise.

 History:

    08/07/2001 mikrause  Created

--*/

LONG
CVirtualRegistry::DeleteKeyA(
    IN HKEY hKey,
    IN LPCSTR lpSubKey
    )
{
    LONG lRet;
    DWORD dwSize;
    WCHAR*  wszSubKey = NULL;

    dwSize = (DWORD)(lstrlenA(lpSubKey) + 1);
    dwSize *= sizeof(WCHAR);
    wszSubKey = (WCHAR*)malloc(dwSize);
    if (wszSubKey == NULL)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (MultiByteToWideChar(
        CP_ACP, 
        0, 
        lpSubKey, 
        -1, 
        (LPWSTR)wszSubKey, 
        dwSize/sizeof(WCHAR)) == 0)
    {
       return ERROR_INVALID_PARAMETER;
    }

    lRet = DeleteKeyW(hKey, wszSubKey);

    free(wszSubKey);

    return lRet;
}

/*++

 Function Description:

    Wrapper for DeleteKeyW.

    Algorithm:
    1. If key is not protected, delete key.
    2. If in 9x compat mode, recursively delete all subkeys.

 Arguments:

    hKey - Key to that contains subkey to delete.
    lpSubKey - Name of key to delete    

 Return Value:

    ERROR_SUCCESS on success, failure code otherwise.

 History:

    08/07/2001 mikrause  Created

--*/

LONG 
CVirtualRegistry::DeleteKeyW(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey
    )
{
    LONG hRet;
    OPENKEY* key = FindOpenKey(hKey);
    LPWSTR wzPath = NULL;
    BOOL bProtected;

    // Key not found, assume it's a root key.
    if (!key)
    {
        DPFN( eDbgLevelInfo, "Key not found!");
        wzPath = MakePath(hKey, 0, lpSubKey);
        if (!wzPath)
        {
           DPFN(eDbgLevelError, szOutOfMemory);
           return ERROR_NOT_ENOUGH_MEMORY;
        }
        DPFN( eDbgLevelInfo, "Using path %S", wzPath);
    }
    else if (lpSubKey)
    {   
        DWORD dwSize = wcslen(key->wzPath) + wcslen(L"\\") + wcslen(lpSubKey) + 1;
        wzPath = (LPWSTR) malloc(dwSize * sizeof(WCHAR));
        if (!wzPath)
        {
           DPFN(eDbgLevelError, szOutOfMemory);
           return ERROR_NOT_ENOUGH_MEMORY;
        }
        ZeroMemory(wzPath, dwSize);

        StringCchCopyW(wzPath, dwSize, key->wzPath);
        StringCchCatW(wzPath, dwSize, L"\\");
        StringCchCatW(wzPath, dwSize, lpSubKey);
    }

    bProtected = (key && CheckProtected(key->wzPath))
        || (wzPath && CheckProtected(wzPath));
    if (!bProtected)
    {
        if (g_bWin9x)
        {
            //
            // Find out whether hKey has any subkeys under it or not.
            // If not, then proceed as normal.
            // If yes, recursively delete the subkeys under it
            // Then proceed as normal.
            //

            DWORD cSize = 0;
            WCHAR lpSubKeyName[MAX_PATH];
            HKEY hSubKey;

            DPFN( eDbgLevelInfo, "RegDeleteKeyW called with hKey: %x, SubKey: %S", hKey, lpSubKey);

            hRet = ORIGINAL_API(RegOpenKeyExW)(
                    hKey,
                    lpSubKey,
                    0,
                    KEY_ENUMERATE_SUB_KEYS,
                    &hSubKey);
            
            if (SUCCESS(hRet))
            {
                for (;;)
                {
                    cSize = MAX_PATH;
            
                    hRet = ORIGINAL_API(RegEnumKeyExW)(
                        hSubKey,
                        0,              
                        lpSubKeyName,
                        &cSize,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );

                    if (SUCCESS(hRet))
                    {                    
                        LOGN( eDbgLevelInfo, 
                            "[DeleteKeyW] Deleting subkey %S for key %S.",
                            lpSubKeyName,
                            lpSubKey);         
                     
                        hRet = DeleteKeyW(
                                hSubKey,
                                lpSubKeyName);
                    
                        if (SUCCESS(hRet))
                        {
                            LOGN( eDbgLevelInfo, "[DeleteKeyW] subkey %S was deleted.",lpSubKeyName);            
                        }
                        else
                        {
                            LOGN( eDbgLevelInfo, "[DeleteKeyW] subkey %S was not deleted.",lpSubKeyName);            
                            break;
                        }                        
                    }
                    else
                    {
                        DPFN( eDbgLevelInfo, "[DeleteKeyW] No more subkey under key %S.",lpSubKey);
                        break;
                    }
                } 

                ORIGINAL_API(RegCloseKey)(hSubKey);
            }
        }

        DPFN( eDbgLevelInfo, "[RegDeleteKeyW] Deleting subkey %S.",lpSubKey);
        
        hRet = ORIGINAL_API(RegDeleteKeyW)(
            hKey,
            lpSubKey);     
    }
    else
    {
        // Protected, just say it succeeded
        hRet = ERROR_SUCCESS;
    }

    if (wzPath) 
    {
        free(wzPath);
    }

    // Possible change in enumeration data, flush lists.
    FlushEnumLists();

    return hRet;
}

/*++

 Function Description:

    Wrapper for RegCloseKey. Note that we make sure we know about the key before closing it.

    Algorithm:
        1. Run the list of open keys and free if found
        2. Close the key 

 Arguments:

    IN hKey - Handle to open key to close

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::CloseKey(
    IN HKEY hKey
    )
{
    OPENKEY *key = OpenKeys, *last = NULL;
    LONG lRet;

    __try
    {
        lRet = ERROR_INVALID_HANDLE;

        while (key)
        {
            if (key->hkOpen == hKey)
            {
                if (last)
                {
                    last->next = key->next;
                }
                else
                {
                    OpenKeys = key->next;
                }
        
                lRet = ORIGINAL_API(RegCloseKey)(hKey);
            
                free(key->wzPath);
                free(key);
                break;
            }

            last = key;
            key = key->next;
        }

        if (key == NULL)
        {
           RegCloseKey(hKey);
        }

        DPFN( ELEVEL(lRet), "%08lx=CloseKey(Key=%04lx)", lRet, hKey);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        lRet = ERROR_INVALID_HANDLE;
    }

    return lRet;
}


/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegCreateKeyA)(
    HKEY hKey,         
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyA(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED,
        NULL,
        phkResult, 
        0,
        TRUE);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegCreateKeyW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyW(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE, 
        MAXIMUM_ALLOWED,
        NULL,
        phkResult, 
        0,
        TRUE);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegCreateKeyExA)(
    HKEY hKey,                
    LPCSTR lpSubKey,         
    DWORD /* Reserved */,           
    LPSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyA(
        hKey, 
        lpSubKey, 
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition,
        TRUE);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegCreateKeyExW)(
    HKEY hKey,                
    LPCWSTR lpSubKey,         
    DWORD /* Reserved */,
    LPWSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyW(
        hKey, 
        lpSubKey, 
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition,
        TRUE);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegOpenKeyA)(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyA(hKey, lpSubKey, 0, 0, MAXIMUM_ALLOWED, NULL, phkResult, 0, FALSE);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegOpenKeyW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyW(hKey, lpSubKey, 0, 0, MAXIMUM_ALLOWED, NULL, phkResult, 0, FALSE);
}

/*++

 Pass through to virtual registry to handle call.

--*/


LONG 
APIHOOK(RegOpenKeyExA)(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    DWORD /* ulOptions */,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyA(hKey, lpSubKey, 0, 0, samDesired, NULL, phkResult, 0, FALSE);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegOpenKeyExW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    DWORD /* ulOptions */,
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyW(hKey, lpSubKey, 0, 0, samDesired, NULL, phkResult, 0, FALSE);
}

/*++

 Not yet implemented

--*/

LONG 
APIHOOK(RegQueryValueA)(
    HKEY    hKey,
    LPCSTR  lpSubKey,
    LPSTR  lpData,
    PLONG lpcbData
    )
{
    CRegLock Lock;

    return ORIGINAL_API(RegQueryValueA)(
        hKey, 
        lpSubKey, 
        lpData, 
        lpcbData);
}

/*++

 Not yet implemented

--*/

LONG 
APIHOOK(RegQueryValueW)(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    LPWSTR  lpData,
    PLONG lpcbData
    )
{
    CRegLock Lock;

    return ORIGINAL_API(RegQueryValueW)(
        hKey, 
        lpSubKey, 
        lpData, 
        lpcbData);
}

/*++

 Pass through to virtual registry to handle call.
 
--*/

LONG 
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,
    LPSTR   lpValueName,
    LPDWORD /* lpReserved */,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    CRegLock Lock;

    return VRegistry.QueryValueA(hKey, lpValueName, lpType, lpData, lpcbData);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegQueryValueExW)(
    HKEY    hKey,
    LPWSTR  lpValueName,
    LPDWORD /* lpReserved */,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    CRegLock Lock;

    return VRegistry.QueryValueW(hKey, lpValueName, lpType, lpData, lpcbData);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegCloseKey)(HKEY hKey)
{
    CRegLock Lock;

    return VRegistry.CloseKey(hKey);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegEnumValueA)(
    HKEY hKey,              
    DWORD dwIndex,          
    LPSTR lpValueName,     
    LPDWORD lpcbValueName,  
    LPDWORD /* lpReserved */, 
    LPDWORD lpType,         
    LPBYTE lpData,          
    LPDWORD lpcbData        
    )
{
    CRegLock Lock;

    return VRegistry.EnumValueA(
        hKey, 
        dwIndex, 
        lpValueName, 
        lpcbValueName, 
        lpType, 
        lpData, 
        lpcbData);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegEnumValueW)(
    HKEY hKey,              
    DWORD dwIndex,          
    LPWSTR lpValueName,     
    LPDWORD lpcbValueName,  
    LPDWORD /* lpReserved */,
    LPDWORD lpType,         
    LPBYTE lpData,          
    LPDWORD lpcbData        
    )
{
    CRegLock Lock;

    return VRegistry.EnumValueW(
        hKey, 
        dwIndex, 
        lpValueName, 
        lpcbValueName, 
        lpType, 
        lpData, 
        lpcbData);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegEnumKeyExA)(
    HKEY hKey,          
    DWORD dwIndex,      
    LPSTR lpName,      
    LPDWORD lpcbName,   
    LPDWORD /* lpReserved */, 
    LPSTR /* lpClass */,     
    LPDWORD /* lpcbClass */,  
    PFILETIME /* lpftLastWriteTime */
    )
{
    CRegLock Lock;

    return VRegistry.EnumKeyA(hKey, dwIndex, lpName, lpcbName);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegEnumKeyExW)(
    HKEY hKey,          
    DWORD dwIndex,      
    LPWSTR lpName,      
    LPDWORD lpcbName,   
    LPDWORD /* lpReserved */, 
    LPWSTR /* lpClass */,
    LPDWORD /* lpcbClass */,
    PFILETIME /* lpftLastWriteTime */ 
    )
{
    CRegLock Lock;

    return VRegistry.EnumKeyW(hKey, dwIndex, lpName, lpcbName);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegEnumKeyA)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPSTR lpName, 
    DWORD cbName  
    )
{
    CRegLock Lock;

    return VRegistry.EnumKeyA(hKey, dwIndex, lpName, &cbName);
}

/*++

 Calls down to RegEnumKeyExW

--*/

LONG 
APIHOOK(RegEnumKeyW)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPWSTR lpName, 
    DWORD cbName  
    )
{
    CRegLock Lock;

    return VRegistry.EnumKeyW(hKey, dwIndex, lpName, &cbName);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegQueryInfoKeyW)(
    HKEY hKey,                
    LPWSTR lpClass,           
    LPDWORD lpcbClass,        
    LPDWORD lpReserved,       
    LPDWORD lpcSubKeys,       
    LPDWORD lpcbMaxSubKeyLen, 
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues,        
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,  
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime   
    )
{
    CRegLock Lock;

    return VRegistry.QueryInfoW(
        hKey,
        lpClass,           
        lpcbClass,        
        lpReserved,       
        lpcSubKeys,       
        lpcbMaxSubKeyLen, 
        lpcbMaxClassLen,  
        lpcValues,        
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,  
        lpcbSecurityDescriptor,
        lpftLastWriteTime);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegQueryInfoKeyA)(
    HKEY hKey,                
    LPSTR lpClass,           
    LPDWORD lpcbClass,        
    LPDWORD lpReserved,       
    LPDWORD lpcSubKeys,       
    LPDWORD lpcbMaxSubKeyLen, 
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues,        
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,  
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime   
    )
{
    CRegLock Lock;

    return VRegistry.QueryInfoA(
        hKey,
        lpClass,           
        lpcbClass,        
        lpReserved,       
        lpcSubKeys,       
        lpcbMaxSubKeyLen, 
        lpcbMaxClassLen,  
        lpcValues,        
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,  
        lpcbSecurityDescriptor,
        lpftLastWriteTime);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG      
APIHOOK(RegSetValueExA)(
    HKEY hKey, 
    LPCSTR lpSubKey, 
    DWORD /* Reserved */, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    LONG lRet = 0;

    if (!lpData && cbData)
    {
        lRet = ERROR_INVALID_PARAMETER;
    }
    else
    {
        CRegLock lock;
        lRet = VRegistry.SetValueA(hKey, lpSubKey, dwType, lpData, cbData);
    }

    return lRet;
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG      
APIHOOK(RegSetValueExW)(
    HKEY hKey, 
    LPCWSTR lpSubKey, 
    DWORD /* Reserved */, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    LONG lRet = 0;

    if (!lpData && cbData)
    {
        lRet = ERROR_INVALID_PARAMETER;
    }
    else
    {
        CRegLock lock;
        lRet = VRegistry.SetValueW(hKey, lpSubKey, dwType, lpData, cbData);
    }

    return lRet;
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG      
APIHOOK(RegDeleteKeyA)(
    HKEY hKey, 
    LPCSTR lpSubKey
    )
{
    CRegLock Lock;

    return VRegistry.DeleteKeyA(hKey, lpSubKey);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG      
APIHOOK(RegDeleteKeyW)(
    HKEY hKey, 
    LPCWSTR lpSubKey
    )
{
    CRegLock Lock;

    return VRegistry.DeleteKeyW(hKey, lpSubKey);
}

LONG 
APIHOOK(RegConnectRegistryW)(
    LPCWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyW(
        hKey, 
        NULL, 
        0, 
        0, 
        MAXIMUM_ALLOWED,
        NULL,
        phkResult, 
        0, 
        FALSE, 
        TRUE, 
        lpMachineName);
}

LONG 
APIHOOK(RegConnectRegistryA)(
    LPCSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    )
{
    WCHAR wMachineName[MAX_COMPUTERNAME_LENGTH + 1] = L"";

    if (lpMachineName)
    {
        if (MultiByteToWideChar(
            CP_ACP,
            0, 
            lpMachineName, 
            -1, 
            wMachineName, 
            MAX_COMPUTERNAME_LENGTH + 1) == 0)
        {
           return ERROR_INVALID_PARAMETER;
        }
    }

    return APIHOOK(RegConnectRegistryW)(wMachineName, hKey, phkResult);
}

/*++

 Parse the command line for fixes:

    FIXA(param); FIXB(param); FIXC(param) ...

    param is optional, and can be omitted (along with parenthesis's)

--*/

BOOL
ParseCommandLineA(
    LPCSTR lpCommandLine
    )
{
    const char szDefault[] = "Win9x";

    // Add all the defaults if no command line is specified
    if (!lpCommandLine || (lpCommandLine[0] == '\0'))
    {
        // Default to win9x API emulation
        g_bWin9x = TRUE;
        lpCommandLine = szDefault;
    }

    CSTRING_TRY
    {    
       CStringToken csCommandLine(lpCommandLine, " ,\t;");
       CString csTok;
       int nLeftParam, nRightParam;
       CString csParam;
   
   
       VENTRY *ventry;
   
       //
       // Run the string, looking for fix names
       //
       
       DPFN( eDbgLevelInfo, "----------------------------------");
       DPFN( eDbgLevelInfo, "         Virtual registry         ");
       DPFN( eDbgLevelInfo, "----------------------------------");
       DPFN( eDbgLevelInfo, "Adding command line:");
   
       while (csCommandLine.GetToken(csTok))
       {
           PURPOSE ePurpose;
   
           // Get the parameter
           nLeftParam = csTok.Find(L'(');
           nRightParam = csTok.Find(L')');
           if (nLeftParam != -1 &&
               nRightParam != -1)
           {
               if ( (nLeftParam + 1) < (nRightParam - 1))
               {
                   csParam = csTok.Mid(nLeftParam+1, nRightParam-nLeftParam-1);
               }
   
               // Strip off the () from the token.
               csTok.Truncate(nLeftParam);
           }
           else
           {
               csParam = L"";
           }
   
           if (csTok.CompareNoCase(L"Win9x") == 0)
           {
               // Turn on all win9x fixes
               ePurpose = eWin9x;
               g_bWin9x = TRUE;
           }
           else if (csTok.CompareNoCase(L"WinNT") == 0)
           {
               // Turn on all NT fixes
               ePurpose = eWinNT;
               g_bWin9x = FALSE;
           }
           else if (csTok.CompareNoCase(L"Win2K") == 0) 
           {
               // Turn on all Win2K fixes
               ePurpose = eWin2K;
               g_bWin9x = FALSE;
           }
           else if (csTok.CompareNoCase(L"WinXP") == 0) 
           {
               // Turn on all Win2K fixes
               ePurpose = eWinXP;
               g_bWin9x = FALSE;
           }
           else
           {
               // A custom fix
               ePurpose = eCustom;
           }
           
           // Find the specified fix and run it's function
           ventry = g_pVList;
           while (ventry && (ventry->cName[0]))
           {
               if (((ePurpose != eCustom) && (ventry->ePurpose == ePurpose)) ||
                   ((ePurpose == eCustom) && (csTok.CompareNoCase(ventry->cName) == 0)))
               {
                   if (ventry->bShouldCall == FALSE)
                   {
                      ventry->szParam = (char*) malloc(csParam.GetLength() + 1);
                      if (ventry->szParam)
                      {
                         if (SUCCEEDED(StringCchCopyA(ventry->szParam, csParam.GetLength() + 1, csParam.GetAnsi())))
                         {
                            ventry->bShouldCall = TRUE;
                         }
                         else
                         {
                            free(ventry->szParam);
                            ventry->szParam = NULL;
                            return FALSE;
                         }
                      }
                      else
                      {
                         return FALSE;
                      }
                   }                   
               }
               ventry++;
           }
       }
   
       DPFN( eDbgLevelInfo, "----------------------------------");
    }
    CSTRING_CATCH
    {
       DPFN(eDbgLevelError, szOutOfMemory);
       return FALSE;
    }

    return TRUE;
}

/*++

 Initialize all the registry hooks 

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        if (InitializeCriticalSectionAndSpinCount(&csRegCriticalSection, 0x80000000) == FALSE ||
            VRegistry.Init() == FALSE ||
            ParseCommandLineA(COMMAND_LINE) == FALSE)
        {
           DPFN(eDbgLevelError, szOutOfMemory);
           return FALSE;
        }
    }

    // Ignore cleanup because some apps call registry functions during process detach.
    /*
    if (fdwReason == DLL_PROCESS_DETACH)
    {
        if (g_bInitialized)
        {
            VRegistry.Free();
            
            DeleteCriticalSection(&csRegCriticalSection);
        }

        DeleteCriticalSection(&csRegTestCriticalSection);
        
        return;
    }
    */

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(ADVAPI32.DLL, RegConnectRegistryA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegConnectRegistryW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCloseKey);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumValueA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumValueW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryInfoKeyA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryInfoKeyW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyW);

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\vregistry_dsound.h ===
#pragma once

#ifndef VREGISTRY_DSOUND_H
#define VREGISTRY_DSOUND_H

// DirectSound Acceleration levels.
#define DSAPPHACK_ACCELNONE     0xF
#define DSAPPHACK_ACCELSTANDARD 0x8
#define DSAPPHACK_ACCELFULL     0x0

// DirectSound Device Types
#define DSAPPHACK_DEV_EMULATEDRENDER	0x01
#define DSAPPHACK_DEV_KSRENDER          0x04
#define DSAPPHACK_DEV_EMULATEDCAPTURE	0x08
#define DSAPPHACK_DEV_KSCAPTURE         0x10

// Functions to set DirectSound app hacks.
BOOL AddDSHackDeviceAcceleration(DWORD dwAcceleration, DWORD dwDevicesAffected);
BOOL AddDSHackDisableDevice(DWORD dwDevicesAffected);
BOOL AddDSHackPadCursors(LONG lCursorPad);
BOOL AddDSHackReturnWritePos(DWORD dwDevicesAffected);
BOOL AddDSHackSmoothWritePos(LONG lCursorPad);
BOOL AddDSHackCachePositions(DWORD dwDevicesAffected);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\vregistry_dsound.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    VRegistry_DSound.cpp

 Abstract:

    Module to add DSound apphacks with VRegistry

 History:

    08/10/2001  mikrause    Created    

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(VirtualRegistry)

#include <windows.h>
#include "shimhookmacro.h"
#include "vregistry.h"
#include "vregistry_dsound.h"

#define DSAPPHACK_MAXNAME   (MAX_PATH + 16 + 16)

BOOL AddDirectSoundAppHack(DWORD dwHack,DWORD dwParam1,DWORD dwParam2);
BOOL GetDirectSoundAppId(LPTSTR pszAppId);

// Available DirectSound hacks
#define DSAPPHACKID_DEVACCEL            1
#define DSAPPHACKID_PADCURSORS          2
#define DSAPPHACKID_CACHEPOSITIONS      3
#define DSAPPHACKID_RETURNWRITEPOS      4
#define DSAPPHACKID_SMOOTHWRITEPOS      5
#define DSAPPHACKID_DISABLEDEVICE       6

/*++

 Function Description:

    Sets the acceleration level the app will be allowed to use.
 
 Arguments:

    IN dwAcceleration - Acceleration level needed.
    IN dwDevicesAffected - Combination of device that this hack applies to.

 Notes:
    
    See vregistry_dsound.h for acceleration levels and device types.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDSHackDeviceAcceleration(
    IN DWORD dwAcceleration,
    IN DWORD dwDevicesAffected)
{
    return AddDirectSoundAppHack(DSAPPHACKID_DEVACCEL, dwAcceleration,
        dwDevicesAffected);
}

/*++

 Function Description:

    Disabled some category of devices altogether, forces
    playback through emulated path.
 
 Arguments:

    IN dwDevicesAffected - Combination of device that this hack applies to.

 Notes:
    
    See vregistry_dsound.h for device types.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDSHackDisableDevice(
    IN DWORD dwDevicesAffected)
{
    return AddDirectSoundAppHack(DSAPPHACKID_DISABLEDEVICE, dwDevicesAffected,
        0);
}

/*++

 Function Description:

    Makes IDirectSoundBuffer::GetCurrentPosition() tell the app
    that the play and write cursors are X milliseconds further
    along than they really are.
 
 Arguments:

    IN lCursorPad - Number of milliseconds to pad cursors.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDSHackPadCursors(
    IN LONG lCursorPad)
{
    return AddDirectSoundAppHack(DSAPPHACKID_PADCURSORS, (DWORD)lCursorPad,
        0);
}

/*++

 Function Description:

    When the app asks for the play cursor, we give it the
    write cursor instead.  The correct way to stream audio
    into a looping dsound buffer is to key off the write cursor,
    but some apps (e.g. QuickTime) use the play cursor instead.
    This apphacks alleviates them.
 
 Arguments:

    IN dwDevicesAffected - Combination of devices to apply hack to.

 Notes:
    
    See vregistry_dsound.h for device types.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDSHackReturnWritePos(
    IN DWORD dwDevicesAffected)
{
    return AddDirectSoundAppHack(DSAPPHACKID_RETURNWRITEPOS, dwDevicesAffected,
        0);
}

/*++

 Function Description:

    Makes dsound always return a write position which is X
    milliseconds ahead of the play position, rather than
    the real write position. 
 
 Arguments:

    IN lCursorPad - Milliseconds of padding.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDSHackSmoothWritePos(
    IN LONG lCursorPad)
{
    return AddDirectSoundAppHack(DSAPPHACKID_SMOOTHWRITEPOS, 1,
        (DWORD)lCursorPad);
}

/*++

 Function Description:

    Caches the play/write positions last returned by
    GetCurrentPosition(), and reuses them if the app
    calls it again within 5ms (great for apps that
    abuse GetCurrentPosition(), which is more expensive
    on WDM devices than it was on the Win9X VxD devices
    many of these games were tested with).  This hack
    should spring to mind if you see slow or jerky graphics
    or stop-and-go sound  the GetCurrentPosition() calls are
    probably pegging the CPU (to confirm, use debug spew
    level 6 on DSound.dll).
 
 Arguments:

    IN dwDevicesAffected - Combination of devices to apply this hack to.


 Notes:
    
    See vregistry_dsound.h for device types.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDSHackCachePositions(
    IN DWORD dwDevicesAffected)
{
    return AddDirectSoundAppHack(DSAPPHACKID_CACHEPOSITIONS, dwDevicesAffected,
        0);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Adds a DirectSound app hack to the registry.
 
 Arguments:

    IN dwHack - ID of app hack to apply.
    IN dwParam1 - First parameter.  Depends on app hack.
    IN dwParam2 - Second paramter.  Depends on app hack.

 Notes:
    
    See vregistry_dsound.h for more information on specific hacks.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDirectSoundAppHack(
    IN DWORD dwHack,
    IN DWORD dwParam1,
    IN DWORD dwParam2)
{
    WCHAR  wzAppID[MAX_PATH];
    LPWSTR wzValName;
    DWORD dwData[2];
    DWORD dwDataSize;
    VIRTUALKEY *dsoundKey;
    VIRTUALKEY *appKey;
    VIRTUALVAL *val;

    if (GetDirectSoundAppId(wzAppID) == FALSE)
    {
        DPFN(eDbgLevelError, "Unable to create DirectSound app ID");
        return FALSE;
    }    

    dwData[0] = dwParam1;
    dwData[1] = dwParam2;

    switch(dwHack)
    {
    case DSAPPHACKID_DEVACCEL:
        wzValName = L"DSAPPHACKID_DEVACCEL";
        dwDataSize = 2 * sizeof(DWORD);
        break;

    case DSAPPHACKID_PADCURSORS:
        wzValName = L"DSAPPHACKID_PADCURSORS";
        dwDataSize = 1 * sizeof(DWORD);
        break;

    case DSAPPHACKID_CACHEPOSITIONS:
        wzValName = L"DSAPPHACKID_CACHEPOSITIONS";
        dwDataSize = 1 * sizeof(DWORD);
        break;

    case DSAPPHACKID_RETURNWRITEPOS:
        wzValName = L"DSAPPHACKID_RETURNWRITEPOS";
        dwDataSize = 1 * sizeof(DWORD);
        break;

    case DSAPPHACKID_SMOOTHWRITEPOS:
        wzValName = L"DSAPPHACKID_SMOOTHWRITEPOS";
        dwDataSize = 2 * sizeof(DWORD);
        break;

    case DSAPPHACKID_DISABLEDEVICE:
        wzValName = L"DSAPPHACKID_DISABLEDEVICE";
        dwDataSize = 1 * sizeof(DWORD);
        break;

    default:
        DPFN(eDbgLevelError, "Unknown DirectSound AppHack");
        return FALSE;
    }

    dsoundKey = VRegistry.AddKey(L"HKLM\\System\\CurrentControlSet\\Control\\MediaResources\\DirectSound\\Application Compatibility");
    if (dsoundKey == NULL)
    {
        DPFN(eDbgLevelError, "Cannot create virtual registry key");
        return FALSE;
    }

    appKey = dsoundKey->AddKey(wzAppID);
    if (appKey == NULL)
    {
        DPFN(eDbgLevelError, "Cannot create virtual registry key");
        return FALSE;
    }

    val = appKey->AddValue(wzValName,REG_BINARY,(BYTE*)dwData, dwDataSize);
    if (val == NULL)
    {
        DPFN(eDbgLevelError, "Cannot create virtual registry value");
        return FALSE;
    }

    DPFN(eDbgLevelWarning, "DirectSound Apphack \"%S\" enabled, arguments: %X %X", wzValName, dwData[0], dwData[1]);

    return TRUE;
}

// Arguments:
//   LPTSTR szExecPath: full pathname of the app (e.g. C:\program files\foo\foo.exe)
//   LPTSTR szExecName: executable name of the app (e.g. foo.exe)
//   LPTSTR pszAppId: returns the dsound app ID.  (Pass in an array of DSAPPHACK_MAXNAME TCHARs.)
// Return code:
//   BOOL: true if we obtained the application ID successfully.

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Gets an AppID for the running application.
 
 Arguments:
    IN OUT wzAppId: Buffer for the dsound app ID.  (Pass in an array of DSAPPHACK_MAXNAME TCHARs.)

 Returns:
    
    TRUE if app ID created, FALSE otherwise.

 History:

    08/10/2001 mikrause  Created

--*/
BOOL
GetDirectSoundAppId(
    IN OUT LPWSTR wzAppId)
{
    WCHAR wzExecPath[MAX_PATH];
    LPWSTR wzExecName;
    IMAGE_NT_HEADERS nth;
    IMAGE_DOS_HEADER dh;
    DWORD cbRead;
    DWORD dwFileSize;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BOOL fSuccess = FALSE;

    __try
    {
        // Get the name of the running EXE, and its full path.
        if (GetModuleFileNameW(NULL, wzExecPath, MAX_PATH) == FALSE)
        {
            __leave;
        }

        wzExecName = wcsrchr(wzExecPath, L'\\');
        if (wzExecName == NULL)
        {
            __leave;;
        }

        wzExecName++;
        
        // Open the executable
        hFile = CreateFile(wzExecPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            __leave;
        }

        // Read the executable's DOS header
        fSuccess = ReadFile(hFile, &dh, sizeof(dh), &cbRead, NULL);
        if (!fSuccess || cbRead != sizeof(dh))
        {
            // Log("Unable to read DOS header");
            __leave;
        }    

        if (dh.e_magic != IMAGE_DOS_SIGNATURE)
        {
            // Log("Invalid DOS signature");
            __leave;
        }

        // Read the executable's PE header
        cbRead = SetFilePointer(hFile, dh.e_lfanew, NULL, FILE_BEGIN);
        if ((LONG)cbRead != dh.e_lfanew)
        {
            // Log("Unable to seek to PE header");
            __leave;
        }    
        
        if ((ReadFile(hFile, &nth, sizeof(nth), &cbRead, NULL) == FALSE)
             || cbRead != sizeof(nth))
        {
            // Log("Unable to read PE header");
            __leave;
        }

        if (nth.Signature != IMAGE_NT_SIGNATURE)
        {
            // Log("Invalid PE signature");
            __leave;
        }

        // Get the executable's size
        // Assuming < 4 GB
        dwFileSize = GetFileSize(hFile, NULL);
        if (dwFileSize == INVALID_FILE_SIZE )
        {
            // Log("Unable to get file size");
            __leave;
        }    

        // Create the application ID 
        if (FAILED(StringCchPrintfW(
                                 wzAppId,
                                 MAX_PATH,
                                 L"%s%8.8lX%8.8lX",
                                 wzExecName,
                                 nth.FileHeader.TimeDateStamp,
                                 dwFileSize)))
        {
           __leave;
        }
        CharUpperW(wzAppId);

        fSuccess = TRUE;
    }
    __finally
    {
        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
        }
    }

    return fSuccess;
}

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\vregistry_custom.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Custom.cpp

 Abstract:

    Module to add custom behaviour to virtual registry.

 Fixes:

    VersionNumber string for Microsoft Playpack
    Expanders for DevicePath, ProgramFilesPath and WallPaperDir
    Redirectors for screen savers
    Virtual HKEY_DYN_DATA structure
    Add ProductName to all Network Cards
    Locale has been moved
    Wordpad filenames
    NoDriveTypeAutorun has a different type

 Notes:

    This file should be used to add custom behavior to virtual registry.

 History:

    05/05/2000  linstev     Created
    09/01/2000  t-adams     Added support for PCI devices to BuildDynData()
    09/01/2000  robkenny    Added Krondor
    09/09/2000  robkenny    Updated Wordpad to return a short path to the exe
    09/21/2000  prashkud    Added fix for SpellItDeluxe
    10/25/2000  maonis      Added CookieMaster
    10/17/2000  robkenny    Added HKEY_DYN_DATA\Display\Settings
    11/27/2000  a-fwills    Added display guid to redirectors
    12/28/2000  a-brienw    Added BuildTalkingDictionary for American Heritage
                            Talking Dictionary which is looking for a SharedDir key
    01/15/2001  maonis      Added PageKeepPro
    02/06/2001  a-larrsh    Added FileNet Web Server
    02/27/2001  maonis      Added PageMaker
    02/27/2001  robkenny    Converted to use tcs.h
    03/01/2001  prashkud    Added NetBT keys in BuildNetworkCards()
    04/05/2001  mnikkel     Added HKLM\Microsoft\Windows\CurrentVersion\App Paths\DXDIAG.EXE
    04/27/2001  prashkud    Added custom MiddleSchoolAdvantage 2001 entry
    05/04/2001  prashkud    Added custom entry for BOGUSCTRLID - Win2K layer
    05/19/2001  hioh        Added NOWROBLUE, BuildNowroBlue
    06/13/2001  carlco      Added Princeton ACT
    08/10/2001  mikrause    Added Airline Tycoon, DirectSound hacks.
    11/06/2001  mikrause    Added Delphi 5.0 Pro
    01/02/2002  mamathas    Added NortonAntiVirus2002, BuildNortonAntiVirus
    04/23/2002  garyma      Added Word Perfect Office 2002

--*/

#define SHIM_LIB_BUILD_FLAG

#include "precomp.h"

#include "secutils.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(VirtualRegistry)
#include "ShimHookMacro.h"
#include "VRegistry.h"
#include "VRegistry_dsound.h"

//
// Functions that modify the behaviour of virtualregistry
//

void BuildWin98SE(char* szParam);
void BuildRedirectors(char* szParam);
void BuildCookiePath(char* szParam);
void BuildHasbro(char* szParam);
void BuildDynData(char* szParam);
void BuildCurrentConfig(char* szParam);
void BuildLocale(char* szParam);
void BuildWordPad(char* szParam);
void BuildAutoRun(char* szParam);
void BuildTalkingDictionary(char* szParam);
void BuildNetworkCards(char* szParam);
void BuildNT4SP5(char* szParam);
void BuildNT50(char* szParam);
void BuildNT51(char* szParam);
void BuildBogusCtrlID(char* szParam);
void BuildExpanders(char* szParam);
void BuildDX7A(char* szParam);
void BuildDXDiag(char* szParam);
void BuildFutureCop(char* szParam);
void BuildKrondor(char* szParam);
void BuildPageKeepProDirectory(char* szParam);
void BuildProfile(char* szParam);
void BuildSpellItDeluxe(char* szParam);
void BuildIE401(char* szParam);
void BuildIE55(char* szParam);
void BuildIE60(char* szParam);
void BuildJoystick(char* szParam);
void BuildIllustrator8(char* szParam);
void BuildModemWizard(char* szParam);
void BuildMSI(char* szParam);
void BuildFileNetWebServer(char* szParam);
void BuildPrinter(char* szParam);
void BuildPageMaker65(char* szParam);
void BuildStarTrekArmada(char* szParam);
void BuildMSA2001(char* szParam);
void BuildNowroBlue(char* szParam);
void BuildRegisteredOwner(char* szParam);
void BuildPrincetonACT(char* szParam);
void BuildHEDZ(char* szParam);
void BuildAirlineTycoon(char* szParam);
void BuildDSDevAccel(char* szParam);
void BuildDSPadCursors(char* szParam);
void BuildDSCachePositions(char* szParam);
void BuildDSReturnWritePos(char* szParam);
void BuildDSSmoothWritePos(char* szParam);
void BuildDSDisableDevice(char* szParam);
void BuildDelphi5Pro(char* szParam);
void BuildNortonAntiVirus(char* szParam);
void BuildWordPerfect2002(char* szParam);


// Table that contains all the fixes - note, must be terminated by a NULL entry.

VENTRY g_VList[] =
{
    {L"WIN98SE",           BuildWin98SE,                 eWin9x,  FALSE, NULL },
    {L"REDIRECT",          BuildRedirectors,             eWin9x,  FALSE, NULL },
    {L"COOKIEPATH",        BuildCookiePath,              eWin9x,  FALSE, NULL },
    {L"HASBRO",            BuildHasbro,                  eWin9x,  FALSE, NULL },
    {L"DYN_DATA",          BuildDynData,                 eWin9x,  FALSE, NULL },
    {L"CURRENT_CONFIG",    BuildCurrentConfig,           eWin9x,  FALSE, NULL },
    {L"LOCALE",            BuildLocale,                  eWin9x,  FALSE, NULL },
    {L"WORDPAD",           BuildWordPad,                 eWin9x,  FALSE, NULL },
    {L"AUTORUN",           BuildAutoRun,                 eWin9x,  FALSE, NULL },
    {L"TALKINGDICTIONARY", BuildTalkingDictionary,       eWin9x,  FALSE, NULL },
    {L"PRINTER",           BuildPrinter,                 eWin9x,  FALSE, NULL },
    {L"REGISTEREDOWNER",   BuildRegisteredOwner,         eWin9x,  FALSE, NULL },
    {L"NETWORK_CARDS",     BuildNetworkCards,            eWinNT,  FALSE, NULL },
    {L"NT4SP5",            BuildNT4SP5,                  eWinNT,  FALSE, NULL },
    {L"NT50",              BuildNT50,                    eWin2K,  FALSE, NULL },
    {L"BOGUSCTRLID",       BuildBogusCtrlID,             eWin2K,  FALSE, NULL },    
    {L"NT51",              BuildNT51,                    eWinXP,  FALSE, NULL },
    {L"EXPAND",            BuildExpanders,               eCustom, FALSE, NULL },
    {L"DX7A",              BuildDX7A,                    eCustom, FALSE, NULL },
    {L"DXDIAG",            BuildDXDiag,                  eCustom, FALSE, NULL },
    {L"FUTURECOP",         BuildFutureCop,               eCustom, FALSE, NULL },
    {L"KRONDOR",           BuildKrondor,                 eCustom, FALSE, NULL },
    {L"PROFILE",           BuildProfile,                 eCustom, FALSE, NULL },
    {L"SPELLITDELUXE",     BuildSpellItDeluxe,           eCustom, FALSE, NULL },
    {L"IE401",             BuildIE401,                   eCustom, FALSE, NULL }, 
    {L"IE55",              BuildIE55,                    eCustom, FALSE, NULL }, 
    {L"IE60",              BuildIE60,                    eCustom, FALSE, NULL }, 
    {L"JOYSTICK",          BuildJoystick,                eCustom, FALSE, NULL },
    {L"ILLUSTRATOR8",      BuildIllustrator8,            eCustom, FALSE, NULL },
    {L"PAGEKEEPPRO30",     BuildPageKeepProDirectory,    eCustom, FALSE, NULL },
    {L"MODEMWIZARD",       BuildModemWizard,             eCustom, FALSE, NULL },
    {L"MSI",               BuildMSI,                     eCustom, FALSE, NULL },
    {L"FILENETWEBSERVER",  BuildFileNetWebServer,        eCustom, FALSE, NULL },
    {L"PAGEMAKER65",       BuildPageMaker65,             eCustom, FALSE, NULL },
    {L"STARTREKARMADA",    BuildStarTrekArmada,          eCustom, FALSE, NULL },
    {L"MSA2001",           BuildMSA2001,                 eCustom, FALSE, NULL },    
    {L"NOWROBLUE",         BuildNowroBlue,               eCustom, FALSE, NULL },
    {L"PRINCETONACT",      BuildPrincetonACT,            eCustom, FALSE, NULL },    
    {L"HEDZ",              BuildHEDZ,                    eCustom, FALSE, NULL },
    {L"AIRLINETYCOON",     BuildAirlineTycoon,           eCustom, FALSE, NULL },
    {L"DSDEVACCEL",        BuildDSDevAccel,              eCustom, FALSE, NULL },
    {L"DSPADCURSORS",      BuildDSPadCursors,            eCustom, FALSE, NULL },
    {L"DSCACHEPOSITIONS",  BuildDSCachePositions,        eCustom, FALSE, NULL },
    {L"DSRETURNWRITEPOS",  BuildDSReturnWritePos,        eCustom, FALSE, NULL },
    {L"DSSMOOTHWRITEPOS",  BuildDSSmoothWritePos,        eCustom, FALSE, NULL },
    {L"DSDISABLEDEVICE",   BuildDSDisableDevice,         eCustom, FALSE, NULL },
    {L"DELPHI5PRO",        BuildDelphi5Pro,              eCustom, FALSE, NULL },
    {L"NORTONANTIVIRUS",   BuildNortonAntiVirus,         eCustom, FALSE, NULL },
    {L"WORDPERFECT2002",   BuildWordPerfect2002,         eCustom, FALSE, NULL },
    // Must Be The Last Entry   
    {L"",                  NULL,                         eCustom, FALSE, NULL }
};
VENTRY *g_pVList = &g_VList[0];

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add Win98 SE registry value - so far we only know about the Play Pack that 
    needs it.

 History:

    05/04/2000 linstev  Created

--*/

void
BuildWin98SE(char* /*szParam*/)
{
    VIRTUALKEY *key;

    // Add version number string for emulation of Win98 SE
    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"VersionNumber", REG_SZ, (LPBYTE)L"4.10.2222");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Known moved locations for which we need redirectors

 History:

    05/04/2000 linstev  Created

--*/

void
BuildRedirectors(char* /*szParam*/)
{
    // Display property page add ons and controls have changed location.
    VRegistry.AddRedirect(
        L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\Display",
        L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\Desk");

    // this key moved somewhere around build 2200.
    // System config scan type apps (ip.exe bundled in EA sports)
    // starting failing again.
    VRegistry.AddRedirect(
        L"HKLM\\System\\CurrentControlSet\\Services\\Class",
        L"HKLM\\System\\CurrentControlSet\\Control\\Class");

    // Nightmare Ned wasn't finding display starting from Class.
    // Directing it from Display to the GUID.
    VRegistry.AddRedirect(
        L"HKLM\\System\\CurrentControlSet\\Services\\Class\\Display",
        L"HKLM\\System\\CurrentControlSet\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}");

}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    CookieMaster gets the wrong path to cookies
    because HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Special Paths\\Cookies
    contains bogus value (shell is going to fix this). We change this to the correct value %USERPROFILE%\Cookies.
    
 History:

    10/25/2000 maonis  Created

--*/

void
BuildCookiePath(char* /*szParam*/)
{
    WCHAR wCookiePath[] = L"%USERPROFILE%\\Cookies";

    VIRTUALKEY *key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Special Paths\\Cookies");
    if (key)
    {
        key->AddValue(L"Directory", REG_EXPAND_SZ, (LPBYTE)wCookiePath, 0);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

  During the Slingo installation, the program places a value in the registry
  called 'PALFILE'. When you run the app, it checks this value to determine
  where the CD-ROM is located. For example, if the CD-ROM drive is 'E', it
  should put 'E:\Slingo.pal'. It fails to do this correctly on Win2K or Whistler,
  as it puts the install path instead. When the app runs, if the value doesn't
  refer to 'x:\Slingo.pal (where x is the CD-ROM drive)', the app immediately
  starts to do a FindFirstFile->FindNextFile looking for the file on the hard
  drive. Eventually it AVs during the search with no error message. This code
  sets the value in the registry on behalf of the app.

 History:

    11/1/2000   rparsons     Created

--*/

LONG 
WINAPI
VR_Hasbro(
    OPENKEY *key,
    VIRTUALKEY * /* vkey */,
    VIRTUALVAL *vvalue
    )
{
    DWORD dwType;
    WCHAR wszPath[MAX_PATH];
    DWORD dwSize = sizeof(wszPath);
    DWORD dwAttributes;

    //
    // Query the original value
    //

    LONG lRet = RegQueryValueExW(
        key->hkOpen, 
        vvalue->wName, 
        NULL, 
        &dwType, 
        (LPBYTE)wszPath, 
        &dwSize);
    
    //
    // Query failed - something went wrong
    //

    if (FAILURE(lRet))
    {
        DPFN( eDbgLevelError, "[Hasbro hack] Failed to query %S for expansion", vvalue->wName);
        goto Exit;
    }

    //
    // Not a string type!
    //

    if ((dwType != REG_SZ) || (dwSize > sizeof(wszPath)))
    {
        DPFN( eDbgLevelError, "[Hasbro hack] Failed to query %S", vvalue->wName);
        lRet = ERROR_BAD_ARGUMENTS;
        goto Exit;
    }

    // Check what's there
    dwAttributes = GetFileAttributes(wszPath);

    // If it's not a file, or it's a directory, then we have to find it ourselves
    if ((dwAttributes == (DWORD)-1) || (dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        WCHAR *lpDrives = L"";
        DWORD dwBufferLen = 0;

        //
        // The plan is to run all the drives and find one with a .PAL file on 
        // it. We also have the restriction that it must be a CDRom. It has
        // been pointed out that if the user has multiple CD drives and has
        // different HasBro titles in each drive, we could cause a failure, 
        // but we're considering that a pathological case for now. Especially 
        // considering we have no way of knowing what the palfile name is ahead
        // of time.
        //

        dwBufferLen = GetLogicalDriveStringsW(0, lpDrives);
        if (dwBufferLen)
        {
            lpDrives = (WCHAR *) malloc((dwBufferLen + 1) * sizeof(WCHAR));
            if (lpDrives)
            {
                GetLogicalDriveStrings(dwBufferLen, lpDrives);

                WCHAR *lpCurrent = lpDrives;
                while (lpCurrent && lpCurrent[0])
                {
                    if (GetDriveTypeW(lpCurrent) == DRIVE_CDROM)
                    {
                        //
                        // We've found a CD drive, now see if it has a .PAL 
                        // file on it.
                        //

                        WCHAR wszFile[MAX_PATH];
                        WIN32_FIND_DATAW ffData;
                        HANDLE hFindFile;
                        
                        if (SUCCEEDED(StringCchCopyW(wszFile, MAX_PATH, lpCurrent)) &&
                            SUCCEEDED(StringCchCatW(wszFile, MAX_PATH, L"*.PAL")))

                        {                                                                        
                           hFindFile = FindFirstFileW(wszFile, &ffData);
   
                           if (hFindFile != INVALID_HANDLE_VALUE)
                           {
                               // A .PAL file exists, return that.
                               FindClose(hFindFile);

                               if (SUCCEEDED(StringCchCopyW(wszPath, MAX_PATH, lpCurrent)) &&
                                   SUCCEEDED(StringCchCatW(wszPath, MAX_PATH, ffData.cFileName)))
                               {                                                              
   
                                  LOGN( eDbgLevelInfo, "[Hasbro hack] Returning path %S", wszPath);
                                  break;
                               }
                            }
                        }
                    }
                    
                    // Advance to the next drive letter
                    lpCurrent += wcslen(lpCurrent) + 1;
                }

                free(lpDrives);
            }
        }
    }

    // Copy the result into the output of QueryValue

    vvalue->cbData = (wcslen(wszPath) + 1) * sizeof(WCHAR);
    vvalue->lpData = (LPBYTE) malloc(vvalue->cbData);

    if (!vvalue->lpData)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    MoveMemory(vvalue->lpData, wszPath, vvalue->cbData);

    //
    // Never call us again, since we've done the work to set this value up and
    // stored it in our virtual value
    //
    vvalue->pfnQueryValue = NULL;

    lRet = ERROR_SUCCESS;

Exit:
    return lRet;
}

void
BuildHasbro(char* /*szParam*/)
{
    HKEY hHasbroKey;    
    WCHAR wszKeyName[MAX_PATH];
    DWORD dwIndex;

    const WCHAR wszHasbroPath[] = L"SOFTWARE\\Hasbro Interactive";

    if (FAILURE(RegOpenKeyExW(HKEY_LOCAL_MACHINE, wszHasbroPath, 0, KEY_READ, &hHasbroKey)))
    {
        DPFN( eDbgLevelSpew, "[Hasbro hack] Ignoring fix - no titles found");
        return;
    }
    
    //
    // Enum the keys under Hasbro Interactive and add a virtual PALFILE value.
    // Attach our callback to this value (see above)
    //

    dwIndex = 0;

    while (SUCCESS(RegEnumKeyW(hHasbroKey, dwIndex, wszKeyName, MAX_PATH)))
    {
        WCHAR wszName[MAX_PATH] = L"HKLM\\";

        if (SUCCEEDED(StringCchCatW(wszName, MAX_PATH, wszHasbroPath)) &&
            SUCCEEDED(StringCchCatW(wszName, MAX_PATH, L"\\")) &&
            SUCCEEDED(StringCchCatW(wszName, MAX_PATH, wszKeyName)))
        {
           VIRTUALKEY *key = VRegistry.AddKey(wszName);
           if (key)
           {
               VIRTUALVAL *val = key->AddValue(L"PALFILE", REG_SZ, 0, 0);
               if (val)
               {
                   val->pfnQueryValue = VR_Hasbro;
               }
 
               DPFN( eDbgLevelInfo, "[Hasbro hack] Adding fix for %S", wszKeyName);
          }
        }
        dwIndex++;
    }

    RegCloseKey(hHasbroKey);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    A simple DYN_DATA structure which emulates win9x.

 History:

    05/04/2000 linstev  Created
    09/01/2000 t-adams  Added support for PCI devices so EA's 3dSetup.exe & others can
                        detect hardware.

--*/

#define ENUM_BASE 0xC29A28C0

void
BuildDynData(char* /*szParam*/)
{
    VIRTUALKEY *key, *nkey;
    HKEY hkPCI = 0;
    DWORD i = 0;
    DWORD dwNameLen = 0;
    LPWSTR wstrName = NULL;
    LPWSTR wstrVName = NULL;
    FILETIME fileTime;
    DWORD dwValue;

    // Entries in HKDD\Config Manager\Enum were references to entries in HKLM\Enum\PCI that are now
    //   located at HKLM\SYSTEM\CurrentControlSet\Enum\PCI
    VRegistry.AddRedirect(
        L"HKLM\\Enum",
        L"HKLM\\SYSTEM\\CurrentControlSet\\Enum");

    // Construct HKDD\Config Manager\Enum so that it reflects the entries in HKLM\SYSTEM\CurrentControlSet\Enum\PCI
    key = VRegistry.AddKey(L"HKDD\\Config Manager\\Enum");
    if (!key)
    {
        goto exit;
    }

    if (SUCCESS(RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Enum\\PCI",0, KEY_READ, &hkPCI)))
    {
        dwNameLen = MAX_PATH;
        wstrName = (LPWSTR) malloc(dwNameLen * sizeof(WCHAR));
        if (NULL == wstrName)
        {
            goto exit;
        }

        wstrVName = (LPWSTR) malloc(dwNameLen * sizeof(WCHAR));
        if (NULL == wstrName)
        {
            goto exit;
        }

        i = 0;
        while (ERROR_SUCCESS == RegEnumKeyExW(hkPCI, i, wstrName, &dwNameLen, NULL, NULL, NULL, &fileTime))
        {            
            if (FAILED(StringCchPrintf(wstrVName, MAX_PATH, L"%x", ENUM_BASE+i)))
            {
               continue;
            }
            
            nkey = key->AddKey(wstrVName);
            if (!nkey) continue;

            if (SUCCEEDED(StringCchCopy(wstrVName, MAX_PATH, L"PCI\\")) &&
                SUCCEEDED(StringCchCat(wstrVName, MAX_PATH, wstrName)))                
            {
               nkey->AddValue(L"HardWareKey", REG_SZ, (LPBYTE)wstrVName);
            }            
            nkey->AddValueDWORD(L"Problem", 0);

            dwNameLen = MAX_PATH;
            ++i;
        }
    }

    key = VRegistry.AddKey(L"HKDD\\Config Manager\\Global");

    key = VRegistry.AddKey(L"HKDD\\PerfStats");
    
    key = VRegistry.AddKey(L"HKDD\\PerfStats\\StartSrv");
    if (key)
    {
        dwValue = 0x0000001;
        key->AddValue(L"KERNEL", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM", REG_BINARY, (LPBYTE)&dwValue, 4);
    }
    
    key = VRegistry.AddKey(L"HKDD\\PerfStats\\StartStat");
    if (key)
    {
        dwValue = 0x0000001;
        key->AddValue(L"KERNEL\\CPUUsage", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"KERNEL\\Threads", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"KERNEL\\VMs", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VCACHE\\cCurPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\cMacPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\cMinPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\FailedRecycles", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\Hits", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\LRUBuffers", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\LRURecycles", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\Misses", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\RandomRecycles", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VFAT\\BReadsSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\BWritesSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\DirtyData", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\ReadsSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\WritesSec", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VMM\\cDiscards", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cInstanceFaults", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageFaults", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageIns", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageOuts", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgCommit", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcache", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMac", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMid", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMin", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgFree", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgLocked", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgLockedNonCache", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgOther", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSharedPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwap", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFile", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFileDefective", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFileInUse", REG_BINARY, (LPBYTE)&dwValue, 4);
    }

    key = VRegistry.AddKey(L"HKDD\\PerfStats\\StatData");
    if (key)
    {
        dwValue = 0x0000001;
        key->AddValue(L"KERNEL\\CPUUsage", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"KERNEL\\Threads", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"KERNEL\\VMs", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VCACHE\\cCurPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\cMacPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\cMinPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\FailedRecycles", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\Hits", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\LRUBuffers", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\LRURecycles", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\Misses", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\RandomRecycles", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VFAT\\BReadsSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\BWritesSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\DirtyData", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\ReadsSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\WritesSec", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VMM\\cDiscards", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cInstanceFaults", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageFaults", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageIns", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageOuts", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgCommit", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcache", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMac", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMid", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMin", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgFree", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgLocked", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgLockedNonCache", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgOther", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSharedPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwap", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFile", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFileDefective", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFileInUse", REG_BINARY, (LPBYTE)&dwValue, 4);
    }

    key = VRegistry.AddKey(L"HKDD\\PerfStats\\StopSrv");
    if (key)
    {
        dwValue = 0x0000001;
        key->AddValue(L"KERNEL", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT",   REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM",    REG_BINARY, (LPBYTE)&dwValue, 4);
    }

    key = VRegistry.AddKey(L"HKDD\\PerfStats\\StopStat");
    if (key)
    {
        dwValue = 0x0000001;
        key->AddValue(L"KERNEL\\CPUUsage", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"KERNEL\\Threads", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"KERNEL\\VMs", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VCACHE\\cCurPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\cMacPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\cMinPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\FailedRecycles", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\Hits", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\LRUBuffers", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\LRURecycles", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\Misses", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\RandomRecycles", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VFAT\\BReadsSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\BWritesSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\DirtyData", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\ReadsSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\WritesSec", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VMM\\cDiscards", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cInstanceFaults", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageFaults", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageIns", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageOuts", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgCommit", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcache", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMac", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMid", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMin", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgFree", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgLocked", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgLockedNonCache", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgOther", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSharedPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwap", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFile", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFileDefective", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFileInUse", REG_BINARY, (LPBYTE)&dwValue, 4);
    }

exit:
    if (NULL != wstrName)
    {
        free(wstrName);
    }

    if (NULL != wstrVName)
    {
        free(wstrVName);
    }

    if (0 != hkPCI)
    {
        RegCloseKey(hkPCI);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

  DisplaySettings

 History:

    10/17/2000 robkenny Added HKEY_CURRENT_CONFIG

--*/

void
BuildCurrentConfig(char* /*szParam*/)
{
    DEVMODE devMode;
    memset(&devMode, 0, sizeof(devMode));
    devMode.dmSize = sizeof(devMode);

    // Get the current display settings
    BOOL bSuccessful = EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &devMode);
    if (bSuccessful)
    {
        // Create fake registry keys with dmPelsWidth, dmPelsHeight, dmPelsWidth and dmBitsPerPel
        VIRTUALKEY *key = VRegistry.AddKey(L"HKCC\\Display\\Settings");
        if (key)
        {
            WCHAR lpValue[100];
            if (SUCCEEDED(StringCchPrintf(lpValue, 100, L"%d",devMode.dmBitsPerPel)))
            {
               key->AddValue(L"BitsPerPixel", REG_SZ, (LPBYTE)lpValue, 0);
            }
            
            if (SUCCEEDED(StringCchPrintf(lpValue, 100,L"%d,%d", devMode.dmPelsWidth, devMode.dmPelsHeight)))
            {
               key->AddValue(L"Resolution", REG_SZ, (LPBYTE)lpValue, 0);
            }
        }
    }

    // Redirect the current desktop fonts
    VRegistry.AddRedirect(
        L"HKCC\\Display\\Fonts",
        L"HKCC\\Software\\Fonts");
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Make RegQueryValue return the value that's in the "(Default)" value, rather 
    than the NULL which is in there now. Not sure why the Locale key has this 
    difference.

 History:

    06/29/2000 linstev  Created

--*/

void
BuildLocale(char* /*szParam*/)
{
    #define LOCALE_KEY    HKEY_LOCAL_MACHINE
    #define LOCALE_SUBKEY L"System\\CurrentControlSet\\Control\\Nls\\Locale"

    HKEY hkBase;

    if (FAILURE(RegOpenKeyExW(
            LOCALE_KEY,
            LOCALE_SUBKEY,
            0,
            KEY_READ,
            &hkBase)))
    {
        return;
    }

    WCHAR wValue[MAX_PATH];
    DWORD dwSize = MAX_PATH * sizeof(WCHAR);

    if (SUCCESS(RegQueryValueExW(hkBase, L"(Default)", 0, 0, (LPBYTE)wValue, &dwSize)))
    {
        LPWSTR wzPath;
        VIRTUALKEY *localekey;

        // Convert the KEY and SUBKEY into a path we can use for the vregistry
        wzPath = MakePath(LOCALE_KEY, 0, LOCALE_SUBKEY);
        if (wzPath)
        {
            localekey = VRegistry.AddKey(wzPath);
            if (localekey)
            {
                localekey->AddValue(L"", REG_SZ, (LPBYTE)wValue);
            }
            free(wzPath);
        }
    }

    RegCloseKey(hkBase);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    On NT, the strings in these values are of the form:

          C:\Program Files\Windows NT\Accessories\WORDPAD.EXE "%1"

    Note that the entire string is NOT quoted. On win9x, the string was:

          C:\Windows\wordpad.exe "%1"

    This causes problems when apps parse the NT version, because they hit the 
    space between Program and Files.

    The fix is to return a shortened pathname to wordpad.exe

 History:

    05/04/2000 linstev  Created
    05/04/2000 robkenny Updated to return a correct short pathname to wordpad.exe

--*/

void
BuildWordPad(char* /*szParam*/)
{
    // Allocate memory so we don't use up lots of stack
    WCHAR *lpwzWordpadOpen = (WCHAR *)malloc(MAX_PATH * sizeof(WCHAR));
    WCHAR *lpwzWordpadPrint = (WCHAR *)malloc(MAX_PATH * sizeof(WCHAR));
    WCHAR *lpwzWordpadPrintTo = (WCHAR *)malloc(MAX_PATH * sizeof(WCHAR));

    WCHAR *lpwzWordpadLong = lpwzWordpadOpen; // borrow the buffer to save space
    WCHAR *lpwzWordpadShort = (WCHAR *)malloc(MAX_PATH * sizeof(WCHAR));

    DWORD lpType;
    DWORD cbValue;
    LONG result;

    if (lpwzWordpadOpen == NULL ||
        lpwzWordpadPrint == NULL ||
        lpwzWordpadPrintTo == NULL ||
        lpwzWordpadShort == NULL)
    {
        goto AllDone;
    }

    // Read the path to WORDPAD.EXE directly from the registry.
    HKEY hKeyAppPaths;
    result = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\WORDPAD.EXE",
        0, 
        KEY_QUERY_VALUE,
        &hKeyAppPaths
        );
    
    if (result != ERROR_SUCCESS)
    {
        goto AllDone;
    }

    cbValue = MAX_PATH * sizeof(DWORD);
    result = RegQueryValueExW(
        hKeyAppPaths,
        NULL, // default value
        NULL,
        &lpType,
        (LPBYTE)lpwzWordpadLong,
        &cbValue);

    RegCloseKey(hKeyAppPaths);
    if (result != ERROR_SUCCESS)
    {
        goto AllDone;
    }

    // turn bytes into string length (includes EOS)
    DWORD cchValue = cbValue /sizeof(WCHAR); 

    if (lpType == REG_EXPAND_SZ)
    {
        WCHAR * lpwzWordpadExpand = lpwzWordpadPrintTo; // borrow the lpwzWordpadPrintTo buffer for a moment.

        cchValue = ExpandEnvironmentStringsW(lpwzWordpadLong, lpwzWordpadExpand, MAX_PATH);
        if (cchValue == 0 || cchValue > MAX_PATH )
            goto AllDone;

        lpwzWordpadLong = lpwzWordpadExpand;
    }

    // Rip off the trailing Quote
    lpwzWordpadLong[cchValue-2] = 0;
    lpwzWordpadLong += 1;

    // Build the short path to wordpad
    cchValue = GetShortPathNameW(lpwzWordpadLong, lpwzWordpadShort, MAX_PATH);
    if (cchValue == 0 || cchValue > MAX_PATH)
    {
        goto AllDone;
    }

    if (FAILED(StringCchPrintf(lpwzWordpadOpen, MAX_PATH,L"%s \"%%1\"", lpwzWordpadShort)) ||
        FAILED(StringCchPrintf(lpwzWordpadPrint, MAX_PATH, L"%s /p \"%%1\"",lpwzWordpadShort)) ||
        FAILED(StringCchPrintf(lpwzWordpadPrintTo, MAX_PATH,L"%s /pt \"%%1\" \"%%2\" \"%%3\" \"%%4\"", lpwzWordpadShort)))
    {
       goto AllDone;
    }    

    #define WORDPAD_OPEN    ((LPBYTE)lpwzWordpadOpen)
    #define WORDPAD_PRINT   ((LPBYTE)lpwzWordpadPrint)
    #define WORDPAD_PRINTTO ((LPBYTE)lpwzWordpadPrintTo)

    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKCR\\rtffile\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKCR\\rtffile\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKCR\\rtffile\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

    key = VRegistry.AddKey(L"HKCR\\Wordpad.Document.1\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKCR\\Wordpad.Document.1\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKCR\\Wordpad.Document.1\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

    key = VRegistry.AddKey(L"HKCR\\wrifile\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKCR\\wrifile\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKCR\\wrifile\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\Applications\\wordpad.exe\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\Applications\\wordpad.exe\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\Applications\\wordpad.exe\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\rtffile\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\rtffile\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\rtffile\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\Wordpad.Document.1\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\Wordpad.Document.1\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\Wordpad.Document.1\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\wrifile\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\wrifile\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\wrifile\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

AllDone:
    free(lpwzWordpadOpen);
    free(lpwzWordpadPrint);
    free(lpwzWordpadPrintTo);

    free(lpwzWordpadShort);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    This is a REG_BINARY on win9x

 History:

    07/18/2000 linstev  Created

--*/

void
BuildAutoRun(char* /*szParam*/)
{
    #define AUTORUN_KEY    HKEY_CURRENT_USER
    #define AUTORUN_SUBKEY L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"

    HKEY hkBase;

    if (FAILURE(RegOpenKeyExW(
            AUTORUN_KEY,
            AUTORUN_SUBKEY,
            0,
            KEY_READ,
            &hkBase)))
    {
        return;
    }

    DWORD dwValue;
    DWORD dwSize = sizeof(DWORD);

    if (SUCCESS(RegQueryValueExW(hkBase, L"NoDriveTypeAutoRun", 0, 0, (LPBYTE)&dwValue, &dwSize)))
    {
        LPWSTR wzPath;
        VIRTUALKEY *vkey;

        // Convert the KEY and SUBKEY into a path we can use for the vregistry
        wzPath = MakePath(AUTORUN_KEY, 0, AUTORUN_SUBKEY);
        if (wzPath)
        {
            vkey = VRegistry.AddKey(wzPath);
            if (vkey)
            {
                vkey->AddValue(L"NoDriveTypeAutoRun", REG_BINARY, (LPBYTE)&dwValue, sizeof(DWORD));
            }
            free(wzPath);
        }
    }

    RegCloseKey(hkBase);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add SharedDir value to HKLM\Software\Microsoft\Windows\CurrentVersion\Setup
    The SharedDir in this case is just the windows directory (as it was on 9x).

 History:

    12/28/2000 a-brienw  Created

--*/

void
BuildTalkingDictionary(char* /*szParam*/)
{
    VIRTUALKEY *key;
    WCHAR szWindowsDir[MAX_PATH];
    
    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup");
    if (key)
    {
        DWORD cchSize = GetWindowsDirectoryW( (LPWSTR)szWindowsDir, MAX_PATH);
        if (cchSize != 0 && cchSize <= MAX_PATH)
            key->AddValue(L"SharedDir", REG_SZ, (LPBYTE)szWindowsDir);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add a ProductName value to every network card description as on NT 4. The 
    product name in this case is just the first 8 characters of the 
    description.

 History:

    01/18/2000 linstev  Created
    03/01/2001 prashkud Added NetBT\Adapter key and the corresponding values

--*/

void 
BuildNetworkCards(char* /*szParam*/)
{
    #define NETCARD_KEY    HKEY_LOCAL_MACHINE
    #define NETCARD_SUBKEY L"Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards"
    #define NETBT_SUBKEY   L"System\\CurrentControlSet\\Services\\NetBT"
    
    // For NetBT
    LPWSTR wzNetBTPath;
    WCHAR wAdapter[MAX_PATH];   
    VIRTUALKEY *vkAdapter = NULL;
    HKEY hkNetBT;

    if (FAILURE(RegOpenKeyExW(
            NETCARD_KEY,
            NETBT_SUBKEY,
            0,
            KEY_READ,
            &hkNetBT)))
    {
        DPFN( eDbgLevelError, "Failed to add NetBT settings");
        return;
    }

    if (FAILED(StringCchCopy(wAdapter, MAX_PATH, NETBT_SUBKEY)))
    {
       RegCloseKey(hkNetBT);
       return;
    }
    if (FAILED(StringCchCat(wAdapter, MAX_PATH, L"\\Adapters")))
    {
       RegCloseKey(hkNetBT);
       return;
    }
    
    // Make this a Virtual path
    wzNetBTPath = MakePath(NETCARD_KEY, 0, wAdapter);
    if (!wzNetBTPath)
    {
        DPFN( eDbgLevelError, "Failed to make NetBT path");
        RegCloseKey(hkNetBT);
        return;
    }

    // Adding the Adapters subkey to NetBT
    vkAdapter = VRegistry.AddKey(wzNetBTPath);
    free(wzNetBTPath);

    HKEY hkBase;

    // Check for network cards
    if (FAILURE(RegOpenKeyExW(
            NETCARD_KEY,
            NETCARD_SUBKEY,
            0,
            KEY_READ,
            &hkBase)))
    {
        DPFN( eDbgLevelError, "Failed to add Network card registry settings");
        return;
    }

    LPWSTR wzPath;
    VIRTUALKEY *netkey;

    // Convert the KEY and SUBKEY into a path we can use for the vregistry
    wzPath = MakePath(NETCARD_KEY, 0, NETCARD_SUBKEY);
    netkey = wzPath ? VRegistry.AddKey(wzPath) : NULL;
    
    if (wzPath && netkey)
    {
        // Enumerate the keys and add them to the virtual registry
        DWORD dwIndex = 0;
        WCHAR wName[MAX_PATH];

        while (SUCCESS(RegEnumKeyW(
                hkBase,
                dwIndex,
                wName,
                MAX_PATH)))
        {
            HKEY hKey;
            VIRTUALKEY *keyn;
            WCHAR wTemp[MAX_PATH];

            keyn = netkey->AddKey(wName);

            if (!keyn)
            {
                break;
            }

            if (SUCCEEDED(StringCchCopy(wTemp, MAX_PATH, NETCARD_SUBKEY)) &&
                SUCCEEDED(StringCchCat(wTemp, MAX_PATH, L"\\")) &&
                SUCCEEDED(StringCchCat(wTemp, MAX_PATH,wName)))

            {            
               // Open the actual key
               if (SUCCESS(RegOpenKeyExW(
                       NETCARD_KEY,
                       wTemp,
                       0,
                       KEY_READ,
                       &hKey)))
               {
                   WCHAR wDesc[MAX_PATH];
                   WCHAR wServName[MAX_PATH];
                   DWORD dwSize = MAX_PATH; 
   
                   // check for description
                   if (SUCCESS(RegQueryValueExW(
                           hKey,
                           L"Description",
                           0,
                           0,
                           (LPBYTE)wDesc,
                           &dwSize)))
                   {
                       // Max out at 8 characters
                       wDesc[8] = L'\0';
                       keyn->AddValue(L"ProductName", REG_SZ, (LPBYTE)wDesc);
                   }
   
                   // Query for the ServiceName Value
                   dwSize = MAX_PATH;
                   if (SUCCESS(RegQueryValueExW(
                          hKey,
                          L"ServiceName",
                          0,
                          0,
                          (LPBYTE)wServName,
                          &dwSize)))
                   {                                       
                       if (vkAdapter)
                       {                       
                           if (!vkAdapter->AddKey(wServName))
                           {
                               DPFN( eDbgLevelError, "Error adding the Key to NetBT");                        
                           }
                       }
                   }
   
                   RegCloseKey(hKey);
               }
            }

            dwIndex++;
        }
    }

    free(wzPath);

    RegCloseKey(hkBase);
    RegCloseKey(hkNetBT);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add NT4 SP5 Credentials.

 History:

    05/23/2000 linstev  Created

--*/

void
BuildNT4SP5(char* /*szParam*/)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"CSDVersion", REG_SZ, (LPBYTE)L"Service Pack 5");
    }

    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"CurrentVersion", REG_SZ, (LPBYTE)L"4.0");
    }

    key = VRegistry.AddKey(L"HKLM\\System\\CurrentControlSet\\Control\\Windows");
    if (key)
    {
        key->AddValueDWORD(L"CSDVersion", 0x0500);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add Win2k version number

 History:

    05/22/2001 linstev  Created

--*/

void
BuildNT50(char* /*szParam*/)
{
    VIRTUALKEY *key;

    // Add Win2k version number 
    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"CurrentVersion", REG_SZ, (LPBYTE)L"5.0");
        key->AddValue(L"ProductName", REG_SZ, (LPBYTE)L"Microsoft Windows 2000");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add WinXP version number

 History:

    05/01/2002 linstev  Created

--*/

void
BuildNT51(char* /*szParam*/)
{
    VIRTUALKEY *key;

    // Add Win2k version number 
    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"CurrentVersion", REG_SZ, (LPBYTE)L"5.1");
        key->AddValue(L"ProductName", REG_SZ, (LPBYTE)L"Microsoft Windows XP");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    This function adds the Shell compatibility flag for apps that need the 
    bogus Ctrl ID of IDOK for ToolBarWindows32 class.

    This also gets applied through the Win2K layer as this is a regression from 
    Win2K.

 History:

    05/04/2001 prashkud  Created

--*/

void
BuildBogusCtrlID(char* /*szParam*/)
{            
    CSTRING_TRY
    {
        WCHAR wszFileName[MAX_PATH];
        CString csFileName, csFileTitle;
        CString csRegPath(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\ShellCompatibility\\Applications");
        VIRTUALKEY *Key;

        if (GetModuleFileName(NULL, wszFileName, MAX_PATH))
        {
            csFileName = wszFileName;
            csFileName.GetLastPathComponent(csFileTitle);
            csRegPath.AppendPath(csFileTitle);

            Key = VRegistry.AddKey(csRegPath.Get());
            if (Key)
            {
                Key->AddValue(L"FILEOPENBOGUSCTRLID", REG_SZ, 0, 0);                
                LOGN(eDbgLevelInfo, "Added FILEOPENBOGUSCTRLID value for app %S", csFileTitle.Get());
            }
        }
    }
    CSTRING_CATCH
    {
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Known different values from Win9x.

 History:

    05/04/2000 linstev  Created

--*/

void
BuildExpanders(char* /*szParam*/)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion");
    if (key)
    {
        // These are REG_EXPAND_SZ on NT and REG_SZ on Win9x
        key->AddExpander(L"DevicePath");
        key->AddExpander(L"ProgramFilesPath");
        key->AddExpander(L"WallPaperDir");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add DX7a Credentials.

 History:

    05/23/2000 linstev  Created

--*/

void
BuildDX7A(char* /*szParam*/)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\DirectX");
    if (key)
    {
        key->AddValue(L"Version", REG_SZ, (LPBYTE)L"4.07.00.0716");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add DXDIAG path.

 History:

    04/05/2001 mnikkel  Created

--*/

void
BuildDXDiag(char* /*szParam*/)
{
    VIRTUALKEY *key;
    WCHAR wszPathDir[MAX_PATH];   
    DWORD cchSize = GetSystemDirectoryW(wszPathDir, MAX_PATH);
    
    if (cchSize == 0 || cchSize > MAX_PATH)
    {
        DPFN( eDbgLevelError, "BuildDXDiag: GetSystemDirectory Failed");
        return;
    }
    
    if (FAILED(StringCchCat(wszPathDir, MAX_PATH,  L"\\dxdiag.exe")))
    {
       return;
    }    

    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\DXDIAG.EXE");
    if (key)
    {
        key->AddValue(L"", REG_EXPAND_SZ, (LPBYTE)wszPathDir, 0);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add FullScreen == 1 to fix bug in Future Cop that makes it not always run
    in fullscreen mode.

 History:

    09/01/2000 linstev  Created

--*/

void
BuildFutureCop(char* /*szParam*/)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\Software\\Electronic Arts\\Future Cop\\Settings");
    if (key)
    {
        key->AddValueDWORD(L"FullScreen", 0x01);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Return to Krondor attempts to find ACM drivers, this key was moved and renamed.
    Was: HKLM\System\CurrentControlSet\Control\MediaResources\ACM\MSACM.MSADPCM\drivers = msadp32.acm
    Is:  HKLM\Software\Microsoft\Windows NT\CurrentVersion\Drivers32\Msacm.Msadpcm = msadp32.acm
    Grab the current value from the registry, and build a virtual key and value

 History:

    09/06/2000 robkenny  Created

--*/

void
BuildKrondor(char* /*szParam*/)
{
    HKEY msadpcmKey;
    LONG error = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32",
        0, KEY_READ, &msadpcmKey);

    if (SUCCESS(error))
    {
        // Found the key, grab the name of the driver
        WCHAR driverName[MAX_PATH];
        DWORD driverNameSize = sizeof(driverName);
        DWORD driverNameType = REG_SZ;

        error = RegQueryValueExW(
            msadpcmKey, 
            L"MSACM.MSADPCM", 
            0, &driverNameType, 
            (LPBYTE)driverName, 
            &driverNameSize);

        if (SUCCESS(error))
        {
            // We got all the data, so we can now add the virtual key and value
            VIRTUALKEY *key = VRegistry.AddKey(L"HKLM\\System\\CurrentControlSet\\Control\\MediaResources\\ACM\\MSACM.MSADPCM");
            if (key)
            {
                key->AddValue(L"driver", REG_SZ, (LPBYTE)driverName, 0);
            }
        }

        RegCloseKey(msadpcmKey);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Redirect changes from CURRENT_USER to LOCAL_MACHINE.

 History:

    09/17/2000 linstev  Created

--*/

void
BuildProfile(char* /*szParam*/)
{
    VRegistry.AddRedirect(
        L"HKCU\\Software\\Microsoft\\Windows",
        L"HKLM\\Software\\Microsoft\\Windows");
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

  In Spell it Deluxe setup, the path for the SpeechFonts DLL ECN_1K8.DLL is 
  hardcoded to " C:\Voices32". If the installation is on a D: partition, the
  LoadLibraryA( ) call fails and the App AV's. 
  Now the current partition drive will be taken and added to the path.

 History:

    09/21/2000 prashkud  Created

--*/

void
BuildSpellItDeluxe(char* /*szParam*/)
{
    HKEY hSpeechFonts;
    WCHAR wszSystemDir[MAX_PATH], wszPathDir[MAX_PATH];
       
    if (GetSystemDirectory(wszSystemDir, MAX_PATH))
    {
        *(wszSystemDir+3) = L'\0';
    }
    else
    {
        DPFN( eDbgLevelError, "SpellIt: GetSystemDirectory Failed");
        return;
    }
    
    
    if (FAILED(StringCchCopy(wszPathDir, MAX_PATH, wszSystemDir)))
    {
       return;
    }
    if (FAILED(StringCchCat(wszPathDir, MAX_PATH, L"Voices32")))
    {
       return;
    }

    LONG error = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        L"Software\\FirstByte\\ProVoice\\SpeechFonts",
        0, KEY_READ | KEY_WRITE, &hSpeechFonts);

    if (SUCCESS(error))
    {
        if (FAILED(RegSetValueExW(
            hSpeechFonts,
            L"Path",
            0,
            REG_SZ,
            (LPBYTE) wszPathDir,
            wcslen(wszPathDir) * sizeof(WCHAR))))                          
        {
            DPFN( eDbgLevelError, "SpellIt: RegSetValueEx failed");
        }

        RegCloseKey(hSpeechFonts);
    }
    else
    {
        DPFN( eDbgLevelError, "SpellIt: RegOpenKeyExW failed");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Some applications need internet explorer for their functionality. The 
    applications try get the version of the internet explorer from the following 
    registry key : HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion. But 
    under WHISTLER environment, the key entry will not be created. So, the apps 
    fail to continue.

    The app looks for the version info of the Internet Explorer in the registry
    at HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion from the "Plus! 
    VersionNumber" Key. In WHISTLER the key will not be created in the registry. 

    To solve the problem we use Virtual Registry Keys. So, the app will assume 
    the key is existing in the registry.

    WHISTLER, by default, will install I.E.6. So, I have created the key as 
    "IE 6 6.0.2404.0000" and this is the latest version of I.E. on WHISTLER as 
    on today.(11/22/2000).

 History:

    11/22/2000 v-rbabu  Created
    07/03/2001 linstev  Added IE 5.5 from Win2k 

--*/

void
BuildIE401(char* /*szParam*/)
{
    
    VIRTUALKEY *key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Internet Explorer");
    if (key)
    {
        key->AddValue(L"Version", REG_SZ, (LPBYTE)L"4.72.2106.9", 0);
    }
}

void
BuildIE55(char* /*szParam*/)
{
    
    VIRTUALKEY *key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Internet Explorer");
    if (key)
    {
        key->AddValue(L"Version", REG_SZ, (LPBYTE)L"5.50.4522.1800", 0);
    }
}

void
BuildIE60(char* /*szParam*/)
{
    WCHAR wIE[] = L"IE 6 6.0.2404.0000";
    
    // Now add the virtual key and value
    VIRTUALKEY *key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"Plus! VersionNumber", REG_SZ, (LPBYTE)wIE, 0);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    The idea here is to fix apps that depend on short names for input devices.
    We just trim the name to 32 characters (including terminator).
    
 History:

    12/06/2000 linstev  Created

--*/

void
BuildJoystick(char* /*szParam*/)
{
    HKEY hJoystickKey;    
    WCHAR wszKeyName[MAX_PATH];
    DWORD dwIndex;

    const WCHAR wszJoystickPath[] = L"System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Joystick\\OEM";

    if (FAILURE(RegOpenKeyExW(HKEY_LOCAL_MACHINE, wszJoystickPath, 0, KEY_READ, &hJoystickKey)))
    {
        DPFN( eDbgLevelSpew, "[Joystick hack] No joysticks found");
        return;
    }
    
    //
    // Enum the keys under Joystick and make virtual entries 
    //

    dwIndex = 0;

    while (SUCCESS(RegEnumKeyW(hJoystickKey, dwIndex, wszKeyName, MAX_PATH)))
    {
        WCHAR wszID[MAX_PATH] = L"HKLM\\";
        if (SUCCEEDED(StringCchCat(wszID, MAX_PATH, wszJoystickPath)) &&
            SUCCEEDED(StringCchCat(wszID, MAX_PATH, L"\\")) &&
            SUCCEEDED(StringCchCat(wszID, MAX_PATH, wszKeyName)))
        {
           HKEY hkOEM;
           if (SUCCESS(RegOpenKeyExW(hJoystickKey, wszKeyName, 0, KEY_READ, &hkOEM)))
           {
               WCHAR wszName[MAX_PATH + 1];
               DWORD dwSize = MAX_PATH * sizeof(WCHAR);
               if (SUCCESS(RegQueryValueExW(hkOEM, L"OEMName", 0, NULL, (LPBYTE) wszName, &dwSize)))
               {
                   if (dwSize > 31 * sizeof(WCHAR))
                   {
                       VIRTUALKEY *key = VRegistry.AddKey(wszID);
                       if (key)
                       {
                           dwSize = 31 * sizeof(WCHAR);
                           wszName[31] = L'\0';
                           key->AddValue(L"OEMName", REG_SZ, (LPBYTE) wszName);
                       }
                   }
               }
   
               RegCloseKey(hkOEM);
           }
        }

        dwIndex++;
    }
    
    RegCloseKey(hJoystickKey);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Hack for Adobe Illustrator 8

 History:

    12/18/2000 linstev  Created

--*/

void
BuildIllustrator8(char* /*szParam*/)
{
    if (ShouldApplyShim())
    {
        // Redirect everything 
        VRegistry.AddRedirect(
            L"HKLM\\Software\\Adobe",
            L"HKCU\\Software\\Adobe");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Hack for Adobe PageMaker 6.5

 History:

    02/27/2001 maonis Created

--*/

void BuildPageMaker65(char* /*szParam*/)
{
    if (ShouldApplyShim())
    {
        VRegistry.AddRedirect(
            L"HKCU\\Software\\Adobe\\PageMaker65",
            L"HKLM\\Software\\Adobe\\PageMaker65");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Hack for PageKeepPro30.
    
 History:

    01/15/2000 maonis  Created

--*/

void
BuildPageKeepProDirectory(char* /*szParam*/)
{
    // We cannot call ShGetSpecialFolderPath since we are still in our DLL main,
    // so we get the path to "My Documents" directly from the registry.
    HKEY hkFolders;
    if (SUCCESS(RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", 0, KEY_READ, &hkFolders)))
    {
        DWORD dwType;
        WCHAR wszPath[MAX_PATH];
        DWORD dwSize = MAX_PATH*sizeof(WCHAR);

        if (SUCCESS(RegQueryValueExW( hkFolders, L"Personal", NULL, &dwType, (LPBYTE)wszPath, &dwSize)))
        {
            VIRTUALKEY *key = VRegistry.AddKey(L"HKCU\\Software\\Caere Corp\\PageKeepPro30\\Preference");
            if (key)
            {
                key->AddValue(L"Directory", REG_EXPAND_SZ, (LPBYTE)wszPath, 0);
            }
        }
        RegCloseKey(hkFolders);
    }

    // Secondly, since we don't support using UI-less mode for TWAIN layer 
    // we mandatorily set BASICMODE for scanners to 2 instead of 0 - 2 means
    // to always use UI mode.
    HKEY hkScanners;
    WCHAR wszKeyName[MAX_PATH] = L"";
    DWORD dwIndex;

    const WCHAR wszScanner[] = L"Software\\Caere Corp\\Scan Manager\\4.02\\Scanners";

    if (FAILURE(RegOpenKeyExW(HKEY_LOCAL_MACHINE, wszScanner,0, KEY_READ, &hkScanners)))
    {
        DPFN( eDbgLevelSpew, "[PageKeepPro 3.0] No scanner found");
        return;
    }
    
    dwIndex = 0;

    while (SUCCESS(RegEnumKeyW(hkScanners, dwIndex, wszKeyName, MAX_PATH)))
    {
        WCHAR wszID[MAX_PATH] = L"HKLM\\";
        
        if (SUCCEEDED(StringCchCat(wszID, MAX_PATH,wszScanner)) &&
            SUCCEEDED(StringCchCat(wszID, MAX_PATH,L"\\")) &&
            SUCCEEDED(StringCchCat(wszID, MAX_PATH,wszKeyName)))
        {        
           HKEY hkScanner;
           if (SUCCESS(RegOpenKeyExW(hkScanners, wszKeyName, 0, KEY_READ, &hkScanner)))
           {
               VIRTUALKEY *keyMode = VRegistry.AddKey(wszID);
               if (keyMode)
               {
                   keyMode->AddValueDWORD(L"BASICMODE", 2);
               }
   
               RegCloseKey(hkScanner);
           }
        }

        dwIndex++;
    }
    
    RegCloseKey(hkScanners);

}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Hack for ModemWizard because the keys moved

 History:

    01/18/2001 linstev & a-leelat Created

--*/

void
BuildModemWizard(char* /*szParam*/)
{
    // Redirect everything 
    VRegistry.AddRedirect(
        L"HKLM\\SYSTEM\\CurrentControlSet\\Enum\\Root",
        L"HKLM\\SYSTEM\\CurrentControlSet\\Enum");
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Hack for Office2000 Developer 1.5 which looks in the wrong place for 
    components. 

    From ChetanP:

        Basically the redirect code would have to do something like this -

        if HKLM\Software\Microsoft\Windows\CurrentVersion\Installer\UserData\<user sid>\Components\359E92CC2CB71D119A12000A9CE1A22A
            exists, redirect to that location
        else if HKLM\Software\Microsoft\Windows\CurrentVersion\Installer\UserData\S-1-5-18\Components\359E92CC2CB71D119A12000A9CE1A22A
            exists, redirect to that location
        else, no redirection.

    Whistler Bug #241596

 History:

    02/01/2001 linstev  Created

--*/

#define SIZE_OF_TOKEN_INFORMATION                 \
    sizeof(TOKEN_USER) +                          \
    sizeof(SID) +                                 \
    sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES

#define SIZE_OF_SID_MAX                           \
    sizeof(SID) +                                 \
    SID_MAX_SUB_AUTHORITIES * sizeof(DWORD) 

#define cchMaxSID                               256

//
// Get the current SID as text
//

BOOL 
GetStringSID(
    WCHAR *szSID
    )
{
    BOOL bRet = TRUE;
    HANDLE hToken = NULL;
    int i;
    PISID pISID;
    UCHAR rgSID[SIZE_OF_SID_MAX];
    UCHAR TokenInformation[SIZE_OF_TOKEN_INFORMATION];
    ULONG ReturnLength;
    WCHAR Buffer[cchMaxSID];

    // 
    // Get a token
    //
    
    if (!OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_IMPERSONATE | TOKEN_QUERY, 
            TRUE, 
            &hToken))
    {
        if (GetLastError() == ERROR_NO_TOKEN)
        {
            bRet = OpenProcessToken(
                GetCurrentProcess(), 
                TOKEN_IMPERSONATE | TOKEN_QUERY, 
                &hToken);
        }
        else
        {
            bRet = FALSE;
        }
    }

    if (!bRet) 
    {
        DPFN( eDbgLevelError, "[GetStringSID] Failed to OpenProcessToken");
        goto Exit;
    }

    // 
    // Get the binary form of the token
    //

    bRet = GetTokenInformation(
        hToken,
        TokenUser,
        TokenInformation,
        sizeof(TokenInformation),
        &ReturnLength);

    if (bRet)
    {
        bRet = FALSE;
        pISID = (PISID)((PTOKEN_USER) TokenInformation)->User.Sid;
    
        if (!CopySid(SIZE_OF_SID_MAX, rgSID, pISID))
        {
            DPFN( eDbgLevelError, "CopySID failed");
            goto Exit;
        }
    
        //
        // Get the text form of the token
        //
        
        HRESULT hr = StringCchPrintf(Buffer, cchMaxSID,L"S-%u-", (USHORT) pISID->Revision);
        if (FAILED(hr))
        {
           goto Exit;
        }
        hr = StringCchCopy(szSID, 1024, Buffer);
        if (FAILED(hr))
        {
           goto Exit;
        }        
    
        if ((pISID->IdentifierAuthority.Value[0] != 0) ||
            (pISID->IdentifierAuthority.Value[1] != 0))
        {
            hr = StringCchPrintf(Buffer, cchMaxSID,
                                 L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                                 (USHORT) pISID->IdentifierAuthority.Value[0],
                                 (USHORT) pISID->IdentifierAuthority.Value[1],
                                 (USHORT) pISID->IdentifierAuthority.Value[2],
                                 (USHORT) pISID->IdentifierAuthority.Value[3],
                                 (USHORT) pISID->IdentifierAuthority.Value[4],
                                 (USHORT) pISID->IdentifierAuthority.Value[5]);
            if (FAILED(hr))
            {
               goto Exit;
            }

            hr = StringCchCat(szSID, 1024, Buffer);
            if (FAILED(hr))
            {
               goto Exit;
            }
        } 
        else 
        {
            ULONG Tmp = 
                (ULONG) pISID->IdentifierAuthority.Value[5]         +
                (ULONG)(pISID->IdentifierAuthority.Value[4] <<  8)  +
                (ULONG)(pISID->IdentifierAuthority.Value[3] << 16)  +
                (ULONG)(pISID->IdentifierAuthority.Value[2] << 24);
    
            hr = StringCchPrintf(Buffer, cchMaxSID, L"%lu", Tmp);
            if (FAILED(hr))
            {
               goto Exit;
            }
            hr = StringCchCat(szSID, 1024, Buffer);
            if (FAILED(hr))
            {
               goto Exit;
            }
        }
    
        for (i=0; i < pISID->SubAuthorityCount; i++) 
        {
            hr = StringCchPrintf(Buffer, cchMaxSID, L"-%lu", pISID->SubAuthority[i]);
            if (FAILED(hr))
            {
               goto Exit;
            }

            hr = StringCchCat(szSID, 1024, Buffer);
            if (FAILED(hr))
            {
               goto Exit;
            }            
        }
    }
    else
    {
        DPFN( eDbgLevelError, "GetTokenInformation failed");
        goto Exit;
    }

    bRet = TRUE;
Exit:
    if (hToken)
    {
        CloseHandle(hToken);
    }
    return bRet;
}

void
BuildMSI(char* /*szParam*/)
{
    WCHAR szSID[1024];

    // Get the current users SID as a string
    if (!GetStringSID(szSID))
    {
        DPFN( eDbgLevelError, "BuildMSI Failed");
        return;
    }

    HKEY hKey;
    WCHAR szTemp[1024];

    const WCHAR szBase[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\";
    const WCHAR szComp[] = L"\\Components\\359E92CC2CB71D119A12000A9CE1A22A";

    HRESULT hr;
    hr = StringCchCopy(szTemp, 1024, szBase);
    if (FAILED(hr))
    {
       return;
    }
    hr = StringCchCat(szTemp, 1024, szSID);
    if (FAILED(hr))
    {
       return;
    }
    hr = StringCchCat(szTemp, 1024, szComp);
    if (FAILED(hr))
    {
       return;
    }
    // Attempt to open szBase + <user sid> + szComp
    if (RegOpenKeyW(HKEY_LOCAL_MACHINE, szTemp, &hKey) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);

        // Attempt to open szBase + S-1-5-18 + szComp
        hr = StringCchCopy(szTemp, 1024, szBase);
        if (FAILED(hr))
        {
           return;
        }
        hr = StringCchCat(szTemp, 1024, L"S-1-5-18");
        if (FAILED(hr))
        {
           return;
        }
        hr = StringCchCat(szTemp, 1024, szComp);
        if (FAILED(hr))
        {
           return;
        }

        if (RegOpenKeyW(HKEY_LOCAL_MACHINE, szTemp, &hKey) != ERROR_SUCCESS)
        {
            DPFN( eDbgLevelError, "BuildMSI Failed to find keys");
            RegCloseKey(hKey);
            return;
        }
    }

    // Redirect as appropriate
    WCHAR szTarget[1024] = L"HKLM\\";
    hr = StringCchCat(szTarget,1024, szTemp);
    if (FAILED(hr))
    {
       return;
    }
    VRegistry.AddRedirect(
        L"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components\\359E92CC2CB71D119A12000A9CE1A22A",
        szTarget);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Added FileNet Web Server

 History:

    02/06/2001 a-larrsh  Created

--*/

void 
BuildFileNetWebServer(char* /*szParam*/)
{
    VIRTUALKEY *key;    

    key = VRegistry.AddKey(L"HKLM\\System\\CurrentControlSet\\Services\\W3SVC\\Parameters");
    if (key)
    {
        key->AddValueDWORD(L"MajorVersion", 0x00000005);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Added default printer key. We have to effectively delay load this, because 
    we can't be guaranteed that winspool will have had it's init routine loaded
    before us. Of course, we still can't guarentee that somebody won't try to 
    get at this key from their dllmain, so we wrap the whole thing in an 
    exception handler.

 History:

    02/06/2001 linstev & mnikkel Created

--*/

LONG 
WINAPI
VR_Printer(
    OPENKEY * /* key */,
    VIRTUALKEY * /* vkey */,
    VIRTUALVAL *vvalue
    )
{
    LOGN( eDbgLevelInfo, "[Printer] Query for legacy printer");

    __try 
    {
        DWORD dwSize;

        // Get the default printer name
        if (GetDefaultPrinterW(NULL, &dwSize) == 0)
        {
            // Now that we have the right size, allocate a buffer
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                LPWSTR pszName = (LPWSTR) malloc(dwSize * sizeof(WCHAR));
                if (pszName)
                {
                    // Now get the default printer with the right buffer size.
                    if (GetDefaultPrinterW(pszName, &dwSize))
                    {
                        //
                        // Set up the virtual value. Note we don't have free the 
                        // memory since it's a once off allocation that persists 
                        // with the value
                        //
                        vvalue->cbData = dwSize * sizeof(WCHAR);
                        vvalue->lpData = (LPBYTE) pszName;

                        //
                        // Never call us again, since we've found the printer and
                        // stored it in our virtual value
                        //
                        vvalue->pfnQueryValue = NULL;
                        return ERROR_SUCCESS;
                    }
                    else
                    {
                        //
                        // We failed to get the default printer, may as well 
                        // clean up gracefully.
                        //

                        free(pszName);
                    }
                }

            }
        }
        
        DPFN( eDbgLevelError, "[Printer] No printers found or out of memory");
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPFN( eDbgLevelError, "[Printer] Exception encountered, winspool not initialized?");
    }

    //
    // Going for the graceful exit: there's no default printer or we get an 
    // error trying to find it.
    //
    
    return ERROR_FILE_NOT_FOUND;
}

void
BuildPrinter(char* /*szParam*/)
{
    VIRTUALKEY *key;
    
    key = VRegistry.AddKey(L"HKCC\\System\\CurrentControlSet\\Control\\Print\\Printers");
    
    if (key)
    {
        VIRTUALVAL *val = key->AddValue(L"Default", REG_SZ, 0, 0);
        if (val)
        {
            val->pfnQueryValue = VR_Printer;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    The app is multi-threaded, but the app sets the DX DDSCL_MULTITHREADED flag 
    too late: after D3D is initialized. This hack basically turns on 
    multi-threaded locking for D3D.

 History:

    02/27/2001 rankala + ssteiner  Created

--*/

void
BuildStarTrekArmada(char* /*szParam*/)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\SOFTWARE\\Microsoft\\Direct3D");
    if (key)
    {
        key->AddValueDWORD(L"DisableST", 1);
    }
}

/*++

 Function Description:

    This function gets called whenever the app queries for "Health" value.This 
    is not set properly by the app and this causes the app not to function 
    properly. We fix this issue by obtaining the right path which the app sets 
    in another registry key and sending that back as the value for "Health".

 History:

    05/04/2001 prashkud  Created

--*/

LONG 
WINAPI
VR_MSA2001(
    OPENKEY * /* key */,
    VIRTUALKEY * /* vkey */,
    VIRTUALVAL *vvalue
    )
{
    HKEY hPath = NULL;
    LONG lRet = ERROR_SUCCESS;

    CSTRING_TRY
    {
        CString csBody5Reg(L"Software\\Classes\\Body5\\Open\\Shell\\Command");        
        WCHAR wPath[MAX_PATH];
        DWORD dwSize = MAX_PATH*sizeof(WCHAR);
            
        if (FAILURE(lRet = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    csBody5Reg.Get(),
                    0, KEY_READ, &hPath)))
        {
            DPFN(eDbgLevelError, "MSA2001: RegOpenKeyExW failed");
            goto exit;
        }

        if (FAILURE( lRet = RegQueryValueExW(
                hPath, L"",    // Default value
                0, NULL, (LPBYTE)wPath, &dwSize)))                          
        {
            DPFN(eDbgLevelError, "MSA2001: RegQueryValueEx failed");
            goto exit;
        }           

        CString csPath(wPath);
        int len = csPath.Find(L" ");

        // We get the space in the string
        wPath[len] = L'\0';
        csPath = wPath;
        CString csPathName;
        csPath.GetNotLastPathComponent(csPathName);

        vvalue->cbData = (csPathName.GetLength()+1) * sizeof(WCHAR);
        vvalue->lpData = (LPBYTE) malloc(vvalue->cbData);
 
        if (!vvalue->lpData)
        {
            DPFN(eDbgLevelError, szOutOfMemory);
            lRet = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        MoveMemory(vvalue->lpData, csPathName.Get(), vvalue->cbData);
        DPFN(eDbgLevelInfo, "MSA2001: The data value is %S",csPathName.Get());

        lRet = ERROR_SUCCESS;
        vvalue->dwType = REG_SZ;

        return lRet;        
    }
    CSTRING_CATCH
    {
    }

exit:
    if (hPath)
    {
        RegCloseKey(hPath);
    }

    return lRet;
}

/*++

 Function Description:


 History:

    04/27/2001 prashkud  Created

--*/

void
BuildMSA2001(char* /*szParam*/)
{
    VIRTUALKEY *Key = VRegistry.AddKey(L"HKLM\\Software\\Encore Software\\Middle School Advantage 2001\\1.0");

    if (Key)
    {
        VIRTUALVAL *val = Key->AddValue(L"health", REG_SZ, 0, 0);
        if (val) 
        {
            val->pfnQueryValue = VR_MSA2001;
            DPFN(eDbgLevelInfo, "[Middle School Advantage 2001]  Added Health");
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Hack for Nowro Blue (Korean App)

 History:

    05/17/2001 hioh Created

--*/

void BuildNowroBlue(char* /*szParam*/)
{
    // Below HKCU include location of files.
    // Non install user could not locate files and could not run app properly.
    // Redirect from HKCU to HKLM for commonly use.
    VRegistry.AddRedirect(
        L"HKCU\\Software\\nowcom",
        L"HKLM\\Software\\nowcom");
    VRegistry.AddRedirect(
        L"HKCU\\Software\\nowirc",
        L"HKLM\\Software\\nowirc");
    VRegistry.AddRedirect(
        L"HKCU\\Software\\nownuri",
        L"HKLM\\Software\\nownuri");
}


///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    To enable the trial version, WebWasher looks for RegisteredOrganization at:

      HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion

    rather than:

      HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion

 History:

    05/31/2001 stevepro Created

--*/

void
BuildRegisteredOwner(char* /*szParam*/)
{
    HKEY hkCurrentVersion;

    if (FAILURE(RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\Windows NT\\CurrentVersion",
            0,
            KEY_READ,
            &hkCurrentVersion)))
    {
        return;
    }

    // Read the registered owner values from the old location
    WCHAR szOrg[MAX_PATH];
    *szOrg = L'\0';
    DWORD dwSize = ARRAYSIZE(szOrg);
    if (FAILURE(RegQueryValueExW(
                        hkCurrentVersion,
                        L"RegisteredOrganization",
                        NULL,
                        NULL,
                        (LPBYTE)szOrg,
                        &dwSize)))
    {
       RegCloseKey(hkCurrentVersion);
       return;
    }

    WCHAR szOwner[MAX_PATH];
    *szOwner = L'\0';
    dwSize = ARRAYSIZE(szOwner);
    if (FAILURE(RegQueryValueExW(
       hkCurrentVersion,
       L"RegisteredOwner",
       NULL,
       NULL,
       (LPBYTE)szOwner,
       &dwSize)))
    {
       RegCloseKey(hkCurrentVersion);
       return;
    }

    RegCloseKey(hkCurrentVersion);

    // Add them as virtual values to the new location
    if (*szOrg || *szOwner)
    {
        VIRTUALKEY *pKey = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion");
        if (pKey)
        {
            if (*szOrg)
            {
                pKey->AddValue(L"RegisteredOrganization", REG_SZ, (LPBYTE)szOrg);
            }

            if (*szOwner)
            {
                pKey->AddValue(L"RegisteredOwner", REG_SZ, (LPBYTE)szOwner);
            }
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    The ACT CD of Princeton review looks for and, if not found, creates an "MSN"
    key illegally in the root of HKLM. Win9x allows this, but Win2k does not. 
    This fix will redirect the program to look in the normal location for this
    key.
    

 History:

    02/22/2001 a-noahy Created

--*/

void
BuildPrincetonACT(char* /*szParam*/)
{
    VRegistry.AddRedirect(
        L"HKLM\\MSN",
        L"HKLM\\Software\\Microsoft\\MSN");
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Fix for HEDZ which uses the registry to determine the resolution

 History:

    06/28/2001 linstev  Created

--*/

void
BuildHEDZ(char* /*szParam*/)
{
    VIRTUALKEY *key;

    //
    // Add just what this app needs - don't bother with full emulation of this 
    // part of the registry
    //
    key = VRegistry.AddKey(L"HKLM\\Config\\0001\\Display\\Settings");
    if (key)
    {
        WCHAR wzRes[10];
        DWORD dwCX, dwCY;
        key->AddValue(L"BitsPerPixel", REG_SZ, (LPBYTE)L"16");
        dwCX = GetSystemMetrics(SM_CXSCREEN);
        dwCY = GetSystemMetrics(SM_CYSCREEN);
        if (FAILED(StringCchPrintfW(
                                 wzRes, 10, L"%d,%d", dwCX, dwCY)))
        {
           return;
        }

        key->AddValue(L"Resolution", REG_SZ, (LPBYTE)wzRes);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Called by BuildAirlineTycoon to recursively search for the key describing a CDROM

 History:

    08/07/2001 mikrause  Created

--*/

void FindCDROMKey(HKEY hKey, CString& csCurrentPath)
{   
    LONG lRet;
    DWORD dwKeyNameSize = MAX_PATH;
    WCHAR wszKeyName[MAX_PATH];
    HKEY hSubKey;
    DWORD dwIndex = 0;

    // Recurse into all subkeys.
    while( ORIGINAL_API(RegEnumKeyExW)(hKey, dwIndex, wszKeyName, &dwKeyNameSize,
        NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
    {
        lRet = ORIGINAL_API(RegOpenKeyExW)(hKey, wszKeyName, 0, KEY_READ, &hSubKey);
        if (lRet == ERROR_SUCCESS)
        {
            // Add this key to the path
            csCurrentPath += L"\\";
            csCurrentPath += wszKeyName;

            // Check this key's subkeys.                        
            FindCDROMKey(hSubKey, csCurrentPath);
            ORIGINAL_API(RegCloseKey)(hSubKey);

            // Trim the path back.
            int index = csCurrentPath.ReverseFind(L'\\');
            csCurrentPath.Truncate(index);
        }

        dwKeyNameSize = MAX_PATH;
        dwIndex++;
    }

    // Check if this key has a Class value equal to "cdrom"

    DWORD dwDataSize;
    BYTE pData[MAX_PATH*sizeof(WCHAR)];

    DWORD dwType;

    dwDataSize = MAX_PATH * sizeof(WCHAR);

    lRet = ORIGINAL_API(RegQueryValueExW)(hKey, L"CLASS", NULL, &dwType, pData,
        &dwDataSize);
    if ( (lRet == ERROR_SUCCESS) && (dwType == REG_SZ)
        && (_wcsicmp((LPWSTR)pData, L"CDROM")==0))
    {                         
        // Get location information on the device
        WCHAR wszLocationInformation[MAX_PATH];
        DWORD dwLocInfoSize = MAX_PATH * sizeof(WCHAR);
        
        lRet = ORIGINAL_API(RegQueryValueExW)(hKey, L"LocationInformation",
            NULL, &dwType, (BYTE*)wszLocationInformation, &dwLocInfoSize);
        if ( (lRet == ERROR_SUCCESS) && (dwType == REG_SZ))
        {
            // Create the device name (like "\\?\cdrom0\".
            CString csDevice = L"\\\\?\\cdrom";
            csDevice += wszLocationInformation;
            csDevice += L"\\";

            // Find which volume name this is mapped to.
            WCHAR wszCDRomMountPoint[50];
            if (GetVolumeNameForVolumeMountPoint(csDevice.Get(),
                wszCDRomMountPoint, 50))
            {
                // Find which drive this is mapped to.
                WCHAR wszDriveMountPoint[50];
                WCHAR wszDrive[] = L"A:\\";
                
                // Find what drive has an identical volume mount point.
                for(; wszDrive[0] <= L'Z'; wszDrive[0]++)
                {                    
                    if (GetVolumeNameForVolumeMountPoint(wszDrive,
                        wszDriveMountPoint, 50))
                    {
                        // Check if the CD-ROM and this disk drive
                        // map to the same volume.
                        if (_wcsicmp(wszDriveMountPoint, wszCDRomMountPoint)==0)
                        {
                            // Add a value to the CD-ROM key.
                            VIRTUALKEY* key = VRegistry.AddKey(csCurrentPath);
                            if (key)
                            {
                                // Only use a single letter.
                                wszDrive[1] = L'\0';
                                VIRTUALVAL* val =
                                    key->AddValue(L"CurrentDriveLetterAssignment",
                                        REG_SZ, (BYTE*) wszDrive, sizeof(WCHAR));
                                if (val)
                                {
                                    DPFN(eDbgLevelInfo,
                                        "[Airline Tycoon]Added drive letter \
                                        %S for %S to PNP data", wszDrive,
                                        csDevice.Get());
                                }
                            }
                            break;
                        }
                    }        
                }
            }
        }                
    }    
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Fix for Airline Tycoon which uses PNP registry entries to determine the
    drive letter assignments for CD-ROM drives.

 History:

    08/07/2001 mikrause  Created

--*/

void
BuildAirlineTycoon(char* /*szParam*/)
{    
    // Search for CD-ROM keys in the registry.
    HKEY hKey;
    LONG lRet;
    lRet = ORIGINAL_API(RegOpenKeyExW)(HKEY_LOCAL_MACHINE,
        L"System\\CurrentControlSet\\Enum", 0, KEY_READ, &hKey);
    if (lRet != ERROR_SUCCESS)
    {
        DPFN(eDbgLevelError, "[AirlineTycoon] Cannot open ENUM key!");
        return;
    }

    // Enumerate subkeys
    CString csBasePath = L"HKLM\\System\\CurrentControlSet\\Enum";
    FindCDROMKey(hKey, csBasePath);

    ORIGINAL_API(RegCloseKey)(hKey);

    // Set up so that PNP data is redirected.
    BuildDynData("");
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

   Sets the DirectSound acceleration level the app will be allowed to use.

 Arguments:

    szParam - Command line of the form: accellevel | device1 | device2 | ...
              Accellevel is the device acceleration level, and devices 1 through n
              are the devices to apply to.
              Accellevel can be: NONE, STANDARD, or FULL
              Devices can be: EMULATEDRENDER, KSRENDER, EMULATEDCAPTURE, KSCAPTURE 

 History:

    08/10/2001 mikrause  Created

--*/

void
BuildDSDevAccel(
    char* szParam)
{
    // No Try/Catch needed, already in ParseCommandLine
    CStringToken csParam(szParam, "|");
    CString csTok;

    DWORD dwAccelLevel;
    DWORD dwDevices = 0;

    if (csParam.GetToken(csTok))
    {
        if (csTok.CompareNoCase(L"NONE")==0)
        {
            dwAccelLevel = DSAPPHACK_ACCELNONE;
        }
        else if (csTok.CompareNoCase(L"STANDARD")==0)
        {
            dwAccelLevel = DSAPPHACK_ACCELSTANDARD;
        }
        else if (csTok.CompareNoCase(L"FULL")==0)
        {
            dwAccelLevel = DSAPPHACK_ACCELFULL;
        }
        else
        {
            DPFN(eDbgLevelError, "[DSDEVACCEL] Invalid Acceleration Level %s", csTok.GetAnsi());
            return;
        }
    }
    else
    {
        DPFN(eDbgLevelError, "[DSDEVACCEL] Invalid Parameters");
        return;
    }

    while (csParam.GetToken(csTok))
    {
        if (csTok.CompareNoCase(L"EMULATEDRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDRENDER;
        }
        else if (csTok.CompareNoCase(L"KSRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSRENDER;
        }
        else if (csTok.CompareNoCase(L"EMULATEDCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDCAPTURE;
        }
        else if (csTok.CompareNoCase(L"KSCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSCAPTURE;
        }
        else
        {
            DPFN(eDbgLevelError, "[DSDEVACCEL] Unknown device %s", csTok.GetAnsi());
        }
    }

    if (dwDevices == 0)
    {
        DPFN(eDbgLevelError, "[DSDEVACCEL] No devices specified.");
        return;
    }

    if (AddDSHackDeviceAcceleration(dwAccelLevel, dwDevices) == FALSE)
    {
        DPFN(eDbgLevelError, "[DSDEVACCEL] Unabled to add DirectSound hack");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Makes IDirectSoundBuffer::GetCurrentPosition() tell the app
    that the play and write cursors are X milliseconds further
    along than they really are.
 
 Arguments:

    szParam - Command line of the form: milliseconds
              Where milliseconds is the number of milliseconds to pad the cursors.

 History:

    08/10/2001 mikrause  Created

--*/

void
BuildDSPadCursors(
    char* szParam)
{
    // No Try/Catch needed, already in ParseCommandLine
    CString csParam(szParam);
    DWORD dwMilliseconds = 0;

    dwMilliseconds = atol(csParam.GetAnsi());
    if ( dwMilliseconds == 0)
    {
        DPFN(eDbgLevelWarning, "[DSPADCURSORS] Invalid number of milliseconds");
        return;
    }

    if (AddDSHackPadCursors(dwMilliseconds) == FALSE)
    {
        DPFN(eDbgLevelError, "[DSPADCURSORS] Unabled to add DirectSound hack");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Caches the positions of the cursors for apps that abuse
    IDirectSoundBuffer::GetCurrentPosition().

 Arguments:
    szParam - Command line of the form: Dev1 | Dev2 | . . .
              Devices affected.  See BuildDSDevAccel().

 History:

    08/10/2001 mikrause  Created

--*/

void
BuildDSCachePositions(
    char* szParam)
{
    // No Try/Catch needed, already in ParseCommandLine
    CStringToken csParam(szParam, "|");
    CString csTok;
   
    DWORD dwDevices = 0;

    while (csParam.GetToken(csTok))
    {
        if (csTok.CompareNoCase(L"EMULATEDRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDRENDER;
        }
        else if (csTok.CompareNoCase(L"KSRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSRENDER;
        }
        else if (csTok.CompareNoCase(L"EMULATEDCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDCAPTURE;
        }
        else if (csTok.CompareNoCase(L"KSCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSCAPTURE;
        }
        else
        {
            DPFN(eDbgLevelError, "[DSCACHEPOSITIONS] Unknown device %s", csTok.GetAnsi());
        }
    }

    if (dwDevices == 0)
    {
        DPFN(eDbgLevelError, "[DSCACHEPOSITIONS] No devices specified.");
        return;
    }

    if (AddDSHackCachePositions(dwDevices) == FALSE)
    {
        DPFN(eDbgLevelError, "[DSCACHEPOSITIONS] Unabled to add DirectSound hack");
    }
}

/*++

 Function Description:

    When the app asks for the play cursor, we give it the
    write cursor instead.  The correct way to stream audio
    into a looping dsound buffer is to key off the write cursor,
    but some apps (e.g. QuickTime) use the play cursor instead.
    This apphacks alleviates them.
 
 Arguments:

    szParam - Parameters of the form dev1 | dev2 | . . . 
    See BuildDSDevAccel() for valid devices.

 History:

    08/10/2001 mikrause  Created

--*/
void
BuildDSReturnWritePos(
    char* szParam)
{
    // No Try/Catch needed, already in ParseCommandLine
    CStringToken csParam(szParam, "|");
    CString csTok;
   
    DWORD dwDevices = 0;

    while (csParam.GetToken(csTok))
    {
        if (csTok.CompareNoCase(L"EMULATEDRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDRENDER;
        }
        else if (csTok.CompareNoCase(L"KSRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSRENDER;
        }
        else if (csTok.CompareNoCase(L"EMULATEDCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDCAPTURE;
        }
        else if (csTok.CompareNoCase(L"KSCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSCAPTURE;
        }
        else
        {
            DPFN(eDbgLevelError, "[DSRETURNWRITEPOSITION] Unknown device %s", csTok.GetAnsi());
        }
    }

    if (dwDevices == 0)
    {
        DPFN(eDbgLevelError, "[DSRETURNWRITEPOSITION] No devices specified.");
        return;
    }

    if (AddDSHackReturnWritePos(dwDevices) == FALSE)
    {
        DPFN(eDbgLevelError, "[DSRETURNWRITEPOSITION] Unabled to add DirectSound hack");
    }
}

/*++

 Function Description:

    Makes dsound always return a write position which is X
    milliseconds ahead of the play position, rather than
    the real write position. 
 
 Arguments:

    szParam - Milliseconds of padding.

 History:

    08/10/2001 mikrause  Created

--*/


void
BuildDSSmoothWritePos(
    char* szParam)
{
    // No Try/Catch needed, already in ParseCommandLine
    CString csParam(szParam);
    DWORD dwMilliseconds = 0;

    dwMilliseconds = atol(csParam.GetAnsi());
    if ( dwMilliseconds == 0)
    {
        DPFN(eDbgLevelWarning, "[DSSMOOTHWRITEPOS] Invalid number of milliseconds");
        return;
    }

    if (AddDSHackSmoothWritePos(dwMilliseconds) == FALSE)
    {
        DPFN(eDbgLevelError, "[DSSMOOTHWRITEPOS] Unabled to add DirectSound hack");
    }
    else
    {
        DPFN(eDbgLevelInfo, "[DSSMOOTHWRITEPOS] Added DS Hack Smooth Write Pos, %d ms",
            dwMilliseconds);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

     NortonAntiVirus trys to set the registry value to hide the language bar.
     Protecting the registry value.

 History:

    01/02/2002 mamathas Created

--*/

void BuildNortonAntiVirus(char* /*szParam*/)
{    
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKCU\\Software\\Microsoft\\CTF\\LangBar");
    if (key)
    {
        // Block all writes to ShowStatus
        key->AddProtector(L"ShowStatus");
    }
}


///////////////////////////////////////////////////////////////////////////////

/*++

 Function Description:

    Disabled some category of devices altogether, forces
    playback through emulated path.
 
 Arguments:

    szParam - Combination of device that this hack applies to, see BuildDSDevAccel().

 History:

    08/10/2001 mikrause  Created

--*/

void
BuildDSDisableDevice(
    char* szParam)
{
    // No try/catch needed.  Already done in ParseCommandLine
    CStringToken csParam(szParam, "|");
    CString csTok;
   
    DWORD dwDevices = 0;

    while (csParam.GetToken(csTok)==TRUE)
    {
        if (csTok.CompareNoCase(L"EMULATEDRENDER"))
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDRENDER;
        }
        else if (csTok.CompareNoCase(L"KSRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSRENDER;
        }
        else if (csTok.CompareNoCase(L"EMULATEDCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDCAPTURE;
        }
        else if (csTok.CompareNoCase(L"KSCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSCAPTURE;
        }
        else
        {
            DPFN(eDbgLevelError, "[DSDISABLEDEVICE] Unknown device %s", csTok.GetAnsi());
        }
    }

    if (dwDevices == 0)
    {
        DPFN(eDbgLevelError, "[DSDISABLEDEVICE] No devices specified.");
        return;
    }

    if (AddDSHackDisableDevice(dwDevices) == FALSE)
    {
        DPFN(eDbgLevelError, "[DSRETURNWRITEPOSITION] Unabled to add DirectSound hack");
    }
}

LONG WINAPI 
Delphi5SetValue(
    OPENKEY *key,
    VIRTUALKEY * /* vkey */,
    VIRTUALVAL *vvalue,
    DWORD dwType,
    const BYTE* pbData,
    DWORD cbData)
{
    // Only accept attempts to set a valid REG_SZ value.
    if (dwType == REG_SZ && !IsBadStringPtrW((PWSTR)pbData, cbData/sizeof(WCHAR)))
    {
       CSTRING_TRY
       {    
          CString csValue = (PWSTR)pbData;
      
          int idx = csValue.Find(L"InstReg.exe");
          
          if (idx != -1)
          {             
             csValue.Insert(idx + lstrlenW(L"InstReg.exe"), L'\"');
             csValue.Insert(0, L'\"');
         
             return RegSetValueExW(key->hkOpen, vvalue->wName, 0, dwType, (BYTE*)csValue.Get(), 
                 (csValue.GetLength()+1)*sizeof(WCHAR));
          }
       }
       CSTRING_CATCH
       {
          DPFN(eDbgLevelError, "CString exception occured in Delphi5SetValue");
       }
    }              

    // Got here, something went wrong.  Default o normal RegSetValue
    return RegSetValueExW(key->hkOpen, vvalue->wName, 0, dwType, pbData, cbData);    
}

void
BuildDelphi5Pro(
    char* /* szParam */)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
    if (key)
    {
        key->AddCustomSet(L"BorlandReboot1", Delphi5SetValue);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

     Word Perfect Office Suite 2002 attempts to delete ODBC key during uninstall.
     Protecting the registry value.

 History:

    04/23/2002 garyma  Created

--*/

void BuildWordPerfect2002(char* /*szParam*/)
{    
    VRegistry.AddKeyProtector(L"HKLM\\Software\\ODBC");
}


///////////////////////////////////////////////////////////////////////////////



IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\vregistry_worker.h ===
#pragma once

#ifndef _WORKER_H_
#define _WORKER_H_

LONG 
WINAPI
VR_Expand(
    OPENKEY *key,
    VIRTUALKEY *vkey,
    VIRTUALVAL *vvalue
    );

LONG
WINAPI
VR_Protect(
    OPENKEY *key,
    VIRTUALKEY *vkey,
    VIRTUALVAL *vvalue,
    DWORD dwType,
    const BYTE* pbData,
    DWORD cbData
    );

#endif //_WORKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\vregistry.h ===
#ifndef _VREGISTRY_H_
#define _VREGISTRY_H_

#include "StrSafe.h"
#include "precomp.h"

#define SUCCESS(x) ((x) == ERROR_SUCCESS)
#define FAILURE(x) (!SUCCESS(x))
#define szOutOfMemory "ERROR OUT OF MEMORY"

struct VIRTUALKEY;
struct VIRTUALVAL;
struct ENUMENTRY;
struct OPENKEY;

//
// Callback for QueryValue
//

typedef LONG (WINAPI *_pfn_QueryValue)(
    OPENKEY *key,
    VIRTUALKEY *vkey,
    VIRTUALVAL *vvalue);

//
// Callback for SetValue
//
typedef LONG (WINAPI *_pfn_SetValue)(
    OPENKEY *key,
    VIRTUALKEY *vkey,
    VIRTUALVAL *vvalue,
    DWORD dwType,
    const BYTE* pbData,
    DWORD cbData);

//
// Callback for OpenKey, called before virtual keys are searched.
//
typedef LONG (WINAPI *_pfn_OpenKeyTrigger)(WCHAR* wszKey);

//
// A generic prototype for RegEnumValue and RegEnumKeyEx.
// This is used to simplify the enumeration code.
// When using this function pointer, the last four parameters
// must be NULL.
//
typedef LONG (WINAPI *_pfn_EnumFunction)(HKEY hKey, DWORD dwIndex, LPWSTR lpName,
                                         LPDWORD lpcName, void*, void*, void*, void*);
//
// Redirector: maps a key from one location to another
//

struct REDIRECTOR
{
    REDIRECTOR *next;

    LPWSTR wzPath;
    LPWSTR wzPathNew;
};

//
// Protector: Prevents the key in the path from being deleted or modified.
//

struct PROTECTOR
{
    PROTECTOR *next;

    LPWSTR wzPath;
};

//
// Open registry key as opened with RegCreateKey/Ex or RegOpenKey/Ex
//

struct OPENKEY
{
    OPENKEY *next;
    
    HKEY hkOpen;
    BOOL bVirtual;
    BOOL bRedirected;
    VIRTUALKEY *vkey;
    LPWSTR wzPath;

    ENUMENTRY* enumKeys;
    ENUMENTRY* enumValues;

    template<class T>
    ENUMENTRY* AddEnumEntries(T* entryHead, _pfn_EnumFunction enumFunc);

    VOID BuildEnumList();
    VOID FlushEnumList();
};

//
// Virtual value: holds virtual registry value, owned by VIRTUALKEY
//

struct VIRTUALVAL
{
    VIRTUALVAL *next;

    WCHAR wName[MAX_PATH];
    DWORD dwType;
    BYTE *lpData;
    DWORD cbData;
    _pfn_QueryValue pfnQueryValue;
    _pfn_SetValue   pfnSetValue;
};

//
// Virtual key: holds virtual key and values, owned by other virtualkeys
//

struct VIRTUALKEY
{
    VIRTUALKEY *next;
    VIRTUALKEY *keys;
    VIRTUALVAL *values;

    WCHAR wName[MAX_PATH];

    VIRTUALKEY *AddKey(
        LPCWSTR lpPath
        );

    VIRTUALVAL *AddValue(
        LPCWSTR lpValueName, 
        DWORD dwType, 
        BYTE *lpData, 
        DWORD cbData = 0
        );

    VIRTUALVAL *AddValueDWORD(
        LPCWSTR lpValueName, 
        DWORD dwValue
        );

    VIRTUALVAL *AddExpander(LPCWSTR lpValueName);
    VIRTUALVAL *AddProtector(LPCWSTR lpValueName);

    VIRTUALVAL *AddCustom(
        LPCWSTR lpValueName,         
        _pfn_QueryValue pfnQueryValue
        );

    VIRTUALVAL *AddCustomSet(
        LPCWSTR lpValueName,
        _pfn_SetValue pfnSetValue
        );

    VIRTUALKEY *FindKey(LPCWSTR lpKeyName);

    VIRTUALVAL *FindValue(
        LPCWSTR lpValueName
        );

    VOID Free();
};

//
// Enum entry: An entry in a list of all enumerated items belonging to a key.
//
struct ENUMENTRY
{
    ENUMENTRY* next;

    LPWSTR wzName;
};

//
// Open Key Trigger: Describes a function to be called when a key is opened.
//
struct OPENKEYTRIGGER
{
    OPENKEYTRIGGER* next;

    LPWSTR wzPath;

    _pfn_OpenKeyTrigger pfnTrigger;
};

// Class to wrap the virtual registry functionality
class CVirtualRegistry
{
private:
    OPENKEY *OpenKeys;
    VIRTUALKEY *Root;
    REDIRECTOR *Redirectors;
    PROTECTOR  *KeyProtectors;
    OPENKEYTRIGGER *OpenKeyTriggers;
    
    HKEY CreateDummyKey();

    OPENKEY *FindOpenKey(HKEY hKey);

    BOOL CheckRedirect(
        LPWSTR *lpPath
        );

    BOOL CheckProtected(
        LPWSTR lpPath
        );
    
    VOID CheckTriggers(
        LPWSTR lpPath
        );

    VOID FlushEnumLists();

public:
    BOOL Init();
    VOID Free();
    
    REDIRECTOR *AddRedirect(
        LPCWSTR lpPath, 
        LPCWSTR lpPathNew);

    PROTECTOR *AddKeyProtector(
        LPCWSTR lpPath);

    OPENKEYTRIGGER* AddOpenKeyTrigger(
        LPCWSTR lpPath,
        _pfn_OpenKeyTrigger pfnOpenKey);

    VIRTUALKEY *AddKey(LPCWSTR lpPath);

    LONG OpenKeyA(
        HKEY hKey, 
        LPCSTR lpSubKey,
        LPSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES pSecurityAttributes,
        HKEY *phkResult,
        LPDWORD lpdwDisposition,
        BOOL bCreate
        );

    LONG OpenKeyW(
        HKEY hKey, 
        LPCWSTR lpSubKey, 
        LPWSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES pSecurityAttributes,
        HKEY *phkResult,
        LPDWORD lpdwDisposition,
        BOOL bCreate,
        BOOL bRemote = FALSE,
        LPCWSTR lpMachineName = NULL
        );

    LONG QueryValueA(
        HKEY hKey, 
        LPSTR lpValueName, 
        LPDWORD lpType, 
        LPBYTE lpData, 
        LPDWORD lpcbData
        );

    LONG QueryValueW(
        HKEY hKey, 
        LPWSTR lpValueName, 
        LPDWORD lpType, 
        LPBYTE lpData, 
        LPDWORD lpcbData
        );

    LONG EnumKeyA(
        HKEY hKey,          
        DWORD dwIndex,      
        LPSTR lpName,      
        LPDWORD lpcbName
        );

    LONG EnumKeyW(
        HKEY hKey,          
        DWORD dwIndex,      
        LPWSTR lpName,      
        LPDWORD lpcbName
        );

    LONG EnumValueA(
        HKEY hKey,          
        DWORD dwIndex,      
        LPSTR lpValueName,      
        LPDWORD lpcbValueName,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData
        );

    LONG EnumValueW(
        HKEY hKey,          
        DWORD dwIndex,      
        LPWSTR lpValueName,      
        LPDWORD lpcbValueName,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData
        );

    LONG QueryInfoA(
        HKEY hKey,                
        LPSTR lpClass,           
        LPDWORD lpcbClass,        
        LPDWORD lpReserved,       
        LPDWORD lpcSubKeys,       
        LPDWORD lpcbMaxSubKeyLen, 
        LPDWORD lpcbMaxClassLen,  
        LPDWORD lpcValues,        
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,  
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime   
        );

    LONG QueryInfoW(
        HKEY hKey,                
        LPWSTR lpClass,           
        LPDWORD lpcbClass,        
        LPDWORD lpReserved,       
        LPDWORD lpcSubKeys,       
        LPDWORD lpcbMaxSubKeyLen, 
        LPDWORD lpcbMaxClassLen,  
        LPDWORD lpcValues,        
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,  
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime   
        );

    LONG SetValueA(
        HKEY hKey,
        LPCSTR lpValueName,
        DWORD dwType,
        CONST BYTE* lpData,
        DWORD cbData
        );

    LONG SetValueW(
        HKEY hKey,
        LPCWSTR lpValueName,
        DWORD dwType,
        CONST BYTE* lpData,
        DWORD cbData
        );

    LONG DeleteKeyA(
        HKEY hKey,
        LPCSTR lpSubKey
        );

    LONG DeleteKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey
        );

    LONG CloseKey(HKEY hKey);
};

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(RegConnectRegistryA)
    APIHOOK_ENUM_ENTRY(RegConnectRegistryW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExW)
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)
    APIHOOK_ENUM_ENTRY(RegCloseKey)
    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegQueryValueA)
    APIHOOK_ENUM_ENTRY(RegQueryValueW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExW)
    APIHOOK_ENUM_ENTRY(RegEnumValueA)
    APIHOOK_ENUM_ENTRY(RegEnumValueW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExW)
    APIHOOK_ENUM_ENTRY(RegQueryInfoKeyA)
    APIHOOK_ENUM_ENTRY(RegQueryInfoKeyW)
    APIHOOK_ENUM_ENTRY(RegSetValueExA)
    APIHOOK_ENUM_ENTRY(RegSetValueExW)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyA)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyW)

APIHOOK_ENUM_END

extern CVirtualRegistry VRegistry;
extern LPWSTR MakePath(HKEY hkBase, LPCWSTR lpKey, LPCWSTR lpSubKey);
extern LPWSTR SplitPath(LPCWSTR lpPath, HKEY *hkBase);

// Type for the functions that build the keys
typedef VOID (*_pfn_Builder)(char* szParam);

enum PURPOSE {eWin9x, eWinNT, eWin2K, eWinXP, eCustom};

// Entry in the table of custom registry settings
struct VENTRY
{
    WCHAR cName[64];
    _pfn_Builder pfnBuilder;
    PURPOSE ePurpose;

    // Indicates if this entry should be called as part of VRegistry initialization
    BOOL bShouldCall;

    // Parameter
    char* szParam;
};

extern VENTRY *g_pVList;

#endif //_VREGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\vregistry_worker.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Worker.cpp

 Abstract:

    These are the worker functions for virtual registry. They are called 
    whenever a non-static value is queried. 

 Notes:
    

 History:

    07/18/2000 linstev  Created
    10/11/2001 mikrause Added protectors.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(VirtualRegistry)
#include "ShimHookMacro.h"
#include "VRegistry.h"
#include "VRegistry_Worker.h"

/*++

 Expand REG_EXPAND_SZ for this value

--*/

LONG 
WINAPI
VR_Expand(
    OPENKEY *key,
    VIRTUALKEY*,
    VIRTUALVAL *vvalue
    )
{
    DWORD dwType;
    WCHAR wSrc[MAX_PATH];
    DWORD dwSize = sizeof(wSrc);

    //
    // Query the original value
    //

    LONG lRet = ORIGINAL_API(RegQueryValueExW)(
        key->hkOpen, 
        vvalue->wName, 
        NULL, 
        &dwType, 
        (LPBYTE)wSrc, 
        &dwSize);
    
    //
    // Query failed - this should never happen 
    //

    if (FAILURE(lRet))
    {
        DPFN( eDbgLevelError, "Failed to query %S for expansion", vvalue->wName);
        goto Exit;
    }

    //
    // Not a string type!
    //

    if (!((dwType == REG_EXPAND_SZ) || (dwType == REG_SZ)) && 
        (dwSize > sizeof(wSrc)))
    {
        DPFN( eDbgLevelError, "Expander: Not a string type");
        lRet = ERROR_BAD_ARGUMENTS;
        goto Exit;
    }

    //
    // Expand the string and store it in the value
    //

    vvalue->cbData = ExpandEnvironmentStringsW(wSrc, NULL, 0) * 2;   

    if (vvalue->cbData == 0)
    {
       lRet = ERROR_BAD_ARGUMENTS;
       goto Exit;
    }

    vvalue->lpData = (LPBYTE) malloc(vvalue->cbData);
    if (!vvalue->lpData)
    {
       DPFN( eDbgLevelError, szOutOfMemory);
       lRet = ERROR_NOT_ENOUGH_MEMORY;
       goto Exit;
    }

    if (ExpandEnvironmentStringsW(wSrc, (PWSTR)vvalue->lpData, vvalue->cbData / 2) != vvalue->cbData / sizeof(WCHAR))
    {
       lRet = ERROR_NOT_ENOUGH_MEMORY;
       goto Exit;
    }

    //
    // Value is now cached, so we don't need to get called again
    //

    vvalue->pfnQueryValue = NULL;

    lRet = ERROR_SUCCESS;

    DPFN( eDbgLevelInfo, "Expanded Value=%S\n", vvalue->lpData);

Exit:
    return lRet;
}

/*++

 Do nothing, the SetValue is ignored.

--*/

LONG
WINAPI
VR_Protect(
    OPENKEY*,
    VIRTUALKEY*,
    VIRTUALVAL*,
    DWORD,
    const BYTE*,
    DWORD)
{
    return ERROR_SUCCESS;
}

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\win2000versionlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Win2000VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 2000
   version credentials.

 Notes:

   This is a general purpose shim.

 History:

   03/13/2000 clupu  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Win2000VersionLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetVersionExW)
    APIHOOK_ENUM_ENTRY(GetVersion)
APIHOOK_ENUM_END


/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials.

--*/

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExA] called. return Win2k.");

        //
        // Fixup the structure with the Win2k data.
        //
        lpVersionInformation->dwMajorVersion = 5;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber  = 2195;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        *lpVersionInformation->szCSDVersion  = '\0';

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials. This is the
 wide-character version of GetVersionExW.

--*/

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExW] called. return Win2k.");

        //
        // Fixup the structure with the Win2k data.
        //
        lpVersionInformation->dwMajorVersion = 5;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber  = 2195;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        *lpVersionInformation->szCSDVersion  = L'\0';

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function returns Windows 95 credentials.

--*/

DWORD
APIHOOK(GetVersion)(
    void
    )
{
    LOGN(
        eDbgLevelInfo,
        "[GetVersion] called. return Win2k.");
    
    return (DWORD)0x08930005;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\win2kpropagatelayer_cleanup.cpp ===
#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(Win2kPropagateLayer)
#include "ShimHookMacro.h"

#include <stdarg.h>
#include <string.h>
#include <stdio.h>

#define APPCOMPAT_KEYW L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility"

BOOL
CleanupRegistryForCurrentExe(
    void
    )
{
    NTSTATUS          status;
    OBJECT_ATTRIBUTES objA;
    HANDLE            hkey;
    WCHAR             wszExeName[MAX_PATH];
    WCHAR             wszKey[MAX_PATH];
    UNICODE_STRING    strKey;
    UNICODE_STRING    strValue;

    DWORD dwChars = GetModuleFileNameW(NULL, wszExeName, MAX_PATH);
     
    if (dwChars == 0) {
        return FALSE;
    }
    
    WCHAR* pwsz = wszExeName + dwChars;

    while (pwsz >= wszExeName) {

        if (*pwsz == '\\') {
            break;
        }
        pwsz--;
    }

    pwsz++;

    LOGN(
        eDbgLevelInfo,
        "[CleanupRegistryForCurrentExe] Cleanup for \"%S\"",
        pwsz);
    
    swprintf(wszKey, L"%s\\%s", APPCOMPAT_KEYW, pwsz);

    RtlInitUnicodeString(&strKey, wszKey);
    
    InitializeObjectAttributes(&objA,
                               &strKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    
    status = NtOpenKey(&hkey,
                       MAXIMUM_ALLOWED,
                       &objA);

    if (!NT_SUCCESS(status)) {
        LOGN(
            eDbgLevelError,
            "[CleanupRegistryForCurrentExe] Failed to open key \"%S\"",
            wszKey);
        return TRUE;
    }
    
    RtlInitUnicodeString(&strValue, L"DllPatch-y");
    NtDeleteValueKey(hkey, &strValue);

    RtlInitUnicodeString(&strValue, L"y");
    NtDeleteValueKey(hkey, &strValue);

    //
    // Now check to see if there are any more values under this key.
    // Delete it if there are no more values.
    //
    
    KEY_FULL_INFORMATION keyInfo;
    DWORD                dwReturnLength = 0;
    
    status = NtQueryKey(hkey,
                        KeyFullInformation,
                        &keyInfo,
                        sizeof(keyInfo),
                        &dwReturnLength);

    if (NT_SUCCESS(status) && keyInfo.Values == 0) {
        NtDeleteKey(hkey);
    }

    NtClose(hkey);

    return TRUE;
}

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\win2000sp1versionlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Win2000SP1VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 2000 SP1
   version credentials.

 Notes:

   This is a general purpose shim.

 History:

   04/25/2000 prashkud  Created

--*/

#include "precomp.h"

//This module has been given an official blessing to use the str routines
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(Win2000SP1VersionLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetVersionExW)
    APIHOOK_ENUM_ENTRY(GetVersion)
APIHOOK_ENUM_END


/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 2000 SP1 credentials.

--*/

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExA] called. return Win2k SP1");

        //
        // Fixup the structure with the Win2k data.
        //
        lpVersionInformation->dwMajorVersion = 5;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber  = 2195;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;        
        strcpy(lpVersionInformation->szCSDVersion, "Service Pack 1");

        if (lpVersionInformation->dwOSVersionInfoSize == sizeof(OSVERSIONINFOEXA))
        {
            // We are here as we are passed a OSVERSIONINFOEX structure.
            // Set the major and minor service pack numbers.
            ((LPOSVERSIONINFOEXA)lpVersionInformation)->wServicePackMajor = 1;
            ((LPOSVERSIONINFOEXA)lpVersionInformation)->wServicePackMinor = 0;

        }

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials. This is the
 wide-character version of GetVersionExW.

--*/

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExW] called. return Win2k SP1");

        //
        // Fixup the structure with the Win2k data.
        //
        lpVersionInformation->dwMajorVersion = 5;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber  = 2195;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        wcscpy(lpVersionInformation->szCSDVersion, L"Service Pack 1");

        if (lpVersionInformation->dwOSVersionInfoSize == sizeof(OSVERSIONINFOEXW))
        {
            // We are here as we are passed a OSVERSIONINFOEX structure.
            // Set the major and minor service pack numbers.
            ((LPOSVERSIONINFOEXW)lpVersionInformation)->wServicePackMajor = 1;
            ((LPOSVERSIONINFOEXW)lpVersionInformation)->wServicePackMinor = 0;

        }

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function returns Windows 95 credentials.

--*/

DWORD
APIHOOK(GetVersion)(
    void
    )
{
    LOGN(
        eDbgLevelInfo,
        "[GetVersion] called. return Win2k SP1");
    
    return (DWORD)0x08930005;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\win2kpropagatelayer.h ===
#ifndef _WIN2KPROPAGATELAYER_H
#define _WIN2KPROPAGATELAYER_H


#ifdef __cplusplus
extern "C" {
#endif

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "zwapi.h"

#ifdef __cplusplus
}
#endif

#define SHIM_LIB_BUILD_FLAG
#include "vdmdbg.h"
#include "stddef.h"


#ifdef __cplusplus
extern "C" {
#endif

#include "wownt32.h"


#ifdef __cplusplus
}
#endif

//
// WINUSERP defines TAG type which conflicts
// with the definition available in shimdb.h
// we define it inside the separate namespace
// avoiding any conflicts
//

namespace NSWOWUSERP {

#ifdef __cplusplus
extern "C" {
#endif

#include "winuserp.h"
#include "wowuserp2k.h"

#ifdef __cplusplus
}
#endif

}

typedef ULONG_PTR (WINAPI *_pfn_UserRegisterWowHandlers)(NSWOWUSERP::APFNWOWHANDLERSIN apfnWowIn,
                                                         NSWOWUSERP::APFNWOWHANDLERSOUT apfnWowOut);


/////////////////////////////////////////////////////////////////////////////
//
// 16-bit TDB structure, stolen from base\mvdm\inc\tdb16.h
// Keep this in-sync
//


/*
 * Task Data Block - 16 Bit Kernel Data Structure
 *
 *   Contains all 16 bit task specific data.
 *
 */

#define numTaskInts 7
#define THUNKELEM   8   // (62*8) = 512-16 (low arena overhead)
#define THUNKSIZE   8



#pragma pack(2)

typedef struct TDB  {       /* tdb16 */

     WORD TDB_next    ;     // next task in dispatch queue
     WORD TDB_taskSP      ;     // Saved SS:SP for this task
     WORD TDB_taskSS      ;     //
     WORD TDB_nEvents     ;     // Task event counter
     BYTE TDB_priority    ;     // Task priority (0 is highest)
     BYTE TDB_thread_ordinal  ;     // ordinal number of this thread
     WORD TDB_thread_next   ;       // next thread
     WORD TDB_thread_tdb      ; // the real TDB for this task
     WORD TDB_thread_list   ;       // list of allocated thread structures
     WORD TDB_thread_free   ;       // free list of availble thread structures
     WORD TDB_thread_count  ;       // total count of tread structures
     WORD TDB_FCW         ; // Floating point control word
     BYTE TDB_flags   ;     // Task flags
     BYTE TDB_filler      ;     // keep word aligned
     WORD TDB_ErrMode     ;     // Error mode for this task
     WORD TDB_ExpWinVer   ;     // Expected Windows version for this task
     WORD TDB_Module      ;     // Task module handle to free in killtask
     WORD TDB_pModule     ;     // Pointer to the module database.
     WORD TDB_Queue   ;     // Task Event Queue pointer
     WORD TDB_Parent      ;     // TDB of the task that started this up
     WORD TDB_SigAction   ;     // Action for app task signal
     DWORD TDB_ASignalProc   ;      // App's Task Signal procedure address
     DWORD TDB_USignalProc   ;      // User's Task Signal procedure address
     DWORD TDB_GNotifyProc    ; // Task global discard notify proc.
     DWORD TDB_INTVECS[numTaskInts] ;   // Task specfic harare interrupts
     WORD TDB_CompatFlags ;     // Compatibility flags
     WORD TDB_CompatFlags2 ;        // Upper 16 bits
     WORD TDB_CompatHandle ;    // for dBase bug
     WORD TDB_WOWCompatFlagsEx ;     // More WOW Compatibility flags
     WORD TDB_WOWCompatFlagsEx2 ;        // Upper 16 bits
     BYTE TDB_Free[3] ;         // Filler to keep TDB size unchanged
     BYTE TDB_cLibrary    ;     // tracks  add/del of ALL libs in system EMS
     DWORD TDB_PHT        ; // (HANDLE:OFFSET) to private handle table
     WORD TDB_PDB         ; // MSDOS Process Data Block (PDB)
     DWORD TDB_DTA        ; // MSDOS Disk Transfer Address
     BYTE TDB_Drive  ;      // MSDOS current drive
     BYTE TDB_Directory[65] ;       // *** not used starting with win95
     WORD TDB_Validity    ;     // initial AX to be passed to a task
     WORD TDB_Yield_to    ;     // DirectedYield arg stored here
     WORD TDB_LibInitSeg      ; // segment address of libraries to init
     WORD TDB_LibInitOff      ; // MakeProcInstance thunks live here.
     WORD TDB_MPI_Sel     ;     // Code selector for thunks
     WORD TDB_MPI_Thunks[((THUNKELEM*THUNKSIZE)/2)]; //
     BYTE TDB_ModName[8] ;      // Name of Module.
     WORD TDB_sig         ; // Signature word to detect bogus code
     DWORD TDB_ThreadID   ;     // 32-Bit Thread ID for this Task (use TDB_Filler Above)
     DWORD TDB_hThread    ; // 32-bit Thread Handle for this task
     WORD  TDB_WOWCompatFlags;  // WOW Compatibility flags
     WORD  TDB_WOWCompatFlags2; // WOW Compatibility flags
#ifdef FE_SB
     WORD  TDB_WOWCompatFlagsJPN;  // WOW Compatibility flags for JAPAN
     WORD  TDB_WOWCompatFlagsJPN2; // WOW Compatibility flags for JAPAN
#endif // FE_SB
     DWORD TDB_vpfnAbortProc;   // printer AbortProc
     BYTE TDB_LFNDirectory[260]; // Long directory name

} TDB;
typedef TDB UNALIGNED *PTDB;

// This bit is defined for the TDB_Drive field
#define TDB_DIR_VALID 0x80
#define TDB_SIGNATURE 0x4454

#define TDBF_OS2APP   0x8
#define TDBF_WINOLDAP 0x1


// NOTE TDB_ThreadID MUST be DWORD aligned or else it will fail on MIPS

#pragma pack()


/////////////////////////////////////////////////////////////////////////////
//
// DOSPDB structure, stolen from base\mvdm\inc\doswow.h
//
//


#pragma pack(1)

typedef struct _DOSPDB {                        // DOS Process Data Block
    CHAR   PDB_Not_Interested[44];      // Fields we are not interested in
    USHORT PDB_environ;             // segment of environment
    DWORD  PDB_User_stack;
    USHORT PDB_JFN_Length;          // JFT length
    ULONG  PDB_JFN_Pointer;         // JFT pointer
} DOSPDB, *PDOSPDB;

#pragma pack()


///////////////////////////////////////////////////////////////////////////////
//
//
// Variables and functions that are local to this project
//

//
// defined in wowprocesshistory.cpp
//

extern CHAR     g_szCompatLayerVar[];
extern CHAR     g_szProcessHistoryVar[];
extern CHAR     g_szShimFileLogVar[];

extern WCHAR    g_wszCompatLayerVar[];

extern BOOL     g_bIsNTVDM;
extern BOOL     g_bIsExplorer;

extern WCHAR*   g_pwszCompatLayer;

//
// Function in Win2kPropagateLayer that allows us to create env from wow data
//

LPVOID
ShimCreateWowEnvironment_U(
    LPVOID lpEnvironment,       // pointer to the existing environment
    DWORD* lpdwFlags,           // process creation flags
    BOOL   bNewEnvironment      // when set, forces us to clone environment ptr
    );


//
// functions in environment.cpp
//
PSZ
ShimFindEnvironmentVar(
    PSZ  pszName,
    PSZ  pszEnv,
    PSZ* ppszVal
    );

DWORD
ShimGetEnvironmentSize(
    PSZ     pszEnv,
    LPDWORD pStrCount
    );

DWORD
ShimGetEnvironmentSize(
    WCHAR*  pwszEnv,
    LPDWORD pStrCount
    );

NTSTATUS
ShimCloneEnvironment(
    LPVOID* ppEnvOut,
    LPVOID  lpEnvironment,
    BOOL    bUnicode
    );

NTSTATUS
ShimFreeEnvironment(
    LPVOID lpEnvironment
    );

NTSTATUS
ShimSetEnvironmentVar(
    LPVOID* ppEnvironment,
    WCHAR*  pwszVarName,
    WCHAR*  pwszVarValue
    );

//
// stuff in wowtask.cpp
//

//
// Structure to reflect WOW environment values
//

typedef struct tagWOWENVDATA {

    PSZ   pszCompatLayer; // fully-formed compat layer variable
    PSZ   pszCompatLayerVal;

    PSZ   pszProcessHistory; // fully-formed process history variable
    PSZ   pszProcessHistoryVal;

    PSZ   pszShimFileLog;   // file log variable
    PSZ   pszShimFileLogVal;

    // buffer that we use for the accomulated process history,
    PSZ   pszCurrentProcessHistory;

} WOWENVDATA, *PWOWENVDATA;



//
// function to retrieve all the "interesting" things out of wow environment
//


BOOL
ShimRetrieveVariablesEx(
    PWOWENVDATA pData
    );

//
// Store information about wow task
//

BOOL
UpdateWowTaskList(
    WORD hTask16
    );

//
// wow task exits, cleanup the list
//

BOOL
CleanupWowTaskList(
    WORD hTask16
    );


//
// Functions in cleanup.cpp
//


BOOL
CleanupRegistryForCurrentExe(
    void
    );

//
// functions in win2kpropagatelayer.cpp
//

void
InitLayerStorage(
    BOOL bDelete
    );

BOOL
AddSupport(
    LPCWSTR lpCommandLine,
    LPVOID* ppEnvironment,
    LPDWORD lpdwCreationFlags
    );

BOOL
CheckAndShimNTVDM(
    WORD hTask16
    );



//
// Exception filter, proto for the function in WowProcessHistory.cpp
//
//

ULONG
Win2kPropagateLayerExceptionHandler(
    PEXCEPTION_POINTERS pexi,
    char * szFile,
    DWORD dwLine
    );

//
// Exception filter to use with our hooks
//

#define WOWPROCESSHISTORYEXCEPTIONFILTER \
    Win2kPropagateLayerExceptionHandler(GetExceptionInformation(), __FILE__, __LINE__)


#endif // _WIN2KPROPAGATELAYER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\win95versionlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Win95VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 95
   version credentials. Applications often check to ensure that they are 
   running on a Win9x system, even though they will run OK on an NT based 
   system.

 Notes:

   This is a general purpose shim.

 History:

   11/10/1999 v-johnwh  Created

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(Win95VersionLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersion)
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetVersionExW)
APIHOOK_ENUM_END

// Used for layer to turn on SafeDisc checking
BOOL g_bCheckSafeDisc = FALSE;

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials.

--*/

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    if (g_bCheckSafeDisc && bIsSafeDisc2()) {
        return ORIGINAL_API(GetVersionExA)(lpVersionInformation);
    } else {
        BOOL bReturn = FALSE;

        if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {
            
            LOGN(eDbgLevelInfo, "[GetVersionExA] Return Win95");
            
            //
            // Fixup the structure with the Win95 data.
            //
            lpVersionInformation->dwMajorVersion = 4;
            lpVersionInformation->dwMinorVersion = 0;
            lpVersionInformation->dwBuildNumber = 950;
            lpVersionInformation->dwPlatformId = 1;
            *lpVersionInformation->szCSDVersion = '\0';

            bReturn = TRUE;
        }
        
        return bReturn;
    }
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials.

--*/

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    if (g_bCheckSafeDisc && bIsSafeDisc2()) {
        return ORIGINAL_API(GetVersionExW)(lpVersionInformation);
    } else {
        BOOL bReturn = FALSE;

        if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {
            
            LOGN(eDbgLevelInfo, "[GetVersionExW] Return Win95");
            
            //
            // Fixup the structure with the Win95 data.
            //
            lpVersionInformation->dwMajorVersion = 4;
            lpVersionInformation->dwMinorVersion = 0;
            lpVersionInformation->dwBuildNumber = 950;
            lpVersionInformation->dwPlatformId = 1;
            *lpVersionInformation->szCSDVersion = L'\0';

            bReturn = TRUE;
        }
        
        return bReturn;
    }
}

/*++

 This stub function returns Windows 95 credentials.

--*/

DWORD
APIHOOK(GetVersion)(
    void
    )
{
    if (g_bCheckSafeDisc && bIsSafeDisc2()) {
        return ORIGINAL_API(GetVersion)();
    } else {
        LOGN(eDbgLevelInfo, "[GetVersion] Return Win95");
        return (DWORD)0xC3B60004;
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_bCheckSafeDisc = COMMAND_LINE && (_stricmp(COMMAND_LINE, "Detect_SafeDisc") == 0);

        if (g_bCheckSafeDisc && bIsSafeDisc1())
        {
            LOGN(eDbgLevelWarning, "SafeDisc 1.x detected: ignoring shim");
            return FALSE;
        }
    }
    
    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\win2kpropagatelayer_wowtask.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   WoWTask.cpp

 Abstract:

   Functions that retrieve process-history related information from
   16-bit environment. This includes the retrieval of the correct
   __PROCESS_HISTORY that was passed in from the parent (32-bit)process
   and tracing the process history through WOW

 Notes:


 History:

   10/26/00 VadimB  Created

--*/


#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(Win2kPropagateLayer)
#include "ShimHookMacro.h"

#include "Win2kPropagateLayer.h"


typedef struct tagFINDWOWTASKDATA {
    BOOL  bFound;
    DWORD dwProcessId;
    DWORD dwThreadId;
    WORD  hMod16;
    WORD  hTask16;

} FINDWOWTASKDATA, *PFINDWOWTASKDATA;


//
// Dynamically Linked apis
//
//  from WOW32.dll
//

typedef LPVOID (WINAPI *PFNWOWGetVDMPointer)(DWORD vp,
                                             DWORD dwBytes,
                                             BOOL  fProtectedMode);

//
//  from vdmdbg.dll - defined in the header file
//
//

typedef INT (WINAPI *PFNVDMEnumTaskWOW)(DWORD        dwProcessId,
                                        TASKENUMPROC fp,
                                        LPARAM       lparam);

//
// Api importing -- modules
//
WCHAR g_wszWOW32ModName[]  = L"wow32.dll";
WCHAR g_wszVdmDbgModName[] = L"VdmDbg.dll";

//
// Api importing - module handles and function pointers
//

HMODULE g_hWow32;
HMODULE g_hVdmDbg;
BOOL    g_bInitialized;  // set to true when imports are initialized

PFNWOWGetVDMPointer  g_pfnWOWGetVDMPointer;
PFNVDMEnumTaskWOW    g_pfnVDMEnumTaskWOW;

extern BOOL* g_pSeparateWow;


//
// function in this module to import apis
//

BOOL ImportWowApis(VOID);


//
// Marcro to access 16-bit memory
//


#define SEGPTR(seg,off)  ((g_pfnWOWGetVDMPointer)((((ULONG)seg) << 16) | (off), 0, TRUE))

//
// task enum proc, called back from vdmdbg
//

BOOL WINAPI MyTaskEnumProc(
    DWORD dwThreadId,
    WORD  hMod16,
    WORD  hTask16,
    LPARAM lParam
    )
{
    PFINDWOWTASKDATA pFindData = (PFINDWOWTASKDATA)lParam;

    if (dwThreadId == pFindData->dwThreadId) {
        pFindData->hMod16  = hMod16;
        pFindData->hTask16 = hTask16;
        pFindData->bFound  = TRUE;
        return TRUE;
    }

    return FALSE;
}


BOOL FindWowTask(
    DWORD dwProcessId,
    DWORD dwThreadId,
    PFINDWOWTASKDATA pFindData
    )
{
    RtlZeroMemory(pFindData, sizeof(*pFindData));

    pFindData->dwProcessId = dwProcessId;
    pFindData->dwThreadId  = dwThreadId;

    g_pfnVDMEnumTaskWOW(dwProcessId, (TASKENUMPROC)MyTaskEnumProc, (LPARAM)pFindData);

    return pFindData->bFound;
}


//
// get the pointer to task database block from hTask
//


PTDB
GetTDB(
    WORD wTDB
    )
{
    PTDB pTDB;

    pTDB = (PTDB)SEGPTR(wTDB, 0);
    if (NULL == pTDB || TDB_SIGNATURE != pTDB->TDB_sig) {
        LOGN(
            eDbgLevelError,
            "[GetTDB] TDB is invalid for task 0x%x",
            (DWORD)wTDB);
        return NULL;
    }

    return pTDB;
}


//
// GetModName
//   wTDB      - TDB entry
//   szModName - pointer to the buffer that receives module name
//               buffer should be at least 9 characters long
//
// returns FALSE if the entry is invalid


BOOL
GetModName(
    WORD wTDB,
    PCH  szModName
    )
{
    PTDB pTDB;
    PCH  pch;

    pTDB = GetTDB(wTDB);
    if (NULL == pTDB) {
        return FALSE;
    }

    RtlCopyMemory(szModName, pTDB->TDB_ModName, 8 * sizeof(CHAR)); // we have modname now
    szModName[8] = '\0';

    pch = &szModName[8];
    while (*(--pch) == ' ') {
        *pch = 0;
    }

    return TRUE;
}


//
// ShimGetTaskFileName
//      IN wTask - 16-bit task handle
// Returns:
//      Fully qualified exe that is running in this task's context
//


PSZ
ShimGetTaskFileName(
    WORD wTask
    )
{
    PSZ pszFileName = NULL;
    PTDB pTDB;

    pTDB = GetTDB(wTask);
    if (NULL == pTDB) {
        // this is really bad -- the module is invalid, debug output is generated by GetTDB
        return pszFileName;
    }

    if (NULL == pTDB->TDB_pModule) {
        LOGN(
            eDbgLevelError,
            "[ShimGetTaskFileName] module pointer is NULL for 0x%x",
            (DWORD)wTask);
        return pszFileName;
    }

    pszFileName = (PSZ)SEGPTR(pTDB->TDB_pModule, (*(WORD *)SEGPTR(pTDB->TDB_pModule, 10)) + 8);
    return pszFileName;
}


PSZ 
ShimGetTaskEnvptr(
    WORD hTask16
    )
{
    PTDB pTDB = GetTDB(hTask16);
    PSZ  pszEnv = NULL;
    PDOSPDB pPSP;

    if (NULL == pTDB) {
        LOGN( eDbgLevelError, 
            "[ShimGetTaskEnvptr] Bad TDB entry 0x%x",  hTask16);
        return NULL;
    }
    
    //
    // Prepare environment data - this buffer is used when we're starting a new task from the
    // root of the chain (as opposed to spawning from an existing 16-bit task)
    //

    pPSP   = (PDOSPDB)SEGPTR(pTDB->TDB_PDB, 0); // psp
        
    if (pPSP != NULL) {
        pszEnv = (PCH)SEGPTR(pPSP->PDB_environ, 0);
    }

    return pszEnv;
}
    

// IsWowExec
//      IN wTDB - entry into the task database
// Returns:
//      TRUE if this particular entry points to WOWEXEC
//
// Note:
//      WOWEXEC is a special stub module that always runs on NTVDM
//      new tasks are spawned by wowexec (in the most typical case)
//      it is therefore the "root" module and it's environment's contents
//      should not be counted, since we don't know what was ntvdm's parent process
//

BOOL
IsWOWExec(
    WORD wTDB
    )
{
    PTDB pTDB;
    PTDB pTDBParent;
    CHAR szModName[9];

    pTDB = GetTDB(wTDB);
    if (NULL == pTDB) {
        LOGN(
            eDbgLevelError,
            "[IsWOWExec] Bad TDB entry 0x%x",
            (DWORD)wTDB);
        return FALSE;
    }

    if (!GetModName(wTDB, szModName)) { // can we get modname ?
        LOGN(
            eDbgLevelError,
            "[IsWOWExec] GetModName failed.");
        return FALSE;
    }

    return (0 == _strcmpi(szModName, "wowexec")); // is the module named WOWEXEC ?
}

//
// ImportWowApis
//      Function imports necessary apis from wow32.dll and vdmdbg.dll
//
//

BOOL
ImportWowApis(
    VOID
    )
{
    g_hWow32 = LoadLibraryW(g_wszWOW32ModName);
    
    if (g_hWow32 == NULL) {
        LOGN(
            eDbgLevelError,
            "[ImportWowApis] Failed to load wow32.dll Error 0x%x",
            GetLastError());
        goto Fail;
    }

    g_pfnWOWGetVDMPointer = (PFNWOWGetVDMPointer)GetProcAddress(g_hWow32, "WOWGetVDMPointer");
    
    if (g_pfnWOWGetVDMPointer == NULL) {
        LOGN(
            eDbgLevelError,
            "[ImportWowApis] Failed to get address of WOWGetVDMPointer Error 0x%x",
            GetLastError());
        goto Fail;
    }

    g_hVdmDbg = LoadLibraryW(g_wszVdmDbgModName);
    
    if (g_hVdmDbg == NULL) {
        LOGN(
            eDbgLevelError,
            "[ImportWowApis] Failed to load vdmdbg.dll Error 0x%x",
            GetLastError());
        goto Fail;
    }

    g_pfnVDMEnumTaskWOW = (PFNVDMEnumTaskWOW)GetProcAddress(g_hVdmDbg, "VDMEnumTaskWOW");
    
    if (g_pfnVDMEnumTaskWOW == NULL) {
        LOGN(
            eDbgLevelError,
            "[ImportWowApis] Failed to get address of VDMEnumTaskWOW Error 0x%x",
            GetLastError());
        goto Fail;
    }

    g_bInitialized = TRUE;

    return TRUE;

Fail:

    if (g_hWow32) {
        FreeLibrary(g_hWow32);
        g_hWow32 = NULL;
    }
    if (g_hVdmDbg) {
        FreeLibrary(g_hVdmDbg);
        g_hVdmDbg = NULL;
    }
    g_pfnWOWGetVDMPointer = NULL;
    g_pfnVDMEnumTaskWOW   = NULL;

    return FALSE;

}


/////////////////////////////////////////////////////////////////////////////////////////////
//
//
// WOWTaskList
//
// We maintain a shadow list of running wow tasks complete with respective process history and
// inherited process history
//
//

typedef struct tagWOWTASKLISTITEM* PWOWTASKLISTITEM;

typedef struct tagWOWTASKLISTITEM {

    WORD  hTask16;                 // 16-bit tdb entry

    DWORD dwThreadId;              // thread id of the task

    WOWENVDATA EnvData;            // environment data (process history, compat layer, etc)

    PWOWTASKLISTITEM pTaskNext;

} WOWTASKLISTITEM;

PWOWTASKLISTITEM g_pWowTaskList;


/*++

    FindWowTaskInfo

        IN hTask16                   16-bit task's handle
        IN dwThreadId OPTIONAL       32-bit thread id of the task, might be 0

    Returns: pointer to the task information structure

--*/

PWOWTASKLISTITEM
FindWowTaskInfo(
    WORD  hTask16,
    DWORD dwThreadId
    )
{
    PWOWTASKLISTITEM pTask = g_pWowTaskList;

    while (NULL != pTask) {

        if (hTask16 == pTask->hTask16) {

            if (dwThreadId == 0 || dwThreadId == pTask->dwThreadId) {
                break;
            }
        }

        pTask = pTask->pTaskNext;
    }

    return pTask;
}

/*++

    UpdateWowTaskList

        IN hTask16              16-bit task's handle

    Returns: True if the task was added successfully
    Note:    wowexec is not among the "legitimate" tasks

--*/


BOOL
UpdateWowTaskList(
    WORD hTask16
    )
{
    PTDB             pTDB;
    WORD             wTaskParent;
    PWOWTASKLISTITEM pTaskParent = NULL;
    LPSTR            lpszFileName;
    PSZ              pszEnv;
    WOWENVDATA       EnvData;
    PWOWENVDATA      pData = NULL;
    DWORD            dwLength;
    PWOWTASKLISTITEM pTaskNew;
    PCH              pBuffer;
    PDOSPDB          pPSP;
    BOOL             bSuccess;

    //
    // see that we are initialized, import apis
    //
    if (!g_bInitialized) { // first call, link apis
        bSuccess = ImportWowApis();
        if (!bSuccess) {
            LOGN(
                eDbgLevelError,
                "[UpdateWowTaskList] Failed to import apis.");
            return FALSE;
        }
    }

    //
    // If this task is WOWEXEC -- just return, it's not an error condition, but we don't need
    // wowexec in our list
    //

    if (IsWOWExec(hTask16)) {  // this is ok, we don't want wowexec
        return FALSE;
    }

    //
    // next, see what the parent item is, to do so -- access it through TDB
    //

    pTDB = GetTDB(hTask16);
    if (NULL == pTDB) {
        LOGN(
            eDbgLevelError,
            "[UpdateWowTaskList] Bad TDB entry 0x%x",
            hTask16);
        return FALSE;
    }

    //
    // Prepare environment data - this buffer is used when we're starting a new task from the
    // root of the chain (as opposed to spawning from an existing 16-bit task)
    //

    RtlZeroMemory(&EnvData, sizeof(EnvData));
    pData = &EnvData;

    wTaskParent = pTDB->TDB_Parent;
    
    if (IsWOWExec(wTaskParent) || GetTDB(wTaskParent) == NULL) {
        //
        // Root task, extract process history, compat layer, etc
        //
        pszEnv = NULL;
        pPSP   = (PDOSPDB)SEGPTR(pTDB->TDB_PDB, 0); // psp
        
        if (pPSP != NULL) {
            pszEnv = (PCH)SEGPTR(pPSP->PDB_environ, 0);
        }

        //
        // we have a pointer to the current environment here, pData is initialized
        //
        if (pszEnv != NULL) {
            pData->pszProcessHistory = ShimFindEnvironmentVar(g_szProcessHistoryVar,
                                                              pszEnv,
                                                              &pData->pszProcessHistoryVal);
            
            pData->pszCompatLayer    = ShimFindEnvironmentVar(g_szCompatLayerVar,
                                                              pszEnv,
                                                              &pData->pszCompatLayerVal);
            
            pData->pszShimFileLog    = ShimFindEnvironmentVar(g_szShimFileLogVar,
                                                              pszEnv,
                                                              &pData->pszShimFileLogVal);
        }

    } else {
        //
        // Not a root task, find parent process
        //
        pTaskParent = FindWowTaskInfo(wTaskParent, 0); // we can't determine which thread owns the task

        if (pTaskParent == NULL) {
            //
            // something is very wrong
            // we can't inherit
            //

            LOGN(
                eDbgLevelError,
                "[UpdateWowTaskList] Task 0x%x is not root but parent not listed 0x%x",
                (DWORD)hTask16,
                (DWORD)wTaskParent);
            //
            // we still allow building up process history. The initial variables will be empty
            //


        } else {
            //
            // inherit everything from the parent and add it's module name (later)
            //

            pData = &pTaskParent->EnvData;
        }
    }

    //
    // Get the filename involved
    //
    //

    lpszFileName = ShimGetTaskFileName(hTask16);

    //
    // now calculate how much space is required to hold all of the data
    //

    dwLength = sizeof(WOWTASKLISTITEM) +
               (NULL == pData->pszProcessHistory        ? 0 : (strlen(pData->pszProcessHistory) + 1) * sizeof(CHAR)) +
               (NULL == pData->pszCompatLayer           ? 0 : (strlen(pData->pszCompatLayer) + 1) * sizeof(CHAR)) +
               (NULL == pData->pszShimFileLog           ? 0 : (strlen(pData->pszShimFileLog) + 1) * sizeof(CHAR)) +
               (NULL == pData->pszCurrentProcessHistory ? 0 : (strlen(pData->pszCurrentProcessHistory) + 1) * sizeof(CHAR)) +
               (NULL == lpszFileName                    ? 0 : (strlen(lpszFileName) + 1) * sizeof(CHAR));


    pTaskNew = (PWOWTASKLISTITEM)ShimMalloc(dwLength);
    
    if (pTaskNew == NULL) {
        LOGN(
            eDbgLevelError,
            "[UpdateWowTaskList] failed to allocate 0x%x bytes",
            dwLength);
        return FALSE;
    }

    RtlZeroMemory(pTaskNew, dwLength);

    //
    // now this entry has to be setup
    // process history is first
    //

    pBuffer = (PCH)(pTaskNew + 1);

    pTaskNew->hTask16    = hTask16;
    pTaskNew->dwThreadId = GetCurrentThreadId();

    if (pData->pszProcessHistory != NULL) {

        //
        // Copy process history. The processHistoryVal is a pointer into the buffer
        // pointed to by pszProcessHistory: __PROCESS_HISTORY=c:\foo;c:\docs~1\install
        // then pszProcessHistoryVal will point here ---------^
        //
        // we are copying the data and moving the pointer using the calculated offset

        pTaskNew->EnvData.pszProcessHistory = pBuffer;
        strcpy(pTaskNew->EnvData.pszProcessHistory, pData->pszProcessHistory);
        pTaskNew->EnvData.pszProcessHistoryVal = pTaskNew->EnvData.pszProcessHistory +
                                                 (INT)(pData->pszProcessHistoryVal - pData->pszProcessHistory);
        //
        // There is enough space in the buffer to accomodate all the strings, so
        // move pointer past current string to point at the "empty" space
        //

        pBuffer += strlen(pData->pszProcessHistory) + 1;
    }

    if (pData->pszCompatLayer != NULL) {
        pTaskNew->EnvData.pszCompatLayer = pBuffer;
        strcpy(pTaskNew->EnvData.pszCompatLayer, pData->pszCompatLayer);
        pTaskNew->EnvData.pszCompatLayerVal = pTaskNew->EnvData.pszCompatLayer +
                                              (INT)(pData->pszCompatLayerVal - pData->pszCompatLayer);
        pBuffer += strlen(pData->pszCompatLayer) + 1;
    }

    if (pData->pszShimFileLog != NULL) {
        pTaskNew->EnvData.pszShimFileLog = pBuffer;
        strcpy(pTaskNew->EnvData.pszShimFileLog, pData->pszShimFileLog);
        pTaskNew->EnvData.pszShimFileLogVal = pTaskNew->EnvData.pszShimFileLog +
                                              (INT)(pData->pszShimFileLogVal - pData->pszShimFileLog);
        pBuffer += strlen(pData->pszShimFileLog) + 1;
    }

    if (pData->pszCurrentProcessHistory != NULL || lpszFileName != NULL) {
        //
        // Now process history
        //
        pTaskNew->EnvData.pszCurrentProcessHistory = pBuffer;
        
        if (pData->pszCurrentProcessHistory != NULL) {
            strcpy(pTaskNew->EnvData.pszCurrentProcessHistory, pData->pszCurrentProcessHistory);
            strcat(pTaskNew->EnvData.pszCurrentProcessHistory, ";");
        }
        
        if (lpszFileName != NULL) {
            strcat(pTaskNew->EnvData.pszCurrentProcessHistory, lpszFileName);
        }
    }

    LOGN(
        eDbgLevelInfo,
        "[UpdateWowTaskList] Running           : \"%s\"",
        lpszFileName);
    
    LOGN(
        eDbgLevelInfo,
        "[UpdateWowTaskList] ProcessHistory    : \"%s\"",
        pTaskNew->EnvData.pszCurrentProcessHistory);
    
    LOGN(
        eDbgLevelInfo,
        "[UpdateWowTaskList] BaseProcessHistory: \"%s\"",
        pTaskNew->EnvData.pszProcessHistory);
    
    LOGN(
        eDbgLevelInfo,
        "[UpdateWowTaskList] CompatLayer       : \"%s\"",
        pTaskNew->EnvData.pszCompatLayer);


    //
    // We are done, link the entry into the list
    //
    pTaskNew->pTaskNext = g_pWowTaskList;

    g_pWowTaskList = pTaskNew;

    return TRUE;
}


/*++

    CleanupWowTaskList

        IN hTask16  16-bit task handle that is to be removed from the list of running tasks

    Returns : TRUE if the function succeeds

--*/

BOOL
CleanupWowTaskList(
    WORD hTask16
    )
{
    PWOWTASKLISTITEM pTask = g_pWowTaskList;
    PWOWTASKLISTITEM pTaskPrev = NULL;

    while (pTask != NULL) {

        if (pTask->hTask16 == hTask16) {
            // this is the item
            break;
        }

        pTaskPrev = pTask;
        pTask = pTask->pTaskNext;
    }

    if (pTask == NULL) {
        LOGN(
            eDbgLevelError,
            "[CleanupWowTaskList] Failed to locate task information for 0x%x",
            (DWORD)hTask16);
        return FALSE;
    }


    if (pTaskPrev == NULL) {

        g_pWowTaskList = pTask->pTaskNext;

    } else {

        pTaskPrev->pTaskNext = pTask->pTaskNext;

    }

    ShimFree(pTask);

    return TRUE;

}

/*++

    ShimRetrieveVariablesEx

        IN pData        Structure that receives pointers to all the relevant environment information
                        for the calling thread. The threads are scheduled non-preemptively by user and
                        threadid is used to identify the calling 16-bit task
                        All the real work on information retrieval is done in UpdateWowTaskList

    Returns: TRUE if success
--*/

BOOL
ShimRetrieveVariablesEx(
    PWOWENVDATA pData
    )
{
    DWORD            dwProcessId = GetCurrentProcessId();
    DWORD            dwThreadId  = GetCurrentThreadId();
    PWOWTASKLISTITEM pTask;
    FINDWOWTASKDATA  FindData;
    WORD             hTask;
    BOOL             bSuccess;

    RtlZeroMemory(pData, sizeof(*pData));

    if (!g_bInitialized) { // first call, link apis
        bSuccess = ImportWowApis();
        if (!bSuccess) {
            LOGN(
                eDbgLevelError,
                "[ShimRetrieveVariablesEx] Failed to import apis.");
            return FALSE;
        }
    }

    if (!FindWowTask(dwProcessId, dwThreadId, &FindData)) {
        LOGN(
            eDbgLevelError,
            "[ShimRetrieveVariablesEx] Task not found ProcessId 0x%x ThreadId 0x%x",
            dwProcessId,
            dwThreadId);
        return FALSE;
    }

    hTask = FindData.hTask16;

    pTask = FindWowTaskInfo(hTask, dwThreadId);
    
    if (pTask == NULL) {
        LOGN(
            eDbgLevelError,
            "[ShimRetrieveVariablesEx] Failed to locate wow task.");
        return FALSE;
    }

    //
    // Found this one. Copy the info.
    //
    RtlMoveMemory(pData, &pTask->EnvData, sizeof(*pData));

    return TRUE;
}

/*++ 
    ShimThisProcess

    Function invokes Shim Engine for dynamic shimming of the current process 
    Which happens to be ntvdm, naturally. This ntvdm is a separate ntvdm 
    (which is insured through various checks in CheckAndShimNTVDM) 

--*/

BOOL
ShimThisProcess(
    HMODULE hModShimEngine,
    HSDB    hSDB,
    SDBQUERYRESULT* pQueryResult
    )
{
    typedef BOOL    (WINAPI *PFNDynamicShim)(LPCWSTR , HSDB , SDBQUERYRESULT*, LPCSTR);
    PFNDynamicShim  pfnDynamicShim = NULL;
    WCHAR wszFileName[MAX_PATH];
    DWORD dwLength;

    pfnDynamicShim = (PFNDynamicShim) GetProcAddress(hModShimEngine, "SE_DynamicShim");
    if (NULL == pfnDynamicShim) {
        LOGN( eDbgLevelError, 
            "[ShimThisProcess] failed to obtain dynamic shim proc address\n");
        return FALSE;
    }

    dwLength = GetModuleFileNameW(GetModuleHandle(NULL), wszFileName, CHARCOUNT(wszFileName));
    if (!dwLength || dwLength > CHARCOUNT(wszFileName)) {
        LOGN( eDbgLevelError, 
            "[ShimThisProcess] failed to obtain module file name\n");
        return FALSE;
    }

    return pfnDynamicShim(wszFileName, hSDB, pQueryResult, NULL);
}

/*++ 
    CheckAndShimNTVDM
    
    Procedure checks ntvdm application for having to be shimmed. If an application is located in 
    appcompat database, this ntvdm would have to be running as a separate ntvdm (explorer is shimmed as 
    well, as a result it will have checked the binary first and set the separate vdm flag in CreateProcess)

    Further, this call comes through InitTask (intercepted between ntvdm and user32) -- as a parameter it 
    takes hTask16 - which we're able to use to retrieve application's environment and other important 
    information.
--*/


BOOL
CheckAndShimNTVDM(
    WORD hTask16
    )
{
    HMODULE  hModShimEngine;
    PSZ      pszTaskFileName = NULL;
    CString  csTaskFileName;
    DWORD    dwExeCount;
    PSZ      pszEnv  = NULL;
    PTDB     pTDB    = NULL;
    PVOID    pEnvNew = NULL;
    PDOSPDB  pPSP;
    BOOL     bSuccess = FALSE;
    BOOL     bMatch;
    BOOL     bNewEnv  = FALSE;
    HSDB     hSDB;
    NTSTATUS Status;
    SDBQUERYRESULT QueryResult;
    DWORD    dwFlags;

    hModShimEngine = GetModuleHandle(TEXT("shim.dll"));
    if (hModShimEngine == NULL) {
        // impossible -- shim.dll is not injected!!!
        return FALSE;
    }
    
    if (g_pSeparateWow != NULL && *g_pSeparateWow == FALSE) {
        // 
        // not a separate wow
        //
        LOGN( eDbgLevelError,
            "[CheckAndShimNTVDM] running in shared wow, no shimming\n");
        return FALSE;
    }

    if (!g_bInitialized) { // first call, link apis
        bSuccess = ImportWowApis();
        if (!bSuccess) {
            LOGN( eDbgLevelError,
                "[CheckAndShimNTVDM] Failed to import apis.\n");
            return FALSE;
        }
    }

    if (IsWOWExec(hTask16)) {
        LOGN( eDbgLevelError,
            "[CheckAndShimNTVDM] not touching wowexec\n");
        
        return FALSE;
    }

    csTaskFileName = ShimGetTaskFileName(hTask16);
    if (csTaskFileName.IsEmpty()) {
        LOGN( eDbgLevelError,
            "[CheckAndShimNTVDM] failed to get the filename for task 0x%lx\n", hTask16);
        return FALSE;
    }
    
    //
    // init database
    //
    hSDB = SdbInitDatabase(0, NULL);

    if (hSDB == NULL) {
        LOGN( eDbgLevelError, 
            "[CheckAndShimNTVDM] failed to init shim database\n");
        return FALSE;
    } 


    //
    // process history please -- 
    // if we end up here, we are a separate ntvdm 
    // running with a process history in the env, was retrieved in init
    //

    pTDB = GetTDB(hTask16);
    if (NULL == pTDB) {
        LOGN( eDbgLevelError, "[UpdateWowTaskList] Bad TDB entry 0x%x",  hTask16);
        return FALSE;
    }

    //
    // Prepare environment data - this buffer is used when we're starting a new task from the
    // root of the chain (as opposed to spawning from an existing 16-bit task)
    //

    pszEnv = ShimGetTaskEnvptr(hTask16);
    if (NULL != pszEnv) {
        Status = ShimCloneEnvironment(&pEnvNew, (LPVOID)pszEnv, FALSE);
        if (!NT_SUCCESS(Status)) {
            LOGN( eDbgLevelError, 
                "[CheckAndShimNTVDM] cannot clone environment 0x%lx\n", Status);
            pEnvNew = NULL;
            bNewEnv = TRUE;
        }

        // 
        // if this call has come the way of VDM - we need to carry over our environment stuff
        // which is stored separately in this shim
        //
        // should the call to ShimCloneEnvironment fail, we will have pEnvNew == NULL
        // and bNewEnv = TRUE, as a result, we shall try again to clone the environment

        
        dwFlags = CREATE_UNICODE_ENVIRONMENT;
        pEnvNew = ShimCreateWowEnvironment_U(pEnvNew, &dwFlags, bNewEnv);
    }
    
    //
    // run detection please
    //
    
    bMatch = SdbGetMatchingExe(hSDB,
                               (LPCWSTR)csTaskFileName,
                               NULL, // we can give out module name as well -- but WHY?
                               (LPCWSTR)pEnvNew,
                               0,
                               &QueryResult);
                                  
    if (bMatch) {
        bSuccess = ShimThisProcess(hModShimEngine, hSDB, &QueryResult);
    }
                     
    if (pEnvNew != NULL) {
        ShimFreeEnvironment(pEnvNew);
    }
    
    return bSuccess;
}
    


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\win2kpropagatelayer.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Win2000VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 2000
   version credentials.

 Notes:

   This is a general purpose shim.

 History:

   03/13/2000 clupu  Created
   10/26/2000 Vadimb Merged WowProcessHistory functionality, new environment-handling cases

--*/

#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(Win2kPropagateLayer)
#include "ShimHookMacro.h"

#include "Win2kPropagateLayer.h"
#include "stdio.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(UserRegisterWowHandlers)
APIHOOK_ENUM_END


#define LI_WIN95    0x00000001
#define LI_NT4      0x00000002
#define LI_WIN98    0x00000004

#define LS_MAGIC    0x07036745

typedef struct tagLayerStorageHeader {
    DWORD       dwItemCount;    // number of items in the file
    DWORD       dwMagic;        // magic to identify the file
    SYSTEMTIME  timeLast;       // time of last access
} LayerStorageHeader, *PLayerStorageHeader;


typedef struct tagLayeredItem {
    WCHAR   szItemName[MAX_PATH];
    DWORD   dwFlags;

} LayeredItem, *PLayeredItem;



#define APPCOMPAT_KEY L"System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility"

WCHAR g_szLayerStorage[MAX_PATH] = L"";


CHAR g_szCompatLayerVar[]    = "__COMPAT_LAYER";
CHAR g_szProcessHistoryVar[] = "__PROCESS_HISTORY";
CHAR g_szShimFileLogVar[]    = "SHIM_FILE_LOG";


WCHAR g_wszCompatLayerVar[]  = L"__COMPAT_LAYER";
WCHAR g_wszProcessHistroyVar[] = L"__PROCESS_HISTORY";
//
// This variable receives current process' compat layer
//

WCHAR* g_pwszCompatLayer = NULL;
WCHAR* g_pwszProcessHistory = NULL;

//
// Unicode equivalent of the above
//
UNICODE_STRING g_ustrProcessHistoryVar = RTL_CONSTANT_STRING(L"__PROCESS_HISTORY");
UNICODE_STRING g_ustrCompatLayerVar    = RTL_CONSTANT_STRING(L"__COMPAT_LAYER");

//
// Global flags
//
BOOL g_bIsNTVDM    = FALSE;
BOOL g_bIsExplorer = FALSE;

INT    g_argc    = 0;
CHAR** g_argv    = NULL;

//
// is this a separate wow ?
//

BOOL* g_pSeparateWow = NULL;


void
InitLayerStorage(
    BOOL bDelete
    )
{
    GetSystemWindowsDirectoryW(g_szLayerStorage, MAX_PATH);

    if (g_szLayerStorage[lstrlenW(g_szLayerStorage) - 1] == L'\\') {
        g_szLayerStorage[lstrlenW(g_szLayerStorage) - 1] = 0;
    }

    lstrcatW(g_szLayerStorage, L"\\AppPatch\\LayerStorage.dat");

    if (bDelete) {
        DeleteFileW(g_szLayerStorage);
    }
}

void
ReadLayeredStorage(
    LPWSTR  pszItem,
    LPDWORD lpdwFlags
    )
{
    HANDLE              hFile        = INVALID_HANDLE_VALUE;
    HANDLE              hFileMapping = NULL;
    DWORD               dwFileSize;
    PBYTE               pData        = NULL;
    PLayerStorageHeader pHeader      = NULL;
    PLayeredItem        pItems;
    PLayeredItem        pCrtItem     = NULL;
    int                 nLeft, nRight, nMid, nItem;

    LOGN(
        eDbgLevelInfo,
        "[ReadLayeredStorage] for \"%S\"",
        pszItem);

    //
    // Make sure we don't corrupt the layer storage.
    //
    if (lstrlenW(pszItem) + 1 > MAX_PATH) {
        pszItem[MAX_PATH - 1] = 0;
    }

    hFile = CreateFileW(g_szLayerStorage,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        LOGN(
            eDbgLevelInfo,
            "[ReadLayeredStorage] the layer storage doesn't exist.");
        *lpdwFlags = 0;
        return;
    }

    //
    // The file already exists. Create a file mapping that will allow
    // for querying the item.
    //
    dwFileSize = GetFileSize(hFile, NULL);

    hFileMapping = CreateFileMapping(hFile,
                                     NULL,
                                     PAGE_READWRITE,
                                     0,
                                     dwFileSize,
                                     NULL);

    if (hFileMapping == NULL) {
        LOGN(
            eDbgLevelError,
            "[ReadLayeredStorage] CreateFileMapping failed 0x%X",
            GetLastError());
        goto done;
    }

    pData = (PBYTE)MapViewOfFile(hFileMapping,
                                 FILE_MAP_READ | FILE_MAP_WRITE,
                                 0,
                                 0,
                                 0);

    if (pData == NULL) {
        LOGN(
            eDbgLevelError,
            "[ReadLayeredStorage] MapViewOfFile failed 0x%X",
            GetLastError());
        goto done;
    }

    pHeader = (PLayerStorageHeader)pData;

    pItems = (PLayeredItem)(pData + sizeof(LayerStorageHeader));

    //
    // Make sure it's our file.
    //
    if (dwFileSize < sizeof(LayerStorageHeader) || pHeader->dwMagic != LS_MAGIC) {
        LOGN(
            eDbgLevelError,
            "[ReadLayeredStorage] invalid file magic 0x%X",
            pHeader->dwMagic);
        goto done;
    }

    //
    // First search for the item. The array is sorted so we do binary search.
    //
    nItem = -1, nLeft = 0, nRight = (int)pHeader->dwItemCount - 1;

    while (nLeft <= nRight) {

        int nVal;

        nMid = (nLeft + nRight) / 2;

        pCrtItem  = pItems + nMid;

        nVal = _wcsnicmp(pszItem, pCrtItem->szItemName, lstrlenW(pCrtItem->szItemName));

        if (nVal == 0) {
            nItem = nMid;
            break;
        } else if (nVal < 0) {
            nRight = nMid - 1;
        } else {
            nLeft = nMid + 1;
        }
    }

    if (nItem == -1) {
        LOGN(
            eDbgLevelInfo,
            "[ReadLayeredStorage] the item was not found in the file.");

        *lpdwFlags = 0;
    } else {
        //
        // The item is in the file.
        //
        LOGN(
            eDbgLevelInfo,
            "[ReadLayeredStorage] the item is in the file.");

        *lpdwFlags = pCrtItem->dwFlags;
    }

done:

    if (pData != NULL) {
        UnmapViewOfFile(pData);
    }

    if (hFileMapping != NULL) {
        CloseHandle(hFileMapping);
    }

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}


BOOL
GetFileNameFromCmdLine(
    LPWSTR lpFileName,
    DWORD  dwFileNameSize,
    LPCWSTR lpCmdLine
    )
{
    LPWSTR pTemp = lpFileName;
    LPCWSTR pSrc = lpCmdLine;
    DWORD dwQuote = 0;
    LPCWSTR pStart;
    BOOL    bQuote = FALSE;
    BOOL    bInitialQuote = FALSE;
    BOOL    bDone = FALSE;
    DWORD   dwLength; // length of the result, in chars

    pSrc += wcsspn(pSrc, L" \t");
    if (*pSrc == L'\"') {
        ++pSrc;
        bQuote = TRUE;
        bInitialQuote = TRUE;
    }

    pStart = pSrc; // note -- we're past the quote

    // we end when: 1) we start we the quote -- we end with the quote or
    // we did not start with the quote -- we encounter space then
    
    while (*pSrc && !bDone) {
        switch(*pSrc) {
            case L'\"':
                bQuote = !bQuote;
                break;
                
            case L' ':
                bDone = !bQuote; // out of quotes? this is the end
                break;
        }
        
        if (!bDone) {
            ++pSrc;
        }
    }   

    if (pSrc > pStart && bInitialQuote && *(pSrc-1) == L'\"') {
        --pSrc;
    }

    //
    // now that we ended the run, copy 
    //
    dwLength = (DWORD)(pSrc - pStart);

    if (dwFileNameSize < (dwLength + 1)) {
        // too big 
        LOGN( eDbgLevelError, 
            "[GetFileNameFromCmdLine] filename is too long\"%S\".\n", lpCmdLine);
        return FALSE;
    }

    RtlCopyMemory(lpFileName, pStart, dwLength * sizeof(WCHAR));
    lpFileName[dwLength] = L'\0';
    return TRUE;

}
    
BOOL
AddSupport(
    LPCWSTR lpCommandLine,
    LPVOID* ppEnvironment,
    LPDWORD lpdwCreationFlags
    )
{
    WCHAR    szKey[MAX_PATH];
    WCHAR    szFullPath[MAX_PATH] = L"\"";
    WCHAR    szExeName[128];
    HKEY     hkey;
    DWORD    type;
    DWORD    cbData = 0;
    BOOL     bBraket = FALSE;
    LPVOID   pEnvironmentNew  = *ppEnvironment;
    DWORD    dwCreationFlags  = *lpdwCreationFlags;
    BOOL     bUserEnvironment = (*ppEnvironment != NULL);
    NTSTATUS Status;
    LPCWSTR  pszEnd;
    LPCWSTR  pszStart = lpCommandLine;

    //
    // Need to look in lpCommandLine for the first token
    //
    LPCWSTR  psz = lpCommandLine;

    while (*psz == L' ' || *psz == L'\t') {
        psz++;
    }

    if (*psz == L'\"') {
        pszStart = psz + 1;
    } else {
        pszStart = psz;
    }

    while (*psz != 0) {
        if (*psz == L'\"') {
            bBraket = !bBraket;
        } else if (*psz == L' ' && !bBraket) {
            break;
        }

        psz++;
    }

    pszEnd = psz;

    //
    // Now walk back to get the caracters.
    //
    psz--;

    if (*psz == L'\"') {
        psz--;
        pszEnd--;
    }

    memcpy(szFullPath + 1, pszStart, (pszEnd - pszStart) * sizeof(WCHAR));
    szFullPath[pszEnd - pszStart + 1] = L'\"';
    szFullPath[pszEnd - pszStart + 2] = 0;

    pszStart = lpCommandLine;

    pszEnd = psz + 1;

    while (psz >= lpCommandLine) {
        if (*psz == L'\\') {
            pszStart = psz + 1;
            break;
        }
        psz--;
    }

    memcpy(szExeName, pszStart, (pszEnd - pszStart) * sizeof(WCHAR));
    szExeName[pszEnd - pszStart] = 0;

    if (g_bIsExplorer) {
        DWORD    dwFlags = 0, id = 0;
        LPVOID   pEnvironmentNew = NULL;

        ReadLayeredStorage(szFullPath, &dwFlags);

        if (dwFlags != LI_WIN95 && dwFlags != LI_NT4 && dwFlags != LI_WIN98) {
            //
            // no layer support
            //

            LOGN(
                eDbgLevelInfo,
                "[AddSupport] No Layer specified for \"%S\".",
                lpCommandLine);

            return TRUE;
        }

        // we are using layer -- clone the environment
        Status = ShimCloneEnvironment(&pEnvironmentNew, *ppEnvironment, !!(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT));
        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[AddSupport] Failed to Clone the environment. Status = 0x%x",
                Status);
            return FALSE;
        }

        if (LI_WIN95 == dwFlags) {
            Status = ShimSetEnvironmentVar(&pEnvironmentNew, g_wszCompatLayerVar, L"Win95");

            LOGN( eDbgLevelInfo, "[AddSupport] Env var \"Win95\" added.");

        } else if (LI_WIN98 == dwFlags) {
            Status = ShimSetEnvironmentVar(&pEnvironmentNew, g_wszCompatLayerVar, L"Win98");

            LOGN( eDbgLevelInfo, "[AddSupport] Env var \"Win98\" added.");

        } else if (LI_NT4 == dwFlags) {
            Status = ShimSetEnvironmentVar(&pEnvironmentNew, g_wszCompatLayerVar, L"NT4SP5");

            LOGN( eDbgLevelInfo, "[AddSupport] Env var \"NT4SP5\" added.");

        }

        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[AddSupport] Failed to set the environment variable. Status = 0x%x",
                Status);
            ShimFreeEnvironment(pEnvironmentNew);
            return FALSE;
        }

        //
        // We have succeeded, set the output values.
        //
        *ppEnvironment = pEnvironmentNew;
        *lpdwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;

    } else {
        //
        // not explorer - set the environment variable up
        // compat_layer will be inherited by the child process if bUserEnvironment is FALSE
        //
        if (bUserEnvironment) {

            //
            // Clone the environment and add the layer variable to the new env.
            //
            Status = ShimCloneEnvironment(&pEnvironmentNew,
                                            *ppEnvironment,
                                            !!(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT));
            if (!NT_SUCCESS(Status)) {
                LOGN(
                    eDbgLevelError,
                    "[AddSupport] Failed to clone the environment. Status = 0x%x",
                    Status);
                return FALSE;
            }

            Status = ShimSetEnvironmentVar(&pEnvironmentNew,
                                           g_wszCompatLayerVar,
                                           g_pwszCompatLayer);

            if (!NT_SUCCESS(Status)) {
                ShimFreeEnvironment(pEnvironmentNew);
                LOGN(
                    eDbgLevelError,
                    "[AddSupport] Failed to set compat layer variable. Status = 0x%x",
                    Status);
                return FALSE;
            }

            LOGN(
                eDbgLevelInfo,
                "[AddSupport] Env var \"%S\" added.",
                g_pwszCompatLayer);

            *ppEnvironment = pEnvironmentNew;
            *lpdwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;
        }
    }

    //
    // Build the registry key.
    //
    swprintf(szKey, L"%s\\%s", APPCOMPAT_KEY, szExeName);

    if (RegCreateKeyW(HKEY_LOCAL_MACHINE, szKey, &hkey) != ERROR_SUCCESS) {
        LOGN(
            eDbgLevelError,
            "Failed to open/create the appcompat key \"%s\"",
            szKey);
    } else {
        if (RegQueryValueExA(hkey, "DllPatch-x", NULL, &type, NULL, &cbData) != ERROR_SUCCESS) {

            BYTE data[16] = {0x0c, 0, 0, 0, 0, 0, 0, 0,
                             0x06, 0, 0, 0, 0, 0, 0, 0};

            //
            // The value doesn't exist. Create it.
            //
            RegSetValueExA(hkey,
                           "y",
                           NULL,
                           REG_BINARY,
                           data,
                           sizeof(data));

            data[0] = 0;

            RegSetValueExA(hkey,
                           "DllPatch-y",
                           NULL,
                           REG_SZ,
                           data,
                           2);
        }
    }

    RegCloseKey(hkey);

    //
    // Finally, set a separate vdm flag
    // if we are here, it means that we are running under the layer
    // and the next exe is going to be shimmed.
    //
    *lpdwCreationFlags &= ~CREATE_SHARED_WOW_VDM;
    *lpdwCreationFlags |= CREATE_SEPARATE_WOW_VDM;

    return TRUE;
}


LPVOID
ShimCreateWowEnvironment_U(
    LPVOID lpEnvironment,       // pointer to the existing environment
    DWORD* lpdwFlags,           // process creation flags
    BOOL   bNewEnvironment      // when set, forces us to clone environment ptr
    )
{
    WOWENVDATA     WowEnvData   = { 0 };
    LPVOID         lpEnvRet     = lpEnvironment;
    LPVOID         lpEnvCurrent = NULL;
    NTSTATUS       Status       = STATUS_SUCCESS;
    DWORD          dwFlags      = *lpdwFlags;
    UNICODE_STRING ustrProcessHistory = { 0 };
    ANSI_STRING    strProcessHistory  = { 0 };
    DWORD          dwProcessHistoryLength = 0;
    UNICODE_STRING ustrCompatLayer    = { 0 };
    ANSI_STRING    strCompatLayer     = { 0 };

    if (!ShimRetrieveVariablesEx(&WowEnvData)) {
        //
        // If no data, we have failed. Return the current data.
        //
        goto Fail;
    }

    if (bNewEnvironment) {
        Status = ShimCloneEnvironment(&lpEnvCurrent,
                                      lpEnvironment,
                                      !!(dwFlags & CREATE_UNICODE_ENVIRONMENT));
        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] Failed to clone the environment. Status = 0x%x",
                Status);
            goto Fail;
        }
    } else {
        lpEnvCurrent = lpEnvironment;
    }

    //
    // Now we are ready to set the environment in place.
    //

    //
    // Nuke the existing process history first. We don't care for the return result.
    //
    RtlSetEnvironmentVariable(&lpEnvCurrent, &g_ustrProcessHistoryVar, NULL);

    if (WowEnvData.pszProcessHistory != NULL ||
        WowEnvData.pszCurrentProcessHistory != NULL) {

        //
        // Convert the process history which consists of 2 strings.
        //
        // The length is the existing process history length + 1 (for ';') +
        // new process history length + 1 (for '\0')
        //
        dwProcessHistoryLength = ((WowEnvData.pszProcessHistory == NULL) ? 0 : (strlen(WowEnvData.pszProcessHistory) + 1)) +
                                 ((WowEnvData.pszCurrentProcessHistory == NULL) ? 0 : strlen(WowEnvData.pszCurrentProcessHistory)) + 1;

        //
        // Allocate process history buffer and convert it, allocating resulting unicode string.
        //
        strProcessHistory.Buffer = (PCHAR)ShimMalloc(dwProcessHistoryLength);

        if (strProcessHistory.Buffer == NULL) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] failed to allocate %d bytes for process history.",
                dwProcessHistoryLength);
            Status = STATUS_NO_MEMORY;
            goto Fail;
        }

        strProcessHistory.MaximumLength = (USHORT)dwProcessHistoryLength;

        if (WowEnvData.pszProcessHistory != NULL) {
            strcpy(strProcessHistory.Buffer, WowEnvData.pszProcessHistory);
            strProcessHistory.Length = strlen(WowEnvData.pszProcessHistory);
        } else {
            strProcessHistory.Length = 0;
        }

        if (WowEnvData.pszCurrentProcessHistory != NULL) {

            //
            // Append ';' if the string was not empty.
            //
            if (strProcessHistory.Length) {
                Status = RtlAppendAsciizToString(&strProcessHistory, ";");
                if (!NT_SUCCESS(Status)) {
                    LOGN(
                        eDbgLevelError,
                        "[ShimCreateWowEnvironment_U] failed to append ';' to the process history. Status = 0x%x",
                        Status);
                    goto Fail;
                }
            }

            Status = RtlAppendAsciizToString(&strProcessHistory,
                                             WowEnvData.pszCurrentProcessHistory);
            if (!NT_SUCCESS(Status)) {
                LOGN(
                    eDbgLevelError,
                    "[ShimCreateWowEnvironment_U] failed to build the process history. Status = 0x%x",
                    Status);
                goto Fail;
            }

        }

        //
        // Convert the process history.
        //
        Status = RtlAnsiStringToUnicodeString(&ustrProcessHistory, &strProcessHistory, TRUE);
        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] failed to convert process history to UNICODE. Status = 0x%x",
                Status);
            goto Fail;
        }

        //
        // Now we can set the process history.
        //
        Status = RtlSetEnvironmentVariable(&lpEnvCurrent,
                                           &g_ustrProcessHistoryVar,
                                           &ustrProcessHistory);
        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] failed to set the process history. Status = 0x%x",
                Status);
            goto Fail;
        }
    }

    //
    // Now we pass along any compat layer that we might have.
    //
    if (g_pwszCompatLayer != NULL) {

        //
        // Pass along this thing, we have been started under layer.
        //
        LOGN(
            eDbgLevelInfo,
            "[ShimCreateWowEnvironment_U] Propagating CompatLayer from the ntvdm environment __COMPAT_LAYER=\"%S\"",
            g_pwszCompatLayer);

        RtlInitUnicodeString(&ustrCompatLayer, g_pwszCompatLayer);

        Status = RtlSetEnvironmentVariable(&lpEnvCurrent, &g_ustrCompatLayerVar, &ustrCompatLayer);

        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] Failed to set compatlayer environment variable. Status = 0x%x",
                Status);
            goto Fail;
        }

    } else if (WowEnvData.pszCompatLayerVal != NULL) {

        LOGN(
            eDbgLevelInfo,
            "[ShimCreateWowEnvironment_U] Propagating CompatLayer from the parent WOW app \"%s\"",
            WowEnvData.pszCompatLayer);

        RtlInitString(&strCompatLayer, WowEnvData.pszCompatLayerVal);

        Status = RtlAnsiStringToUnicodeString(&ustrCompatLayer, &strCompatLayer, TRUE);
        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] Failed to convert compatlayer to UNICODE. Status = 0x%x",
                Status);
            goto Fail;
        }

        Status = RtlSetEnvironmentVariable(&lpEnvCurrent, &g_ustrCompatLayerVar, &ustrCompatLayer);

        RtlFreeUnicodeString(&ustrCompatLayer);

        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] Failed to set compatlayer environment variable. Status = 0x%x",
                Status);
            goto Fail;
        }
    }

    //
    // We have been successful. The return environment is UNICODE now.
    //
    lpEnvRet   = (LPVOID)lpEnvCurrent;
    *lpdwFlags = dwFlags | CREATE_UNICODE_ENVIRONMENT;
    Status     = STATUS_SUCCESS;

Fail:

    if (!NT_SUCCESS(Status) && lpEnvCurrent != NULL && bNewEnvironment) {
        //
        // This points to the cloned environment ALWAYS.
        //
        RtlDestroyEnvironment(lpEnvCurrent);
    }

    RtlFreeUnicodeString(&ustrProcessHistory);

    if (strProcessHistory.Buffer != NULL) {
        ShimFree(strProcessHistory.Buffer);
    }

    //
    // This call is only necessary when using ShimRetrieveVariables.
    // It is not needed when using ShimRetrieveVariablesEx.
    //
    // ShimFreeWOWEnvData(&WowEnvData);
    //

    return lpEnvRet;
}

ULONG
Win2kPropagateLayerExceptionHandler(
    PEXCEPTION_POINTERS pexi,
    char*               szFile,
    DWORD               dwLine
    )
{
    LOGN(
        eDbgLevelError,
        "[Win2kPropagateLayerExceptionHandler] %#x in module \"%s\", line %d,"
        " at address %#p. flags:%#x. !exr %#p !cxr %#p",
        pexi->ExceptionRecord->ExceptionCode,
        szFile,
        dwLine,
        CONTEXT_TO_PROGRAM_COUNTER(pexi->ContextRecord),
        pexi->ExceptionRecord->ExceptionFlags,
        pexi->ExceptionRecord,
        pexi->ContextRecord);

#if DBG
    DbgBreakPoint();
#endif // DBG

    return EXCEPTION_EXECUTE_HANDLER;
}

/*++

    Stub functions that are intercepted from WOW initialization code
    (through APIHook_UserRegisterWowHandlers)
    
--*/



NSWOWUSERP::PFNINITTASK   g_pfnInitTask;
NSWOWUSERP::PFNWOWCLEANUP g_pfnWowCleanup;

BOOL WINAPI
StubInitTask(
    UINT   dwExpWinVer,
    DWORD  dwAppCompatFlags,
    LPCSTR lpszModName,
    LPCSTR lpszBaseFileName,
    DWORD  hTaskWow,
    DWORD  dwHotkey,
    DWORD  idTask,
    DWORD  dwX,
    DWORD  dwY,
    DWORD  dwXSize,
    DWORD  dwYSize
    )
{
    BOOL bReturn;
    
    bReturn = g_pfnInitTask(dwExpWinVer,
                            dwAppCompatFlags,
                            lpszModName,
                            lpszBaseFileName,
                            hTaskWow,
                            dwHotkey,
                            idTask,
                            dwX,
                            dwY,
                            dwXSize,
                            dwYSize);
    if (bReturn) {
        CheckAndShimNTVDM((WORD)hTaskWow);
        UpdateWowTaskList((WORD)hTaskWow);
    }


    return bReturn;
}


BOOL WINAPI
StubWowCleanup(
    HANDLE hInstance,
    DWORD  hTaskWow
    )
{
    BOOL bReturn;

    bReturn = g_pfnWowCleanup(hInstance, hTaskWow);

    if (bReturn) {
        CleanupWowTaskList((WORD)hTaskWow);
    }

    return bReturn;
}


/*++
    APIHook_UserRegisterWowHandlers

        Trap InitTask and WowCleanup functions and
        replace them with stubs

--*/

ULONG_PTR
APIHOOK(UserRegisterWowHandlers)(
    NSWOWUSERP::APFNWOWHANDLERSIN  apfnWowIn,
    NSWOWUSERP::APFNWOWHANDLERSOUT apfnWowOut
    )
{
    ULONG_PTR ulRet;

    ulRet = ORIGINAL_API(UserRegisterWowHandlers)(apfnWowIn, apfnWowOut);

    g_pfnInitTask = apfnWowOut->pfnInitTask;
    apfnWowOut->pfnInitTask = StubInitTask;

    g_pfnWowCleanup = apfnWowOut->pfnWOWCleanup;
    apfnWowOut->pfnWOWCleanup = StubWowCleanup;

    return ulRet;
}

BOOL 
CheckWOWExe(
    LPCWSTR lpApplicationName,
    LPVOID  lpEnvironment, 
    LPDWORD lpdwCreationFlags
    )
{
    BOOL bSuccess;
    BOOL bReturn = FALSE;
    NTSTATUS Status;
    LPVOID pEnvironmentNew = lpEnvironment;
    SDBQUERYRESULT QueryResult;
    DWORD dwBinaryType = 0;
    HSDB hSDB = NULL;
    DWORD dwExes;
    WCHAR wszAppName[MAX_PATH];

    bSuccess = GetFileNameFromCmdLine(wszAppName, CHARCOUNT(wszAppName), lpApplicationName);
    if (!bSuccess) {
        return FALSE;
    }
    
    bSuccess = GetBinaryTypeW(wszAppName, &dwBinaryType);
    if (!bSuccess || dwBinaryType != SCS_WOW_BINARY) {
        LOGN( eDbgLevelInfo, "[CheckWowExe] can't get binary type\n");
        return FALSE;
    }

    //
    // for these binaries we shall perform the good deed of running the detection
    //
    hSDB = SdbInitDatabase(0, NULL);
    if (hSDB == NULL) {
        LOGN( eDbgLevelError, "[CheckWowExe] Failed to init the database.");
        return FALSE;
    }
  
    if (lpEnvironment != NULL && !(*lpdwCreationFlags & CREATE_UNICODE_ENVIRONMENT)) { // non-null unicode env?
        Status = ShimCloneEnvironment(&pEnvironmentNew, 
                                      lpEnvironment, 
                                      FALSE); 
        if (!NT_SUCCESS(Status)) {
            LOGN( eDbgLevelError, "[ShimCloneEnvironment] failed with status 0x%lx\n", Status);
            goto cleanup;
        }
    }

    //
    // all parameters below have to be unicode
    //
    
    dwExes = SdbGetMatchingExe(hSDB,
                               wszAppName,
                               NULL,
                               (LPCWSTR)pEnvironmentNew,
                               0,
                               &QueryResult);
    bSuccess = (QueryResult.atrExes  [0] != TAGREF_NULL || 
                QueryResult.atrLayers[0] != TAGREF_NULL);

    //
    // if we have been successful -- layers apply to this thing
    //

    if (!bSuccess) {
        goto cleanup;
    }

    //
    // set the separate ntvdm flag and be on our way out
    //
    *lpdwCreationFlags &= ~CREATE_SHARED_WOW_VDM;
    *lpdwCreationFlags |= CREATE_SEPARATE_WOW_VDM;
    
    bReturn = TRUE;
    
cleanup:

    if (pEnvironmentNew != lpEnvironment) {
        ShimFreeEnvironment(pEnvironmentNew);
    }

    if (hSDB) {
        SdbReleaseDatabase(hSDB);
    }     

    return bReturn;
}

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                  lpApplicationName,
    LPSTR                   lpCommandLine,
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes,
    BOOL                    bInheritHandles,
    DWORD                   dwCreationFlags,
    LPVOID                  lpEnvironment,
    LPCSTR                  lpCurrentDirectory,
    LPSTARTUPINFOA          lpStartupInfo,
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    BOOL   bRet;
    LPVOID lpEnvironmentNew        = lpEnvironment;
    DWORD  dwCreationFlagsOriginal = dwCreationFlags;
    LPSTR  pszApp                  = NULL;

    LOGN(
        eDbgLevelError,
        "[CreateProcessA] called for:");

    LOGN(
        eDbgLevelError,
        "[CreateProcessA]    lpApplicationName : \"%s\"",
        (lpApplicationName == NULL ? "null": lpApplicationName));

    LOGN(
        eDbgLevelError,
        "[CreateProcessA]    lpCommandLine     : \"%s\"",
        (lpCommandLine == NULL ? "null": lpCommandLine));

    if (lpApplicationName != NULL) {
        pszApp = (LPSTR)lpApplicationName;
    } else if (lpCommandLine != NULL) {
        pszApp = lpCommandLine;
    } else {
        LOGN(
            eDbgLevelError,
            "[CreateProcessA] called with NULL params.");
    }

    __try {

        WCHAR wszApp[MAX_PATH];

        if (pszApp != NULL) {
        
            MultiByteToWideChar(CP_ACP,
                                0,
                                pszApp,
                                -1,
                                wszApp,
                                MAX_PATH);

            AddSupport(wszApp, &lpEnvironmentNew, &dwCreationFlags);
        }

        if (g_bIsNTVDM) {

            //
            // if the environment stayed the same as it was passed in -- clone it to propagate process history
            // if it was modified in AddSupport -- use it
            //

            lpEnvironmentNew = ShimCreateWowEnvironment_U(lpEnvironmentNew,
                                                          &dwCreationFlags,
                                                          lpEnvironmentNew == lpEnvironment);
        }
    

        if (pszApp != NULL && !(dwCreationFlags & CREATE_SEPARATE_WOW_VDM)) {
            // since the separate vdm flag is not set -- we need to determine whether we have 
            // any kind of fixes to care about. 
            CheckWOWExe(wszApp, lpEnvironmentNew, &dwCreationFlags);
        }


    } __except(WOWPROCESSHISTORYEXCEPTIONFILTER) {

        //
        // cleanup the mess, if we have allocated the environment, free it now
        //
        if (lpEnvironmentNew != lpEnvironment) {

            ShimFreeEnvironment(lpEnvironmentNew);

            lpEnvironmentNew = lpEnvironment;
        }
    }


    bRet = ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                        lpCommandLine,
                                        lpProcessAttributes,
                                        lpThreadAttributes,
                                        bInheritHandles,
                                        dwCreationFlags,
                                        lpEnvironmentNew,
                                        lpCurrentDirectory,
                                        lpStartupInfo,
                                        lpProcessInformation);

    if (lpEnvironmentNew != lpEnvironment) {
        //
        // The function below does not need a __try/__except wrapper, it has it internally
        //
        ShimFreeEnvironment(lpEnvironmentNew);
    }

    return bRet;
}

BOOL
APIHOOK(CreateProcessW)(
    LPCWSTR                 lpApplicationName,
    LPWSTR                  lpCommandLine,
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes,
    BOOL                    bInheritHandles,
    DWORD                   dwCreationFlags,
    LPVOID                  lpEnvironment,
    LPCWSTR                 lpCurrentDirectory,
    LPSTARTUPINFOW          lpStartupInfo,
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    LPWSTR pszApp = NULL;
    BOOL   bRet;
    LPVOID lpEnvironmentNew = lpEnvironment;

    LOGN(
        eDbgLevelInfo,
        "[CreateProcessW] called for:");

    LOGN(
        eDbgLevelInfo,
        "[CreateProcessW]    lpApplicationName : \"%S\"",
        (lpApplicationName == NULL ? L"null": lpApplicationName));

    LOGN(
        eDbgLevelInfo,
        "[CreateProcessW]    lpCommandLine     : \"%S\"",
        (lpCommandLine == NULL ? L"null": lpCommandLine));

    if (lpApplicationName != NULL) {
        pszApp = (LPWSTR)lpApplicationName;
    } else if (lpCommandLine != NULL) {
        pszApp = lpCommandLine;
    } else {
        LOGN(
            eDbgLevelError,
            "[CreateProcessW] called with NULL params.");
    }

    __try {

        if (pszApp != NULL) {

            AddSupport(pszApp, &lpEnvironmentNew, &dwCreationFlags);
        }

        if (g_bIsNTVDM) {

            lpEnvironmentNew = ShimCreateWowEnvironment_U(lpEnvironmentNew,
                                                          &dwCreationFlags,
                                                          lpEnvironment == lpEnvironmentNew);
        }

        //
        // typically we need to find out whether the current app is ntvdm
        //

        if (!(dwCreationFlags & CREATE_SEPARATE_WOW_VDM)) {
            // since the separate vdm flag is not set -- we need to determine whether we have 
            // any kind of fixes to care about. 
            CheckWOWExe(pszApp, lpEnvironmentNew, &dwCreationFlags);
        }
        
    } __except(WOWPROCESSHISTORYEXCEPTIONFILTER) {

        if (lpEnvironmentNew != lpEnvironment) {

            ShimFreeEnvironment(lpEnvironmentNew);

            lpEnvironmentNew = lpEnvironment; // reset the pointer
        }
    }

    bRet = ORIGINAL_API(CreateProcessW)(lpApplicationName,
                                        lpCommandLine,
                                        lpProcessAttributes,
                                        lpThreadAttributes,
                                        bInheritHandles,
                                        dwCreationFlags,
                                        lpEnvironmentNew,
                                        lpCurrentDirectory,
                                        lpStartupInfo,
                                        lpProcessInformation);

    if (lpEnvironmentNew != lpEnvironment) {

        ShimFreeEnvironment(lpEnvironmentNew);

    }

    return bRet;
}

BOOL
GetVariableFromEnvironment(
    LPCWSTR pwszVariableName,
    LPWSTR* ppwszVariableValue
    )
{
    DWORD dwLength;
    DWORD dwLen;
    BOOL  bSuccess = FALSE;
    LPWSTR pwszVariableValue = *ppwszVariableValue;

    dwLength = GetEnvironmentVariableW(pwszVariableName, NULL, 0);

    if (dwLength == 0) {
        LOGN(
            eDbgLevelInfo,
            "[GetCompatLayerFromEnvironment] Not under the compatibility layer.");
        *ppwszVariableValue = NULL;
        return FALSE;
    }

    if (pwszVariableValue != NULL) {
        LOGN(
            eDbgLevelError,
            "[GetCompatLayerFromEnvironment] called twice!");
        ShimFree(pwszVariableValue);
        pwszVariableValue = NULL;
    }

    pwszVariableValue = (WCHAR*)ShimMalloc(dwLength * sizeof(WCHAR));

    if (pwszVariableValue == NULL) {
        LOGN(
            eDbgLevelError,
            "[GetCompatLayerFromEnvironment] Failed to allocate %d bytes for Compat Layer.",
            dwLength * sizeof(WCHAR));
        goto out;
    }

    *pwszVariableValue = L'\0';

    dwLen = GetEnvironmentVariableW(pwszVariableName, 
                                  pwszVariableValue, 
                                  dwLength);

    bSuccess = (dwLen != 0 && dwLen < dwLength);

    if (!bSuccess) {
        LOGN(
            eDbgLevelError,
            "[GetCompatLayerFromEnvironment] Failed to get compat layer variable.");
        ShimFree(pwszVariableValue);
        pwszVariableValue = NULL;
    }
    
out:

    *ppwszVariableValue = pwszVariableValue;

    return bSuccess;
}

BOOL 
GetCompatLayerFromEnvironment(
    VOID
    )
{
    return GetVariableFromEnvironment(g_wszCompatLayerVar, &g_pwszCompatLayer);
}


BOOL 
GetSeparateWowPtr(
    VOID
    )
{

    HMODULE hMod = GetModuleHandle(NULL);
    
    g_pSeparateWow = (BOOL*)GetProcAddress(hMod, "fSeparateWow");
    if (g_pSeparateWow == NULL) {
        LOGN( eDbgLevelError, "[GetSeparateWowPtr] Failed 0x%lx\n", GetLastError());
        return FALSE;
    }    

    return TRUE;
}


VOID
ParseCommandLine(
    LPCSTR commandLine
    )
{
    int   i;
    char* pArg;

    g_argc = 0;
    g_argv = NULL;

    g_bIsNTVDM    = FALSE;
    g_bIsExplorer = FALSE;

    g_argv = _CommandLineToArgvA(commandLine, &g_argc);

    if (0 == g_argc || NULL == g_argv) {
        return; // nothing to do
    }

    for (i = 0; i < g_argc; ++i) {
        pArg = g_argv[i];

        if (!_strcmpi(pArg, "ntvdm")) {
            LOGN( eDbgLevelInfo, "[ParseCommandLine] Running NTVDM.");
            g_bIsNTVDM = TRUE;

        } else if (!_strcmpi(pArg, "explorer")) {
            LOGN( eDbgLevelInfo, "[ParseCommandLine] Running Explorer.");
            g_bIsExplorer = TRUE;

        } else {
            LOGN(
                eDbgLevelError,
                "[ParseCommandLine] Unrecognized argument: \"%s\"",
                pArg);
        }
    }

    if (g_bIsNTVDM && g_bIsExplorer) {
        LOGN(
            eDbgLevelError,
            "[ParseCommandLine] Conflicting arguments! Neither will be applied.");
        g_bIsNTVDM    = FALSE;
        g_bIsExplorer = FALSE;
    }
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    OSVERSIONINFO osvi;
    BOOL          bHook = FALSE;
    DWORD         dwCompatLayerLength;
    DWORD         dwLen;

    if (fdwReason != DLL_PROCESS_ATTACH) {
        return TRUE;
    }

    osvi.dwOSVersionInfoSize = sizeof(osvi);

    GetVersionEx(&osvi);

    if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) {

        ParseCommandLine(COMMAND_LINE);

        InitLayerStorage(FALSE);

        CleanupRegistryForCurrentExe();

        if (g_bIsNTVDM) {

            bHook = TRUE;

            //
            // Retrieve the compat layer variable that we have been started with (just in case)
            //
            GetCompatLayerFromEnvironment();

            GetSeparateWowPtr(); // retrieve ptr to a sep flag

        } else if (g_bIsExplorer) {

            //
            // Cleanup compat layer variable
            //
            SetEnvironmentVariableW(g_wszCompatLayerVar, NULL);
            bHook = TRUE;

        } else {
            //
            // Neither explorer nor ntvdm. Get the compat layer.
            //
            bHook = GetCompatLayerFromEnvironment();
            if (!bHook) {
                LOGN(
                    eDbgLevelInfo,
                    "[NOTIFY_FUNCTION] Not under the compatibility layer.");
            }
        }
    }

    if (bHook) {
        APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
        APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)
        APIHOOK_ENTRY(USER32.DLL,   UserRegisterWowHandlers)
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\win2kpropagatelayer_environment.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Environment.Cpp

 Abstract:

   Various environment-related function

 Notes:

   Cloning environment for the purpose of using it in Rtl* environment-related functions

 History:

   10/26/00 VadimB  Created

--*/


#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(Win2kPropagateLayer)
#include "ShimHookMacro.h"

#include "Win2kPropagateLayer.h"
//
//  This is so we can compare offsets if we know the segments are equal
//

#define OFFSET(x) (LOWORD((DWORD)(x)))
//
//  I'm cheating here to make some functions a little faster;
//  we won't have to push a word on the stack every time
//

static WORD gwMatch;

// 
//  ChrCmp -  Case sensitive character comparison for DBCS
//  Assumes   w1, gwMatch are characters to be compared
//  Return    FALSE if they match, TRUE if no match
//

static BOOL ChrCmp( WORD w1 )
{
    //
    //  Most of the time this won't match, so test it first for speed.
    //

    if( LOBYTE( w1 ) == LOBYTE( gwMatch ) )
    {
        if( IsDBCSLeadByte( LOBYTE( w1 ) ) )
        {
            return( w1 != gwMatch );
        }
        return FALSE;
    }
    return TRUE;
}

//
//  StrRChr - Find last occurrence of character in string
//  Assumes   lpStart points to start of string
//            lpEnd   points to end of string (NOT included in search)
//            wMatch  is the character to match
//  returns ptr to the last occurrence of ch in str, NULL if not found.
//

static LPSTR StrRChr( LPSTR lpStart, LPSTR lpEnd, WORD wMatch )
{
    LPSTR lpFound = NULL;

    if( !lpEnd )
        lpEnd = lpStart + strlen( lpStart );

    gwMatch = wMatch;

    for(  ; OFFSET( lpStart ) < OFFSET( lpEnd ); lpStart = CharNextA( lpStart ) )
    {
        if( !ChrCmp( *(LPWORD)lpStart ) )
            lpFound = lpStart;
    }

    return( lpFound );
}


//
// Find environment variable pszName within the buffer pszEnv
// ppszVal receives pointer to the variable's value
//

PSZ
ShimFindEnvironmentVar(
    PSZ  pszName,
    PSZ  pszEnv,
    PSZ* ppszVal
    )
{
    int nNameLen = strlen(pszName);
    PSZ pTemp;

    if (pszEnv != NULL) {

        while (*pszEnv != '\0') {
            //
            // Check the first char to be speedy.
            //
            if (*pszName == *pszEnv) {
                //
                // Compare the rest now.
                //
                if ((pTemp = StrRChr(pszEnv, NULL, '=')) != NULL &&
                    (int)(pTemp - pszEnv) == nNameLen &&
                    !_strnicmp(pszEnv, pszName, nNameLen)) {
                    
                    //
                    // Found it.
                    //
                    if (ppszVal != NULL) {
                        *ppszVal = pTemp + 1;
                    }
                    return pszEnv;
                }
            }

            pszEnv += strlen(pszEnv) + 1;
        }
    }

    return NULL;
}

//
// returns size in characters
// of an env block
// pStrCount receives the number of env strings
//
DWORD
ShimGetEnvironmentSize(
    PSZ     pszEnv,
    LPDWORD pStrCount
    )
{
    PSZ   pTemp   = pszEnv;
    DWORD dwCount = 0;

    while (*pTemp != '\0') {
        dwCount++;
        pTemp += strlen(pTemp) + 1;
    }
    
    pTemp++;

    if (pStrCount != NULL) {
        *pStrCount = dwCount;
    }
    return (DWORD)(pTemp - pszEnv);
}

// returns size (in characters) of an environment block

DWORD
ShimGetEnvironmentSize(
    WCHAR*  pwszEnv,
    LPDWORD pStrCount
    )
{
    WCHAR* pTemp   = pwszEnv;
    DWORD  dwCount = 0;

    while(*pTemp != L'\0') {
        dwCount++;
        pTemp += wcslen(pTemp) + 1;
    }
    
    pTemp++; // include terminating '\0'

    if (pStrCount != NULL) {
        *pStrCount = dwCount;
    }

    return (DWORD)(pTemp - pwszEnv);

}

//
// returns cloned (unicode) environment
//

NTSTATUS
ShimCloneEnvironment(
    LPVOID* ppEnvOut,
    LPVOID  lpEnvironment,
    BOOL    bUnicode
    )
{
    NTSTATUS Status    = STATUS_INVALID_PARAMETER;
    DWORD    dwEnvSize = 0;
    LPVOID   lpEnvNew  = NULL;

    MEMORY_BASIC_INFORMATION MemoryInformation;

    if (lpEnvironment == NULL) {
        Status = RtlCreateEnvironment(TRUE, &lpEnvNew);
    } else {

        //
        // Find the environment's size in characters but recalc in unicode.
        //
        dwEnvSize = (bUnicode ? ShimGetEnvironmentSize((WCHAR*)lpEnvironment, NULL) :
                                ShimGetEnvironmentSize((PSZ)lpEnvironment, NULL));

        //
        // Allocate memory -- using Zw routines (that is what rtl is using).
        //
        MemoryInformation.RegionSize = (dwEnvSize + 2) * sizeof(UNICODE_NULL);
        Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
                                         &lpEnvNew,
                                         0,
                                         &MemoryInformation.RegionSize,
                                         MEM_COMMIT,
                                         PAGE_READWRITE);

        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCloneEnvironment] Failed to allocate %d bytes for the environment block.",
                dwEnvSize * sizeof(UNICODE_NULL));
            return Status;
        }

        if (bUnicode) {
            //
            // Unicode, just copy the environment
            //
            RtlMoveMemory(lpEnvNew, lpEnvironment, dwEnvSize * sizeof(UNICODE_NULL));

        } else {

            //
            // The environment is ANSI, so we need to convert.
            //
            UNICODE_STRING UnicodeBuffer;
            ANSI_STRING    AnsiBuffer;

            AnsiBuffer.Buffer = (CHAR*)lpEnvironment;
            AnsiBuffer.Length = AnsiBuffer.MaximumLength = (USHORT)dwEnvSize; // size in bytes = size in chars, includes \0\0

            UnicodeBuffer.Buffer        = (WCHAR*)lpEnvNew;
            UnicodeBuffer.Length        = (USHORT)dwEnvSize * sizeof(UNICODE_NULL);
            UnicodeBuffer.MaximumLength = (USHORT)(dwEnvSize + 2) * sizeof(UNICODE_NULL); // leave room for \0

            Status = RtlAnsiStringToUnicodeString(&UnicodeBuffer, &AnsiBuffer, FALSE);
            if (!NT_SUCCESS(Status)) {
                LOGN(
                    eDbgLevelError,
                    "[ShimCloneEnvironment] Failed to convert ANSI environment to UNICODE. Status = 0x%x",
                    Status);
            }
        }
    }

    if (NT_SUCCESS(Status)) {

        *ppEnvOut = lpEnvNew;

    } else {

        if (lpEnvNew != NULL) {
            RtlDestroyEnvironment(lpEnvNew);
        }
    }

    return Status;

}

NTSTATUS
ShimFreeEnvironment(
    LPVOID lpEnvironment
    )
{
    NTSTATUS Status;

    __try {

        Status = RtlDestroyEnvironment(lpEnvironment);
        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimFreeEnvironment] RtlDestroyEnvironment failed. Status = 0x%x",
                Status);
        }
    } __except(WOWPROCESSHISTORYEXCEPTIONFILTER) {

        Status = STATUS_ACCESS_VIOLATION;

    }

    return Status;
}

//
// Set environment variable, possibly create or clone provided environment
//

NTSTATUS
ShimSetEnvironmentVar(
    LPVOID* ppEnvironment,
    WCHAR*  pwszVarName,
    WCHAR*  pwszVarValue
    )
{
    UNICODE_STRING ustrVarName;
    UNICODE_STRING ustrVarValue;
    NTSTATUS       Status;

    RtlInitUnicodeString(&ustrVarName, pwszVarName);
    
    if (NULL != pwszVarValue) {
        RtlInitUnicodeString(&ustrVarValue, pwszVarValue);
    }
    
    Status = RtlSetEnvironmentVariable(ppEnvironment,
                                       &ustrVarName,
                                       (NULL == pwszVarValue) ? NULL : &ustrVarValue);
    if (!NT_SUCCESS(Status)) {
        LOGN(
            eDbgLevelError,
            "[ShimSetEnvironmentVar] RtlSetEnvironmentVariable failed. Status = 0x%x",
            Status);
    }

    return Status;
}

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\winexecraceconditionfix.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WinExecRaceConditionFix.cpp

 Abstract:

    This Shim uses the command line parameter to indicate how it works:

    If passed 'nowait', it enables the WinExec functionality:
    The WinExec in this DLL is identical to the actual WinExec API but without
    the WaitForUserinputIdleRoutine, which inverts an almost race condition 
    between the launcher and the launchee.  9x does not have this wait, so the
    programmers were able to (possibly inadvertently) use the same window class
    exclusion matching for both since, in 9x, the launcher kills itself before
    the launchee can check for a duplicate window.  This shim leaves out the
    wait condition, allowing 9x like behavior.

    If passed a number, it sleeps in initialization for that number of
    microseconds.

 Notes:

    This shim has no app specific information.

 History:

    03/22/2000 a-charr  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WinExecRaceConditionFix)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WinExec)
APIHOOK_ENUM_END

/*++

 This function breaks into WinExec and calls CreateProcessA without
 waiting afterward.
  
--*/

UINT 
APIHOOK(WinExec)(
    LPCSTR lpCmdLine, 
    UINT   uCmdShow 
    )
/*++

 This is a direct copy of the actual WinExec API minus two sections,

 1. UserWaitForInputIdleRoutine is removed because it is waiting for the spawned 
    process to begin its event loop, but the spawned process is killing itself 
    before starting the event loop because the spawning process is waiting for 
    it.

 2. Some app specific appcompat code that seems to be hanging around from who
    knows when.
      
--*/
{
    STARTUPINFOA        StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL                CreateProcessStatus;
    DWORD               ErrorCode;
    
    LOGN(
        eDbgLevelInfo,
        "[WinExec] Called. Returning without waiting for new process to start.");
    
    RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
    
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = (WORD)uCmdShow;
    
    CreateProcessStatus = CreateProcessA(
        NULL,
        (LPSTR)lpCmdLine,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation);
    
    if (CreateProcessStatus) {
        return 33;
    } else {
        ErrorCode = GetLastError();
        
        switch (ErrorCode) {
        case ERROR_FILE_NOT_FOUND:
            return 2;
            
        case ERROR_PATH_NOT_FOUND:
            return 3;
            
        case ERROR_BAD_EXE_FORMAT:
            return 11;
            
        default:
            return 0;
        }
    }
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Sleep when starting up, if the command line is a number.
        //
        long lSleepTicks = atol(COMMAND_LINE);

        if (lSleepTicks > 0) {
            Sleep((DWORD)lSleepTicks);
        }
    }

    return TRUE;
}


/*++

  Register hooked functions
  
--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, WinExec)
    
    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\winnt4sp5versionlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WinNT4SP5VersionLie.cpp

 Abstract:

   This DLL APIHooks GetVersion and GetVersionEx so that they return Windows NT
   Service Pack 5 version credentials. Applications often check to ensure that 
   they are running on a certain Win NTsystem, even though the current system 
   is of higher build then the one they are checking for.

 Notes:

   This is a general purpose shim.

 History:

    11/10/1999 v-johnwh Created

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(WinNT4SP5VersionLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA) 
    APIHOOK_ENUM_ENTRY(GetVersionExW) 
    APIHOOK_ENUM_ENTRY(GetVersion) 
APIHOOK_ENUM_END


/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows NT Service Pack 5 credentials.

--*/

BOOL 
APIHOOK(GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation)
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExA)(lpVersionInformation))  {
        // Fixup the structure with the NT data
        lpVersionInformation->dwMajorVersion = 4;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber = 1381;
        lpVersionInformation->dwPlatformId = VER_PLATFORM_WIN32_NT;
        strcpy(lpVersionInformation->szCSDVersion, "Service Pack 5");

        DPFN( eDbgLevelInfo, "GetVersionExA called. return NT4 SP5\n");

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is returned to 
 the caller with Win NT Service Pack 5 credentials. This is the 
 wide-character version of GetVersionExW.

--*/

BOOL
APIHOOK(GetVersionExW)(LPOSVERSIONINFOW lpVersionInformation)
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExW)(lpVersionInformation))  {
        // Fixup the structure with the Win NT Service Pack 5 data
        lpVersionInformation->dwMajorVersion = 4;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber = 1381;
        lpVersionInformation->dwPlatformId = VER_PLATFORM_WIN32_NT;
        wcscpy( lpVersionInformation->szCSDVersion, L"Service Pack 5" );

        DPFN( eDbgLevelInfo, "GetVersionExW called. return NT4 SP5\n");
        
        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function returns Windows NT 4.0 credentials.

--*/

DWORD 
APIHOOK(GetVersion)()
{
    DPFN( eDbgLevelInfo, "GetVersion called. return NT4 SP5\n");
    return (DWORD) 0x05650004;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA )
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW )
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion )

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\wowuserp2k.h ===
/******************************Module*Header*******************************\
* Module Name: wowuserp.h                                                  *
*                                                                          *
* Declarations of USER services provided to WOW.                           *
*                                                                          *
* Created: 03-Mar-1993                                                     *
* Author: John Colleran [johnc]                                            *
*                                                                          *
* Copyright (c) 1993-1998 Microsoft Corporation                            *
\**************************************************************************/

#include "w32w64.h"

#pragma pack(1)
typedef struct _NE_MODULE_SEG {
    USHORT ns_sector;
    USHORT ns_cbseg;
    USHORT ns_flags;
    USHORT ns_minalloc;
    USHORT ns_handle;
} NEMODULESEG;
typedef struct _NE_MODULE_SEG UNALIGNED *PNEMODULESEG;
#pragma pack()


// Shared WOW32 prototypes called by USER32.
typedef HLOCAL  (WINAPI *PFNLALLOC)(UINT dwFlags, UINT dwBytes, HANDLE hInstance);
typedef HLOCAL  (WINAPI *PFNLREALLOC)(HLOCAL hMem, UINT dwBytes, UINT dwFlags, HANDLE hInstance, PVOID* ppv);
typedef LPVOID  (WINAPI *PFNLLOCK)(HLOCAL hMem, HANDLE hInstance);
typedef BOOL    (WINAPI *PFNLUNLOCK)(HLOCAL hMem, HANDLE hInstance);
typedef UINT    (WINAPI *PFNLSIZE)(HLOCAL hMem, HANDLE hInstance);
typedef HLOCAL  (WINAPI *PFNLFREE)(HLOCAL hMem, HANDLE hInstance);
typedef WORD    (WINAPI *PFN16GALLOC)(UINT flags, DWORD cb);
typedef VOID    (WINAPI *PFN16GFREE)(WORD h16Mem);
typedef DWORD   (WINAPI *PFNGETMODFNAME)(HANDLE hModule, LPTSTR lpszPath, DWORD cchPath);
typedef VOID    (WINAPI *PFNEMPTYCB)(VOID);
typedef DWORD   (WINAPI *PFNGETEXPWINVER)(HANDLE hModule);
typedef HANDLE  (WINAPI *PFNFINDA)(HANDLE hModule, LPCSTR lpName,  LPCSTR lpType,  WORD wLang);
typedef HANDLE  (WINAPI *PFNFINDW)(HANDLE hModule, LPCWSTR lpName, LPCWSTR lpType, WORD wLang);
typedef HANDLE  (WINAPI *PFNLOAD)(HANDLE hModule, HANDLE hResInfo);
typedef BOOL    (WINAPI *PFNFREE)(HANDLE hResData, HANDLE hModule);
typedef LPSTR   (WINAPI *PFNLOCK)(HANDLE hResData, HANDLE hModule);
typedef BOOL    (WINAPI *PFNUNLOCK)(HANDLE hResData, HANDLE hModule);
typedef DWORD   (WINAPI *PFNSIZEOF)(HANDLE hModule, HANDLE hResInfo);
typedef DWORD   (WINAPI *PFNWOWWNDPROCEX)(HWND hwnd, UINT uMsg, WPARAM uParam, LPARAM lParam, DWORD dw, PVOID adwWOW);
typedef BOOL    (WINAPI *PFNWOWDLGPROCEX)(HWND hwnd, UINT uMsg, WPARAM uParam, LPARAM lParam, DWORD dw, PVOID adwWOW);
typedef int     (WINAPI *PFNWOWEDITNEXTWORD)(LPSTR lpch, int ichCurrent, int cch, int code, DWORD dwProc16);
typedef VOID    (WINAPI *PFNWOWCBSTOREHANDLE)(WORD wFmt, WORD h16);
typedef WORD    (FASTCALL *PFNGETPROCMODULE16)(DWORD vpfn);
typedef VOID    (FASTCALL *PFNWOWMSGBOXINDIRECTCALLBACK)(DWORD vpfnCallback, LPHELPINFO lpHelpInfo);
typedef int     (WINAPI *PFNWOWILSTRCMP)(LPCWSTR lpString1, LPCWSTR lpString2);
typedef VOID    (FASTCALL *PFNWOWTELLWOWTHEHDLG)(HWND hDlg);

// Shared USER32 prototypes called by WOW32
typedef HWND    (WINAPI *PFNCSCREATEWINDOWEX)(DWORD dwExStyle, LPCTSTR lpClassName,
        LPCTSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HANDLE hInstance, LPVOID lpParam, DWORD Flags);
typedef VOID    (WINAPI *PFNDIRECTEDYIELD)(DWORD ThreadId);
typedef VOID    (WINAPI *PFNFREEDDEDATA)(HANDLE hDDE, BOOL fIgnorefRelease, BOOL fFreeTruelyGlobalObjects);
typedef LONG    (WINAPI *PFNGETCLASSWOWWORDS)(HINSTANCE hInstance, LPCTSTR pString);
typedef BOOL    (WINAPI *PFNINITTASK)(UINT dwExpWinVer, DWORD dwAppCompatFlags, LPCSTR lpszModName, LPCSTR lpszBaseFileName, DWORD hTaskWow, DWORD dwHotkey, DWORD idTask, DWORD dwX, DWORD dwY, DWORD dwXSize, DWORD dwYSize);
typedef ATOM    (WINAPI *PFNREGISTERCLASSWOWA)(PVOID lpWndClass, LPDWORD pdwWOWstuff);
typedef BOOL    (WINAPI *PFNREGISTERUSERHUNGAPPHANDLERS)(PFNW32ET pfnW32EndTask, HANDLE hEventWowExec);
typedef HWND    (WINAPI *PFNSERVERCREATEDIALOG)(HANDLE hmod, LPDLGTEMPLATE lpDlgTemplate, DWORD cb, HWND hwndOwner , DLGPROC pfnWndProc, LPARAM dwInitParam, UINT fFlags);
typedef HCURSOR (WINAPI *PFNSERVERLOADCREATECURSORICON)(HANDLE hmod, LPTSTR lpModName, DWORD dwExpWinVer, LPCTSTR lpName, DWORD cb, PVOID pcur, LPTSTR lpType, BOOL fClient);
typedef HMENU   (WINAPI *PFNSERVERLOADCREATEMENU)(HANDLE hMod, LPTSTR lpName, CONST LPMENUTEMPLATE pmt, DWORD cb, BOOL fCallClient);
typedef BOOL    (WINAPI *PFNWOWCLEANUP)(HANDLE hInstance, DWORD hTaskWow);
typedef BOOL    (WINAPI *PFNWOWMODULEUNLOAD)(HANDLE hModule);
typedef HWND    (WINAPI *PFNWOWFINDWINDOW)(LPCSTR lpClassName, LPCSTR lpWindowName);
typedef HBITMAP (WINAPI *PFNWOWLOADBITMAPA)(HINSTANCE hmod, LPCSTR lpName, LPBYTE pResData, DWORD cbResData);
typedef BOOL    (WINAPI *PFNWOWWAITFORMSGANDEVENT)(HANDLE hevent);
typedef BOOL    (WINAPI *PFNYIELDTASK)(VOID);
typedef DWORD   (WINAPI *PFNGETFULLUSERHANDLE)(WORD wHandle);
typedef DWORD   (WINAPI *PFNGETMENUINDEX)(HMENU hMenu, HMENU hSubMenu);
typedef WORD    (WINAPI *PFNWOWGETDEFWINDOWPROCBITS)(PBYTE pDefWindowProcBits, WORD cbDefWindowProcBits);
typedef VOID    (WINAPI *PFNFILLWINDOW)(HWND hwndParent, HWND hwnd, HDC hdc, HANDLE hBrush);

// other prototypes
typedef BOOL    (WINAPI *PFNWOWGLOBALFREEHOOK)(HGLOBAL hMem);


/*
 * MEASUREITEMSTRUCT itemWidth tag telling wow the itemData is a flat pointer
 */
#define MIFLAG_FLAT      0x464C4154

/*
 * CallWindowProc Bits
 */
#define WOWCLASS_RPL_MASK  0x00060000  // the LDT bits that store the 2 high bits
#define WNDPROC_WOWPROC     0xC0000000  // These bits for WOW Window Procs
#define WNDPROC_WOWMASK     0x3fffffff  // To mask off wow bits
#define WNDPROC_HANDLE      0xFFFF      // HIWORD(x) == 0xFFFF for handle

// USER needs a way to distinguish between a WOW and a Win32 window proc. We
// used to achieve this by always setting the MSB of a 16:16 address as 1 (and
// storing the MSB in the Table indicator bit of the LDT which is always 1). The
// MSB of a user mode flat address was guranteed to be never 1 as the user mode
// address space was limited to 2GB. Starting with NT 5.0, user mode address
// space is being increased to 3GB. This change breaks the above assumption
// that a 32bit user mode flat address will never have the MSB as 1.
// To work around this problem, WOW is going to use the  two bits of a
// 16:16 address instead of just one. We will set both these bits as 1 because
// with 3GB address space, the user mode flat addresses cannot have 11 as the
// first two bits. To achieve this, we will save the 2 most significant bits of
// the selector in the bit 1 and bit 2. We are able to do this because for WOW
// because both these bits have fixed values.
//
// SudeepB 21-Nov-1996

#ifndef _WIN64

// MarkWOWProc
// zero out the RPL bits
// get the high two bit in position where they have to be saved
// save the high bits and mark it a wow proc

#define MarkWOWProc(vpfnProc,result)                                  \
{                                                                     \
    ULONG temp1,temp2;                                                \
    temp1 = (ULONG)vpfnProc & ~WOWCLASS_RPL_MASK;                     \
    temp2 = ((ULONG)vpfnProc & WNDPROC_WOWPROC) >> 13;                \
    (ULONG)result = temp1 | temp2 | WNDPROC_WOWPROC;                  \
}

// UnMarkWOWProc
// mask off the marker bits
// get the saved bits to right places
// restore the saved bits and set the RPL field correctly

#define UnMarkWOWProc(vpfnProc,result)                     \
{                                                          \
    ULONG temp1,temp2;                                     \
    temp1 = (ULONG)vpfnProc & WNDPROC_WOWMASK;             \
    temp2 = ((ULONG)vpfnProc & WOWCLASS_RPL_MASK) << 13;   \
    result = temp1 | temp2 | WOWCLASS_RPL_MASK;            \
}

#define IsWOWProc(vpfnProc) (((ULONG)vpfnProc & WNDPROC_WOWPROC) == WNDPROC_WOWPROC)

#else

#define MarkWOWProc(vpfnProc,result)    DBG_UNREFERENCED_PARAMETER(vpfnProc)
#define UnMarkWOWProc(vpfnProc,result)  DBG_UNREFERENCED_PARAMETER(vpfnProc)
#define IsWOWProc(vpfnProc)             (FALSE)

#endif

/*
 * CreateWindow flags
 */
#define CW_FLAGS_ANSI       0x00000001

typedef struct tagAPFNWOWHANDLERSIN
{
    // In'ees - passed from WOW32 to USER32 and called by USER32
    PFNLALLOC                           pfnLocalAlloc;
    PFNLREALLOC                         pfnLocalReAlloc;
    PFNLLOCK                            pfnLocalLock;
    PFNLUNLOCK                          pfnLocalUnlock;
    PFNLSIZE                            pfnLocalSize;
    PFNLFREE                            pfnLocalFree;
    PFNGETEXPWINVER                     pfnGetExpWinVer;
    PFN16GALLOC                         pfn16GlobalAlloc;
    PFN16GFREE                          pfn16GlobalFree;
    PFNEMPTYCB                          pfnEmptyCB;
    PFNFINDA                            pfnFindResourceEx;
    PFNLOAD                             pfnLoadResource;
    PFNFREE                             pfnFreeResource;
    PFNLOCK                             pfnLockResource;
    PFNUNLOCK                           pfnUnlockResource;
    PFNSIZEOF                           pfnSizeofResource;
    PFNWOWWNDPROCEX                     pfnWowWndProcEx;
    PFNWOWDLGPROCEX                     pfnWowDlgProcEx;
    PFNWOWEDITNEXTWORD                  pfnWowEditNextWord;
    PFNWOWCBSTOREHANDLE                 pfnWowCBStoreHandle;
    PFNGETPROCMODULE16                  pfnGetProcModule16;
    PFNWOWMSGBOXINDIRECTCALLBACK        pfnWowMsgBoxIndirectCallback;
    PFNWOWILSTRCMP                      pfnWowIlstrsmp;
    PFNWOWTELLWOWTHEHDLG                pfnWOWTellWOWThehDlg;
} PFNWOWHANDLERSIN, * APFNWOWHANDLERSIN;


typedef struct tagAPFNWOWHANDLERSOUT
{
    // Out'ees - passed from USER32 to WOW32 and called/used by WOW32
    DWORD                               dwBldInfo;
    PFNCSCREATEWINDOWEX                 pfnCsCreateWindowEx;
    PFNDIRECTEDYIELD                    pfnDirectedYield;
    PFNFREEDDEDATA                      pfnFreeDDEData;
    PFNGETCLASSWOWWORDS                 pfnGetClassWOWWords;
    PFNINITTASK                         pfnInitTask;
    PFNREGISTERCLASSWOWA                pfnRegisterClassWOWA;
    PFNREGISTERUSERHUNGAPPHANDLERS      pfnRegisterUserHungAppHandlers;
    PFNSERVERCREATEDIALOG               pfnServerCreateDialog;
    PFNSERVERLOADCREATECURSORICON       pfnServerLoadCreateCursorIcon;
    PFNSERVERLOADCREATEMENU             pfnServerLoadCreateMenu;
    PFNWOWCLEANUP                       pfnWOWCleanup;
    PFNWOWMODULEUNLOAD                  pfnWOWModuleUnload;
    PFNWOWFINDWINDOW                    pfnWOWFindWindow;
    PFNWOWLOADBITMAPA                   pfnWOWLoadBitmapA;
    PFNWOWWAITFORMSGANDEVENT            pfnWowWaitForMsgAndEvent;
    PFNYIELDTASK                        pfnYieldTask;
    PFNGETFULLUSERHANDLE                pfnGetFullUserHandle;
    PFNGETMENUINDEX                     pfnGetMenuIndex;
    PFNWOWGETDEFWINDOWPROCBITS          pfnWowGetDefWindowProcBits;
    PFNFILLWINDOW                       pfnFillWindow;
    INT *                               aiWowClass;
} PFNWOWHANDLERSOUT, * APFNWOWHANDLERSOUT;


//
// The WW structure is embedded at the end of USER's WND structure.
// However, WOW and USER use different names to access the WW
// fields. So this structure is defined as a union of two structures,
// WHICH MUST HAVE THE SAME SIZE, just different field names.
//
// Make sure that WND_CNT_WOWDWORDS matches the number of DWORDs
//  used by the WOW only fields.
//
// FindPWW(hwnd) returns a read-only pointer to this structure for
// a given window.  To change elements of this structure, use
// SETWW (== SetWindowLong) with the appropriate GWL_WOW* offset
// defined below.
//

/* WOW class/handle type identifiers (see WARNING below)
 */

#define FNID_START                  0x0000029A
#define FNID_END                    0x000002B4

#define WOWCLASS_UNKNOWN    0   // here begin our "window handle" classes
#define WOWCLASS_WIN16      1
#define WOWCLASS_BUTTON     2
#define WOWCLASS_COMBOBOX   3
#define WOWCLASS_EDIT       4
#define WOWCLASS_LISTBOX    5
#define WOWCLASS_MDICLIENT  6
#define WOWCLASS_SCROLLBAR  7
#define WOWCLASS_STATIC     8
#define WOWCLASS_DESKTOP    9
#define WOWCLASS_DIALOG     10
#define WOWCLASS_ICONTITLE  11
#define WOWCLASS_MENU       12
#define WOWCLASS_SWITCHWND  13
#define WOWCLASS_COMBOLBOX  14
#define WOWCLASS_MAX        14  // Always equal to the last value used.

#define WOWCLASS_NOTHUNK    0xFF // not an actual class index
//
// WARNING! The above sequence and values must be maintained otherwise the
// table in WMSG16.C for message thunking must be changed.  Same goes for
// table in WALIAS.C.
//


//
// When including this from USER, VPWNDPROC is undefined
//
#ifndef _WALIAS_
typedef DWORD VPWNDPROC;
typedef DWORD VPSZ;
#endif

typedef struct tagWOWCLS {
    VPSZ       vpszMenu;
    WORD       iClsExtra;   // app's value for class extra
    WORD       hMod16;
    } WC;

typedef WC UNALIGNED *PWC;

typedef struct _WW { /* ww */
    /*
     *
     * WOW/USER fields
     * NOTE: The order and size of the following 4 fields is assumed
     *       by the SetWF, ClrWF, TestWF, MaskWF macros.
     *       Specifically, state must remain the first field in this structure.
     *
     */
    DWORD         state;        // State flags
    DWORD         state2;       //
    DWORD         ExStyle;      // Extended Style
    DWORD         style;        // Style flags

    KHANDLE       hModule;      // Handle to module instance data (32-bit).
    WORD          hMod16;       // WOW only -- hMod of wndproc
    WORD          fnid;         // record window proc used by this hwnd
                        // access through GETFNID

} WW, *PWW, **PPWW;

// this is tied to WFISINITIALIZED in ntuser\inc\user.h
#define WINDOW_IS_INITIALIZED   0x80000000

ULONG_PTR UserRegisterWowHandlers(APFNWOWHANDLERSIN apfnWowIn, APFNWOWHANDLERSOUT apfnWowOut);

VOID WINAPI RegisterWowBaseHandlers(PFNWOWGLOBALFREEHOOK pfn);

BOOL
InitTask(
    UINT dwExpWinVer,
    DWORD dwAppCompatFlags,
    LPCSTR lpszModName,
    LPCSTR lpszBaseFileName,
    DWORD hTaskWow,
    DWORD dwHotkey,
    DWORD idTask,
    DWORD dwX,
    DWORD dwY,
    DWORD dwXSize,
    DWORD dwYSize);

BOOL YieldTask(VOID);

#define DY_OLDYIELD     ((DWORD)-1)
VOID DirectedYield(DWORD ThreadId);
DWORD UserGetInt16State(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\appandcommandline.cpp ===
/*++

 Copyright (c) 2000, 2001 Microsoft Corporation

 Module Name:

    AppAndCommandLine.cpp

 Abstract:

    This class takes an application name and command line and
    parses them *exactly* as as they would by CreateProcess.
    If the Set routine returns TRUE, then the application name
    will contain a value; however, it does not guarantee that the application
    actually exists.

    Example:
    AppAndCommandLine.Set(NULL, "notepad.exe readme.txt");
    GetApplicationName()        == "notepad.exe"
    GetCommandline()            == "notepad.exe readme.txt"
    GetCommandlineNoAppName()   == "readme.txt"


 Notes:

    None

 History:

    07/21/2000  robkenny    Created
    12/18/2000  prashkud    Modified GetAppAndCommandLine to fix the AV
                            caused by EmulateGetCommandLine when the
                            layer was applied to Oregon Trail 4th Edition.
    03/04/2001  robkenny    Converted to use CString
    03/29/2001  prashkud    Modified GetAppnameAndCommandline to set
                            the application name even when there is only
                            Commandline passed and the application name
                            passed is NULL.
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.


--*/

#include "ShimLib.h"



namespace ShimLib
{

AppAndCommandLine::AppAndCommandLine(const char * applicationName, const char * commandLine)
{
    CString csApp(applicationName);
    CString csCl(commandLine);

    GetAppnameAndCommandline(csApp.GetNIE(), csCl.GetNIE());
}

AppAndCommandLine::AppAndCommandLine(const WCHAR * applicationName, const WCHAR * commandLine)
{
    GetAppnameAndCommandline(applicationName, commandLine);
}

// If the application name is the first entry on the command line,
// we convert the appName to its short name; thereby removing any spaces.
const CString & AppAndCommandLine::GetShortCommandLine()
{
    // If lpCommandLineNoAppName is not the same as lpCommandLine,
    // then the command line contains the application name.
    if ( csShortCommandLine.IsEmpty() &&                             // Haven't been here
        !csApplicationName.IsEmpty() &&                              // Set() has been called
        !csCommandLine.IsEmpty() &&                                  // Set() has been called
        csShortCommandLine.GetLength() != csCommandLine.GetLength()) // Command line actually contains app name
    {
        csShortCommandLine = csApplicationName;
        csShortCommandLine.GetShortPathNameW();
        csShortCommandLine += L" ";
        csShortCommandLine += csCommandLineNoAppName;
    }

    // If we still don't have a short version of the command line,
    // just duplicate the current command line
    if (csShortCommandLine.IsEmpty())
    {
        csShortCommandLine = csCommandLine;
    }
    return csShortCommandLine;
}

BOOL AppAndCommandLine::GetAppnameAndCommandline(const WCHAR * lpcApp, const WCHAR * lpcCl)
{
    BOOL SearchRetry = TRUE;
    ULONG Length = 0;
    WCHAR * NameBuffer = NULL;
    BOOL success = FALSE;
    DWORD dwAppNameLen = 0;
    CString csTempAppName;
    BOOL bFound = TRUE;

    // It is really, really bad to remove the const from the Get,
    // However we never change the length of the string, so it should be okay
    WCHAR * lpApplicationName = (WCHAR *)lpcApp;
    WCHAR * lpCommandLine     = (WCHAR *)lpcCl;

    // The following is done as there are lot of instances when the
    // the pointer is not NULL but contains an EMPTY string.
    if (lpApplicationName && !(*lpApplicationName))
    {
        lpApplicationName = NULL;
    }

    if (lpCommandLine && !(*lpCommandLine))
    {
        lpCommandLine = NULL;
    }

    if (lpApplicationName == NULL && lpCommandLine == NULL)
    {
        // Degenerate case
        csApplicationName      = L"";
        csCommandLine          = csApplicationName;
        csCommandLineNoAppName = csApplicationName;
        return FALSE; // Didn't find application name
    }

    csCommandLine = lpCommandLine;

    DPF("Common",
        eDbgLevelSpew,
        "[AppAndCommandLineT::Set] BEFORE App(%S) CL(%S)\n",
        lpApplicationName, lpCommandLine);

    if (lpApplicationName == NULL)         
    {
        DWORD fileattr;
        WCHAR TempChar;
        //
        // Locate the image
        //

        NameBuffer = (WCHAR *) malloc(MAX_PATH * sizeof( WCHAR ));
        if ( !NameBuffer )
        {
            goto errorExit;
        }
        lpApplicationName = lpCommandLine;
        WCHAR * TempNull = lpApplicationName;
        WCHAR * WhiteScan = lpApplicationName;
        DWORD QuoteFound = 0;

        //
        // check for lead quote
        //
        if ( *WhiteScan == L'\"' ) {
            SearchRetry = FALSE;
            WhiteScan++;
            lpApplicationName = WhiteScan;
            while(*WhiteScan) {
                if ( *WhiteScan == L'\"' ) {
                    TempNull = WhiteScan;
                    QuoteFound = 2;
                    break;
                    }
                WhiteScan++;
                TempNull = WhiteScan;
                }
            }
        else {
retrywsscan:
            lpApplicationName = lpCommandLine;
            while(*WhiteScan) {
                if ( *WhiteScan == L' ' ||
                     *WhiteScan == L'\t' ) {
                    TempNull = WhiteScan;
                    break;
                    }
                WhiteScan++;
                TempNull = WhiteScan;
                }
            }
        TempChar = *TempNull;
        *TempNull = 0;

        WCHAR * filePart;
        Length = SearchPathW(
                    NULL,
                    lpApplicationName,
                    L".exe",
                    MAX_PATH,
                    NameBuffer,
                    &filePart
                    )*sizeof(WCHAR);

        if (Length != 0 && Length < MAX_PATH * sizeof( WCHAR )) {
            //
            // SearchPathW worked, but file might be a directory
            // if this happens, we need to keep trying
            //
            fileattr = GetFileAttributesW(NameBuffer);
            if ( fileattr != 0xffffffff &&
                 (fileattr & FILE_ATTRIBUTE_DIRECTORY) ) {
                Length = 0;
            } else {
                Length++;
                Length++;
            }
        }

        if ( !Length || Length >= MAX_PATH<<1 ) {

            //
            // restore the command line
            //

            *TempNull = TempChar;
            lpApplicationName = NameBuffer;

            //
            // If we still have command line left, then keep going
            // the point is to march through the command line looking
            // for whitespace so we can try to find an image name
            // launches of things like:
            // c:\word 95\winword.exe /embedding -automation
            // require this. Our first iteration will stop at c:\word, our next
            // will stop at c:\word 95\winword.exe
            //
            if (*WhiteScan && SearchRetry) {
                WhiteScan++;
                TempNull = WhiteScan;
                goto retrywsscan;
            }

            // If we are here then the Application has not been found.
            // We used to send back lpApplicationName as NULL earlier
            // but now instead we fill the ApplicationName with the
            // commandline till the first space or tab.This was added
            // to support EmulateMissingExe SHIM which will fail if 
            // we return NULL as we used to earlier.
            bFound = FALSE;
            
            if (QuoteFound == 0)
            {
                // No quotes were found.
                lpApplicationName = lpCommandLine;

                // Since we just reset to the entire command line, we need to skip leading white space
                SkipBlanksW(lpApplicationName);

                TempNull = lpApplicationName;

                while (*TempNull)
                {
                    if ((*TempNull == L' ') ||
                       (*TempNull == L'\t') )
                    {
                        TempChar = *TempNull;
                        *TempNull = 0;
                        break;
                    }
                    TempNull++;
                }
            }
            else
            {
                // Quotes were found.
                *TempNull = 0;
            }

            csTempAppName = lpApplicationName;                        
            *TempNull = TempChar;
            dwAppNameLen = (DWORD)(TempNull - lpApplicationName) + QuoteFound;
            lpApplicationName = (WCHAR*)csTempAppName.Get();

            goto successExit;       
        }

        dwAppNameLen = (DWORD)(TempNull - lpApplicationName) + QuoteFound;

        //
        // restore the command line
        //

        *TempNull = TempChar;
        lpApplicationName = NameBuffer;
    }
    else if (lpCommandLine == NULL || *lpCommandLine == 0 )
    {
        lpCommandLine = lpApplicationName;
            
        dwAppNameLen = wcslen(lpApplicationName);
    }

    // If they provided both, check to see if the app name
    // is the first entry on the command line.
    else if (lpApplicationName != NULL && lpCommandLine != NULL )
    {
        int appNameLen = wcslen(lpApplicationName);

        if (
            _wcsnicmp(lpApplicationName, lpCommandLine, appNameLen) == 0 &&
            (lpCommandLine[appNameLen] == 0 || iswspace(lpCommandLine[appNameLen]))
            )
        {
            // lpApplicationName is the first entry on the command line
            dwAppNameLen = appNameLen;
        }
        // check for quoted lpApplicationName
        else if (
            lpCommandLine[0] == L'"' && 
            _wcsnicmp(lpApplicationName, lpCommandLine+1, appNameLen) == 0 &&
            lpCommandLine[appNameLen+1] == L'"' &&                                  
            (lpCommandLine[appNameLen+2] == 0 || iswspace(lpCommandLine[appNameLen+2]))
            )
        {
            // lpApplicationName is the first *quoted* entry on the command line
            dwAppNameLen = appNameLen + 2;
        }
        else
        {
            // Didn't find the application name at the beginning of the command line
            dwAppNameLen = 0;
        }
    }

successExit:
    if (bFound)
    {
        success = TRUE;
    }    

    csApplicationName       = lpApplicationName;
    csCommandLineNoAppName  = lpCommandLine + dwAppNameLen;
    csCommandLineNoAppName.TrimLeft();

errorExit:

    free(NameBuffer);

    DPF("Common",
        eDbgLevelSpew,
        "[AppAndCommandLineT::Set] AFTER  App(%S) CL(%S)\n",
        csApplicationName.Get(), csCommandLine.Get());
    
    DPF("Common",
        eDbgLevelSpew,
        "[AppAndCommandLineT::Set] CL without App(%S)\n",
        csCommandLineNoAppName.Get());

    return success;
}



};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\layer\win98versionlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Win98VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 98
   version credentials. Applications often check to ensure that they are 
   running on a Win9x system, even though they will run OK on an NT based 
   system.

 Notes:

   This is a general purpose shim.

 History:

   11/08/2000 v-hyders  Created

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(Win98VersionLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA) 
    APIHOOK_ENUM_ENTRY(GetVersionExW) 
    APIHOOK_ENUM_ENTRY(GetVersion) 
APIHOOK_ENUM_END

BOOL g_bCheckSafeDisc = FALSE;

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 98 credentials.

--*/

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    if (g_bCheckSafeDisc && bIsSafeDisc2()) {
        return ORIGINAL_API(GetVersionExA)(lpVersionInformation);
    } else {
        BOOL bReturn = FALSE;

        if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {

            LOGN(eDbgLevelInfo, "[GetVersionExA] called. return Win98");

            //
            // Fixup the structure with the Win98 data.
            //
            lpVersionInformation->dwMajorVersion = 4;
            lpVersionInformation->dwMinorVersion = 10;
            lpVersionInformation->dwBuildNumber = 0x040A08AE;
            lpVersionInformation->dwPlatformId = 1;
            *lpVersionInformation->szCSDVersion = '\0';

            bReturn = TRUE;
        }

        return bReturn;
    }
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 98 credentials. This is the
 wide-character version of GetVersionExW.

--*/

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    if (g_bCheckSafeDisc && bIsSafeDisc2()) {
        return ORIGINAL_API(GetVersionExW)(lpVersionInformation);
    } else {
        BOOL bReturn = FALSE;

        if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {

            LOGN(eDbgLevelInfo, "[GetVersionExW] called. return Win98");

            //
            // Fixup the structure with the Win98 data.
            //
            lpVersionInformation->dwMajorVersion = 4;
            lpVersionInformation->dwMinorVersion = 10;
            lpVersionInformation->dwBuildNumber = 0x040A08AE;
            lpVersionInformation->dwPlatformId = 1;
            *lpVersionInformation->szCSDVersion = '\0';

            bReturn = TRUE;
        }

        return bReturn;
    }
}

/*++

 This stub function returns Windows 98 credentials.

--*/
DWORD
APIHOOK(GetVersion)(
    void
    )
{
    if (g_bCheckSafeDisc && bIsSafeDisc2()) {
        return ORIGINAL_API(GetVersion)();
    } else {
        LOGN(eDbgLevelInfo, "[GetVersion] Return Win98");
        return (DWORD) 0xC0000A04;
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_bCheckSafeDisc = COMMAND_LINE && (_stricmp(COMMAND_LINE, "Detect_SafeDisc") == 0);

        if (g_bCheckSafeDisc && bIsSafeDisc1())
        {
            LOGN(eDbgLevelWarning, "SafeDisc 1.x detected: ignoring shim");
            return FALSE;
        }
    }
    
    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\argva.cpp ===
/***
*argvw.c - create Unicode version of argv arguments
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       processes program command line
*
*Revision History:
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.
*
*******************************************************************************/

// This routine actually lives in shell32.dll,
// we have a private copy so we don't have to link to the library.

#include <windows.h>


namespace ShimLib
{

/***
*void Parse_Cmdline(cmdstart, argv, lpstr, numargs, numbytes)
*
*Purpose:
*       Parses the command line and sets up the Unicode argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, lpstr
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only counting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numbytes has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       LPSTR cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       TCHAR **argv - where to build argv array; NULL means don't
*                      build array
*       LPSTR lpstr - where to place argument text; NULL means don't
*                      store text
*
*Exit:
*       no return value
*       INT *numargs - returns number of argv entries created
*       INT *numbytes - number of bytes used in args buffer
*
*Exceptions:
*
*******************************************************************************/

void Parse_CmdlineA (
    LPCSTR cmdstart,
    LPSTR* argv,
    LPSTR  lpstr,
    INT *  numargs,
    INT *  numbytes
    )
{
    LPCSTR p;
    char c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *numbytes = 0;
    *numargs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = lpstr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numbytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *numbytes += sizeof(char);
            if (lpstr)
                *lpstr++ = *p;
        }
        /* append the terminating null */
        *numbytes += sizeof(char);
        if (lpstr)
            *lpstr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *numbytes += sizeof(char);
            if (lpstr)
                *lpstr++ = *p;

            c = (char) *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (lpstr)
                *(lpstr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = lpstr;         /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (lpstr)
                    *lpstr++ = TEXT('\\');
                *numbytes += sizeof(char);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (lpstr)
                        *lpstr++ = *p;
                *numbytes += sizeof(char);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (lpstr)
            *lpstr++ = TEXT('\0');         /* terminate string */
        *numbytes += sizeof(char);
    }

}


/***
*CommandLineToArgvW - set up Unicode "argv" for C programs
*
*Purpose:
*       Read the command line and create the argv array for C
*       programs.
*
*Entry:
*       Arguments are retrieved from the program command line
*
*Exit:
*       "argv" points to a null-terminated list of pointers to UNICODE
*       strings, each of which is an argument from the command line.
*       The list of pointers is also located on the heap or stack.
*
*Exceptions:
*       Terminates with out of memory error if no memory to allocate.
*
*******************************************************************************/

LPSTR * _CommandLineToArgvA (LPCSTR lpCmdLine, int*pNumArgs)
{
    LPSTR*argv_U;
    LPCSTR cmdstart;                 /* start of command line to parse */
    INT    numbytes;

    if (pNumArgs == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    cmdstart = lpCmdLine;

    /* first find out how much space is needed to store args */
    Parse_CmdlineA(cmdstart, NULL, NULL, pNumArgs, &numbytes);

    /* allocate space for argv[] vector and strings */
    argv_U = (LPSTR*)LocalAlloc(LMEM_ZEROINIT,
                                (*pNumArgs + 1) * sizeof(LPSTR) + numbytes);
    if (!argv_U) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (NULL);
    }

    /* store args and argv ptrs in just allocated block */
    Parse_CmdlineA(cmdstart,
                   argv_U,
                   (LPSTR)(((LPBYTE)argv_U) + *pNumArgs * sizeof(LPSTR)),
                   pNumArgs,
                   &numbytes);

    return argv_U;
}


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\argvw.cpp ===
/***
*argvw.c - create Unicode version of argv arguments
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       processes program command line
*
*Revision History:
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.
*
*******************************************************************************/

// This routine actually lives in shell32.dll,
// we have a private copy so we don't have to link to the library.

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <wchar.h>


namespace ShimLib
{

/***
*void Parse_Cmdline(cmdstart, argv, lpstr, numargs, numbytes)
*
*Purpose:
*       Parses the command line and sets up the Unicode argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, lpstr
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only counting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numbytes has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       LPWSTR cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       TCHAR **argv - where to build argv array; NULL means don't
*                      build array
*       LPWSTR lpstr - where to place argument text; NULL means don't
*                      store text
*
*Exit:
*       no return value
*       INT *numargs - returns number of argv entries created
*       INT *numbytes - number of bytes used in args buffer
*
*Exceptions:
*
*******************************************************************************/

void Parse_Cmdline (
    LPCWSTR cmdstart,
    LPWSTR*argv,
    LPWSTR lpstr,
    INT *numargs,
    INT *numbytes
    )
{
    LPCWSTR p;
    WCHAR c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *numbytes = 0;
    *numargs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = lpstr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numbytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;
        }
        /* append the terminating null */
        *numbytes += sizeof(WCHAR);
        if (lpstr)
            *lpstr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;

            c = (WCHAR) *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (lpstr)
                *(lpstr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = lpstr;         /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (lpstr)
                    *lpstr++ = TEXT('\\');
                *numbytes += sizeof(WCHAR);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (lpstr)
                        *lpstr++ = *p;
                *numbytes += sizeof(WCHAR);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (lpstr)
            *lpstr++ = TEXT('\0');         /* terminate string */
        *numbytes += sizeof(WCHAR);
    }

}


/***
*CommandLineToArgvW - set up Unicode "argv" for C programs
*
*Purpose:
*       Read the command line and create the argv array for C
*       programs.
*
*Entry:
*       Arguments are retrieved from the program command line
*
*Exit:
*       "argv" points to a null-terminated list of pointers to UNICODE
*       strings, each of which is an argument from the command line.
*       The list of pointers is also located on the heap or stack.
*
*Exceptions:
*       Terminates with out of memory error if no memory to allocate.
*
*******************************************************************************/

LPWSTR * _CommandLineToArgvW (LPCWSTR lpCmdLine, int*pNumArgs)
{
    LPWSTR*argv_U;
    LPCWSTR cmdstart;                 /* start of command line to parse */
    INT     numbytes;

    if (pNumArgs == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    cmdstart = lpCmdLine;

    /* first find out how much space is needed to store args */
    Parse_Cmdline (cmdstart, NULL, NULL, pNumArgs, &numbytes);

    /* allocate space for argv[] vector and strings */
    argv_U = (LPWSTR*) LocalAlloc( LMEM_ZEROINIT,
                                   (*pNumArgs+1) * sizeof(LPWSTR) + numbytes);
    if (!argv_U) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (NULL);
    }

    /* store args and argv ptrs in just allocated block */
    Parse_Cmdline (cmdstart, argv_U,
                   (LPWSTR) (((LPBYTE)argv_U) + *pNumArgs * sizeof(LPWSTR)),
                   pNumArgs, &numbytes);

    return (argv_U);
}


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\classcfp.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    CorrectPathChangesBase.cpp

 Abstract:
    Several paths were changed between Win9x and WinNT.  This routine defines
    the CorrectPathChangesBase routines that is called with a Win9x path and returns
    the corresponding WinNT path.

 History:

    03-Mar-00   robkenny        Converted CorrectPathChanges.cpp to this class.
    21-Mar-00   robkenny        StringISub("abc", "abcd") now works
    06/20/2000  robkenny        EnvironmentValues::Initialize now checks the return status of the system calls
    12/12/2000  mnikkel         Some apps look for ddhelp.exe to exist to confirm directx is installed,
                                set this to look for ddraw.dll since ddhelp.exe no longer exists in directx.
    02/13/2001  robkenny/a-larrsh Added AllProfile and UserProfile to EnvironmentValues
    03/22/2001  robkenny        Do not redirect files to directories that the user does not have permission.
    08/14/2001  robkenny        Moved code inside the ShimLib namespace.
    

--*/
#include "ClassCFP.h"
#include "Userenv.h"
#include <stdio.h>

namespace ShimLib
{


/*++

    A simple string class.
    Mostly to ease the pain and drudgery of string manipulation in StringISub

--*/

class SimpleString
{
protected:
    DWORD       dwLen;      // String Length
    DWORD       dwSize;     // String Data size
    WCHAR *     lpData;     // String Data

    bool            Resize(DWORD dwSize); // Make buffer large enough for dwSize characters (not bytes)

public:
    SimpleString();
    ~SimpleString();

    //
    // Note, this ctor should only be used for const.
    //
    SimpleString(LPCWSTR pwsz, DWORD dwLen)
    {
        lpData = (LPWSTR)pwsz;
        this->dwLen = dwLen;
        dwSize = 0;
    }

    DWORD           Length() const;     // Number of characters in string
    bool    Append(const SimpleString & string);
    BOOL    Set(const WCHAR * string);
    BOOL    SetN(const WCHAR * string, DWORD dwStringLen);
    const WCHAR *   Get() const;

    BOOL    StringISub(const SimpleString & ssMatch, const SimpleString & ssReplace);

    WCHAR * ReleaseString();    // Caller now owns the string

    operator const WCHAR * () const;
    SimpleString & operator = (const SimpleString & string);

    static WCHAR *  ReplaceAllStringsAllocW(const WCHAR * lpOrig, const StringPairW * ReplaceList, DWORD dwReplaceListSize);
};

typedef const SimpleString ConstSimpleString;

/*++

    Constructor, init all values

--*/
SimpleString::SimpleString()
{
    dwLen       = 0;
    dwSize      = 0;
    lpData      = NULL;
}

/*++

    Destructor, free memory

--*/
SimpleString::~SimpleString()
{
    if (lpData && dwSize)
        free(lpData);
}

/*++

    Return the number of char in the string

--*/
DWORD SimpleString::Length() const
{
    return dwLen;
}

/*++

    Make the string large enough to hold size characters.
    Note: size should include EOS at the end.

--*/
bool SimpleString::Resize(DWORD size)
{
    if (size > dwSize)
    {
        lpData = (WCHAR *) realloc(lpData, size * sizeof(WCHAR));
        dwSize = size;
    }
    return(size == 0) || (lpData != NULL);
}

/*++

    Append string onto the end of this.

--*/
bool SimpleString::Append(const SimpleString & string)
{
    bool stringSafe = Resize(Length() + string.Length() + 1);
    if (stringSafe)
    {
        wcscat(lpData, string);
        dwLen = Length() + string.Length();
    }
    return stringSafe;
}

/*++

    Initialize this with a char string

--*/
BOOL SimpleString::Set(const WCHAR * string)
{
    return SetN(string, wcslen(string));
}

/*++

    Return a pointer to the string, class still owns pointer.

--*/
const WCHAR * SimpleString::Get() const
{
    return lpData;
}

/*++

    Initialize this with the first stringLen chars in string.

--*/
BOOL SimpleString::SetN(const WCHAR * string, DWORD stringLen)
{
    BOOL bAllocGood = Resize(stringLen + 1);
    if (bAllocGood)
    {
        dwLen = stringLen;
        wcsncpy(lpData, string, stringLen);
        lpData[stringLen] = 0;
    }

    return bAllocGood;
}

/*++

    Release ownership of the string.
    Caller is now responsible for calling free()

--*/
WCHAR * SimpleString::ReleaseString()
{
    WCHAR * lpOwner = lpData;

    dwLen       = 0;
    dwSize      = 0;
    lpData      = NULL;

    return lpOwner;
}

/*++

  String substitution, replace all ssMatch with ssReplace

--*/
BOOL SimpleString::StringISub(const SimpleString & ssMatch, const SimpleString & ssReplace)
{
    // Look to see if the match string exists
    WCHAR * lpMatchInString = wcsistr( lpData, ssMatch );
    if (lpMatchInString != NULL)
    {
        // The remainder of the uncorrected string
        SimpleString strRemainder;
        if (!strRemainder.Set(lpMatchInString + ssMatch.Length()))
            return FALSE;

        BOOL stringRemainderReplaced = strRemainder.StringISub(ssMatch, ssReplace);

        if (!SetN(lpData, (DWORD)(lpMatchInString - lpData)))
            return FALSE;

        if (!Append(ssReplace))
            return FALSE;
        if (!Append(strRemainder))
            return FALSE;

        return stringRemainderReplaced;
    }
    else
    {
        return FALSE;
    }
}
/*++

  Return a const pointer to the string.

--*/
SimpleString::operator const WCHAR * () const
{
    return lpData;
}

/*++

  Assignment operator, safely make a duplicate.

--*/
SimpleString & SimpleString::operator = (const SimpleString & string)
{
    SetN(string.lpData, string.dwLen);

    return *this;
}
/*++

  Func:   ReplaceAllStringsAllocW

  Params: lpOrig              Original string
          ReplaceList         Array of string old/new pairs
          dwReplaceListSize   Number of entries in ReplaceList

  Return: WCHAR *             Newly allocated string containing (possibly) modified string

  Desc:   For each entry in ReplaceList replace the string in lpOrig, placing the result into lpCorrected.
--*/
WCHAR * SimpleString::ReplaceAllStringsAllocW(
                                             const WCHAR * lpOrig,
                                             const StringPairW * ReplaceList,
                                             DWORD dwReplaceListSize)
{
    //DPF("SimpleString", eDbgLevelInfo, "\nReplaceAllStringsAllocW(%S)\n", lpOrig);

    SimpleString ssReplaced;
    if (ssReplaced.Set(lpOrig))
    {
        for (DWORD i = 0; i < dwReplaceListSize; ++i)
        {
            // Attempt a string substitution
            ssReplaced.StringISub(
                ConstSimpleString(ReplaceList[i].lpOld, ReplaceList[i].dwLenOld), 
                ConstSimpleString(ReplaceList[i].lpNew, ReplaceList[i].dwLenNew));

            //DPF("SimpleString", eDbgLevelInfo, "Old(%S)\n", ReplaceList[i].lpOld);
            //DPF("SimpleString", eDbgLevelInfo, "New(%S)\n", ReplaceList[i].lpNew);
            //DPF("SimpleString", eDbgLevelInfo, "Val(%S)\n", ssReplaced.Get());
        }
    }

    return ssReplaced.ReleaseString();
}

//-------------------------------------------------------------------------------------------------------------

EnvironmentValues::EnvironmentValues()
{
    bInitialized = FALSE;
}

EnvironmentValues::~EnvironmentValues()
{
    // Clear the list
    Erase();
}

// Given an CLSIDL, create an environment variable and its two variants
// CSIDL_WINDOWS would add c:\windows, \windows and windows
void EnvironmentValues::Add_Variants(const WCHAR * lpEnvName, const WCHAR * lpEnvValue, eAddNameEnum addName, eAddNoDLEnum noDL)
{
    CSTRING_TRY
    {
        CString csEnvName(lpEnvName);
        CString csEnvValue(lpEnvValue);

        csEnvName.Format(L"%%%s%%", lpEnvName);
        AddEnvironmentValue(csEnvName, csEnvValue);

        // Remove the drive letter and the colon.
        if (noDL == eAddNoDL)
        {
            CString csNoDL(csEnvValue);
            csNoDL.Delete(0, 2);

            csEnvName.Format(L"%%%s_NODL%%", lpEnvName);
            AddEnvironmentValue(csEnvName, csNoDL);
        }

        // Use the last path component as the name.
        if (addName == eAddName)
        {
            CString csName;
            csEnvValue.GetLastPathComponent(csName);

            csEnvName.Format(L"%%%s_NAME%%", lpEnvName);
            AddEnvironmentValue(csEnvName, csName);
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }
}

// Given an CLSIDL, create an environment variable and its two variants
// CSIDL_WINDOWS would add c:\windows, \windows and windows
void EnvironmentValues::Add_CSIDL(const WCHAR * lpEnvName, int nFolder, eAddNameEnum addName, eAddNoDLEnum noDL)
{
    CSTRING_TRY
    {
        CString csPath;
        SHGetSpecialFolderPathW(csPath, nFolder);

        if (csPath.GetLength() > 0)
        {
            Add_Variants(lpEnvName, csPath, addName, noDL);
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }
}

// Add all _CSIDL values as environment variables.
void EnvironmentValues::AddAll_CSIDL()
{
    Add_CSIDL(L"CSIDL_APPDATA",                 CSIDL_APPDATA,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_ADMINTOOLS",       CSIDL_COMMON_ADMINTOOLS,        eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_APPDATA",          CSIDL_COMMON_APPDATA,           eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_DESKTOPDIRECTORY", CSIDL_COMMON_DESKTOPDIRECTORY,  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_DOCUMENTS",        CSIDL_COMMON_DOCUMENTS,         eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_FAVORITES",        CSIDL_COMMON_FAVORITES,         eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_MUSIC",            CSIDL_COMMON_MUSIC,             eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_PICTURES",         CSIDL_COMMON_PICTURES,          eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_PROGRAMS",         CSIDL_COMMON_PROGRAMS,          eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_STARTMENU",        CSIDL_COMMON_STARTMENU,         eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_STARTUP",          CSIDL_COMMON_STARTUP,           eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_TEMPLATES",        CSIDL_COMMON_TEMPLATES,         eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COOKIES",                 CSIDL_COOKIES,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_DESKTOPDIRECTORY",        CSIDL_DESKTOPDIRECTORY,         eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_FAVORITES",               CSIDL_FAVORITES,                eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_FONTS",                   CSIDL_FONTS,                    eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_HISTORY",                 CSIDL_HISTORY,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_INTERNET_CACHE",          CSIDL_INTERNET_CACHE,           eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_LOCAL_APPDATA",           CSIDL_LOCAL_APPDATA,            eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_MYMUSIC",                 CSIDL_MYMUSIC,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_MYPICTURES",              CSIDL_MYPICTURES,               eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_NETHOOD",                 CSIDL_NETHOOD,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_PERSONAL",                CSIDL_PERSONAL,                 eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_PRINTHOOD",               CSIDL_PRINTHOOD,                eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_PROFILE",                 CSIDL_PROFILE,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_PROGRAM_FILES",           CSIDL_PROGRAM_FILES,            eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_PROGRAM_FILES_COMMON",    CSIDL_PROGRAM_FILES_COMMON,     eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_PROGRAMS",                CSIDL_PROGRAMS,                 eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_RECENT",                  CSIDL_RECENT,                   eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_SENDTO",                  CSIDL_SENDTO,                   eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_STARTMENU",               CSIDL_STARTMENU,                eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_STARTUP",                 CSIDL_STARTUP,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_SYSTEM",                  CSIDL_SYSTEM,                   eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_TEMPLATES",               CSIDL_TEMPLATES,                eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_WINDOWS",                 CSIDL_WINDOWS,                  eAddName, eAddNoDL);
}

void EnvironmentValues::Initialize()
{
    if (bInitialized == FALSE)
    {
        bInitialized = TRUE;

        WCHAR   lpDir[MAX_PATH];
        DWORD   dwSize;
        HRESULT result;
        DWORD   dwChars;
        BOOL    bResult;

        dwChars = GetWindowsDirectoryW(lpDir, MAX_PATH);
        if (dwChars != 0)
        {
            AddEnvironmentValue( L"%WinDir%", lpDir );
            AddEnvironmentValue( L"%SystemRoot%", lpDir );

            lpDir[2] = 0;
            AddEnvironmentValue( L"%SystemDrive%", lpDir );
        }

        dwChars = GetSystemDirectoryW( lpDir, MAX_PATH);
        if (dwChars != 0)
        {
            AddEnvironmentValue( L"%SystemDir%", lpDir );
        }

        dwSize = MAX_PATH;
        bResult = GetUserNameW(lpDir, &dwSize);
        if (bResult)
        {
            AddEnvironmentValue( L"%Username%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_PROGRAM_FILES, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%ProgramFiles%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_STARTMENU, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%UserStartMenu%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_COMMON_STARTMENU, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%AllStartMenu%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%UserDesktop%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_COMMON_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%AllDesktop%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_FAVORITES, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%UserFavorites%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_COMMON_FAVORITES, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%AllFavorites%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_APPDATA, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%UserAppData%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_COMMON_APPDATA, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%AllAppData%", lpDir );
        }


        // C:\Documents and Settings\All Users 
        dwSize = MAX_PATH;
        bResult = GetAllUsersProfileDirectoryW(lpDir, &dwSize);
        if (bResult)
        {
            Add_Variants( L"AllUsersProfile", lpDir, eAddName, eAddNoDL); // same as real Env var
        }

        // C:\Documents and Settings\owner
        HANDLE hProcessHandle = GetCurrentProcess();
        HANDLE hUserToken;
        if (OpenProcessToken(hProcessHandle, TOKEN_QUERY, &hUserToken))
        {
            dwSize = MAX_PATH;
            bResult = GetUserProfileDirectoryW(hUserToken, lpDir, &dwSize);
            if (bResult)
            {
                Add_Variants( L"UserProfile", lpDir, eAddName, eAddNoDL);
            }
        }


        // Add the new CLSIDL variables (some have duplicate values to above)
        AddAll_CSIDL();
    }
}


WCHAR * EnvironmentValues::ExpandEnvironmentValueW(const WCHAR * lpOld)
{
    Initialize();

    // Replace all the "environment" values into their real values
    WCHAR * lpMassagedOld = SimpleString::ReplaceAllStringsAllocW(lpOld, vectorList, nVectorListMax );

    return lpMassagedOld;
}


char * EnvironmentValues::ExpandEnvironmentValueA(const char * lpOld)
{
    Initialize();

    char * lpMassagedOld = NULL;

    WCHAR * lpOldWide = ToUnicode(lpOld);
    if (lpOldWide)
    {
        WCHAR * lpMassagedOldWide = SimpleString::ReplaceAllStringsAllocW(lpOldWide, vectorList, nVectorListMax );
        if (lpMassagedOldWide)
        {
            lpMassagedOld = ToAnsi(lpMassagedOldWide);
            free(lpMassagedOldWide);
        }

        free(lpOldWide);
    }

    return lpMassagedOld;
}


void EnvironmentValues::AddEnvironmentValue(const WCHAR * lpOld, const WCHAR * lpNew)
{
    Initialize();

    StringPairW appendThis(lpOld, lpNew);

    if (Append(appendThis))
    {
        DPF("EnvironmentValues", eDbgLevelInfo, "AddEnvironmentValue: (%S) to (%S)\n", appendThis.lpOld, appendThis.lpNew );
    }
}



//-------------------------------------------------------------------------------------------------------------
CorrectPathChangesBase::CorrectPathChangesBase()
{
    lpEnvironmentValues         = new EnvironmentValues;

    dwKnownPathFixesCount       = 0;
    lpKnownPathFixes            = (StringPairW *)malloc(sizeof(StringPairW)); // prime the pump for realloc later

    bInitialized                = FALSE;
    bEnabled                    = TRUE;

    InitializeCriticalSection(&csCritical);
}

CorrectPathChangesBase::~CorrectPathChangesBase()
{
    if (lpEnvironmentValues)
        delete lpEnvironmentValues;

    if (lpKnownPathFixes)
        free(lpKnownPathFixes);

    DeleteCriticalSection(&csCritical);
}

void CorrectPathChangesBase::EnterCS()
{
    EnterCriticalSection(&csCritical);
}

void CorrectPathChangesBase::LeaveCS()
{
    LeaveCriticalSection(&csCritical);
}


/*++

  Func:   AddEnvironmentValue

  Params: dwIndex
          lpOld        Name of "environment" variable
          lpNew        Value of "environment" variable

--*/
void CorrectPathChangesBase::AddEnvironmentValue(const WCHAR * lpOld, const WCHAR * lpNew )
{
    if (lpEnvironmentValues)
    {
        lpEnvironmentValues->AddEnvironmentValue(lpOld, lpNew);
    }
}

/*++

  Func:   InsertPathChangeW

  Params:
          lpOld     Old Win9x path
          lpNew     New Win2000 path

  Desc:   Insert the Old/New string pair into lpKnownPathFixes
          making sure the list is large enough.
--*/
void CorrectPathChangesBase::InsertPathChangeW( const WCHAR * lpOld, const WCHAR * lpNew )
{
    // Ignore identical strings
    if (lstrcmpiW(lpOld, lpNew) == 0)
        return;

    // Ignore duplicates
    int i;
    for (i = 0; i < dwKnownPathFixesCount; ++i)
    {
        if (_wcsicmp(lpKnownPathFixes[i].lpOld, lpOld) == 0)
        {
            DPF("CorrectPathChangesBase", eDbgLevelSpew, "Duplicate PathChange (%S) to (%S)\n", lpOld, lpNew );
            return;
        }
    }

    // Grow the list
    size_t oldListSize = dwKnownPathFixesCount * sizeof(StringPairW);
    lpKnownPathFixes = (StringPairW *)realloc(lpKnownPathFixes, oldListSize + sizeof(StringPairW));
    if (lpKnownPathFixes == NULL)
    {
        // Alloc failed, don't add anymore
        return;
    }

    DWORD dwLenOld = wcslen(lpOld);
    wcsncpy( lpKnownPathFixes[dwKnownPathFixesCount].lpOld, lpOld, dwLenOld + 1);
    lpKnownPathFixes[dwKnownPathFixesCount].dwLenOld = dwLenOld;
    DWORD dwLenNew = wcslen(lpNew);
    wcsncpy( lpKnownPathFixes[dwKnownPathFixesCount].lpNew, lpNew, dwLenNew + 1);
    lpKnownPathFixes[dwKnownPathFixesCount].dwLenNew = dwLenNew;

    DPF("CorrectPathChangesBase", eDbgLevelInfo, "PathChange (%S) to (%S)\n", lpKnownPathFixes[dwKnownPathFixesCount].lpOld, lpKnownPathFixes[dwKnownPathFixesCount].lpNew );

    dwKnownPathFixesCount += 1;
}


/*++

  Func:   AddPathChangeW

  Params:
          lpOld     Old Win9x path
          lpNew     New Win2000 path

  Desc:   Add lpOld/lpNew combo to the list, two times:
          first:    lpOld/short(lpNew)
          second:   short(lpOld)/short(lpNew)

--*/

void CorrectPathChangesBase::AddPathChangeW( const WCHAR * lpOld, const WCHAR * lpNew )
{
    InitializeCorrectPathChanges();

    // Replace all the "environment" values into their real values
    WCHAR * lpExpandedOld = ExpandEnvironmentValueW(lpOld);
    WCHAR * lpExpandedNew = ExpandEnvironmentValueW(lpNew);

    const WCHAR * lpNewShort = lpExpandedNew;

    // Convert lpNew to its short name
    WCHAR   lpNewShortBuffer[MAX_PATH];
    DWORD status = GetShortPathNameW(lpExpandedNew, lpNewShortBuffer, MAX_PATH);
    if (status > 0 && status < MAX_PATH)
    {
        lpNewShort = lpNewShortBuffer;
    }

    // first: lpOld/short(lpNew)
    InsertPathChangeW(lpExpandedOld, lpNewShort);

    // Convert lpOld to its short name
    WCHAR lpOldShort[MAX_PATH];
    status = GetShortPathNameW(lpExpandedOld, lpOldShort, MAX_PATH);
    if (status > 0 && status < MAX_PATH) // successfully got the short path
    {
        if (_wcsicmp(lpOld, lpOldShort) != 0)
        {
            // second:   short(lpOld)/short(lpNew)
            InsertPathChangeW( lpOldShort, lpNewShort );
        }
    }

    free(lpExpandedOld);
    free(lpExpandedNew);
}

/*++

  Func:   ExpandEnvironmentValueA

  Params:  lpOld     string with environment vars

  Desc:    Return a pointer to a malloc() string with all internal env values expanded.

--*/

char * CorrectPathChangesBase::ExpandEnvironmentValueA(const char * lpOld)
{
    WCHAR * lpOldWide = ToUnicode(lpOld);

    // Replace all the "environment" values into their real values
    WCHAR * lpExpandedOldWide = ExpandEnvironmentValueW(lpOldWide);

    char * lpExpandedOld = ToAnsi(lpExpandedOldWide);

    free(lpOldWide);
    free(lpExpandedOldWide);

    return lpExpandedOld;
}

/*++

  Func:   ExpandEnvironmentValueW

  Params:  lpOld     string with environment vars

  Desc:    Return a pointer to a malloc() string with all internal env values expanded.

--*/

WCHAR * CorrectPathChangesBase::ExpandEnvironmentValueW(const WCHAR * lpOld)
{
    WCHAR * lpMassagedOld = NULL;

    InitializeCorrectPathChanges();

    if (lpEnvironmentValues)
    {
        lpMassagedOld = lpEnvironmentValues->ExpandEnvironmentValueW(lpOld);
    }

    return lpMassagedOld;
}

/*++

  Func:   InitializeEnvironmentValuesW

  Params: None, applies changes to lpEnvironmentValues

  Desc:   This function sets the "environment" values to their explicit values
--*/
void CorrectPathChangesBase::InitializeEnvironmentValuesW( )
{
    if (lpEnvironmentValues)
    {
        lpEnvironmentValues->Initialize();
    }
}


/*++

  Func:   InitializePathFixes

  Params: None, applies changes to lpEnvironmentValues

  Desc:   This function sets the "environment" values to their explicit values
--*/
void CorrectPathChangesBase::InitializePathFixes( )
{
}

/*++

  Func:   InitializeCorrectPathChanges

  Params: None.

  Desc:   Initialize the CorrectPathChangesBase values, both A and W versions.
          This *must* be called prior to calling either CorrectPathChangesA or CorrectPathChangesW
--*/
void CorrectPathChangesBase::InitializeCorrectPathChanges( )
{
    // This seems a little odd, but we wanted to minimize the amount of time spent
    // attempting to enter the critical section.  The simple code is:
    // EnterCS();
    // if (!bInitialized)
    // {
    //      BOOL isEnabled = bEnabled; // remember previous enabled state
    //
    // This would enter the critical section every time we make sure
    // the class is initialized.

    if (!bInitialized)
    {
        EnterCS();

        if (!bInitialized)
        {
            BOOL isEnabled = bEnabled; // remember previous enabled state

            // We must not be enabled while we are initializing, otherwise
            // we can (and do!) hook routines that we are trying to use while
            // grabbing values from the system.
            bEnabled = FALSE;
            bInitialized = TRUE;

            InitializeEnvironmentValuesW();
            InitializePathFixes();

            bEnabled = isEnabled;
        }

        LeaveCS();
    }
}


/*++

   Helper routine to call CorrectPathA, allocates necessary buffer space and returns a pointer
   to the corrected path.  Caller is responsible for releasing the memory by calling free().

--*/

char *  CorrectPathChangesBase::CorrectPathAllocA(const char * str)
{
    if (str == NULL)
        return NULL;

    // Convert lpOrig to WCHAR, correct the WCHAR path, then convert back to char

    WCHAR * strWide = ToUnicode(str);

    // Correct
    WCHAR * strCorrectedWide = CorrectPathAllocW(strWide);

    char * strCorrected = ToAnsi(strCorrectedWide);

    free(strWide);
    free(strCorrectedWide);

    return strCorrected;
}

/*++

   Helper routine to call CorrectPathW, allocates necessary buffer space and returns a pointer
   to the corrected path.  Caller is responsible for releasing the memory by calling free().

--*/

WCHAR * CorrectPathChangesBase::CorrectPathAllocW(const WCHAR * str)
{
    if (str == NULL)
        return NULL;

    // Make sure the paths have been initialized.
    InitializeCorrectPathChanges();

    if (bEnabled)
    {
        WCHAR * strCorrected = SimpleString::ReplaceAllStringsAllocW(str, lpKnownPathFixes, dwKnownPathFixesCount);

        return strCorrected;
    }
    else
    {
        return StringDuplicateW(str);
    }
}

void CorrectPathChangesBase::AddFromToPairW(const WCHAR * lpFromToPair )
{
    // Make sure the paths have been initialized.
    InitializeCorrectPathChanges();

    WCHAR * FromPath = NULL;
    WCHAR * ToPath = NULL;
    const WCHAR * PathBegin = NULL;
    char argSeperator = 0; // Stop parsing the string when we reach this char

    SkipBlanksW(lpFromToPair);

    // Malformed input, stop processing
    if (*lpFromToPair == 0)
        goto AllDone;

    // If the beginning of the string is a quote, look for the matching close quote
    if (*lpFromToPair == '"')
    {
        argSeperator = L'"';
        lpFromToPair += 1;
    }

    // The beginning of the From path
    PathBegin = lpFromToPair;

    // Search for the first from/to seperator, this is end of the From path
    while (*lpFromToPair != L';')
    {
        // Malformed input, stop processing
        if (*lpFromToPair == 0)
            goto AllDone;

        lpFromToPair += 1;
    }

    // Malformed input, stop processing
    if (lpFromToPair == PathBegin)
        goto AllDone;

    // Copy into our From string
    FromPath = StringNDuplicateW(PathBegin, (int)(lpFromToPair - PathBegin));

    lpFromToPair += 1; // Skip the from/to seperator

    // The beginning of the To path
    PathBegin = lpFromToPair;

    // Search for argSeperator, this is end of the To path
    while (*lpFromToPair != argSeperator)
    {
        // Found the end of the string, To path is definately complete
        if (*lpFromToPair == 0)
            break;

        lpFromToPair += 1;
    }

    // Malformed input, stop processing
    if (lpFromToPair == PathBegin)
        goto AllDone;

    // Copy into our To string
    ToPath = StringNDuplicateW(PathBegin, (int)(lpFromToPair - PathBegin));

    lpFromToPair += 1; // Skip the argSeperator

    // Success!
    AddPathChangeW(FromPath, ToPath);

    AllDone:
    free(FromPath);
    free(ToPath);
}

/*++

    Take a single string containing (multiple) path change pairs,
    split them up and call AddPathChangeW.
    The from/to pair is seperated by a : (colon)
    If a path contains spaces, the entire pair must be surrounded by quotes

    Example:
    "%windir%\Goofy Location:%SystemDir%\CorrectLocation" %windir%\Goofy2:%SystemDir%\CorrectLocation2

    will call
    AddPathChangeW("%windir%\Goofy Location", "%SystemDir%\CorrectLocation");
    AddPathChangeW("%windir%\Goofy2", "%SystemDir%\CorrectLocation2");

--*/
void CorrectPathChangesBase::AddCommandLineW(const WCHAR * lpCommandLine )
{
    if (!lpCommandLine || *lpCommandLine == 0)
        return;

    DPF("CorrectPathChangesBase", eDbgLevelInfo, "AddCommandLine(%S)\n", lpCommandLine);

    int argc;
    LPWSTR * argv = _CommandLineToArgvW(lpCommandLine, &argc);
    if (!argv)
        return;

    for (int i = 0; i < argc; ++i)
    {
        AddFromToPairW(argv[i]);
    }

    free(argv);
}

/*++

    Simply widen the string and call AddCommandLineW

--*/
void CorrectPathChangesBase::AddCommandLineA(const char * lpCommandLine )
{
    if (!lpCommandLine || *lpCommandLine == 0)
        return;

    WCHAR * wszCommandLine = ToUnicode(lpCommandLine);

    AddCommandLineW(wszCommandLine);

    free(wszCommandLine);
}

// Get the full path to wordpad.exe from the registry
BOOL GetWordpadPath(CString & csWordpad)
{
    csWordpad.Truncate(0);

    DWORD dwRegType;
    LONG lStatus = RegQueryValueExW(csWordpad,
                                    HKEY_CLASSES_ROOT,
                                    L"Applications\\wordpad.exe\\shell\\open\\command",
                                    NULL, // default key
                                    &dwRegType);
    if (ERROR_SUCCESS == lStatus &&
        (dwRegType == REG_SZ || dwRegType == REG_EXPAND_SZ))
    {
        // String is of the form "wordpad path" "%1"
        // We want to grab all the stuff between the first pair of quotes
        if (csWordpad[0] == L'"')
        {
            int nNextQuote = csWordpad.Find(L'"', 1);
            if (nNextQuote > 0)
            {
                csWordpad.Truncate(nNextQuote);
                csWordpad.Delete(0, 1);

                if (dwRegType == REG_EXPAND_SZ)
                {
                    csWordpad.ExpandEnvironmentStringsW();
                }

                return TRUE;
            }
        }
    }

    return FALSE;
}

void CorrectPathChangesUser::InitializePathFixes()
{
    // The order of this list is important.  Early entries may create paths that are modified by later entries.

    // Hardcoded bad path
    AddPathChangeW( L"c:\\windows",                                   L"%WinDir%" );
    // robkenny 4/2/2001 Do not redirect Program Files, because it is common to
    // create this directory on many hard drives, especially when c:\ is nearly full
//    AddPathChangeW( L"c:\\program files",                             L"%ProgramFiles%" );

    // Moved system applications
    AddPathChangeW( L"%WinDir%\\rundll32.exe",                        L"%SystemDir%\\rundll32.exe" );
    AddPathChangeW( L"%WinDir%\\rundll.exe",                          L"%SystemDir%\\rundll32.exe" );
    AddPathChangeW( L"%WinDir%\\write.exe",                           L"%SystemDir%\\write.exe" );
    AddPathChangeW( L"%WinDir%\\dxdiag.exe",                          L"%SystemDir%\\dxdiag.exe" );

    CSTRING_TRY
    {
        CString csWordpad;
        if (GetWordpadPath(csWordpad))
        {
            AddPathChangeW( L"%WinDir%\\wordpad.exe",                         csWordpad);
            AddPathChangeW( L"%ProgramFiles%\\Accessories\\wordpad.exe",      csWordpad);
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }


    // Win9x single user locations (also default)
    AddPathChangeW( L"%WinDir%\\Start Menu",                          L"%UserStartMenu%" );
    AddPathChangeW( L"%WinDir%\\Desktop",                             L"%UserDesktop%" );
    AddPathChangeW( L"%WinDir%\\Favorites",                           L"%UserFavorites%" );
    // These locations are properly internationalized.  Duplicates of above for English
    AddPathChangeW( L"%WinDir%\\%CSIDL_STARTMENU_NAME%",              L"%UserStartMenu%" );
    AddPathChangeW( L"%WinDir%\\%CSIDL_DESKTOPDIRECTORY_NAME%",       L"%UserDesktop%" );
    AddPathChangeW( L"%WinDir%\\%CSIDL_FAVORITES_NAME%",              L"%UserFavorites%" );


    // Win9x & WinNT multi user locations
    AddPathChangeW( L"%WinDir%\\Profiles\\%Username%\\Start Menu",                                  L"%UserStartMenu%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\%Username%\\Desktop",                                     L"%UserDesktop%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\%Username%\\Favorites",                                   L"%UserFavorites%" );
    // These locations are properly internationalized.  Duplicates of above for English
    AddPathChangeW( L"%WinDir%\\Profiles\\%Username%\\%CSIDL_STARTMENU_NAME%",                      L"%UserStartMenu%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\%Username%\\%CSIDL_DESKTOPDIRECTORY_NAME%",               L"%UserDesktop%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\%Username%\\%CSIDL_FAVORITES_NAME%",                      L"%UserFavorites%" );


    // WinNT all user location
    AddPathChangeW( L"%WinDir%\\Profiles\\All Users\\Start Menu",                                   L"%AllStartMenu%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\All Users\\Desktop",                                      L"%AllDesktop%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\All Users\\Favorites",                                    L"%UserFavorites%" ); // Should be %AllFavorites%, but IE 5.0 doesn't look there.
    // These locations are properly internationalized.  Duplicates of above for English
    AddPathChangeW( L"%WinDir%\\Profiles\\%AllUsersProfile_NAME%\\%CSIDL_STARTMENU_NAME%",          L"%AllStartMenu%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\%AllUsersProfile_NAME%\\%CSIDL_DESKTOPDIRECTORY_NAME%",   L"%AllDesktop%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\%AllUsersProfile_NAME%\\%CSIDL_FAVORITES_NAME%",          L"%UserFavorites%" ); // Should be %AllFavorites%, but IE 5.0 doesn't look there.


    // Win9x deleted DirectX files
    AddPathChangeW( L"ddhelp.exe",                                    L"ddraw.dll" );
    AddPathChangeW( L"ddraw16.dll",                                   L"ddraw.dll" );
    AddPathChangeW( L"dsound.vxd",                                    L"ddraw.dll" );
}

// Does the current process have permission to write into this directory?
BOOL CanWriteHere(DWORD clsid)
{
    BOOL bCanWriteHere = FALSE;

    WCHAR   wszDir[MAX_PATH];
    HRESULT result = SHGetFolderPathW( NULL, clsid, NULL, SHGFP_TYPE_DEFAULT, wszDir );
    if (SUCCEEDED(result))
    {
        WCHAR wszTempFile[MAX_PATH];

        // We do not use GetTempFileName() to test if we have permission
        // to the directory even though it does all that we need.  Unfortunately
        // the temp file will appear in the start menu since it is not hidden.
        // Emulate the behaviour of GetTempFileName but use our file attributes.


        // Loop a bunch of times attempting to create a temp file,
        // If we can create this file return immediately,
        // If we have insuffient permission return immediately
        // certain other errors will return immediately
        // otherwise we'll attempt to open the next temp file name

        // 100 is totally arbitrary: just need to attempt this a bunch of times
        static const int MaxTempFileAttempts = 100;

        int i;
        for (i = 0; i < MaxTempFileAttempts; ++i)
        {
            swprintf(wszTempFile, L"%s\\CFP%08x.tmp", wszDir, i);

            DPF("CanWriteHere", eDbgLevelSpew, "File(%S)\n", wszTempFile);

            HANDLE hTempFile = CreateFileW(
                wszTempFile,
                GENERIC_WRITE | DELETE,
                0, // no sharing
                NULL,
                CREATE_NEW,
                FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
                NULL
                );

            if (hTempFile != INVALID_HANDLE_VALUE)
            {
                DPF("CanWriteHere", eDbgLevelSpew, "success\n");

                CloseHandle(hTempFile);
                return TRUE;
            }
            else
            {
                // Borrowed this code from GetTempFileName:
                DWORD LastError = GetLastError();
                DPF("CanWriteHere", eDbgLevelSpew, "Error(0x%08x)\n", LastError);

                switch (LastError)
                {
                    case ERROR_INVALID_PARAMETER     :
                    case ERROR_WRITE_PROTECT         :
                    case ERROR_FILE_NOT_FOUND        :
                    case ERROR_BAD_PATHNAME          :
                    case ERROR_INVALID_NAME          :
                    case ERROR_PATH_NOT_FOUND        :
                    case ERROR_NETWORK_ACCESS_DENIED :
                    case ERROR_DISK_CORRUPT          :
                    case ERROR_FILE_CORRUPT          :
                    case ERROR_DISK_FULL             :
                        // An error from which we cannot recover...
                        return FALSE;

                    case ERROR_ACCESS_DENIED         :
                        // It's possible for us to hit this if there's a
                        // directory with the name we're trying; in that
                        // case, we can usefully continue.
                        // CreateFile() uses BaseSetLastNTError() to set
                        // LastStatusValue to the actual NT error in the
                        // TEB; we just need to check it, and only abort
                        // if it's not a directory.
                        // This was bug #397477.
                        if (NtCurrentTeb()->LastStatusValue != STATUS_FILE_IS_A_DIRECTORY)
                        {
                            // Insuffient permission
                            return FALSE;
                        }
                }
            }
        }

    }

    return bCanWriteHere;
}

void CorrectPathChangesAllUser::InitializePathFixes()
{
    CorrectPathChangesUser::InitializePathFixes();

    // The choice to put these values into All Users instead of <UserName>
    // was not taken lightly.  The problem is: some apps create  ...\All Users\Start Menu\folder
    // then attempt to place files into c:\windows\Start Menu\folder or username\Start Menu\folder.
    // Yes the apps are WRONG, but we want them to work.  By directing all of these paths
    // to All Users we *know* where the files will be placed and can make sure they all are the same place.

    // Another note, IE 5.0 does *not* look in All Users\Favorites for links,
    // so we force all favorites to end up in the user favorites.  Sheesh.

    // We add these changes twice, the first to convert any long path names to the All User dir,
    // the second to convert any short path names to All User.

    if (CanWriteHere(CSIDL_COMMON_STARTMENU))
    {
        AddPathChangeW( L"%UserStartMenu%",                               L"%AllStartMenu%" );
    }
    else
    {
        DPF("CorrectPathChangesAllUser", eDbgLevelInfo, "*NOT* forcing %UserStartMenu% to %AllStartMenu% -- insufficient permission");
    }

    /*
    // 05/11/2001 robkenny:
    // We are nolonger modifying the Desktop directory
    if (CanWriteHere(CSIDL_COMMON_DESKTOPDIRECTORY))
    {
        AddPathChangeW( L"%UserDesktop%",                                 L"%AllDesktop%" );
    }
    else
    {
        DPF("CorrectPathChangesAllUser", eDbgLevelInfo, "*NOT* forcing %UserDesktop% to %AllDesktop% -- insufficient permission");
    }
    */


    /*
    // IE 5.0/5.5 doesn't use All Users 
    if (CanWriteHere(CSIDL_COMMON_FAVORITES))
    {
        AddPathChangeW( L"%UserFavorites%",                              L"%AllFavorites%" ); // IE 5.0 doesn't use All Users
    }
    else
    {
        DPF("CorrectPathChangesAllUser", eDbgLevelInfo, "*NOT* forcing %UserFavorites% to %AllFavorites% -- insufficient permission");
    }
    */
}

};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\common.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    Common.cpp

 Abstract:

    Common functions for all modules

 Notes:

    None

 History:

    12/15/1999  linstev     Created
    01/10/2000  linstev     Format to new style
    03/14/2000  robkenny    Added StringWiden and StringNWiden,
                            StringSubstituteRoutine[A|W] was not using the proper compare routine
                            when calling recursively.
    07/06/2000  t-adams     Added IsImage16Bit
    10/18/2000  a-larrsh    Move PatternMatch to common removing redundent code in shims.
    10/25/2000  linstev     Cleaned up
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.
    09/11/2001  mnikkel     Modified DebugPrintfList, DebugPrintf, ShimLogList and ShimLog to retain LastError
    09/25/2001  rparsons    Modified logging code to use NT calls. Added critical section.
    10/18/2001  rparsons    Removed critical section, added mutex for logging.

--*/

#include "ShimHook.h"
#include "ShimLib.h"
#include "ShimHookMacro.h"
#include <stdio.h>



namespace ShimLib
{

BOOL                    g_bFileLogEnabled = FALSE;   // enable/disable file logging
WCHAR                   g_wszFileLog[MAX_PATH];       // name of the log file
HANDLE                  g_hMemoryHeap = INVALID_HANDLE_VALUE;
BOOL                    g_bDebugLevelInitialized = FALSE;
DEBUGLEVEL              g_DebugLevel = eDbgLevelBase;

inline HANDLE GetHeap()
{
    if (g_hMemoryHeap == INVALID_HANDLE_VALUE)
    {
        g_hMemoryHeap = HeapCreate(0, 0, 0);
    }

    return g_hMemoryHeap;
}

void * __cdecl ShimMalloc(size_t size)
{
    HANDLE heap = GetHeap();

    void* memory = HeapAlloc(heap, HEAP_ZERO_MEMORY, size);

    return memory;
}

void __cdecl ShimFree(void * memory)
{
    HANDLE heap = GetHeap();
    HeapFree(heap, 0, memory);
}

void * __cdecl ShimCalloc( size_t num, size_t size )
{
    size_t nBytes = size * num;
    void * callocMemory = ShimMalloc(nBytes);
    ZeroMemory(callocMemory, nBytes);

    return callocMemory;
}

void * __cdecl ShimRealloc(void * memory, size_t size)
{
    if (memory == NULL)
        return ShimMalloc(size);

    HANDLE heap = GetHeap();
    void * reallocMemory = HeapReAlloc(heap, 0, memory, size);

    return reallocMemory;
}


DEBUGLEVEL GetDebugLevel()
{
    CHAR cEnv[MAX_PATH];

    if (g_bDebugLevelInitialized) {
        return g_DebugLevel;
    }

    g_DebugLevel = eDbgLevelBase;

    if (GetEnvironmentVariableA(
            szDebugEnvironmentVariable,
            cEnv,
            MAX_PATH)) {

        CHAR c = cEnv[0];

        if ((c >= '0') || (c <= '9')) {
            g_DebugLevel = (DEBUGLEVEL)((int)(c - '0'));
        }
    }

    g_bDebugLevelInitialized = TRUE;

    return g_DebugLevel;
}

/*++

 Function Description:

    Assert that prints file and line number.

 Arguments:

    IN dwDetail -  Detail level above which no print will occur
    IN pszFmt   -  Format string

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

#if DBG
VOID
DebugAssert(
    LPCSTR      szFile,
    DWORD       dwLine,
    BOOL        bAssert,
    LPCSTR      szHelpString
    )
{
    if (!bAssert )
    {
        DPF("ShimLib", eDbgLevelError, "\n");
        DPF("ShimLib", eDbgLevelError, "ASSERT: %s\n", szHelpString);
        DPF("ShimLib", eDbgLevelError, "FILE: %s\n", szFile);
        DPF("ShimLib", eDbgLevelError, "LINE: %d\n", dwLine);
        DPF("ShimLib", eDbgLevelError, "\n");

        DebugBreak();
    }
}

/*++

 Function Description:

    Print a formatted string using DebugOutputString.

 Arguments:

    IN dwDetail -  Detail level above which no print will occur
    IN pszFmt   -  Format string

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/


VOID
DebugPrintfList(
    LPCSTR      szShimName,
    DEBUGLEVEL  dwDetail,
    LPCSTR       pszFmt,
    va_list     vaArgList
    )
{
    // This must be the first line of this routine to preserve LastError.
    DWORD dwLastError = GetLastError();

    extern DEBUGLEVEL GetDebugLevel();

    char szT[1024];

    szT[1022] = '\0';
    _vsnprintf(szT, 1022, pszFmt, vaArgList);

    // make sure we have a '\n' at the end of the string

    int len = lstrlen(szT);

    if (szT[len-1] != '\n')
    {
        lstrcpy(&szT[len], "\n");
    }


    if (dwDetail <= GetDebugLevel())
    {
        switch (dwDetail)
        {
        case eDbgLevelError:
            OutputDebugStringA ("[FAIL] ");
            break;
        case eDbgLevelWarning:
            OutputDebugStringA ("[WARN] ");
            break;
        case eDbgLevelInfo:
            OutputDebugStringA ("[INFO] ");
            break;
        }

        OutputDebugStringA(szShimName);

        OutputDebugStringA(" - ");

        OutputDebugStringA(szT);
    }

    // This must be the last line of this routine to preserve LastError.
    SetLastError(dwLastError);
}

VOID
DebugPrintf(
    LPCSTR      szShimName,
    DEBUGLEVEL  dwDetail,
    LPCSTR      pszFmt,
    ...
    )
{
    // This must be the first line of this routine to preserve LastError.
    DWORD dwLastError = GetLastError();

    va_list vaArgList;
    va_start(vaArgList, pszFmt);

    DebugPrintfList(szShimName, dwDetail, pszFmt, vaArgList);

    va_end(vaArgList);

    // This must be the last line of this routine to preserve LastError.
    SetLastError(dwLastError); }

#endif // DBG

/*++

 Function Description:

    Prints a log in the log file if logging is enabled

 Arguments:

    IN  pszFmt -  Format string

 Return Value:

    none

 History:

    03/03/2000 clupu  Created

--*/

#define MAX_LOG_LENGTH  1024

char g_szLog[MAX_LOG_LENGTH];


/*++

 Function Description:

    Prints a log in the log file if logging is enabled

 Arguments:

    IN wszShimName  -  Name of shim that string originates from
    IN dwDetail     -  Detail level above which no print will occur
    IN pszFmt       -  Format string

 Return Value:

    none

 History:

    03/03/2000 clupu  Created
    09/25/2001  rparsons    Converted to NT calls

--*/

void
ShimLogList(
    LPCSTR      szShimName,
    DEBUGLEVEL  dwDbgLevel,
    LPCSTR      pszFmt,
    va_list     arglist
    )
{
    //
    // This must be the first line of this routine to preserve LastError.
    //
    DWORD dwLastError = GetLastError();

    int                 nLen = 0;
    NTSTATUS            status;
    SYSTEMTIME lt;


    UNICODE_STRING      strLogFile = {0};
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    LARGE_INTEGER       liOffset;
    char                szNewLine[] = "\r\n";
    DWORD               dwWaitResult;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    HANDLE              hLogMutex;

    //
    // Convert the path to the log file from DOS to NT.
    //
    RtlInitUnicodeString(&strLogFile, g_wszFileLog);

    status = RtlDosPathNameToNtPathName_U(strLogFile.Buffer, &strLogFile, NULL, NULL);

    if (!NT_SUCCESS(status)) {
        DPF("ShimLib", eDbgLevelError,
            "[ShimLogList] 0x%X Failed to convert log file '%ls' to NT path",
            status, g_wszFileLog);
        return;
    }

    //
    // Attempt to get a handle to our log file.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          FILE_APPEND_DATA | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    RtlFreeUnicodeString(&strLogFile);

    if (!NT_SUCCESS(status)) {
        DPF("ShimLib", eDbgLevelError, "[ShimLogList] 0x%X Failed to open log file %ls",
            status, g_wszFileLog);
        return;
    }

    SetFilePointer(hFile, 0, NULL, FILE_END);

    //
    // Print a header consisting of data, time, app name, and shim name.
    //
    GetLocalTime(&lt);

    sprintf(g_szLog, "%02d/%02d/%04d %02d:%02d:%02d %s %d - ",
            lt.wMonth, lt.wDay,    lt.wYear,
            lt.wHour,  lt.wMinute, lt.wSecond,
            szShimName,
            dwDbgLevel);

    nLen = lstrlen(g_szLog);

    //
    // Write the header out to the file.
    //
    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    //
    // Get a handle to the mutex and attempt to get ownership.
    //
    hLogMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, "SHIMLIB_LOG_MUTEX");

    if (!hLogMutex) {
        DPF("ShimLib", eDbgLevelError, "[ShimLogList] %lu Failed to open logging mutex", GetLastError());
        goto exit;
    }

    dwWaitResult = WaitForSingleObject(hLogMutex, 500);

    if (WAIT_OBJECT_0 == dwWaitResult) {
        //
        // Write the header to the log file.
        //
        status = NtWriteFile(hFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             (PVOID)g_szLog,
                             (ULONG)nLen,
                             &liOffset,
                             NULL);

        if (!NT_SUCCESS(status)) {
            DPF("ShimLib", eDbgLevelError, "[ShimLogList] 0x%X Failed to write header to log file",
                status);
            goto exit;
        }

        //
        // Format our string using the specifiers passed.
        //
    _vsnprintf(g_szLog, MAX_LOG_LENGTH - 1, pszFmt, arglist);
    g_szLog[MAX_LOG_LENGTH - 1] = 0;

        //
        // Write the actual data out to the file.
        //
        IoStatusBlock.Status = 0;
        IoStatusBlock.Information = 0;

        liOffset.LowPart  = 0;
        liOffset.HighPart = 0;

        nLen = lstrlen(g_szLog);

        status = NtWriteFile(hFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             (PVOID)g_szLog,
                             (ULONG)nLen,
                             &liOffset,
                             NULL);

        if (!NT_SUCCESS(status)) {
            DPF("ShimLib", eDbgLevelError, "[ShimLogList] 0x%X Failed to make entry in log file",
                status);
            goto exit;
        }

        //
        // Now write a new line to the log file.
        //
        IoStatusBlock.Status = 0;
        IoStatusBlock.Information = 0;

        liOffset.LowPart  = 0;
        liOffset.HighPart = 0;

        nLen = lstrlen(szNewLine);

        status = NtWriteFile(hFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             (PVOID)szNewLine,
                             (ULONG)nLen,
                             &liOffset,
                             NULL);

        if (!NT_SUCCESS(status)) {
            DPF("ShimLib", eDbgLevelError, "[ShimLogList] 0x%X Failed to write new line to log file",
                status);
            goto exit;
        }
    }

    //
    // Dump it out to the debugger on checked builds.
    //
#if DBG
    DebugPrintf(szShimName, dwDbgLevel, g_szLog);
    DebugPrintf(szShimName, dwDbgLevel, "\n");
#endif // DBG

exit:

    if (INVALID_HANDLE_VALUE != hFile) {
        NtClose(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    if (hLogMutex) {
        ReleaseMutex(hLogMutex);
    }

    //
        // This must be the last line of this routine to preserve LastError.
    //
    SetLastError(dwLastError);
}


/*++

 Function Description:

    Initializes the support for file logging.

 Arguments:

    IN  pszShim - the name of the shim DLL

 Return Value:

    TRUE if successful, FALSE if failed

 History:

    03/03/2000 clupu  Created

--*/

BOOL
InitFileLogSupport(
    char *pszShim
    )
{
    BOOL                fReturn = FALSE;
    WCHAR               wszAppPatch[MAX_PATH];
    WCHAR*              pwsz = NULL;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    HANDLE              hLogMutex = NULL;
    DWORD               dwLen = 0;
    NTSTATUS            status;
    UNICODE_STRING      strLogFile = {0};
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;

    //
    // Attempt to create a mutex. If the mutex already exists,
    // we don't need to go any further as the log file has
    // already been created.
    //
    hLogMutex = CreateMutex(NULL, TRUE, "SHIMLIB_LOG_MUTEX");

    if (!hLogMutex) {
        DPF("ShimLib", eDbgLevelError, "[InitFileLogSupport] Failed to create logging mutex");
        return FALSE;
    }

    DWORD dwLastError = GetLastError();

    if (ERROR_ALREADY_EXISTS == dwLastError) {
        fReturn = TRUE;
        goto exit;
    }

    //
    // We'll create the log file in %windir%\AppPatch.
    //
    if (!GetSystemWindowsDirectoryW(g_wszFileLog, MAX_PATH)) {
        DPF("ShimLib", eDbgLevelError, "[InitFileLogSupport] Failed to get windir path");
        goto exit;
    }

    lstrcatW(g_wszFileLog, L"\\AppPatch\\");

    dwLen = lstrlenW(g_wszFileLog);
    pwsz = g_wszFileLog + dwLen;

    //
    // Query the environment variable and get the name of our log file.
    //
    if (!GetEnvironmentVariableW(wszFileLogEnvironmentVariable,
                                 pwsz,
                                 (MAX_PATH - dwLen) * sizeof(WCHAR))) {
        goto exit;
    }

    //
    // Convert the path to the log file from DOS to NT.
    //
    RtlInitUnicodeString(&strLogFile, g_wszFileLog);

    status = RtlDosPathNameToNtPathName_U(strLogFile.Buffer, &strLogFile, NULL, NULL);

    if (!NT_SUCCESS(status)) {
        DPF("ShimLib", eDbgLevelError,
            "[InitFileLogSupport] 0x%X Failed to convert log file '%ls' to NT path",
            status, g_wszFileLog);
        goto exit;
    }

    //
    // Attempt to create the log file. If it exists, the contents will be cleared.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          GENERIC_WRITE | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN_IF,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    RtlFreeUnicodeString(&strLogFile);

    if (!NT_SUCCESS(status)) {
        DPF("ShimLib", eDbgLevelError, "[InitFileLogSupport] 0x%X Failed to open log file %ls",
            status, g_wszFileLog);
        goto exit;
    }

    NtClose(hFile);

    //
    // Turn on the flag that tells everyone that logging is enabled.
    // Release the mutex so that others can use it.
    //
    g_bFileLogEnabled = TRUE;


    fReturn = TRUE;

exit:

    ReleaseMutex(hLogMutex);

    return fReturn;
}


/*++

 Function Description:

    Determine the drive type a file resides on.

 Arguments:

    IN lpFileName - Filename or relative filename

 Return Value:

    See GetDriveType in MSDN

 History:

    10/25/2000 linstev  Created

--*/

UINT
GetDriveTypeFromFileNameA(LPCSTR lpFileName, char *lpDriveLetter)
{
    WCHAR * lpwszFileName = ToUnicode(lpFileName);
    if (lpwszFileName)
    {
        WCHAR szDrive;
        UINT uType = GetDriveTypeFromFileNameW(lpwszFileName, &szDrive);

        if (lpDriveLetter)
        {
            *lpDriveLetter = (char) szDrive;
        }

        free(lpwszFileName);

        return uType;
    }
    else
    {
        return DRIVE_UNKNOWN;
    }
}

/*++

 Function Description:

    Determine the drive type a file resides on.

 Arguments:

    IN lpFileName - Filename or relative filename

 Return Value:

    See GetDriveType in MSDN

 History:

    10/25/2000 linstev  Created

--*/

UINT
GetDriveTypeFromFileNameW(LPCWSTR lpFileName, WCHAR *lpDriveLetter)
{
    if (lpFileName && (lpFileName[0] == L'\\') && (lpFileName[1] == L'\\'))
    {
        // UNC naming - always network
        if (lpDriveLetter)
        {
            *lpDriveLetter = L'\0';
        }
        return DRIVE_REMOTE;
    }

    WCHAR cDrive;

    if (lpFileName && lpFileName[0] && (lpFileName[1] == L':'))
    {
        // Format is Drive:Path\File, so just take the drive
        cDrive = lpFileName[0];
    }
    else
    {
        // Must be a relative path
        cDrive = 0;

        WCHAR *wzCurDir = NULL;
        DWORD dwCurDirSize = GetCurrentDirectoryW(0, wzCurDir);

        if (!dwCurDirSize)
        {
            goto EXIT;
        }

        wzCurDir = (LPWSTR) LocalAlloc(LPTR, dwCurDirSize * sizeof(WCHAR));
        if (!wzCurDir)
        {
            goto EXIT;
        }

        dwCurDirSize = GetCurrentDirectoryW(dwCurDirSize, wzCurDir);
        if (!dwCurDirSize || wzCurDir[0] == L'\\')
        {
            goto EXIT;
        }

        cDrive = wzCurDir[0];

    EXIT:
        if (wzCurDir)
        {
            LocalFree(wzCurDir);
        }
    }

    if (lpDriveLetter)
    {
        *lpDriveLetter = L'\0';
    }

    if (cDrive)
    {
        WCHAR wzDrive[4];
        wzDrive[0] = cDrive;
        wzDrive[1] = L':';
        wzDrive[2] = L'\\';
        wzDrive[3] = L'\0';
        if (lpDriveLetter)
        {
            *lpDriveLetter = (WCHAR)cDrive;
        }

        return GetDriveTypeW(wzDrive);
    }
    else
    {
        return DRIVE_UNKNOWN;
    }
}

/*++

 Function Description:

    Widen and duplicate a string into malloc memory.

 Arguments:

    IN  strToCopy - String to copy

 Return Value:

    String in malloc memory

 History:

    03/07/2000 robkenny Created
    05/16/2000 robkenny Moved MassagePath (shim specific) routines out of here.

--*/

WCHAR *
ToUnicode(const char *strToCopy)
{
    if (strToCopy == NULL)
    {
        return NULL;
    }

    // Get the number of characters in the resulting string, includes NULL at end
    int nChars = MultiByteToWideChar(CP_ACP, 0, strToCopy, -1, NULL, 0);
    WCHAR *lpwsz = (WCHAR *) malloc(nChars * sizeof(WCHAR));
    if (lpwsz)
    {
        nChars = MultiByteToWideChar(CP_ACP, 0, strToCopy, -1, lpwsz, nChars);
        // If MultibyteToWideChar failed, return NULL
        if (nChars == 0)
        {
            free(lpwsz);
            lpwsz = NULL;
        }
    }

    return lpwsz;
}


/*++

 Function Description:

    Convert a WCHAR string to a char string

 Arguments:

    IN  lpOld - String to convert to char

 Return Value:

    char string in malloc memory

 History:

    06/19/2000 robkenny Created

--*/

char *
ToAnsi(const WCHAR *lpOld)
{
    if (lpOld == NULL)
    {
        return NULL;
    }

    // Get the number of bytes necessary for the WCHAR string
    int nBytes = WideCharToMultiByte(CP_ACP, 0, lpOld, -1, NULL, 0, NULL, NULL);
    char *lpsz = (char *) malloc(nBytes);
    if (lpsz)
    {
        nBytes = WideCharToMultiByte(CP_ACP, 0, lpOld, -1, lpsz, nBytes, NULL, NULL);
        // If WideCharToMultibyte failed, return NULL
        if (nBytes == 0)
        {
            free(lpsz);
            lpsz = NULL;
        }
    }

    return lpsz;
}

/*++

 Function Description:

    Duplicate the first nChars of strToCopy string into malloc memory.

 Arguments:

    IN  strToCopy - String to copy
    IN  nChar     - Number of chars to duplicate, does not count NULL at end.

 Return Value:

    String in malloc memory

 History:

    06/02/2000 robkenny Created

--*/

char *
StringNDuplicateA(const char *strToCopy, int nChars)
{
    if (strToCopy == NULL)
    {
        return NULL;
    }

    size_t nBytes = (nChars + 1) * sizeof(strToCopy[0]);

    char *strDuplicate = (char *) malloc(nBytes);
    if (strDuplicate)
    {
        memcpy(strDuplicate, strToCopy, nBytes);
        strDuplicate[nChars] = 0;
    }

    return strDuplicate;
}

/*++

 Function Description:

    Duplicate a string into malloc memory.

 Arguments:

    IN  strToCopy - String to copy

 Return Value:

    String in malloc memory

 History:

    01/10/2000 linstev  Updated
    02/14/2000 robkenny Converted from VirtualAlloc to malloc
    06/02/2000 robkenny Use StringNDuplicateA

--*/

char *
StringDuplicateA(const char *strToCopy)
{
    if (strToCopy == NULL)
    {
        return NULL;
    }

    char *strDuplicate = StringNDuplicateA(strToCopy, strlen(strToCopy));
    return strDuplicate;
}

/*++

 Function Description:

    Duplicate the first nChars of strToCopy string into malloc memory.

 Arguments:

    IN  strToCopy - String to copy
    IN  nChar     - Number of chars to duplicate, does not count NULL at end.

 Return Value:

    String in malloc memory

 History:

    06/02/2000 robkenny Created

--*/

WCHAR *
StringNDuplicateW(const WCHAR *strToCopy, int nChars)
{
    if (strToCopy == NULL)
    {
        return NULL;
    }

    size_t nBytes = (nChars + 1) * sizeof(strToCopy[0]);

    WCHAR *strDuplicate = (WCHAR *) malloc(nBytes);
    if (strDuplicate)
    {
        memcpy(strDuplicate, strToCopy, nBytes);
        strDuplicate[nChars] = 0;
    }

    return strDuplicate;
}

/*++

 Function Description:

    Duplicate a string into malloc memory.

 Arguments:

    IN  strToCopy - String to copy

 Return Value:

    String in malloc memory

 History:

    01/10/2000 linstev  Updated
    02/14/2000 robkenny Converted from VirtualAlloc to malloc
    06/02/2000 robkenny Use StringNDuplicateW

--*/

WCHAR *
StringDuplicateW(const WCHAR *strToCopy)
{
    if (strToCopy == NULL)
    {
        return NULL;
    }

    WCHAR *wstrDuplicate = StringNDuplicateW(strToCopy, wcslen(strToCopy));
    return wstrDuplicate;
}


/*++

 Function Description:

    Skip leading whitespace

 Arguments:

    IN  str - String to scan

 Return Value:

    None

 History:

    01/10/2000 linstev  Updated

--*/

VOID
SkipBlanksW(const WCHAR *& str)
{
    if (str)
    {
        // Skip leading whitespace
        static const WCHAR *WhiteSpaceString = L" \t";
        str += wcsspn(str, WhiteSpaceString);
    }
}

/*++

 Function Description:

    Find the first occurance of strCharSet in string
    Case insensitive

 Arguments:

    IN string            - String to search
    IN strCharSet        - String to search for

 Return Value:

    First occurance or NULL

 History:

    12/01/1999 robkenny Created
    12/15/1999 linstev  Reformatted

--*/

char*
__cdecl
stristr(
    IN const char* string,
    IN const char* strCharSet
    )
{
    char *pszRet = NULL;

    long  nstringLen = strlen(string) + 1;
    long  nstrCharSetLen = strlen(strCharSet) + 1;

    char *szTemp_string = (char *) malloc(nstringLen);
    char *szTemp_strCharSet = (char *) malloc(nstrCharSetLen);

    if ((!szTemp_string) || (!szTemp_strCharSet))
    {
        goto Fail;
    }

    strcpy(szTemp_string, string);
    strcpy(szTemp_strCharSet, strCharSet);
    _strlwr(szTemp_string);
    _strlwr(szTemp_strCharSet);

    pszRet = strstr(szTemp_string, szTemp_strCharSet);

    if (pszRet)
    {
        pszRet = ((char *) string) + (pszRet - szTemp_string);
    }

Fail:
    if (szTemp_string)
    {
        free(szTemp_string);
    }

    if (szTemp_strCharSet)
    {
        free(szTemp_strCharSet);
    }

    return pszRet;
}

/*++

 Function Description:

    Find the first occurance of strCharSet in string
    Case insensitive

 Arguments:

    IN string            - String to search
    IN strCharSet        - String to search for

 Return Value:

    First occurance or NULL

 History:

    12/01/1999 robkenny Created
    12/15/1999 linstev  Reformatted
    05/04/2001 maonis   Changed to use more efficient implementation.

--*/

#define _UPPER          0x1 /* upper case letter */
#define iswupper(_c)    (iswctype(_c,_UPPER))

WCHAR*
__cdecl
wcsistr(
    IN const WCHAR* wcs1,
    IN const WCHAR* wcs2
    )
{
    wchar_t *cp = (wchar_t *) wcs1;
    wchar_t *s1, *s2;
    wchar_t cs1, cs2;

    while (*cp)
    {
            s1 = cp;
            s2 = (wchar_t *) wcs2;

            cs1 = *s1;
            cs2 = *s2;

            if (iswupper(cs1))
                cs1 = towlower(cs1);

            if (iswupper(cs2))
                cs2 = towlower(cs2);


            while ( *s1 && *s2 && !(cs1-cs2) ) {

                s1++, s2++;

                cs1 = *s1;
                cs2 = *s2;

                if (iswupper(cs1))
                    cs1 = towlower(cs1);

                if (iswupper(cs2))
                    cs2 = towlower(cs2);
            }

            if (!*s2)
                    return(cp);

            cp++;
    }

    return(NULL);
}

/*++

 Function Description:

    Find the next token in a string. See strtok in MSDN.
    Implemented here so we don't need CRT.

 Arguments:

    OUT strToken   - string containing token(s)
    IN  strDelimit - token list

 Return Value:

    Return a pointer to the next token found.

 History:

    04/19/2000 linstev  Created

--*/

char *
__cdecl
_strtok(
    char *strToken,
    const char *strDelimit
    )
{
    unsigned char *str = (unsigned char *)strToken;
    const unsigned char *ctrl = (const unsigned char *)strDelimit;

    unsigned char map[32];
    int count;
    char *token;

    static char *nextoken;

    // Clear strDelimit map
    for (count = 0; count < 32; count++)
    {
        map[count] = 0;
    }

    // Set bits in delimiter table
    do
    {
        map[*ctrl >> 3] |= (1 << (*ctrl & 7));
    } while (*ctrl++);

    // If strToken==NULL, continue with previous strToken
    if (!str)
    {
        str = (unsigned char *)nextoken;
    }

    // Find beginning of token (skip over leading delimiters). Note that
    // there is no token iff this loop sets strToken to point to the terminal
    // null (*strToken == '\0')
    while ((map[*str >> 3] & (1 << (*str & 7))) && *str)
    {
        str++;
    }

    token = (char *)str;

    // Find the end of the token. If it is not the end of the strToken,
    // put a null there.
    for (; *str; str++)
    {
        if (map[*str >> 3] & (1 << (*str & 7)))
        {
            *str++ = '\0';
            break;
        }
    }

    // Update nextoken (or the corresponding field in the per-thread data
    // structure
    nextoken = (char *)str;

    // Determine if a token has been found
    if (token == (char *)str)
    {
        return NULL;
    }
    else
    {
        return token;
    }
}

/*++

 Function Description:

    Copy lpSrc into lpDest without overflowing the buffer

 Arguments:

    OUT lpDest            Destination string
    IN  nDestChars        Size in chars of lpDest
    IN  lpSrc             Original string
    IN  nSrcChars         Number of chars to copy

 Return Value:

    Returns the number of chars copied into lpDest

 History:

    04/19/2000 Robkenny  Created

--*/

int
SafeStringCopyW(
    WCHAR *lpDest,
    DWORD nDestChars,
    const WCHAR *lpSrc,
    DWORD nSrcChars
    )
{
    size_t nCharsToCopy = __min(nSrcChars, nDestChars);
    if (nCharsToCopy > 0)
    {
        memcpy(lpDest, lpSrc, nCharsToCopy*sizeof(WCHAR));

        // Make sure string is properly terminated
        if (lpSrc[nSrcChars-1] == 0)
        {
            lpDest[nCharsToCopy-1] = 0;
        }
    }

    return nCharsToCopy;
}


/*++

 Function Description:

    Tests whether an executable is 16-Bit.

 Arguments:

    IN  szImageName - The name of the executable image.

 Return Value:

    TRUE if executable image is found to be 16-bit, FALSE otherwise.

 History:

    07/06/2000 t-adams  Created

--*/

BOOL
IsImage16BitA(LPCSTR lpApplicationName)
{
    DWORD dwBinaryType;

    if (GetBinaryTypeA(lpApplicationName, &dwBinaryType))
    {
        return (dwBinaryType == SCS_WOW_BINARY);
    }
    else
    {
        return FALSE;
    }
}

/*++

 Function Description:

    Tests whether an executable is 16-Bit.

 Arguments:

    IN  wstrImageName - The name of the executable image.

 Return Value:

    TRUE if executable image is found to be 16-bit, FALSE otherwise.

 History:

    07/06/2000 t-adams  Created

--*/

BOOL
IsImage16BitW(LPCWSTR lpApplicationName)
{
    DWORD dwBinaryType;

    if (GetBinaryTypeW(lpApplicationName, &dwBinaryType))
    {
        return (dwBinaryType == SCS_WOW_BINARY);
    }
    else
    {
        return FALSE;
    }
}

/*++

 Function Description:

    Match these two strings, with wildcards.
    ? matches a single character
    * matches 0 or more characters
    The compare is case in-sensitive

 Arguments:

    IN  pszPattern - Pattern for matching.
    IN  pszTestString - String to match against.

 Return Value:

    TRUE if pszTestString matches pszPattern.

 History:

    01/09/2001  markder     Replaced non-straightforward version.

--*/

BOOL
PatternMatchW(
    IN  LPCWSTR pszPattern,
    IN  LPCWSTR pszTestString)
{
    //
    // March through pszTestString. Each time through the loop,
    // pszTestString is advanced one character.
    //
    BOOL bDone = TRUE;
    while (bDone) {

        //
        // If pszPattern and pszTestString are both sitting on a NULL,
        // then they reached the end at the same time and the strings
        // must be equal.
        //
        if (*pszPattern == L'\0' && *pszTestString == L'\0') {
            return TRUE;
        }

        if (*pszPattern != L'*') {

            //
            // Non-asterisk mode. Look for a match on this character.
            //

            switch (*(pszPattern)) {

            case L'?':
                //
                // Match on any character, don't bother comparing.
                //
                pszPattern++;
                break;

            case L'\\':
                //
                // Backslash indicates to take the next character
                // verbatim. Advance the pointer before making a
                // comparison.
                //
                pszPattern++;

            default:
                //
                // Compare the characters. If equal, continue traversing.
                // Otherwise, the strings cannot be equal so return FALSE.
                //
                if (towupper(*pszPattern) == towupper(*pszTestString)) {
                    pszPattern++;
                } else {
                    return FALSE;
                }
            }

        } else {

            //
            // Asterisk mode. Look for a match on the character directly
            // after the asterisk.
            //

            switch (*(pszPattern + 1)) {

            case L'*':
                //
                // Asterisks exist side by side. Advance the pattern pointer
                // and go through loop again.
                //
                pszPattern++;
                continue;

            case L'\0':
                //
                // Asterisk exists at the end of the pattern string. Any
                // remaining part of pszTestString matches so we can
                // immediately return TRUE.
                //
                return TRUE;

            case L'?':
                //
                // Match on any character. If the remaining parts of
                // pszPattern and pszTestString match, then the entire
                // string matches. Otherwise, keep advancing the
                // pszTestString pointer.
                //
                if (PatternMatchW(pszPattern + 1, pszTestString)) {
                    return TRUE;
                }
                break;

            case L'\\':
                //
                // Backslash indicates to take the next character
                // verbatim. Advance the pointer before making a
                // comparison.
                //
                pszPattern++;
                break;
            }

            if (towupper(*(pszPattern + 1)) == towupper(*pszTestString)) {
                //
                // Characters match. If the remaining parts of
                // pszPattern and pszTestString match, then the entire
                // string matches. Otherwise, keep advancing the
                // pszTestString pointer.
                //
                if (PatternMatchW(pszPattern + 1, pszTestString)) {
                    return TRUE;
                }
            }
        }

        //
        // No more pszTestString left. Must not be a match.
        //
        if (!*pszTestString) {
            return FALSE;
        }

        pszTestString++;
    }
    return FALSE;
}

/*++

 Function Description:

    Determine if the current process is a SafeDisc process. We do this by
    simply by testing if both an .EXE and .ICD extension exist for the
    process name.

 Arguments:

    None.

 Return Value:

    TRUE if Safedisc 1.x is detected.

 History:

    01/23/2001  linstev   Created

--*/

BOOL
bIsSafeDisc1()
{
    BOOL bRet = FALSE;
    WCHAR szFileName[MAX_PATH+1];

    if (GetModuleFileNameW(NULL, szFileName, MAX_PATH)) {
        //
        // Find the extension: first '.' after '\'
        //

        WCHAR *lpExtension = wcsrchr(szFileName, L'.');
        if (lpExtension && (lpExtension > wcsrchr(szFileName, L'\\'))) {

            //
            // Detect SafeDisc 1.X, just look for an .ICD file with the same
            // name
            //

            if (_wcsicmp(lpExtension, L".EXE") == 0) {
                // Current file is .EXE, check for corresponding .ICD
                wcscpy(lpExtension, L".ICD");
                bRet = GetFileAttributesW(szFileName) != 0xFFFFFFFF;
            }
        }
    }

    if (bRet) {
        DPF("ShimLib", eDbgLevelInfo, "SafeDisc detected: %S", szFileName);
    }

    return bRet;
}

/*++

 Function Description:

    Determine if the current process is a SafeDisc process. We do this running the
    image header and looking for a particular signature.

 Arguments:

    None.

 Return Value:

    TRUE if Safedisc 2 is detected.

 History:

    07/28/2001  linstev   Created

--*/

BOOL
bIsSafeDisc2()
{
    PPEB Peb = NtCurrentPeb();
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    DWORD dwCnt = 0;

    //
    // Use the try-except in case the module list changes while we're looking at it
    //
    __try {
        //
        // Loop through the loaded modules. We use a count to make sure we
        // aren't looping infinitely
        //
        LdrHead = &Peb->Ldr->InMemoryOrderModuleList;

        LdrNext = LdrHead->Flink;

        while ((LdrNext != LdrHead) && (dwCnt < 256)) {

            PLDR_DATA_TABLE_ENTRY LdrEntry;

            LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

            if ((SSIZE_T)LdrEntry->DllBase > 0) {
                //
                // A user mode dll, now check for temp name
                //
                WCHAR *wzName = LdrEntry->BaseDllName.Buffer;
                DWORD dwLen;

                if (wzName && (dwLen = wcslen(wzName)) && (dwLen > 4) && (_wcsicmp(wzName + dwLen - 4, L".tmp") == 0)) {
                    //
                    // Name ends in .tmp, so detect SafeDisc
                    //
                    DWORD_PTR hMod = (DWORD_PTR) LdrEntry->DllBase;
                    PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER) hMod;
                    PIMAGE_NT_HEADERS pINTH = (PIMAGE_NT_HEADERS)(hMod + pIDH->e_lfanew);
                    PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY) (hMod + pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
                    LPSTR pName = (LPSTR)(hMod + pExport->Name);

                    if (_stricmp(pName, "SecServ.dll") == 0) {
                        //
                        // Export name says this is SafeDisc
                        //
                        DPF("ShimLib", eDbgLevelInfo, "SafeDisc 2 detected");
                        return TRUE;
                    }
                }
            }

            dwCnt++;
            LdrNext = LdrEntry->InMemoryOrderLinks.Flink;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        DPF("ShimLib", eDbgLevelError, "Exception encounterd while detecting SafeDisc 2");
    }

    return FALSE;
}

/*++

 Function Description:

    Determine if the current process is NTVDM.

 Arguments:

    None.

 Return Value:

    TRUE if NTVDM is detected.

 History:

    01/14/2002  clupu   Created

--*/

BOOL
IsNTVDM(
    void
    )
{
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY           Head;
    PPEB                  Peb = NtCurrentPeb();

    Head = &Peb->Ldr->InLoadOrderModuleList;
    Head = Head->Flink;

    Entry = CONTAINING_RECORD(Head, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

    if (_wcsicmp(Entry->FullDllName.Buffer, L"ntvdm.exe") == 0) {
        return TRUE;
    }

    return FALSE;
}

};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\hookcallback.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    HookCallback.cpp

 Abstract:

    Hooking mechanism for callbacks.

 Notes:

    Use the HookCallback mechanism to hook any type of callback
    function, like an application-defined WindowProc. HookCallback
    will register your hook and insert an extra parameter -- pfnOld.
    This will allow you to call the actual callback from your stub
    function. pfnOld is inserted as the first parameter. Do not pass
    pfnOld to the original callback, use the real prototype for the
    callback.

    See the shim DisableW2KOwnerDrawButtonStates for example usage.

 History:

    02/16/2000  markder     Created
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.

--*/

#include <ShimHook.h>


namespace ShimLib
{

#pragma pack(push)
#pragma pack(1)
typedef struct _JUMPTABLEENTRY
{
    BYTE                PopEax;
    BYTE                PushDword;
    PVOID               pfnOld;
    BYTE                PushEax;
    BYTE                Jmp[2];
    PVOID               ppfnNew;
    PVOID               pfnNew;
    _JUMPTABLEENTRY*    pNextEntry;
} JUMPTABLEENTRY, *PJUMPTABLEENTRY;
#pragma pack(pop)


PJUMPTABLEENTRY g_pCallbackJumpTable = NULL;

// defines from user.h to tell if a windowproc is actually a handle to a CPD
#define HMINDEXBITS             0x0000FFFF      // bits where index is stored
#define CPDHANDLE_HI            ((ULONG_PTR)~HMINDEXBITS)
#define ISCPDTAG(x)             (((ULONG_PTR)(x) & CPDHANDLE_HI) == CPDHANDLE_HI)

/*++

 Function Description:
    
    Registers a callback hook.

 Arguments:

    IN pfnOld   -  The original callback function address.
    IN pfnNew   -  The new (stub) callback function address.

 Return Value: 
    
    The address to be passed in as the callback. If you wanted
    to hook the progress routine that is called when you use
    the MoveFileWithProgress API, simply hook the API through the
    normal shim mechanism and then use this function to obtain a new
    address to pass in as lpProgressRoutine.

 History:

    11/01/1999 markder  Created

--*/

PVOID 
HookCallback(PVOID pfnOld, PVOID pfnNew)
{
    PJUMPTABLEENTRY pJT = g_pCallbackJumpTable;

    if (pfnOld == NULL)
    {
        // NULL has been passed in. Ignore this call.
        pJT = NULL;
        goto eh;
    }

    if (ISCPDTAG(pfnOld) || IsBadCodePtr((FARPROC)pfnOld)) 
    {

        // This isn't a normal procedure call, and must be from a system DLL.
        // We should ignore it.

        pJT = (PJUMPTABLEENTRY)pfnOld;
        goto eh;
    }

    // Check to see if we have already made an entry for this pfnOld. If so,
    // just pass back the existing jump table.
    while (pJT != NULL)
    {
        if (pJT->pfnOld == pfnOld)
            break;

        pJT = pJT->pNextEntry;
    }

    if (pJT == NULL)
    {
        // Note that this table is allocated and never freed because
        // the entries will be used right up until the very last message
        // is sent to a window. There is no opportunity for cleanup.
        pJT = (PJUMPTABLEENTRY) HeapAlloc(GetProcessHeap(),
                                          HEAP_GENERATE_EXCEPTIONS,
                                          sizeof(JUMPTABLEENTRY) );

        // Fill in assembler. Each hard-coded hex value is the i386
        // opcode for the particular instruction.
        pJT->PopEax     = 0x58;     // Pop off return address
        pJT->PushDword  = 0x68;     // Push pfnOld as extra parameter
        pJT->pfnOld     = pfnOld;   
        pJT->PushEax    = 0x50;     // Push return address back on
        pJT->Jmp[0]     = 0xFF;     // Jump to pfnNew
        pJT->Jmp[1]     = 0x25;
        pJT->ppfnNew    = &(pJT->pfnNew);

        // Fill in data members
        pJT->pfnNew     = pfnNew;
        pJT->pNextEntry = g_pCallbackJumpTable;

        // Add to top of list
        g_pCallbackJumpTable = pJT;
    }

eh:
    DPF("ShimLib", eDbgLevelInfo, "CallbackHook( pfnOld = 0x%08X, pfnNew = 0x%08X ) returned 0x%08X\n", pfnOld, pfnNew, pJT);

    return pJT;
}




};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\internal.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    Internal.cpp

 Abstract:

    Common functions that use internals.

 Notes:

    None

 History:

    01/10/2000  linstev     Created
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <windef.h>


namespace ShimLib
{


/*++

 Function Description:
    
    Determine the device type from an open handle.

 Arguments:

    IN hFile - Handle to an open file

 Return Value: 
    
    Same as GetDriveType

 History:

    01/10/2000 linstev  Updated

--*/

// These are in winbase, which we don't want to include
#define DRIVE_UNKNOWN     0
#define DRIVE_NO_ROOT_DIR 1
#define DRIVE_REMOVABLE   2
#define DRIVE_FIXED       3
#define DRIVE_REMOTE      4
#define DRIVE_CDROM       5
#define DRIVE_RAMDISK     6

UINT  
GetDriveTypeFromHandle(HANDLE hFile)
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInformation;

    Status = NtQueryVolumeInformationFile(
        hFile,
        &IoStatusBlock,
        &DeviceInformation,
        sizeof(DeviceInformation),
        FileFsDeviceInformation);

    UINT uRet;

    if (NT_SUCCESS(Status))
    {
        switch (DeviceInformation.DeviceType) 
        {
        case FILE_DEVICE_NETWORK:
        case FILE_DEVICE_NETWORK_FILE_SYSTEM:
            uRet = DRIVE_REMOTE;
            break;

        case FILE_DEVICE_CD_ROM:
        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
            uRet = DRIVE_CDROM;
            break;

        case FILE_DEVICE_VIRTUAL_DISK:
            uRet = DRIVE_RAMDISK;
            break;

        case FILE_DEVICE_DISK:
        case FILE_DEVICE_DISK_FILE_SYSTEM:
            if (DeviceInformation.Characteristics & FILE_REMOVABLE_MEDIA) 
            {
                uRet = DRIVE_REMOVABLE;
            }
            else 
            {
                uRet = DRIVE_FIXED;
            }
            break;

        default:
            uRet = DRIVE_UNKNOWN;
            break;
        }
    }
    else
    {
        uRet = DRIVE_UNKNOWN;
    }

    return uRet;
}

/*++

 Function Description:
    
    Cause a break

 Arguments:

    None

 Return Value: 
    
    None

 History:

    10/25/2000 linstev  Added this comment

--*/

void APPBreakPoint(void)
{
    DbgBreakPoint();
}


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\rtlutils.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    rtlutils.cpp

 Abstract:
    
    Contains functions from ntdll on XP
    that are not available on W2K.

 History:

    09/10/2001  rparsons    Created

--*/

#include "rtlutils.h"

namespace ShimLib
{

#define IS_PATH_SEPARATOR_U(ch) (((ch) == L'\\') || ((ch) == L'/'))

extern const UNICODE_STRING RtlpDosDevicesPrefix    = RTL_CONSTANT_STRING( L"\\??\\" );
extern const UNICODE_STRING RtlpDosDevicesUncPrefix = RTL_CONSTANT_STRING( L"\\??\\UNC\\" );

const UNICODE_STRING RtlpEmptyString = RTL_CONSTANT_STRING(L"");

//
// Taken from %SDXROOT%\public\sdk\inc\ntrtl.h
//
#if DBG
#undef ASSERT
#define ASSERT( exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
        TRUE)
#else
#undef ASSERT
#define ASSERT( exp )         ((void) 0)
#endif
        
#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) \
                                    || (x) == STATUS_OBJECT_NAME_NOT_FOUND    \
                                    ) \
                                ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)
                                


                                
//
// These functions were taken from:
// %SDXROOT%\base\ntdll\ldrinit.c
//
PVOID
ShimAllocateStringRoutine(
    SIZE_T NumberOfBytes
    )
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, NumberOfBytes);
}

VOID
ShimFreeStringRoutine(
    PVOID Buffer
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
}

//
// These functions were pulled from:
// %SDXROOT%\base\ntdll\curdir.c
//

RTL_PATH_TYPE
NTAPI
ShimDetermineDosPathNameType_Ustr(
    IN PCUNICODE_STRING String
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines the
    type of file name (i.e.  UNC, DriveAbsolute, Current Directory
    rooted, or Relative.)

Arguments:

    DosFileName - Supplies the Dos format file name whose type is to be
        determined.

Return Value:

    RtlPathTypeUnknown - The path type can not be determined

    RtlPathTypeUncAbsolute - The path specifies a Unc absolute path
        in the format \\server-name\sharename\rest-of-path

    RtlPathTypeLocalDevice - The path specifies a local device in the format
        \\.\rest-of-path or \\?\rest-of-path.  This can be used for any device
        where the nt and Win32 names are the same. For example mailslots.

    RtlPathTypeRootLocalDevice - The path specifies the root of the local
        devices in the format \\. or \\?

    RtlPathTypeDriveAbsolute - The path specifies a drive letter absolute
        path in the form drive:\rest-of-path

    RtlPathTypeDriveRelative - The path specifies a drive letter relative
        path in the form drive:rest-of-path

    RtlPathTypeRooted - The path is rooted relative to the current disk
        designator (either Unc disk, or drive). The form is \rest-of-path.

    RtlPathTypeRelative - The path is relative (i.e. not absolute or rooted).

--*/

{
    RTL_PATH_TYPE ReturnValue;
    const PCWSTR DosFileName = String->Buffer;

#define ENOUGH_CHARS(_cch) (String->Length >= ((_cch) * sizeof(WCHAR)))

    if ( ENOUGH_CHARS(1) && IS_PATH_SEPARATOR_U(*DosFileName) ) {
        if ( ENOUGH_CHARS(2) && IS_PATH_SEPARATOR_U(*(DosFileName+1)) ) {
            if ( ENOUGH_CHARS(3) && (DosFileName[2] == '.' ||
                                     DosFileName[2] == '?') ) {

                if ( ENOUGH_CHARS(4) && IS_PATH_SEPARATOR_U(*(DosFileName+3)) ){
                    // "\\.\" or "\\?\"
                    ReturnValue = RtlPathTypeLocalDevice;
                    }
                //
                // Bogosity ahead, the code is confusing length and nuls,
                // because it was copy/pasted from the PCWSTR version.
                //
                else if ( ENOUGH_CHARS(4) && (*(DosFileName+3)) == UNICODE_NULL ){
                    // "\\.\0" or \\?\0"
                    ReturnValue = RtlPathTypeRootLocalDevice;
                    }
                else {
                    // "\\.x" or "\\." or "\\?x" or "\\?"
                    ReturnValue = RtlPathTypeUncAbsolute;
                    }
                }
            else {
                // "\\x"
                ReturnValue = RtlPathTypeUncAbsolute;
                }
            }
        else {
            // "\x"
            ReturnValue = RtlPathTypeRooted;
            }
        }
    //
    // the "*DosFileName" is left over from the PCWSTR version
    // Win32 and DOS don't allow embedded nuls and much code limits
    // drive letters to strictly 7bit a-zA-Z so it's ok.
    //
    else if (ENOUGH_CHARS(2) && *DosFileName && *(DosFileName+1)==L':') {
        if (ENOUGH_CHARS(3) && IS_PATH_SEPARATOR_U(*(DosFileName+2))) {
            // "x:\"
            ReturnValue = RtlPathTypeDriveAbsolute;
            }
        else  {
            // "c:x"
            ReturnValue = RtlPathTypeDriveRelative;
            }
        }
    else {
        // "x", first char is not a slash / second char is not colon
        ReturnValue = RtlPathTypeRelative;
        }
    return ReturnValue;

#undef ENOUGH_CHARS
}

NTSTATUS
NTAPI
ShimNtPathNameToDosPathName(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Path,
    OUT    ULONG*                     Disposition OPTIONAL,
    IN OUT PWSTR*                     FilePart OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SIZE_T NtFilePartOffset = 0;
    SIZE_T DosFilePartOffset = 0;
    BOOLEAN Unc = FALSE;
    const static UNICODE_STRING DosUncPrefix = RTL_CONSTANT_STRING(L"\\\\");
    PCUNICODE_STRING NtPrefix = NULL;
    PCUNICODE_STRING DosPrefix = NULL;
    RTL_STRING_LENGTH_TYPE Cch = 0;

    if (ARGUMENT_PRESENT(Disposition)) {
        *Disposition = 0;
    }

    if (   !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(Flags == 0)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (ARGUMENT_PRESENT(FilePart) && *FilePart != NULL) {
        NtFilePartOffset = *FilePart - Path->String.Buffer;
        if (!RTL_SOFT_VERIFY(NtFilePartOffset < RTL_STRING_GET_LENGTH_CHARS(&Path->String))
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    if (RtlPrefixUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpDosDevicesUncPrefix), &Path->String, TRUE)
        ) {
        NtPrefix = &RtlpDosDevicesUncPrefix;
        DosPrefix = &DosUncPrefix;
        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_UNC;
        }
    }
    else if (RtlPrefixUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpDosDevicesPrefix), &Path->String, TRUE)
        ) {
        NtPrefix = &RtlpDosDevicesPrefix;
        DosPrefix = &RtlpEmptyString;
        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_DRIVE;
        }
    }
    else {
        //
        // It is not recognizably an Nt path produced by RtlDosPathNameToNtPathName_U.
        //
        if (ARGUMENT_PRESENT(Disposition)) {
            RTL_PATH_TYPE PathType = ShimDetermineDosPathNameType_Ustr(&Path->String);
            switch (PathType) {
                case RtlPathTypeUnknown:
                case RtlPathTypeRooted: // NT paths are identified as this
                    *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS;
                    break;

                //
                // "already" dospaths, but not gotten from this function, let's
                // give a less good disposition
                //
                case RtlPathTypeDriveRelative:
                case RtlPathTypeRelative:
                    *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS;
                    break;

                // these are pretty clearly dospaths already
                case RtlPathTypeUncAbsolute:
                case RtlPathTypeDriveAbsolute:
                case RtlPathTypeLocalDevice: // "\\?\" or "\\.\" or "\\?\blah" or "\\.\blah" 
                case RtlPathTypeRootLocalDevice: // "\\?" or "\\."
                    *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_ALREADY_DOS;
                    break;
            }
        }
        goto Exit;
    }

    Cch =
              RTL_STRING_GET_LENGTH_CHARS(&Path->String)
            + RTL_STRING_GET_LENGTH_CHARS(DosPrefix)
            - RTL_STRING_GET_LENGTH_CHARS(NtPrefix);

    Status =
        ShimEnsureUnicodeStringBufferSizeChars(Path, Cch);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // overlapping buffer shuffle...careful.
    //
    RtlMoveMemory(
        Path->String.Buffer + RTL_STRING_GET_LENGTH_CHARS(DosPrefix),
        Path->String.Buffer + RTL_STRING_GET_LENGTH_CHARS(NtPrefix),
        Path->String.Length - NtPrefix->Length
        );
    RtlMoveMemory(
        Path->String.Buffer,
        DosPrefix->Buffer,
        DosPrefix->Length
        );
    Path->String.Length = Cch * sizeof(Path->String.Buffer[0]);
    RTL_NUL_TERMINATE_STRING(&Path->String);

    if (NtFilePartOffset != 0) {
        // review/test..
        *FilePart = Path->String.Buffer + (NtFilePartOffset - RTL_STRING_GET_LENGTH_CHARS(NtPrefix) + RTL_STRING_GET_LENGTH_CHARS(DosPrefix));
    }
    Status = STATUS_SUCCESS;
Exit:
    /* KdPrintEx((
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path, Status)); */
    return Status;
}

NTSTATUS
ShimValidateUnicodeString(
    ULONG Flags,
    const UNICODE_STRING *String
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(Flags == 0);

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (String != NULL) {
        if (((String->Length % 2) != 0) ||
            ((String->MaximumLength % 2) != 0) ||
            (String->Length > String->MaximumLength)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        if (((String->Length != 0) ||
             (String->MaximumLength != 0)) &&
            (String->Buffer == NULL)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

//
// This function was taken from:
// %SDXROOT%\base\ntos\rtl\nls.c
//

NTSTATUS
ShimDuplicateUnicodeString(
    ULONG Flags,
    PCUNICODE_STRING StringIn,
    PUNICODE_STRING StringOut
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT Length = 0;
    USHORT NewMaximumLength = 0;
    PWSTR Buffer = NULL;

    if (((Flags & ~(
            RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
            RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING)) != 0) ||
        (StringOut == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // It doesn't make sense to force allocation of a null string unless you
    // want null termination.
    if ((Flags & RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING) &&
        !(Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = ShimValidateUnicodeString(0, StringIn);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (StringIn != NULL)
        Length = StringIn->Length;

    if ((Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE) &&
        (Length == UNICODE_STRING_MAX_BYTES)) {
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    if (Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE)
        NewMaximumLength = (USHORT) (Length + sizeof(WCHAR));
    else
        NewMaximumLength = Length;

    // If it's a zero length string in, force the allocation length to zero
    // unless the caller said that they want zero length strings allocated.
    if (((Flags & RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING) == 0) &&
        (Length == 0)) {
        NewMaximumLength = 0;
    }

    if (NewMaximumLength != 0) {
        Buffer = (PWSTR)(RtlAllocateStringRoutine)(NewMaximumLength);
        if (Buffer == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        // If there's anything to copy, copy it.  We explicitly test Length because
        // StringIn could be a NULL pointer, so dereferencing it to get the Buffer
        // pointer would access violate.
        if (Length != 0) {
            RtlCopyMemory(
                Buffer,
                StringIn->Buffer,
                Length);
        }

        if (Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE) {
            Buffer[Length / sizeof(WCHAR)] = L'\0';
        }
    }

    StringOut->Buffer = Buffer;
    StringOut->MaximumLength = NewMaximumLength;
    StringOut->Length = Length;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

//
// This function was pulled from:
// %SDXROOT%\base\ntdll\buffer.c
//
NTSTATUS
NTAPI
ShimpEnsureBufferSize(
    IN ULONG           Flags,
    IN OUT PRTL_BUFFER Buffer,
    IN SIZE_T          Size
    )
/*++

Routine Description:

    This function ensures Buffer can hold Size bytes, or returns
    an error. It either bumps Buffer->Size closer to Buffer->StaticSize,
    or heap allocates.

Arguments:

    Buffer - a Buffer object, see also RtlInitBuffer.

    Size - the number of bytes the caller wishes to store in Buffer->Buffer.


Return Value:

     STATUS_SUCCESS
     STATUS_NO_MEMORY

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Temp = NULL;

    if ((Flags & ~(RTL_ENSURE_BUFFER_SIZE_NO_COPY)) != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Buffer == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (Size <= Buffer->Size) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    // Size <= Buffer->StaticSize does not imply static allocation, it
    // could be heap allocation that the client poked smaller.
    if (Buffer->Buffer == Buffer->StaticBuffer && Size <= Buffer->StaticSize) {
        Buffer->Size = Size;
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    //
    // The realloc case was messed up in Whistler, and got removed.
    // Put it back in Blackcomb.
    //
    Temp = (PUCHAR)RtlAllocateStringRoutine(Size);
    if (Temp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    if ((Flags & RTL_ENSURE_BUFFER_SIZE_NO_COPY) == 0) {
        RtlCopyMemory(Temp, Buffer->Buffer, Buffer->Size);
    }

    if (RTLP_BUFFER_IS_HEAP_ALLOCATED(Buffer)) {
        RtlFreeStringRoutine(Buffer->Buffer);
        Buffer->Buffer = NULL;
    }
    ASSERT(Temp != NULL);
    Buffer->Buffer = Temp;
    Buffer->Size = Size;
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

} // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\parsedde.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    ParseDde.cpp

 Abstract:
    Useful routines for parsing DDE commands.

 History:

    08/14/2001  robkenny    Moved code inside the ShimLib namespace.
    

--*/

//
// This code was copied from:
// \\index1\src\shell\shell32\unicpp\dde.cpp
// with minimal processing.
//

#include "Windows.h"
#include "ParseDDE.h"
#include <ShlObj.h>


namespace ShimLib
{
//--------------------------------------------------------------------------
// Returns a pointer to the first non-whitespace character in a string.
LPSTR SkipWhite(LPSTR lpsz)
    {
    /* prevent sign extension in case of DBCS */
    while (*lpsz && (UCHAR)*lpsz <= ' ')
        lpsz++;

    return(lpsz);
    }

LPSTR GetCommandName(LPSTR lpCmd, const char * lpsCommands[], UINT *lpW)
    {
    CHAR chT;
    UINT iCmd = 0;
    LPSTR lpT;

    /* Eat any white space. */
    lpCmd = SkipWhite(lpCmd);
    lpT = lpCmd;

    /* Find the end of the token. */
    while (IsCharAlpha(*lpCmd))
        lpCmd = CharNextA(lpCmd);

    /* Temporarily NULL terminate it. */
    chT = *lpCmd;
    *lpCmd = 0;

    /* Look up the token in a list of commands. */
    *lpW = (UINT)-1;
    while (*lpsCommands)
        {
        const char * knownCommand = *lpsCommands;
        if (!_strcmpi(knownCommand, lpT))
            {
            *lpW = iCmd;
            break;
            } 
        iCmd++;
        ++lpsCommands;
        }

    *lpCmd = chT;

    return(lpCmd);
    }
//--------------------------------------------------------------------------
// Reads a parameter out of a string removing leading and trailing whitespace.
// Terminated by , or ).  ] [ and ( are not allowed.  Exception: quoted
// strings are treated as a whole parameter and may contain []() and ,.
// Places the offset of the first character of the parameter into some place
// and NULL terminates the parameter.
// If fIncludeQuotes is false it is assumed that quoted strings will contain single
// commands (the quotes will be removed and anything following the quotes will
// be ignored until the next comma). If fIncludeQuotes is TRUE, the contents of
// the quoted string will be ignored as before but the quotes won't be
// removed and anything following the quotes will remain.
LPSTR GetOneParameter(LPCSTR lpCmdStart, LPSTR lpCmd,
    UINT *lpW, BOOL fIncludeQuotes)
    {
    LPSTR     lpT;

    switch (*lpCmd)
        {
        case ',':
            *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
            *lpCmd++ = 0;                /* comma: becomes a NULL string */
            break;

        case '"':
            if (fIncludeQuotes)
            {
                //TraceMsg(TF_DDE, "GetOneParameter: Keeping quotes.");

                // quoted string... don't trim off "
                *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
                ++lpCmd;
                while (*lpCmd && *lpCmd != '"')
                    lpCmd = CharNextA(lpCmd);
                if (!*lpCmd)
                    return(NULL);
                lpT = lpCmd;
                ++lpCmd;

                goto skiptocomma;
            }
            else
            {
                // quoted string... trim off "
                ++lpCmd;
                *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
                while (*lpCmd && *lpCmd != '"')
                    lpCmd = CharNextA(lpCmd);
                if (!*lpCmd)
                    return(NULL);
                *lpCmd++ = 0;
                lpCmd = SkipWhite(lpCmd);

                // If there's a comma next then skip over it, else just go on as
                // normal.
                if (*lpCmd == ',')
                    lpCmd++;
            }
            break;

        case ')':
            return(lpCmd);                /* we ought not to hit this */

        case '(':
        case '[':
        case ']':
            return(NULL);                 /* these are illegal */

        default:
            lpT = lpCmd;
            *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
skiptocomma:
            while (*lpCmd && *lpCmd != ',' && *lpCmd != ')')
            {
                /* Check for illegal characters. */
                if (*lpCmd == ']' || *lpCmd == '[' || *lpCmd == '(' )
                    return(NULL);

                /* Remove trailing whitespace */
                /* prevent sign extension */
                if (*lpCmd > ' ')
                    lpT = lpCmd;

                lpCmd = CharNextA(lpCmd);
            }

            /* Eat any trailing comma. */
            if (*lpCmd == ',')
                lpCmd++;

            /* NULL terminator after last nonblank character -- may write over
             * terminating ')' but the caller checks for that because this is
             * a hack.
             */

#ifdef UNICODE
            lpT[1] = 0;
#else
            lpT[IsDBCSLeadByte(*lpT) ? 2 : 1] = 0;
#endif
            break;
        }

    // Return next unused character.
    return(lpCmd);
    }

// Extracts an alphabetic string and looks it up in a list of possible
// commands, returning a pointer to the character after the command and
// sticking the command index somewhere.
UINT* GetDDECommands(LPSTR lpCmd, const char * lpsCommands[], BOOL fLFN)
{
  UINT cParm, cCmd = 0;
  UINT *lpW;
  UINT *lpRet;
  LPCSTR lpCmdStart = lpCmd;
  BOOL fIncludeQuotes = FALSE;

  if (lpCmd == NULL)
      return NULL;

  lpRet = lpW = (UINT*)GlobalAlloc(GPTR, 512L);
  if (!lpRet)
      return 0;

  while (*lpCmd)
    {
      /* Skip leading whitespace. */
      lpCmd = SkipWhite(lpCmd);

      /* Are we at a NULL? */
      if (!*lpCmd)
        {
          /* Did we find any commands yet? */
          if (cCmd)
              goto GDEExit;
          else
              goto GDEErrExit;
        }

      /* Each command should be inside square brackets. */
      if (*lpCmd != '[')
          goto GDEErrExit;
      lpCmd++;

      /* Get the command name. */
      lpCmd = GetCommandName(lpCmd, lpsCommands, lpW);
      if (*lpW == (UINT)-1)
          goto GDEErrExit;

      // We need to leave quotes in for the first param of an AddItem.
      if (fLFN && *lpW == 2)
      {
          //TraceMsg(TF_DDE, "GetDDECommands: Potential LFN AddItem command...");
          fIncludeQuotes = TRUE;
      }

      lpW++;

      /* Start with zero parms. */
      cParm = 0;
      lpCmd = SkipWhite(lpCmd);

      /* Check for opening '(' */
      if (*lpCmd == '(')
        {
          lpCmd++;

          /* Skip white space and then find some parameters (may be none). */
          lpCmd = SkipWhite(lpCmd);

          while (*lpCmd != ')')
            {
              if (!*lpCmd)
                  goto GDEErrExit;

              // Only the first param of the AddItem command needs to
              // handle quotes from LFN guys.
              if (fIncludeQuotes && (cParm != 0))
                  fIncludeQuotes = FALSE;

              /* Get the parameter. */
              lpCmd = GetOneParameter(lpCmdStart, lpCmd, lpW + (++cParm), fIncludeQuotes);
              if (!lpCmd)
                  goto GDEErrExit;

              /* HACK: Did GOP replace a ')' with a NULL? */
              if (!*lpCmd)
                  break;

              /* Find the next one or ')' */
              lpCmd = SkipWhite(lpCmd);
            }

          // Skip closing bracket.
          lpCmd++;

          /* Skip the terminating stuff. */
          lpCmd = SkipWhite(lpCmd);
        }

      /* Set the count of parameters and then skip the parameters. */
      *lpW++ = cParm;
      lpW += cParm;

      /* We found one more command. */
      cCmd++;

      /* Commands must be in square brackets. */
      if (*lpCmd != ']')
          goto GDEErrExit;
      lpCmd++;
    }

GDEExit:
  /* Terminate the command list with -1. */
  *lpW = (UINT)-1;

  return lpRet;

GDEErrExit:
  GlobalFree(lpW);
  return(0);
}

BOOL SHTestTokenMembership (HANDLE hToken, ULONG ulRID)

{
    static  SID_IDENTIFIER_AUTHORITY    sSystemSidAuthority     =   SECURITY_NT_AUTHORITY;

    BOOL    fResult;
    PSID    pSIDLocalGroup;

    fResult = FALSE;
    if (AllocateAndInitializeSid(&sSystemSidAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 ulRID,
                                 0, 0, 0, 0, 0, 0,
                                 &pSIDLocalGroup) != FALSE)
    {
        if (CheckTokenMembership(hToken, pSIDLocalGroup, &fResult) == FALSE)
        {
            //TraceMsg(TF_WARNING, "shell32: SHTestTokenMembership call to advapi32!CheckTokenMembership failed with error %d", GetLastError());
            fResult = FALSE;
        }
        (void*)FreeSid(pSIDLocalGroup);
    }
    return(fResult);
}

BOOL IsUserAnAdmin()
{
    return(SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_ADMINS));
}


// Map the group name to a proper path taking care of the startup group and
// app hacks on the way.
void GetGroupPath(LPCSTR pszName, LPSTR pszPath, DWORD /*dwFlags*/, INT iCommonGroup)
{
    BOOL   bCommonGroup;

    if (IsUserAnAdmin()) {
        if (iCommonGroup == 0) {
            bCommonGroup = FALSE;

        } else if (iCommonGroup == 1) {
            bCommonGroup = TRUE;

        } else {
            //
            // Administrators get common groups created by default
            // when the setup application doesn't specificly state
            // what kind of group to create.  This feature can be
            // turned off in the cabinet state flags.
            //
            //CABINETSTATE cs;
            //ReadCabinetState(&cs, sizeof(cs));
            //if (cs.fAdminsCreateCommonGroups) {
            //    bFindPersonalGroup = TRUE;
            //    bCommonGroup = FALSE;   // This might get turned on later
            //                            // if find is unsuccessful
            //} else {
            //    bCommonGroup = FALSE;
            //}

            bCommonGroup = TRUE;
        }
    } else {
        //
        // Regular users can't create common group items.
        //
        bCommonGroup = FALSE;
    }

    // Build a path to the directory
    if (bCommonGroup) {
        SHGetSpecialFolderPathA(NULL, pszPath, CSIDL_COMMON_PROGRAMS, TRUE);
    } else {
        SHGetSpecialFolderPathA(NULL, pszPath, CSIDL_PROGRAMS, TRUE);
    }
    strcat(pszPath, "\\");
    strcat(pszPath, pszName);
}


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\cstring.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    CString.cpp

 Abstract:
    A CString class, pure UNICODE internally.

   This code was ripped from MFC Strcore.cpp and Strex.cpp

 History:

    05/11/2001   robkenny     Added this header
    05/11/2001   robkenny     Fixed SplitPath.
    05/11/2001   robkenny     Do not Truncate(0) GetShortPathNameW,
                              GetLongPathNameW and GetFullPathNameW if
                              the API does not succeed.
    08/14/2001  robkenny      Moved code inside the ShimLib namespace.
    
--*/



#include "ShimHook.h"
#include "ShimLib.h"
#include "Win9xPath.h"
#include <stdio.h> // for _vsnwprintf
#include <stdlib.h>


namespace ShimLib
{

typedef WCHAR  _TUCHAR;
struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };


#ifdef USE_SEH
const ULONG_PTR  CString::m_CStringExceptionValue = CString::eCStringExceptionValue;

// Exception filter for CString __try/__except blocks
// Return EXCEPTION_EXECUTE_HANDLER if this is a CString exception
// otherwise return EXCEPTION_CONTINUE_SEARCH
int CString::ExceptionFilter(PEXCEPTION_POINTERS pexi)
{
    if (pexi->ExceptionRecord->ExceptionCode            == CString::eCStringNoMemoryException &&
        pexi->ExceptionRecord->NumberParameters         == 1 &&
        pexi->ExceptionRecord->ExceptionInformation[0]  == CString::m_CStringExceptionValue
        )
    {
        // This is a CString exception, handle it
        return EXCEPTION_EXECUTE_HANDLER;
    }

    // Not our error
    return EXCEPTION_CONTINUE_SEARCH;
}
#endif


// The original code was written using a memcpy that correctly handled
// overlapping buffers, despite the documentation.
// Replace memcpy with memmove, which correctly handles overlapping buffers
#define memcpy memmove

const WCHAR * wcsinc(const WCHAR * s1)                                    
{ 
    return (s1) + 1; 
}

LPWSTR wcsinc(LPWSTR s1)                                    
{ 
    return (s1) + 1; 
}

// WCS routines that are only available in MSVCRT

wchar_t * __cdecl _wcsrev (
    wchar_t * string
    )
{
    wchar_t *start = string;
    wchar_t *left = string;
    wchar_t ch;

    while (*string++)         /* find end of string */
        ;
    string -= 2;

    while (left < string)
    {
        ch = *left;
        *left++ = *string;
        *string-- = ch;
    }

    return(start);
}


void __cdecl _wsplitpath (
        register const WCHAR *path,
        WCHAR *drive,
        WCHAR *dir,
        WCHAR *fname,
        WCHAR *ext
        )
{
        register WCHAR *p;
        WCHAR *last_slash = NULL, *dot = NULL;
        unsigned len;

        /* we assume that the path argument has the following form, where any
         * or all of the components may be missing.
         *
         *  <drive><dir><fname><ext>
         *
         * and each of the components has the following expected form(s)
         *
         *  drive:
         *  0 to _MAX_DRIVE-1 characters, the last of which, if any, is a
         *  ':'
         *  dir:
         *  0 to _MAX_DIR-1 characters in the form of an absolute path
         *  (leading '/' or '\') or relative path, the last of which, if
         *  any, must be a '/' or '\'.  E.g -
         *  absolute path:
         *      \top\next\last\     ; or
         *      /top/next/last/
         *  relative path:
         *      top\next\last\  ; or
         *      top/next/last/
         *  Mixed use of '/' and '\' within a path is also tolerated
         *  fname:
         *  0 to _MAX_FNAME-1 characters not including the '.' character
         *  ext:
         *  0 to _MAX_EXT-1 characters where, if any, the first must be a
         *  '.'
         *
         */

        /* extract drive letter and :, if any */

        if ((wcslen(path) >= (_MAX_DRIVE - 2)) && (*(path + _MAX_DRIVE - 2) == L':')) {
            if (drive) {
                wcsncpy(drive, path, _MAX_DRIVE - 1);
                *(drive + _MAX_DRIVE-1) = L'\0';
            }
            path += _MAX_DRIVE - 1;
        }
        else if (drive) {
            *drive = L'\0';
        }

        /* extract path string, if any.  Path now points to the first character
         * of the path, if any, or the filename or extension, if no path was
         * specified.  Scan ahead for the last occurence, if any, of a '/' or
         * '\' path separator character.  If none is found, there is no path.
         * We will also note the last '.' character found, if any, to aid in
         * handling the extension.
         */

        for (last_slash = NULL, p = (WCHAR *)path; *p; p++) {
            if (*p == L'/' || *p == L'\\')
                /* point to one beyond for later copy */
                last_slash = p + 1;
            else if (*p == L'.')
                dot = p;
        }

        if (last_slash) {

            /* found a path - copy up through last_slash or max. characters
             * allowed, whichever is smaller
             */

            if (dir) {
                len = __min((unsigned)(((char *)last_slash - (char *)path) / sizeof(WCHAR)),
                    (_MAX_DIR - 1));
                wcsncpy(dir, path, len);
                *(dir + len) = L'\0';
            }
            path = last_slash;
        }
        else if (dir) {

            /* no path found */

            *dir = L'\0';
        }

        /* extract file name and extension, if any.  Path now points to the
         * first character of the file name, if any, or the extension if no
         * file name was given.  Dot points to the '.' beginning the extension,
         * if any.
         */

        if (dot && (dot >= path)) {
            /* found the marker for an extension - copy the file name up to
             * the '.'.
             */
            if (fname) {
                len = __min((unsigned)(((char *)dot - (char *)path) / sizeof(WCHAR)),
                    (_MAX_FNAME - 1));
                wcsncpy(fname, path, len);
                *(fname + len) = L'\0';
            }
            /* now we can get the extension - remember that p still points
             * to the terminating nul character of path.
             */
            if (ext) {
                len = __min((unsigned)(((char *)p - (char *)dot) / sizeof(WCHAR)),
                    (_MAX_EXT - 1));
                wcsncpy(ext, dot, len);
                *(ext + len) = L'\0';
            }
        }
        else {
            /* found no extension, give empty extension and copy rest of
             * string into fname.
             */
            if (fname) {
                len = __min((unsigned)(((char *)p - (char *)path) / sizeof(WCHAR)),
                    (_MAX_FNAME - 1));
                wcsncpy(fname, path, len);
                *(fname + len) = L'\0';
            }
            if (ext) {
                *ext = L'\0';
            }
        }
}

// conversion helpers
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// AfxIsValidString() returns TRUE if the passed pointer
// references a string of at least the given length in characters.
// A length of -1 (the default parameter) means that the string
// buffer's minimum length isn't known, and the function will
// return TRUE no matter how long the string is. The memory
// used by the string can be read-only.

BOOL AFXAPI AfxIsValidString(LPCWSTR lpsz, int nLength /* = -1 */)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrW(lpsz, nLength) == 0;
}

// AfxIsValidAddress() returns TRUE if the passed parameter points
// to at least nBytes of accessible memory. If bReadWrite is TRUE,
// the memory must be writeable; if bReadWrite is FALSE, the memory
// may be const.

BOOL AFXAPI AfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite /* = TRUE */)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

WCHAR CString::ChNil = L'\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
int                    CString::_afxInitData[] = { -1, 0, 0, 0 };
CStringData<WCHAR> *   CString::_afxDataNil    = (CStringData<WCHAR>*)&_afxInitData;
const WCHAR *          CString::_afxPchNil     = (const WCHAR *)(((BYTE*)&_afxInitData)+sizeof(CStringData<WCHAR>));

// special function to make afxEmptyString work even during initialization
//const CString& AFXAPI AfxGetEmptyString()
//  { return *(CString*)&CString::_afxPchNil; }


//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString(const CString& stringSrc)
{
    ASSERT(stringSrc.GetData()->nRefs != 0, "CString::CString(const CString& stringSrc)");
    if (stringSrc.GetData()->nRefs >= 0)
    {
        ASSERT(stringSrc.GetData() != _afxDataNil, "CString::CString(const CString& stringSrc)");
        // robkenny: increment before copy is safer
        InterlockedIncrement(&stringSrc.GetData()->nRefs);
        m_pchData = stringSrc.m_pchData;
        m_pchDataAnsi = NULL;
    }
    else
    {
        Init();
        *this = stringSrc.m_pchData;
    }
}

inline int Round4(int x)
{
    return (x + 3) & ~3;
}

inline int RoundBin(int x)
{
    return Round4(x * sizeof(WCHAR) + sizeof(CStringData<WCHAR>) );
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
    ASSERT(nLen >= 0, "CString::AllocBuffer");
    ASSERT(nLen <= INT_MAX-1, "CString::AllocBuffer");    // max size (enough room for 1 extra)

    if (nLen == 0)
    {
        Init();
    }
    else
    {
        int allocGranularity = nLen + 1;

        if (nLen < 64)
        {
            allocGranularity = 64;
        }
        else if (nLen < 128)
        {
            allocGranularity = 128;
        }
        else if (nLen < MAX_PATH)
        {
            allocGranularity = MAX_PATH;
        }
        else if (nLen < 512)
        {
            allocGranularity = 512;
        }

        // Number of bytes necessary for the CStringData thingy.
        DWORD dwBufferSize = RoundBin(allocGranularity);

        CStringData<WCHAR>* pData = (CStringData<WCHAR>*) new BYTE[dwBufferSize];
        if (pData)
        {
            pData->nAllocLength = allocGranularity;
            pData->nRefs = 1;
            pData->data()[nLen] = '\0';
            pData->nDataLength = nLen;
            m_pchData = pData->data();
        }
        else
        {
            CSTRING_THROW_EXCEPTION
        }
    }
}

void CString::Release()
{
    if (GetData() != _afxDataNil)
    {
        ASSERT(GetData()->nRefs != 0, "CString::Release()");
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            FreeData(GetData());
        Init();
    }
}

void CString::Release(CStringData<WCHAR>* pData)
{
    if (pData != _afxDataNil)
    {
        ASSERT(pData->nRefs != 0, "CString::Release(CStringData<WCHAR>* pData)");
        if (InterlockedDecrement(&pData->nRefs) <= 0)
            FreeData(pData);
    }
}

void CString::Empty()
{
    if (GetData()->nDataLength == 0)
        return;
    if (GetData()->nRefs >= 0)
        Release();
    else
        *this = &ChNil;
    ASSERT(GetData()->nDataLength == 0, "CString::Empty()");
    ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0, "CString::Empty()");
}

void CString::CopyBeforeWrite()
{
    if (GetData()->nRefs > 1)
    {
        CStringData<WCHAR>* pData = GetData();
        Release();
        AllocBuffer(pData->nDataLength);
        memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(WCHAR));
    }
    ASSERT(GetData()->nRefs <= 1, "CString::CopyBeforeWrite()");
}

void CString::AllocBeforeWrite(int nLen)
{
    if (GetData()->nRefs > 1 || nLen >= GetData()->nAllocLength)
    {
        Release();
        AllocBuffer(nLen);
    }
    ASSERT(GetData()->nRefs <= 1, "CString::AllocBeforeWrite(int nLen)");
}

CString::~CString()
//  free any attached data
{
    if (GetData() != _afxDataNil)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            FreeData(GetData());
    }
    if (m_pchDataAnsi)
    {
        free(m_pchDataAnsi);
    }
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // Copy nCopyIndex to nCopyIndex+nCopyLen into dest
    // Make sure dest has nExtraLen chars left over in the dest string
    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        WCHAR * lpszDestBuffer = dest.GetBuffer(nNewLen);
        memcpy(lpszDestBuffer, m_pchData+nCopyIndex, nCopyLen*sizeof(WCHAR));
        lpszDestBuffer[nCopyLen] = '\0';
        dest.ReleaseBuffer(nCopyLen);
    }
}

///////////////////////////////////////////////////////////////////////////////
// CString conversion helpers (these use the current system locale)

int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
    if (count == 0 && wcstr != NULL)
        return 0;

    int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
        wcstr, count);
    ASSERT(wcstr == NULL || result <= (int)count, "CString::_mbstowcsz");
    if (result > 0)
        wcstr[result-1] = 0;
    return result;
}


//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(LPCWSTR lpsz)
{
    Init();
    {
        int nLen = SafeStrlen(lpsz);
        if (nLen != 0)
        {
            AllocBuffer(nLen);
            memcpy(m_pchData, lpsz, nLen*sizeof(WCHAR));
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors
CString::CString(LPCSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? strlenChars(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen);
        _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
    }
}
CString::CString(LPCSTR lpsz, int nCharacters)
{
    Init();
    if (nCharacters != 0)
    {
        AllocBuffer(nCharacters);
        _mbstowcsz(m_pchData, lpsz, nCharacters);
        ReleaseBuffer(nCharacters);
    }
}

//////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CString& string)
{
    dc << string.m_pchData;
    return dc;
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, LPCWSTR lpszSrcData)
{
    AllocBeforeWrite(nSrcLen);
    memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(WCHAR));
    GetData()->nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator=(const CString& stringSrc)
{
    if (m_pchData != stringSrc.m_pchData)
    {
        if ((GetData()->nRefs < 0 && GetData() != _afxDataNil) ||
            stringSrc.GetData()->nRefs < 0)
        {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else
        {
            // can just copy references around
            Release();
            ASSERT(stringSrc.GetData() != _afxDataNil, "CString::operator=(const CString& stringSrc)");
            // robkenny: increment before copy is safer
            InterlockedIncrement(&stringSrc.GetData()->nRefs);
            m_pchData = stringSrc.m_pchData;
            m_pchDataAnsi = NULL;
        }
    }
    return *this;
}

const CString& CString::operator=(LPCWSTR lpsz)
{
    ASSERT(lpsz == NULL || AfxIsValidString(lpsz), "CString::operator=(LPCWSTR lpsz)");
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

const CString& CString::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? strlenChars(lpsz) : 0;
    AllocBeforeWrite(nSrcLen);
    _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
    ReleaseBuffer();
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = WCHAR, LPCWSTR
//          CString + ?
//          ? + CString

void CString::ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data,
    int nSrc2Len, LPCWSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

    int nNewLen = nSrc1Len + nSrc2Len;
    if (nNewLen != 0)
    {
        AllocBuffer(nNewLen);
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(WCHAR));
        memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(WCHAR));
    }
}

CString AFXAPI operator+(const CString& string1, const CString& string2)
{
    CString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
        string2.GetData()->nDataLength, string2.m_pchData);
    return s;
}

CString AFXAPI operator+(const CString& string, LPCWSTR lpsz)
{
    ASSERT(lpsz == NULL || AfxIsValidString(lpsz), "CString::operator+(const CString& string, LPCWSTR lpsz)");
    CString s;
    s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        CString::SafeStrlen(lpsz), lpsz);
    return s;
}

CString AFXAPI operator+(LPCWSTR lpsz, const CString& string)
{
    ASSERT(lpsz == NULL || AfxIsValidString(lpsz), "CString::operator+(LPCWSTR lpsz, const CString& string)");
    CString s;
    s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
        string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData)
{
    //  -- the main routine for += operators

    // concatenating an empty string is a no-op!
    if (nSrcLen == 0)
        return;

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen + 1 > GetData()->nAllocLength)
    {
        // we have to grow the buffer, use the ConcatCopy routine
        CStringData<WCHAR>* pOldData = GetData();
        ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
        ASSERT(pOldData != NULL, "CString::ConcatInPlace");
        CString::Release(pOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(WCHAR));
        GetData()->nDataLength += nSrcLen;
        ASSERT(GetData()->nDataLength <= GetData()->nAllocLength, "CString::ConcatInPlace");
        m_pchData[GetData()->nDataLength] = '\0';
    }
}

const CString& CString::operator+=(LPCWSTR lpsz)
{
    ASSERT(lpsz == NULL || AfxIsValidString(lpsz), "CString::operator+=(LPCWSTR lpsz)");
    ConcatInPlace(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CString& CString::operator+=(WCHAR ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CString& CString::operator+=(const CString& string)
{
    ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPWSTR CString::GetBuffer(int nMinBufLength)
{
    ASSERT(nMinBufLength >= 0, "CString::GetBuffer");

    if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
    {
#ifdef _DEBUG
        // give a warning in case locked string becomes unlocked
        if (GetData() != _afxDataNil && GetData()->nRefs < 0)
            TRACE0("Warning: GetBuffer on locked CString creates unlocked CString!\n");
#endif
        // we have to grow the buffer
        CStringData<WCHAR>* pOldData = GetData();
        int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
        if (nMinBufLength < nOldLen)
            nMinBufLength = nOldLen;
        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(WCHAR));
        GetData()->nDataLength = nOldLen;
        CString::Release(pOldData);
    }
    ASSERT(GetData()->nRefs <= 1, "CString::GetBuffer");

    // return a pointer to the character storage for this string
    ASSERT(m_pchData != NULL, "CString::GetBuffer");
    return m_pchData;
}

void CString::ReleaseBuffer(int nNewLength)
{
    CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
        nNewLength = wcslen(m_pchData); // zero terminated

    ASSERT(nNewLength <= GetData()->nAllocLength, "CString::ReleaseBuffer");
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
}

LPWSTR CString::GetBufferSetLength(int nNewLength)
{
    ASSERT(nNewLength >= 0, "CString::GetBufferSetLength");

    GetBuffer(nNewLength);
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
    return m_pchData;
}

void CString::FreeExtra()
{
    ASSERT(GetData()->nDataLength <= GetData()->nAllocLength, "CString::FreeExtra");
    if (GetData()->nDataLength != GetData()->nAllocLength)
    {
        CStringData<WCHAR>* pOldData = GetData();
        AllocBuffer(GetData()->nDataLength);
        memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(WCHAR));
        ASSERT(m_pchData[GetData()->nDataLength] == '\0', "CString::FreeExtra");
        CString::Release(pOldData);
    }
    ASSERT(GetData() != NULL, "CString::FreeExtra");
}

LPWSTR CString::LockBuffer()
{
    LPWSTR lpsz = GetBuffer(0);
    GetData()->nRefs = -1;
    return lpsz;
}

void CString::UnlockBuffer()
{
    ASSERT(GetData()->nRefs == -1, "CString::UnlockBuffer");
    if (GetData() != _afxDataNil)
        GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CString::Find(WCHAR ch) const
{
    return Find(ch, 0);
}

int CString::Find(WCHAR ch, int nStart) const
{
    int nLength = GetData()->nDataLength;
    if (nStart >= nLength)
        return -1;

    // find first single character
    LPWSTR lpsz = wcschr(m_pchData + nStart, (_TUCHAR)ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CString::FindOneOf(LPCWSTR lpszCharSet) const
{
    return FindOneOf(lpszCharSet, 0);
}

int CString::FindOneOf(LPCWSTR lpszCharSet, int nCount) const
{
    ASSERT(AfxIsValidString(lpszCharSet), "CString::FindOneOf");
    LPCWSTR lpsz = wcspbrk(m_pchData + nCount, lpszCharSet);
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CString::FindOneNotOf(const WCHAR * lpszCharSet, int nCount) const
{
    ASSERT(AfxIsValidString(lpszCharSet), "CString::FindOneNotOf");
    while (wcschr(lpszCharSet, m_pchData[nCount]))
    {
        nCount += 1;
    }
    if (nCount >= GetLength())
    {
        // entire string contains lpszCharSet
        return -1;
    }
    return nCount;

}

void CString::MakeUpper()
{
    CopyBeforeWrite();
    _wcsupr(m_pchData);
}

void CString::MakeLower()
{
    CopyBeforeWrite();
    _wcslwr(m_pchData);
}

void CString::MakeReverse()
{
    CopyBeforeWrite();
    _wcsrev(m_pchData);
}

void CString::SetAt(int nIndex, WCHAR ch)
{
    ASSERT(nIndex >= 0, "CString::SetAt");
    ASSERT(nIndex < GetData()->nDataLength, "CString::SetAt");

    CopyBeforeWrite();
    m_pchData[nIndex] = ch;
}

///////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(WCHAR ch, int nLength)
{
    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
        for (int i = 0; i < nLength; i++)
            m_pchData[i] = ch;
    }
}

CString::CString(int nLength)
{
    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
        GetData()->nDataLength = 0;
    }
}

CString::CString(LPCWSTR lpch, int nLength)
{
    Init();
    if (nLength != 0)
    {
        ASSERT(AfxIsValidAddress(lpch, nLength, FALSE), "CString::CString(LPCWSTR lpch, int nLength)");
        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(WCHAR));
    }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CString& CString::operator=(WCHAR ch)
{
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CString AFXAPI operator+(const CString& string1, WCHAR ch)
{
    CString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
    return s;
}

CString AFXAPI operator+(WCHAR ch, const CString& string)
{
    CString s;
    s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Advanced manipulation

int CString::Delete(int nIndex, int nCount /* = 1 */)
{
    if (nIndex < 0)
        nIndex = 0;
    int nNewLength = GetData()->nDataLength;
    if (nCount > 0 && nIndex < nNewLength)
    {
        CopyBeforeWrite();
        int nBytesToCopy = nNewLength - (nIndex + nCount) + 1;

        memcpy(m_pchData + nIndex,
            m_pchData + nIndex + nCount, nBytesToCopy * sizeof(WCHAR));
        GetData()->nDataLength = nNewLength - nCount;
    }

    return nNewLength;
}

int CString::Insert(int nIndex, WCHAR ch)
{
    CopyBeforeWrite();

    if (nIndex < 0)
        nIndex = 0;

    int nNewLength = GetData()->nDataLength;
    if (nIndex > nNewLength)
        nIndex = nNewLength;
    nNewLength++;

    if (GetData()->nAllocLength < nNewLength)
    {
        CStringData<WCHAR>* pOldData = GetData();
        LPWSTR pstr = m_pchData;
        AllocBuffer(nNewLength);
        memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(WCHAR));
        CString::Release(pOldData);
    }

    // move existing bytes down
    memcpy(m_pchData + nIndex + 1,
        m_pchData + nIndex, (nNewLength-nIndex)*sizeof(WCHAR));
    m_pchData[nIndex] = ch;
    GetData()->nDataLength = nNewLength;

    return nNewLength;
}

int CString::Insert(int nIndex, LPCWSTR pstr)
{
    if (nIndex < 0)
        nIndex = 0;

    int nInsertLength = SafeStrlen(pstr);
    int nNewLength = GetData()->nDataLength;
    if (nInsertLength > 0)
    {
        CopyBeforeWrite();
        if (nIndex > nNewLength)
            nIndex = nNewLength;
        nNewLength += nInsertLength;

        if (GetData()->nAllocLength < nNewLength)
        {
            CStringData<WCHAR>* pOldData = GetData();
            LPWSTR lpwsz = m_pchData;
            AllocBuffer(nNewLength);
            memcpy(m_pchData, lpwsz, (pOldData->nDataLength+1)*sizeof(WCHAR));
            CString::Release(pOldData);
        }

        // move existing bytes down
        memcpy(m_pchData + nIndex + nInsertLength,
            m_pchData + nIndex,
            (nNewLength-nIndex-nInsertLength+1)*sizeof(WCHAR));
        memcpy(m_pchData + nIndex,
            pstr, nInsertLength*sizeof(WCHAR));
        GetData()->nDataLength = nNewLength;
    }

    return nNewLength;
}

int CString::Replace(WCHAR chOld, WCHAR chNew)
{
    int nCount = 0;

    // short-circuit the nop case
    if (chOld != chNew)
    {
        // otherwise modify each character that matches in the string
        CopyBeforeWrite();
        LPWSTR psz = m_pchData;
        LPWSTR pszEnd = psz + GetData()->nDataLength;
        while (psz < pszEnd)
        {
            // replace instances of the specified character only
            if (*psz == chOld)
            {
                *psz = chNew;
                nCount++;
            }
            psz = wcsinc(psz);
        }
    }
    return nCount;
}


int CString::Replace(LPCWSTR lpszOld, LPCWSTR lpszNew)
{
    return ReplaceRoutine(lpszOld, lpszNew, wcsstr);
}

int CString::ReplaceI(LPCWSTR lpszOld, LPCWSTR lpszNew)
{
    return ReplaceRoutine(lpszOld, lpszNew, wcsistr);
}

int CString::ReplaceRoutine(LPCWSTR lpszOld, LPCWSTR lpszNew, _pfn_wcsstr tcsstr)
{
    // can't have empty or NULL lpszOld

    int nSourceLen = SafeStrlen(lpszOld);
    if (nSourceLen == 0)
        return 0;
    int nReplacementLen = SafeStrlen(lpszNew);

    // loop once to figure out the size of the result string
    int nCount = 0;
    LPWSTR lpszStart = m_pchData;
    LPWSTR lpszEnd = m_pchData + GetData()->nDataLength;
    LPWSTR lpszTarget;
    while (lpszStart < lpszEnd)
    {
        while ((lpszTarget = tcsstr(lpszStart, lpszOld)) != NULL)
        {
            nCount++;
            lpszStart = lpszTarget + nSourceLen;
        }
        lpszStart += wcslen(lpszStart) + 1;
    }

    // if any changes were made, make them
    if (nCount > 0)
    {
        CopyBeforeWrite();

        // if the buffer is too small, just
        //   allocate a new buffer (slow but sure)
        int nOldLength = GetData()->nDataLength;
        int nNewLength =  nOldLength + (nReplacementLen-nSourceLen)*nCount;
        
        if (GetData()->nAllocLength < nNewLength + 1 || GetData()->nRefs > 1)
        {
            CStringData<WCHAR>* pOldData = GetData();
            LPWSTR pstr = m_pchData;
            AllocBuffer(nNewLength);
            memcpy(m_pchData, pstr, pOldData->nDataLength*sizeof(WCHAR));
            CString::Release(pOldData);
        }
        // else, we just do it in-place
        lpszStart = m_pchData;
        lpszEnd = m_pchData + GetData()->nDataLength;

        // loop again to actually do the work
        while (lpszStart < lpszEnd)
        {
            while ( (lpszTarget = wcsstr(lpszStart, lpszOld)) != NULL)
            {
                int nBalance = nOldLength - ((int)(lpszTarget - m_pchData) + nSourceLen);
                memmove(lpszTarget + nReplacementLen, lpszTarget + nSourceLen,
                    nBalance * sizeof(WCHAR));
                memcpy(lpszTarget, lpszNew, nReplacementLen*sizeof(WCHAR));
                lpszStart = lpszTarget + nReplacementLen;
                lpszStart[nBalance] = '\0';
                nOldLength += (nReplacementLen - nSourceLen);
            }
            lpszStart += wcslen(lpszStart) + 1;
        }
        ASSERT(m_pchData[nNewLength] == '\0', "CString::ReplaceRoutine");
        GetData()->nDataLength = nNewLength;
    }

    return nCount;
}

int CString::Remove(WCHAR chRemove)
{
    CopyBeforeWrite();

    LPWSTR pstrSource = m_pchData;
    LPWSTR pstrDest = m_pchData;
    LPWSTR pstrEnd = m_pchData + GetData()->nDataLength;

    while (pstrSource < pstrEnd)
    {
        if (*pstrSource != chRemove)
        {
            *pstrDest = *pstrSource;
            pstrDest = wcsinc(pstrDest);
        }
        pstrSource = wcsinc(pstrSource);
    }
    *pstrDest = '\0';
    int nCount = (int)(pstrSource - pstrDest);
    GetData()->nDataLength -= nCount;

    return nCount;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CString CString::Mid(int nFirst) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
    CString dest;
    Mid(nFirst, nCount, dest);
    return dest;
}

CString CString::Right(int nCount) const
{
    CString dest;
    Right(nCount, dest);
    return dest;
}

CString CString::Left(int nCount) const
{
    CString dest;
    Left(nCount, dest);
    return dest;
}

// strspn equivalent
CString CString::SpanIncluding(LPCWSTR lpszCharSet) const
{
    ASSERT(AfxIsValidString(lpszCharSet), "CString::SpanIncluding");
    return Left(wcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CString CString::SpanExcluding(LPCWSTR lpszCharSet) const
{
    ASSERT(AfxIsValidString(lpszCharSet), "CString::SpanIncluding");
    return Left(wcscspn(m_pchData, lpszCharSet));
}

void CString::Mid(int nFirst, CString & csMid) const
{
    Mid(nFirst, GetData()->nDataLength - nFirst, csMid);
}

void CString::Mid(int nFirst, int nCount, CString & csMid) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
        nFirst = 0;
    if (nCount < 0)
        nCount = 0;

    if (nFirst + nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength - nFirst;
    if (nFirst > GetData()->nDataLength)
        nCount = 0;

    ASSERT(nFirst >= 0, "CString::Mid(int nFirst, int nCount)");
    ASSERT(nFirst + nCount <= GetData()->nDataLength, "CString::Mid(int nFirst, int nCount)");

    // optimize case of returning entire string
    if (nFirst == 0 && nFirst + nCount == GetData()->nDataLength)
    {
        csMid = *this;
        return;
    }

    AllocCopy(csMid, nCount, nFirst, 0);
}

void CString::Right(int nCount, CString & csRight) const
{
    if (nCount < 0)
        nCount = 0;
    if (nCount >= GetData()->nDataLength)
        return;

    AllocCopy(csRight, nCount, GetData()->nDataLength-nCount, 0);
}

void CString::Left(int nCount, CString & csLeft) const
{
    if (nCount < 0)
        nCount = 0;
    if (nCount >= GetData()->nDataLength)
        return;

    AllocCopy(csLeft, nCount, 0, 0);
}

void CString::SpanIncluding(const WCHAR * lpszCharSet, CString & csSpanInc) const
{
    ASSERT(AfxIsValidString(lpszCharSet), "CString::SpanIncluding");
    return Left(wcsspn(m_pchData, lpszCharSet), csSpanInc);
}

void CString::SpanExcluding(const WCHAR * lpszCharSet, CString & csSpanExc) const
{
    ASSERT(AfxIsValidString(lpszCharSet), "CString::SpanIncluding");
    return Left(wcscspn(m_pchData, lpszCharSet), csSpanExc);
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CString::ReverseFind(WCHAR ch) const
{
    // find last single character
    LPCWSTR lpsz = wcsrchr(m_pchData, (_TUCHAR) ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CString::Find(LPCWSTR lpszSub) const
{
    return Find(lpszSub, 0);
}

int CString::Find(LPCWSTR lpszSub, int nStart) const
{
    ASSERT(AfxIsValidString(lpszSub), "CString::Find");

    int nLength = GetData()->nDataLength;
    if (nStart > nLength)
        return -1;

    // find first matching substring
    LPWSTR lpsz = wcsstr(m_pchData + nStart, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}


/////////////////////////////////////////////////////////////////////////////
// CString formatting

#define TCHAR_ARG   WCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    WCHAR

#ifdef _X86_
    #define DOUBLE_ARG  _AFX_DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000
#define FORCE_INT64     0x40000

void CString::FormatV(LPCWSTR lpszFormat, va_list argList)
{
    ASSERT(AfxIsValidString(lpszFormat), "CString::FormatV");

    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCWSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = wcsinc(lpsz))
    {
        // handle '%' character, but watch out for '%%'
        if (*lpsz != '%' || *(lpsz = wcsinc(lpsz)) == '%')
        {
            nMaxLen += 1;
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != '\0'; lpsz = wcsinc(lpsz))
        {
            // check for valid flags
            if (*lpsz == '#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == '*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                *lpsz == ' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0)
        {
            // width indicated by
            nWidth = _wtoi(lpsz);
            for (; *lpsz != '\0' && iswdigit(*lpsz); lpsz = wcsinc(lpsz))
                ;
        }
        ASSERT(nWidth >= 0, "CString::FormatV");

        int nPrecision = 0;
        if (*lpsz == '.')
        {
            // skip past '.' separator (width.precision)
            lpsz = wcsinc(lpsz);

            // get precision and skip it
            if (*lpsz == '*')
            {
                nPrecision = va_arg(argList, int);
                lpsz = wcsinc(lpsz);
            }
            else
            {
                nPrecision = _wtoi(lpsz);
                for (; *lpsz != '\0' && iswdigit(*lpsz); lpsz = wcsinc(lpsz))
                    ;
            }
            ASSERT(nPrecision >= 0, "CString::FormatV");
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        if (wcsncmp(lpsz, L"I64", 3) == 0)
        {
            lpsz += 3;
            nModifier = FORCE_INT64;
#if !defined(_X86_) && !defined(_ALPHA_)
            // __int64 is only available on X86 and ALPHA platforms
            ASSERT(FALSE, "CString::FormatV");
#endif
        }
        else
        {
            switch (*lpsz)
            {
            // modifiers that affect size
            case 'h':
                nModifier = FORCE_ANSI;
                lpsz = wcsinc(lpsz);
                break;
            case 'l':
                nModifier = FORCE_UNICODE;
                lpsz = wcsinc(lpsz);
                break;

            // modifiers that do not affect size
            case 'F':
            case 'N':
            case 'L':
                lpsz = wcsinc(lpsz);
                break;
            }
        }

        // now should be on specifier
        switch (*lpsz | nModifier)
        {
        // single characters
        case 'c':
        case 'C':
            nItemLen = 2;
            va_arg(argList, TCHAR_ARG);
            break;
        case 'c'|FORCE_ANSI:
        case 'C'|FORCE_ANSI:
            nItemLen = 2;
            va_arg(argList, CHAR_ARG);
            break;
        case 'c'|FORCE_UNICODE:
        case 'C'|FORCE_UNICODE:
            nItemLen = 2;
            va_arg(argList, WCHAR_ARG);
            break;

        // strings
        case 's':
            {
                LPCWSTR pstrNextArg = va_arg(argList, LPCWSTR);
                if (pstrNextArg == NULL)
                   nItemLen = 6;  // "(null)"
                else
                {
                   nItemLen = wcslen(pstrNextArg);
                   nItemLen = max(1, nItemLen);
                }
            }
            break;

        case 'S':
            {
#ifndef _UNICODE
                LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
                if (pstrNextArg == NULL)
                   nItemLen = 6;  // "(null)"
                else
                {
                   nItemLen = wcslen(pstrNextArg);
                   nItemLen = max(1, nItemLen);
                }
#else
                LPCWSTR pstrNextArg = va_arg(argList, LPCWSTR);
                if (pstrNextArg == NULL)
                   nItemLen = 6; // "(null)"
                else
                {
                   nItemLen = wcslenChars(pstrNextArg);
                   nItemLen = max(1, nItemLen);
                }
#endif
            }
            break;

        case 's'|FORCE_ANSI:
        case 'S'|FORCE_ANSI:
            {
                LPCWSTR pstrNextArg = va_arg(argList, LPCWSTR);
                if (pstrNextArg == NULL)
                   nItemLen = 6; // "(null)"
                else
                {
                   nItemLen = wcslen(pstrNextArg);
                   nItemLen = max(1, nItemLen);
                }
            }
            break;

        case 's'|FORCE_UNICODE:
        case 'S'|FORCE_UNICODE:
            {
                LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
                if (pstrNextArg == NULL)
                   nItemLen = 6; // "(null)"
                else
                {
                   nItemLen = wcslen(pstrNextArg);
                   nItemLen = max(1, nItemLen);
                }
            }
            break;
        }

        // adjust nItemLen for strings
        if (nItemLen != 0)
        {
            if (nPrecision != 0)
                nItemLen = min(nItemLen, nPrecision);
            nItemLen = max(nItemLen, nWidth);
        }
        else
        {
            switch (*lpsz)
            {
            // integers
            case 'd':
            case 'i':
            case 'u':
            case 'x':
            case 'X':
            case 'o':
                if (nModifier & FORCE_INT64)
                    va_arg(argList, __int64);
                else
                    va_arg(argList, int);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'e':
            case 'g':
            case 'G':
                va_arg(argList, DOUBLE_ARG);
                nItemLen = 128;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'f':
                va_arg(argList, DOUBLE_ARG);
                nItemLen = 128; // width isn't truncated
                // 312 == strlen("-1+(309 zeroes).")
                // 309 zeroes == max precision of a double
                nItemLen = max(nItemLen, 312+nPrecision);
                break;

            case 'p':
                va_arg(argList, void*);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            // no output
            case 'n':
                va_arg(argList, int*);
                break;

            default:
                ASSERT(FALSE, "CString::FormatV");  // unknown formatting option
            }
        }

        // adjust nMaxLen for output nItemLen
        nMaxLen += nItemLen;
    }

    GetBuffer(nMaxLen);
    int nChars = _vsnwprintf(m_pchData, nMaxLen, lpszFormat, argListSave);
    ASSERT(nChars <= GetAllocLength(), "CString::FormatV");
    ReleaseBuffer();

    va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CString::Format(LPCWSTR lpszFormat, ...)
{
    ASSERT(AfxIsValidString(lpszFormat), "CString::Format");

    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}

// formatting (using FormatMessage style formatting)
void AFX_CDECL CString::FormatMessage(LPCWSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPWSTR lpszTemp;

    if (::FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPWSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
        CSTRING_THROW_EXCEPTION
    }
    else
    {
        // assign lpszTemp into the resulting string and free the temporary
        *this = lpszTemp;
        LocalFree(lpszTemp);
        va_end(argList);
    }
}

void CString::TrimRight(LPCWSTR lpszTargetList)
{
    // find beginning of trailing matches
    // by starting at beginning (DBCS aware)

    CopyBeforeWrite();
    LPWSTR lpsz = m_pchData;
    LPWSTR lpszLast = NULL;

    while (*lpsz != '\0')
    {
        if (wcschr(lpszTargetList, *lpsz) != NULL)
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = wcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at left-most matching character
        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CString::TrimRight(WCHAR chTarget)
{
    // find beginning of trailing matches
    // by starting at beginning (DBCS aware)

    CopyBeforeWrite();
    LPWSTR lpsz = m_pchData;
    LPWSTR lpszLast = NULL;

    while (*lpsz != '\0')
    {
        if (*lpsz == chTarget)
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = wcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at left-most matching character
        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CString::TrimRight()
{
    // find beginning of trailing spaces by starting at beginning (DBCS aware)

    CopyBeforeWrite();
    LPWSTR lpsz = m_pchData;
    LPWSTR lpszLast = NULL;

    while (*lpsz != '\0')
    {
        if (iswspace(*lpsz))
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = wcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start
        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CString::TrimLeft(LPCWSTR lpszTargets)
{
    // if we're not trimming anything, we're not doing any work
    if (SafeStrlen(lpszTargets) == 0)
        return;

    CopyBeforeWrite();
    LPCWSTR lpsz = m_pchData;

    while (*lpsz != '\0')
    {
        if (wcschr(lpszTargets, *lpsz) == NULL)
            break;
        lpsz = wcsinc(lpsz);
    }

    if (lpsz != m_pchData)
    {
        // fix up data and length
        int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
        memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(WCHAR));
        GetData()->nDataLength = nDataLength;
    }
}

void CString::TrimLeft(WCHAR chTarget)
{
    // find first non-matching character

    CopyBeforeWrite();
    LPCWSTR lpsz = m_pchData;

    while (chTarget == *lpsz)
        lpsz = wcsinc(lpsz);

    if (lpsz != m_pchData)
    {
        // fix up data and length
        int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
        memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(WCHAR));
        GetData()->nDataLength = nDataLength;
    }
}

void CString::TrimLeft()
{
    // find first non-space character

    CopyBeforeWrite();
    LPCWSTR lpsz = m_pchData;

    while (iswspace(*lpsz))
        lpsz = wcsinc(lpsz);

    if (lpsz != m_pchData)
    {
        // fix up data and length
        int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
        memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(WCHAR));
        GetData()->nDataLength = nDataLength;
    }
}

void CString::SplitPath(
    CString * csDrive,
    CString * csDir,
    CString * csName,
    CString * csExt) const
{
    WCHAR * drive = NULL;
    WCHAR * dir   = NULL;
    WCHAR * name  = NULL;
    WCHAR * ext   = NULL;

    if (csDrive)
    {
        drive = csDrive->GetBuffer(_MAX_DRIVE);
    } 
    if (csDir)
    {
        dir = csDir->GetBuffer(_MAX_DIR);
    } 
    if (csName)
    {
        name = csName->GetBuffer(_MAX_FNAME);
    } 
    if (csExt)
    {
        ext = csExt->GetBuffer(_MAX_EXT);
    } 
    _wsplitpath(Get(), drive, dir, name, ext);

    if (csDrive)
    {
        csDrive->ReleaseBuffer(-1);
    } 
    if (csDir)
    {
        csDir->ReleaseBuffer(-1);
    } 
    if (csName)
    {
        csName->ReleaseBuffer(-1);
    } 
    if (csExt)
    {
        csExt->ReleaseBuffer(-1);
    } 
}

void CString::MakePath(
    const CString * csDrive,
    const CString * csDir,
    const CString * csName,
    const CString * csExt)
{
    Truncate(0);

    if (csDrive && !csDrive->IsEmpty())
    {
        ConcatInPlace(SafeStrlen(csDrive->Get()), csDrive->Get());
    }
    if (csDir && !csDir->IsEmpty())
    {
        ConcatInPlace(SafeStrlen(csDir->Get()), csDir->Get());
    }
    if (csName && !csName->IsEmpty())
    {
        // Make sure there is a \ between the two
        if (!IsEmpty() && !IsPathSep(GetLength()) && !csName->IsPathSep(0) )
        {
            ConcatInPlace(1, L"\\");
        }
        ConcatInPlace(SafeStrlen(csName->Get()), csName->Get());
    }
    if (csExt && !csExt->IsEmpty())
    {
        // Make sure the extension has a dot
        if (csExt->GetAt(0) != L'.')
        {
            ConcatInPlace(1, L".");
        }
        ConcatInPlace(SafeStrlen(csExt->Get()), csExt->Get());
    }
}

void CString::AppendPath(const WCHAR * lpszPath)
{
    int nLen = GetLength();
    BOOL bThisHasSep = (nLen > 0) ? IsPathSep(nLen - 1) : FALSE;
    BOOL bThatHasSep = ShimLib::IsPathSep(*lpszPath);
    
    if (lpszPath == NULL || *lpszPath == 0)
    {
        return;
    }
    else if (nLen == 0)
    {
        // No path seperator is necessary
    }
    else if ((nLen == 2) && (GetAt(1) == L':') && !bThatHasSep )
    {
        // We must place a path seperator between the two
        ConcatInPlace(1, L"\\");
    }
    else if (!bThisHasSep && !bThatHasSep )
    {
        // We must place a path seperator between the two
        ConcatInPlace(1, L"\\");
    }
    else if (bThisHasSep && bThatHasSep )
    {
        // Both have seperators, remove one
        do
        {
            lpszPath += 1;
        }
        while (ShimLib::IsPathSep(*lpszPath));
    }
    ConcatInPlace(SafeStrlen(lpszPath), lpszPath);
}

// Find the trailing path component
// Return index of the last path seperator or -1 if none found
int CString::FindLastPathComponent() const
{
    for (int nLen = GetLength() - 1; nLen >= 0; --nLen)
    {
        if (IsPathSep(nLen))
        {
            return nLen;
        }
    }

    return -1;
}

// Remove the trailing path component from the string
void CString::StripPath()
{
    int nLastPathComponent = FindLastPathComponent();
    if (nLastPathComponent != -1)
    {
        Truncate(nLastPathComponent);
    }
    else
    {
        Truncate(0);
    }
}

char * CString::GetAnsi() const
{
    // Since we don't know if the original (WCHAR) data has changed
    // we need to update the ansi string each time.
    if (m_pchDataAnsi)
    {
        free(m_pchDataAnsi);
        m_pchDataAnsi = NULL;
    }
    
    // Get the number of bytes necessary for the WCHAR string
    int nBytes = WideCharToMultiByte(CP_ACP, 0, m_pchData, -1, NULL, 0, NULL, NULL);
    m_pchDataAnsi = (char *) malloc(nBytes);
    if (m_pchDataAnsi)
    {
        WideCharToMultiByte(CP_ACP, 0, m_pchData, -1, m_pchDataAnsi, nBytes, NULL, NULL);
    }
    else
    {
        CSTRING_THROW_EXCEPTION
    }

    return m_pchDataAnsi; 
}

void CString::GetLastPathComponent(CString & pathComponent) const
{
    int nPath = FindLastPathComponent();
    if (nPath < 0)
    {
        pathComponent = *this;
    }
    else
    {
        Mid(nPath+1, pathComponent);
    }
}

// Get what's not the "file" portion of this path
void CString::GetNotLastPathComponent(CString & pathComponent) const
{
    int nPath = FindLastPathComponent();
    if (nPath < 1)
    {
        pathComponent.Truncate(0);
    }
    else
    {
        Left(nPath, pathComponent);
    }
}

// Get the Drive portion of this path,
// Either C: or \\server\disk format.
void CString::GetDrivePortion(CString & csDrivePortion) const
{
    const WCHAR * lpwszPath = Get();

    const WCHAR * lpwszNonDrivePortion = ShimLib::GetDrivePortion(lpwszPath);

    if (lpwszPath == lpwszNonDrivePortion)
    {
        csDrivePortion.Truncate(0);
    }
    else
    {
        Left((int)(lpwszNonDrivePortion - lpwszPath), csDrivePortion);
    }
}

DWORD CString::GetModuleFileNameW(
  HMODULE hModule    // handle to module
)
{
    // Force the size to MAX_PATH because there is no way to determine necessary buffer size.

    WCHAR * lpsz = GetBuffer(MAX_PATH);
    DWORD dwChars = ::GetModuleFileNameW(hModule, lpsz, MAX_PATH);
    ReleaseBuffer(dwChars);

    return dwChars;
}

DWORD CString::GetSystemDirectoryW(void)
{
    UINT dwChars = ::GetSystemDirectoryW(NULL, 0);
    if (dwChars)
    {
        dwChars += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(dwChars);

        dwChars = ::GetSystemDirectoryW(lpszPath, dwChars);
        
        ReleaseBuffer(dwChars);
    } 
    else
    {
        Truncate(0);
    }

    return dwChars;
}

UINT CString::GetSystemWindowsDirectoryW(void)
{
    UINT dwChars = ::GetSystemWindowsDirectoryW(NULL, 0);
    if (dwChars)
    {
        dwChars += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(dwChars);

        dwChars = ::GetSystemWindowsDirectoryW(lpszPath, dwChars);
        
        ReleaseBuffer(dwChars);
    } 
    else
    {
        Truncate(0);
    }

    return dwChars;
}


DWORD CString::GetWindowsDirectoryW(void)
{
    UINT dwChars = ::GetWindowsDirectoryW(NULL, 0);
    if (dwChars)
    {
        dwChars += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(dwChars);

        dwChars = ::GetWindowsDirectoryW(lpszPath, dwChars);
        
        ReleaseBuffer(dwChars);
    } 
    else
    {
        Truncate(0);
    }

    return dwChars;
}

DWORD CString::GetShortPathNameW(void)
{
    DWORD dwChars = ::GetShortPathNameW(Get(), NULL, 0);
    if (dwChars)
    {
        dwChars += 1;   // One for the NULL

        CString csCopy(*this);
        
        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(dwChars);

        dwChars = ::GetShortPathNameW(csCopy, lpszPath, dwChars);
        
        ReleaseBuffer(dwChars);
    } 

    return dwChars;
}

DWORD CString::GetLongPathNameW(void)
{
    DWORD dwChars = ::GetLongPathNameW(Get(), NULL, 0);
    if (dwChars)
    {
        dwChars += 1;   // One for the NULL

        CString csCopy(*this);
        
        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(dwChars);

        dwChars = ::GetLongPathNameW(csCopy, lpszPath, dwChars);
        
        ReleaseBuffer(dwChars);
    } 

    return dwChars;
}

DWORD CString::GetFullPathNameW(void)
{
    DWORD dwChars = ::GetFullPathNameW(Get(), 0, NULL, NULL);
    if (dwChars)
    {
        dwChars += 1;   // One for the NULL

        CString csCopy(*this);
        
        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(dwChars);

        dwChars = ::GetFullPathNameW(csCopy, dwChars, lpszPath, NULL);
        
        ReleaseBuffer(dwChars);
    } 

    return dwChars;
}

DWORD CString::GetTempPathW(void)
{
    DWORD dwChars = ::GetTempPathW(0, NULL);
    if (dwChars)
    {
        dwChars += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(dwChars);

        dwChars = ::GetTempPathW(dwChars, lpszPath);
        
        ReleaseBuffer(dwChars);
    } 
    else
    {
        Truncate(0);
    }

    return dwChars;
}

UINT CString::GetTempFileNameW(
  LPCWSTR lpPathName,      // directory name
  LPCWSTR lpPrefixString,  // file name prefix
  UINT uUnique            // integer
)
{
    WCHAR * lpsz = GetBuffer(MAX_PATH);
    DWORD dwChars = ::GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpsz);
    ReleaseBuffer(dwChars);

    return dwChars;
}


DWORD CString::GetCurrentDirectoryW(void)
{
    DWORD dwChars = ::GetCurrentDirectory(0, NULL);
    if (dwChars)
    {
        dwChars += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpsz = GetBuffer(dwChars);

        dwChars = ::GetCurrentDirectoryW(dwChars, lpsz);

        ReleaseBuffer(dwChars);
    }
    else
    {
        Truncate(0);
    }

    return dwChars;
}

DWORD CString::ExpandEnvironmentStringsW( )
{
    DWORD dwChars = ::ExpandEnvironmentStringsW(Get(), NULL, 0);
    if (dwChars)
    {
        dwChars += 1;   // One for the NULL

        CString csCopy(*this);

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(dwChars);

        dwChars = ::ExpandEnvironmentStringsW(csCopy, lpszPath, dwChars);
        
        ReleaseBuffer(dwChars-1);
    } 

    return dwChars;
}


// delete all characters to the right of nIndex
void CString::Truncate(int nIndex)
{
    ASSERT(nIndex >= 0, "CString::Truncate");

    if (nIndex < GetLength())
    {
        SetAt(nIndex, L'\0');
        GetData()->nDataLength = nIndex;
    }
}


// Copy the ansi version of this string into the specified buffer,
// If the buffer is not large enough, no data is copied.
//
// Returns the number of BYTES necessary for the buffer
//
DWORD CString::CopyAnsiBytes(char * lpszBuffer, DWORD nBytes)
{
    const char * lpszAnsi = GetAnsi();

    // Length of cstring, in bytes, not including terminator.
    int nDataBytes = strlen(lpszAnsi);

    // Length of buffer (no terminator)
    int nBufBytes = nBytes - 1;

    // Only copy the data if the buffer is large enough
    if (nDataBytes <= nBufBytes)
    {
        // Copy the data into the buffer
        strcpy(lpszBuffer, lpszAnsi);
    }

    // return the actual size of string
    return nDataBytes;
}


// Copy the ansi version of this string into the specified buffer,
// If the buffer is not large enough, no data is copied.
//
// Returns the number of CHARS necessary for the buffer
//
DWORD CString::CopyAnsiChars(char * lpszBuffer, DWORD nChars)
{
    const char * lpszAnsi = GetAnsi();

    // Length of cstring, in bytes, not including terminator.
    int nDataChars = GetLength();

    // Length of buffer (no terminator)
    int nBufChars = nChars - 1;

    // Only copy the data if the buffer is large enough
    if (nDataChars <= nBufChars)
    {
        // Copy the data into the buffer
        strcpy(lpszBuffer, lpszAnsi);
    }

    // return the actual size of string
    return nDataChars;
}



BOOL CString::PatternMatch(const WCHAR * lpszPattern) const
{
    return PatternMatchW(lpszPattern, Get());
}

};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\cstringapi.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    CStringPI.cpp

 Abstract:

    Win32 API wrappers for CString

 Created:

    02/27/2001  robkenny    Created
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.


--*/

#include "ShimLib.h"
#include "Shlobj.h"


namespace ShimLib
{

/*====================================================================================*/
/*++

    Read a registry value into this CString.
    REG_EXPAND_SZ is automatically expanded and the type is changed to REG_SZ
    If the type is not REG_SZ or REG_EXPAND_SZ, then csRegValue.GetLength()
    is the number of *bytes* in the string.
    
    This should, really, only be used to read REG_SZ/REG_EXPAND_SZ registry values.
    
--*/

LONG RegQueryValueExW(
        CString & csValue,
        HKEY hKeyRoot,
        const WCHAR * lpszKey,
        const WCHAR * lpszValue,
        LPDWORD lpType)
{
    LONG success;
    HKEY hKey;

    success = RegOpenKeyW(hKeyRoot, lpszKey, &hKey);
    if (success == ERROR_SUCCESS)
    {    
        DWORD dwSizeBytes;
        success = ::RegQueryValueExW(hKey, lpszValue, 0, lpType, NULL, &dwSizeBytes);
        if (success == ERROR_SUCCESS)
        {
            int nChars = dwSizeBytes / sizeof(WCHAR);
            nChars -= 1; // size included null
            WCHAR * lpszBuffer = csValue.GetBuffer(nChars);

            success = ::RegQueryValueExW(hKey, lpszValue, 0, lpType, (BYTE*)lpszBuffer, &dwSizeBytes);
            if (success == ERROR_SUCCESS)
            {
                csValue.ReleaseBuffer(nChars);

                if (*lpType == REG_EXPAND_SZ)
                {
                    csValue.ExpandEnvironmentStringsW();
                    *lpType = REG_SZ;    
                }
            }
            else
            {
                csValue.ReleaseBuffer(0);
            }
        }

        ::RegCloseKey(hKey);
    }

    if (success != ERROR_SUCCESS)
    {
        csValue.Truncate(0);
    }
    
    return success;
}


/*====================================================================================*/


BOOL SHGetSpecialFolderPathW(
    CString & csFolder,
    int nFolder,
    HWND hwndOwner
)
{
    // Force the size to MAX_PATH because there is no way to determine necessary buffer size.

    WCHAR * lpsz = csFolder.GetBuffer(MAX_PATH);
    BOOL bSuccess = ::SHGetSpecialFolderPathW(hwndOwner, lpsz, nFolder, FALSE);
    csFolder.ReleaseBuffer(-1);  // Don't know the length of the resulting string

    return bSuccess;
}

/*====================================================================================*/
CStringToken::CStringToken(const CString & csToken, const CString & csDelimit)
{
    m_nPos          = 0;
    m_csToken       = csToken;
    m_csDelimit     = csDelimit;
}

/*++

    Grab the next token
--*/

BOOL CStringToken::GetToken(CString & csNextToken, int & nPos) const
{
    // Already reached the end of the string
    if (nPos > m_csToken.GetLength())
    {
        csNextToken.Truncate(0);
        return FALSE;
    }

    int nNextToken;

    // Skip past all the leading seperators
    nPos = m_csToken.FindOneNotOf(m_csDelimit, nPos);
    if (nPos < 0)
    {
        // Nothing but seperators
        csNextToken.Truncate(0);
        nPos = m_csToken.GetLength() + 1;
        return FALSE;
    }

    // Find the next seperator
    nNextToken = m_csToken.FindOneOf(m_csDelimit, nPos);
    if (nNextToken < 0)
    {
        // Did not find a seperator, return remaining string
        m_csToken.Mid(nPos, csNextToken);
        nPos = m_csToken.GetLength() + 1;
        return TRUE;
    }

    // Found a seperator, return the string
    m_csToken.Mid(nPos, nNextToken - nPos, csNextToken);
    nPos = nNextToken;

    return TRUE;
}

/*++

    Grab the next token

--*/

BOOL CStringToken::GetToken(CString & csNextToken)
{
    return GetToken(csNextToken, m_nPos);
}

/*++

    Count the number of remaining tokens.

--*/

int CStringToken::GetCount() const
{
    int nTokenCount = 0;
    int nNextToken = m_nPos;

    CString csTok;
    
    while (GetToken(csTok, nNextToken))
    {
        nTokenCount += 1;
    }

    return nTokenCount;
}

/*====================================================================================*/
/*====================================================================================*/

/*++

    A simple class to assist in command line parsing

--*/

CStringParser::CStringParser(const WCHAR * lpszCl, const WCHAR * lpszSeperators)
{
    m_ncsArgList    = 0;
    m_csArgList     = NULL;

    if (!lpszCl || !*lpszCl)
    {
        return; // no command line == no tokens
    }

    CString csCl(lpszCl);
    CString csSeperator(lpszSeperators);

    if (csSeperator[0] == L' ')
    {
        // Special processing for blank seperated cl
        SplitWhite(csCl);
    }
    else
    {
        SplitSeperator(csCl, csSeperator); 
    }
}

CStringParser::~CStringParser()
{
    if (m_csArgList)
    {
        delete [] m_csArgList;
    }
}

/*++

    Split up the command line based on the seperators

--*/

void CStringParser::SplitSeperator(const CString & csCl, const CString & csSeperator)
{
    CStringToken    csParser(csCl, csSeperator); 
    CString         csTok;

    m_ncsArgList = csParser.GetCount();
    m_csArgList = new CString[m_ncsArgList];
    if (!m_csArgList)
    {
        CSTRING_THROW_EXCEPTION
    }
    
    // Break the command line into seperate tokens
    for (int i = 0; i < m_ncsArgList; ++i)
    {
        csParser.GetToken(m_csArgList[i]);
    }
}

/*++

    Split up the command line based on whitespace,
    this works exactly like the CMD's command line.

--*/

void CStringParser::SplitWhite(const CString & csCl)
{
    LPWSTR * argv = _CommandLineToArgvW(csCl, &m_ncsArgList);
    if (!argv)
    {
        CSTRING_THROW_EXCEPTION
    }

    m_csArgList = new CString[m_ncsArgList];
    if (!m_csArgList)
    {
        CSTRING_THROW_EXCEPTION
    }

    for (int i = 0; i < m_ncsArgList; ++i)
    {
        m_csArgList[i] = argv[i];
    }
    LocalFree(argv);
}

/*====================================================================================*/
/*====================================================================================*/


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\secutils.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    secutils.cpp

 Abstract:
    The utility functions for the shims.

 History:

    02/09/2001  maonis      Created
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.

--*/

#include "secutils.h"


namespace ShimLib
{
/*++

 Function Description:

    Determine if the log on user is a member of the group.

 Arguments:

    IN dwGroup - specify the alias of the group.
    OUT pfIsMember - TRUE if it's a member, FALSE if not.

 Return Value:

    TRUE - we successfully determined if it's a member.
    FALSE otherwise.
 
 DevNote: 
    
    We are assuming the calling thread is not impersonating.

 History:

    02/12/2001 maonis  Created

--*/

BOOL 
SearchGroupForSID(
    DWORD dwGroup, 
    BOOL* pfIsMember
    )
{
    PSID pSID = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL fRes = TRUE;
    
    if (!AllocateAndInitializeSid(
        &SIDAuth, 
        2, 
        SECURITY_BUILTIN_DOMAIN_RID,
        dwGroup,
        0, 
        0, 
        0, 
        0, 
        0, 
        0,
        &pSID))
    {
        DPF("SecurityUtils", eDbgLevelError, "[SearchGroupForSID] AllocateAndInitializeSid failed %d", GetLastError());
        return FALSE;
    }

    if (!CheckTokenMembership(NULL, pSID, pfIsMember))
    {
        DPF("SecurityUtils", eDbgLevelError, "[SearchGroupForSID] CheckTokenMembership failed: %d", GetLastError());
        fRes = FALSE;
    }

    FreeSid(pSID);

    return fRes;
}

/*++

 Function Description:

    Determine if we should shim this app or not.

    If the user is 
    1) a member of the Users and
    2) not a member of the Administrators group and
    3) not a member of the Power Users group and
    3) not a member of the Guest group

    we'll apply the shim.

 Arguments:

    None.

 Return Value:

    TRUE - we should apply the shim.
    FALSE otherwise.
 
 History:

    02/12/2001 maonis  Created

--*/

BOOL 
ShouldApplyShim()
{
    BOOL fIsUser, fIsAdmin, fIsPowerUser, fIsGuest;

    if (!SearchGroupForSID(DOMAIN_ALIAS_RID_USERS, &fIsUser) || 
        !SearchGroupForSID(DOMAIN_ALIAS_RID_ADMINS, &fIsAdmin) || 
        !SearchGroupForSID(DOMAIN_ALIAS_RID_POWER_USERS, &fIsPowerUser) ||
        !SearchGroupForSID(DOMAIN_ALIAS_RID_GUESTS, &fIsGuest))
    {
        //
        // Don't do anything if we are not sure.
        //
        return FALSE;
    }

    return (fIsUser && !fIsPowerUser && !fIsAdmin && !fIsGuest);
}

/*++

 Function Description:

    Get the current thread on user's SID. If the thread is not 
    impersonating we get the current process SID instead.

 Arguments:

    OUT ppThreadSid - points to the current thread's SID.

 Return Value:

    TRUE - successfully got the SID, the caller is responsible for
           freeing it with free().
    FALSE otherwise.
 
 History:

    02/12/2001 maonis  Created

--*/

BOOL 
GetCurrentThreadSid(
    OUT PSID* ppThreadSid
    )
{
    HANDLE hToken;
    DWORD dwLastErr;
    DWORD cbBuffer, cbRequired;
    PTOKEN_USER pUserInfo;
    BOOL fRes = FALSE;

    // Get the thread token.
    if (!OpenThreadToken(
        GetCurrentThread(),
        TOKEN_QUERY,
        FALSE,
        &hToken))
    {
        if ((dwLastErr = GetLastError()) == ERROR_NO_TOKEN)
        {
            // The thread isn't impersonating so we get the process token instead.
            if (!OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &hToken))
            {
                DPF("SecurityUtils", eDbgLevelError, "[GetThreadSid] OpenProcessToken failed: %d", GetLastError());
                return FALSE;
            }
        }
        else
        {
            DPF("SecurityUtils", eDbgLevelError, 
                "[GetThreadSid] OpenThreadToken failed (and not with no token): %d", 
                dwLastErr);
            return FALSE;
        }
    }

    // Call GetTokenInformation with 0 buffer length to get the 
    // required buffer size for the token info.
    cbBuffer = 0;
    if (!GetTokenInformation(
        hToken,
        TokenUser,
        NULL,
        cbBuffer,
        &cbRequired) && 
        (dwLastErr = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) 
    {
        DPF("SecurityUtils", eDbgLevelError, 
            "[GetThreadSid] 1st time calling GetTokenInformation "
            "didn't failed with ERROR_INSUFFICIENT_BUFFER: %d", 
            dwLastErr);
        return FALSE;
    }

    cbBuffer = cbRequired;
    pUserInfo = (PTOKEN_USER)malloc(cbBuffer);
    if (!pUserInfo)
    {
        DPF("SecurityUtils", eDbgLevelError, "[GetThreadSid] HeapAlloc for user data failed");
        return FALSE;
    }

    // Make the "real" call.
    if (!GetTokenInformation(
        hToken,
        TokenUser,
        pUserInfo,
        cbBuffer,
        &cbRequired))
    {
        DPF("SecurityUtils", eDbgLevelError, 
            "[GetThreadSid] 2nd time calling GetTokenInformation failed: %d",
            GetLastError());
        goto EXIT;
    }

    cbBuffer = GetLengthSid(pUserInfo->User.Sid);
    *ppThreadSid = (PSID)malloc(cbBuffer);
    if (!(*ppThreadSid))
    {
        DPF("SecurityUtils", eDbgLevelError, "[GetThreadSid] HeapAlloc for SID failed");
        goto EXIT;
    }

    if (!CopySid(cbBuffer, *ppThreadSid, pUserInfo->User.Sid))
    {
        DPF("SecurityUtils", eDbgLevelError, "[GetThreadSid] CopySid failed: %d", GetLastError());
        goto EXIT;
    }

    fRes = TRUE;

EXIT:

    free(pUserInfo);
    return fRes;
}


// The GENERIC_MAPPING from generic file access rights to specific and standard
// access types.
static GENERIC_MAPPING s_gmFile =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE
};

/*++

 Function Description:

    Given the creation dispositon and the desired access when calling 
    CreateFile, we determine if the caller is requesting write access. 

    This is specific for files.

 Arguments:

    IN pszObject - name of the file or directory.
    OUT pam - points to the access mask of the user to this object.

 Return Value:

    TRUE - successfully got the access mask.
    FALSE otherwise.

 DevNote:

    UNDONE - This might not be a complete list...can add as we debug more apps.

 History:

    02/12/2001 maonis  Created

--*/

BOOL 
RequestWriteAccess(
    IN DWORD dwCreationDisposition, 
    IN DWORD dwDesiredAccess
    )
{
    MapGenericMask(&dwDesiredAccess, &s_gmFile);

    if ((dwCreationDisposition != OPEN_EXISTING) ||
        (dwDesiredAccess & DELETE) || 
        // Generally, app would not specify FILE_WRITE_DATA directly, and if
        // it specifies GENERIC_WRITE, it will get mapped to FILE_WRITE_DATA
        // OR other things so checking FILE_WRITE_DATA is sufficient.
        (dwDesiredAccess & FILE_WRITE_DATA))
    {
        return TRUE;
    }

    return FALSE;
}

/*++

 Function Description:

    Given the name of a directory, determine if the user can create
    new files in this directory.

 Arguments:

    IN pszDir - name of the directory.
    IN pUserSid - the user that's requesting to create files.
    OUT pfCanCreate.

 Return Value:

    TRUE - successfully enabled or disabled the privilege.
    FALSE - otherwise.
 
 History:

    04/03/2001 maonis  Created

--*/

BOOL 
AdjustPrivilege(
    LPCWSTR pwszPrivilege, 
    BOOL fEnable
    )
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tp;
    BOOL fRes = FALSE;

    // Obtain the process token.
    if (OpenProcessToken(
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
        &hToken))
    {
        // Get the LUID.
        if (LookupPrivilegeValueW(NULL, pwszPrivilege, &tp.Privileges[0].Luid))
        {        
            tp.PrivilegeCount = 1;

            tp.Privileges[0].Attributes = (fEnable ? SE_PRIVILEGE_ENABLED : 0);

            // Enable or disable the privilege.
            if (AdjustTokenPrivileges(
                hToken, 
                FALSE, 
                &tp, 
                0,
                (PTOKEN_PRIVILEGES)NULL, 
                0))
            {
                fRes = TRUE;
            }
        }

        CloseHandle(hToken);
    }

    return fRes;
}



};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\shimhook.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    ShimHook.cpp

 Abstract:

    Strictly Shim hooking routines.

 Notes:

    None

 History:

    11/01/1999  markder     Created
    11/11/1999  markder     Added comments
    01/10/2000  linstev     Format to new style
    03/14/2000  robkenny    Changed DPF from eDebugLevelInfo to eDebugLevelSpew
    03/31/2000  robkenny    Added our own private versions of malloc/free new/delete
    10/29/2000  markder     Added version 2 support
    08/14/2001  robkenny    Moved generic routines to ShimLib.cpp
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.

--*/

#include "ShimHook.h"
#include "ShimHookMacro.h"

namespace ShimLib
{

HINSTANCE               g_hinstDll;
BOOL                    g_bMultiShim;
PHOOKAPI                g_pAPIHooks;   
PSHIM_COM_HOOK          g_pCOMHooks;   
DWORD                   g_dwAPIHookCount;   
DWORD                   g_dwCOMHookCount;   
DWORD                   g_dwCOMHookBuffer;
DWORD                   g_dwShimVersion;
CHAR                    g_szCommandLine[SHIM_COMMAND_LINE_MAX_BUFFER];

/*++

 Global variables for COM hook support

 The following variables are pointers to the first entry in linked lists that
 are maintained by the mechanism in order to properly manage the hooking
 process.

 There will be one SHIM_IFACE_FN_MAP for every COM interface function pointer
 that was overwritten with one of our hooks.

 There will be one SHIM_HOOKED_OBJECT entry every COM interface that is handed
 out. This is required to differentiate between different classes that expose
 the same interface, but one is hooked and one isn't.

--*/
PSHIM_IFACE_FN_MAP      g_pIFaceFnMaps;
PSHIM_HOOKED_OBJECT     g_pObjectCache;
PLDR_DATA_TABLE_ENTRY   g_DllLoadingEntry;



PHOOKAPI    GetHookAPIs( IN LPSTR pszCmdLine, IN LPWSTR pwszShim, IN OUT DWORD *pdwHooksCount ); 
void        PatchFunction( PVOID* pVtbl, DWORD dwVtblIndex, PVOID pfnNew );
ULONG       COMHook_AddRef( PVOID pThis );
ULONG       COMHook_Release( PVOID pThis );
HRESULT     COMHook_QueryInterface( PVOID pThis, REFIID iid, PVOID* ppvObject );
HRESULT     COMHook_IClassFactory_CreateInstance( PVOID pThis, IUnknown * pUnkOuter, REFIID riid, void ** ppvObject );
VOID        HookObject(IN CLSID *pCLSID, IN REFIID riid, OUT LPVOID *ppv, OUT PSHIM_HOOKED_OBJECT pOb, IN BOOL bClassFactory);



void
NotifyShims(
    int      nReason,
    UINT_PTR extraInfo
    )
{
    switch (nReason) {
    case SN_STATIC_DLLS_INITIALIZED:
        InitializeHooksEx(SHIM_STATIC_DLLS_INITIALIZED, NULL, NULL, NULL);
        break;
    case SN_PROCESS_DYING:
        InitializeHooksEx(SHIM_PROCESS_DYING, NULL, NULL, NULL);
        break;
    case SN_DLL_LOADING:
        
        g_DllLoadingEntry = (PLDR_DATA_TABLE_ENTRY)extraInfo;
        
        InitializeHooksEx(SHIM_DLL_LOADING, NULL, NULL, NULL);
        break;
    }
}


/*++

 Function Description:

    Called by the shim mechanism. Initializes the global APIHook array and
    returns necessary information to the shim mechanism.

 Arguments:

    IN dwGetProcAddress  -  Function pointer to GetProcAddress
    IN dwLoadLibraryA    -  Function pointer to LoadLibraryA
    IN dwFreeLibrary     -  Function pointer to FreeLibrary
    IN OUT pdwHooksCount -  Receive the number of APIHooks in the returned array

 Return Value:

    Pointer to global HOOKAPI array.

 History:

    11/01/1999 markder  Created

--*/

PHOOKAPI
GetHookAPIs(
    IN LPSTR pszCmdLine,
    IN LPWSTR pwszShim,
    IN OUT DWORD * pdwHooksCount
    )
{
    char        szModName[MAX_PATH] = "";
    char*       pszCursor = NULL;
    PHOOKAPI    pHookAPIs = NULL;
    
    // Initialize file logging for this shim.
    
    GetModuleFileNameA(g_hinstDll, szModName, MAX_PATH);

    pszCursor = szModName + lstrlenA(szModName);

    while (pszCursor >= szModName && *pszCursor != '\\') {
        pszCursor--;
    }
    
    InitFileLogSupport(pszCursor + 1);
    
    pHookAPIs = InitializeHooksEx(DLL_PROCESS_ATTACH, pwszShim, pszCmdLine, pdwHooksCount);

    DPF("ShimLib", eDbgLevelBase, 
        "[Shim] %S%s%s%s\n", 
        pwszShim,
        pszCmdLine[0] != '\0' ? "(\"" : "",
        pszCmdLine,
        pszCmdLine[0] != '\0' ? "\")" : "");

    return pHookAPIs;
}

/*++

 Function Description:

    Adds an entry to the g_IFaceFnMaps linked list.

 Arguments:

    IN  pVtbl  - Pointer to an interface vtable to file under
    IN  pfnNew - Pointer to the new (stub) function
    IN  pfnOld - Pointer to the old (original) function

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

VOID
AddIFaceFnMap(
    IN PVOID pVtbl,
    IN PVOID pfnNew,
    IN PVOID pfnOld
    )
{
    PSHIM_IFACE_FN_MAP pNewMap = (PSHIM_IFACE_FN_MAP) ShimMalloc( sizeof(SHIM_IFACE_FN_MAP) );

    if (pNewMap == NULL)
    {
        DPF("ShimLib", eDbgLevelError, "[AddIFaceFnMap]  Could not allocate space for new SHIM_IFACE_FN_MAP.\n");
        return;
    }

    DPF("ShimLib", eDbgLevelSpew, "[AddIFaceFnMap]  pVtbl: 0x%p pfnNew: 0x%p pfnOld: 0x%p\n",
        pVtbl,
        pfnNew,
        pfnOld);

    pNewMap->pVtbl  = pVtbl;
    pNewMap->pfnNew = pfnNew;
    pNewMap->pfnOld = pfnOld;

    pNewMap->pNext = g_pIFaceFnMaps;
    g_pIFaceFnMaps = pNewMap;
}

/*++

 Function Description:

  Searches the g_pIFaceFnMaps linked list for a match on pVtbl and pfnNew, and
  returns the corresponding pfnOld. This is typically called from inside a
  stubbed function to determine what original function pointer to call for the
  particular vtable that was used by the caller.

  It is also used by PatchFunction to determine if a vtable's function pointer
  has already been stubbed.

 Arguments:

    IN  pVtbl  - Pointer to an interface vtable to file under
    IN  pfnNew - Pointer to the new (stub) function
    IN  bThrowExceptionIfNull - Flag that specifies whether it should be
                 possible to not find the original function in our function
                 map

 Return Value:

    Returns the original function pointer

 History:

    11/01/1999 markder  Created

--*/

PVOID
LookupOriginalCOMFunction(
    IN PVOID pVtbl,
    IN PVOID pfnNew,
    IN BOOL bThrowExceptionIfNull
    )
{
    PSHIM_IFACE_FN_MAP pMap = g_pIFaceFnMaps;
    PVOID pReturn = NULL;

    DPF("ShimLib", eDbgLevelSpew, "[LookupOriginalCOMFunction] pVtbl: 0x%p pfnNew: 0x%p ",
        pVtbl,
        pfnNew);

    // Scan the linked list for a match and return if found.
    while (pMap)
    {
        if (pMap->pVtbl == pVtbl && pMap->pfnNew == pfnNew)
        {
            pReturn = pMap->pfnOld;
            break;
        }

        pMap = (PSHIM_IFACE_FN_MAP) pMap->pNext;
    }

    DPF("ShimLib", eDbgLevelSpew, " --> Returned: 0x%p\n", pReturn);

    if (!pReturn && bThrowExceptionIfNull)
    {
        // If we have hit this point, there is something seriously wrong.
        // Either there is a bug in the AddRef/Release stubs or the app
        // obtained an interface pointer in some way that we don't catch.
        DPF("ShimLib", eDbgLevelError,"ERROR: Shim COM APIHooking mechanism failed.\n");
        APPBreakPoint();
    }

    return pReturn;
}

/*++

 Function Description:

  Stores the original function pointer in the function map and overwrites it in
  the vtable with the new one.

 Arguments:

    IN  pVtbl       - Pointer to an interface vtable to file under
    IN  dwVtblIndex - The index of the target function within the vtable.
    IN  pfnNew      - Pointer to the new (stub) function

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

VOID
PatchFunction(
    IN PVOID* pVtbl,
    IN DWORD dwVtblIndex,
    IN PVOID pfnNew
    )
{
    DWORD dwOldProtect = 0;
    DWORD dwOldProtect2 = 0;

    DPF("ShimLib", eDbgLevelSpew, "[PatchFunction] pVtbl: 0x%p, dwVtblIndex: %d, pfnOld: 0x%p, pfnNew: 0x%p\n",
        pVtbl,
        dwVtblIndex,
        pVtbl[dwVtblIndex],
        pfnNew);

    // if not patched yet
    if (!LookupOriginalCOMFunction( pVtbl, pfnNew, FALSE))
    {
        AddIFaceFnMap( pVtbl, pfnNew, pVtbl[dwVtblIndex]);

        // Make the code page writable and overwrite function pointers in vtable
        if (VirtualProtect(pVtbl + dwVtblIndex,
                sizeof(DWORD),
                PAGE_READWRITE,
                &dwOldProtect))
        {
            pVtbl[dwVtblIndex] = pfnNew;

            // Return the code page to its original state
            VirtualProtect(pVtbl + dwVtblIndex,
                sizeof(DWORD),
                dwOldProtect,
                &dwOldProtect2);
        }
    }

}

/*++

 Function Description:

    This stub exists to keep track of an interface's reference count changes.
    Note that the bAddRefTrip flag is cleared, which allows
    APIHook_QueryInterface to determine whether an AddRef was performed inside
    the original QueryInterface function call.

 Arguments:

    IN  pThis - The object's 'this' pointer

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

ULONG
APIHook_AddRef(
    IN PVOID pThis
    )
{
    PSHIM_HOOKED_OBJECT pHookedOb = g_pObjectCache;
    _pfn_AddRef pfnOld;
    ULONG ulReturn;

    pfnOld = (_pfn_AddRef) LookupOriginalCOMFunction( *((PVOID*)(pThis)),
        APIHook_AddRef,
        TRUE);

    ulReturn = (*pfnOld)(pThis);

    while (pHookedOb)
    {
        if (pHookedOb->pThis == pThis)
        {
            pHookedOb->dwRef++;
            pHookedOb->bAddRefTrip = FALSE;
            DPF("ShimLib", eDbgLevelSpew, "[AddRef] pThis: 0x%p dwRef: %d ulReturn: %d\n",
                pThis,
                pHookedOb->dwRef,
                ulReturn);
            break;
        }

        pHookedOb = (PSHIM_HOOKED_OBJECT) pHookedOb->pNext;
    }

    return ulReturn;
}

/*++

 Function Description:

    This stub exists to keep track of an interface's reference count changes.

 Arguments:

    IN  pThis - The object's 'this' pointer

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

ULONG
APIHook_Release(
    IN PVOID pThis
    )
{
    PSHIM_HOOKED_OBJECT *ppHookedOb = &g_pObjectCache;
    PSHIM_HOOKED_OBJECT pTemp;
    _pfn_Release pfnOld;
    ULONG ulReturn;

    pfnOld = (_pfn_Release) LookupOriginalCOMFunction(*((PVOID*)(pThis)),
        APIHook_Release,
        TRUE);

    ulReturn = (*pfnOld)( pThis );

    while ((*ppHookedOb))
    {
        if ((*ppHookedOb)->pThis == pThis)
        {
            (*ppHookedOb)->dwRef--;

            DPF("ShimLib", eDbgLevelSpew, "[Release] pThis: 0x%p dwRef: %d ulReturn: %d %s\n",
                pThis,
                (*ppHookedOb)->dwRef,
                ulReturn,
                ((*ppHookedOb)->dwRef?"":" --> Deleted"));

            if (!((*ppHookedOb)->dwRef))
            {
                pTemp = (*ppHookedOb);
                *ppHookedOb = (PSHIM_HOOKED_OBJECT) (*ppHookedOb)->pNext;
                ShimFree(pTemp);
            }

            break;
        }

        ppHookedOb = (PSHIM_HOOKED_OBJECT*) &((*ppHookedOb)->pNext);
    }

    return ulReturn;
}

/*++

 Function Description:

    This stub catches the application attempting to obtain a new interface
    pointer to the same object. The function searches the object cache
    to obtain a CLSID for the object and, if found, APIHooks all required
    functions in the new vtable (via the HookObject call).

 Arguments:

    IN  pThis     - The object's 'this' pointer
    IN  iid       - Reference to the identifier of the requested interface
    IN  ppvObject - Address of output variable that receives the interface
                    pointer requested in riid.

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

HRESULT
APIHook_QueryInterface(
    PVOID pThis,
    REFIID iid,
    PVOID* ppvObject
    )
{
    HRESULT hrReturn = E_FAIL;
    _pfn_QueryInterface pfnOld = NULL;
    PSHIM_HOOKED_OBJECT pOb = g_pObjectCache;

    pfnOld = (_pfn_QueryInterface) LookupOriginalCOMFunction(
        *((PVOID*)pThis),
        APIHook_QueryInterface,
        TRUE);

    while (pOb)
    {
        if (pOb->pThis == pThis)
        {
            pOb->bAddRefTrip = TRUE;
            break;
        }
        pOb = (PSHIM_HOOKED_OBJECT) pOb->pNext;
    }

    if (S_OK == (hrReturn = (*pfnOld) (pThis, iid, ppvObject)))
    {
        if (pOb)
        {
            if (pOb->pThis == *((PVOID*)ppvObject))
            {
                // Same object. Detect whether QueryInterface used IUnknown::AddRef
                // or an internal function.
                DPF("ShimLib",  eDbgLevelSpew,"[HookObject] Existing object%s. pThis: 0x%p\n",
                    (pOb->bAddRefTrip?" (AddRef'd) ":""),
                    pOb->pThis);

                if (pOb->bAddRefTrip)
                {
                    (pOb->dwRef)++;      // AddRef the object
                    pOb->bAddRefTrip = FALSE;
                }

                // We are assured that the CLSID for the object will be the same.
                HookObject(pOb->pCLSID, iid, ppvObject, pOb, pOb->bClassFactory);
            }
            else
            {
                HookObject(pOb->pCLSID, iid, ppvObject, NULL, pOb->bClassFactory);
            }
        }
    }

    return hrReturn;
}

/*++

 Function Description:

    This stub catches the most interesting part of the object creation process:
    The actual call to IClassFactory::CreateInstance. Since no CLSID is passed
    in to this function, the stub must decide whether to APIHook the object by
    looking up the instance of the class factory in the object cache. IF IT
    EXISTS IN THE CACHE, that indicates that it creates an object that we wish
    to APIHook.

 Arguments:

    IN  pThis     - The object's 'this' pointer
    IN  pUnkOuter - Pointer to whether object is or isn't part of an aggregate
    IN  riid      - Reference to the identifier of the interface
    OUT ppvObject - Address of output variable that receives the interface
                    pointer requested in riid

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

HRESULT
APIHook_IClassFactory_CreateInstance(
    PVOID pThis,
    IUnknown *pUnkOuter,
    REFIID riid,
    VOID **ppvObject
    )
{
    HRESULT hrReturn = E_FAIL;
    _pfn_CreateInstance pfnOldCreateInst = NULL;
    PSHIM_HOOKED_OBJECT pOb = g_pObjectCache;

    pfnOldCreateInst = (_pfn_CreateInstance) LookupOriginalCOMFunction(
                                                *((PVOID*)pThis),
                                                APIHook_IClassFactory_CreateInstance,
                                                FALSE);

    if (pfnOldCreateInst == NULL) {
        DPF("ShimLib", eDbgLevelError, "[CreateInstance] Cannot find CreateInstance\n", pThis);
        return E_FAIL;
    }
    
    if (S_OK == (hrReturn = (*pfnOldCreateInst)(pThis, pUnkOuter, riid, ppvObject)))
    {
        while (pOb)
        {
            if (pOb->pThis == pThis)
            {
                // This class factory instance creates an object that we APIHook.
                DPF("ShimLib", eDbgLevelSpew, "[CreateInstance] Hooking object! pThis: 0x%p\n", pThis);
                HookObject(pOb->pCLSID, riid, ppvObject, NULL, FALSE);
                break;
            }

            pOb = (PSHIM_HOOKED_OBJECT) pOb->pNext;
        }
    }

    return hrReturn;
}


VOID
HookCOMInterface(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv,
    BOOL bClassFactory
    )
{
    DWORD i = 0;

    // Determine if we need to hook this object
    for (i = 0; i < g_dwCOMHookCount; i++)
    {
        if (g_pCOMHooks[i].pCLSID &&
            IsEqualGUID( (REFCLSID) *(g_pCOMHooks[i].pCLSID), rclsid))
        {
            // Yes, we are hooking an interface on this object.
            HookObject((CLSID*) &rclsid, riid, ppv, NULL, bClassFactory);
            break;
        }
    }
}

/*++

 Function Description:

    Free memory associated with Hooks and dump info

 Arguments:

    None

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

VOID
DumpCOMHooks()
{
    PSHIM_IFACE_FN_MAP pMap = g_pIFaceFnMaps;
    PSHIM_HOOKED_OBJECT pHookedOb = g_pObjectCache;

    // Dump function map
    DPF("ShimLib", eDbgLevelSpew, "\n--- Shim COM Hook Function Map ---\n\n");

    while (pMap)
    {
        DPF("ShimLib", eDbgLevelSpew, "pVtbl: 0x%p pfnNew: 0x%p pfnOld: 0x%p\n",
            pMap->pVtbl,
            pMap->pfnNew,
            pMap->pfnOld);

        pMap = (PSHIM_IFACE_FN_MAP) pMap->pNext;
    }

    // Dump class factory cache
    DPF("ShimLib", eDbgLevelSpew, "\n--- Shim Object Cache (SHOULD BE EMPTY!!) ---\n\n");

    while (pHookedOb)
    {
        DPF("ShimLib", eDbgLevelSpew, "pThis: 0x%p dwRef: %d\n",
            pHookedOb->pThis,
            pHookedOb->dwRef);

        pHookedOb = (PSHIM_HOOKED_OBJECT) pHookedOb->pNext;
    }
}

/*++

 Function Description:

    This function adds the object's important info to the object cache and then
    patches all required functions. IUnknown is hooked for all objects
    regardless.

 Arguments:

    IN  rclsid - CLSID for the class object
    IN  riid   - Reference to the identifier of the interface that communicates
                 with the class object
    OUT ppv    - Address of the pThis pointer that uniquely identifies an
                 instance of the COM interface
    OUT pOb    - New obj pointer
    IN  bClassFactory - Is this a class factory call

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

VOID
HookObject(
    IN CLSID *pCLSID,
    IN REFIID riid,
    OUT LPVOID *ppv,
    OUT PSHIM_HOOKED_OBJECT pOb,
    IN BOOL bClassFactory
    )
{
    // Here's how a COM object looks in memory:
    //
    //      pv                        - The pointer to the object's interface. In C++ terms, it 
    //       |                          is sort of like the "this" pointer but objects
    //       |                          will hand back different pointers for different interfaces.
    //       |
    //       `-> pVtbl                - The COM virtual function table pointer. This is the
    //            |                     first 32-bit member of the interface structure.
    //            |
    //            |-> QueryInterface  - First function in the root interface, IUnknown. This
    //            |                     function allows calling members to request a different
    //            |                     interface that may be implemented by the object.
    //            |
    //            |-> AddRef          - Increments the reference count for this interface.
    //            |
    //            |-> Release         - Decrements the reference count for this interface.
    //            |
    //            |-> InterfaceFn1    - Beginning of the interface-specific functions.
    //            |-> InterfaceFn2    
    //            |-> InterfaceFn3
    //            |        .
    //            |        .
    //            |        .
    //

    // The COM hooking mechanism is interested in the virtual function table pointer, and to get
    // it we must dereference the ppv pointer twice.
    PVOID *pVtbl = ((PVOID*)(*((PVOID*)(*ppv))));

    DWORD i = 0;

    if (!pOb)
    {
        // If pOb is NULL, then the object does not exist in the cache yet.
        // Make a new entry for the object.

        DPF("ShimLib", eDbgLevelSpew, "[HookObject] New %s! pThis: 0x%p\n",
            (bClassFactory?"class factory":"object"),
            *ppv);

        pOb = (PSHIM_HOOKED_OBJECT) ShimMalloc(sizeof(SHIM_HOOKED_OBJECT));

        if( pOb == NULL )
        {
            DPF("ShimLib", eDbgLevelError, "[HookObject] Could not allocate memory for SHIM_HOOKED_OBJECT.\n");
            return;
        }

        pOb->pCLSID = pCLSID;
        pOb->pThis = *ppv;
        pOb->dwRef = 1;
        pOb->bAddRefTrip = FALSE;
        pOb->pNext = g_pObjectCache;
        pOb->bClassFactory = bClassFactory;

        g_pObjectCache = pOb;
    }

    // IUnknown must always be hooked since it is possible to get
    // a new interface pointer using it, and we need to process each interface
    // handed out. We must also keep track of the reference count so that
    // we can clean up our interface function map.

    PatchFunction(pVtbl, 0, APIHook_QueryInterface);
    PatchFunction(pVtbl, 1, APIHook_AddRef);
    PatchFunction(pVtbl, 2, APIHook_Release);

    if (bClassFactory && IsEqualGUID(IID_IClassFactory, riid))
    {
        // If we are processing a class factory, all we care about
        // hooking is CreateInstance, since it is an API that produces
        // the actual object we are interested in.
        PatchFunction(pVtbl, 3, APIHook_IClassFactory_CreateInstance);
    }
    else
    {
        for (i = 0; i < g_dwCOMHookCount; i++)
        {
            if (!(g_pCOMHooks[i].pCLSID) || !pCLSID)
            {
                // A CLSID was not specified -- hook any object that exposes
                // the specified interface.
                if (IsEqualGUID( (REFIID) *(g_pCOMHooks[i].pIID), riid))
                {
                    PatchFunction(
                        pVtbl,
                        g_pCOMHooks[i].dwVtblIndex,
                        g_pCOMHooks[i].pfnNew);
                }
            }
            else
            {
                // A CLSID was specified -- hook only interfaces on the
                // specified object.
                if (IsEqualGUID((REFCLSID) *(g_pCOMHooks[i].pCLSID), *pCLSID) &&
                    IsEqualGUID((REFIID) *(g_pCOMHooks[i].pIID), riid))
                {
                    PatchFunction(
                        pVtbl,
                        g_pCOMHooks[i].dwVtblIndex,
                        g_pCOMHooks[i].pfnNew);
                }
            }
        }
    }
}


BOOL InitHooks(DWORD dwCount)
{
    g_dwAPIHookCount = dwCount;
    g_pAPIHooks = (PHOOKAPI) ShimMalloc( g_dwAPIHookCount * sizeof(HOOKAPI) );
    if (g_pAPIHooks)
    {
        ZeroMemory(g_pAPIHooks, g_dwAPIHookCount * sizeof(HOOKAPI) );
    }

    return g_pAPIHooks != NULL;
}

BOOL InitComHooks(DWORD dwCount)
{
    //DECLARE_APIHOOK(DDraw.dll, DirectDrawCreate);
    //DECLARE_APIHOOK(DDraw.dll, DirectDrawCreateEx);

    g_dwCOMHookCount = dwCount;
    g_pCOMHooks = (PSHIM_COM_HOOK) ShimMalloc( g_dwCOMHookCount * sizeof(SHIM_COM_HOOK) );
    if (g_pCOMHooks)
    {
        ZeroMemory(g_pCOMHooks, g_dwCOMHookCount * sizeof(SHIM_COM_HOOK) );
    }

    return g_pCOMHooks != NULL;
    
}

VOID AddComHook(REFCLSID clsid, REFIID iid, PVOID hook, DWORD vtblndx)
{
    if (g_dwCOMHookBuffer <= g_dwCOMHookCount) {

        // Buffer is too small, must resize.
        DWORD           dwNewBuffer = g_dwCOMHookBuffer * 2;
        PSHIM_COM_HOOK  pNewBuffer  = NULL;

        if (dwNewBuffer == 0) {
            // 50 is the initial allocation, but it should be at least g_dwCOMHookCount
            dwNewBuffer = max(50, g_dwCOMHookCount);
        }

        pNewBuffer = (PSHIM_COM_HOOK) ShimMalloc( sizeof(SHIM_COM_HOOK) * dwNewBuffer );

        if (pNewBuffer == NULL) {
            DPF("ShimLib", eDbgLevelError, 
                "[AddComHook] Could not allocate SHIM_COM_HOOK array.");
            return;
        }

        // Copy over original array, then free the old one.

        if (g_pCOMHooks != NULL) {
            memcpy(pNewBuffer, g_pCOMHooks, sizeof(SHIM_COM_HOOK) * g_dwCOMHookBuffer);
            ShimFree(g_pCOMHooks);
        }

        g_pCOMHooks = pNewBuffer;
        g_dwCOMHookBuffer = dwNewBuffer;
    }
    
    g_pCOMHooks[g_dwCOMHookCount].pCLSID        = (CLSID*) &clsid;           
    g_pCOMHooks[g_dwCOMHookCount].pIID          = (IID*)  &iid;              
    g_pCOMHooks[g_dwCOMHookCount].dwVtblIndex   = vtblndx;                   
    g_pCOMHooks[g_dwCOMHookCount].pfnNew        = hook;            

    g_dwCOMHookCount++;

    return;
}


}; // end of namespace ShimLib

/*++

 Function Description:

    Called on process detach with old shim mechanism.

 Arguments:

    See MSDN

 Return Value:

    See MSDN

 History:

    11/01/1999 markder  Created

--*/

BOOL
DllMain(
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID /*lpvReserved*/
    )
{
    using namespace ShimLib;

    switch (fdwReason) {
    
    case DLL_PROCESS_ATTACH:
        g_hinstDll          = hinstDLL;
        g_pAPIHooks         = NULL;
        g_dwAPIHookCount    = 0;
        g_dwCOMHookCount    = 0;
        g_dwCOMHookBuffer   = 0;
        g_pCOMHooks         = NULL;
        g_pIFaceFnMaps      = NULL;
        g_pObjectCache      = NULL;
        g_szCommandLine[0]  = '\0';
        g_bMultiShim        = FALSE;
        g_dwShimVersion     = 1;
        break;
    
    case DLL_PROCESS_DETACH:
        if (g_dwCOMHookCount > 0) {
            DumpCOMHooks();
        }

        InitializeHooks(DLL_PROCESS_DETACH);
        InitializeHooksEx(DLL_PROCESS_DETACH, NULL, NULL, NULL);

        break;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\win9xpath.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Win9xPath.h

 History:

    10/20/2000  robkenny    Created

--*/


#include <windows.h>

namespace ShimLib
{

inline bool bIsPathSep(char ch)
{
    return ch == '\\' || ch == '/';
}

inline bool bIsPathSep(WCHAR ch)
{
    return ch == L'\\' || ch == L'/';
}

const WCHAR * GetDrivePortion(const WCHAR * uncorrected);

// Non-const version of above routine.
inline WCHAR * GetDrivePortion(WCHAR * uncorrected)
{
    return (WCHAR *)GetDrivePortion((const WCHAR*)uncorrected);
}

WCHAR * W9xPathMassageW(const WCHAR * uncorrect);

};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\lua.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   lua.h

 Abstract:

   Exports used by ntvdm.

 Created:

   05/31/2001 maonis

 Modified:

--*/

#ifndef _LUA__H_
#define _LUA__H_

#ifndef EXTERN_C
#if defined(__cplusplus)
#define EXTERN_C extern "C"
#else
#define EXTERN_C
#endif
#endif

EXTERN_C BOOL      LuaShouldApplyShim();
EXTERN_C BOOL      LuaFSInit(LPCSTR pszCommandLine);
EXTERN_C BOOL      LuaRegInit();
EXTERN_C BOOL      LuacFSInit(LPCSTR pszCommandLine);
EXTERN_C VOID      LuacFSCleanup();
EXTERN_C BOOL      LuacRegInit();
EXTERN_C VOID      LuacRegCleanup();
EXTERN_C BOOL      LuatFSInit();
EXTERN_C VOID      LuatFSCleanup();

//
// Redirect routines.
//

EXTERN_C HANDLE    LuaCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
EXTERN_C BOOL      LuaDeleteFileW(LPCWSTR lpFileName);
EXTERN_C BOOL      LuaRemoveDirectoryW(LPCWSTR lpFileName);
EXTERN_C BOOL      LuaCreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
EXTERN_C BOOL      LuaCopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
EXTERN_C BOOL      LuaMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
EXTERN_C DWORD     LuaGetFileAttributesW(LPCWSTR wcsFileName);
EXTERN_C BOOL      LuaSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
EXTERN_C UINT      LuaGetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);

EXTERN_C UINT      LuaGetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
EXTERN_C DWORD     LuaGetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
EXTERN_C DWORD     LuaGetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName);
EXTERN_C DWORD     LuaGetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR  lpReturnedString, DWORD  nSize, LPCWSTR lpFileName);
EXTERN_C BOOL      LuaGetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR lpFileName);
EXTERN_C BOOL      LuaWritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName);
EXTERN_C BOOL      LuaWritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
EXTERN_C BOOL      LuaWritePrivateProfileStructW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR lpFileName);

EXTERN_C LONG      LuaRegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
EXTERN_C LONG      LuaRegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); 
EXTERN_C LONG      LuaRegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult); 
EXTERN_C LONG      LuaRegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
EXTERN_C LONG      LuaRegCloseKey(HKEY hkey);
EXTERN_C LONG      LuaRegQueryValueW(HKEY hkey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData);
EXTERN_C LONG      LuaRegQueryValueExW(HKEY hkey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
EXTERN_C LONG      LuaRegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData);
EXTERN_C LONG      LuaRegSetValueExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, DWORD dwType, CONST BYTE * lpData, DWORD cbData);
EXTERN_C LONG      LuaRegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
EXTERN_C LONG      LuaRegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cbName);
EXTERN_C LONG      LuaRegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
EXTERN_C LONG      LuaRegDeleteKeyW(HKEY hKey,LPCWSTR lpSubKey);

//
// Cleanup routines.
//

EXTERN_C HANDLE    LuacFindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
EXTERN_C DWORD     LuacGetFileAttributesW(LPCWSTR wcsFileName);
EXTERN_C HANDLE    LuacCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
EXTERN_C BOOL      LuacDeleteFileW(LPCWSTR lpFileName);
EXTERN_C BOOL      LuacRemoveDirectoryW(LPCWSTR lpFileName);

EXTERN_C LONG      LuacRegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
EXTERN_C LONG      LuacRegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); 
EXTERN_C LONG      LuacRegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cbName);
EXTERN_C LONG      LuacRegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
EXTERN_C LONG      LuacRegCloseKey(HKEY hkey);
EXTERN_C LONG      LuacRegDeleteKeyW(HKEY hKey,LPCWSTR lpSubKey);

//
// Tracking routines.
//

EXTERN_C HANDLE    LuatCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
EXTERN_C BOOL      LuatCopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
EXTERN_C BOOL      LuatCreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
EXTERN_C BOOL      LuatSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
EXTERN_C BOOL      LuatDeleteFileW(LPCWSTR lpFileName);
EXTERN_C BOOL      LuatMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
EXTERN_C BOOL      LuatRemoveDirectoryW(LPCWSTR lpFileName);
EXTERN_C UINT      LuatGetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);

EXTERN_C BOOL      LuatWritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
EXTERN_C BOOL      LuatWritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName);
EXTERN_C BOOL      LuatWritePrivateProfileStructW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR lpFileName);

#endif // _LUA__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\utils.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    Utils.cpp

 Abstract:

    Common functions for all modules

 Notes:

    None

 History:

    11/03/2001  clupu     Created

--*/

#include "ShimHook.h"

namespace ShimLib
{

void
DumpUnloadOrder(
    PPEB Peb
    )
{
    PLIST_ENTRY LdrNext;
    
    if (GetDebugLevel() > eDbgLevelInfo) {
        return;
    }
    
    //
    // Dump the order the shims will unload
    //
    LdrNext = Peb->Ldr->InInitializationOrderModuleList.Blink;

    DPF("ShimLib", eDbgLevelInfo, "\n[SeiDumpUnloadOrder] Unload order:\n");
    
    while (LdrNext != &Peb->Ldr->InInitializationOrderModuleList) {

        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InInitializationOrderLinks);
        
        LdrNext = LdrNext->Blink;

        //
        // Dump the entry to be called
        //
        DPF("ShimLib",
            eDbgLevelInfo,
            "[SeiDumpUnloadOrder] \"%40S\" 0x%x\n",
            LdrEntry->BaseDllName.Buffer,
            LdrEntry->DllBase);
    }
}

/*++

 Function Description:
    
    Call this function if you want to push the specified DLL to the
    end of the list of modules to be unloaded.
    
    NOTE: Make sure that the module that will be pushed at the end
          will not call any APIs that reside in other modules during
          its DLL_PROCESS_DETACH callout.

 Arguments:

    IN hMod          - handle to the module to push.
                       Specify NULL to push the calling DLL.

 Return Value: 
    
    TRUE if successful, FALSE otherwise.

 History:

    11/01/2001 clupu Created

--*/
BOOL
MakeShimUnloadLast(
    HMODULE hMod
    )
{
    PPEB        Peb = NtCurrentPeb();
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    BOOL        bRet = FALSE;
    
    if (hMod == NULL) {
        hMod = g_hinstDll;
    }
    
    //
    // Dump the unload order if SHIM_DEBUG_LEVEL is at least eDbgLevelInfo
    //
    DumpUnloadOrder(Peb);

    LdrHead = &Peb->Ldr->InInitializationOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        PLIST_ENTRY           LdrCrt;
        PLDR_DATA_TABLE_ENTRY LdrEntry;
        
        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InInitializationOrderLinks);

        LdrCrt = LdrNext;
        
        LdrNext = LdrEntry->InInitializationOrderLinks.Flink;
        
        if (LdrEntry->DllBase == hMod) {
            //
            // This is the module we're looking for. Get him out of the list
            // and insert it at the beginning of the list.
            //
            RemoveEntryList(LdrCrt);
            InsertHeadList(LdrHead, LdrCrt);
            bRet = TRUE;
            break;
        }
    }
    
    DumpUnloadOrder(Peb);
    
    return bRet;
}

};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\veriflog.cpp ===
/*++

    Copyright (c) 2001  Microsoft Corporation

    Module Name:

        VerifLog.cpp

    Abstract:

        This module implements the code for manipulating the AppVerifier log file.

    Author:

        dmunsil     created     04/26/2001

    Revision History:

    08/14/2001  robkenny    Moved code inside the ShimLib namespace.
    09/21/2001  rparsons    Logging code now uses NT calls.
    09/25/2001  rparsons    Added critical section.
--*/

#include "ShimHook.h"
#include "VerifLog.h"
#include "avrfutil.h"


namespace ShimLib
{


typedef struct _VLOG_GLOBAL_DATA {
    BOOL                    bLoggingDisabled;      // was logging disabled?
    WCHAR                   szSessionLog[MAX_PATH];
    WCHAR                   szProcessLog[MAX_PATH];
    RTL_CRITICAL_SECTION    csLogging;
} VLOG_GLOBAL_DATA, *PVLOG_GLOBAL_DATA;


PVLOG_GLOBAL_DATA g_pData = NULL;
HANDLE  g_hMap = NULL;                      // mapping handle for global data
BOOL    g_bVerifierLogInited = FALSE;   // have we been through the init sequence?
BOOL    g_bLoggingDisabled = TRUE;   // have we been through the init sequence?
BOOL    g_bLogBreakIn = FALSE;
CString g_strSessionLog;
CString g_strProcessLog;
RTL_CRITICAL_SECTION g_csLogging;
LPVOID  g_pDllBase;                 // our own DLL base
LPVOID  g_pDllEnd;                  // one past the DLL's last byte
DWORD   g_dwSizeOfImage;            // our own DLL image size


void
CheckForDebuggerBreakIn(
    void
    )
{
    /*
    UNICODE_STRING                  ustrKey;
    UNICODE_STRING                  ustrBreakIn;
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle;
    PKEY_VALUE_PARTIAL_INFORMATION  KeyValueInformation;
    ULONG                           KeyValueBuffer[256];
    ULONG                           KeyValueLength;

    RtlInitUnicodeString(&ustrKey, AV_KEY);
    RtlInitUnicodeString(&ustrBreakIn, AV_BREAKIN);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle,
                       GENERIC_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        return;
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)&KeyValueBuffer;

    Status = NtQueryValueKey(KeyHandle,
                             &ustrBreakIn,
                             KeyValuePartialInformation,
                             KeyValueInformation,
                             sizeof(KeyValueBuffer),
                             &KeyValueLength);

    NtClose(KeyHandle);

    if (!NT_SUCCESS(Status)) {
        return;
    }

    //
    // Check for the value type.
    //
    if (KeyValueInformation->Type != REG_DWORD) {
        return;
    }

    g_bLogBreakIn = (*(DWORD*)(&KeyValueInformation->Data) != 0);
    */
    WCHAR szExe[100];

    GetCurrentExeName(szExe, 100);

    g_bLogBreakIn = GetShimSettingDWORD(L"General", szExe, AV_BREAKIN, FALSE);
}

BOOL
GetModuleNameAndOffset(
    LPVOID  lpAddress,          // IN return address to search for
    LPWSTR  lpwszModuleName,    // OUT name of module that contains address
    DWORD   dwBufferChars,      // IN size in chars of module name buffer
    PDWORD  pdwOffset           // OUT offset within module
    )
{
    PPEB        Peb = NtCurrentPeb();
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    DWORD       i;
    BOOL        bRet = FALSE;

    if (!lpAddress || !lpwszModuleName || !pdwOffset) {
        return FALSE;
    }

    //
    // search for the module
    //

    LdrHead = &Peb->Ldr->InMemoryOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        //
        // Is this it?
        //
        if (lpAddress >= LdrEntry->DllBase && lpAddress < ((PBYTE)(LdrEntry->DllBase) + LdrEntry->SizeOfImage)) {

            wcsncpy(lpwszModuleName, LdrEntry->BaseDllName.Buffer, dwBufferChars);
            lpwszModuleName[dwBufferChars - 1] = 0;

            *pdwOffset = (DWORD)((PBYTE)lpAddress - (PBYTE)(LdrEntry->DllBase));
            bRet = TRUE;
            break;
        }

        LdrNext = LdrEntry->InMemoryOrderLinks.Flink;
    }

    return bRet;

}

void
GetCallingModule(
    LPWSTR szModule,
    DWORD  dwChars,
    PDWORD pdwOffset
    )
{
    PVOID   apRetAddresses[10];
    USHORT  unAddresses, i;
    BOOL    bFound = FALSE;
    ULONG   ulHash;

    //
    // On W2K, RtlCaptureStackBackTrace tries to dereference the fourth
    // argument (the returned hash) without ensuring that it's valid.
    // This causes on an access violation. On XP, the problem has been
    // fixed. We get a hash value back, but we'll never use it.
    //
    unAddresses = RtlCaptureStackBackTrace(3, 10, apRetAddresses, &ulHash);

    for (i = 0; i != unAddresses; i++) {
        PVOID pAddress = apRetAddresses[i];

        if (pAddress < g_pDllBase || pAddress >= g_pDllEnd) {
            bFound = GetModuleNameAndOffset(pAddress, szModule, dwChars, pdwOffset);
            if (bFound) {
                break;
            }
        }
    }

    if (!bFound) {
        if (pdwOffset) {
            *pdwOffset = 0;
        }
        if (szModule && dwChars > 10) {
            wcscpy(szModule, L"<unknown>");
        }
    }

    return;
}


/*++

 Function Description:

    Initializes the globals holding this module's base address and size

 Return Value:

    none.

 History:

    09/26/2001 dmunsil  Created

--*/
void
GetCurrentModuleInfo(void)
{
    PPEB        Peb = NtCurrentPeb();
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    DWORD       i;

    //
    // the base address is just the hInst
    //
    g_pDllBase = (LPVOID)g_hinstDll;

    //
    // now go find the size of the image by looking through the
    // loader's module list
    //

    LdrHead = &Peb->Ldr->InMemoryOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        //
        // Is this it?
        //
        if (LdrEntry->DllBase == g_pDllBase) {
            g_dwSizeOfImage = LdrEntry->SizeOfImage;
            g_pDllEnd = (PVOID)((PBYTE)g_pDllBase + g_dwSizeOfImage);
            break;
        }

        LdrNext = LdrEntry->InMemoryOrderLinks.Flink;
    }
}

/*++

 Function Description:

    Initializes the support for file logging.

 Return Value:

    TRUE if successful, FALSE if failed

 History:

    04/26/2001 dmunsil  Created
    09/27/2001 rparsons Converted to use NT calls

--*/
BOOL
InitVerifierLogSupport(void)
{
    CString strVLogPath;
    CString strProcessPath;
    CString strProcessName;
    CString strTemp;
    SYSTEMTIME LocalTime;
    CString strTime;
    CString strShared;
    char *szTemp;
    int nTemp;
    BOOL bAlreadyInited;
    BOOL bSuccess = FALSE;
    DWORD dwID;
    DWORD dwErr;
    NTSTATUS status;
    UNICODE_STRING strLogFile = {0};
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    //
    // if we've already been inited, get out
    //
    if (g_bVerifierLogInited) {
        return FALSE;
    }
    g_bVerifierLogInited = TRUE;

    CheckForDebuggerBreakIn();

    //
    // get the current module's base address and size
    //
    GetCurrentModuleInfo();

    //
    // first check for a shared memory block
    //
    dwID = GetCurrentProcessId();
    strShared.Format(L"VeriferLog_%08X", dwID);

    g_hMap = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, strShared.GetAnsi());
    if (g_hMap) {
        bAlreadyInited = TRUE;
    } else {
        bAlreadyInited = FALSE;
        g_hMap = CreateFileMapping(INVALID_HANDLE_VALUE,
                          NULL,
                          PAGE_READWRITE,
                          0,
                          sizeof(VLOG_GLOBAL_DATA),
                          strShared.GetAnsi());
    }

    if (!g_hMap) {
        DPF("VerifierLog", eDbgLevelError, "Cannot get shared global data.");
        g_bLoggingDisabled = TRUE;
        return FALSE;
    }

    g_pData = (PVLOG_GLOBAL_DATA)MapViewOfFile(g_hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);
    if (!g_pData) {
        DPF("VerifierLog", eDbgLevelError, "Cannot map shared global data.");
        g_bLoggingDisabled = TRUE;
        return FALSE;
    }

    if (bAlreadyInited) {
        if (g_pData->szProcessLog[0] == 0 || g_pData->szSessionLog[0] == 0) {
            g_bLoggingDisabled = TRUE;
            g_pData->bLoggingDisabled = TRUE;
            return FALSE;
        }
        g_bLoggingDisabled = g_pData->bLoggingDisabled;

        g_strSessionLog = g_pData->szSessionLog;
        g_strProcessLog = g_pData->szProcessLog;
        g_csLogging     = g_pData->csLogging;
        return TRUE;
    } else {
        //
        // just in case -- make sure these are NULL
        //
        ZeroMemory(g_pData, sizeof(VLOG_GLOBAL_DATA));
    }

    //
    // we need to init the file mapping, so temporarily disable logging, just in case.
    //
    g_pData->bLoggingDisabled = TRUE;

    //
    // init the CString objects and critical section
    //
    RtlInitializeCriticalSection(&g_csLogging);

    //
    // the verifier log will be located in %ALLUSERSPROFILE%\\Documents\\AppVerifierLogs
    //

    //
    // First, check that VLog exists; if not, we're not logging
    //
    strVLogPath = L"%ALLUSERSPROFILE%\\Documents\\AppVerifierLogs";
    strVLogPath.ExpandEnvironmentStringsW();

    if (GetFileAttributesW(strVLogPath.Get()) == -1) {
        DPF("VerifierLog", eDbgLevelInfo, "No log directory %ls. Logging disabled.", strVLogPath.Get());
        g_bLoggingDisabled = TRUE;
        return FALSE;
    }

    //
    // Next, check for the existence of session.log. If it's not there,
    // we're not logging
    //
    g_strSessionLog = strVLogPath;
    g_strSessionLog += L"\\session.log";
    if (GetFileAttributesW(g_strSessionLog.Get()) == -1) {
        DPF("VerifierLog", eDbgLevelInfo, "No session log file '%ls'. Logging disabled.", g_strSessionLog.Get());
        g_bLoggingDisabled = TRUE;
        return FALSE;
    }

    //
    // get the process log file name
    //
    if (strProcessPath.GetModuleFileNameW(NULL) == 0) {
        DPF("VerifierLog", eDbgLevelError, "Cannot get module file name.");
        g_bLoggingDisabled = TRUE;
        return FALSE;
    }

    //
    // strip out just the name minus path and extension
    //
    strProcessPath.SplitPath(NULL, NULL, &strProcessName, NULL);

    //
    // combine into log name, find first available
    //
    nTemp = 0;
    do {
        g_strProcessLog.Format(L"%ls\\%ls%d.%ls", strVLogPath.Get(), strProcessName.Get(), nTemp, L"log");
        nTemp++;
    } while (GetFileAttributesW(g_strProcessLog.Get()) != -1);

    //
    // Convert the path to the log file from DOS to NT.
    //
    bSuccess = RtlDosPathNameToNtPathName_U(g_strProcessLog.Get(), &strLogFile, NULL, NULL);

    if (!bSuccess) {
        DPF("VerifierLog",
            eDbgLevelError,
            "Failed to convert log file '%ls' to NT path",
            g_strProcessLog.Get());
        return FALSE;
    }

    //
    // Attempt to get a handle to our log file.
    // Truncate the file if it already exists.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          GENERIC_ALL | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN_IF,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    RtlFreeUnicodeString(&strLogFile);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "0x%X Failed to open log file %ls",
            status, g_strProcessLog.Get());
        g_bLoggingDisabled = TRUE;
        return FALSE;
    }

    NtClose(hFile);

    //
    // put the info in the session log and the process log
    //
    g_pData->bLoggingDisabled = FALSE;
    g_bLoggingDisabled = FALSE;

    //
    // I realize these pointers point to process-specific memory, but since
    // this mapping is only shared by this process, it seems safe.
    //
    wcscpy(g_pData->szProcessLog, g_strProcessLog);
    wcscpy(g_pData->szSessionLog, g_strSessionLog);

    GetLocalTime(&LocalTime);
    strTime.Format(L"%d/%d/%d %d:%02d:%02d",
                   LocalTime.wMonth,
                   LocalTime.wDay,
                   LocalTime.wYear,
                   LocalTime.wHour,
                   LocalTime.wMinute,
                   LocalTime.wSecond
                   );

    strTemp.Format(L"# LOG_BEGIN %ls '%ls' '%ls'", strTime.Get(),
              strProcessPath.Get(), g_strProcessLog.Get());
    szTemp = strTemp.GetAnsi();
    WriteToProcessLog(szTemp);
    WriteToSessionLog(szTemp);

    return TRUE;
}

/*++

 Function Description:

    clean up all our shared file resources

 History:

    04/26/2001 dmunsil  Created

--*/
void
ReleaseVerifierLogSupport(void)
{
    g_bLoggingDisabled = TRUE;
    if (g_pData) {
        UnmapViewOfFile(g_pData);
        g_pData = NULL;
        if (g_hMap) {
            CloseHandle(g_hMap);
            g_hMap = NULL;
        }
    }
}

/*++

 Function Description:

    Logs a problem that the verifier has found

 History:

    04/26/2001 dmunsil  Created

--*/

void
CVerifierLog::VLog(
    VLOG_LEVEL eLevel,
    DWORD dwLogNum,
    LPCSTR pszFmt,
    ...
    )
{
    char szT[1024];
    char *szTemp;
    int nLen;
    int nRemain;
    va_list arglist;
    DWORD dwOffset = 0;
    WCHAR szModule[256];

    if (g_bLoggingDisabled) {
        return;
    }

    GetCallingModule(szModule, 256, &dwOffset);

    _snprintf(szT, 1023, "| %ls %d | %d %ls %X'", m_strShimName.Get(), dwLogNum, eLevel,
              szModule, dwOffset);

    nLen = lstrlen(szT);
    szTemp = szT + nLen;
    nRemain = 1023 - nLen;

    if (nRemain > 0) {
        va_start(arglist, pszFmt);
        _vsnprintf(szTemp, nRemain, pszFmt, arglist);
        va_end(arglist);
    }

    szT[1023] = 0;
    WriteToProcessLog(szT);

    if (g_bLogBreakIn) {
        OutputDebugString(szT);
        DbgBreakPoint();
    }
}

/*++

 Function Description:

    Dumps the header for a shim that tells how many log entries it has.

 History:

    04/26/2001 dmunsil  Created

--*/
void
CVerifierLog::DumpShimHeader(void)
{
    char szT[1024];

    if (m_bHeaderDumped) {
        return;
    }

    _snprintf(szT, 1023, "# SHIM_BEGIN %ls %d", m_strShimName.Get(), m_dwEntries);
    WriteToProcessLog(szT);

    m_bHeaderDumped = TRUE;
}


/*++

 Function Description:

    Dumps into the log the text string associated with
    each log entry. These are dumped before logging begins, just to
    provide the strings necessary for the verifier UI to display them

 Return Value:

 History:

    04/26/2001 dmunsil  Created

--*/
void
CVerifierLog::DumpLogEntry(
    DWORD   dwLogNum,
    UINT    unResTitle,
    UINT    unResDescription,
    UINT    unResURL
    )
{
    WCHAR szRes[1024];
    char szLine[4096];

    if (g_bLoggingDisabled) {
        return;
    }

    //
    // dump the header, if necessary
    //
    DumpShimHeader();

    if (!VLogLoadString(g_hinstDll, unResTitle, szRes, 1024)) {
        DPF("VerifierLog", eDbgLevelError, "No string resource found for title.");
        szRes[0] = 0;
    }
    sprintf(szLine, "# LOGENTRY %ls %d '%ls", m_strShimName.Get(), dwLogNum, szRes);
    WriteToProcessLog(szLine);

    if (!VLogLoadString(g_hinstDll, unResDescription, szRes, 1024)) {
        DPF("VerifierLog", eDbgLevelWarning, "No string resource found for description.");
        szRes[0] = 0;
    }
    if (szRes[0]) {
        WriteToProcessLog("# DESCRIPTION BEGIN");
        sprintf(szLine, "%ls", szRes);
        WriteToProcessLog(szLine);
        WriteToProcessLog("# DESCRIPTION END");
    }

    if (!VLogLoadString(g_hinstDll, unResURL, szRes, 1024)) {
        DPF("VerifierLog", eDbgLevelWarning, "No string resource found for URL.");
        szRes[0] = 0;
    }

    if (szRes[0]) {
        sprintf(szLine, "# URL '%ls", szRes);
        WriteToProcessLog(szLine);
    }

}

/*++

 Function Description:

    Writes a line of text to the process log file

 Return Value:

 History:

    04/26/2001 dmunsil  Created
    09/21/2001 rparsons Converted to NT calls

--*/
void
WriteToProcessLog(
    LPCSTR szLine
    )
{
    int                 nLen = 0;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    LARGE_INTEGER       liOffset;
    UNICODE_STRING      strLogFile = {0};
    NTSTATUS            status;
    char                szNewLine[] = "\r\n";
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    BOOL                bSuccess = FALSE;

    if (g_bLoggingDisabled) {
        return;
    }

    //
    // Convert the path to the log file from DOS to NT.
    //
    bSuccess = RtlDosPathNameToNtPathName_U(g_strProcessLog.Get(), &strLogFile, NULL, NULL);

    if (!bSuccess) {
        DPF("VerifierLog",
            eDbgLevelError,
            "[WriteToProcessLog] Failed to convert log file '%ls' to NT path",
            g_strProcessLog.Get());
        return;
    }

    //
    // Attempt to get a handle to our log file.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          FILE_APPEND_DATA | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    RtlFreeUnicodeString(&strLogFile);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "[WriteToProcessLog] 0x%X Failed to open log file %ls",
            status, g_strProcessLog.Get());
        return;
    }

    //
    // Make sure we have no '\n' or '\r' at the end of the string.
    //
    nLen = lstrlen(szLine);

    while (nLen && (szLine[nLen - 1] == '\n' || szLine[nLen - 1] == '\r')) {
        nLen--;
    }

    //
    // Write the data out to the file.
    //
    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    //
    // Enter a critical section to ensure that log entries are in the proper order.
    //
    RtlEnterCriticalSection(&g_csLogging);

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)szLine,
                         (ULONG)nLen,
                         &liOffset,
                         NULL);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "[WriteToProcessLog] 0x%X Failed to make entry in log file",
            status);
        goto exit;
    }

    //
    // Now write a new line to the log file.
    //
    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    nLen = lstrlen(szNewLine);

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)szNewLine,
                         (ULONG)nLen,
                         &liOffset,
                         NULL);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "[WriteToProcessLog] 0x%X Failed to write new line to log file",
            status);
        goto exit;
    }

    //
    // Dump it out to the debugger on checked builds.
    //
#if DBG
    DebugPrintf("VerifierLog", eDbgLevelInfo, szLine);
    DebugPrintf("VerifierLog", eDbgLevelInfo, szNewLine);
#endif // DBG

exit:

    if (INVALID_HANDLE_VALUE != hFile) {
        NtClose(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    RtlLeaveCriticalSection(&g_csLogging);
}


/*++

 Function Description:

    Writes a line of text to the session log file

 Return Value:

 History:

    04/26/2001 dmunsil  Created
    09/21/2001 rparsons Converted to NT calls

--*/
void
WriteToSessionLog(
    LPCSTR szLine
    )
{
    int                 nLen = 0;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    LARGE_INTEGER       liOffset;
    UNICODE_STRING      strLogFile = {0};
    NTSTATUS            status;
    char                szNewLine[] = "\r\n";
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    BOOL                bSuccess = FALSE;

    if (g_bLoggingDisabled) {
        return;
    }

    //
    // Convert the path to the log file from DOS to NT.
    //
    bSuccess = RtlDosPathNameToNtPathName_U(g_strSessionLog.Get(), &strLogFile, NULL, NULL);

    if (!bSuccess) {
        DPF("VerifierLog",
            eDbgLevelError,
            "[WriteToSessionLog] Failed to convert log file '%ls' to NT path",
            g_strSessionLog.Get());
        return;
    }

    //
    // Attempt to get a handle to our log file.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          FILE_APPEND_DATA | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    RtlFreeUnicodeString(&strLogFile);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "[WriteToSessionLog] 0x%X Failed to open log file %ls",
            status, g_strProcessLog.Get());
        return;
    }

    //
    // Make sure we have no '\n' or '\r' at the end of the string.
    //
    nLen = lstrlen(szLine);

    while (nLen && (szLine[nLen - 1] == '\n' || szLine[nLen - 1] == '\r')) {
        nLen--;
    }

    //
    // Write the data out to the file.
    //
    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    //
    // Enter a critical section to ensure that log entries are in the proper order.
    //
    RtlEnterCriticalSection(&g_csLogging);

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)szLine,
                         (ULONG)nLen,
                         &liOffset,
                         NULL);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "[WriteToSessionLog] 0x%X Failed to make entry in log file",
            status);
        goto exit;
    }

    //
    // Now write a new line to the log file.
    //
    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    nLen = lstrlen(szNewLine);

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)szNewLine,
                         (ULONG)nLen,
                         &liOffset,
                         NULL);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "[WriteToSessionLog] 0x%X Failed to write new line to log file",
            status);
        goto exit;
    }

    //
    // Dump it out to the debugger on checked builds.
    //
#if DBG
    DebugPrintf("VerifierLog", eDbgLevelInfo, szLine);
    DebugPrintf("VerifierLog", eDbgLevelInfo, szNewLine);
#endif // DBG

exit:

    if (INVALID_HANDLE_VALUE != hFile) {
        NtClose(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    RtlLeaveCriticalSection(&g_csLogging);
}


int VLogLoadString(
    HMODULE   hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax)
{
    HRSRC hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    /*
     * Make sure the parms are valid.
     */
    if (lpBuffer == NULL) {
        DPF("VLogLoadString", eDbgLevelWarning, "LoadStringOrError: lpBuffer == NULL");
        return 0;
    }


    cch = 0;

    /*
     * String Tables are broken up into 16 string segments.  Find the segment
     * containing the string we are interested in.
     */
    if (hResInfo = FindResourceW(hModule, (LPWSTR)ULongToPtr( ((LONG)(((USHORT)wID >> 4) + 1)) ), (LPWSTR)RT_STRING)) {

        /*
         * Load that segment.
         */
        hStringSeg = LoadResource(hModule, hResInfo);

        /*
         * Lock the resource.
         */
        if (lpsz = (LPWSTR)LockResource(hStringSeg)) {

            /*
             * Move past the other strings in this segment.
             * (16 strings in a segment -> & 0x0F)
             */
            wID &= 0x0F;
            while (TRUE) {
                cch = *((WCHAR *)lpsz++);       // PASCAL like string count
                                                // first WCHAR is count of WCHARs
                if (wID-- == 0) break;
                lpsz += cch;                    // Step to start if next string
            }

            /*
             * chhBufferMax == 0 means return a pointer to the read-only resource buffer.
             */
            if (cchBufferMax == 0) {
                *(LPWSTR *)lpBuffer = lpsz;
            } else {

                /*
                 * Account for the NULL
                 */
                cchBufferMax--;

                /*
                 * Don't copy more than the max allowed.
                 */
                if (cch > cchBufferMax)
                    cch = cchBufferMax;

                /*
                 * Copy the string into the buffer.
                 */
                RtlCopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));
            }

            /*
             * Unlock resource, but don't free it - better performance this
             * way.
             */
            UnlockResource(hStringSeg);
        }
    }

    /*
     * Append a NULL.
     */
    if (cchBufferMax != 0) {
        lpBuffer[cch] = 0;
    }

    return cch;
}




};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\lua_redirectfs_cleanup.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   LUA_RedirectFS_Cleanup.cpp

 Abstract:

   Delete the redirected copies in every user's directory.

 Created:

   03/30/2001 maonis

 Modified:


--*/
#include "precomp.h"
#include "utils.h"

IMPLEMENT_SHIM_BEGIN(LUARedirectFS_Cleanup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(DeleteFileW)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryW)

APIHOOK_ENUM_END

HANDLE 
APIHOOK(FindFirstFileW)(
    LPCWSTR lpFileName,               
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    return LuacFindFirstFileW(lpFileName, lpFindFileData);
}

HANDLE 
APIHOOK(FindFirstFileA)(
    LPCSTR lpFileName,               
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    STRINGA2W wstrFileName(lpFileName);

    if (wstrFileName.m_fIsOutOfMemory)
    {
        return ORIGINAL_API(FindFirstFileA)(
            lpFileName,
            lpFindFileData);
    }

    HANDLE hFind;
    WIN32_FIND_DATAW fdw;
    
    if ((hFind = LuacFindFirstFileW(wstrFileName, &fdw)) != INVALID_HANDLE_VALUE)
    {
        FindDataW2A(&fdw, lpFindFileData);
    }

    return hFind;
}

DWORD 
APIHOOK(GetFileAttributesW)(
    LPCWSTR lpFileName
    )
{
    return LuacGetFileAttributesW(lpFileName);
}

DWORD 
APIHOOK(GetFileAttributesA)(
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ?
        ORIGINAL_API(GetFileAttributesA)(lpFileName) :
        LuacGetFileAttributesW(wstrFileName));
}

HANDLE 
APIHOOK(CreateFileW)(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    return LuacCreateFileW(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);
}

HANDLE 
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ?
    
        ORIGINAL_API(CreateFileA)(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile) :

        LuacCreateFileW(
            wstrFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile));
}

BOOL 
APIHOOK(DeleteFileW)(
    LPCWSTR lpFileName
    )
{
    return LuacDeleteFileW(lpFileName);
}

BOOL 
APIHOOK(DeleteFileA)(
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ? 
        ORIGINAL_API(DeleteFileA)(lpFileName) :
        LuacDeleteFileW(wstrFileName));
}

BOOL 
APIHOOK(RemoveDirectoryW)(
    LPCWSTR lpPathName
    )
{
    return LuacRemoveDirectoryW(lpPathName);
}

BOOL 
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpPathName
    )
{
    STRINGA2W wstrPathName(lpPathName);

    return (wstrPathName.m_fIsOutOfMemory ?
        ORIGINAL_API(RemoveDirectoryA)(lpPathName) :
        LuacRemoveDirectoryW(wstrPathName));
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) 
    {
        return LuacFSInit(COMMAND_LINE);
    }

    if (fdwReason == DLL_PROCESS_DETACH)
    {
        LuacFSCleanup();
    }

    return TRUE;
}

/*++

  Register hooked functions

--*/
HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesW)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\lua_redirectfs.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    LUA_RedirectFS.cpp

 Abstract:

    When the app gets access denied when trying to modify a file because 
    it doesn't have sufficient access rights, we redirect the file to a 
    location where the app does have enough access rights to do so. 
    
    This file mostly contains stubs. For implementation details on how the
    redirection is done see RedirectFS.cpp.
    
 Notes:

    This is a general purpose shim.

 History:

    02/12/2001 maonis  Created
    05/21/2001 maonis  Moved the bulk work into RedirectFS.cpp.

--*/

#include "precomp.h"
#include "utils.h"
#include "RedirectFS.h"

IMPLEMENT_SHIM_BEGIN(LUARedirectFS)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(CopyFileA)
    APIHOOK_ENUM_ENTRY(CopyFileW)
    APIHOOK_ENUM_ENTRY(OpenFile)
    APIHOOK_ENUM_ENTRY(_lopen)
    APIHOOK_ENUM_ENTRY(_lcreat)
    APIHOOK_ENUM_ENTRY(CreateDirectoryA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(SetFileAttributesA)
    APIHOOK_ENUM_ENTRY(SetFileAttributesW)
    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileW)
    APIHOOK_ENUM_ENTRY(FindNextFileA)
    APIHOOK_ENUM_ENTRY(FindNextFileW)
    APIHOOK_ENUM_ENTRY(FindClose)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(DeleteFileW)
    APIHOOK_ENUM_ENTRY(MoveFileA)
    APIHOOK_ENUM_ENTRY(MoveFileW)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryW)
    APIHOOK_ENUM_ENTRY(GetTempFileNameA)
    APIHOOK_ENUM_ENTRY(GetTempFileNameW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructW)

APIHOOK_ENUM_END

HANDLE 
APIHOOK(CreateFileW)(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    return LuaCreateFileW(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);
}

HANDLE 
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    STRINGA2W wstrFileName(lpFileName);
    return (wstrFileName.m_fIsOutOfMemory ?
    
        ORIGINAL_API(CreateFileA)(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile) :

        LuaCreateFileW(
            wstrFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile));
}

BOOL 
APIHOOK(CopyFileW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    return LuaCopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
}

BOOL 
APIHOOK(CopyFileA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    STRINGA2W wstrExistingFileName(lpExistingFileName);
    STRINGA2W wstrNewFileName(lpNewFileName);

    return ((wstrExistingFileName.m_fIsOutOfMemory || wstrNewFileName.m_fIsOutOfMemory) ?
        ORIGINAL_API(CopyFileA)(lpExistingFileName, lpNewFileName, bFailIfExists) :
        LuaCopyFileW(wstrExistingFileName, wstrNewFileName, bFailIfExists));
}

DWORD 
APIHOOK(GetFileAttributesW)(
    LPCWSTR lpFileName
    )
{
    return LuaGetFileAttributesW(lpFileName);
}

DWORD 
APIHOOK(GetFileAttributesA)(
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ?
        ORIGINAL_API(GetFileAttributesA)(lpFileName) :
        LuaGetFileAttributesW(wstrFileName));
}

BOOL 
APIHOOK(DeleteFileW)(
    LPCWSTR lpFileName
    )
{
    return LuaDeleteFileW(lpFileName);
}

BOOL 
APIHOOK(DeleteFileA)(
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ? 
        ORIGINAL_API(DeleteFileA)(lpFileName) :
        LuaDeleteFileW(wstrFileName));
}

//
// ----- Begin out-of-date API hooks -----
// This is taken from the nt base code with modifications to do the redirection.
// 

#ifndef BASE_OF_SHARE_MASK
#define BASE_OF_SHARE_MASK 0x00000070
#endif 

ULONG
BasepOfShareToWin32Share(
    IN ULONG OfShare
    )
{
    DWORD ShareMode;

    if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_DENY_READ ) {
        ShareMode = FILE_SHARE_WRITE;
        }
    else if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_DENY_WRITE ) {
        ShareMode = FILE_SHARE_READ;
        }
    else if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_DENY_NONE ) {
        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
        }
    else if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_EXCLUSIVE ) {
        ShareMode = 0;
        }
    else {
        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;;
        }
    return ShareMode;
}

ULONG BaseSetLastNTError(IN NTSTATUS Status)
{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}

UINT GetErrorMode()
{
    UINT PreviousMode;
    NTSTATUS Status;

    Status = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessDefaultHardErrorMode,
                (PVOID) &PreviousMode,
                sizeof(PreviousMode),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }

    if (PreviousMode & 1) {
        PreviousMode &= ~SEM_FAILCRITICALERRORS;
        }
    else {
        PreviousMode |= SEM_FAILCRITICALERRORS;
        }
    return PreviousMode;
}

BOOL
CheckAlternateLocation(
    LPCSTR pFileName,
    LPSTR pszPathName,
    DWORD* pdwPathLength
    )
{
    *pdwPathLength = 0;

    STRINGA2W wstrFileName(pFileName);
    if (wstrFileName.m_fIsOutOfMemory)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    REDIRECTFILE rf(wstrFileName);

    if (rf.m_pwszAlternateName)
    {
        DWORD cRedirectRoot = 
            (rf.m_fAllUser ? g_cRedirectRootAllUser : g_cRedirectRootPerUser);

        //
        // We need to convert the alternate path back to a normal path.
        //
        WCHAR chDrive = rf.m_pwszAlternateName[cRedirectRoot];
        LPWSTR pwszTempPathName = rf.m_pwszAlternateName + cRedirectRoot - 1;
        *pwszTempPathName = chDrive;
        *(pwszTempPathName + 1) = L':';

        DPF("RedirectFS", eDbgLevelInfo, 
            "[CheckAlternateLocation] Converted back to %S", pwszTempPathName);

        //
        // Convert back to ansi.
        //
        DWORD cLen = WideCharToMultiByte(
            CP_ACP, 
            0, 
            pwszTempPathName, 
            -1, 
            NULL, 
            0, 
            0, 
            0);

        if (cLen > OFS_MAXPATHNAME)
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[CheckAlternateLocation] File name requires %d bytes which is "
                "more than OFS_MAXPATHNAME", 
                cLen);

            return FALSE;
        }

        *pdwPathLength = WideCharToMultiByte(
            CP_ACP, 
            0, 
            pwszTempPathName, 
            -1, 
            pszPathName, 
            OFS_MAXPATHNAME, 
            0, 
            0);
    }

    return TRUE;
}

HFILE 
APIHOOK(OpenFile)(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[OpenFile] lpFileName=%s", lpFileName);

    BOOL b;
    FILETIME LastWriteTime;
    HANDLE hFile;
    DWORD DesiredAccess;
    DWORD ShareMode;
    DWORD CreateDisposition;
    DWORD PathLength;
    LPSTR FilePart;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    NTSTATUS Status;
    OFSTRUCT OriginalReOpenBuff;
    BOOL SearchFailed;

    SearchFailed = FALSE;
    OriginalReOpenBuff = *lpReOpenBuff;
    hFile = (HANDLE)-1;
    __try {
        SetLastError(0);

        if ( uStyle & OF_PARSE ) {
            PathLength = GetFullPathNameA(lpFileName,(OFS_MAXPATHNAME - 1),lpReOpenBuff->szPathName,&FilePart);
            if ( PathLength > (OFS_MAXPATHNAME - 1) ) {
                SetLastError(ERROR_INVALID_DATA);
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
            lpReOpenBuff->fFixedDisk = 1;
            lpReOpenBuff->nErrCode = 0;
            lpReOpenBuff->Reserved1 = 0;
            lpReOpenBuff->Reserved2 = 0;
            hFile = (HANDLE)0;
            goto finally_exit;
            }
        //
        // Compute Desired Access
        //

        if ( uStyle & OF_WRITE ) {
            DesiredAccess = GENERIC_WRITE;
            }
        else {
            DesiredAccess = GENERIC_READ;
            }
        if ( uStyle & OF_READWRITE ) {
            DesiredAccess |= (GENERIC_READ | GENERIC_WRITE);
            }

        //
        // Compute ShareMode
        //

        ShareMode = BasepOfShareToWin32Share(uStyle);

        //
        // Compute Create Disposition
        //

        CreateDisposition = OPEN_EXISTING;
        if ( uStyle & OF_CREATE ) {
            CreateDisposition = CREATE_ALWAYS;
            DesiredAccess = (GENERIC_READ | GENERIC_WRITE);
            }

        DPF("RedirectFS", eDbgLevelInfo,
            "[OpenFile] ShareMode=0x%08x; CreateDisposition=%d; DesiredAccess=0x%08x",
            ShareMode, CreateDisposition, DesiredAccess);

        //
        // if this is anything other than a re-open, fill the re-open buffer
        // with the full pathname for the file
        //

        if ( !(uStyle & OF_REOPEN) ) {
            PathLength = SearchPathA(NULL,lpFileName,NULL,OFS_MAXPATHNAME-1,lpReOpenBuff->szPathName,&FilePart);
  
            //
            // If we are trying to open an existing file we should also check the alternate location.
            //
            if ( (uStyle & OF_EXIST) && (PathLength == 0) && lpFileName)
            {
                if (!CheckAlternateLocation(lpFileName, lpReOpenBuff->szPathName, &PathLength)) 
                {
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                }
            }

            if ( PathLength > (OFS_MAXPATHNAME - 1) ) {
                SetLastError(ERROR_INVALID_DATA);
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            if ( PathLength == 0 ) {
                SearchFailed = TRUE;
                PathLength = GetFullPathNameA(lpFileName,(OFS_MAXPATHNAME - 1),lpReOpenBuff->szPathName,&FilePart);
                if ( !PathLength || PathLength > (OFS_MAXPATHNAME - 1) ) {
                    SetLastError(ERROR_INVALID_DATA);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }
                }
            }

        //
        // Special case, Delete, Exist, and Parse
        //

        if ( uStyle & OF_EXIST ) {
            if ( !(uStyle & OF_CREATE) ) {
                DWORD FileAttributes;

                if (SearchFailed) {
                    SetLastError(ERROR_FILE_NOT_FOUND);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }

                FileAttributes = APIHOOK(GetFileAttributesA)(lpReOpenBuff->szPathName);
                if ( FileAttributes == 0xffffffff ) {
                    SetLastError(ERROR_FILE_NOT_FOUND);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }
                if ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                    SetLastError(ERROR_ACCESS_DENIED);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }
                else {
                    hFile = (HANDLE)1;
                    lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
                    goto finally_exit;
                    }
                }
            }

        if ( uStyle & OF_DELETE ) {
            if ( APIHOOK(DeleteFileA)(lpReOpenBuff->szPathName) ) {
                lpReOpenBuff->nErrCode = 0;
                lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
                hFile = (HANDLE)1;
                goto finally_exit;
                }
            else {
                lpReOpenBuff->nErrCode = ERROR_FILE_NOT_FOUND;
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            }


        //
        // Open the file
        //

retry_open:
        hFile = APIHOOK(CreateFileA)(
                    lpReOpenBuff->szPathName,
                    DesiredAccess,
                    ShareMode,
                    NULL,
                    CreateDisposition,
                    0,
                    NULL
                    );

        if ( hFile == INVALID_HANDLE_VALUE ) {

            if ( uStyle & OF_PROMPT && !(GetErrorMode() & SEM_NOOPENFILEERRORBOX) ) {
                {
                    DWORD WinErrorStatus;
                    NTSTATUS st,HardErrorStatus;
                    ULONG_PTR ErrorParameter;
                    ULONG ErrorResponse;
                    ANSI_STRING AnsiString;
                    UNICODE_STRING UnicodeString;

                    WinErrorStatus = GetLastError();
                    if ( WinErrorStatus == ERROR_FILE_NOT_FOUND ) {
                        HardErrorStatus = STATUS_NO_SUCH_FILE;
                        }
                    else if ( WinErrorStatus == ERROR_PATH_NOT_FOUND ) {
                        HardErrorStatus = STATUS_OBJECT_PATH_NOT_FOUND;
                        }
                    else {
                        goto finally_exit;
                        }

                    //
                    // Hard error time
                    //

                    RtlInitAnsiString(&AnsiString,lpReOpenBuff->szPathName);
                    st = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
                    if ( !NT_SUCCESS(st) ) {
                        goto finally_exit;
                        }
                    ErrorParameter = (ULONG_PTR)&UnicodeString;

                    HardErrorStatus = NtRaiseHardError(
                                        HardErrorStatus | HARDERROR_OVERRIDE_ERRORMODE,
                                        1,
                                        1,
                                        &ErrorParameter,
                                        OptionRetryCancel,
                                        &ErrorResponse
                                        );
                    RtlFreeUnicodeString(&UnicodeString);
                    if ( NT_SUCCESS(HardErrorStatus) && ErrorResponse == ResponseRetry ) {
                        goto retry_open;
                        }
                    }
                }
            goto finally_exit;
            }

        if ( uStyle & OF_EXIST ) {
            CloseHandle(hFile);
            hFile = (HANDLE)1;
            lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
            goto finally_exit;
            }

        //
        // Determine if this is a hard disk.
        //

        Status = NtQueryVolumeInformationFile(
                    hFile,
                    &IoStatusBlock,
                    &DeviceInfo,
                    sizeof(DeviceInfo),
                    FileFsDeviceInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            CloseHandle(hFile);
            BaseSetLastNTError(Status);
            hFile = (HANDLE)-1;
            goto finally_exit;
            }
        switch ( DeviceInfo.DeviceType ) {

            case FILE_DEVICE_DISK:
            case FILE_DEVICE_DISK_FILE_SYSTEM:
                if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                    lpReOpenBuff->fFixedDisk = 0;
                    }
                else {
                    lpReOpenBuff->fFixedDisk = 1;
                    }
                break;

            default:
                lpReOpenBuff->fFixedDisk = 0;
                break;
            }

        //
        // Capture the last write time and save in the open struct.
        //

        b = GetFileTime(hFile,NULL,NULL,&LastWriteTime);

        if ( !b ) {
            lpReOpenBuff->Reserved1 = 0;
            lpReOpenBuff->Reserved2 = 0;
            }
        else {
            b = FileTimeToDosDateTime(
                    &LastWriteTime,
                    &lpReOpenBuff->Reserved1,
                    &lpReOpenBuff->Reserved2
                    );
            if ( !b ) {
                lpReOpenBuff->Reserved1 = 0;
                lpReOpenBuff->Reserved2 = 0;
                }
            }

        lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);

        //
        // The re-open buffer is completely filled in. Now
        // see if we are quitting (parsing), verifying, or
        // just returning with the file opened.
        //

        if ( uStyle & OF_VERIFY ) {
            if ( OriginalReOpenBuff.Reserved1 == lpReOpenBuff->Reserved1 &&
                 OriginalReOpenBuff.Reserved2 == lpReOpenBuff->Reserved2 &&
                 !strcmp(OriginalReOpenBuff.szPathName,lpReOpenBuff->szPathName) ) {
                goto finally_exit;
                }
            else {
                *lpReOpenBuff = OriginalReOpenBuff;
                CloseHandle(hFile);
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            }
finally_exit:;
        }
    __finally {
        lpReOpenBuff->nErrCode = (WORD)GetLastError();
        }

    return (HFILE)(ULONG_PTR)(hFile);
}

HFILE 
APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int iReadWrite
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[_lopen] lpPathName=%s", lpPathName);

    HANDLE hFile;
    DWORD DesiredAccess;
    DWORD ShareMode;
    DWORD CreateDisposition;

    SetLastError(0);
    //
    // Compute Desired Access
    //

    if ( iReadWrite & OF_WRITE ) {
        DesiredAccess = GENERIC_WRITE;
        }
    else {
        DesiredAccess = GENERIC_READ;
        }
    if ( iReadWrite & OF_READWRITE ) {
        DesiredAccess |= (GENERIC_READ | GENERIC_WRITE);
        }

    //
    // Compute ShareMode
    //

    ShareMode = BasepOfShareToWin32Share((DWORD)iReadWrite);

    CreateDisposition = OPEN_EXISTING;

    //
    // Open the file
    //

    hFile = APIHOOK(CreateFileA)(
                lpPathName,
                DesiredAccess,
                ShareMode,
                NULL,
                CreateDisposition,
                0,
                NULL
                );

    return (HFILE)(ULONG_PTR)(hFile);
}

#ifndef FILE_ATTRIBUTE_VALID_FLAGS
#define FILE_ATTRIBUTE_VALID_FLAGS      0x00003fb7
#endif

HFILE 
APIHOOK(_lcreat)(
    LPCSTR lpPathName,
    int iAttribute
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[_lcreat] lpPathName=%s", lpPathName);

    HANDLE hFile;
    DWORD DesiredAccess;
    DWORD ShareMode;
    DWORD CreateDisposition;

    SetLastError(0);

    //
    // Compute Desired Access
    //

    DesiredAccess = (GENERIC_READ | GENERIC_WRITE);

    ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;;

    //
    // Compute Create Disposition
    //

    CreateDisposition = CREATE_ALWAYS;

    //
    // Open the file
    //

    hFile = APIHOOK(CreateFileA)(
                lpPathName,
                DesiredAccess,
                ShareMode,
                NULL,
                CreateDisposition,
                iAttribute & FILE_ATTRIBUTE_VALID_FLAGS,
                NULL
                );

    return (HFILE)(ULONG_PTR)(hFile);
}

//
// ----- End out-of-date API hooks -----
// 

BOOL 
APIHOOK(CreateDirectoryW)(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    return LuaCreateDirectoryW(lpPathName, lpSecurityAttributes);
}

BOOL 
APIHOOK(CreateDirectoryA)(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    STRINGA2W wstrPathName(lpPathName);

    return (wstrPathName.m_fIsOutOfMemory ?
        ORIGINAL_API(CreateDirectoryA)(lpPathName, lpSecurityAttributes) :
        LuaCreateDirectoryW(wstrPathName, lpSecurityAttributes));
}

BOOL 
APIHOOK(SetFileAttributesW)(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
  )
{
    return LuaSetFileAttributesW(lpFileName, dwFileAttributes);
}

DWORD 
APIHOOK(SetFileAttributesA)(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
  )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ?
        ORIGINAL_API(SetFileAttributesA)(lpFileName, dwFileAttributes) :
        LuaSetFileAttributesW(wstrFileName, dwFileAttributes));
}

//
// Find*File stuff.
//

// This version is for FindFirstFile, we search for the last back slash
// to get the file name, then search for wildcards in the file name.
BOOL 
HasWildCards(
    LPCWSTR pwszName
    )
{
    LPWSTR pwszLastSlash = wcsrchr(pwszName, L'\\');

    LPCWSTR pwszStartSearching = pwszName;
    
    if (pwszLastSlash)
    {
        pwszStartSearching += pwszLastSlash - pwszName + 1;
    }

    for (; *pwszStartSearching; ++pwszStartSearching)
    {
        if (*pwszStartSearching == L'*' || *pwszStartSearching == L'?')
        {
            return TRUE;
        }
    }

    return FALSE;
}

VOID GetFullPath(
    LPCWSTR pwszFileName,
    LPWSTR pwszFullPath
    )
{
    wcscpy(pwszFullPath, pwszFileName);
    LPWSTR pwszLastSlash = wcsrchr(pwszFullPath, L'\\');

    if (pwszLastSlash)
    {
        *pwszLastSlash = L'\\';
        *++pwszLastSlash = L'\0';
    }
}

// This is for Find*File APIs.
BOOL IsFoundFileInRedirectList(
    LPCWSTR pwszFullPath,
    LPCWSTR pwszFileName
    )
{
    WCHAR wszFileName[MAX_PATH] = L"";
    
    DWORD cPathLen = wcslen(pwszFullPath);
    DWORD cFileLen = wcslen(pwszFileName);

    //
    // Make sure we don't overflow.
    //
    if (cPathLen + cFileLen + 1 > MAX_PATH)
    {
        return FALSE;
    }

    wcsncpy(wszFileName, pwszFullPath, cPathLen);
    wcsncpy(wszFileName + cPathLen, pwszFileName, cFileLen);
    wszFileName[cPathLen + cFileLen] = L'\0';

    return IsInRedirectList(wszFileName);
}

struct FINDFILE 
{
    FINDFILE* next;
    WCHAR wszFileName[MAX_PATH];
};

struct FINDFILEINFO 
{
    FINDFILEINFO() 
    { 
        InitializeCriticalSection(&m_Lock);
        files = NULL; 
        fCheckRedirectList = TRUE;
        fCheckDuplicate = FALSE;
    }

    ~FINDFILEINFO() 
    {
        Free(); 
        DeleteCriticalSection(&m_Lock);
    }

    void Lock()
    {
        EnterCriticalSection(&m_Lock);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_Lock);
    }

    VOID Free();
    BOOL AddFile(LPCWSTR pwszFileName, LPCWSTR pwszPerUserFileName = NULL);
    BOOL FindFile(LPCWSTR pwszFileName);
    VOID AddNewHandle(HANDLE hNew);

    FINDFILE* files;
    HANDLE hFirstFind; // The first handle,this is what the app will be using.
    HANDLE hCurrentFind;
    WCHAR wszFindName[MAX_PATH];
    WCHAR wszFullPath[MAX_PATH];
    LPWSTR pwszPerUserFileName;
    BOOL fCheckRedirectList;
    BOOL fCheckDuplicate;

    FINDFILEINFO* next;

private:

    CRITICAL_SECTION m_Lock;
};

class FINDFILELIST
{
public:
    
    VOID Init()
    {
        InitializeCriticalSection(&m_Lock);
    }

    void Lock()
    {
        EnterCriticalSection(&m_Lock);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_Lock);
    }

    BOOL Add(
        HANDLE hFind,
        LPCWSTR pwszFindName,
        LPCWSTR pwszFullPath,
        LPCWSTR pwszFirstFile,
        LPCWSTR pwszPerUserFileName);

    BOOL Release(HANDLE hFind);
    BOOL FindHandle(HANDLE hFind, FINDFILEINFO** ppFileInfo);

private:

    CRITICAL_SECTION m_Lock;
    FINDFILEINFO* fflist;
};

VOID FINDFILEINFO::Free()
{
    Lock();
    FINDFILE* pFile = files;

    while (pFile)
    {
        files = files->next;
        delete pFile;
        pFile = files;
    }

    Unlock();
}

// We add the new file to the end of the list.
BOOL 
FINDFILEINFO::AddFile(
    LPCWSTR pwszFileName,
    LPCWSTR pwszPerUserFileName
    )
{
    Lock();
    BOOL fRes = FALSE;
    FINDFILE* pNewFile = new FINDFILE;

    if (pNewFile)
    {
        wcsncpy(pNewFile->wszFileName, pwszFileName, MAX_PATH - 1);
        pNewFile->wszFileName[MAX_PATH - 1] = L'\0';
        
        if (pwszPerUserFileName)
        {
            DWORD cLen = wcslen(pwszPerUserFileName) + 1;
            this->pwszPerUserFileName = new WCHAR [cLen];

            if (this->pwszPerUserFileName)
            {
                ZeroMemory(this->pwszPerUserFileName, sizeof(WCHAR) * cLen);
                wcscpy(this->pwszPerUserFileName, pwszPerUserFileName);
            }
            else
            {
                goto CLEANUP;
            }
        }

        pNewFile->next = NULL;

        if (files)
        {
            for (FINDFILE* pFile = files; pFile->next; pFile = pFile->next);
            pFile->next = pNewFile;
        }
        else
        {
            files = pNewFile;
        }

        fRes = TRUE;
    }

CLEANUP: 

    if (!fRes)
    {
        delete pNewFile;
    }

    Unlock();
    return fRes;
}

BOOL 
FINDFILEINFO::FindFile(
    LPCWSTR pwszFileName
    )
{
    Lock();
    BOOL fRes = FALSE;
    FINDFILE* pFile = files;

    while (pFile)
    {
        if (!_wcsicmp(pFile->wszFileName, pwszFileName))
        {
            fRes = TRUE;
            break;
        }

        pFile = pFile->next;
    }

    Unlock();
    return fRes;
}

// If this is called, it means we have finished searching at the alternate
// location and started to search at the original location. hNew is the handle
// return by FindFirstFile at the original location.
VOID 
FINDFILEINFO::AddNewHandle(
    HANDLE hNew)
{
    Lock();
    ORIGINAL_API(FindClose)(hCurrentFind);
    hCurrentFind = hNew;

    //
    // If pwszPerUserFileName is not NULL, when we add a new handle, 
    // it means we are searching at the orignal location so we can
    // free pwszPerUserFileName.
    // 
    delete [] pwszPerUserFileName;
    pwszPerUserFileName = NULL;

    Unlock();
}

// We add the newest handle to the beginning of the list.
BOOL 
FINDFILELIST::Add(
    HANDLE hFind,
    LPCWSTR pwszFindName,
    LPCWSTR pwszFullPath,
    LPCWSTR pwszFirstFile,
    LPCWSTR pwszPerUserFileName
    )
{
    Lock();
    BOOL fRes = FALSE;
    FINDFILEINFO* pFileInfo = new FINDFILEINFO;

    if (pFileInfo)
    {
        pFileInfo->hFirstFind = hFind;
        pFileInfo->hCurrentFind = hFind; 

        wcsncpy(pFileInfo->wszFindName, pwszFindName, MAX_PATH - 1);
        pFileInfo->wszFindName[MAX_PATH - 1] = L'\0';
        wcsncpy(pFileInfo->wszFullPath, pwszFullPath, MAX_PATH - 1);
        pFileInfo->wszFullPath[MAX_PATH - 1] = L'\0';

        pFileInfo->files = NULL;
        pFileInfo->AddFile(pwszFirstFile, pwszPerUserFileName);
        pFileInfo->next = fflist;
        fflist = pFileInfo;
        fRes = TRUE;
    }

    Unlock();
    return fRes;
}

// Remove the info with this handle value from the list.
BOOL
FINDFILELIST::Release(
    HANDLE hFind
    )
{
    Lock();
    BOOL fRes = FALSE;
    FINDFILEINFO* pFileInfo = fflist;
    FINDFILEINFO* last = NULL;

    while (pFileInfo)
    {
        if (pFileInfo->hFirstFind == hFind)
        {
            if (last)
            {
                last->next = pFileInfo->next;
            }
            else
            {
                fflist = pFileInfo->next;
            }

            delete [] pFileInfo->pwszPerUserFileName;
            delete pFileInfo;
            fRes = TRUE;
            break;
        }

        last = pFileInfo;
        pFileInfo = pFileInfo->next;
    }

    Unlock();
    return fRes;
}

// Returns FALSE if hFind can't be found in the list.
BOOL 
FINDFILELIST::FindHandle(
    HANDLE hFind, 
    FINDFILEINFO** ppFileInfo
    )
{
    Lock();
    BOOL fRes = FALSE;
    FINDFILEINFO* pFileInfo = fflist;

    while (pFileInfo)
    {
        if (pFileInfo->hFirstFind == hFind)
        {
            fRes = TRUE;
            *ppFileInfo = pFileInfo;
            break;
        }

        pFileInfo = pFileInfo->next;
    }

    Unlock();
    return fRes;
}

FINDFILELIST g_fflist;

BOOL
FindFirstValidFile(
    BOOL fHasWildCards,
    BOOL fCheckRedirectList,
    LPCWSTR pwszFileName,
    LPCWSTR pwszFullPath,
    LPWIN32_FIND_DATAW lpFindFileData,
    HANDLE* phFind
    )
{
    BOOL fFound = FALSE;

    if ((*phFind = FindFirstFileW(pwszFileName, lpFindFileData)) != INVALID_HANDLE_VALUE)
    {
        if (fHasWildCards)
        {
            // If the file name does have wildcards, we need to check if the file 
            // found is in the redirect lists; if not, we need to discard it and 
            // search for the next file.
            do 
            {
                if (!fCheckRedirectList || 
                    IsFoundFileInRedirectList(pwszFullPath, lpFindFileData->cFileName))
                {             
                    fFound = TRUE;
                    break;
                }
            }
            while (FindNextFileW(*phFind, lpFindFileData));
        }
        else
        {
            fFound = TRUE;
        }
    }

    return fFound;
}
    

//
// Algorithm for finding files:
// We merge the info from the alternate directories and the original directory.
// We keep a list of the files in the alternate directory and when we search in 
// the original directory we exclude the files that are in the alternate directory.
//
// The behavior of FindFirstFile: 
// If the file name has a trailing slash, it'll return error 2.
// If you want to look for a directory, use c:\somedir;
// If you want to look at the contents of a dir, use c:\somedir\*
//

HANDLE 
APIHOOK(FindFirstFileW)(
    LPCWSTR lpFileName,               
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[FindFirstFileW] lpFileName=%S", lpFileName);

    if (!lpFileName || !*lpFileName || (lpFileName && lpFileName[0] && lpFileName[wcslen(lpFileName) - 1] == L'\\'))
    {
        return FindFirstFileW(lpFileName, lpFindFileData);
    }
 
    HANDLE hFind = INVALID_HANDLE_VALUE;
    BOOL fHasWildCards = HasWildCards(lpFileName);
    BOOL fFoundAtAlternate = FALSE;
    BOOL fHasSearchedAllUser = FALSE;
    
    REDIRECTFILE rf(lpFileName, OBJ_FILE_OR_DIR, !fHasWildCards);
    WCHAR wszFullPath[MAX_PATH];
    
    if (rf.m_pwszAlternateName)
    {
        if (fHasWildCards) 
        {
            rf.GetAlternateAllUser();
        }

        GetFullPath(rf.m_wszOriginalName, wszFullPath);

        // Try the all user redirect dir first.
        fFoundAtAlternate = FindFirstValidFile(
            fHasWildCards, 
            TRUE, // Check in the redirect list.
            rf.m_pwszAlternateName, 
            wszFullPath, 
            lpFindFileData, 
            &hFind);
        
        rf.GetAlternatePerUser();

        if (fHasWildCards && !fFoundAtAlternate)
        {
            fHasSearchedAllUser = TRUE;

            //
            // Now try the per user redirect dir if the file name has wildcards.
            //
            fFoundAtAlternate = FindFirstValidFile(
                fHasWildCards, 
                TRUE, // Check in the redirect list
                rf.m_pwszAlternateName, 
                wszFullPath, 
                lpFindFileData, 
                &hFind);
        }
    }
    
    if (fHasWildCards && fFoundAtAlternate)
    {
        // If the filename doesn't have wildcards, FindNextFile will return 
        // ERROR_NO_MORE_FILES, no need to add the info to the list.
        g_fflist.Add(
            hFind, 
            lpFileName, 
            wszFullPath, 
            lpFindFileData->cFileName, 
            (fHasSearchedAllUser ? NULL : rf.m_pwszAlternateName));
    }

    if (!fFoundAtAlternate)
    {
        hFind = FindFirstFileW(lpFileName, lpFindFileData);
    }

    if (hFind != INVALID_HANDLE_VALUE)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[FindFirstFileW] Found %S", lpFindFileData->cFileName);
    }

    return hFind;
}

HANDLE 
APIHOOK(FindFirstFileA)(
    LPCSTR lpFileName,               
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    STRINGA2W wstrFileName(lpFileName);
    if (wstrFileName.m_fIsOutOfMemory)
    {
        return ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);
    }

    HANDLE hFind;
    WIN32_FIND_DATAW fdw;
    
    if ((hFind = APIHOOK(FindFirstFileW)(wstrFileName, &fdw)) != INVALID_HANDLE_VALUE)
    {
        FindDataW2A(&fdw, lpFindFileData);
    }

    return hFind;
}

BOOL 
APIHOOK(FindNextFileW)(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[FindNextFileW] hFindFile=%d", hFindFile);

    BOOL fRes = FALSE;
    BOOL fHasNewHandle = FALSE;
    FINDFILEINFO* pFindInfo;

    if (g_fflist.FindHandle(hFindFile, &pFindInfo))
    {
        //
        // We need to use the current handle instead of the handle passed in
        // if they are different.
        //
        while (TRUE) 
        {
            fRes = FindNextFileW(pFindInfo->hCurrentFind, lpFindFileData);
            
            if (fRes)
            {
                //
                // Check to see if this file is valid.
                //
                if ((pFindInfo->fCheckRedirectList &&
                    !IsFoundFileInRedirectList(pFindInfo->wszFullPath, lpFindFileData->cFileName)) ||
                    (pFindInfo->fCheckDuplicate && 
                    pFindInfo->FindFile(lpFindFileData->cFileName)))
                {
                    continue;
                }

                //
                // If we get here, it means we got a valid file name, return.
                //
                pFindInfo->AddFile(lpFindFileData->cFileName);
                fRes = TRUE;
                break;
            }
            else
            {
                if (!pFindInfo->fCheckRedirectList)
                {
                    //
                    // If fCheckRedirectList is FALSE, it means we have been searching
                    // at the original location, bail out now.
                    //
                    break;
                }

                //
                // If pwszPerUserFileName is not NULL it means we haven't searched 
                // there yet, so search there.
                //
            retry:

                LPWSTR pwszFindName;
                
                if (pFindInfo->fCheckRedirectList && pFindInfo->pwszPerUserFileName)
                {
                    pwszFindName = pFindInfo->pwszPerUserFileName;
                }
                else
                {
                    pwszFindName = pFindInfo->wszFindName;
                    pFindInfo->fCheckRedirectList = FALSE;
                }

                pFindInfo->fCheckDuplicate = TRUE;

                HANDLE hNewFind;

                if (FindFirstValidFile(
                    TRUE, 
                    pFindInfo->fCheckRedirectList,
                    pwszFindName,
                    pFindInfo->wszFullPath,
                    lpFindFileData,
                    &hNewFind))
                {
                    //
                    // If we get a valid handle, we need to add this to the fileinfo.
                    //
                    pFindInfo->AddNewHandle(hNewFind);
                    pFindInfo->AddFile(lpFindFileData->cFileName);
                    fRes = TRUE;
                    break;
                }
                else
                {
                    if (pFindInfo->fCheckRedirectList)
                    {
                        pFindInfo->fCheckRedirectList = FALSE;
                        goto retry;
                    }

                    //
                    // If fCheckRedirect is FALSE, it means we ran out of
                    // options - we already searched at the original location.
                    // so nothing left to do.
                    //
                }
            }
        }
    }
    else
    {
        // If we can't find the handle in the list, it means we have been searching
        // at the original location so don't need to do anything special.
        fRes = FindNextFileW(hFindFile, lpFindFileData);
    }

    if (fRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[FindNextFileW] Found %S", lpFindFileData->cFileName);
    }
    return fRes;
}

BOOL 
APIHOOK(FindNextFileA)(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    BOOL fRes;
    WIN32_FIND_DATAW fdw;
    
    if (fRes = APIHOOK(FindNextFileW)(hFindFile, &fdw))
    {
        FindDataW2A(&fdw, lpFindFileData);
    }

    return fRes;;
}

BOOL 
APIHOOK(FindClose)(
    HANDLE hFindFile
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[FindClose] hFindFile=%d", hFindFile);

    // If we have a new handle, we need to close both handles.
    FINDFILEINFO* pFindInfo;

    if (g_fflist.FindHandle(hFindFile, &pFindInfo))
    {
        g_fflist.Release(hFindFile);
    }

    return FindClose(hFindFile);
}

BOOL 
APIHOOK(MoveFileW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    return LuaMoveFileW(lpExistingFileName, lpNewFileName);
}

BOOL 
APIHOOK(MoveFileA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    )
{
    STRINGA2W wstrExistingFileName(lpExistingFileName);
    STRINGA2W wstrNewFileName(lpNewFileName);

    return ((wstrExistingFileName.m_fIsOutOfMemory || wstrNewFileName.m_fIsOutOfMemory) ?
        ORIGINAL_API(MoveFileA)(lpExistingFileName, lpNewFileName) :
        LuaMoveFileW(wstrExistingFileName, wstrNewFileName));
}

BOOL 
APIHOOK(RemoveDirectoryW)(
    LPCWSTR lpPathName
    )
{
    return LuaRemoveDirectoryW(lpPathName);
}

BOOL 
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpPathName
    )
{
    STRINGA2W wstrPathName(lpPathName);

    return (wstrPathName.m_fIsOutOfMemory ?
        ORIGINAL_API(RemoveDirectoryA)(lpPathName) :
        LuaRemoveDirectoryW(wstrPathName));
}

UINT 
APIHOOK(GetTempFileNameW)(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
)
{
    return LuaGetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);
}

UINT 
APIHOOK(GetTempFileNameA)(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
)
{
    STRINGA2W wstrPathName(lpPathName);
    STRINGA2W wstrPrefixString(lpPrefixString);
    
    if (wstrPathName.m_fIsOutOfMemory || wstrPrefixString.m_fIsOutOfMemory)
    {
        return ORIGINAL_API(GetTempFileNameA)(
            lpPathName,
            lpPrefixString,
            uUnique,
            lpTempFileName);
    }

    WCHAR wstrTempFileName[MAX_PATH];
    UINT uiRes;
    
    if (uiRes = LuaGetTempFileNameW(
        wstrPathName,
        wstrPrefixString,
        uUnique,
        wstrTempFileName))
    {
        UnicodeToAnsi(wstrTempFileName, lpTempFileName);
    }

    return uiRes;
}

DWORD 
APIHOOK(GetPrivateProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    return LuaGetPrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpDefault,
        lpReturnedString,
        nSize,
        lpFileName);
}

DWORD 
APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrKeyName(lpKeyName);
    STRINGA2W wstrDefault(lpDefault);
    STRINGA2W wstrFileName(lpFileName);

    if (wstrAppName.m_fIsOutOfMemory || 
        wstrKeyName.m_fIsOutOfMemory || 
        wstrDefault.m_fIsOutOfMemory ||
        wstrFileName.m_fIsOutOfMemory)
    {
        return ORIGINAL_API(GetPrivateProfileStringA)(
            lpAppName,
            lpKeyName,
            lpDefault,
            lpReturnedString,
            nSize,
            lpFileName);
    }

    LPWSTR pwszReturnedString = new WCHAR [nSize];

    BOOL fRes = LuaGetPrivateProfileStringW(
        wstrAppName,
        wstrKeyName,
        wstrDefault,
        pwszReturnedString,
        nSize,
        wstrFileName);

    // Some apps lie - they pass in an nSize that's larger than their actual 
    // buffer size. We only convert at most the string length of characters 
    // so we don't overwrite their stack. Global Dialer does this.
    int cLen = WideCharToMultiByte(CP_ACP, 0, pwszReturnedString, -1, 0, 0, 0, 0);
    if (cLen > (int)nSize)
    {
        cLen = nSize; 
    }

    WideCharToMultiByte(CP_ACP, 0, pwszReturnedString, -1, lpReturnedString, cLen, 0, 0);
    delete [] pwszReturnedString;

    return fRes;
}

BOOL 
APIHOOK(WritePrivateProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    return LuaWritePrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpString,
        lpFileName);
}

BOOL 
APIHOOK(WritePrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrKeyName(lpKeyName);
    STRINGA2W wstrString(lpString);
    STRINGA2W wstrFileName(lpFileName);

    return ((wstrAppName.m_fIsOutOfMemory ||
        wstrKeyName.m_fIsOutOfMemory ||
        wstrString.m_fIsOutOfMemory ||
        wstrFileName.m_fIsOutOfMemory) ?

        ORIGINAL_API(WritePrivateProfileStringA)(
            lpAppName,
            lpKeyName,
            lpString,
            lpFileName) :

        LuaWritePrivateProfileStringW(
            wstrAppName,
            wstrKeyName,
            wstrString,
            wstrFileName));
}

DWORD 
APIHOOK(GetPrivateProfileSectionW)(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    return LuaGetPrivateProfileSectionW(
        lpAppName,
        lpReturnedString,
        nSize,
        lpFileName);
}

DWORD 
APIHOOK(GetPrivateProfileSectionA)(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrFileName(lpFileName);
    LPWSTR pwszReturnedString = new WCHAR [nSize];

    if (wstrAppName.m_fIsOutOfMemory || wstrFileName.m_fIsOutOfMemory || !pwszReturnedString)
    {
        delete [] pwszReturnedString;

        return ORIGINAL_API(GetPrivateProfileSectionA)(
            lpAppName,
            lpReturnedString,
            nSize,
            lpFileName);
    }

    DWORD dwRes = LuaGetPrivateProfileSectionW(
        wstrAppName,
        pwszReturnedString,
        nSize,
        wstrFileName);

    ConvertBufferForProfileAPIs(pwszReturnedString, nSize, lpReturnedString);
    delete [] pwszReturnedString;

    return dwRes;
}

BOOL 
APIHOOK(WritePrivateProfileSectionW)(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    return LuaWritePrivateProfileSectionW(
        lpAppName,
        lpString,
        lpFileName);
}

BOOL 
APIHOOK(WritePrivateProfileSectionA)(
    LPCSTR lpAppName,
    LPCSTR lpString,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrString(lpString);
    STRINGA2W wstrFileName(lpFileName);

    return ((wstrAppName.m_fIsOutOfMemory || 
        wstrString.m_fIsOutOfMemory || 
        wstrFileName.m_fIsOutOfMemory) ?

        ORIGINAL_API(WritePrivateProfileSectionA)(
            lpAppName,
            lpString,
            lpFileName) :

        LuaWritePrivateProfileSectionW(
            wstrAppName,
            wstrString,
            wstrFileName));
}

UINT 
APIHOOK(GetPrivateProfileIntW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault,
    LPCWSTR lpFileName
    )
{
    return LuaGetPrivateProfileIntW(
        lpAppName,
        lpKeyName,
        nDefault,
        lpFileName);
}

UINT 
APIHOOK(GetPrivateProfileIntA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrKeyName(lpKeyName);
    STRINGA2W wstrFileName(lpFileName);

    return ((wstrAppName.m_fIsOutOfMemory ||
        wstrKeyName.m_fIsOutOfMemory ||
        wstrFileName.m_fIsOutOfMemory) ?

        ORIGINAL_API(GetPrivateProfileIntA)(
            lpAppName,
            lpKeyName,
            nDefault,
            lpFileName) :

        LuaGetPrivateProfileIntW(
            wstrAppName,
            wstrKeyName,
            nDefault,
            wstrFileName));
}

DWORD 
APIHOOK(GetPrivateProfileSectionNamesW)(
    LPWSTR lpszReturnBuffer,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    return LuaGetPrivateProfileSectionNamesW(
        lpszReturnBuffer,
        nSize,
        lpFileName);
}

DWORD 
APIHOOK(GetPrivateProfileSectionNamesA)(
    LPSTR lpszReturnBuffer,
    DWORD nSize,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrFileName(lpFileName);
    LPWSTR pwszReturnBuffer = new WCHAR [nSize];

    if (wstrFileName.m_fIsOutOfMemory || !pwszReturnBuffer)
    {
        return ORIGINAL_API(GetPrivateProfileSectionNamesA)(
            lpszReturnBuffer,
            nSize,
            lpFileName);
    }

    DWORD dwRes = LuaGetPrivateProfileSectionNamesW(
        pwszReturnBuffer,
        nSize,
        wstrFileName);

    ConvertBufferForProfileAPIs(pwszReturnBuffer, nSize, lpszReturnBuffer);
    delete [] pwszReturnBuffer;

    return dwRes;
}

BOOL 
APIHOOK(GetPrivateProfileStructW)(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    )
{
    return LuaGetPrivateProfileStructW(
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile);
}

BOOL 
APIHOOK(GetPrivateProfileStructA)(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCSTR szFile
    )
{
    STRINGA2W wstrSection(lpszSection);
    STRINGA2W wstrKey(lpszKey);
    STRINGA2W wstrFile(szFile);

    return ((wstrSection.m_fIsOutOfMemory ||
        wstrKey.m_fIsOutOfMemory ||
        wstrFile.m_fIsOutOfMemory) ?

        ORIGINAL_API(GetPrivateProfileStructA)(
            lpszSection,
            lpszKey,
            lpStruct,
            uSizeStruct,
            szFile) :

        LuaGetPrivateProfileStructW(
            wstrSection,
            wstrKey,
            lpStruct,
            uSizeStruct,
            wstrFile));
}

BOOL 
APIHOOK(WritePrivateProfileStructW)(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    )
{
    return LuaWritePrivateProfileStructW(
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile);
}

BOOL 
APIHOOK(WritePrivateProfileStructA)(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCSTR szFile
    )
{
    STRINGA2W wstrSection(lpszSection);
    STRINGA2W wstrKey(lpszKey);
    STRINGA2W wstrFile(szFile);

    return ((wstrSection.m_fIsOutOfMemory ||
        wstrKey.m_fIsOutOfMemory ||
        wstrFile.m_fIsOutOfMemory) ?

        ORIGINAL_API(WritePrivateProfileStructA)(
            lpszSection,
            lpszKey,
            lpStruct,
            uSizeStruct,
            szFile) :

        LuaWritePrivateProfileStructW(
            wstrSection,
            wstrKey,
            lpStruct,
            uSizeStruct,
            wstrFile));
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_fflist.Init();

        return LuaFSInit(COMMAND_LINE);
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    if (LuaShouldApplyShim())
    {
        CALL_NOTIFY_FUNCTION

        APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
        APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
        APIHOOK_ENTRY(KERNEL32.DLL, CopyFileA)
        APIHOOK_ENTRY(KERNEL32.DLL, CopyFileW)
        APIHOOK_ENTRY(KERNEL32.DLL, OpenFile)
        APIHOOK_ENTRY(KERNEL32.DLL, _lopen)
        APIHOOK_ENTRY(KERNEL32.DLL, _lcreat)
        APIHOOK_ENTRY(KERNEL32.DLL, CreateDirectoryA)
        APIHOOK_ENTRY(KERNEL32.DLL, CreateDirectoryW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesW)
        APIHOOK_ENTRY(KERNEL32.DLL, SetFileAttributesA)
        APIHOOK_ENTRY(KERNEL32.DLL, SetFileAttributesW)
        APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
        APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileW)
        APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileA)
        APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileW)
        APIHOOK_ENTRY(KERNEL32.DLL, FindClose)
        APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileA)
        APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileW)
        APIHOOK_ENTRY(KERNEL32.DLL, MoveFileA)
        APIHOOK_ENTRY(KERNEL32.DLL, MoveFileW)
        APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryA)
        APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetTempFileNameA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetTempFileNameW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStringA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStringW)
        APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStringA)
        APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStringW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileSectionA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileSectionW)
        APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileSectionA)
        APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileSectionW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileIntA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileIntW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileSectionNamesA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileSectionNamesW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStructA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStructW)
        APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStructA)
        APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStructW)
    }

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lib\win9xpath.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    Win9xPath.cpp

 Abstract:

    Munge a path the same was as Win9x.

    Much of this code was copied from Win9x:
    \\redrum\slm\proj\win\src\CORE\win32\KERNEL\dirutil.c
    \\redrum\slm\proj\win\src\CORE\win32\KERNEL\fileopcc.c 


    Path changes:
    1.  Translate all / to \
    2.  Remove all . and .. from the path, also removes some spaces
        (This is really bad Win9x code)
    3.  Remove all spaces before a \, except spaces following a .
        ( "abc  \xyz" -> "abc\xyz" or ".  \xyz" -> ".  \xyz")

 Notes:

    None

 History:

    10/05/2000  robkenny    Created
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.

--*/


#include "Win9xPath.h"
#include "ShimLib.h"


namespace ShimLib
{

#define WHACK       L'\\'
#define SPACE       L' '
#define DOT         L'.'
#define QUESTION    L'.'
#define EOS         L'\0'

#define     chNetIni    L'\\'
#define     chDirSep    L'\\'
#define     chDirSep2   L'/'
#define     chRelDir    L'.'

#define IsWhackWhack( lpstr )               (lpstr[0] == WHACK && lpstr[1] == WHACK)
#define IsWhackWhackDotWhack( lpstr )       (lpstr[0] == WHACK && lpstr[1] == WHACK && lpstr[2] == DOT      && lpstr[3] == WHACK)
#define IsWhackWhackQuestionWhack( lpstr )  (lpstr[0] == WHACK && lpstr[1] == WHACK && lpstr[2] == QUESTION && lpstr[3] == WHACK)


#define CopySz wcscpy       // Must be safe for overlapping strings


/***    PchGetNetDir    - Validates a net drive spcification and returns
**                        a pointer to directory portion.
**
**  Synopsis
**      WCHAR * = PchGetNetDir (pchNetName)
**
**  Input:
**      pchNetName      - pointer to a string previously validated as
**                        the start of a net name (begins with \\)
**
**  Output:
**      returns pointer to the start of the directory portion of a net path
**
**  Errors:
**      returns NULL if the net name is invalid
**
**  Description:
**      This function takes a name starting with \\ and confirms that
**      it has one following \. It returns the position of the directory
**      portion. For the string
**
**               \\server\share[\path[\]]
**
**      it returns
**
**               [\path[\]]
*/

const WCHAR * PchGetNetDir (const WCHAR * pchNetName)
    {
    register const WCHAR * pch = pchNetName;

    // Skip starting slashes
    pch +=2;

    // Skip to first backslash
    for (;*pch != chNetIni; pch++) {
        if (*pch == EOS) {
            // No code required.
            return (NULL);
        }
    }

    pch++; // skip past 1st backslash

    // Skip to second backslash
    for (;(*pch != chDirSep) && (*pch != chDirSep2); pch++) {
       if (*pch == EOS) {
           // ok if share with no following \path
           return ((*(pch-1)==chNetIni) ? NULL : pch);
       }
    }
    return (pch);
}

/***    DwRemoveDots    - Remove any dots from a path name
**
**  Synopsis
**      DWORD DwRemoveDots (pchPath)
**
**  Input:
**      pchPath         - A path string
**
**
**  Output:
**      returns the number of double dot levels removed from front
**
**  Errors:
**      returns dwInvalid if invalid path
**
**  Description:
**      Removes ..\ and .\ sequences from a path string. The path
**      string should not include the root drive or net name portion.
**      The return value of is the number of levels removed from the
**      start of the string. Levels removed from inside the string
**      will not be returned. For example:
**
**          String          Result              Return
**
**          ..\..\dir1      dir1                2
**          dir1\..\dir2    dir2                0
**          dir1\..\..\dir2 dir2                1
**          .\dir1          dir1                0
**          dir1\.\dir2     dir1\dir2           0
**
**      A backslash at the start of the string will be ignored.
*/

DWORD DwRemoveDots (WCHAR * pchPath)
    {
    BOOL            fInside = FALSE;
    DWORD           cLevel = 0;
    DWORD           cBackup;
    register WCHAR * pchR;
    register WCHAR * pchL;

    // Check for invalid characters
//    if (!FFixPathChars(pchPath)) {
//        // No code required.
//        return dwInvalid;
//    }
//
    // Skip slashes
    for (; *pchPath == chDirSep; pchPath++)
        ;
    pchL = pchR = pchPath;

    // Loop through handling each directory part
    while (*pchR) {
        // This part starts with dot. Is it one or more?
        if (*pchR++ == chRelDir) {
            for (cBackup = 0; *pchR == chRelDir; cBackup++, pchR++)
                ;
            if (cBackup) {
                // More than one dot. Back up the left pointer.
                if ((*pchR != chDirSep) && (*pchR != EOS)) {
                    // we got a [.]+X (X != '\') might be an LFN
                    // process this as a name
                    goto name_processing;
                }
                // Doesn't advance for ending ..
                for (; *pchR == chDirSep; pchR++)
                    ;
                if (fInside) {
                    for (; cBackup; cBackup--) {
                        if (pchL <= pchPath) {
                            cLevel += cBackup;
                            fInside = FALSE;
                            break;
                        }
                        // Remove the previous part
                        for (pchL -= 2; *pchL != chDirSep; pchL--) {
                            if (pchL <= pchPath) {
                                fInside = FALSE;
                                pchL--;
                                break;
                            }
                        }
                        pchL++;
                    }
                } else {
                    cLevel += cBackup;
                }
                // Subtract ending backslash if not root
                if ((*pchR == EOS) && (pchL != pchPath))
                    pchL--;
                CopySz(pchL, pchR);
                pchR = pchL;
            } else {
                // This part starts with one dot. Throw it away.
                if (*pchR != chDirSep) {
                    // Special case "\." by converting it to ""
                    // unless it is a root, when it becomes "\".
                    if (*pchR == EOS) {
                        if (pchL == pchPath)
                            *(pchR-1) = EOS;   // root
                        else
                            *(pchR-2) = EOS;   // not root
                        return cLevel;
                    }
                    // we started with a '.' and then there was no '\'
                    // might be an LFN name
                    goto name_processing;
                }
                pchR++;
                CopySz(pchL, pchR);
                pchR = pchL;
            }
        } else {
name_processing:
            // This part is a name. Skip it.
            fInside = TRUE;
            for (; TRUE; pchR++) {
                if (*pchR == chDirSep) {
                    if (*(pchR-1) == chRelDir) {
                        // This name has one or more dots at the end.
                        // Remove the last dot (NT3.5 does this).
                        pchL = pchR-1;
                        CopySz(pchL, pchR);
                        pchR = pchL;    // point to chDirSep again
                    }
                    for (; *pchR == chDirSep; pchR++)
                        ;
                    break;
                } else if (*pchR == EOS) {
                    // Remove trailing dots.
                    // NB Can't fall off the beginning since the first WCHAR
                    // of the current path element was not chRelDir.
                    for (; *(pchR-1) == chRelDir; pchR--)
                        ;
                    // Overstore the first trailing dot, if there is one.
                    *pchR = EOS;
                    break;
                }
            }
            pchL = pchR;
        }
    }
    return cLevel;
}


// Get the Drive portion of this path,
// Either C: or \\server\disk format.
const WCHAR * GetDrivePortion(const WCHAR * uncorrected)
{
    if (uncorrected && uncorrected[0])
    {
        // Look for DOS style
        if (uncorrected[1] == ':')
        {
            uncorrected += 2;
        }
        // Look for UNC
        else if (IsWhackWhack(uncorrected))
        {
            const WCHAR * pchDir = PchGetNetDir(uncorrected);
            if (pchDir == NULL)
            {
                if (IsWhackWhackDotWhack(uncorrected) || IsWhackWhackQuestionWhack(uncorrected))
                {
                    uncorrected += 4;
                }
            }
            else
            {
                uncorrected = pchDir;
            }
        }
    }

    return uncorrected;
}

// Remove blank directory names "abc\   \def" -> "abc\def"
void RemovePreceedingBlanks(WCHAR * directoryPortion)
{
    if (directoryPortion == NULL || directoryPortion[0] == 0)
    {
        return;
    }

    WCHAR * blank = wcschr(directoryPortion, SPACE);
    while (blank != NULL)
    {
        // Find the end of the spaces
        WCHAR * blankEnd = blank;
        while (*blankEnd == SPACE && *blankEnd != WHACK)
        {
            ++blankEnd;
        }

        // Do not remove spaces *after* a period
        BOOL bPrevCharDot = (blank > directoryPortion) && (blank[-1] == DOT);
        if (bPrevCharDot)
        {
            blank = blankEnd;
            continue;
        }

        // If the the blank is a \ then we simply move the string down
        if (*blankEnd == WHACK)
        {
            BOOL bPrevCharWhack = blank[-1] == WHACK;

            // If the previous WCHAR is a \
            // we remove the \ at the end of the spaces as well
            if (bPrevCharWhack)
                blankEnd += 1;

            CopySz(blank, blankEnd);

            // Note: we don't change the value of blank,
            // since we moved all the data to it!
        }
        else
        {
            blank = blankEnd + 1;
        }
        
        // Keep on truckin'
        blank = wcschr(blank, SPACE);
    }
}


// Win9x performs some special process on path names,
// particularly they remove spaces before slashes.
WCHAR * W9xPathMassageW(const WCHAR * uncorrect)
{
    if (uncorrect == NULL)
        return NULL;

    // Make a buffer large enough for the resulting string
    WCHAR * correctBuffer = StringDuplicateW(uncorrect);
    if (!correctBuffer)
        return NULL;

    // Convert all '/' to '\'
    // Win9x allows //robkenny/d as a valid UNC name
    for (WCHAR * whack = correctBuffer; *whack; ++whack)
    {
        if (*whack == chDirSep2)
            *whack = chDirSep;
    }

    // We need to skip past the drive portion of the path
    WCHAR * directoryPortion = (WCHAR *)GetDrivePortion(correctBuffer);

    // Remove blank directory names "abc\   \def" -> "abc\def"
    // These are remove entirely rather than just removing the spaces,
    // because we could end up changing "\ \abc" -> "\\abc"
    RemovePreceedingBlanks(directoryPortion);

    // DwRemoveDots is used to remove all .\ and any ..\ in the middle of a path.
    DWORD dwUpDirs = DwRemoveDots(directoryPortion);
    if (dwUpDirs > 0)
    {
        // We need to add some ..\ to the front of the directoryPortion string
        // This is sorta wierd, removing the dots and adding them back again.
        // But the DwRemoveDots routine was copied strait from Win9x, and I
        // didn't want to change it in any way, as to preserve all peculiarities.
        // So we have to add back the leading parent directories that were removed.
        
        DWORD dwLen = (dwUpDirs * 3) + wcslen(correctBuffer) + 1;
        WCHAR * moreCorrectBuffer = (WCHAR*)malloc(dwLen * sizeof(WCHAR));
        if (moreCorrectBuffer)
        {
            moreCorrectBuffer[0] = 0;
            
            // Copy any drive portion
            wcsncpy(moreCorrectBuffer, correctBuffer, directoryPortion - correctBuffer);

            // add as many "..\" as were removed by DwRemoveDots
            while (dwUpDirs-- > 0)
            {
                wcscat(moreCorrectBuffer, L"..\\");
            }

            // finally the remainder of the string
            wcscat(moreCorrectBuffer, directoryPortion);

            delete correctBuffer;
            correctBuffer = moreCorrectBuffer;
        }
    }

    return correctBuffer;
}




};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\main.cpp ===
#include "precomp.h"
#include "ShimHookMacro.h"

DECLARE_SHIM(LUARedirectFS)
DECLARE_SHIM(LUARedirectReg)
DECLARE_SHIM(LUARedirectFS_Cleanup)
DECLARE_SHIM(LUARedirectReg_Cleanup)
DECLARE_SHIM(LUATrackFS)

VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPF("AcLua", eDbgLevelSpew, "LUA Shims initialized.");
            break;
    
        case DLL_PROCESS_DETACH:
            DPF("AcLua", eDbgLevelSpew, "LUA Shims uninitialized.");
            break;

        default:
            break;
    }
}

MULTISHIM_BEGIN()
    MULTISHIM_ENTRY(LUARedirectFS)
    MULTISHIM_ENTRY(LUARedirectReg)
    MULTISHIM_ENTRY(LUARedirectFS_Cleanup)
    MULTISHIM_ENTRY(LUARedirectReg_Cleanup)
    MULTISHIM_ENTRY(LUATrackFS)

    CALL_MULTISHIM_NOTIFY_FUNCTION()
MULTISHIM_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\precomp.h ===
#ifndef _LUA_PRECOMP_H_
#define _LUA_PRECOMP_H_

#include "ShimHook.h"
using namespace ShimLib;

#include "lua.h"

#endif // _LUA_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\lua_trackfs.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    LUA_TrackFS.cpp

 Abstract:
    Track the directories the app looks at and record them into a file.

 Notes:

    This is a general purpose shim.

 History:

    04/04/2001 maonis  Created

--*/

#include "precomp.h"
#include "utils.h"

HFILE LuatOpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle);
HFILE Luat_lopen(LPCSTR, int);
HFILE Luat_lcreat(LPCSTR, int);

class CTrackObject;
extern CTrackObject g_td;

IMPLEMENT_SHIM_BEGIN(LUATrackFS)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(CopyFileA)
    APIHOOK_ENUM_ENTRY(CopyFileW)
    APIHOOK_ENUM_ENTRY(OpenFile)
    APIHOOK_ENUM_ENTRY(_lopen)
    APIHOOK_ENUM_ENTRY(_lcreat)
    APIHOOK_ENUM_ENTRY(CreateDirectoryA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryW)
    APIHOOK_ENUM_ENTRY(SetFileAttributesA)
    APIHOOK_ENUM_ENTRY(SetFileAttributesW)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(DeleteFileW)
    APIHOOK_ENUM_ENTRY(MoveFileA)
    APIHOOK_ENUM_ENTRY(MoveFileW)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryW)
    APIHOOK_ENUM_ENTRY(GetTempFileNameA)
    APIHOOK_ENUM_ENTRY(GetTempFileNameW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructW)
    
APIHOOK_ENUM_END

HANDLE 
APIHOOK(CreateFileW)(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    return LuatCreateFileW(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);
}

HANDLE 
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ?
    
        ORIGINAL_API(CreateFileA)(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile) :

        LuatCreateFileW(
            wstrFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile));
}

BOOL 
APIHOOK(CopyFileW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    )
{    
    return LuatCopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
}

BOOL 
APIHOOK(CopyFileA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    STRINGA2W wstrExistingFileName(lpExistingFileName);
    STRINGA2W wstrNewFileName(lpNewFileName);

    return ((wstrExistingFileName.m_fIsOutOfMemory || wstrNewFileName.m_fIsOutOfMemory) ?
        ORIGINAL_API(CopyFileA)(lpExistingFileName, lpNewFileName, bFailIfExists) :
        LuatCopyFileW(wstrExistingFileName, wstrNewFileName, bFailIfExists));
}

HFILE 
APIHOOK(OpenFile)(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    )
{
    return LuatOpenFile(lpFileName, lpReOpenBuff, uStyle);
}

HFILE 
APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int iReadWrite
    )
{
    return Luat_lopen(lpPathName, iReadWrite);
}

HFILE 
APIHOOK(_lcreat)(
    LPCSTR lpPathName,
    int iAttribute
    )
{
    return Luat_lcreat(lpPathName, iAttribute);
}

BOOL 
APIHOOK(CreateDirectoryW)(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    return LuatCreateDirectoryW(lpPathName, lpSecurityAttributes);
}

BOOL 
APIHOOK(CreateDirectoryA)(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    STRINGA2W wstrPathName(lpPathName);

    return (wstrPathName.m_fIsOutOfMemory ?
        ORIGINAL_API(CreateDirectoryA)(lpPathName, lpSecurityAttributes) :
        LuatCreateDirectoryW(wstrPathName, lpSecurityAttributes));
}

BOOL 
APIHOOK(SetFileAttributesW)(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
  )
{
    return LuatSetFileAttributesW(lpFileName, dwFileAttributes);
}

BOOL 
APIHOOK(SetFileAttributesA)(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
  )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ?
        ORIGINAL_API(SetFileAttributesA)(lpFileName, dwFileAttributes) :
        LuatSetFileAttributesW(wstrFileName, dwFileAttributes));
}

BOOL 
APIHOOK(DeleteFileW)(
    LPCWSTR lpFileName
    )
{
    return LuatDeleteFileW(lpFileName);
}


BOOL 
APIHOOK(DeleteFileA)(
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ? 
        ORIGINAL_API(DeleteFileA)(lpFileName) :
        LuatDeleteFileW(wstrFileName));
}

BOOL 
APIHOOK(MoveFileW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    return LuatMoveFileW(lpExistingFileName, lpNewFileName);
}

BOOL 
APIHOOK(MoveFileA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    )
{
    STRINGA2W wstrExistingFileName(lpExistingFileName);
    STRINGA2W wstrNewFileName(lpNewFileName);

    return ((wstrExistingFileName.m_fIsOutOfMemory || wstrNewFileName.m_fIsOutOfMemory) ?
        ORIGINAL_API(MoveFileA)(lpExistingFileName, lpNewFileName) :
        LuatMoveFileW(wstrExistingFileName, wstrNewFileName));
}

BOOL 
APIHOOK(RemoveDirectoryW)(
    LPCWSTR lpPathName
    )
{
    return LuatRemoveDirectoryW(lpPathName);
}


BOOL 
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpPathName
    )
{
    STRINGA2W wstrPathName(lpPathName);

    return (wstrPathName.m_fIsOutOfMemory ?
        ORIGINAL_API(RemoveDirectoryA)(lpPathName) :
        LuatRemoveDirectoryW(wstrPathName));
}

UINT 
APIHOOK(GetTempFileNameW)(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
)
{
    return LuatGetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);
}

UINT 
APIHOOK(GetTempFileNameA)(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
)
{
    STRINGA2W wstrPathName(lpPathName);
    STRINGA2W wstrPrefixString(lpPrefixString);

    if (wstrPathName.m_fIsOutOfMemory || wstrPrefixString.m_fIsOutOfMemory)
    {
        return ORIGINAL_API(GetTempFileNameA)(
            lpPathName,
            lpPrefixString,
            uUnique,
            lpTempFileName);
    }

    WCHAR wstrTempFileName[MAX_PATH];
    UINT uiRes;
    
    if (uiRes = LuatGetTempFileNameW(
        wstrPathName,
        wstrPrefixString,
        uUnique,
        wstrTempFileName))
    {
        UnicodeToAnsi(wstrTempFileName, lpTempFileName);
    }

    return uiRes;
}

BOOL 
APIHOOK(WritePrivateProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    return LuatWritePrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpString,
        lpFileName);
}

BOOL 
APIHOOK(WritePrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrKeyName(lpKeyName);
    STRINGA2W wstrString(lpString);
    STRINGA2W wstrFileName(lpFileName);

    return ((wstrAppName.m_fIsOutOfMemory ||
        wstrKeyName.m_fIsOutOfMemory ||
        wstrString.m_fIsOutOfMemory ||
        wstrFileName.m_fIsOutOfMemory) ?

        ORIGINAL_API(WritePrivateProfileStringA)(
            lpAppName,
            lpKeyName,
            lpString,
            lpFileName) :

        LuatWritePrivateProfileStringW(
            wstrAppName,
            wstrKeyName,
            wstrString,
            wstrFileName));
}

BOOL 
APIHOOK(WritePrivateProfileSectionW)(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    return LuatWritePrivateProfileSectionW(
        lpAppName,
        lpString,
        lpFileName);
}

BOOL 
APIHOOK(WritePrivateProfileSectionA)(
    LPCSTR lpAppName,
    LPCSTR lpString,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrString(lpString);
    STRINGA2W wstrFileName(lpFileName);

    return ((wstrAppName.m_fIsOutOfMemory || 
        wstrString.m_fIsOutOfMemory || 
        wstrFileName.m_fIsOutOfMemory) ?

        ORIGINAL_API(WritePrivateProfileSectionA)(
            lpAppName,
            lpString,
            lpFileName) :

        LuatWritePrivateProfileSectionW(
            wstrAppName,
            wstrString,
            wstrFileName));
}

BOOL 
APIHOOK(WritePrivateProfileStructW)(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    )
{
    return LuatWritePrivateProfileStructW(
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile);
}

BOOL 
APIHOOK(WritePrivateProfileStructA)(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCSTR szFile
    )
{
    STRINGA2W wstrSection(lpszSection);
    STRINGA2W wstrKey(lpszKey);
    STRINGA2W wstrFile(szFile);

    return ((wstrSection.m_fIsOutOfMemory ||
        wstrKey.m_fIsOutOfMemory ||
        wstrFile.m_fIsOutOfMemory) ?

        ORIGINAL_API(WritePrivateProfileStructA)(
            lpszSection,
            lpszKey,
            lpStruct,
            uSizeStruct,
            szFile) :

        LuatWritePrivateProfileStructW(
            wstrSection,
            wstrKey,
            lpStruct,
            uSizeStruct,
            wstrFile));
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return LuatFSInit();
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        LuatFSCleanup();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, OpenFile)
    APIHOOK_ENTRY(KERNEL32.DLL, _lopen)
    APIHOOK_ENTRY(KERNEL32.DLL, _lcreat)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL, SetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL, SetFileAttributesW)
    APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, MoveFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, MoveFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetTempFileNameA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetTempFileNameW)
    APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStringW)
    APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStructA)
    APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStructW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\lua_redirectreg.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    LUA_RedirectReg.cpp

 Abstract:
    Redirect the reg keys to current user hive when the app needs to 
    write to them but doesn't have enough access rights.

 Notes:

    This is a general purpose shim.

 History:

    02/14/2001 maonis  Created
    05/30/2001 maonis  Moved the bulk into lua.dll.

--*/

#include "precomp.h"
#include "utils.h"

LONG LuaRegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
LONG LuaRegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); 
LONG LuaRegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult); 
LONG LuaRegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
LONG LuaRegQueryValueA(HKEY hkey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData);
LONG LuaRegQueryValueExA(HKEY hkey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
LONG LuaRegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData);
LONG LuaRegSetValueExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, DWORD dwType, CONST BYTE *lpData, DWORD cbData);
LONG LuaRegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
LONG LuaRegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cbName);
LONG LuaRegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
LONG LuaRegDeleteKeyA(HKEY hKey,LPCSTR lpSubKey);

IMPLEMENT_SHIM_BEGIN(LUARedirectReg)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExW)
    APIHOOK_ENUM_ENTRY(RegCloseKey)
    APIHOOK_ENUM_ENTRY(RegQueryValueA)
    APIHOOK_ENUM_ENTRY(RegQueryValueW)
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)
    APIHOOK_ENUM_ENTRY(RegSetValueA)
    APIHOOK_ENUM_ENTRY(RegSetValueW)
    APIHOOK_ENUM_ENTRY(RegSetValueExA)
    APIHOOK_ENUM_ENTRY(RegSetValueExW)
    APIHOOK_ENUM_ENTRY(RegEnumValueA)
    APIHOOK_ENUM_ENTRY(RegEnumValueW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExW)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyA)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyW)

APIHOOK_ENUM_END

LONG 
APIHOOK(RegOpenKeyA)(
    HKEY hKey,         
    LPSTR lpSubKey,  
    PHKEY phkResult
    )
{
    return LuaRegOpenKeyA(
        hKey, 
        lpSubKey, 
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyW)(
    HKEY hKey,         
    LPWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    return LuaRegOpenKeyW(
        hKey, 
        lpSubKey, 
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyExA)(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    return LuaRegOpenKeyExA(
        hKey, 
        lpSubKey,
        ulOptions,
        samDesired, 
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyExW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    return LuaRegOpenKeyExW(
        hKey, 
        lpSubKey, 
        ulOptions,
        samDesired, 
        phkResult);
}

LONG 
APIHOOK(RegCreateKeyA)(
    HKEY hKey,         
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    return LuaRegCreateKeyA(
        hKey, 
        lpSubKey, 
        phkResult);
}

LONG 
APIHOOK(RegCreateKeyW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    return LuaRegCreateKeyW(
        hKey, 
        lpSubKey, 
        phkResult);
}

LONG 
APIHOOK(RegCreateKeyExA)(
    HKEY hKey,                
    LPCSTR lpSubKey,         
    DWORD Reserved,           
    LPSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    return LuaRegCreateKeyExA(
        hKey, 
        lpSubKey,
        Reserved,
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition);
}

LONG 
APIHOOK(RegCreateKeyExW)(
    HKEY hKey,                
    LPCWSTR lpSubKey,         
    DWORD Reserved,           
    LPWSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    return LuaRegCreateKeyExW(
        hKey, 
        lpSubKey,
        Reserved,
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition);
}

LONG 
APIHOOK(RegQueryValueA)(
    HKEY    hKey,
    LPCSTR  lpSubKey,
    LPSTR lpValue,
    PLONG lpcbValue
    )
{
    return LuaRegQueryValueA(
        hKey,
        lpSubKey,
        lpValue,
        lpcbValue);
}

LONG 
APIHOOK(RegQueryValueW)(
    HKEY    hKey,
    LPCWSTR  lpSubKey,
    LPWSTR  lpValue,
    PLONG lpcbValue
    )
{
    return LuaRegQueryValueW(
        hKey,
        lpSubKey,
        lpValue,
        lpcbValue);
}

LONG 
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,
    LPCSTR   lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    return LuaRegQueryValueExA(
        hKey,
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG 
APIHOOK(RegQueryValueExW)(
    HKEY    hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    return LuaRegQueryValueExW(
        hKey,
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG      
APIHOOK(RegSetValueA)(
    HKEY hKey, 
    LPCSTR lpSubKey, 
    DWORD dwType, 
    LPCSTR lpData, 
    DWORD cbData
    )
{
    return LuaRegSetValueA(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG      
APIHOOK(RegSetValueW)(
    HKEY hKey, 
    LPCWSTR lpSubKey, 
    DWORD dwType, 
    LPCWSTR lpData, 
    DWORD cbData
    )
{
    return LuaRegSetValueW(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG      
APIHOOK(RegSetValueExA)(
    HKEY hKey, 
    LPCSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    return LuaRegSetValueExA(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG      
APIHOOK(RegSetValueExW)(
    HKEY hKey, 
    LPCTSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    return LuaRegSetValueExW(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG 
APIHOOK(RegEnumValueA)(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    return LuaRegEnumValueA(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,      
        lpcbData);
}

LONG 
APIHOOK(RegEnumValueW)(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    return LuaRegEnumValueW(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,      
        lpcbData);
}

LONG 
APIHOOK(RegEnumKeyA)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPSTR lpName, 
    DWORD cbName  
    )
{
    return LuaRegEnumKeyA(
        hKey,
        dwIndex,
        lpName,
        cbName);
}

LONG 
APIHOOK(RegEnumKeyW)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPWSTR lpName, 
    DWORD cbName  
    )
{
    return LuaRegEnumKeyW(
        hKey,
        dwIndex,
        lpName,
        cbName);
}

LONG 
APIHOOK(RegEnumKeyExA)(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    return LuaRegEnumKeyExA(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG 
APIHOOK(RegEnumKeyExW)(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    return LuaRegEnumKeyExW(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG 
APIHOOK(RegCloseKey)(HKEY hKey)
{
    return LuaRegCloseKey(hKey);
}

LONG      
APIHOOK(RegDeleteKeyA)(
    HKEY hKey, 
    LPCSTR lpSubKey
    )
{
    return LuaRegDeleteKeyA(hKey, lpSubKey);
}

LONG      
APIHOOK(RegDeleteKeyW)(
    HKEY hKey, 
    LPCWSTR lpSubKey
    )
{
    return LuaRegDeleteKeyW(hKey, lpSubKey);
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return LuaRegInit();
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    if (LuaShouldApplyShim())
    {
        CALL_NOTIFY_FUNCTION

        APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegCloseKey)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumValueA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumValueW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyW)
    }

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\lua_redirectreg_cleanup.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   LUA_RedirectReg_Cleanup.cpp

 Abstract:

   Delete the redirected keys from the original location and every user's 
   hive.

 Created:

   03/21/2001 maonis

 Modified:


--*/
#include "precomp.h"
#include "utils.h"

IMPLEMENT_SHIM_BEGIN(LUARedirectReg_Cleanup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExW)
    APIHOOK_ENUM_ENTRY(RegCloseKey)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyA)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyW)

APIHOOK_ENUM_END

LONG 
APIHOOK(RegOpenKeyExW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    return LuacRegOpenKeyExW(
        hKey,         
        lpSubKey,  
        ulOptions,   
        samDesired, 
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyExA)(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    WCHAR wszSubKey[MAX_PATH] = L"";
    AnsiToUnicode(lpSubKey, wszSubKey);

    return LuacRegOpenKeyExW(
        hKey,
        wszSubKey,
        ulOptions,
        samDesired,
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyW)(
    HKEY hKey,         
    LPWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    return LuacRegOpenKeyExW(
        hKey,
        lpSubKey,
        0, 
        MAXIMUM_ALLOWED, 
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyA)(
    HKEY hKey,         
    LPSTR lpSubKey,  
    PHKEY phkResult
    )
{
    return APIHOOK(RegOpenKeyExA)(
        hKey,
        lpSubKey,
        0, 
        MAXIMUM_ALLOWED, 
        phkResult);
}

LONG 
APIHOOK(RegEnumKeyExW)(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{   
    return LuacRegEnumKeyExW(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG 
APIHOOK(RegEnumKeyExA)(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    WCHAR wszName[MAX_PATH];
    DWORD dwName = MAX_PATH;

    LONG lRes = LuacRegEnumKeyExW(
        hKey,
        dwIndex,
        wszName,
        &dwName,
        lpReserved,
        NULL,
        NULL,
        lpftLastWriteTime);

    if (lRes == ERROR_SUCCESS)
    {
        // Convert the values back to ansi.
        DWORD dwByte = WideCharToMultiByte(
            CP_ACP, 
            0, 
            wszName, 
            dwName, 
            lpName, 
            *lpcbName, 
            0, 
            0);
        
        lpName[dwByte] = '\0'; 
        *lpcbName = dwByte;
        if (!dwByte)
        {
            lRes = GetLastError();
            
            // Generate a registry error code.
            if (lRes == ERROR_INSUFFICIENT_BUFFER)
            {
                lRes = ERROR_MORE_DATA;
            }
        }        
    }

    return lRes;   
}

LONG 
APIHOOK(RegEnumKeyW)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPWSTR lpName, 
    DWORD cbName  
    )
{
    return LuacRegEnumKeyExW(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL);
}

LONG 
APIHOOK(RegEnumKeyA)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPSTR lpName, 
    DWORD cbName  
    )
{
    return APIHOOK(RegEnumKeyExA)(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL);
}

LONG 
APIHOOK(RegCloseKey)(HKEY hKey)
{
    return LuacRegCloseKey(hKey);
}

LONG      
APIHOOK(RegDeleteKeyW)(
    HKEY hKey, 
    LPCWSTR lpSubKey
    )
{
    return LuacRegDeleteKeyW(hKey, lpSubKey);
}

LONG      
APIHOOK(RegDeleteKeyA)(
    HKEY hKey, 
    LPCSTR lpSubKey
    )
{
    WCHAR wszSubKey[MAX_PATH] = L"";
    AnsiToUnicode(lpSubKey, wszSubKey);

    return LuacRegDeleteKeyW(hKey, wszSubKey);
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) 
    {
        return LuacRegInit();
    }

    if (fdwReason == DLL_PROCESS_DETACH)
    {
        LuacRegCleanup();
    }

    return TRUE;
}

/*++

  Register hooked functions

--*/
HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCloseKey)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\redirectfs.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RedirectFS.h

 Notes:

    This is a general purpose shim.

 History:

    02/12/2001 maonis  Created

--*/

#ifndef _LUA_REDIRECT_FS_H_
#define _LUA_REDIRECT_FS_H_

#include <sfc.h>

extern DWORD g_cRedirectRootAllUser;
extern DWORD g_cRedirectRootPerUser;

//
// Helper functions.
// 

// Object type
enum EOBJTYPE
{
    OBJ_FILE = 1,
    OBJ_DIR = 2,
    // When GetFileAttributes/SetFileAttributes or FindFirstFile 
    // is called, we are not sure if the object is a file or a directory
    // so we need to search in both lists.
    OBJ_FILE_OR_DIR = 3
};

// File system type
enum EFSTYPE
{
    FS_UNINIT = 0,
    FS_NTFS,
    FS_NON_NTFS
};

BOOL IsInRedirectList(LPCWSTR pwszObject, BOOL* pfAllUser = NULL);
BOOL IsNTFSW(LPCWSTR pwszFile);
LPWSTR MassageName(LPWSTR pwszFullPath);

inline BOOL
IsNotFileW(LPCWSTR pwszName)
{
    UINT cLen = wcslen(pwszName);
    
    // If the user specify a trailing slash, we never need to do anything.
    // because it'll never return ACCESS_DENIED.
    if (pwszName[cLen - 1] == L'\\')
    {
        return TRUE;
    }

    return FALSE;
}

// Check if a file is under SFP.
inline BOOL 
IsFileSFPedW(LPCWSTR pszFile)
{
    return SfcIsFileProtected(NULL, pszFile);
}

// Some apps (actually one so far) use the \\?\ notation when they call
// CreateFile for the file name. For now we simply ignore that part.
// When the app uses this notation they could pass in a file name that's 
// longer than MAX_PATH - we might need to handle this later.
inline LPCWSTR 
ConvertToNormalPath(LPCWSTR pwszPath)
{
    if (pwszPath)
    {
        if (!wcsncmp(pwszPath, FILE_NAME_PREFIX, FILE_NAME_PREFIX_LEN))
        {
            pwszPath = pwszPath + FILE_NAME_PREFIX_LEN;
        }
    }

    return pwszPath;
}

struct REDIRECTFILE
{
    REDIRECTFILE(LPCWSTR pwszOriginalName, EOBJTYPE eObjType = OBJ_FILE, BOOL fCheckRedirectList = TRUE)
    {
        // Before we get the full path there's a special case to check for.
        // If we have a console handle say CONIN$, we are going to get 
        // currentdirectory\CONIN$ back if we call GetFullPathName on it.
        // For other special cases like com ports, GetFullPathName returns
        // something like \\.\com1 which will be handled by IsNotFile.
        WCHAR wszFullPath[MAX_PATH] = L"";
        DWORD cFullPath = 0;

        pwszOriginalName = ConvertToNormalPath(pwszOriginalName);
        m_pwszAlternateName = NULL;

        //
        // Do the easy checks first.
        //
        if (!pwszOriginalName ||
            !_wcsicmp(pwszOriginalName, L"conin$") || 
            !_wcsicmp(pwszOriginalName, L"conout$"))
        {
            return;
        }

        cFullPath = GetFullPathNameW(pwszOriginalName, MAX_PATH, wszFullPath, NULL);

        //
        // Make sure we can get the full path and within the range we handle.
        //
        if (!cFullPath || cFullPath < 2 || cFullPath > MAX_PATH)
        {
            return;
        }

        //
        // Verify it's the kind of file we handle, ie, it must start with x: and not
        // contain any of the following chars.
        //
        WCHAR chDrive = (WCHAR)tolower(wszFullPath[0]);

        if (wszFullPath[1] != L':' || !(chDrive >= L'a' && chDrive <= L'z') ||
            ((eObjType == OBJ_FILE) && IsNotFileW(wszFullPath)))
        {
            return;
        }

        //
        // Do the more complicated checks.
        //
        if (!IsNTFSW(wszFullPath) ||
            !MassageName(wszFullPath) ||
            IsUserDirectory(wszFullPath) ||
            (fCheckRedirectList && !IsInRedirectList(wszFullPath, &m_fAllUser)))
        {
            return;
        }

        m_eObjType = eObjType;

        wcsncpy(m_wszOriginalName, wszFullPath, MAX_PATH);

        //
        // if fCheckRedirectList is FALSE, it means it could be in either per user or
        // all user dir, the caller should then call separated methods to retrieve each
        // redirected file name.
        //
        if (fCheckRedirectList) 
        {
            // Construct the alternate file name.
            MakeAlternateName();
        }
    }

    ~REDIRECTFILE()
    {
        delete [] m_pwszAlternateName;
    }

    BOOL CreateAlternateCopy();

    VOID GetAlternateAllUser();
    VOID GetAlternatePerUser();

    WCHAR m_wszOriginalName[MAX_PATH];
    LPWSTR m_pwszAlternateName;
    BOOL m_fAllUser;

private:

    VOID MakeAlternateName();

    EOBJTYPE m_eObjType;
};

// We give the users an option to exclude files with extensions they specify.
// This is mostly useful when you want to redirect everything except user
// created files.

#define EXCLUDED_EXTENSIONS_DELIMITER L' '

struct EXCLUDED_EXTENSIONS
{
    // We store all extensions in one string, using '/' as the delimiter.
    LPWSTR pwszExtensions;
    DWORD cExtensions;
    DWORD* pdwIndices;
    DWORD cIndices;

    EXCLUDED_EXTENSIONS()
    {
        pwszExtensions = NULL;
        cExtensions = 0;
        pdwIndices = NULL;
        cIndices = 0;
    }

    ~EXCLUDED_EXTENSIONS()
    {
        //
        // Let the process clean up the memory for us.
        //
    }

    BOOL Init(LPCWSTR pwszExcludedExtensions)
    {
        if (!pwszExcludedExtensions || !*pwszExcludedExtensions)
        {
            //
            // Nothing to do.
            //
            return TRUE;
        }

        cExtensions = wcslen(pwszExcludedExtensions);

        pwszExtensions = new WCHAR [cExtensions + 2];

        if (!pwszExtensions)
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[EXCLUDED_EXTENSIONS::Init] Error allocating %d WCHARs",
                cExtensions + 1);

            return FALSE;
        }

        ZeroMemory(pwszExtensions, (cExtensions + 1) * sizeof(WCHAR));
        NormalizeExtensions(pwszExcludedExtensions);
        ++cIndices;

        pdwIndices = new DWORD [cIndices];

        if (!pdwIndices)
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[EXCLUDED_EXTENSIONS::Init] Error allocating %d DWORDs",
                cIndices);

            delete [] pwszExtensions;
            pwszExtensions = NULL;
            return FALSE;
        }

        ZeroMemory(pdwIndices, cIndices * sizeof(DWORD));

        DWORD dwIndex = 1;
        LPWSTR pwszTemp = pwszExtensions;

        while (*pwszTemp)
        {
            if (*pwszTemp == EXCLUDED_EXTENSIONS_DELIMITER)
            {
                pdwIndices[dwIndex] = (DWORD)(pwszTemp - pwszExtensions + 1);

                if (++dwIndex == cIndices - 1)
                {
                    break;
                }
            }

            ++pwszTemp;
        }

        pdwIndices[cIndices - 1] = cExtensions + 1;

        return TRUE;
    }

    BOOL IsExtensionExcluded(LPCWSTR pwszName)
    {
        DWORD cItemLen = wcslen(pwszName);
        DWORD cExtensionLen, cExtensionLenItem;
        LPWSTR pwszExtensionItem;

        if ((pwszExtensionItem = wcschr(pwszName, L'.')) == NULL)
        {
            //
            // If the file has no extension, it will not be excluded.
            //
            return FALSE;
        }
        else
        {
            cExtensionLenItem = (DWORD)(cItemLen - (pwszExtensionItem - pwszName) - 1);
        }

        for (DWORD dwIndex = 0; dwIndex < cIndices - 1; ++dwIndex)
        {
            cExtensionLen = pdwIndices[dwIndex + 1] - pdwIndices[dwIndex] - 1;

            if (cExtensionLen == cExtensionLenItem)
            {
                if (!_wcsnicmp(
                    pwszName + cItemLen - cExtensionLen, 
                    pwszExtensions + pdwIndices[dwIndex],
                    cExtensionLen))
                {
                    return TRUE;
                }
            }
        }

        return FALSE;
    }

private:

    //
    // We want to "normalize" the extension list to
    // "xxx xxx xxx" without any extra spaces.
    //
    void NormalizeExtensions(LPCWSTR pwszExcludedExtensions)
    {
        LPWSTR pwsz = (LPWSTR)pwszExcludedExtensions;
        LPCWSTR pwszToken = wcstok(pwsz, L" \t");

        while (pwszToken)
        {
            wcscat(pwszExtensions, pwszToken);
            wcscat(pwszExtensions, L" ");
            ++cIndices;
            pwszToken = wcstok(NULL, L" \t");
        }

        cExtensions = wcslen(pwszExtensions);
        if (cExtensions > 1)
        {
            pwszExtensions[cExtensions - 1] = L'\0';
            --cExtensions;
        }
    }
};

// We keep the deleted files in an in-memory lists.
struct DELETEDFILE
{
    LIST_ENTRY entry;
    LPWSTR pwszName;
};

//
// If we can find this file in the deletion list, return the entry.
//
PLIST_ENTRY 
FindDeletedFile(
    LPCWSTR pwszFile
    );

//
// Check if the file exists in the deletion list, if not, add it to
// the beginning of the list.
//
BOOL
AddDeletedFile(
    LPCWSTR pwszPath
    );

#endif // _LUA_REDIRECT_FS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\redirectfs.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    RedirectFS.cpp

 Abstract:

    When app gets access denied when trying to modify files due to insufficient
    access rights we copy the file to a location where the app does have enough
    access rights to do so. By default we redirect files to 
    
    %ALLUSERSPROFILE\Application Data\Redirected\drive\filepath

    to simulate the Win9x behavior.

    If you use the LUA wizard in CompatAdmin to customize LUA settings, you can
    choose to redirect files to either an all-user location

    %ALLUSERSPROFILE\Application Data\AppName\drive\filepath

    or a per-user location

    %USERPROFILE\Application Data\AppName\drive\filepath

    For example, you would want to redirect the file that stores the highscore 
    table to a dir that other users can access so you specify to redirect it to
    the all-user location but redirect everything else into your user directory.

 Notes:

    This does the bulk work for the LUARedirectFS shim.

    The 16-bit APIs (OpenFile, _lcreat and _lopen) are not here because we
    redirect the 32-bit APIs that are used to implement those.

    FindFirstFile, FindNextFile and FindClose are also not included because
    these are specially implemented using the ntdll functions in ntvdm.

    We don't handle filenames that are longer than MAX_PATH. So it's a really
    long path we revert to the original API. I have never seem an app that uses
    paths longer than MAX_PATH.

 History:

    02/12/2001 maonis  Created

    05/31/2001 maonis  Exported the APIs that ntvdm needs to implement LUA 
                       stuff.

    10/24/2001 maonis  Added support to have some files redirect to an all-user dir
                       and others to a per-user dir.
                       Changed the commandline format to utilize the <DATA> section
                       in the shim.

    11/15/2001 maonis  Added support to exclude file extensions. Changed to use the
                       ntdll functions in init.

    11/30/2001 maonis  Added support to redirect everything in a directory.

    01/11/2002 maonis  Added support for an in-memory deletion list.

    02/14/2002 maonis  Security fixes including 
                       - prefix bugs 
                       - don't use dangerous APIs
                       - more checks to avoid buffer overrun.

--*/

#include "precomp.h"
#include "utils.h"
#include "secutils.h"
#include "RedirectFS.h"
#include <ntioapi.h>

// The all-user redirect directory.
WCHAR g_wszRedirectRootAllUser[MAX_PATH] = L"";
DWORD g_cRedirectRootAllUser = 0; // Doesn't include the terminating NULL.

// The per-user redirect directory
WCHAR g_wszRedirectRootPerUser[MAX_PATH] = L"";
DWORD g_cRedirectRootPerUser = 0; // Doesn't include the terminating NULL.

// Store the filesystem type for all possible drives.
EFSTYPE g_eVolumnFS[26];

// If the user used the LUA wizard which is indicated by the commandline, we
// redirect everything to per-user by default unless the user specifically
// asked to redirect something to all-user.
// If the shim doesn't have a commandline, we redirect everything to all-user.
BOOL g_fIsConfigured = FALSE;

// Did the user specify a redirect list (via the LUA wizard)?
BOOL g_fHasRedirectList = FALSE;

// The list that stores the file we tried to delete but got access denied.
LIST_ENTRY g_DeletedFileList; 

EXCLUDED_EXTENSIONS g_ExcludedExtensions;
CString             g_strDefaultExclusionList;
BOOL                g_fHasSetExclusionList = FALSE;

// The lists for files we'll consider for redirection.
RITEM* g_pRItemsFile = NULL;
DWORD g_cRItemsFile  = 0;

// The lists for directories we'll consider for redirection.
RITEM* g_pRItemsDir = NULL;
DWORD g_cRItemsDir  = 0;

PLIST_ENTRY 
FindDeletedFile(
    LPCWSTR pwszFile
    )
{
    DELETEDFILE* pItem;
    DWORD cLen = wcslen(pwszFile);

    for (PLIST_ENTRY pEntry = g_DeletedFileList.Flink; 
        pEntry != &g_DeletedFileList; 
        pEntry = pEntry->Flink) 
    {
        pItem = CONTAINING_RECORD(pEntry, DELETEDFILE, entry);

        if (!_wcsicmp(pItem->pwszName, pwszFile))
        {
            DPF("RedirectFS", eDbgLevelInfo,
                "[FindDeletedFile] Found %S in the deletion list",
                pwszFile);

            return pEntry;
        }
    }

    return NULL;
}

BOOL 
AddDeletedFile(
    LPCWSTR pwszFile
    )
{
    PLIST_ENTRY pEntry = FindDeletedFile(pwszFile);

    if (pEntry == NULL)
    {
        DELETEDFILE* pNewFile = new DELETEDFILE;

        if (pNewFile)
        {
            DWORD cLen = wcslen(pwszFile);
            pNewFile->pwszName = new WCHAR [cLen + 1];

            if (pNewFile->pwszName)
            {
                wcsncpy(pNewFile->pwszName, pwszFile, cLen);
                pNewFile->pwszName[cLen] = L'\0';

                InsertHeadList(&g_DeletedFileList, &pNewFile->entry);

                DPF("RedirectFS", eDbgLevelInfo,
                    "[AddDeletedFile] Added %S to the deletion list",
                    pwszFile);

                return TRUE;
            }
            else
            {
                DPF("RedirectFS", eDbgLevelError,
                    "[AddDeletedFile] Failed to allocate %d WCHARs",
                    cLen);

                delete pNewFile;
            }
        }
        else
        {
            DPF("RedirectFS", eDbgLevelError,
                "[AddDeletedFile] Failed to allocate a DELETEFILE");
        }
    }

    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return FALSE;
}



/*++

 Function Description:

    We convert as many components into the long path as possible and
    convert the whole string to lower case.

 Arguments:

    IN pwszFullPath - The name got from GetFullPathName.

 Return Value:

    pointer to the massaged string.

 History:

    05/16/2001 maonis  Created

--*/

LPWSTR 
MassageName(
    LPWSTR pwszFullPath
    )
{
    DWORD dwRes;
    DWORD cLen = wcslen(pwszFullPath);

    if (cLen >= MAX_PATH)
    {
        DPF("RedirectFS", eDbgLevelError,
            "[MassageName] File name has %d chars - we don't handle file name "
            "that long",
            cLen);

        return NULL;
    }

    //
    // BUGBUG: This is taking a bit too much stack space.
    //
    WCHAR wszTempPath[MAX_PATH] = L"";
    WCHAR wszLongPath[MAX_PATH] = L"";
    wcsncpy(wszTempPath, pwszFullPath, cLen);
    wszTempPath[cLen] = L'\0';

    LPWSTR pwszStartSearching = wszTempPath + cLen;
    
    while (!(dwRes = GetLongPathNameW(wszTempPath, wszLongPath, MAX_PATH)))
    {
        while (--pwszStartSearching >= wszTempPath && *pwszStartSearching != L'\\');

        if (pwszStartSearching < wszTempPath)
        {
            break;
        }

        *pwszStartSearching = L'\0';
    }

    //
    // Check we are not exceeding MAX_PATH chars.
    //
    DWORD cLenLongPath = dwRes; // The length of the part we converted to the long path.
    DWORD cLenLongPathEnd = (DWORD)(pwszStartSearching - wszTempPath);
    DWORD cNewLen = cLenLongPath + cLen - cLenLongPathEnd + 1;

    if (dwRes > MAX_PATH || cNewLen > MAX_PATH)
    {
        DPF("RedirectFS", eDbgLevelError,
            "[MassageName] The converted path is more than MAX_PATH chars - "
            "We don't handle it");

        return NULL;
    }

    if (dwRes)
    {
        if (cLenLongPath != cLenLongPathEnd)
        {
            memmove(
                (void*)(pwszFullPath + cLenLongPath), 
                (const void*)(pwszFullPath + cLenLongPathEnd), 
                (cLen - cLenLongPathEnd + 1) * sizeof(WCHAR));

            *(pwszFullPath + cNewLen) = L'\0';
        }

        //
        // Yes we know we have enough space to do the memmove.
        //
        memcpy((void*)pwszFullPath, (const void*)wszLongPath, cLenLongPath * sizeof(WCHAR));
    }

    _wcslwr(pwszFullPath);
    
    //
    // Remove the trailing slash if any.
    //
    DWORD dwLastChar = wcslen(pwszFullPath) - 1;
    if (pwszFullPath[dwLastChar] == L'\\')
    {
        pwszFullPath[dwLastChar] = L'\0';
    }

    return pwszFullPath;
}

BOOL 
AllocateList(
    DWORD cItems,
    RITEM** ppRItems
    )
{
    RITEM* pRItems = new RITEM [cItems];

    if (!pRItems)
    {
        DPF("RedirectFS", eDbgLevelError,
            "[AllocateList] Error allocating %d RITEMs", cItems);

        return FALSE;
    }

    *ppRItems = pRItems;

    return TRUE;
}

BOOL 
HasWildCards(
    LPCWSTR pwszName, 
    DWORD cLen
    )
{
    WCHAR ch;

    for (DWORD dw = 0; dw < cLen; ++dw)
    {
        if ((ch = *(pwszName + dw)) == L'*' || ch == L'?')
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*++

 Function Description:

    Every file that needs redirection will be redirected unless the file extension
    is in the exclusion list and the file is not in the redirect list. For example,
    we have a redirect list:
    
    c:\a\*.txt

    and the exclusion list looks like:
    
    bmp txt

    in which case (we assume those files all need redirection),

    c:\a\b.txt will be redirected because it's in the redirect list;

    c:\b\b.txt will NOT be redirected because it's not in the redirect list and
    the "txt" extension is excluded.

    c:\b\b.ini will be redirected because the extension is not excluded.

    ------------------------------------------------------------------------

    We allow wildcards '*' and '?' in the lists so we need to
    match on those. For performance reasons we'd only call 
    DoNamesMatchWC when comparing the object name with a string
    that has wildcards in it.

 Arguments:

    IN pwszObject - file/dir name.
    OUT pfAllUser - should this file be redirected to the all user dir?

 Return Value:

    TRUE - should be considered for redirection.
    FALSE - shouldn't be considered for redirection.
    
 History:

    05/08/2001 maonis  Created

--*/

BOOL 
IsInRedirectList(
    LPCWSTR pwszObject,
    BOOL* pfAllUser
    )
{
    BOOL fAllUser;

    if (g_fHasRedirectList)
    {
        DWORD dw;

        for (dw = 0; dw < g_cRItemsFile; ++dw)
        {
            if (DoesItemMatchRedirect(pwszObject, &g_pRItemsFile[dw], FALSE))
            {
                if (pfAllUser)
                {
                    *pfAllUser = g_pRItemsFile[dw].fAllUser;
                }

                //
                // If we can find it in the redirect list, we are done, return now.
                //
                return TRUE;
            }
        }

        //
        // If we didn't find the match in the file redirect list, check the directory
        // redirect list.
        //
        for (dw = 0; dw < g_cRItemsDir; ++dw)
        {
            if (DoesItemMatchRedirect(pwszObject, &g_pRItemsDir[dw], TRUE))
            {
                if (pfAllUser)
                {
                    *pfAllUser = g_pRItemsDir[dw].fAllUser;
                }

                //
                // If we can find it in the redirect list, we are done, return now.
                //

                return TRUE;
            }
        }
    }

    //
    // We've looked through the redirect list and didn't find the object there.
    // Now look into the exclusion list and return FALSE if we can find the extension
    // there.
    //
    if (g_ExcludedExtensions.pwszExtensions) 
    {
        if (g_ExcludedExtensions.IsExtensionExcluded(pwszObject))
        {
            DPF("RedirectFS", eDbgLevelInfo,
                "[IsInRedirectList] %S is excluded because of its extension.",
                pwszObject);

            return FALSE;
        }
    }

    //
    // If we get here it means the object should be redirected.
    //
    if (pfAllUser)
    {
        *pfAllUser = !g_fIsConfigured;
    }

    return TRUE;
}

/*++

 Function Description:

    Check if the file is on an NTFS partition. We have to
    check this for every file because they don't necessarily
    locate on one partition.
    
 Arguments:

    IN pwszFile - file name.

 Return Value:

    TRUE - it's NTFS.
    FALSE - it's not.
    
 History:

    02/12/2001 maonis  Created

--*/

BOOL 
IsNTFSW(
    LPCWSTR pwszFile
    )
{
    WCHAR wszRoot[4];
    wcsncpy(wszRoot, pwszFile, 3);
    wszRoot[3] = L'\0';

    DWORD dwFSFlags;
    DWORD dwIndex = towlower(wszRoot[0]) - L'a';
    if (g_eVolumnFS[dwIndex] == FS_UNINIT)
    {
        if (GetVolumeInformationW(
            wszRoot,
            NULL,
            0,
            NULL,
            NULL,
            &dwFSFlags,
            NULL,
            0))
        {
            if (dwFSFlags & FS_PERSISTENT_ACLS)
            {
                g_eVolumnFS[dwIndex] = FS_NTFS;
            }
        }
        else
        {
            g_eVolumnFS[dwIndex] = FS_NON_NTFS;
        }
    }

    return (g_eVolumnFS[dwIndex] == FS_NTFS);
}

BOOL 
DoesFileExist(
    LPCWSTR lpFileName
    )
{
    DWORD dwAttrib = GetFileAttributesW(lpFileName);

    return (dwAttrib != -1);
}

BOOL 
IsDirectoryValid(
    LPCWSTR lpFileName
    )
{
    BOOL fRes = TRUE;

    LPWSTR pwszPathEnd = wcsrchr(lpFileName, L'\\');

    if (pwszPathEnd)
    {
        // Make a copy of the string.
        LPWSTR pwszPath = new WCHAR [wcslen(lpFileName) + 1];

        if (pwszPath)
        {
            wcscpy(pwszPath, lpFileName);
            pwszPath[pwszPathEnd - lpFileName] = L'\0';

            DWORD dwAttrib = GetFileAttributesW(pwszPath);

            fRes = ((dwAttrib != -1) && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));

            delete [] pwszPath;
        }
        else
        {
            fRes = FALSE;
        }
    }

    return fRes;
}

/*++

 Function Description:

    Construct the alternate file name.
    
    Converts drive:\path\file to
    \\?\Redirect_Dir\drive\path\file. If there's no Redirect Dir specified
    on the commandline, we use the default:
    \\?\LocalAppData_Directory\Redirected\drive\path\file.

 Arguments:

    None.

 Return Value:

    None.
    
 History:

    02/12/2001 maonis  Created
    10/24/2001 maonis  Modified

--*/

VOID
REDIRECTFILE::MakeAlternateName()
{
    m_pwszAlternateName = NULL;

    DWORD cRedirectRoot;
    LPWSTR pwszRedirectRoot;

    if (m_fAllUser)
    {
        cRedirectRoot = g_cRedirectRootAllUser;
        pwszRedirectRoot = g_wszRedirectRootAllUser;
    }
    else
    {
        cRedirectRoot = g_cRedirectRootPerUser;
        pwszRedirectRoot = g_wszRedirectRootPerUser;
    }

    DWORD cLen = wcslen(m_wszOriginalName) + cRedirectRoot + 1;
    m_pwszAlternateName = new WCHAR [cLen];

    if (m_pwszAlternateName)
    {
        ZeroMemory(m_pwszAlternateName, cLen * sizeof(WCHAR));

        //
        // We know we have enough space.
        //
        wcscpy(m_pwszAlternateName, pwszRedirectRoot);
        m_pwszAlternateName[cRedirectRoot] = m_wszOriginalName[0];
        wcscpy(m_pwszAlternateName + (cRedirectRoot + 1), m_wszOriginalName + 2);
    }
}

VOID 
REDIRECTFILE::GetAlternateAllUser()
{
    m_fAllUser = TRUE;

    if (m_pwszAlternateName) 
    {
        delete [] m_pwszAlternateName;
        m_pwszAlternateName = NULL;
    }

    MakeAlternateName();
}

VOID
REDIRECTFILE::GetAlternatePerUser()
{
    m_fAllUser = FALSE;

    if (m_pwszAlternateName) 
    {
        delete [] m_pwszAlternateName;
        m_pwszAlternateName = NULL;
    }

    MakeAlternateName();
}

/*++

 Function Description:

    Create the alternate directory hidrachy if needed. If the file exists at the
    original location but not the alternate location, copy the file to the 
    alternate location.
    
 Arguments:
    
    None
    
 History:

    02/12/2001 maonis  Created

--*/

BOOL 
REDIRECTFILE::CreateAlternateCopy()
{
    BOOL fRes = FALSE;
    UINT cAlternatePath = wcslen(m_pwszAlternateName);

    // If it's a directory, we want to ensure the trailing slash.
    // The only API that would pass in an OBJ_FILE_OR_DIR type is GetFileAttributes
    // which will never call this. So the object type must be known.
    if (m_eObjType == OBJ_DIR)
    {
        ++cAlternatePath;
    }

    LPWSTR pwszAlternatePath = new WCHAR [cAlternatePath + 1];

    UINT cRedirectRoot = (m_fAllUser ? g_cRedirectRootAllUser : g_cRedirectRootPerUser);

    if (pwszAlternatePath)
    {
        ZeroMemory(pwszAlternatePath, sizeof(WCHAR) * (cAlternatePath + 1));
        wcsncpy(pwszAlternatePath, m_pwszAlternateName, cAlternatePath + 1);

        // Ensure the trailing slash.
        if ((m_eObjType == OBJ_DIR) && (pwszAlternatePath[cAlternatePath - 2] != L'\\'))
        {
            pwszAlternatePath[cAlternatePath - 1] = L'\\';
            pwszAlternatePath[cAlternatePath] = L'\0';
        }

        WCHAR* pwszEndPath = wcsrchr(pwszAlternatePath, L'\\');

        if (!pwszEndPath)
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[CreateAlternateCopy] We shouldn't have gotten here - "
                "couldn't find '\\'??");
            goto EXIT;
        }

        ++pwszEndPath;
        *pwszEndPath = L'\0';
        
        //
        // Create the directory hierachy.
        // First skip the part of the directory that we know exists.
        //
        WCHAR* pwszStartPath = pwszAlternatePath;
        WCHAR* pwszStartNext = pwszStartPath + cRedirectRoot;
            
        // Find the end of the next sub dir.
        WCHAR* pwszEndNext = pwszStartNext;
        DWORD dwAttrib;

        while (pwszStartNext < pwszEndPath)
        {
            pwszEndNext = wcschr(pwszStartNext, L'\\');

            if (pwszEndNext)
            {
                *pwszEndNext = L'\0';
                if ((dwAttrib = GetFileAttributesW(pwszStartPath)) != -1)
                {
                    //
                    // If the directory already exists, we probe its sub directory.
                    //
                    *pwszEndNext = L'\\';
                    pwszStartNext = pwszEndNext + 1;
                    continue;
                }

                if (!CreateDirectoryW(pwszStartPath, NULL))
                {
                    DPF("RedirectFS", eDbgLevelError, 
                        "[CreateAlternateCopy] CreateDirectory failed: %d", GetLastError());
                    goto EXIT;
                }

                *pwszEndNext = L'\\';
                pwszStartNext = pwszEndNext + 1;
            }
            else
            {
                DPF("RedirectFS", eDbgLevelError, 
                    "[CreateAlternateCopy] We shouldn't have gotten here - "
                    "couldn't find '\\' yet we are not at the end of the path");
                goto EXIT;
            }
        }

        if (m_eObjType == OBJ_FILE && 
            (GetFileAttributesW(m_wszOriginalName) != -1) && 
            (GetFileAttributesW(m_pwszAlternateName) == -1))
        {
            if (!CopyFileW(m_wszOriginalName, m_pwszAlternateName, TRUE))
            {
                DPF("RedirectFS", eDbgLevelError, "[CreateAlternateCopy] CopyFile failed: %d", GetLastError());
                goto EXIT;
            }
        }

        DPF("RedirectFS", eDbgLevelInfo, "[CreateAlternateCopy] Redirecting %S", m_pwszAlternateName);
        fRes = TRUE;
    }

EXIT:

    delete [] pwszAlternatePath;
    return fRes;
}

BOOL 
TryAlternateFirst(
    DWORD dwCreationDisposition,
    LPCWSTR pwszAlternate
    )
{
    DWORD dwAlternateAttrib = GetFileAttributesW(pwszAlternate);

    if (dwCreationDisposition == OPEN_EXISTING || 
        dwCreationDisposition == TRUNCATE_EXISTING ||
        (dwAlternateAttrib != -1 && 
        (dwCreationDisposition == CREATE_ALWAYS || dwCreationDisposition == OPEN_ALWAYS)))
    {
        return TRUE;
    }

    return FALSE;
}

// We want to try the alternate location if we get path not found
// because the user might've created the path at the alternate location.
BOOL 
IsErrorTryAlternate()
{
    DWORD dwLastError = GetLastError();
    return (dwLastError == ERROR_ACCESS_DENIED || dwLastError == ERROR_PATH_NOT_FOUND);
}

//
// Exported APIs.
//

HANDLE 
LuaCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[CreateFileW] lpFileName=%S; dwDesiredAccess=0x%08x; dwCreationDisposition=%d",
        lpFileName, dwDesiredAccess, dwCreationDisposition);

    DWORD dwAttrib = GetFileAttributesW(lpFileName);

    if ((dwAttrib != -1) && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[CreateFileW] Calling CreateFile on a directory!");

        return CreateFileW(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
    }
    
    HANDLE hFile = INVALID_HANDLE_VALUE;

    // Check the alternate location first unless the user wants to create a new file.
    REDIRECTFILE rf(lpFileName);
    DWORD dwLastError;

    if (rf.m_pwszAlternateName)
    {
        //
        // If the user asked to open an existing file, we need to fail the request now
        // if the file is in the deletion list.
        //
        PLIST_ENTRY pDeletedEntry = FindDeletedFile(rf.m_wszOriginalName);
        if (pDeletedEntry && 
            (dwCreationDisposition == OPEN_EXISTING || 
             dwCreationDisposition == TRUNCATE_EXISTING))
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[CreateFileW] %S was already deleted, failing CreateFile call",
                rf.m_wszOriginalName);

            dwLastError = ERROR_FILE_NOT_FOUND;
            SetLastError(dwLastError);
            return hFile;
        }

        //
        // If the directory doesn't exist at the original location or alternate location,
        // fail the call now.
        //
        if (!IsDirectoryValid(rf.m_wszOriginalName) && !IsDirectoryValid(rf.m_pwszAlternateName))
        {
            dwLastError = ERROR_PATH_NOT_FOUND;
            SetLastError(dwLastError);
            return hFile;
        }

        if (!TryAlternateFirst(dwCreationDisposition, rf.m_pwszAlternateName) ||
            ((hFile = CreateFileW(
            rf.m_pwszAlternateName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile)) == INVALID_HANDLE_VALUE && IsErrorNotFound()))
        {
            // Now look at the original location.
            if ((hFile = CreateFileW(
                lpFileName,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes, 
                hTemplateFile)) == INVALID_HANDLE_VALUE &&
                IsErrorTryAlternate())
            {
                BOOL fRequestWriteAccess = RequestWriteAccess(
                    dwCreationDisposition,
                    dwDesiredAccess);

                if (!fRequestWriteAccess)
                {
                    // We didn't want to write to the file yet we got
                    // ACCESS_DENIED, there's nothing we can do about it.
                    DPF("RedirectFS", 
                        eDbgLevelError, 
                        "[CreateFileW] Get access denied on read");
                    goto EXIT;
                }

                // If we are trying to write to a read only file, we
                // will get ACCESS_DENIED whether we are a normal user 
                // or an admin, so simply return.
                if (fRequestWriteAccess && 
                    ((dwAttrib != -1) && (dwAttrib & FILE_ATTRIBUTE_READONLY)))
                {
                    DPF("RedirectFS", 
                        eDbgLevelError, 
                        "[CreateFileW] Get access denied on write to read only file");
                    goto EXIT;
                }

                if (IsFileSFPedW(rf.m_wszOriginalName))
                {
                    // If it's an SFP-ed executable, we simply return success.
                    // NOTE: this might cause problems because the app might expect
                    // to use the handle.
                    DPF("RedirectFS", 
                        eDbgLevelWarning, 
                        "[CreateFileW] Trying to write to an SFPed file");
                    hFile = (HANDLE)1;
                    goto EXIT;
                }

                // If we get this far, we need to make a copy at the alternate location.
                if (rf.CreateAlternateCopy())
                {
                    DPF("RedirectFS", 
                        eDbgLevelInfo, 
                        "[CreateFileW] We made a copy of the file at the alternate location");

                    // Open the file again.
                    hFile = CreateFileW(
                        rf.m_pwszAlternateName,
                        dwDesiredAccess,
                        dwShareMode,
                        lpSecurityAttributes,
                        dwCreationDisposition,
                        dwFlagsAndAttributes,
                        hTemplateFile);
                }
            }
        }

        if (hFile != INVALID_HANDLE_VALUE && pDeletedEntry)
        {
            DPF("RedirectFS", eDbgLevelInfo, 
                "[CreateFileW] Removed %S "
                "from the deletion list because we just created it",
                rf.m_wszOriginalName);

            RemoveEntryList(pDeletedEntry);
        }
    }
    else
    {
        return CreateFileW(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
    }

EXIT:

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[CreateFileW] Createfile failed: %d",
            GetLastError());
    }
    else
    {
        DPF("RedirectFS", eDbgLevelInfo, 
            "[CreateFileW] Createfile succeeded");
    }

    return hFile;
}

BOOL 
LuaCopyFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[CopyFileW] lpExistingFileName=%S; lpNewFileName=%S; bFailIfExists=%d",
        lpExistingFileName, lpNewFileName, bFailIfExists);

    BOOL fRes;
    REDIRECTFILE rfSource(lpExistingFileName);
    REDIRECTFILE rfDest(lpNewFileName);

    if (rfSource.m_pwszAlternateName || rfDest.m_pwszAlternateName)
    {
        //
        // If the user asked to open an existing file, we need to fail the request now
        // if the file is in the deletion list.
        //
        if (rfSource.m_pwszAlternateName)
        {
            PLIST_ENTRY pDeletedEntry = FindDeletedFile(rfSource.m_wszOriginalName);
            if (pDeletedEntry)
            {
                DPF("RedirectFS", eDbgLevelError, 
                    "[CopyFileW] %S was already deleted, failing CopyFile call",
                    rfSource.m_wszOriginalName);

                SetLastError(ERROR_FILE_NOT_FOUND);
                return FALSE;
            }
        }

        //
        // First we need to make sure that both the source file and the destination
        // directory exist. For the source file, if it doesn't exist at the original
        // location, it has to exist at the alternate location.
        //
        if ((DoesFileExist(lpExistingFileName) || DoesFileExist(rfSource.m_pwszAlternateName)) &&
            IsDirectoryValid(lpNewFileName))
        {
            LPWSTR pwszExistingFileName = (LPWSTR)lpExistingFileName;
            LPWSTR pwszNewFileName = (LPWSTR)lpNewFileName;

            if (rfSource.m_pwszAlternateName)
            {
                //
                // If the file exists at the alternate location, we need to use it instead
                // of the one at the original location.
                //
                DWORD dwSourceAttrib = GetFileAttributesW(rfSource.m_pwszAlternateName);

                if (dwSourceAttrib != -1)
                {
                    pwszExistingFileName = rfSource.m_pwszAlternateName;
                }
            }
            
            //
            // Attempt to copy to the original location first. If we can write to the file
            // it means the file shouldn't exist at the alternate location anyway so
            // we can be sure that we are copying to a location where the app will check
            // first when they read from this file.
            //
            if (!(fRes = CopyFileW(pwszExistingFileName, lpNewFileName, bFailIfExists)) && 
                rfDest.m_pwszAlternateName)
            {
                //
                // We try the alternate location under these situations:
                // 1) We got access denied or file/path not found or
                // 2) We got ERROR_FILE_EXISTS and the dest file exists in the deletion list.
                //
                DWORD dwLastError = GetLastError();
                PLIST_ENTRY pDeletedDestEntry = FindDeletedFile(rfDest.m_wszOriginalName);

                if (dwLastError == ERROR_ACCESS_DENIED ||
                    dwLastError == ERROR_FILE_NOT_FOUND ||
                    dwLastError == ERROR_PATH_NOT_FOUND ||
                    (dwLastError == ERROR_FILE_EXISTS && pDeletedDestEntry))
                {
                    pwszNewFileName = rfDest.m_pwszAlternateName;

                    if (!DoesFileExist(pwszNewFileName))
                    {
                        //
                        // If the dest file exists at the original location but not the alternate
                        // location, we should copy the original file to the alternate location 
                        // first because if the user specifies TRUE for bFailIfExists we 
                        // need to return error if it already exists. Also we need to create the 
                        // directory at the alternate location if it doesn't exist yet or CopyFile
                        // will fail.
                        //
                        if (rfDest.CreateAlternateCopy())
                        {
                            DPF("RedirectFS", eDbgLevelInfo, 
                                "[CopyFileW] Created an alternate copy for dest");

                            //
                            // If we successfully created an alternate copy it means the dest
                            // file must exist at the original location and has been added
                            // to the deletion list - we want to delete the file we create to
                            // make it look like the original location.
                            //
                            if (DoesFileExist(rfDest.m_pwszAlternateName) && 
                                !DeleteFileW(rfDest.m_pwszAlternateName))
                            {
                                DPF("RedirectFS", eDbgLevelInfo,
                                    "[CopyFileW] Deleting the alternate dest file failed?! %d",
                                    GetLastError());
                                return FALSE;
                            }
                        }
                        else
                        {
                            DPF("RedirectFS", eDbgLevelError, 
                                "[CopyFileW] Error copying dest file from original location to alternate location");

                            // If errors occur we revert back to the original location.
                            pwszNewFileName = (LPWSTR)lpNewFileName;
                        }
                    }
                }

                fRes = CopyFileW(pwszExistingFileName, pwszNewFileName, bFailIfExists);

                if (fRes && pDeletedDestEntry)
                {
                    DPF("RedirectFS", eDbgLevelInfo, 
                        "[CopyFileW] Removed %S "
                        "from the deletion list because we just created it",
                        rfDest.m_wszOriginalName);

                    RemoveEntryList(pDeletedDestEntry);
                }
            }

            return fRes;
        }
    }

    return CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
}

DWORD 
LuaGetFileAttributesW(
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetFileAttributesW] lpFileName=%S", lpFileName);

    DWORD dwRes;

    // Check the alternate location first.
    REDIRECTFILE rf(lpFileName, OBJ_FILE_OR_DIR);

    if (rf.m_pwszAlternateName)
    {
        //
        // If the user asked to get the attributes of a file that has been deleted, 
        // we need to fail the request now.
        //
        if (FindDeletedFile(rf.m_wszOriginalName))
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[GetFileAttributesW] %S was already deleted, failing CreateFile call",
                rf.m_wszOriginalName);

            SetLastError(ERROR_FILE_NOT_FOUND);
            return -1;
        }

        if ((dwRes = GetFileAttributesW(rf.m_pwszAlternateName)) == -1)
        {
            // Now try the original location.
            dwRes = GetFileAttributesW(lpFileName);
        }
    }
    else
    {
        return GetFileAttributesW(lpFileName);
    }

    return dwRes;
}

/*++

 Function Description:

    If we were an admin user, would we get access denied when deleting this file?

 History:

    01/14/2002 maonis  Modified

--*/

BOOL
DeleteAccessDeniedAsAdmin(
    LPCWSTR pwszFileName
    )
{
    DWORD dwAttrib = GetFileAttributesW(pwszFileName);

    return ((dwAttrib != -1) && 
        ((dwAttrib & FILE_ATTRIBUTE_READONLY) || 
            (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)));
}

/*++

 Function Description:

    First try to delete it at the redirect location; then try to delete it
    at the original location and only add it to the deletion list if it 
    returns ERROR_ACCESS_DENIDED.

    Note that calling DeleteFile on a directory or a file that's read only 
    returns ERROR_ACCESS_DENIED.
    
 History:

    02/12/2001 maonis  Created
    01/14/2002 maonis  Modified

--*/

BOOL 
LuaDeleteFileW(
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[DeleteFileW] lpFileName=%S", lpFileName);

    BOOL fRes, fResTemp;
    DWORD dwLastError;

    // Check the alternate location first.
    REDIRECTFILE rf(lpFileName);

    if (rf.m_pwszAlternateName)
    {
        //
        // Fail the call now if the file exists in the deletion list.
        //
        if (FindDeletedFile(rf.m_wszOriginalName))
        {
            SetLastError(ERROR_FILE_NOT_FOUND);
            return FALSE;
        }

        if (!(fResTemp = DeleteFileW(rf.m_pwszAlternateName)))
        {
            if (GetLastError() == ERROR_ACCESS_DENIED && 
                DeleteAccessDeniedAsAdmin(rf.m_pwszAlternateName))
            {
                //
                // If we get access denied because of reasons that would
                // make admin users get access denied too, we return now.
                //
                return fResTemp;
            }
        }

        //
        // Try the original location now.
        //
        fRes = DeleteFileW(lpFileName);
        dwLastError = GetLastError();

        if (lpFileName && 
            !fRes && 
            GetLastError() == ERROR_ACCESS_DENIED && 
            !DeleteAccessDeniedAsAdmin(lpFileName))
        {
            fRes = AddDeletedFile(rf.m_wszOriginalName);

            if (fRes)
            {
                SetLastError(0);
            }
        }

        if (fResTemp && 
            (dwLastError == ERROR_FILE_NOT_FOUND || 
                dwLastError == ERROR_PATH_NOT_FOUND))
        {
            //
            // If we successfully deleted it at the alternate location and the
            // file does not exist at the original location, we have successfully
            // deleted this file so set the return to success.
            //
            fRes = TRUE;
            SetLastError(0);
        }
    }
    else
    {
        fRes = DeleteFile(lpFileName);
    }

    if (fRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[DeleteFileW] Successfully deleted %S",
            lpFileName);
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[DeleteFileW] Failed to delete %S: %d",
            lpFileName,
            GetLastError()); 
    }

    return fRes;
}

BOOL 
LuaCreateDirectoryW(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[CreateDirectoryW] lpPathName=%S", lpPathName);

    BOOL fRes;

    // Check the alternate location first.
    REDIRECTFILE rf(lpPathName, OBJ_DIR);
    DWORD dwLastError;
    DWORD dwAttrib;

    if (rf.m_pwszAlternateName)
    {
        dwAttrib = GetFileAttributesW(rf.m_pwszAlternateName);

        if (dwAttrib != -1 && dwAttrib & FILE_ATTRIBUTE_DIRECTORY)
        {
            // If the directory already exists, return now.
            SetLastError(ERROR_ALREADY_EXISTS);
            return FALSE;
        }

        // If the directory doesn't already exist at the alternate location,
        // we need to try to create it at the original location first.
        if (!(fRes = CreateDirectoryW(lpPathName, lpSecurityAttributes)))
        {
            dwLastError = GetLastError();

            if (dwLastError == ERROR_ACCESS_DENIED)
            {
                // Create the directory in the alternate location.
                fRes = rf.CreateAlternateCopy();
                DPF("RedirectFS", eDbgLevelInfo, 
                    "[CreateDirectoryW] Redirecting %S", lpPathName);                
            }
            else if (dwLastError == ERROR_PATH_NOT_FOUND)
            {
                // If the path doesn't exist, there's a possiblity that
                // the path has been created at the alternate location
                // so try there.
                fRes = CreateDirectoryW(rf.m_pwszAlternateName, lpSecurityAttributes);
            }
        }
    }
    else
    {
        return CreateDirectoryW(lpPathName, lpSecurityAttributes);
    }

    return fRes;
}

BOOL 
LuaSetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
  )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[SetFileAttributesW] lpFileName=%S", lpFileName);

    BOOL fRes;
    DWORD dwAttrib = GetFileAttributesW(lpFileName);
    if (dwAttrib == -1)
    {
        return SetFileAttributesW(lpFileName, dwFileAttributes);
    }

    EOBJTYPE eObjType = (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) ? OBJ_DIR : OBJ_FILE;

    // Check the alternate location first.
    REDIRECTFILE rf(lpFileName, eObjType);

    if (rf.m_pwszAlternateName)
    {
        //
        // If the user asked to set the attributes of a file that has been deleted, 
        // we need to fail the request now.
        //
        if (FindDeletedFile(rf.m_wszOriginalName))
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[SetFileAttributesW] %S was already deleted, failing CreateFile call",
                rf.m_wszOriginalName);

            SetLastError(ERROR_FILE_NOT_FOUND);
            return -1;
        }

        if (!(fRes = SetFileAttributesW(rf.m_pwszAlternateName, dwFileAttributes)))
        {
            // Now try the original location.
            if (!(fRes = SetFileAttributesW(lpFileName, dwFileAttributes)) &&
                IsErrorTryAlternate())
            {
                // Make a copy at the alternate location and the set the attributes there.
                if (rf.CreateAlternateCopy())
                {
                    fRes = SetFileAttributesW(rf.m_pwszAlternateName, dwFileAttributes);
                }
            }
        }
    }
    else
    {
        return SetFileAttributesW(lpFileName, dwFileAttributes);
    }

    return fRes;
}

/*++

    We simulate MoveFile by doing CopyFile and not caring about the result of 
    DeleteFile because if we don't have enough access rights we simply have to
    leave the file there.

--*/

BOOL 
LuaMoveFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[MoveFileW] lpExistingFileName=%S; lpNewFileName=%S", lpExistingFileName, lpNewFileName);

    BOOL fRes = TRUE;
    DWORD dwLastError = 0;

    if (!(fRes = MoveFileW(lpExistingFileName, lpNewFileName)))
    {
        fRes = LuaCopyFileW(lpExistingFileName, lpNewFileName, TRUE);

        if (fRes)
        {
            fRes = LuaDeleteFileW(lpExistingFileName);
        }
    }

    return fRes;
}

/*++

  If we get access denied we still return TRUE - this is not totally correct
  of course but serves the purpose so far. We might change this to make it 
  correct in the future.

  If the directory is not empty, it'll return ERROR_DIR_NOT_EMPTY.

  Calling RemoveDirectory on a file returns ERROR_DIRECTORY.

--*/

BOOL 
LuaRemoveDirectoryW(
    LPCWSTR lpPathName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[RemoveDirectoryW] lpPathName=%S", lpPathName);

    BOOL fRes;

    // Check the alternate location first.
    REDIRECTFILE rf(lpPathName, OBJ_DIR);

    if (rf.m_pwszAlternateName)
    {
        if (!(fRes = RemoveDirectoryW(rf.m_pwszAlternateName)))
        {
            if (IsErrorNotFound())
            {
                // Now try the original location.
                fRes = RemoveDirectoryW(lpPathName);

                if (!fRes && IsErrorTryAlternate())
                {
                    DWORD dwAttrib = GetFileAttributesW(lpPathName);
                    if ((dwAttrib != -1) && !(dwAttrib & FILE_ATTRIBUTE_READONLY))
                    {
                        fRes = TRUE;
                        SetLastError(0);
                    }
                }
            }
        }
    }
    else
    {
        return RemoveDirectoryW(lpPathName);
    }

    return fRes;
}

/*++

 Function Description:

    It's the caller's responsibility to have lpTempFileName big enough to 
    hold the file name including the terminating NULL or GetTempFileName AVs.

 History:

    05/16/2001 maonis  Created

--*/

UINT 
LuaGetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetTempFileNameW] lpPathName=%S", lpPathName);

    //
    // Try the original location first.
    //
    UINT uiRes = GetTempFileNameW(
        lpPathName, 
        lpPrefixString, 
        uUnique, 
        lpTempFileName);

    if (uiRes || (!lpPathName || uUnique || !IsErrorTryAlternate()))
    {
        return uiRes;
    }

    LPWSTR pwszPathName = (LPWSTR)lpPathName;
    WCHAR wszTemp[4] = L"1:\\"; // '1' is just a place holder for the drive letter.

    //
    // If lpPathName is drive:, we need to change it to drive:\ so when
    // we call GetFullPath we get drive: back instead of the current dir.
    //
    if ((wcslen(pwszPathName) == 2) && (pwszPathName[1] == L':'))
    {
        wszTemp[0] = pwszPathName[0];
        pwszPathName = wszTemp;
    }

    REDIRECTFILE rf(pwszPathName, OBJ_DIR);

    if (rf.m_pwszAlternateName && rf.CreateAlternateCopy())
    {
        DWORD cTempFileName = wcslen(rf.m_pwszAlternateName) + MAX_PATH + 1;

        LPWSTR pwszTempFileName = new WCHAR [cTempFileName];

        if (pwszTempFileName)
        {
            if (uiRes = GetTempFileNameW(
                rf.m_pwszAlternateName, 
                lpPrefixString, 
                uUnique, 
                pwszTempFileName))
            {
                //
                // We need to convert the alternate path back to a normal path
                // because our redirection should be transparent to the app.
                //
                DWORD dwFileStart = (rf.m_fAllUser ? g_cRedirectRootAllUser : g_cRedirectRootPerUser) - 1;

                //
                // We know we have a big enough buffer.
                //
                wcscpy(lpTempFileName, pwszTempFileName + dwFileStart);

                //
                // Convert \c\somedir\some012.tmp back to c:\somedir\some012.tmp
                //
                lpTempFileName[0] = lpTempFileName[1];
                lpTempFileName[1] = L':';
                
                DPF("RedirectFS", eDbgLevelInfo, 
                    "[GetTempFileNameW] temp file %S created at the alternate location", lpTempFileName);
            }

            delete [] pwszTempFileName;
        }
        else
        {
            DPF("RedirectFS", eDbgLevelError,
                "[GetTempFileNameW] Failed to allocate %d WCHARs",
                cTempFileName);

            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    
    return uiRes;
}

DWORD 
LuaGetPrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetPrivateProfileStringW] AppName=%S; KeyName=%S; FileName=%S", 
        lpAppName,
        lpKeyName,
        lpFileName);

    DWORD dwRes = 0;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(lpFileName, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);

        //
        // GetPrivateProfileString returns the default string if the file
        // doesn't exist so we need to check that first.
        //
        if (rf.m_pwszAlternateName && 
            (GetFileAttributesW(rf.m_pwszAlternateName) != -1))
        {
            dwRes = GetPrivateProfileStringW(
                lpAppName,
                lpKeyName,
                lpDefault,
                lpReturnedString,
                nSize,
                rf.m_pwszAlternateName);

            DPF("RedirectFS", eDbgLevelInfo,
                "[GetPrivateProfileStringW] Reading from alternate location");

            goto EXIT;
        }
    }

    dwRes = GetPrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpDefault,
        lpReturnedString,
        nSize,
        lpFileName);

EXIT:

    if (dwRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[GetPrivateProfileStringW] Successfully got string: %S",
            lpReturnedString);
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[GetPrivateProfileStringW] Failed: returned %d",
            dwRes);
    }

    return dwRes;
}

BOOL 
LuaWritePrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[WritePrivateProfileStringW] AppName=%S; KeyName=%S; String=%S; FileName=%S", 
        lpAppName,
        lpKeyName,
        lpString,
        lpFileName);

    BOOL fRes = FALSE;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(lpFileName, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);

        if (rf.m_pwszAlternateName)
        {
            //
            // WritePrivateProfileString creates the file so we want to
            // check if the file exists first. If it exists at the alternate
            // location we set it there; else we need to try the original
            // location first.
            //
            if ((GetFileAttributesW(rf.m_pwszAlternateName) != -1) ||
                (!(fRes = WritePrivateProfileStringW(
                    lpAppName,
                    lpKeyName,
                    lpString,
                    lpFileName)) && IsErrorTryAlternate()))
            {
                if (rf.CreateAlternateCopy())
                {
                    DPF("RedirectFS", eDbgLevelInfo, 
                        "[WritePrivateProfileStringW] Redirecting %S", lpFileName);

                    fRes = WritePrivateProfileStringW(
                        lpAppName,
                        lpKeyName,
                        lpString,
                        rf.m_pwszAlternateName);
                }
            }

            goto EXIT;
        }
    }

    fRes = WritePrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpString,
        lpFileName);

EXIT:

    if (fRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[WritePrivateProfileStringW] Successfully wrote the string");
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[WritePrivateProfileStringW] Failed to write the string: %d",
            GetLastError());
    }

    return fRes;
}

DWORD 
LuaGetPrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetPrivateProfileSectionW] AppName=%S; FileName=%S", 
        lpAppName,
        lpFileName);

    DWORD dwRes = 0;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(lpFileName, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);

        if (rf.m_pwszAlternateName && 
            (GetFileAttributesW(rf.m_pwszAlternateName) != -1))
        {
            dwRes = GetPrivateProfileSectionW(
                lpAppName,
                lpReturnedString,
                nSize,
                rf.m_pwszAlternateName);

            DPF("RedirectFS", eDbgLevelInfo,
                "[GetPrivateProfileSectionW] Reading from alternate location");

            goto EXIT;
        } 
    }

    dwRes = GetPrivateProfileSectionW(
        lpAppName,
        lpReturnedString,
        nSize,
        lpFileName);

EXIT:

    if (dwRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[GetPrivateProfileSectionW] Successfully got section");
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[GetPrivateProfileSectionW] Failed: returned %d",
            dwRes);
    }

    return dwRes;
}

BOOL 
LuaWritePrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[WritePrivateProfileSectionW] AppName=%S; String=%S; FileName=%S", 
        lpAppName,
        lpString,
        lpFileName);

    BOOL fRes = FALSE;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(lpFileName, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);

        if (rf.m_pwszAlternateName)
        {
            //
            // WritePrivateProfileSection creates the file so we want to
            // check if the file exists first. If it exists at the alternate
            // location we set it there; else we need to try the original
            // location first.
            //
            if ((GetFileAttributesW(rf.m_pwszAlternateName) != -1) ||
                (!(fRes = WritePrivateProfileSectionW(
                    lpAppName,
                    lpString,
                    lpFileName)) && IsErrorTryAlternate()))
            {
                if (rf.CreateAlternateCopy())
                {
                    DPF("RedirectFS", eDbgLevelInfo, 
                        "[WritePrivateProfileSectionW] Redirecting %S", lpFileName);

                    fRes = WritePrivateProfileSectionW(
                        lpAppName,
                        lpString,
                        rf.m_pwszAlternateName);
                }
            }

            goto EXIT;
        }
    }

    fRes = WritePrivateProfileSectionW(
        lpAppName,
        lpString,
        lpFileName);

EXIT:

    if (fRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[WritePrivateProfileSectionW] Successfully wrote section");
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[WritePrivateProfileSectionW] Failed to write section: %d",
            GetLastError());
    }

    return fRes;
}

UINT 
LuaGetPrivateProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault,
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetPrivateProfileIntW] AppName=%S; KeyName=%S; FileName=%S", 
        lpAppName,
        lpKeyName,
        lpFileName);

    UINT uiRes = 0;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(lpFileName, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);

        //
        // GetPrivateProfileInt returns the default int if the file
        // doesn't exist so we need to check that first.
        //
        if (rf.m_pwszAlternateName && 
            (GetFileAttributesW(rf.m_pwszAlternateName) != -1))
        {
            uiRes = GetPrivateProfileIntW(
                lpAppName,
                lpKeyName,
                nDefault,
                rf.m_pwszAlternateName);

            DPF("RedirectFS", eDbgLevelInfo,
                "[GetPrivateProfileIntW] Reading from alternate location");

            goto EXIT;
        }
    }

    uiRes = GetPrivateProfileIntW(
        lpAppName,
        lpKeyName,
        nDefault,
        lpFileName);

EXIT:

    if (uiRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[GetPrivateProfileIntW] Successfully got int: %d",
            uiRes);
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[GetPrivateProfileIntW] returned 0");
    }

    return uiRes;
}

DWORD 
LuaGetPrivateProfileSectionNamesW(
    LPWSTR lpszReturnBuffer,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetPrivateProfileSectionNamesW] FileName=%S", 
        lpFileName);

    DWORD dwRes = 0;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(lpFileName, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);

        if (rf.m_pwszAlternateName && 
            (GetFileAttributesW(rf.m_pwszAlternateName) != -1))
        {
            dwRes = GetPrivateProfileSectionNamesW(
                lpszReturnBuffer,
                nSize,
                rf.m_pwszAlternateName);

            DPF("RedirectFS", eDbgLevelInfo,
                "[GetPrivateProfileSectionNamesW] Reading from alternate location");

            goto EXIT;
        } 
    }

    dwRes = GetPrivateProfileSectionNamesW(
        lpszReturnBuffer,
        nSize,
        lpFileName);

EXIT:

    if (dwRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[GetPrivateProfileSectionNamesW] Successfully got section: %S",
            lpszReturnBuffer);
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[GetPrivateProfileSectionNamesW] returned 0");
    }

    return dwRes;
}

BOOL 
LuaGetPrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetPrivateProfileStructW] Section=%S; KeyName=%S; FileName=%S", 
        lpszSection,
        lpszKey,
        szFile);

    DWORD dwRes = 0;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(szFile, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);
     
        if (rf.m_pwszAlternateName && 
            (GetFileAttributesW(rf.m_pwszAlternateName) != -1))
        {
            dwRes = GetPrivateProfileStructW(
                lpszSection,
                lpszKey,
                lpStruct,
                uSizeStruct,
                rf.m_pwszAlternateName);

            DPF("RedirectFS", eDbgLevelInfo,
                "[GetPrivateProfileStructW] Reading from alternate location");

            goto EXIT;
        } 
    }

    dwRes = GetPrivateProfileStructW(
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile);

EXIT:

    if (dwRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[GetPrivateProfileStructW] Successfully got struct");
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[GetPrivateProfileStructW] Failed: returned 0");
    }

    return dwRes;
}

BOOL 
LuaWritePrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[WritePrivateProfileStructW] Section=%S; KeyName=%S; FileName=%S", 
        lpszSection,
        lpszKey,
        szFile);

    BOOL fRes = FALSE;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(szFile, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);
    
        if (rf.m_pwszAlternateName)
        {
            //
            // WritePrivateProfileStruct creates the file so we want to
            // check if the file exists first. If it exists at the alternate
            // location we set it there; else we need to try the original
            // location first.
            //
            if ((GetFileAttributesW(rf.m_pwszAlternateName) != -1) ||
                (!(fRes = WritePrivateProfileStructW(
                    lpszSection,
                    lpszKey,
                    lpStruct,
                    uSizeStruct,
                    szFile)) && IsErrorTryAlternate()))
            {
                if (rf.CreateAlternateCopy())
                {
                    DPF("RedirectFS", eDbgLevelInfo, 
                        "[WritePrivateProfileStructW] Redirecting %S", szFile);

                    fRes = WritePrivateProfileStructW(
                        lpszSection,
                        lpszKey,
                        lpStruct,
                        uSizeStruct,
                        rf.m_pwszAlternateName);
                }
            }

            goto EXIT;
        }
    }

    fRes = WritePrivateProfileStructW(
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile);

EXIT:

    if (fRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[WritePrivateProfileStructW] Successfully wrote struct");
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[WritePrivateProfileStructW] Failed to write struct: %d",
            GetLastError());
    }

    return fRes;
}

//----------------------------------------
// Processing the command line parameters.
//----------------------------------------

BOOL
GetListItemCount(
    LPCWSTR pwsz,
    DWORD* pcFiles,
    DWORD* pcDirs
    )
{
    if (!pwsz)
    {
        return TRUE;
    }

    DWORD cLen = wcslen(pwsz);
    LPWSTR pwszTemp = new WCHAR [cLen + 1];

    if (!pwszTemp)
    {
        DPF("RedirectFS", eDbgLevelError, "[GetListItemCount] failed to allocate %d WCHARs",
            cLen + 1);

        return FALSE;
    }

    wcsncpy(pwszTemp, pwsz, cLen);
    pwszTemp[cLen] = L'\0';

    LPWSTR pwszToken = wcstok(pwszTemp, L";");
    while (pwszToken)
    {
        SkipBlanksW(pwszToken);
        TrimTrailingSpaces(pwszToken);
        
        DWORD cTokenLen = wcslen(pwszToken);

        if (cTokenLen >= 6)
        {
            if (pwszToken[1] == L'C') 
            {
                if (pwszToken[cTokenLen - 1] == L'\\')
                {
                    *pcDirs += 1;
                }
                else
                {
                    *pcFiles += 1;
                }
            }
        }

        pwszToken = wcstok(NULL, L";");
    }

    delete [] pwszTemp;
    return TRUE;
}

/*++

 Function Description:

    Since the user specifies both files and dirs in the list, we allocate
    a single array for all of them and fill the directories in the beginning
    and the files at the end.
    
    Format of the list: 
    AC-%APPDRIVE%\a\;PU-%APPPATH%\b.txt
    A means to redirect to the all-user directory.
    P means to redirect to the per-user directory.
    C means the item is checked.
    U means the item is not checked.

 Arguments:

    IN pwszList - The redirect list.
    IN fStatic - is this the static list?

 Return Value:

    TRUE - successfully processed the list.
    FALSE - otherwise.

 History:

    05/16/2001 maonis  Created
    10/24/2001 maonis  Modified

--*/
BOOL
ProcessRedirectionList(
    LPCWSTR pwszList
    )
{
    if (!pwszList || !*pwszList)
    {
        return TRUE;
    }

    DPF("RedirectFS", eDbgLevelInfo,
        "[ProcessRedirectionList] The list is %S", pwszList);

    DWORD cList = 0;
    LPWSTR pwszExpandList = ExpandItem(
        pwszList, 
        &cList, 
        FALSE,  // Don't need to ensure the trailing slash.
        FALSE,  // Not applicable.
        FALSE); // Not applicable.

    if (!pwszExpandList)
    {
        DPF("RedirectFS", eDbgLevelError,
            "[ProcessRedirectionList] Error expanding %S", pwszList);

        return FALSE;
    }

    g_fHasRedirectList = TRUE;

    LPWSTR pwsz = (LPWSTR)pwszExpandList;    
    LPWSTR pwszToken = pwsz;
    DWORD cLen, dwIndex;
    BOOL fIsDirectory;
    WCHAR ch;

    RITEM* pRItems;

    while (TRUE)
    {
        if (*pwsz == L';' || *pwsz == L'\0')
        {
            ch = *pwsz;
            *pwsz = L'\0';
 
            SkipBlanksW(pwszToken);
            TrimTrailingSpaces(pwszToken);

            cLen = wcslen(pwszToken);
            
            //
            // each item should at least have XX-X:\ at the beginning.
            // 
            if (cLen >= 6)
            {
                //
                // Check if we should use this item or not.
                //
                if (pwszToken[1] == L'U')
                {
                    goto NEXT;
                }

                if (cLen - 3 >= MAX_PATH)
                {
                    DPF("RedirectFS", eDbgLevelError,
                        "[ProcessRedirectionList] File name has %d chars - we don't "
                        "handle filenames that long", 
                        cLen - 3);

                    delete [] pwszExpandList;

                    return FALSE;
                }

                //
                // Check if it's a file or dir.
                //
                if (pwszToken[cLen - 1] == L'\\')
                {
                    dwIndex = g_cRItemsDir;
                    pRItems = g_pRItemsDir;
                    ++g_cRItemsDir;
                    fIsDirectory = TRUE;
                }
                else
                {
                    dwIndex = g_cRItemsFile;
                    pRItems = g_pRItemsFile;
                    ++g_cRItemsFile;
                    fIsDirectory = FALSE;
                }

                pRItems[dwIndex].fAllUser = (pwszToken[0] == L'A');
                wcscpy(pRItems[dwIndex].wszName, pwszToken + 3);
                pRItems[dwIndex].fHasWC = HasWildCards(pwszToken + 3, cLen - 3);
                MassageName(pRItems[dwIndex].wszName);
                pRItems[dwIndex].cLen = wcslen(pRItems[dwIndex].wszName);

                DPF("RedirectFS", eDbgLevelInfo,
                    "[ProcessRedirectionList] Added %s %d in list: --%S--", 
                    fIsDirectory ? "DIR" : "FILE", dwIndex, pRItems[dwIndex].wszName);
            }

        NEXT:

            pwszToken = pwsz + 1;

            if (ch == L'\0')
            {
                break;
            }
        }

        ++pwsz;
    }

    delete [] pwszExpandList;

    return TRUE;
}

/*++

 Function Description:

    The path can use enviorment variables plus %APPPATH% and %APPDRIVE%.

 Arguments:

    IN pwszDir - The redirect dir.
    IN fAllUser - is this dir for redirecting all user files?

 Return Value:

    TRUE - successfully processed the dir.
    FALSE - otherwise.

 History:

    05/16/2001 maonis  Created
    10/24/2001 maonis  Modified

--*/
BOOL 
ProcessRedirectDir(
    LPCWSTR pwszDir,
    BOOL fAllUser
    )
{
    if (!pwszDir || !*pwszDir)
    {
        //
        // If the redirect dir is empty nothing left to do so return now.
        //
        return TRUE;
    }

    DWORD cRedirectRoot = 0;
    LPWSTR pwszExpandDir = ExpandItem(
        pwszDir, 
        &cRedirectRoot, 
        TRUE,   // It's a directory.
        TRUE,   // Create the dir if it doesn't exist.
        TRUE);  // Add the \\?\ prefix.
    if (pwszExpandDir)
    {
        LPWSTR pwszRedirectRoot = (fAllUser ? g_wszRedirectRootAllUser : g_wszRedirectRootPerUser);

        //
        // The return length includes the terminating NULL.
        //
        if (cRedirectRoot > MAX_PATH)
        {
            DPF("RedirectFS", eDbgLevelInfo, 
                "[ProcessRedirectDir] Expand dir %S has %d chars - we don't "
                "handle path that long",
                pwszExpandDir,
                cRedirectRoot - 1);
        }

        wcscpy(pwszRedirectRoot, pwszExpandDir);

        --cRedirectRoot;

        if (fAllUser) 
        {
            g_cRedirectRootAllUser = cRedirectRoot;
        }
        else
        {
            g_cRedirectRootPerUser = cRedirectRoot;
        }

        delete [] pwszExpandDir;
        DPF("RedirectFS", eDbgLevelInfo, 
            "[ProcessRedirectDir] Files will be redirected to %S for %s instead of "
            "the default redirect directory",
            (fAllUser ? g_wszRedirectRootAllUser : g_wszRedirectRootPerUser),
            (fAllUser ? "All User files" : "Per User files"));

        return TRUE;
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[ProcessRedirectDir] Error expanding %S", pwszDir);

        return FALSE;
    }
}

extern "C" {
DWORD
SdbQueryDataExTagID(
    IN     PDB     pdb,               // database handle
    IN     TAGID   tiShim,            // tagid  of the shim
    IN     LPCTSTR lpszDataName,      // if this is null, will try to return all the data tag names
    OUT    LPDWORD lpdwDataType,      // pointer to data type (REG_SZ, REG_BINARY, etc)
    OUT    LPVOID  lpBuffer,          // buffer to fill with information
    IN OUT LPDWORD lpdwBufferSize,    // pointer to buffer size
    OUT    TAGID*  ptiData            // optional pointer to the retrieved data tag
    );
};

BOOL
GetDBStringData(
    const PDB pdb,
    const TAGID tiFix,
    LPCWSTR pwszName,
    CString& strValue
    )
{
    DWORD dwError, dwDataType, cSize = 0;

    if ((dwError = SdbQueryDataExTagID(
        pdb, 
        tiFix, 
        pwszName, 
        &dwDataType, 
        NULL, 
        &cSize, 
        NULL)) != ERROR_INSUFFICIENT_BUFFER) {
    
        DPF("RedirectFS", eDbgLevelError, "[GetDBStringData] Cannot get the size for DATA named %S", pwszName);

        //
        // If the data doesn't exist, there's nothing left to do.
        //
        return (dwError == ERROR_NOT_FOUND);
    }

    LPWSTR pwszValue = new WCHAR [cSize / sizeof(WCHAR)];

    if (pwszValue == NULL) {
        DPF("RedirectFS", eDbgLevelError, "[GetDBStringData] Failed to allocate %d bytes", cSize);
        return FALSE;
    }

    if ((dwError = SdbQueryDataExTagID(
        pdb, 
        tiFix, 
        pwszName, 
        &dwDataType, 
        pwszValue, 
        &cSize, 
        NULL)) != ERROR_SUCCESS) {

        DPF("RedirectFS", eDbgLevelError, "[GetDBStringData] Cannot read the VALUE of DATA named %S", pwszName);
        return FALSE;
    }
 
    strValue = pwszValue;
    delete [] pwszValue;

    return TRUE;
}

/*++

 Function Description:

    The xml looks like:

    <SHIM NAME="LUARedirectFS" COMMAND_LINE="%DbInfo%">

        <DATA NAME="AllUserDir" VALUETYPE="STRING"
                VALUE="%ALLUSERSPROFILE%\AllUserRedirect"/>

        <DATA NAME="PerUserDir" VALUETYPE="STRING"
                VALUE="%USERSPROFILE%\Redirect"/>

        <DATA NAME="StaticList" VALUETYPE="STRING"
                VALUE="AC-%APPDRIVE%\a\;PU-%APPPATH%\b.txt"/>

        <DATA NAME="DynamicList" VALUETYPE="STRING"
                VALUE="AC-%APPPATH%\b\;PU-c:\b\b.txt;AU-c:\c\"/>

    </SHIM>

    and the compiler will replace %DbInfo% with the actual db info, something like:

    -d{40DEBB3B-E9BF-4129-B4D8-A7F7017F3B45} -t0xf2

    We use the guid following -d to obtain the pdb and the tagid following -t to obtain
    the tagid for the shim.

 Arguments:

    IN pwszCommandLine - the command line that contains the database guid and the shim tagid.

 Return Value:

    TRUE - successfully read the <DATA> sections for the shim if any.
    FALSE - otherwise.

 History:

    10/25/2001 maonis  Created

--*/
BOOL
ReadLuaDataFromDB(
    LPWSTR pwszCommandLine
    )
{
    LPWSTR pwszGUID = wcsstr(pwszCommandLine, L"-d");

    if (!pwszGUID) 
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] Something is really wrong!! "
            "Invalid commandline: %S", pwszCommandLine); 
        return FALSE;        
    }

    pwszGUID += 2;

    LPWSTR pwszTagId = wcsstr(pwszGUID, L"-t");

    if (!pwszTagId)
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] Something is really wrong!! "
            "Invalid commandline: %S", pwszCommandLine); 
        return FALSE;        
    }

    *(pwszTagId - 1) = L'\0';
    pwszTagId += 2;
    
    //
    // Get the GUID for this database.
    //
    GUID guidDB;
    if (!SdbGUIDFromString(pwszGUID, &guidDB))
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] Error converting %S to a guid", pwszGUID); 
        return FALSE;
    }

    WCHAR wszDatabasePath[MAX_PATH];
    PDB pdb;

    if (SdbResolveDatabase(&guidDB, NULL, wszDatabasePath, MAX_PATH))
    {
        //
        // now szDatabasePath contains the path to the database, open it 
        //
        if (!(pdb = SdbOpenDatabase(wszDatabasePath, DOS_PATH)))
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[ReadLuaDataFromDB] Error opening the database");
            return FALSE;
        }
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] Error resolving the path to the database");
        return FALSE;
    }
    
    LPWSTR pwszTagIdEnd = pwszTagId + wcslen(pwszTagId);
    TAGID tiShimRef = (TAGID)wcstoul(pwszTagId, &pwszTagIdEnd, 0);

    if (tiShimRef == TAGID_NULL) 
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] The shimref is invalid");
        return FALSE;
    }

    CString strAllUserDir, strPerUserDir, strStaticList, strDynamicList;
    
    if (!GetDBStringData(pdb, tiShimRef, L"AllUserDir", strAllUserDir) ||
        !GetDBStringData(pdb, tiShimRef, L"PerUserDir", strPerUserDir) ||
        !GetDBStringData(pdb, tiShimRef, L"StaticList", strStaticList) ||
        !GetDBStringData(pdb, tiShimRef, L"DynamicList", strDynamicList) ||
        !GetDBStringData(pdb, tiShimRef, L"ExcludedExtensions", g_strDefaultExclusionList))
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] Error reading values from the db");
        return FALSE;
    }

    //
    // Set the APPPATH and APPDRIVE enviorment variables.
    //
    WCHAR wszModuleName[MAX_PATH + 1];

    //
    // GetModuleFileNameW is an awful API. If you don't pass in a buffer 
    // that's big enough to hold the module (including the terminating NULL), it
    // returns the passed in buffer size (NOT the required length) which means
    // it doesn't return an error - it just fills upto the passed in buffer size
    // so does NOT NULL terminate the string. So we set the last char to NULL and
    // make sure it doesn't get overwritten.
    //
    wszModuleName[MAX_PATH] = L'\0';

    DWORD dwRes = GetModuleFileNameW(NULL, wszModuleName, MAX_PATH + 1);

    if (!dwRes)
    {
        DPF("RedirectFS", eDbgLevelError,
            "[ReadLuaDataFromDB] GetModuleFileNameW failed: %d",
            GetLastError());

        return FALSE;
    }

    if (wszModuleName[MAX_PATH] != L'\0')
    {
        DPF("RedirectFS", eDbgLevelError,
            "[ReadLuaDataFromDB] File name is longer than MAX_PATH, "
            "we don't handle file names that long");

        return FALSE;
    }

    LPWSTR pwsz = wszModuleName;
    LPWSTR pwszLastSlash = wcsrchr(pwsz, L'\\');

    if (!pwszLastSlash) 
    {
        DPF("RedirectFS", eDbgLevelError, "[ReadLuaDataFromDB] Error getting the exe path!");
        return FALSE;
    }

    *pwszLastSlash = L'\0';
    SetEnvironmentVariable(L"APPPATH", pwsz);
    *(pwsz + 2) = L'\0';
    SetEnvironmentVariable(L"APPDRIVE", pwsz);

    DWORD cFiles = 0;
    DWORD cDirs = 0;

    if (!GetListItemCount(strStaticList, &cFiles, &cDirs) || 
        !GetListItemCount(strDynamicList, &cFiles, &cDirs))
    {
        DPF("RedirectFS", eDbgLevelError,
            "[ProcessRedirectionList] Failed to get the count of items in list");

        return FALSE;
    }

    g_pRItemsFile = new RITEM [cFiles];
    g_pRItemsDir = new RITEM [cDirs];

    if (!g_pRItemsFile || !g_pRItemsDir)
    {
        DPF("RedirectFS", eDbgLevelError,
            "[ProcessRedirectionList] Failed to allocate the global redirect item lists");

        return FALSE;
    }

    if (!ProcessRedirectDir(strAllUserDir, TRUE) ||
        !ProcessRedirectDir(strPerUserDir, FALSE) ||
        !ProcessRedirectionList(strStaticList) ||
        !ProcessRedirectionList(strDynamicList))
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] Error processing values from the db");
        return FALSE;
    }

    DPF("RedirectFS", eDbgLevelInfo,
        "[ProcessRedirectionList] There are %d DIRs and %d FILES in the lists", 
        g_cRItemsDir, g_cRItemsFile);

    return TRUE;
}

#define LUA_DEFAULT_ALLUSER_DIR L"%ALLUSERSPROFILE%\\Application Data\\Redirected\\"
#define LUA_DEFAULT_PERUSER_DIR L"%USERPROFILE%\\Application Data\\Redirected\\"

/*++

 Function Description:
    
    The default redirect dir for per user is AppData\Redirected
    \\?\c:\Documents And Settings\user\Application Data\Redirected

    The default redirect dir for all user is AppData\Redirected
    \\?\c:\Documents And Settings\All Users\Application Data\Redirected

 Arguments:

    pwszDir - buffer for the dir.
    fAllUser - is it for all user or per user?

 Return Value:

    TRUE - successfully created the dir if necessary.
    FALSE - otherwise.

 History:

    10/24/2001 maonis  Created

--*/
BOOL
GetAppDataRedirectDir(
    LPWSTR pwszRedirectDir,
    DWORD* pcRedirectDir,
    BOOL fAllUser
    )
{
    WCHAR wszDir[MAX_PATH] = L"";
    BOOL fIsSuccess = FALSE;

    DWORD cRedirectRoot = 0;
    LPWSTR pwszExpandDir = ExpandItem(
        (fAllUser ? LUA_DEFAULT_ALLUSER_DIR : LUA_DEFAULT_PERUSER_DIR), 
        &cRedirectRoot, 
        TRUE,   // It's a directory.
        FALSE,  // The directory has to exist.
        TRUE);  // Add the \\?\ prefix.
    if (pwszExpandDir)
    {
        if (cRedirectRoot > MAX_PATH)
        {
            DPF("RedirectFS", eDbgLevelError,
                "[GetAppDataRedirectDir] expand dir is %S which is %d chars long - "
                "we don't handle path names that long",
                pwszExpandDir,
                cRedirectRoot - 1);
        }
        else
        {
            wcsncpy(pwszRedirectDir, pwszExpandDir, cRedirectRoot);
            *pcRedirectDir = cRedirectRoot - 1;

            fIsSuccess = TRUE;

            if (!fAllUser)
            {
                //
                // The all user redirect dir should have been created by
                // installing the sdb. Create the root of the per user 
                // redirect dir if need to.
                //
                fIsSuccess = CreateDirectoryOnDemand(pwszRedirectDir + FILE_NAME_PREFIX_LEN);
            }
        }

        delete [] pwszExpandDir;
    }

    return fIsSuccess;
}

/*++

 Function Description:

    If the all-user and/or per-user redirect dirs hasn't been specified, we need to construct the
    default ones.

 Arguments:

    None.

 Return Value:

    TRUE - successfully constructed the default dirs if necessary.
    FALSE - otherwise.

 History:

    10/24/2001 maonis  Created

--*/
BOOL
ConstructDefaultRDirs()
{
    if (g_wszRedirectRootAllUser[0] == L'\0')
    {
        if (!GetAppDataRedirectDir(g_wszRedirectRootAllUser, &g_cRedirectRootAllUser, TRUE)) 
        {
            return FALSE;
        }
    }

    if (g_wszRedirectRootPerUser[0] == L'\0')
    {
        if (!GetAppDataRedirectDir(g_wszRedirectRootPerUser, &g_cRedirectRootPerUser, FALSE)) 
        {
            return FALSE;
        }
    }

    return TRUE;
}

#define LUA_APPCOMPAT_FLAGS_PATH L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags"
#define LUA_DEFAULT_EXCLUSION_LIST L"LUADefaultExclusionList"

/*++

 Function Description:

    Getting the default exclusion list from the registry. It's the 
    LUADefaultExclusionList value of the 
    HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags
    key.
    
    We use NT APIs so they are garanteed to be initialized during
    PROCESS_ATTACH.

 Arguments:
    
    None.

 Return Value:

    TRUE - if we successfully got the value.
    FALSE - otherwise. We don't want to blindly redirect everything because
            we failed to get the default exclusion list.

 History:

    12/08/2001 maonis  Created

--*/
BOOL
GetDefaultExclusionList()
{
    UNICODE_STRING ustrKeyPath = {0}; 
    UNICODE_STRING ustrValue;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    BYTE* KeyValueBuffer = NULL;
    ULONG KeyValueLength, KeyValueLengthRequired;
    BOOL fIsSuccess = FALSE;

    RtlInitUnicodeString(&ustrKeyPath, LUA_APPCOMPAT_FLAGS_PATH);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &ustrKeyPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtOpenKey(
        &KeyHandle,
        KEY_QUERY_VALUE,
        &ObjectAttributes);

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        //
        // If this key doesn't exist, nothing left to do.
        //
        return TRUE;
    }

    if (!NT_SUCCESS(Status)) 
    {
        DPF("RedirectFS", 
            eDbgLevelError,
            "[GetDefaultExclusionList] ",
            "Failed to open Key %S Status 0x%x",
            LUA_APPCOMPAT_FLAGS_PATH,
            Status);
        return FALSE;
    }

    //
    // Get the length of the value.
    //
    RtlInitUnicodeString(&ustrValue, LUA_DEFAULT_EXCLUSION_LIST);

    Status = NtQueryValueKey(
        KeyHandle,
        &ustrValue,
        KeyValuePartialInformation,
        NULL,
        0,
        &KeyValueLengthRequired);

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        //
        // If this value doesn't exist, nothing left to do.
        //
        return TRUE;
    }

    if (Status != STATUS_BUFFER_OVERFLOW && 
        Status != STATUS_BUFFER_TOO_SMALL)
    {
        DPF("RedirectFS", 
            eDbgLevelError,
            "[GetDefaultExclusionList] ",
            "Failed to get the length of the value named %S for key %S Status 0x%x",
            LUA_DEFAULT_EXCLUSION_LIST,
            LUA_APPCOMPAT_FLAGS_PATH,
            Status);
        return FALSE;
    }

    KeyValueBuffer = (BYTE*)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, KeyValueLengthRequired);
    KeyValueLength = KeyValueLengthRequired;

    if (KeyValueBuffer == NULL)
    {
        DPF("RedirectFS", 
            eDbgLevelError,
            "[GetDefaultExclusionList] ",
            "Failed to allocate %d bytes for value %S",
            LUA_DEFAULT_EXCLUSION_LIST);
        return FALSE;
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;

    Status = NtQueryValueKey(
        KeyHandle,
        &ustrValue,
        KeyValuePartialInformation,
        KeyValueInformation,
        KeyValueLength,
        &KeyValueLengthRequired);

    NtClose(KeyHandle);

    if (!NT_SUCCESS(Status)) 
    {
        DPF("RedirectFS", 
            eDbgLevelError,
            "[GetDefaultExclusionList] "
            "Failed to read value info for value %S Status 0x%x",
            LUA_DEFAULT_EXCLUSION_LIST,
            Status);

        goto EXIT;
    }

    //
    // Check for the value type.
    //
    if (KeyValueInformation->Type != REG_SZ) 
    {
        DPF("RedirectFS", eDbgLevelError,
            "[GetDefaultExclusionList] "
            "Unexpected value type 0x%x for %S",
            KeyValueInformation->Type,
            LUA_DEFAULT_EXCLUSION_LIST);

        goto EXIT;
    }

    g_strDefaultExclusionList = (LPWSTR)KeyValueInformation->Data;

    fIsSuccess = TRUE;

EXIT:

    RtlFreeHeap(RtlProcessHeap(), 0, KeyValueBuffer);

    return fIsSuccess;
}

BOOL 
LuapParseCommandLine(
    LPCSTR pszCommandLine
    )
{
    BOOL fIsSuccess = TRUE;

    if (pszCommandLine && pszCommandLine[0] != '\0')
    {
        LPWSTR pwszCommandLine = AnsiToUnicode(pszCommandLine);

        if (!pwszCommandLine)
        {
            DPF("RedirectFS", eDbgLevelError,
                "[LuapParseCommandLine] Failed to convert command line to unicode");

            return FALSE;
        }
        
        fIsSuccess = ReadLuaDataFromDB(pwszCommandLine);

        if (fIsSuccess)
        {
            g_fIsConfigured = TRUE;
        }

        delete [] pwszCommandLine;
    }

    if (fIsSuccess)
    {
        //
        // If it's successful, we need to construct the redirect dirs if they haven't
        // been specified.
        // Note we don't try to construct the dirs that haven't been constructed if
        // any error occured!! Because we don't want to redirect things that the user
        // doesn't want to redirect.
        //
        fIsSuccess = ConstructDefaultRDirs();
    }

    return fIsSuccess;
}

BOOL
LuaFSInit(
    LPCSTR pszCommandLine
    )
{
    InitializeListHead(&g_DeletedFileList);

    return (
        GetDefaultExclusionList() && 
        LuapParseCommandLine(pszCommandLine) &&
        g_ExcludedExtensions.Init(g_strDefaultExclusionList));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\redirectreg.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    LUA_RedirectReg.h

 Notes:

    This is a general purpose shim.

 History:

    02/14/2001 maonis  Created

--*/

#ifndef _LUA_REDIRECT_REG_H_
#define _LUA_REDIRECT_REG_H_

BOOL
DoesKeyExist(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey
    );

struct DELETEDKEY
{
    LIST_ENTRY entry;

    // This is something like HKLM\Software\Company\Key.
    LPWSTR pwszPath;
    DWORD cLen;
};

PLIST_ENTRY FindDeletedKey(
    LPCWSTR pwszPath,
    BOOL* pfIsSubKey = NULL
    );

//
// Check if the path exists in the deletion list, if not, add it to
// the beginning of the list.
//
LONG AddDeletedKey(
    LPCWSTR pwszPath
    );

extern LIST_ENTRY g_DeletedKeyList; 

//
// The reg class that does all the real work.
//

class CRedirectedRegistry
{
public:

    VOID Init()
    {
        InitializeListHead(&g_DeletedKeyList);
    }

    //
    // (The explanation of the merged view of HKCR in MSDN is very wrong - 
    // see NT #507506)
    // As a limited user, you'll always get access denied if you try to 
    // create a key under HKCR even when its immediate parent exists in HKCU.
    // You can, however, create or modify values in HKCR which will be reflected
    // in HKCU\Software\Classes, not HKLM\Softeware\Classes.
    //
    LONG OpenKeyA(
        HKEY hKey,
        LPCSTR lpSubKey,
        LPSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        BOOL fCreate,
        BOOL fForceRedirect = FALSE
        );

    LONG OpenKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPWSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        BOOL fCreate,
        BOOL fForceRedirect = FALSE
        );

    //
    // RegQueryValue and RegQueryValueEx can and should share the same
    // method because we can use RegQueryValueEx to find out if a value
    // has never been set or has been specifically set to an empty string.
    //
    // RegQueryValue can't tell the difference between the former and the 
    // latter - it will return ERROR_SUCCESS in both cases and set the value
    // to an empty sring.
    //
    // On the other hand, RegQueryValueEx returns ERROR_FILE_NOT_FOUND 
    // if the default value has never been set. 
    //
    // We should always use RegQueryValueEx so we know if we should look at 
    // the original location.
    //
    // For RegQueryValue we also need to open the subkey with KEY_QUERY_VALUE
    // if it's not NULL or an empty string.
    //
    LONG 
    QueryValueW(
        HKEY    hKey,
        LPCWSTR lpSubKey,
        LPCWSTR lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData,
        BOOL    fIsVersionEx // Is this a RegQueryValue or RegQueryValueEx?
        );

    LONG 
    QueryValueA(
        HKEY    hKey,
        LPCSTR  lpSubKey,
        LPCSTR  lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData,
        BOOL    fIsVersionEx // Is this a RegQueryValue or RegQueryValueEx?
        );

    //
    // RegSetValue and RegSetValueEx also share the same implementation but
    // we have to do something special for RegSetValue:
    // 1) ignore the cbData and pass in the string length including terminating
    //    NULL (note that RegQueryValue doesn't have the same behavior).
    // 2) create/open the subkey with KEY_SET_VALUE if it's not NULL or an 
    //    empty string.
    //
    LONG SetValueA(
        HKEY hKey, 
        LPCSTR lpSubKey,
        LPCSTR lpValueName, 
        DWORD Reserved, 
        DWORD dwType, 
        CONST BYTE * lpData, 
        DWORD cbData,
        BOOL fIsVersionEx // Is this a RegQueryValue or RegQueryValueEx?
        );

    LONG SetValueW(
        HKEY hKey, 
        LPCWSTR lpSubKey,
        LPCWSTR lpValueName, 
        DWORD Reserved, 
        DWORD dwType, 
        CONST BYTE * lpData, 
        DWORD cbData,
        BOOL fIsVersionEx // Is this a RegQueryValue or RegQueryValueEx?
        );

    //
    // Notes of enum API hooks:
    //
    // We need to enum at the redirected location first then enum the keys/values
    // at the original location that don't exist at the redirected location *unless*:
    //
    // 1) It's not redirected (HKCU keys are not redirected for example);
    // 2) It's a predefined key, in which case we won't find it in the openkey list;
    //
    // Note we also merge the HKCR keys by ourselves so we can check if the key is 
    // in the deletion list.
    //

    LONG EnumValueA(
        HKEY hKey,
        DWORD dwIndex,
        LPSTR lpValueName,
        LPDWORD lpcbValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData
        );

    LONG EnumValueW(
        HKEY hKey,
        DWORD dwIndex,
        LPWSTR lpValueName,
        LPDWORD lpcbValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData
        );

    LONG EnumKeyA(
        HKEY hKey,
        DWORD dwIndex,
        LPSTR lpName,
        LPDWORD lpcbName,
        LPDWORD lpReserved,
        LPSTR lpClass,
        LPDWORD lpcbClass,
        PFILETIME lpftLastWriteTime 
        );

    LONG EnumKeyW(
        HKEY hKey,
        DWORD dwIndex,
        LPWSTR lpName,
        LPDWORD lpcbName,
        LPDWORD lpReserved,
        LPWSTR lpClass,
        LPDWORD lpcbClass,
        PFILETIME lpftLastWriteTime 
        );

    LONG CloseKey(
        HKEY hKey
        );

    //
    // Notes of delete key:
    //
    // We only add the key to the deletion list if we get access denied. If we get,
    // file not found, we don't need to add because as an admin it won't succeed 
    // anyway.
    // 
    // HKCR keys are a special case. The only case that I've seen is with Corel 
    // draw 10 where it enums a key, then deletes it. So the first time it'll delete
    // the key in HKCU, the 2nd time it'll try to delete the one in HKLM - and we'll
    // add it to the deletion list. So next time enum won't include it.
    // 

    LONG DeleteKeyA(
        HKEY hKey,
        LPCSTR lpSubKey
        );

    LONG DeleteKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey
        );

    LONG QueryInfoKey(
        HKEY hKey,
        LPDWORD lpReserved,
        LPDWORD lpcSubKeys,
        LPDWORD lpcbMaxSubKeyLen,
        LPDWORD lpcbMaxClassLen,
        LPDWORD lpcValues,
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,
        BOOL    fIsW // Do you want the W or the A version?
        );

private:

    struct ENUMENTRY
    {
        WCHAR wszName[MAX_PATH + 1];
        BOOL fIsRedirected;
    };

    struct REDIRECTKEY;
    struct OPENKEY
    {
        OPENKEY *next;
        
        HKEY hKey;
        HKEY hkBase;

        // Was this key redirected?
        BOOL fIsRedirected;

        LPWSTR pwszFullPath;

        // This is the same as pwszPath in REDIRECTKEY
        LPWSTR pwszPath;
        DWORD cPathLen;

        CLUAArray<ENUMENTRY> subkeys;
        CLUAArray<ENUMENTRY> values;
        DWORD cMaxSubKeyLen;
        DWORD cMaxValueLen;
        DWORD cSubKeys;
        DWORD cValues;
        BOOL fNeedRebuild;

        LONG BuildEnumLists(REDIRECTKEY* pKey);

        //
        // From MSDN:
        //
        // "While an application is using the RegEnumKey function, it should not 
        // make calls to any registration functions that might change the key 
        // being queried."
        //
        // Nonetheless, some apps do. So if we detect a key/value change we 
        // delete the enum list so it gets rebuilt next time.
        // 
        // The more efficient way would be to only change keys/values that get
        // modified but it adds very much complexity to the code - you could
        // create multiple keys at a time by one RegCreateKey call if the 
        // intermediate keys don't exist - we'd have to check things like that.
        // 
        VOID DeleteEnumLists();

    private:

        VOID AddSubKey(
            REDIRECTKEY* pKey,
            LPWSTR pwszFullPath,
            ENUMENTRY& entry
            );

        VOID AddValue(
            ENUMENTRY& entry
            );

        LONG BuildEnumList(
            REDIRECTKEY* pKey,
            BOOL fEnumKeys
            );
    };

    struct REDIRECTKEY
    {
        REDIRECTKEY(
            OPENKEY* keyParent,
            HKEY hKey,
            LPCWSTR lpSubKey);

        ~REDIRECTKEY()
        {
            delete [] pwszFullPath;
            pwszPath = NULL;
            pwszFullPath = NULL;
            hkBase = NULL;
            fIsRedirected = FALSE;
            hkRedirectRoot = 0;
        }

        //
        // This is something like HKLM\Software\Company\KeyNeedRedirect or
        // HKCR\appid\something.
        // When we add the key to the deletion list, we use this path.
        //
        LPWSTR pwszFullPath;
        DWORD cFullPathLen; // Doesn't include the terminating NULL.

        //
        // For classes root keys this is g_hkCurrentUserClasses; for other keys 
        // this is g_hkRedirectRoot.
        // 
        HKEY hkRedirectRoot;

        //
        // This is the path without the top level key. So it's like
        // Software\Company\KeyNeedRedirect. 
        // When we want to create a key, we use this path. eg, creating the key
        // at the redirected location.
        //
        LPWSTR pwszPath;
        DWORD cPathLen; // Doesn't include the terminating NULL.

        HKEY hkBase;

        BOOL fIsRedirected;
    };

    OPENKEY* FindOpenKey(
        HKEY hKey
        );

    BOOL HandleDeleted(
        OPENKEY* pOpenKey
        );

    LONG AddOpenKey(
        HKEY hKey,
        REDIRECTKEY* rk,
        BOOL fIsRedirected
        );

    LONG OpenKeyOriginalW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPWSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        BOOL bCreate
        );

    LONG QueryValueOriginalW(
        HKEY    hKey,
        LPCWSTR lpSubKey,
        LPCWSTR lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData,
        BOOL    fIsVersionEx // Is this a RegQueryValue or RegQueryValueEx?
        );

    LONG DeleteLMCRKeyNotRedirected(
        REDIRECTKEY* pKey
        );

    BOOL HasSubkeys(
        HKEY hKey,
        LPCWSTR lpSubKey
        );

    BOOL
    ShouldCheckEnumAlternate(
        HKEY hKey,
        REDIRECTKEY* pKey
        )
    {
        return ((!IsPredefinedKey(hKey)) || (pKey && pKey->fIsRedirected));
    }

    OPENKEY* m_OpenKeyList;
};

#endif // _LUA_REDIRECT_REG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\redirectfs_cleanup.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   RedirectFS_Cleanup.cpp

 Abstract:

   Delete the redirected copies in every user's directory.

 Created:

   03/30/2001 maonis

 Modified:

--*/

#include "precomp.h"
#include "utils.h"

// Stores the redirected path for each user.
// eg, d:\documents and settings\someuser\Local Settings\Application Data\Redirected\.
static REDIRECTED_USER_PATH* g_rup = NULL;

// Number of users that have a Redirected directory.
static DWORD g_cUsers = 0;

static BOOL g_fDefaultRedirect = TRUE;

static WCHAR g_wszRedirectRootAllUser[MAX_PATH] = L"";
static DWORD g_cRedirectRootAllUser = 0; // Doesn't include the terminating NULL.

#define ALLUSERS_APPDATA L"%ALLUSERSPROFILE%\\Application Data\\"
#define REDIRECTED_DIR L"Redirected\\"
#define REDIRECTED_DIR_LEN (sizeof(REDIRECTED_DIR) / sizeof(WCHAR) - 1)

// This struct has a unicode buffer of MAX_PATH length. We only allocate memory
// on the heap if the path is longer than MAX_PATH.
struct MAKEREDIRECT
{
    MAKEREDIRECT() 
    {
        pwszRedirectedPath = NULL;
    }

    ~MAKEREDIRECT() 
    {
        delete [] pwszRedirectedPath;
    }

    LPWSTR 
    ConvertToRedirect(
        LPCWSTR pwszOriginal
        )
    {
        if (pwszOriginal)
        {
            LPWSTR pwszNew = wszRedirectedPath;
            DWORD cFileNameSize = wcslen(pwszOriginal);
            DWORD cSize = g_cRedirectRootAllUser + cFileNameSize;

            if (cSize > MAX_PATH)
            {
                if (pwszRedirectedPath)
                {
                    delete [] pwszRedirectedPath;
                }

                // Need to allocate memory for this long file name.
                pwszRedirectedPath = new WCHAR [cSize];
                if (!pwszRedirectedPath)
                {
                    return NULL;
                }
            }

            // Now we have a big enough buffer, convert to redirected path.
            wcsncpy(pwszNew, g_wszRedirectRootAllUser, g_cRedirectRootAllUser);
            // Get the drive letter.
            pwszNew[g_cRedirectRootAllUser] = *pwszOriginal;
            wcsncpy(pwszNew + g_cRedirectRootAllUser + 1, pwszOriginal + 2, cFileNameSize - 2);
            pwszNew[g_cRedirectRootAllUser + (cSize - 1)] = L'\0';
            
            return pwszNew;
        }

        return NULL;
    }

private:

    WCHAR wszRedirectedPath[MAX_PATH];
    WCHAR* pwszRedirectedPath;
};

// For APIs that probe if the file is there, we return TRUE if 
// it exists at the original location or ANY user's redirected location.
// Normally an uninstall program doesn't call FindNextFile - it keeps a list
// of files it installed and uses FindFirstFile to verify if the file 
// exists then call FindClose.
HANDLE 
LuacFindFirstFileW(
    LPCWSTR lpFileName,               
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    if (!g_fDefaultRedirect)
    {
        return FindFirstFileW(lpFileName, lpFindFileData);
    }

    DPF("RedirectFS_Cleanup", eDbgLevelInfo, 
        "[FindFirstFileW] lpFileName=%S", lpFileName);

    HANDLE hFind;

    if ((hFind = FindFirstFileW(lpFileName, lpFindFileData)) == INVALID_HANDLE_VALUE &&
        IsErrorNotFound())
    {
        // If we can't find the file at the original location, we try to find it at 
        // an alternate location.
        MAKEREDIRECT md;
        LPWSTR pwszRedirected;

        pwszRedirected = md.ConvertToRedirect(lpFileName);

        if (pwszRedirected)
        {
            hFind = FindFirstFileW(pwszRedirected, lpFindFileData);
        }
    }

    return hFind;
}

DWORD 
LuacGetFileAttributesW(
    LPCWSTR lpFileName
    )
{
    if (!g_fDefaultRedirect)
    {
        return GetFileAttributesW(lpFileName);
    }

    DPF("RedirectFS_Cleanup", eDbgLevelInfo, 
        "[GetFileAttributesW] lpFileName=%S", lpFileName);

    DWORD dwRes;

    if ((dwRes = GetFileAttributesW(lpFileName)) == -1 && IsErrorNotFound())
    {
        // If we can't find the file at the original location, we try to find it at 
        // an alternate location.
        MAKEREDIRECT md;
        LPWSTR pwszRedirected;

        pwszRedirected = md.ConvertToRedirect(lpFileName);

        if (pwszRedirected)
        {
            dwRes = GetFileAttributesW(pwszRedirected);
        }
    }

    return dwRes;
}

// Some uninstallers use CreateFile to probe that the file is there and can be written to.
HANDLE 
LuacCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    if (!g_fDefaultRedirect)
    {
        return CreateFileW(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
    }

    DPF("RedirectFS_Cleanup", eDbgLevelInfo, 
        "[GetFileAttributesW] lpFileName=%S", lpFileName);

    HANDLE hFile;

    if ((hFile = CreateFileW(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile)) == INVALID_HANDLE_VALUE && 
        IsErrorNotFound())
    {
        // If we can't find the file at the original location, we try to find it at 
        // an alternate location.
        MAKEREDIRECT md;
        LPWSTR pwszRedirected;

        pwszRedirected = md.ConvertToRedirect(lpFileName);

        if (pwszRedirected)
        {
            hFile = CreateFileW(
                pwszRedirected,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes,
                hTemplateFile);
        }
    }

    return hFile;
}

// If we can delete the file at either the original location or any user's redireted path,
// we return TRUE.
BOOL 
LuacDeleteFileW(
    LPCWSTR lpFileName
    )
{
    if (!g_fDefaultRedirect)
    {
        return DeleteFileW(lpFileName);
    }

    DPF("RedirectFS_Cleanup", eDbgLevelInfo, 
        "[DeleteFileW] lpFileName=%S", lpFileName);

    BOOL fFinalRes = FALSE;

    if (DeleteFileW(lpFileName))
    {
        fFinalRes = TRUE;
    }

    MAKEREDIRECT md;
    LPWSTR pwszRedirected;

    pwszRedirected = md.ConvertToRedirect(lpFileName);

    if (pwszRedirected && DeleteFileW(pwszRedirected))
    {
        fFinalRes = TRUE;
    }

    return fFinalRes;
}

BOOL 
LuacRemoveDirectoryW(
    LPCWSTR lpPathName
    )
{
    if (!g_fDefaultRedirect)
    {
        return RemoveDirectoryW(lpPathName);
    }

    DPF("RedirectFS_Cleanup", eDbgLevelInfo, 
        "[RemoveDirectoryW] lpPathName=%S", lpPathName);

    BOOL fFinalRes = FALSE;

    if (RemoveDirectoryW(lpPathName))
    {
        fFinalRes = TRUE;
    }

    MAKEREDIRECT md;
    LPWSTR pwszRedirected;

    pwszRedirected = md.ConvertToRedirect(lpPathName);
    
    if (pwszRedirected && RemoveDirectoryW(pwszRedirected))
    {
        fFinalRes = TRUE;
    }

    return fFinalRes;
}

VOID 
DeleteObject(
    LPCWSTR pwsz
    )
{
    //
    // If the object is read-only we need to unset that attribute.
    //
    DWORD dw = GetFileAttributesW(pwsz);

    if (dw != -1)
    {
        if (dw & FILE_ATTRIBUTE_READONLY)
        {
            dw &= ~FILE_ATTRIBUTE_READONLY;
            SetFileAttributesW(pwsz, dw);
        }

        if (dw & FILE_ATTRIBUTE_DIRECTORY)
        {
            RemoveDirectoryW(pwsz);
        }
        else
        {
            DeleteFileW(pwsz);
        }
    }
}

VOID 
DeleteFolder(
    CString& strFolder
    )
{
    DPF("RedirectFS_Cleanup", eDbgLevelSpew, 
        "[DeleteFolder] Deleting %S", (LPCWSTR)strFolder);
    CString strPattern(strFolder); 
    strPattern += L"*";

    WIN32_FIND_DATAW fd;
    HANDLE hFind = FindFirstFileW(strPattern, &fd);

    if (hFind == INVALID_HANDLE_VALUE)
    {
        return;
    }

    do
    {
        if (!wcscmp(fd.cFileName, L".") || !wcscmp(fd.cFileName, L".."))
        {
            continue;
        }
        else if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            CString strTmpDir = strFolder + fd.cFileName + L"\\";
            DeleteFolder(strTmpDir);
        }
        else
        {
            CString strTmpFile = strFolder + fd.cFileName;
            DeleteObject(strTmpFile);
        }
    }
    while (FindNextFileW(hFind, &fd));

    FindClose(hFind);

    DeleteObject(strFolder);
}

VOID
DeleteAllRedirectedDirs(
    REDIRECTED_USER_PATH* pRedirectUserPaths, 
    DWORD cUsers,
    LPCWSTR pwszAppName
    )
{
    //
    // Delete the redirect dir for each user.
    //
    for (DWORD i = 0; i < cUsers; ++i)
    {
        CString strRedirectDir = pRedirectUserPaths[i].pwszPath;
        strRedirectDir += L"\\Application Data\\";
        strRedirectDir += pwszAppName;
        strRedirectDir += L"\\";

        DeleteFolder(strRedirectDir);
    }

    //
    // Delete the redirect dir for all users.
    //
    CString strAllUserRedirectDir = g_wszRedirectRootAllUser;
    strAllUserRedirectDir += pwszAppName;
    DeleteFolder(strAllUserRedirectDir);
}

BOOL
LuacFSInit(
    LPCSTR pszCommandLine
    )
{
    DPF("RedirectFS_Cleanup", eDbgLevelInfo, "===================================\n");
    DPF("RedirectFS_Cleanup", eDbgLevelInfo, "        LUA FS Cleanup Shim        \n");
    DPF("RedirectFS_Cleanup", eDbgLevelInfo, "===================================\n");
    DPF("RedirectFS_Cleanup", eDbgLevelInfo, "appname                            \n");
    DPF("RedirectFS_Cleanup", eDbgLevelInfo, "-----------------------------------");

    //
    // We need to get the ALLUSERSPROFILE dir in any case.
    //
    ZeroMemory(g_wszRedirectRootAllUser, MAX_PATH * sizeof(WCHAR));

    DWORD cRedirectRoot = 0;
    LPWSTR pwszExpandDir = ExpandItem(
        ALLUSERS_APPDATA,
        &cRedirectRoot,
        TRUE,   // It's a directory.
        FALSE,  // The directory has to exist.
        TRUE);  // Add the \\?\ prefix.
    if (pwszExpandDir)
    {
        if (cRedirectRoot + REDIRECTED_DIR_LEN > MAX_PATH)
        {
            DPF("RedirectFS_Cleanup", eDbgLevelError,
                "[LuacFSInit] The redirect path %S is too long - we don't handle it",
                pwszExpandDir);

            delete [] pwszExpandDir;
            return FALSE;
        }

        wcscpy(g_wszRedirectRootAllUser, pwszExpandDir);
        g_cRedirectRootAllUser = cRedirectRoot - 1;

        delete [] pwszExpandDir;
    }

    if (pszCommandLine && pszCommandLine[0] != '\0')
    {
        LPWSTR pwszCommandLine = AnsiToUnicode(pszCommandLine);

        if (pwszCommandLine)
        {
            //
            // If the user specified an appname on the commandline, it means all the
            // redirected files will be either in SomeUserProfile\Application Data\appname
            // or AllUsersProfile\Application Data\appname. We just need to delete those
            // directories.
            //
            GetUsersFS(&g_rup, &g_cUsers);
            
            DeleteAllRedirectedDirs(g_rup, g_cUsers, pwszCommandLine);

            FreeUsersFS(g_rup);

            delete [] pwszCommandLine;
        }
        else
        {
            DPF("RedirectFS_Cleanup", eDbgLevelError, 
                "[LuapParseCommandLine] Failed to allocate memory for commandline");
        }

        g_fDefaultRedirect = FALSE;
    }
    else
    {
        //
        // If the user didn't specify anything on the commandline, it means the files
        // were redirected to the default location - %ALLUSERSPROFILE%\Application Data\Redirected.
        //
        wcsncpy(g_wszRedirectRootAllUser + g_cRedirectRootAllUser, REDIRECTED_DIR, REDIRECTED_DIR_LEN);
        g_cRedirectRootAllUser += REDIRECTED_DIR_LEN;
    }

    return TRUE;
}

VOID
LuacFSCleanup(
    )
{   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

!ENDIF

INCLUDES=$(INCLUDES);                       \
         ..;                                \
         $(SHELL_INC_PATH);                 \
         $(BASE_INC_PATH);                  \
         $(WINDOWS_INC_PATH)

TARGETNAME=AcLua

TARGETTYPE=DYNLINK

SOURCES=..\ver.rc                          \
        ..\utils.cpp                       \
        ..\RedirectFS.cpp                  \
        ..\LUA_RedirectFS.cpp              \
        ..\RedirectReg.cpp                 \
        ..\LUA_RedirectReg.cpp             \
        ..\RedirectFS_Cleanup.cpp          \
        ..\LUA_RedirectFS_Cleanup.cpp      \
        ..\RedirectReg_Cleanup.cpp         \
        ..\LUA_RedirectReg_Cleanup.cpp     \
        ..\TrackFS.cpp                     \
        ..\LUA_TrackFS.cpp                 \
        ..\main.cpp 

DLLDEF=..\lua.def

C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -D___TARGETNAME=#$(TARGETNAME).DLL -DSHIM_HOOKDLL_VERSION2

TARGETPATH=$(_OBJ_DIR)

TARGETLIBS=$(TARGETLIBS)                        \
           $(SDK_LIB_PATH)\ntdll.lib            \
           $(SDK_LIB_PATH)\kernel32.lib         \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\userenv.lib          \
           $(SDK_LIB_PATH)\uuid.lib             \
           $(SDK_LIB_PATH)\version.lib          \
           ..\..\..\sdbAPI\lib\$(O)\sdbapil.lib


DLLBASE=0x24000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\redirectreg.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    LUA_RedirectReg.cpp

 Abstract:

    Redirect the reg keys to current user hive when the app needs to 
    write to them but doesn't have enough access rights.

 Notes:

    This is a general purpose shim.

 History:

    02/14/2001 maonis  Created

    05/30/2001 maonis  Exported the APIs that ntvdm needs to implement LUA 
                       stuff. Added RegQueryInfoKey hook because WOWRegDeleteKey
                       calls it.

    12/13/2001 maonis  BIG changes:
                       1) Changed to redirect keys to HKCU\Software\Redirected.
                          HKCR keys are a special case.
                       2) Merge keys at the redirect location and the original
                          location for enum.
                       3) Added an in-memory deletion list to record keys being
                          deleted.
--*/

#include "precomp.h"
#include "utils.h"
#include "RedirectReg.h"

extern HKEY g_hkRedirectRoot;
extern HKEY g_hkCurrentUserClasses;
LIST_ENTRY g_DeletedKeyList;

LONG
AddDeletedKey(
    LPCWSTR pwszPath
    )
{
    PLIST_ENTRY pEntry = FindDeletedKey(pwszPath);

    if (pEntry == NULL)
    {
        DELETEDKEY* pNewKey = new DELETEDKEY;

        if (pNewKey)
        {
            DWORD cLen = wcslen(pwszPath);
            pNewKey->pwszPath = new WCHAR [cLen + 1];

            if (pNewKey->pwszPath)
            {
                ZeroMemory(pNewKey->pwszPath, sizeof(WCHAR) * (cLen + 1));

                wcscpy(pNewKey->pwszPath, pwszPath);
                pNewKey->cLen = cLen;
                InsertHeadList(&g_DeletedKeyList, &pNewKey->entry);

                DPF("RedirectReg", eDbgLevelInfo,
                    "[AddDeletedKey] Added %S to the deletion list",
                    pwszPath);

                return ERROR_SUCCESS;
            }
            else
            {
                DPF("RedirectReg", eDbgLevelError,
                    "[AddDeletedKey] Failed to allocate %d WCHARs",
                    cLen);

                delete pNewKey;
            }
        }
        else
        {
            DPF("RedirectReg", eDbgLevelError,
                "[AddDeletedKey] Failed to allocate a DELETEKEY");
        }
    }

    return ERROR_NOT_ENOUGH_MEMORY;
}

/*++

 Function Description:
    
    Find out if the key is supposed to be deleted.

 Arguments:

    IN pwszPath - path to the key

 Return Value:

    TRUE - The key itself or its parent key is in the deletion list.
    FALSE - Otherwise.

 History:

    12/14/2001 maonis  Created

--*/

PLIST_ENTRY 
FindDeletedKey(
    LPCWSTR pwszPath,
    BOOL* pfIsSubKey
    )
{
    DELETEDKEY* pItem;
    WCHAR ch;
    DWORD cLen = wcslen(pwszPath);

    for (PLIST_ENTRY pEntry = g_DeletedKeyList.Flink; 
        pEntry != &g_DeletedKeyList; 
        pEntry = pEntry->Flink) 
    {
        pItem = CONTAINING_RECORD(pEntry, DELETEDKEY, entry);

        if (cLen >= pItem->cLen)
        {
            ch = pwszPath[pItem->cLen];

            if (!_wcsnicmp(pItem->pwszPath, pwszPath, pItem->cLen) && 
                (ch == L'\0' || ch == L'\\')) 
            {
                DPF("RedirectReg", eDbgLevelInfo,
                    "[FindDeletedKey] Found %S in the deletion list",
                    pwszPath);

                if (pfIsSubKey)
                {
                    *pfIsSubKey = (ch == L'\\');
                }

                return pEntry;
            }
        }
    }

    return NULL;
}

VOID
MakePathForPredefinedKey(
    LPWSTR pwszPath, // is garanteed to have room for at least 4 characters.
    HKEY hKey
    )
{
    if (hKey == HKEY_CLASSES_ROOT)
    {
        wcscpy(pwszPath, L"HKCR");
    }
    else if (hKey == HKEY_CURRENT_USER)
    {
        wcscpy(pwszPath, L"HKCU");
    }
    else if (hKey == HKEY_LOCAL_MACHINE)
    {
        wcscpy(pwszPath, L"HKLM");
    }
    else
    {
        DPF("RedirectReg", eDbgLevelError,
            "[MakePathForPredefinedKey] We shouldn't get here!!! "
            "Something is really wrong.");

#ifdef DBG
        DebugBreak();
#endif 
    }
}

/*++

 Function Description:

    Given either the OPENKEY* or the handle for the parent key and the
    subkey path, construct the redirect location for this subkey.

    We construct the redirect location for HKCR keys specially - we
    need to redirect the key to the normal redirect location and 
    HKCU\Software\Classes.

    We don't store the base key for HKCR keys as HKCR because we want 
    to make the redirection work when the app specifically asks for
    HKLM\Software\Classes keys. So we always convert HKCR to 
    HKLM\Software\Classes.

 Arguments:

    IN keyParent - the parent key info.
    IN hKey - the handle value of this key.
    IN lpSubKey - path of the subkey that this key opened.

 Return Value:

    None.

 History:

    12/13/2001 maonis  Created

--*/

CRedirectedRegistry::REDIRECTKEY::REDIRECTKEY(
    OPENKEY* keyParent,
    HKEY hKey,
    LPCWSTR lpSubKey
    )
{
    pwszPath = NULL;
    pwszFullPath = NULL;
    hkBase = NULL;
    fIsRedirected = FALSE;
    hkRedirectRoot = 0;

    //
    // First make sure the redirect location is there.
    //
    if (g_hkRedirectRoot == NULL)
    {
        if (GetRegRedirectKeys() != ERROR_SUCCESS)
        {
            DPF("RedirectReg", eDbgLevelError,
                "[REDIRECTKEY::REDIRECTKEY] Failed to open/create the root keys??!! "
                "something is really wrong");
#ifdef DBG
            DebugBreak();
#endif
            return;
        }
    }

    //
    // Calculate the length of the key path so we know how much space to allocate.
    //
    LPWSTR pwszParentPath = NULL;
    DWORD cLen = 4; // 4 chars for the predefined key.
    DWORD cLenSubKey = 0;

    if (keyParent)
    {
        hkBase = keyParent->hkBase;

        if (hkBase != HKEY_LOCAL_MACHINE && hkBase != HKEY_CLASSES_ROOT)
        {
            return;
        }

        pwszParentPath = keyParent->pwszPath;

        if (pwszParentPath && *pwszParentPath)
        {
            cLen += keyParent->cPathLen + 1; // Need to count the '\'
        }

        fIsRedirected = keyParent->fIsRedirected;
    }
    else if (IsPredefinedKey(hKey))
    {
        hkBase = hKey;

        if (hkBase == HKEY_CURRENT_USER)
        {
            return;
        }
    }
    else
    {
#ifdef DBG
        if (hKey == HKEY_PERFORMANCE_DATA )
        {
            DPF("RedirectReg", eDbgLevelError,
                "[REDIRECTKEY::REDIRECTKEY] We don't handle performance data keys");
        }
        else if (hKey == HKEY_USERS)
        {
            DPF("RedirectReg", eDbgLevelError,
                "[REDIRECTKEY::REDIRECTKEY] We don't handle HKUS keys",
                hKey);
        }
        else
        {
            DPF("RedirectReg", eDbgLevelError,
                "[REDIRECTKEY::REDIRECTKEY] 0x%08x is an invalid open key handle",
                hKey);
        }
#endif 
        return;
    }

    //
    // Add the length of the subkey.
    //
    if (lpSubKey)
    {
        cLenSubKey = wcslen(lpSubKey);

        if (cLenSubKey)
        {
            //
            // Make room for the '\' before the subkey.
            //
            cLen += cLenSubKey + 1;
        }
    }
    
    if (cLen < 5)
    {
        //
        // We are opening a top level key.
        //
        return;
    }

    //
    // Allocate memory for the key path.
    //
    pwszFullPath = new WCHAR [cLen + 1];

    if (!pwszFullPath)
    {
        DPF("RedirectReg", eDbgLevelError,
            "[REDIRECTKEY::REDIRECTKEY] Failed to allocate %d WCHARs for redirect path",
            cLen + 1);

        return;
    }

    ZeroMemory(pwszFullPath, sizeof(WCHAR) * (cLen + 1));

    MakePathForPredefinedKey(pwszFullPath, hkBase);

    if (keyParent)
    {
        if (pwszParentPath && *pwszParentPath)
        {
            pwszFullPath[4] = L'\\';
            wcscpy(pwszFullPath + 5, pwszParentPath);
        }
    }

    if (cLenSubKey)
    {
        wcscat(pwszFullPath, L"\\");
        wcscat(pwszFullPath, lpSubKey);
    }

    cFullPathLen = cLen;
    cPathLen = cLen - 5;
    pwszPath = pwszFullPath + 5;

    hkRedirectRoot = (hkBase == HKEY_CLASSES_ROOT ? 
                        g_hkCurrentUserClasses : 
                        g_hkRedirectRoot);
}

VOID 
CRedirectedRegistry::OPENKEY::AddSubKey(
    REDIRECTKEY* pKey,
    LPWSTR pwszFullPath,
    ENUMENTRY& entry
    )
{
    //
    // Form the full path of the subkey.
    //
    wcsncpy(pwszFullPath, pKey->pwszFullPath, pKey->cFullPathLen);
    pwszFullPath[pKey->cFullPathLen] = L'\\';
    wcscpy(pwszFullPath + pKey->cFullPathLen + 1, entry.wszName);

    //
    // Check if this key is in the deletion list. If not, we'll add it.
    //
    PLIST_ENTRY pDeletedEntry = FindDeletedKey(pwszFullPath);
    if (pDeletedEntry)
    {
        return;
    }

    DWORD cLen = wcslen(entry.wszName);
    if (cLen > cMaxSubKeyLen)
    {
        cMaxSubKeyLen = cLen;
    }

    subkeys.SetAtGrow(cSubKeys, entry);
    ++cSubKeys;
}

VOID 
CRedirectedRegistry::OPENKEY::AddValue(
    ENUMENTRY& entry
    )
{
    DWORD cLen = wcslen(entry.wszName);
    if (cLen > cMaxValueLen)
    {
        cMaxValueLen = cLen;
    }

    values.SetAtGrow(cValues, entry);
    ++cValues;
}

LONG 
CRedirectedRegistry::OPENKEY::BuildEnumList(
    REDIRECTKEY* pKey,
    BOOL fEnumKeys
    )
{
    CLUAArray<ENUMENTRY>* pHead = (fEnumKeys ? &subkeys : &values);

    PLIST_ENTRY pDeletedEntry = FindDeletedKey(pKey->pwszFullPath);
    if (pDeletedEntry)
    {
        return ERROR_FILE_NOT_FOUND;
    }

    //
    // We allocate a big enough buffer for our subkey so we can check if 
    // it's in the deletion list.
    //
    LPWSTR pwszSubKey = new WCHAR [pKey->cFullPathLen + MAX_PATH + 1];

    if (!pwszSubKey)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory(pwszSubKey, sizeof(WCHAR) * (pKey->cFullPathLen + MAX_PATH + 1));

    DWORD cMaxLen = 0;

    //
    // First find out which keys/values exist at the redirected location.
    // If we are calling this it means the key has to be redirected.
    //
    DWORD dwIndex = 0;
    DWORD i, cArraySize, cLen;
    LONG lRes;
    HKEY hKeyAlternate = 0;
    HKEY hKeyOriginal = 0;
    ENUMENTRY entry;
    entry.fIsRedirected = TRUE;
    DWORD dwSize = MAX_PATH + 1;

    //
    // First opend the key with KEY_READ access.
    //
    lRes = RegOpenKeyEx(
        pKey->hkRedirectRoot,
        pKey->pwszPath,
        0,
        KEY_READ,
        &hKeyAlternate);

    if (lRes == ERROR_SUCCESS)
    {
        while (TRUE)
        {
            if (fEnumKeys)
            {
                lRes = RegEnumKeyW(
                    hKeyAlternate,
                    dwIndex,
                    entry.wszName,
                    dwSize);
            }
            else
            {
                dwSize = MAX_PATH + 1;

                lRes = RegEnumValueW(
                    hKeyAlternate,
                    dwIndex,
                    entry.wszName,
                    &dwSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
            }

            if (lRes == ERROR_SUCCESS)
            {
                if (fEnumKeys)
                {
                    AddSubKey(pKey, pwszSubKey, entry);
                }
                else
                {
                    AddValue(entry);
                }
            }
            else if (lRes != ERROR_NO_MORE_ITEMS)
            {
                goto EXIT;
            }
            else
            {
                //
                // No more items at the redirected location. We need to look
                // at the original location now.
                //
                break;
            }

            ++dwIndex;
        }
    }

    dwIndex = 0;
    entry.fIsRedirected = FALSE;

    //
    // First opend the key with KEY_READ access.
    //
    if ((lRes = RegOpenKeyEx(
        pKey->hkBase,
        pKey->pwszPath,
        0,
        KEY_READ,
        &hKeyOriginal)) == ERROR_SUCCESS)
    {
        while (TRUE)
        {
            if (fEnumKeys)
            {
                lRes = RegEnumKeyW(
                    hKeyOriginal,
                    dwIndex,
                    entry.wszName,
                    dwSize);
            }
            else
            {
                dwSize = MAX_PATH + 1;

                lRes = RegEnumValueW(
                    hKeyOriginal,
                    dwIndex,
                    entry.wszName,
                    &dwSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
            }

            if (lRes == ERROR_SUCCESS)
            {
                //
                // Check if this key/value already exists at the redirected location.
                //
                cArraySize = (fEnumKeys ? cSubKeys : cValues);
                for (i = 0; i < cArraySize; ++i)
                {
                    if (!_wcsnicmp(entry.wszName, pHead->GetAt(i).wszName, MAX_PATH + 1))
                    {
                        break;
                    }
                }

                if (i == cArraySize)
                {
                    if (fEnumKeys)
                    {
                        AddSubKey(pKey, pwszSubKey, entry);
                    }
                    else
                    {
                        AddValue(entry);
                    }
                }
            }
            else if (lRes != ERROR_NO_MORE_ITEMS)
            {
                goto EXIT;
            }
            else
            {
                //
                // No more items at the redirected location. We need to look
                // at the original location now.
                //
                break;
            }

            ++dwIndex;
        }
    }
    else
    {
        //
        // If any other errors occured(eg, ERROR_FILE_NOT_FOUND), we just don't 
        // enum at the original location - it's still a success.
        //
        lRes = ERROR_SUCCESS;
    }

EXIT:

    if (hKeyAlternate)
    {
        RegCloseKey(hKeyAlternate);
    }

    if (hKeyOriginal)
    {
        RegCloseKey(hKeyOriginal);
    }

    if (lRes == ERROR_NO_MORE_ITEMS)
    {
        lRes = ERROR_SUCCESS;
    }

    delete [] pwszSubKey;

    return lRes;
}

LONG
CRedirectedRegistry::OPENKEY::BuildEnumLists(REDIRECTKEY* pKey)
{
    DeleteEnumLists();

    cSubKeys = 0;
    cValues = 0;
    cMaxSubKeyLen = 0;
    cMaxValueLen = 0;
    subkeys.SetSize(10);
    values.SetSize(10);

    LONG lRes;

    if ((lRes = BuildEnumList(pKey, TRUE)) == ERROR_SUCCESS)
    {
        if ((lRes = BuildEnumList(pKey, FALSE)) == ERROR_SUCCESS)
        {
            fNeedRebuild = FALSE;
        }
    }

    return lRes;
}

VOID 
CRedirectedRegistry::OPENKEY::DeleteEnumLists()
{
    subkeys.SetSize(0);
    values.SetSize(0);
}

/*++

 Function Description:
    
    When you call RegCreateKeyEx, it's supposed to tell you if the key was created
    or already existed in lpdwDisposition. Unfortunately this is not reliable - 
    it always returns REG_OPENED_EXISTING_KEY even when the key was created. 
    So we are checking the existence using RegOpenKeyEx. If we can't even read 
    a value off it, we treat it as not existing.

 Arguments:

    IN hKey - the key handle.
    IN lpSubKey - subkey to check.

 Return Value:

    TRUE - This key exists.
    FALSE - This key doesn't exist.

 History:

    03/27/2001 maonis  Created

--*/

BOOL
DoesKeyExist(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey
    )
{
    HKEY hkProbe;

    if (RegOpenKeyExW(
        hKey, 
        lpSubKey,
        0,
        KEY_QUERY_VALUE,
        &hkProbe) == ERROR_SUCCESS)
    {
        RegCloseKey(hkProbe);
        return TRUE;
    }

    return FALSE;
}

//
// locking stuff.
//

static BOOL g_bInitialized = FALSE;

CRITICAL_SECTION g_csRegRedirect;

class CRRegLock
{
public:
    CRRegLock()
    {
        if (!g_bInitialized)
        {
            InitializeCriticalSection(&g_csRegRedirect);
            g_bInitialized = TRUE;            
        }

        EnterCriticalSection(&g_csRegRedirect);
    }
    ~CRRegLock()
    {
        LeaveCriticalSection(&g_csRegRedirect);
    }
};

// ------------------------------------------------
// Implementation of the CRedirectedRegistry class.
// ------------------------------------------------

CRedirectedRegistry::OPENKEY* 
CRedirectedRegistry::FindOpenKey(
    HKEY hKey
    )
{
    OPENKEY* key = m_OpenKeyList;

    while (key)
    {
        if (key->hKey == hKey)
        {
            return key;
        }

        key = key->next;
    }

    return NULL;
}

BOOL 
CRedirectedRegistry::HandleDeleted(
    OPENKEY* pOpenKey
    )
{
    if (pOpenKey && pOpenKey->pwszFullPath)
    {
        if (FindDeletedKey(pOpenKey->pwszFullPath))
        {
            DPF("RedirectReg", eDbgLevelError,
                "%S (0x%08x) has been deleted",
                pOpenKey->pwszFullPath,
                pOpenKey->hKey);

            return TRUE;
        }
    }

    return FALSE;
}


// We add the key to the front of the list because the most
// recently added keys are usually used first.
LONG 
CRedirectedRegistry::AddOpenKey(
    HKEY hKey,
    REDIRECTKEY* rk,
    BOOL fIsRedirected
    )
{
    OPENKEY* key = new OPENKEY;
    if (!key)
    {
        DPF("RedirectReg", eDbgLevelError, 
            "Error allocating memory for a new OPENKEY");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    key->hKey = hKey;
    key->hkBase = rk->hkBase;
    key->fIsRedirected = fIsRedirected;
    key->fNeedRebuild = TRUE;

    //
    // If rk->pwszPath is NULL, it means it was either one of the
    // keys we don't handle, HKCU, or a bad handle.
    // In any of those cases, we won't be needing the path anyway.
    //
    if (rk->pwszPath)
    {
        key->pwszFullPath = new WCHAR [rk->cFullPathLen + 1];

        if (key->pwszFullPath)
        {
            wcscpy(key->pwszFullPath, rk->pwszFullPath);
            key->pwszPath = key->pwszFullPath + 5;
            key->cPathLen = rk->cPathLen;
        }
        else
        {
            delete key;

            DPF("RedirectReg", eDbgLevelError, 
                "Error allocating memory for %d WCHARs",
                rk->cPathLen + 1);

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    key->next = m_OpenKeyList;
    m_OpenKeyList = key;

    return ERROR_SUCCESS;
}

LONG 
CRedirectedRegistry::OpenKeyOriginalW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL bCreate
    )
{
    if (bCreate)
    {
        return RegCreateKeyExW(
            hKey, 
            lpSubKey,
            0,
            lpClass,
            dwOptions,
            samDesired,
            lpSecurityAttributes,
            phkResult,
            lpdwDisposition);
    }
    else
    {
        return RegOpenKeyExW(
            hKey, 
            lpSubKey, 
            0, 
            samDesired, 
            phkResult);
    }
}

LONG 
CRedirectedRegistry::OpenKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL fCreate,
    BOOL fForceRedirect
    )
{
    LPWSTR pwszSubKey = NULL; 
    LPWSTR pwszClass = NULL;

    if (lpSubKey)
    {
        if (!(pwszSubKey = AnsiToUnicode(lpSubKey)))
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[CRedirectedRegistry::OpenKeyExA] "
                "Failed to convert lpSubKey to unicode");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (lpClass)
    {
        if (!(pwszClass = AnsiToUnicode(lpClass)))
        {
            delete [] pwszSubKey;
            DPF("RedirectReg", eDbgLevelError, 
                "[CRedirectedRegistry::OpenKeyExA] "
                "Failed to convert lpClass to unicode");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    LONG lRes = OpenKeyW(
        hKey,
        pwszSubKey,
        pwszClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition,
        fCreate,
        fForceRedirect);

    delete [] pwszSubKey;
    delete [] pwszClass;

    return lRes;
}

/*++

 Function Description:

    Algorithm:
    
    Only create a redirected key under 2 conditions:
    
    1. fForceRedirect is TRUE.
    or 
    2. fCreate is TRUE and the key doesn't exist at the original location.

    The reason we do this is to avoid creating extra keys that
    are not going to be cleaned up by the uninstaller. In any 
    other case we open the key with the desired access.

 Arguments:

    IN hKey - key handle.
    IN lpSubKey - subkey to open or create.
    IN lpClass - address of a class string.
    IN DWORD dwOptions - special options flag.
    IN samDesired - desired access.
    OUT phkResult - handle to open key if successful
    OUT lpdwDisposition - address of disposition value buffer
    IN fCreate - TRUE if it's RegCreate*; FALSE if RegOpen*.
    IN fForceRedirect - this key should be redirected.

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    02/16/2001 maonis  Created
    01/08/2002 maonis  Updated

--*/

LONG 
CRedirectedRegistry::OpenKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL fCreate,
    BOOL fForceRedirect
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[OpenKeyW] %s key: hKey=0x%08x; lpSubKey=%S", 
        (fCreate ? "Creating" : "Opening"),
        hKey, 
        lpSubKey);

    LONG lRes = ERROR_FILE_NOT_FOUND;
    BOOL fIsRedirected = FALSE;
    OPENKEY* key = FindOpenKey(hKey);
    if (HandleDeleted(key))
    {
        return ERROR_KEY_DELETED;
    }

    REDIRECTKEY rk(key, hKey, lpSubKey);

    if (rk.pwszFullPath)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[OpenKeyW] key path is %S", rk.pwszFullPath);

        // 
        // Find if this key has been "deleted". If so we can fail the open 
        // requests now.
        // 
        PLIST_ENTRY pDeletedEntry = FindDeletedKey(rk.pwszFullPath);
        if (pDeletedEntry && !fCreate)
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[OpenKeyW] %S was already deleted, failing open call",
                rk.pwszFullPath);

            return ERROR_FILE_NOT_FOUND;
        }

        if (fCreate)
        {
            if (DoesKeyExist(rk.hkRedirectRoot, rk.pwszPath))
            {
                // If it already exists at the redirect location, we open it.
                lRes = RegCreateKeyExW(
                    rk.hkRedirectRoot, 
                    rk.pwszPath,
                    0,
                    lpClass,
                    dwOptions,
                    samDesired,
                    lpSecurityAttributes,
                    phkResult,
                    lpdwDisposition);

                fIsRedirected = TRUE;
            }
        }
        else
        {
            if ((lRes = RegOpenKeyExW(
                rk.hkRedirectRoot,
                rk.pwszPath,
                0,
                samDesired,
                phkResult)) == ERROR_SUCCESS)
            {
                fIsRedirected = TRUE;
            }
        }

        if (lRes == ERROR_FILE_NOT_FOUND)
        {
            lRes = OpenKeyOriginalW(
                rk.hkBase,
                rk.pwszPath,
                lpClass,
                dwOptions,
                samDesired,
                lpSecurityAttributes,
                phkResult,
                lpdwDisposition,
                fCreate);

            //if (fForceRedirect || (fCreate && !DoesKeyExist(rk.hkBase, rk.pwszPath)))

            {
                if (lRes == ERROR_ACCESS_DENIED)
                {
                    // Create the redirect key.
                    lRes = RegCreateKeyExW(
                        rk.hkRedirectRoot, 
                        rk.pwszPath, 
                        0,
                        NULL,
                        dwOptions,
                        samDesired,
                        NULL,
                        phkResult,
                        lpdwDisposition);

                    if (lRes == ERROR_SUCCESS)
                    {
                        fIsRedirected = TRUE;
                    }
                }
            }

            //
            // We need to remove this key from the deletion list if it was 
            // succesfully created.
            //
            if (lRes == ERROR_SUCCESS && pDeletedEntry)
            {
                DPF("RedirectReg", eDbgLevelInfo, 
                    "[CRedirectedRegistry::OpenKeyW] Removed %S "
                    "from the deletion list because we just created it",
                    rk.pwszFullPath);

                RemoveEntryList(pDeletedEntry);
            }
        }
    }
    else
    {
        lRes = OpenKeyOriginalW(
            hKey,
            lpSubKey,
            lpClass,
            dwOptions,
            samDesired,
            lpSecurityAttributes,
            phkResult,
            lpdwDisposition,
            fCreate);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[OpenKeyW] Successfully created key 0x%08x", *phkResult);

        if ((lRes = AddOpenKey(*phkResult, &rk, fIsRedirected)) != ERROR_SUCCESS)
        {
            DPF("RedirectReg", eDbgLevelError, "[OpenKeyW] Failed to add key 0x%08x", *phkResult);
        }
    }
    else
    {
        if (rk.pwszFullPath)
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[OpenKeyW] Failed to %s key %S: %d", 
                (fCreate ? "Creating" : "Opening"),
                rk.pwszFullPath,
                lRes);
        }
        else
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[OpenKeyW] Failed to %s key: %d", 
                (fCreate ? "Creating" : "Opening"),
                lRes);
        }
    }

    return lRes;
}

LONG 
CRedirectedRegistry::QueryValueOriginalW(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData,
    BOOL    fIsVersionEx
    )
{
    if (fIsVersionEx)
    {
        HKEY hSubKey;

        LONG lRes = RegOpenKeyExW(hKey, lpSubKey, 0, KEY_QUERY_VALUE, &hSubKey);

        if (lRes == ERROR_SUCCESS)
        {
            lRes = RegQueryValueExW(
                hSubKey, 
                lpValueName, 
                lpReserved,
                lpType, 
                lpData, 
                lpcbData);

            RegCloseKey(hSubKey);
        }

        return lRes;
    }
    else
    {
        if (lpType)
        {
            *lpType = REG_SZ;
        }

        return RegQueryValue(hKey, lpSubKey, (LPWSTR)lpData, (PLONG)lpcbData);
    }
}

LONG 
CRedirectedRegistry::QueryValueW(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData,
    BOOL    fIsVersionEx
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[QueryValueW] Querying value: hKey=0x%08x; lpSubKey=%S; lpValueName=%S", 
        hKey, lpSubKey, lpValueName);

    LONG lRes = ERROR_FILE_NOT_FOUND;
    OPENKEY* key = FindOpenKey(hKey);

    if (HandleDeleted(key))
    {
        return ERROR_KEY_DELETED;
    }

    REDIRECTKEY rk(key, hKey, lpSubKey);

    if (rk.pwszFullPath)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[QueryValueW] key path is %S", rk.pwszFullPath);

        HKEY hKeyRedirect = 0;

        //
        // For RegQueryValue we need to remember if the subkey exists at the
        // redirect location.
        //
        BOOL fRedirectKeyExist = FALSE;

        if (lpSubKey && *lpSubKey)
        {
            //
            // If it's from RegQueryValue we need to check if this key has been 
            // deleted; Else we should have already checked its existence when we 
            // obtained the handle.
            //
            if (FindDeletedKey(rk.pwszFullPath))
            {
                DPF("RedirectReg", eDbgLevelError, 
                    "[QueryValueW] %S was already deleted, failing query value call",
                    rk.pwszFullPath);

                return ERROR_FILE_NOT_FOUND;
            }
        }

        if ((lRes = RegOpenKeyExW(
            rk.hkRedirectRoot,
            rk.pwszPath,
            0,
            KEY_QUERY_VALUE,
            &hKeyRedirect)) == ERROR_FILE_NOT_FOUND)
        {
            goto CHECKORIGINAL;
        }
        else if (lRes != ERROR_SUCCESS)
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[QueryValueW] Querying value failed: %d", lRes);

            return lRes;
        }

        fRedirectKeyExist = TRUE;

        lRes = RegQueryValueExW(
            hKeyRedirect,
            lpValueName,
            lpReserved,
            lpType,
            lpData, 
            lpcbData);

        if (hKeyRedirect)
        {
            RegCloseKey(hKeyRedirect);
        }
        
CHECKORIGINAL:

        if (lRes == ERROR_FILE_NOT_FOUND)
        {
            //
            // We'd only goto the original location if it failed with file not found.
            //            
            lRes = QueryValueOriginalW(
                rk.hkBase,
                rk.pwszPath,
                lpValueName,
                lpReserved,
                lpType,
                lpData,
                lpcbData,
                fIsVersionEx);

            if (!fIsVersionEx && (lRes != ERROR_SUCCESS) && fRedirectKeyExist)
            {
                //
                // If it is RegQueryValue we need to fix up the return values.
                //
                lRes = ERROR_SUCCESS;

                if (lpData)
                {
                    *lpData = 0;
                }

                if (lpcbData)
                {
                    //
                    // RegQueryValue only querys strings so set the length to 2 for
                    // a unicode empty string.
                    //
                    *lpcbData = 2;
                }
            }
        }
    }
    else
    {
        return QueryValueOriginalW(
            hKey,
            lpSubKey,
            lpValueName,
            lpReserved,
            lpType,
            lpData,
            lpcbData,
            fIsVersionEx);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[QueryValueW] Querying value succeeded: data is %S", (lpData ? (LPCWSTR)lpData : L""));
    }
    else
    {
        if (rk.pwszFullPath)
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[QueryValueW] Querying value %S at %S failed: %d", 
                lpValueName,
                rk.pwszFullPath,
                lRes);
        }
        else
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[QueryValueW] Querying value failed: %d", lRes);
        }
    }

    return lRes;
}

LONG 
CRedirectedRegistry::QueryValueA(
    HKEY    hKey,
    LPCSTR  lpSubKey,
    LPCSTR  lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData,
    BOOL    fIsVersionEx
    )
{
    if (lpData && !lpcbData)
    {
        return ERROR_INVALID_PARAMETER;
    }

    LPWSTR pwszSubKey = NULL;
    LPWSTR pwszValueName = NULL;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    LPBYTE pbData = NULL;
    LONG lRes = ERROR_FILE_NOT_FOUND;

    //
    // App might call this without passing in the type so we just double the buffer 
    //
    if (lpcbData)
    {
        dwSize = *lpcbData * 2;
        pbData = new BYTE [dwSize];

        if (!pbData)
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[CRedirectedRegistry::QueryValueA] Failed to allocated %d bytes",
                dwSize);

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        pbData = NULL;
    }

    if (lpSubKey)
    {
        if (!(pwszSubKey = AnsiToUnicode(lpSubKey)))
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[CRedirectedRegistry::QueryValueA] "
                "Failed to convert lpSubKey to unicode");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (lpValueName)
    {
        if (!(pwszValueName = AnsiToUnicode(lpValueName)))
        {
            delete [] pwszSubKey;
            DPF("RedirectReg", eDbgLevelError, 
                "[CRedirectedRegistry::QueryValueA] "
                "Failed to convert lpValueName to unicode");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ((lRes = QueryValueW(
        hKey,
        pwszSubKey,
        pwszValueName,
        lpReserved,
        &dwType,
        pbData,
        &dwSize,
        fIsVersionEx)) == ERROR_SUCCESS || lRes == ERROR_MORE_DATA)
    {
        BOOL fIsString = FALSE;

        //
        // Convert the out values out.
        //
        if (dwType == REG_SZ || 
            dwType == REG_EXPAND_SZ || 
            dwType == REG_MULTI_SZ)
        {
            fIsString = TRUE;

            //
            // See how many bytes the ANSI value would take.
            //
            dwSize = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)pbData, -1, NULL, 0, NULL, NULL);
        }

        if (lpData)
        {
            if (dwSize > *lpcbData)
            {
                *lpcbData = dwSize;
                lRes = ERROR_MORE_DATA;
                goto EXIT;
            }
            else
            {
                if (fIsString)
                {
                    WideCharToMultiByte(
                        CP_ACP, 
                        0, 
                        (LPWSTR)pbData, 
                        -1, 
                        (LPSTR)lpData, 
                        *lpcbData,
                        0, 
                        0);
                }
                else
                {
                    MoveMemory(lpData, pbData, dwSize);
                }
            }
        }

        //
        // If lpData is NULL, we should return ERROR_SUCCESS while storing 
        // the required size in lpcbData.
        //
        if (pbData && lRes == ERROR_MORE_DATA && lpData)
        {
            lRes = ERROR_SUCCESS;
        }

        if (lpcbData)
        {
            *lpcbData = dwSize;
        }

        if (lpType)
        {
            *lpType = dwType;
        }
    }

EXIT:

    delete [] pwszSubKey;
    delete [] pwszValueName;
    delete [] pbData;
    
    return lRes;
}

/*++

 Function Description:

    Algorithm:
    
    We call our internal OpenKey function which will create a redirected
    key if the key doesn't exist at the original location, with the 
    KEY_SET_VALUE access. Then we can set the value there.

 Arguments:

    IN hKey - key handle.
    IN lpSubKey - subkey to set the default value of - this is for RegSetValue.
    IN lpValueName - value to set - this is for RegSetValueEx.
    IN Reserved - reserved.
    IN dwType - type of data.
    OUT lpData - contains the default value of the subkey if successful.
    IN cbData - size of input buffer.

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    02/16/2001 maonis  Created

--*/

LONG 
CRedirectedRegistry::SetValueA(
    HKEY hKey, 
    LPCSTR lpSubKey,
    LPCSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData,
    BOOL  fIsVersionEx
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[SetValueA] Setting value: hKey=0x%08x; lpValueName=%s; lpData=%s", hKey, lpValueName, (CHAR*)lpData);

    if (HandleDeleted(FindOpenKey(hKey)))
    {
        return ERROR_KEY_DELETED;
    }

    HKEY hSubKey;
    LONG lRes;

    //
    // First we create the subkey.
    // Note this is the only place where we call OpenKeyExA with TRUE for fForceRedirect.
    //
    if ((lRes = OpenKeyA(
        hKey, 
        (lpSubKey ? lpSubKey : ""), 
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_SET_VALUE,
        NULL,
        &hSubKey,
        NULL,
        TRUE,
        TRUE)) == ERROR_SUCCESS)
    {
        if (!fIsVersionEx)
        {
            //
            // If it's RegSetValue we need to calculate the correct size to pass into
            // RegSetvalueEx.
            //
            cbData = strlen((LPCSTR)lpData) + 1;
        }

        lRes = RegSetValueExA(
            hSubKey,
            lpValueName,
            Reserved,
            dwType,
            lpData,
            cbData);

        CloseKey(hSubKey);
    }

    return lRes;
}

/*++

 Function Description:

    The W version of SetValue.

 Arguments:

    IN hKey - handle to open key or HKLM etc
    IN lpSubKey - subkey to set the default value of - this is for RegSetValue.
    IN lpValueName - value to set - this is for RegSetValueEx.
    IN Reserved - reserved.
    IN dwType - type of data.
    OUT lpData - contains the default value of the subkey if successful.
    IN cbData - size of input buffer.

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    02/16/2001 maonis  Created

--*/

LONG 
CRedirectedRegistry::SetValueW(
    HKEY hKey, 
    LPCWSTR lpSubKey,
    LPCWSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData,
    BOOL  fIsVersionEx
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[SetValueW] Setting value: hKey=0x%08x; lpValueName=%S; lpData=%S", hKey, lpValueName, (WCHAR*)lpData);

    if (HandleDeleted(FindOpenKey(hKey)))
    {
        return ERROR_KEY_DELETED;
    }

    HKEY hSubKey;
    LONG lRes;

    //
    // We create the subkey. From MSDN: "If the key specified by the lpSubKey 
    // parameter does not exist, the RegSetValue function creates it."
    // Note this is the only place where we call OpenKeyA with TRUE for fForceRedirect.
    //
    if ((lRes = OpenKeyW(
        hKey, 
        (lpSubKey ? lpSubKey : L""), 
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_SET_VALUE,
        NULL,
        &hSubKey,
        NULL,
        TRUE,
        TRUE)) == ERROR_SUCCESS)
    {
        if (!fIsVersionEx)
        {
            //
            // If it's RegSetValue we need to calculate the correct size to pass into
            // RegSetvalueEx.
            //
            cbData = wcslen((LPCWSTR)lpData) + 1;
        }

        lRes = RegSetValueExW(
            hSubKey,
            lpValueName,
            Reserved,
            dwType,
            lpData,
            cbData);

        CloseKey(hSubKey);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[SetValueW] Setting value succeeded");
    }
    else
    {
        DPF("RedirectReg", eDbgLevelError, 
            "[SetValueW] Setting value failed: %d", 
            lRes);
    }

    return lRes;
}

LONG 
CRedirectedRegistry::EnumValueA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[EnumValueA] Enuming value: hKey=0x%08x; index=%d; lpValueName=%s", hKey, dwIndex, lpValueName);

    LONG lRes;
    WCHAR wszName[MAX_PATH + 1];
    DWORD dwSize = MAX_PATH + 1;

    if ((lRes = EnumValueW(
        hKey,
        dwIndex,
        wszName,
        &dwSize,
        lpReserved,
        NULL,
        NULL,
        NULL)) == ERROR_SUCCESS)
    {

        dwSize = WideCharToMultiByte(
            CP_ACP,
            0,
            wszName,
            -1,
            lpValueName,
            *lpcbValueName,
            NULL,
            NULL);

        if (dwSize)
        {
            if (!lpType || !lpData || !lpcbData)
            {
                lRes = QueryValueA(
                    hKey, 
                    NULL,
                    lpValueName,
                    NULL,
                    lpType,
                    lpData,
                    lpcbData,
                    TRUE);
            }
        }
        else
        {
            DWORD dwLastError = GetLastError();

            if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
            {
                lRes = ERROR_MORE_DATA;
                *lpcbValueName = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    wszName,
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            }
            else
            {
                lRes = dwLastError;
            }
        }
    }

    return lRes;
}

LONG 
CRedirectedRegistry::EnumValueW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[EnumValueW] Enuming value: hKey=0x%08x; index=%d", hKey, dwIndex);

    LONG lRes = ERROR_SUCCESS;
    OPENKEY* key = FindOpenKey(hKey);
    if (HandleDeleted(key))
    {
        return ERROR_KEY_DELETED;
    }

    REDIRECTKEY rk(key, hKey, NULL);

    if (rk.pwszFullPath && lpValueName && lpcbValueName && ShouldCheckEnumAlternate(hKey, &rk))
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[EnumValueW] key path is %S", rk.pwszFullPath);

        if (key->fNeedRebuild)
        {
            if ((lRes = key->BuildEnumLists(&rk)) != ERROR_SUCCESS)
            {
                DPF("RedirectReg", eDbgLevelError,
                    "[EnumValueW] Failed to build the enum list: %d", lRes);
                return lRes;
            }
        }

        if (dwIndex >= key->cValues)
        {
            DPF("RedirectReg", eDbgLevelInfo, 
                "[EnumValueW] asked to enum value %d when there are only %d values total", 
                dwIndex, 
                key->cValues);

            return ERROR_NO_MORE_ITEMS;
        }

        ENUMENTRY entry = key->values[dwIndex];
        DWORD cValueLen = wcslen(entry.wszName);
        if (*lpcbValueName > cValueLen)
        {
            wcscpy(lpValueName, entry.wszName);
            *lpcbValueName = cValueLen;

            if (!lpType || !lpData || !lpcbData)
            {
                lRes = QueryValueW(
                    hKey, 
                    NULL,
                    entry.wszName,
                    NULL,
                    lpType,
                    lpData,
                    lpcbData,
                    TRUE);
            }
        }
        else
        {
            lRes = ERROR_MORE_DATA;
        }
    }
    else
    {
        lRes = RegEnumValueW(
            hKey,
            dwIndex,
            lpValueName,
            lpcbValueName,
            lpReserved,
            lpType,
            lpData,
            lpcbData);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[EnumValueW] enum value succeeded: value %d is %S",
            dwIndex,
            lpValueName);
    }
    else
    {
        DPF("RedirectReg", eDbgLevelError, 
            "[EnumValueW] enum value failed: %d",
            lRes);
    }

    return lRes;
}

LONG 
CRedirectedRegistry::EnumKeyA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[EnumKeyA] Enuming key: hKey=0x%08x; index=%d", hKey, dwIndex);

    WCHAR wszName[MAX_PATH + 1];
    DWORD dwName = MAX_PATH + 1;

    LONG lRes = EnumKeyW(
        hKey,
        dwIndex,
        wszName,
        &dwName,
        lpReserved,
        NULL,
        NULL,
        lpftLastWriteTime);

    if (lRes == ERROR_SUCCESS && lpName)
    {
        //
        // If lpName is not NULL then lpcbName must not be NULL or it wouldn't
        // have returned ERROR_SUCCESS.
        //
        // The behavior of RegEnumKeyEx is if *lpcbName is not big enough, it  
        // always returns ERROR_MORE_DATA and *lpcbName is unchanged. So first
        // we get the required bytes for the ansi string.
        //
        DWORD dwByte = WideCharToMultiByte(
            CP_ACP, 
            0, 
            wszName, 
            dwName, 
            NULL, 
            0, 
            0, 
            0);

        if (!dwByte)
        {
            //
            // Failed to convert.
            //
            DPF("RedirectFS", eDbgLevelError,
                "[EnumKeyA] Failed to get the required length for the ansi "
                "string: %d",
                GetLastError());

            lRes = GetLastError();

        } 
        else if (*lpcbName < (dwByte + 1)) // dwByte doesn't include terminating NULL.
        {
            lRes = ERROR_MORE_DATA;
        } 
        else
        {
            //
            // We have a big enough buffer. We can convert now.
            //
            if (WideCharToMultiByte(
                CP_ACP, 
                0, 
                wszName, 
                dwName, 
                lpName, 
                *lpcbName, 
                0, 
                0))
            {
                lpName[dwByte] = '\0';
                *lpcbName = dwByte;
            }
            else
            {
                lRes = GetLastError();

                if (lRes == ERROR_INSUFFICIENT_BUFFER)
                {
                    lRes = ERROR_MORE_DATA;
                }
            }
        }
    }

    return lRes;
}

LONG 
CRedirectedRegistry::EnumKeyW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[EnumKeyW] Enuming key: hKey=0x%08x; index=%d", hKey, dwIndex);

    LONG lRes = ERROR_SUCCESS;
    OPENKEY* key = FindOpenKey(hKey);
    if (HandleDeleted(key))
    {
        return ERROR_KEY_DELETED;
    }

    REDIRECTKEY rk(key, hKey, NULL);

    if (rk.pwszFullPath && lpName && lpcbName && ShouldCheckEnumAlternate(hKey, &rk))
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[EnumKeyW] key path is %S", 
            rk.pwszFullPath);

        if (key->fNeedRebuild)
        {
            if ((lRes = key->BuildEnumLists(&rk)) != ERROR_SUCCESS)
            {
                DPF("RedirectReg", eDbgLevelError,
                    "[EnumKeyW] Failed to build the enum list: %d", lRes);
                return lRes;
            }
        }

        if (dwIndex >= key->cSubKeys)
        {
            DPF("RedirectReg", eDbgLevelInfo, 
                "[EnumKeyW] asked to enum key %d when there are only %d keys total", 
                dwIndex, 
                key->cSubKeys);

            return ERROR_NO_MORE_ITEMS;
        }

        ENUMENTRY entry = key->subkeys[dwIndex];
        DWORD cSubKeyLen = wcslen(entry.wszName);
        if (*lpcbName > cSubKeyLen)
        {
            wcscpy(lpName, entry.wszName);
            *lpcbName = cSubKeyLen;

            //
            // TODO: We are not returning info for the last 3rd parameters.....
            //
        }
        else
        {
            lRes = ERROR_MORE_DATA;
        }
    }
    else
    {
        lRes = RegEnumKeyExW(
            hKey,
            dwIndex,
            lpName,
            lpcbName,
            lpReserved,
            lpClass,
            lpcbClass,
            lpftLastWriteTime);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[EnumKeyW] enum key succeeded: key %d is %S",
            dwIndex,
            lpName);
    }
    else
    {
        DPF("RedirectReg", eDbgLevelError, 
            "[EnumKeyW] enum key failed: %d",
            lRes);
    }

    return lRes;
}

/*++

 Function Description:

    Close the key and remove it from the list.
    
 Arguments:

    IN hKey - handle to close

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    02/16/2001 maonis  Created

--*/

LONG 
CRedirectedRegistry::CloseKey(
    HKEY hKey
    )
{
    OPENKEY* key = m_OpenKeyList;
    OPENKEY* last = NULL;

    //
    // NOTE! We don't check if this handle corresponds to a deleted key -
    // RegCloseKey return ERROR_SUCCESS in that case.
    //
    while (key)
    {
        if (key->hKey == hKey)
        {
            if (last)
            {
                last->next = key->next; 
            }
            else
            {
                m_OpenKeyList = key->next;
            }

            delete key;
            break;
        }

        last = key;
        key = key->next;
    }

    DPF("RedirectReg", eDbgLevelInfo, "[CloseKey] closing key 0x%08x", hKey);

    return RegCloseKey(hKey);
}

/*++

 Function Description:

    Delete a key.
    
 Arguments:

    IN hKey - key handle.
    IN lpSubKey - subkey to close.

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    02/16/2001 maonis  Created

--*/

LONG 
CRedirectedRegistry::DeleteKeyA(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{
    LPWSTR pwszSubKey = NULL;

    if (lpSubKey)
    {
        if (!(pwszSubKey = AnsiToUnicode(lpSubKey)))
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[CRedirectedRegistry::DeleteKeyA] "
                "Failed to convert lpSubKey to unicode");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    LONG lRes = DeleteKeyW(hKey, pwszSubKey);

    delete [] pwszSubKey;

    return lRes;
}

BOOL 
CRedirectedRegistry::HasSubkeys(
    HKEY hKey,
    LPCWSTR lpSubKey
    )
{
    //
    // First open the key.
    //
    LONG lRes;
    HKEY hSubKey;
    DWORD cSubKeys;

    //
    // Even though we only need the number of subkeys, we can't only pass in
    // KEY_ENUMERATE_SUB_KEYS or RegQueryInfoKey will get access denied.
    //
    if ((lRes = RegOpenKeyExW(hKey, lpSubKey, 0, KEY_READ, &hSubKey))
        != ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelError,
            "[HasSubkeys] Failed to open the subkey: %d",
            lRes);

        return FALSE;
    }

    if ((lRes = QueryInfoKey(
        hSubKey, 
        NULL,
        &cSubKeys,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        TRUE)) != ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelError,
            "[HasSubkeys] Query key info failed: %d",
            lRes);

        return FALSE;
    }

    return (cSubKeys != 0);
}

/*++

 Function Description:

    The W version of DeleteKey.

    We keep an in-memory list of keys being deleted. This method adds the key
    to this list if the RegDeleteKey call succeeds.
    
 Arguments:

    IN hKey - key handle.
    IN lpSubKey - subkey to close.

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    02/16/2001 maonis  Created

--*/

LONG 
CRedirectedRegistry::DeleteKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[DeleteKeyW] Deleting key: hKey=0x%08x; lpSubKey=%S", hKey, lpSubKey);

    if (lpSubKey == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    OPENKEY* key = FindOpenKey(hKey);
    if (HandleDeleted(key))
    {
        return ERROR_KEY_DELETED;
    }

    REDIRECTKEY rk(key, hKey, lpSubKey);

    LONG lRes = RegDeleteKeyW(hKey, lpSubKey);

    if (key)
    {
        key->fNeedRebuild = TRUE;
    }

    if (rk.pwszFullPath)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[DeleteKeyW] key path is %S",
            rk.pwszFullPath);

        if (lRes == ERROR_ACCESS_DENIED && HasSubkeys(hKey, lpSubKey))
        {
            //
            // RegDeleteKey returns access denied if the key has subkeys. If that's the case
            // we should return now.
            //
            DPF("RedirectReg", eDbgLevelInfo, 
                "[DeleteKeyW] the key has subkeys so return now");

            return lRes;
        }

        if (rk.fIsRedirected)
        {
            //
            // If the key was redirected, we need to check the original location.
            //
            lRes = RegDeleteKeyW(rk.hkBase, rk.pwszPath);
        }
        else
        {
            //
            // If the key was not redirected, we need to check the redirect location.
            // We should be able to delete it if it exists so I am not checking the 
            // return value here.
            //
            LONG lResTemp = RegDeleteKeyW(rk.hkRedirectRoot, rk.pwszPath);

            if (lResTemp == ERROR_SUCCESS && lRes == ERROR_FILE_NOT_FOUND)
            {
                //
                // If the key only existed at the redirected location, now since we deleted
                // it there, we can set the return value to success.
                //
                lRes = ERROR_SUCCESS;
            }
            else if (lResTemp == ERROR_ACCESS_DENIED)
            {
                //
                // If we get here, it means this key has subkeys, we should just return.
                //
                DPF("RedirectReg", eDbgLevelInfo, 
                    "[DeleteKeyW] the redirected key has subkeys so return now");

                return lResTemp;
            }
        }
    
        if (lRes == ERROR_ACCESS_DENIED)
        {
            //
            // We only add the path to the deletion list if we get access
            // denied.
            //
            lRes = AddDeletedKey(rk.pwszFullPath);
        }    
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[DeleteKeyW] delete key succeeded");
    }
    else
    {
        DPF("RedirectReg", eDbgLevelError, 
            "[DeleteKeyW] delete key failed: %d", lRes);
    }

    return lRes;
}

LONG 
CRedirectedRegistry::QueryInfoKey(
    HKEY hKey,               
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    BOOL    fIsW // Do you want the W or the A version?
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[QueryInfoKey] Querying key info: hKey=0x%08x", hKey);

    LONG lRes;
    DWORD i;
    OPENKEY* key = FindOpenKey(hKey);
    if (HandleDeleted(key))
    {
        return ERROR_KEY_DELETED;
    }

    REDIRECTKEY rk(key, hKey, NULL);
    DWORD dwMaxValueLen = 0;

    if (rk.pwszFullPath && ShouldCheckEnumAlternate(hKey, &rk))
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[QueryInfoKey] key path is %S",
            rk.pwszFullPath);

        if ((lRes = key->BuildEnumLists(&rk)) != ERROR_SUCCESS)
        {
            DPF("RedirectReg", eDbgLevelError,
                "[QueryInfoKeyW] Failed to build the enum list: %d", lRes);

            return lRes;
        }

        if (lpcSubKeys)
        {
            *lpcSubKeys = key->cSubKeys;
        }

        if (lpcbMaxSubKeyLen)
        {
            *lpcbMaxSubKeyLen = key->cMaxSubKeyLen;
        }

        if (lpcValues)
        {
            *lpcValues = key->cValues;
        }

        if (lpcbMaxValueNameLen)
        {
            *lpcbMaxValueNameLen = key->cMaxValueLen;
        }

        if (lpcbMaxValueLen)
        {
            for (i = 0; i < key->cValues; ++i)
            {
                DWORD dwData;

                if (fIsW)
                {
                    lRes = QueryValueW(
                        hKey, 
                        NULL,
                        key->values[i].wszName,
                        NULL,
                        NULL,
                        NULL,
                        &dwData,
                        TRUE);
                }
                else
                {
                    LPSTR pszValueName = UnicodeToAnsi(key->values[i].wszName);

                    if (pszValueName)
                    {
                        lRes = QueryValueA(
                            hKey, 
                            NULL,
                            pszValueName,
                            NULL,
                            NULL,
                            NULL,
                            &dwData,
                            TRUE);

                        delete [] pszValueName;
                    }
                    else
                    {
                        DPF("RedirectReg", eDbgLevelError,
                            "[QueryInfoKey] Failed to convert %S to ansi",
                            key->values[i].wszName);

                        return ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                if (lRes == ERROR_SUCCESS)
                {
                    dwMaxValueLen = max(dwMaxValueLen, dwData);
                }
                else
                {
                    DPF("RedirectReg", eDbgLevelError, 
                        "[QueryInfoW] failed to query the data length for value %S: %d",
                        key->values[i].wszName,
                        lRes);
                    return lRes;
                }
            }
        }

        //
        // TODO: we are not returning info for those other parameters....
        //
    }
    else
    {
        lRes = RegQueryInfoKeyW(
            hKey,
            NULL,
            NULL,
            lpReserved,
            lpcSubKeys,
            lpcbMaxSubKeyLen,
            lpcbMaxClassLen, 
            lpcValues,
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,
            NULL,
            NULL);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo,
            "[QueryInfoKeyW] succeeded");

        if (lpcSubKeys)
        {
            DPF("RedirectReg", eDbgLevelInfo,
                "[QueryInfoKeyW] # of subkeys is %d",
                *lpcSubKeys);
        }

        if (lpcbMaxSubKeyLen)
        {
            DPF("RedirectReg", eDbgLevelInfo,
                "[QueryInfoKeyW] max len of subkeys is %d",
                *lpcbMaxSubKeyLen);
        }

        if (lpcValues)
        {
            DPF("RedirectReg", eDbgLevelInfo,
                "[QueryInfoKeyW] # of values is %d",
                *lpcValues);
        }

        if (lpcbMaxValueNameLen)
        {
            DPF("RedirectReg", eDbgLevelInfo,
                "[QueryInfoKeyW] max len of value names is %d",
                *lpcbMaxValueNameLen);
        }

        if (lpcbMaxValueLen)
        {
            DPF("RedirectReg", eDbgLevelInfo,
                "[QueryInfoKeyW] max len of values is %d",
                *lpcbMaxValueLen);
        }
    }
    else
    {
        DPF("RedirectReg", eDbgLevelError,
            "[QueryInfoKeyW] failed %d", 
            lRes);
    }

    return lRes;
}

CRedirectedRegistry RRegistry;

//
// Exported APIs.
//

LONG 
LuaRegOpenKeyA(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyA(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        phkResult,
        NULL,
        FALSE,
        FALSE);
}

LONG 
LuaRegOpenKeyW(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyW(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        phkResult,
        NULL,
        FALSE,
        FALSE);
}

LONG 
LuaRegOpenKeyExA(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyA(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        samDesired, 
        NULL,
        phkResult,
        NULL,
        FALSE,
        FALSE);
}

LONG 
LuaRegOpenKeyExW(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyW(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        samDesired, 
        NULL,
        phkResult,
        NULL,
        FALSE,
        FALSE);
}

LONG 
LuaRegCreateKeyA(
    HKEY hKey,         
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyA(
        hKey, 
        lpSubKey, 
        0,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        phkResult, 
        NULL,
        TRUE,
        FALSE);
}

LONG 
LuaRegCreateKeyW(
    HKEY hKey,         
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyW(
        hKey, 
        lpSubKey, 
        0,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        phkResult, 
        NULL,
        TRUE,
        FALSE);
}

LONG 
LuaRegCreateKeyExA(
    HKEY hKey,                
    LPCSTR lpSubKey,         
    DWORD Reserved,           
    LPSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyA(
        hKey, 
        lpSubKey,
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition,
        TRUE,
        FALSE);
}

LONG 
LuaRegCreateKeyExW(
    HKEY hKey,                
    LPCWSTR lpSubKey,         
    DWORD Reserved,           
    LPWSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyW(
        hKey, 
        lpSubKey,
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition,
        TRUE,
        FALSE);
}

LONG 
LuaRegQueryValueA(
    HKEY   hKey,
    LPCSTR lpSubKey,
    LPSTR  lpValue,
    PLONG  lpcbValue
    )
{
    CRRegLock Lock;

    return RRegistry.QueryValueA(
        hKey,
        lpSubKey,
        NULL, // value name
        NULL, // reserved
        NULL, // type
        (LPBYTE)lpValue,
        (LPDWORD)lpcbValue,
        FALSE);
}

LONG 
LuaRegQueryValueW(
    HKEY    hKey,
    LPCWSTR  lpSubKey,
    LPWSTR  lpValue,
    PLONG lpcbValue
    )
{
    CRRegLock Lock;

    return RRegistry.QueryValueW(
        hKey,
        lpSubKey,
        NULL, // value name
        NULL, // reserved
        NULL, // type
        (LPBYTE)lpValue,
        (LPDWORD)lpcbValue,
        FALSE);
}

LONG 
LuaRegQueryValueExA(
    HKEY    hKey,
    LPCSTR   lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    CRRegLock Lock;

    return RRegistry.QueryValueA(
        hKey,
        NULL, // subkey
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData,
        TRUE);
}

LONG 
LuaRegQueryValueExW(
    HKEY    hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    CRRegLock Lock;

    return RRegistry.QueryValueW(
        hKey,
        NULL, // subkey
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData,
        TRUE);
}

LONG      
LuaRegSetValueA(
    HKEY hKey, 
    LPCSTR lpSubKey, 
    DWORD dwType, 
    LPCSTR lpData, 
    DWORD cbData
    )
{
    CRRegLock Lock;

    return RRegistry.SetValueA(
        hKey,
        lpSubKey,
        "",
        0,
        dwType,
        (CONST BYTE*)lpData,
        cbData,
        FALSE);
}

LONG      
LuaRegSetValueW(
    HKEY hKey, 
    LPCWSTR lpSubKey, 
    DWORD dwType, 
    LPCWSTR lpData, 
    DWORD cbData
    )
{
    CRRegLock Lock;

    return RRegistry.SetValueW(
        hKey,
        lpSubKey,
        L"",
        0,
        dwType,
        (CONST BYTE*)lpData,
        cbData,
        FALSE);
}

LONG      
LuaRegSetValueExA(
    HKEY hKey, 
    LPCSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    CRRegLock Lock;

    return RRegistry.SetValueA(
        hKey,
        NULL,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData,
        TRUE);
}

LONG      
LuaRegSetValueExW(
    HKEY hKey, 
    LPCTSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    CRRegLock Lock;

    return RRegistry.SetValueW(
        hKey,
        NULL,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData,
        TRUE);
}

LONG 
LuaRegEnumValueA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    CRRegLock Lock;

    return RRegistry.EnumValueA(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,      
        lpcbData);
}

LONG 
LuaRegEnumValueW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    CRRegLock Lock;

    return RRegistry.EnumValueW(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,      
        lpcbData);
}

LONG 
LuaRegEnumKeyA(
    HKEY hKey,     
    DWORD dwIndex, 
    LPSTR lpName, 
    DWORD cbName  
    )
{
    CRRegLock Lock;

    return RRegistry.EnumKeyA(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL); 
}

LONG 
LuaRegEnumKeyW(
    HKEY hKey,     
    DWORD dwIndex, 
    LPWSTR lpName, 
    DWORD cbName  
    )
{
    CRRegLock Lock;

    return RRegistry.EnumKeyW(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL);
}

LONG 
LuaRegEnumKeyExA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    CRRegLock Lock;

    return RRegistry.EnumKeyA(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG 
LuaRegEnumKeyExW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    CRRegLock Lock;

    return RRegistry.EnumKeyW(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG 
LuaRegCloseKey(HKEY hKey)
{
    CRRegLock Lock;

    return RRegistry.CloseKey(hKey);
}

LONG      
LuaRegDeleteKeyA(
    HKEY hKey, 
    LPCSTR lpSubKey
    )
{
    CRRegLock Lock;

    return RRegistry.DeleteKeyA(hKey, lpSubKey);
}

LONG      
LuaRegDeleteKeyW(
    HKEY hKey, 
    LPCWSTR lpSubKey
    )
{
    CRRegLock Lock;

    return RRegistry.DeleteKeyW(hKey, lpSubKey);
}

LONG 
LuaRegQueryInfoKeyW(
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,       
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )
{
    CRRegLock Lock;

    return RRegistry.QueryInfoKey(
        hKey,
        lpReserved, 
        lpcSubKeys,
        lpcbMaxSubKeyLen,
        lpcbMaxClassLen, 
        lpcValues,  
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,
        TRUE);
}

LONG 
LuaRegQueryInfoKeyA(
    HKEY hKey,                
    LPSTR lpClass,           
    LPDWORD lpcbClass,        
    LPDWORD lpReserved,       
    LPDWORD lpcSubKeys,       
    LPDWORD lpcbMaxSubKeyLen, 
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,  
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime   
    )
{
    CRRegLock Lock;

    return RRegistry.QueryInfoKey(
        hKey,
        lpReserved,       
        lpcSubKeys,       
        lpcbMaxSubKeyLen, 
        lpcbMaxClassLen,  
        lpcValues,        
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,
        FALSE);
}

BOOL
LuaRegInit()
{
    RRegistry.Init();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\redirectreg_cleanup.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   RedirectReg_Cleanup.cpp

 Abstract:

    What apps usually do in their uninstall is they always enum a key with
    index 0; if the key has subkeys, they keep enuming until they find a child
    key that doesn't have subkeys; then perform the deletion.

   Delete the original key and all the present redirected keys in 
   every user's hive.
   
 Created:

    03/21/2001 maonis
    
 Modified:
    
    01/10/2002 maonis   Updated because of the changes we made in RedirectReg.cpp

--*/
#include "precomp.h"
#include "utils.h"

// Stores the open key HKEY_USERS\SID and HKEY_USER\SID_Classes for each user.
static USER_HIVE_KEY* g_hUserKeys = NULL;

// Number of users that have a Redirected directory.
static DWORD g_cUsers = 0;

struct COPENKEY
{
    COPENKEY* next;

    HKEY hKey;
    HKEY hkBase;
    LPWSTR pwszPath;
    DWORD cPathLen;
};

static COPENKEY* g_openkeys = NULL;

struct CLEANUPKEY
{
    CLEANUPKEY(
        COPENKEY* keyParent,
        HKEY hKey,
        LPCWSTR lpSubKey)
    {
        pwszPath = NULL;
        pwszRedirectPath = NULL;
        hkBase = 0;
        cPathLen = 0;
        fIsClasses = FALSE;

        //
        // Calculate the length of the key path so we know how much space to allocate.
        //
        LPWSTR pwszParentPath = NULL;
        DWORD cLen = 0;
        DWORD cLenRedirect = 0;
        DWORD cLenParent = 0;
        DWORD cLenSubKey = 0;
        DWORD cLenTrace = 0;

        if (keyParent)
        {
            hkBase = keyParent->hkBase;

            pwszParentPath = keyParent->pwszPath;

            if (pwszParentPath && *pwszParentPath)
            {
                cLenParent = keyParent->cPathLen;
            }
        }
        else if (IsPredefinedKey(hKey))
        {
            hkBase = hKey;
        }
        else
        {
    #ifdef DBG
            DPF("RedirectReg", eDbgLevelError,
                "[CLEANUPKEY::CLEANUPKEY] 0x%08x is an invalid open key handle",
                hKey);
    #endif 
            return;
        }

        //
        // Add the length of the redirect key portion.
        //
        if (hkBase == HKEY_LOCAL_MACHINE)
        {
            cLenRedirect = LUA_REG_REDIRECT_KEY_LEN;
            cLen += LUA_REG_REDIRECT_KEY_LEN; // Software\Redirected
        }
        else if (hkBase == HKEY_CLASSES_ROOT)
        {
            fIsClasses = TRUE;
        }
        else if (hkBase != HKEY_CURRENT_USER)
        {
            return;
        }

        //
        // Add the length of the parent key portion.
        //
        if (cLenParent)
        {
            if (cLenRedirect)
            {
                //
                // count the '\' that concatenate redirect and parent.
                //
                ++cLen;
            }

            cLen += cLenParent; 
        }

        //
        // Add the length of the subkey portion.
        //
        if (lpSubKey)
        {
            cLenSubKey = wcslen(lpSubKey);

            if (cLenSubKey)
            {
                if (cLen)
                {
                    //
                    // Make room for the '\' before the subkey.
                    //
                    ++cLen;
                }

                cLen += cLenSubKey;
            }
        }

        //
        // Allocate memory for the redirected path.
        //
        pwszRedirectPath = new WCHAR [cLen + 1];

        if (!pwszRedirectPath)
        {
            DPF("RedirectReg", eDbgLevelError,
                "[CLEANUPKEY::CLEANUPKEY] Failed to allocate %d WCHARs for key path",
                cLen + 1);

            return;
        }

        ZeroMemory(pwszRedirectPath, (cLen + 1) * sizeof(WCHAR));

        if (hkBase == HKEY_LOCAL_MACHINE)
        {
            wcscpy(pwszRedirectPath, LUA_REG_REDIRECT_KEY);
        }

        cLenTrace += cLenRedirect;

        if (cLenParent)
        {
            if (cLenTrace)
            {
                pwszRedirectPath[cLenTrace] = L'\\';

                ++cLenTrace;
            }

            wcscpy(pwszRedirectPath + cLenTrace, pwszParentPath);
        }

        cLenTrace += cLenParent;

        if (cLenSubKey)
        {
            if (cLenTrace)
            {
                pwszRedirectPath[cLenTrace] = L'\\';

                ++cLenTrace;
            }

            wcscpy(pwszRedirectPath + cLenTrace, lpSubKey);
        }

        cLenTrace += cLenSubKey;

        if (cLenRedirect)
        {
            if (cLenTrace != cLenRedirect)
            {
                ++cLenRedirect;
            }
        }

        pwszPath = pwszRedirectPath + cLenRedirect;
        cPathLen = cLen - cLenRedirect;
    }

    ~CLEANUPKEY()
    {
        delete [] pwszRedirectPath;
        pwszRedirectPath = NULL;
        pwszPath = NULL;
        hkBase = 0;
        cPathLen = 0;
    }

    //
    // For each type of key, what those values look like:
    //
    //                     HKCU\a  HKLM\a                  HKCR\a
    // pwszRedirectPath    a       Software\Redirected\a   a
    // hkBase              0       HKLM                    HKCR
    // pwszPath            a       a                       a
    //

    LPWSTR pwszRedirectPath;

    HKEY hkBase;
    LPWSTR pwszPath;
    DWORD cPathLen;
    BOOL fIsClasses;
};

LONG 
AddKey(
    HKEY hKey,
    CLEANUPKEY* ck
    )
{
    COPENKEY* key = new COPENKEY;
    if (!key)
    {
        DPF("REGC", eDbgLevelError, 
            "Error allocating memory for a new COPENKEY");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    key->hKey = hKey;
    key->hkBase = ck->hkBase;

    //
    // If rk->pwszPath is NULL, it means it was either one of the
    // keys we don't handle or a bad handle.
    // In any of those cases, we won't be needing the path anyway.
    //
    if (ck->pwszPath)
    {
        key->pwszPath = new WCHAR [ck->cPathLen + 1];

        if (key->pwszPath)
        {
            if (ck->pwszPath)
            {
                wcscpy(key->pwszPath, ck->pwszPath);
                key->cPathLen = ck->cPathLen;
            }
        }
        else
        {
            delete key;

            DPF("REGC", eDbgLevelError, 
                "Error allocating memory for %d WCHARs",
                ck->cPathLen + 1);

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
 
    key->next = g_openkeys;
    g_openkeys = key;

    return ERROR_SUCCESS;
}

COPENKEY* 
FindKey(
    HKEY hKey
    )
{
    COPENKEY* key = g_openkeys;

    while (key)
    {
        if (key->hKey == hKey)
        {
            return key;
        }

        key = key->next;
    }

    return NULL;
}

//
// locking stuff.
//

static BOOL g_bInitialized = FALSE;

static CRITICAL_SECTION g_csRegCleanup;

class CRRegCleanupLock
{
public:
    CRRegCleanupLock()
    {
        if (!g_bInitialized)
        {
            InitializeCriticalSection(&g_csRegCleanup);
            g_bInitialized = TRUE;            
        }

        EnterCriticalSection(&g_csRegCleanup);
    }
    ~CRRegCleanupLock()
    {
        LeaveCriticalSection(&g_csRegCleanup);
    }
};

//
// Exported APIs.
//

/*++

 Function Description:

    We open the key at the first location we can find, ie, if we
    can't find it at the original location we try in redirected locations.

 History:

    02/16/2001 maonis  Created
    01/10/2002 maonis  Modified

--*/

LONG 
LuacRegOpenKeyExW(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    CRRegCleanupLock Lock;

    DPF("REGC", eDbgLevelInfo,
        "[LuacRegOpenKeyExW] hKey=0x%08x, lpSubKey=%S, samDesired=0x%08x",
        hKey, lpSubKey, samDesired);

    LONG lRes = ERROR_FILE_NOT_FOUND;
    CLEANUPKEY ck(FindKey(hKey), hKey, lpSubKey);

    if (ck.pwszPath)
    {
        DPF("REGC", eDbgLevelInfo,
            "[LuacRegOpenKeyExW] hkBase=0x%08x, path=%S",
            ck.hkBase,
            ck.pwszPath);

        if (ck.hkBase)
        {
            lRes = RegOpenKeyExW(
                ck.hkBase,         
                ck.pwszPath,  
                ulOptions,
                samDesired, 
                phkResult);
        }

        if (lRes == ERROR_FILE_NOT_FOUND)
        {
            for (DWORD dw = 0; dw < g_cUsers; ++dw)
            {
                if ((lRes = RegOpenKeyExW(
                    (ck.fIsClasses ? g_hUserKeys[dw].hkUserClasses : g_hUserKeys[dw].hkUser),
                    ck.pwszRedirectPath,
                    ulOptions,
                    samDesired,
                    phkResult)) == ERROR_SUCCESS)
                {
                    break;
                }
            }
        }
    }
    else
    {
        lRes = RegOpenKeyExW(
            hKey,         
            lpSubKey,  
            ulOptions,   
            samDesired, 
            phkResult);
    }
    
    if (lRes == ERROR_SUCCESS)
    {
        lRes = AddKey(*phkResult, &ck);

        DPF("REGC", eDbgLevelInfo,
            "[LuacRegOpenKeyExW] openkey=0x%08x",
            *phkResult);
    }

    return lRes;
}

LONG 
LuacRegOpenKeyW(
    HKEY hKey,         
    LPWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    return LuacRegOpenKeyExW(
        hKey,
        lpSubKey,
        0, 
        MAXIMUM_ALLOWED, 
        phkResult);
}

/*++

 Function Description:

    We enum the key at the first location we can find, ie, if we
    can't find it at the original location we try in redirected locations.

 History:

    02/16/2001 maonis  Created
    01/10/2002 maonis  Modified

--*/

LONG 
LuacRegEnumKeyExW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    CRRegCleanupLock Lock;
    DPF("REGC", eDbgLevelInfo,
        "[LuacRegEnumKeyExW] hKey=0x%08x, dwIndex=%d",
        hKey, dwIndex);

    LONG lRes = ERROR_FILE_NOT_FOUND;
    LONG lTempRes;
    CLEANUPKEY ck(FindKey(hKey), hKey, NULL);
    HKEY hEnumKey;

    if (ck.pwszPath)
    {
        DPF("REGC", eDbgLevelInfo,
            "[LuacRegEnumKeyExW] hkBase=0x%08x, path=%S",
            ck.hkBase,
            ck.pwszPath);

        if (ck.hkBase)
        {
            //
            // Open the original key.
            //
            lRes = RegOpenKeyW(ck.hkBase, ck.pwszPath, &hEnumKey);

            if (lRes == ERROR_SUCCESS)
            {
                lRes = RegEnumKeyExW(
                    hEnumKey,
                    dwIndex,
                    lpName,
                    lpcbName,
                    lpReserved,
                    lpClass,
                    lpcbClass,
                    lpftLastWriteTime);

                RegCloseKey(hEnumKey);
            }
        }

        //
        // If we can't find it or the key at the original location doesn't
        // have any more keys, we need to check the redirected locations -
        // the key might exist at one of those locations and/or have more keys.
        //
        if (lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_NO_MORE_ITEMS)
        {
            lTempRes = lRes;

            for (DWORD dw = 0; dw < g_cUsers; ++dw)
            {
                HKEY hKeyOriginal;

                if ((lRes = RegOpenKeyW(
                    (ck.fIsClasses ? g_hUserKeys[dw].hkUserClasses : g_hUserKeys[dw].hkUser), 
                    ck.pwszRedirectPath, 
                    &hEnumKey)) 
                    == ERROR_SUCCESS)
                {
                    lRes = RegEnumKeyExW(
                        hEnumKey,
                        dwIndex,
                        lpName,
                        lpcbName,
                        lpReserved,
                        lpClass,
                        lpcbClass,
                        lpftLastWriteTime);

                    RegCloseKey(hEnumKey);

                    if (lRes == ERROR_SUCCESS)
                    {
                        return lRes;
                    }

                    if (lRes == ERROR_NO_MORE_ITEMS)
                    {
                        lTempRes = lRes;
                    }
                }
            }

            if (lTempRes == ERROR_NO_MORE_ITEMS)
            {
                //
                // If it was originally not found now it's found and has no subkeys, 
                // we need to set the return value to ERROR_NO_MORE_ITEMS so the app
                // will delete it.
                //
                lRes = lTempRes;
            }
        }
    }
    else
    {
        return RegEnumKeyExW(
            hKey,
            dwIndex,
            lpName,
            lpcbName,
            lpReserved,
            lpClass,
            lpcbClass,
            lpftLastWriteTime);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("REGC", eDbgLevelInfo,
            "[LuacRegEnumKeyExW] sukey is %S",
            lpName);
    }

    return lRes;
}

LONG 
LuacRegEnumKeyW(
    HKEY hKey,     
    DWORD dwIndex, 
    LPWSTR lpName, 
    DWORD cbName  
    )
{
    return LuacRegEnumKeyExW(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL);
}

LONG 
LuacRegCloseKey(HKEY hKey)
{
    CRRegCleanupLock Lock;
    DPF("REGC", eDbgLevelInfo,
        "[LuacRegCloseKey] closing key 0x%08x",
        hKey);

    COPENKEY* key = g_openkeys;
    COPENKEY* last = NULL;

    while (key)
    {
        if (key->hKey == hKey)
        {
            if (last)
            {
                last->next = key->next; 
            }
            else
            {
                g_openkeys = key->next;
            }

            delete key;
            break;
        }

        last = key;
        key = key->next;
    }

    return RegCloseKey(hKey);
}

/*++

 Function Description:

    We only handle HKCU, HKLM and HKCR keys:

    For HKLM keys, we need to delete at HKLM and each user's redirect location.
    For HKCU keys, we need to delete it in each user's hive.
    For HKCR keys, we need to delete at HKLM\Software\Classes and at each user's
    HKCU\Software\Classes.

 Arguments:

    IN hKey - the handle value of this key.
    IN lpSubKey - path of the subkey that this key opened.

 Return Value:
    
    If we succeed in deleting anykey, we return success.

 History:

    02/16/2001 maonis  Created
    01/10/2002 maonis  Modified

--*/

LONG      
LuacRegDeleteKeyW(
    HKEY hKey, 
    LPCWSTR lpSubKey
    )
{
    CRRegCleanupLock Lock;
    DPF("REGC", eDbgLevelInfo,
        "[LuacRegDeleteKeyW] hKey=0x%08x, lpSubKey=%S",
        hKey, lpSubKey);

    LONG lFinalRes = ERROR_FILE_NOT_FOUND;
    CLEANUPKEY ck(FindKey(hKey), hKey, lpSubKey);

    if (ck.pwszPath)
    {
        DPF("REGC", eDbgLevelInfo,
            "[LuacRegDeleteKeyW] hkBase=0x%08x, path=%S",
            ck.hkBase,
            ck.pwszPath);

        if (ck.hkBase)
        {
            if (RegDeleteKeyW(ck.hkBase, ck.pwszPath) == ERROR_SUCCESS)
            {
                lFinalRes = ERROR_SUCCESS;
            }
        }

        for (DWORD dw = 0; dw < g_cUsers; ++dw)
        {
            if (RegDeleteKeyW((
                ck.fIsClasses ? g_hUserKeys[dw].hkUserClasses : g_hUserKeys[dw].hkUser), 
                ck.pwszRedirectPath) 
                == ERROR_SUCCESS)
            {
                lFinalRes = ERROR_SUCCESS;
            }
        }
    }
    else
    {
        return RegDeleteKeyW(hKey, lpSubKey);
    }

    return lFinalRes;
}

BOOL
LuacRegInit()
{
    return GetUsersReg(&g_hUserKeys, &g_cUsers);
}

VOID
LuacRegCleanup()
{
    FreeUsersReg(g_hUserKeys, g_cUsers);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\utils.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   LUA_RedirectFS_Cleanup.cpp

 Abstract:

   Delete the redirected copies in every user's directory.

 Created:

   02/12/2001 maonis

 Modified:


--*/
#include "precomp.h"
#include "secutils.h"
#include "utils.h"
#include <userenv.h>

WCHAR g_wszUserProfile[MAX_PATH] = L"";
DWORD g_cUserProfile = 0;
WCHAR g_wszSystemRoot[MAX_PATH] = L"";
DWORD g_cSystemRoot = 0;

DWORD
GetUserProfileDirW()
{
    if (g_cUserProfile == 0)
    {
        HANDLE hToken;
        if (OpenProcessToken(
                GetCurrentProcess(),
		TOKEN_QUERY,
		&hToken))
        {
            WCHAR wszProfileDir[MAX_PATH] = L"";
            DWORD dwSize = MAX_PATH;

            if (GetUserProfileDirectoryW(hToken, wszProfileDir, &dwSize))
            {
                dwSize = GetLongPathNameW(wszProfileDir, g_wszUserProfile, MAX_PATH);

                if (dwSize <= MAX_PATH)
                {
                    //
                    // Only if we successfully got the path and it's not more
                    // than MAX_PATH will we set the global values.
                    //
                    g_cUserProfile = dwSize;
                }
                else
                {
                    g_wszUserProfile[0] = L'\0';
                }
            }

            CloseHandle(hToken);
        }
    }

    return g_cUserProfile;
}

BOOL 
IsUserDirectory(LPCWSTR pwszPath)
{
    GetUserProfileDirW();

    if (g_cUserProfile)
    {
        return !_wcsnicmp(pwszPath, g_wszUserProfile, g_cUserProfile);
    }

    return FALSE;
}

DWORD
GetSystemRootDirW()
{
    if (g_cSystemRoot == 0)
    {
        if (g_cSystemRoot = GetSystemWindowsDirectoryW(g_wszSystemRoot, MAX_PATH))
        {
            //
            // Just to be cautious - if we really have a system directory that's
            // longer than MAX_PATH, most likely something suspicious is going on
            // here, so we bail out.
            //
            if (g_cSystemRoot >= MAX_PATH)
            {
                g_wszSystemRoot[0] = L'\0';
                g_cSystemRoot = 0;
            }
            else if (g_cSystemRoot > 3)
            {
                g_wszSystemRoot[g_cSystemRoot] = L'\\';
                g_wszSystemRoot[g_cSystemRoot + 1] = L'\0';
                ++g_cSystemRoot;
            }
            else
            {
                g_wszSystemRoot[g_cSystemRoot] = L'\0';
            }
        }
    }

    return g_cSystemRoot;
}

/*++

 Function Description:

    For the GetPrivateProfile* and WritePrivateProfile* APIs,
    if the app didn't specify the path, we append the windows dir
    in the front as that's where it'll be looking for and creating
    the file it doesn't already exist.

 Arguments:

    IN lpFileName - The file name specified by the profile API.
    IN/OUT pwszFullPath - Pointer to the buffer to receive the full path.
                          This buffer is at least MAX_PATH WCHARs long.

 Return Value:

    TRUE - Successfully got the path.
    FALSE - We don't handle this filename, either because an error
            occured or the file name is longer than MAX_PATH.

 History:

    05/16/2001 maonis  Created
    02/13/2002 maonis  Modified to signal errors.

--*/

BOOL
MakeFileNameForProfileAPIsW(
    IN      LPCWSTR lpFileName,
    IN OUT  LPWSTR  pwszFullPath // at least MAX_PATH in length
    )
{
    BOOL fIsSuccess = FALSE;

    if (lpFileName)
    {
        DWORD cFileNameLen = wcslen(lpFileName);

        if (wcschr(lpFileName, L'\\'))
        {
            if (cFileNameLen < MAX_PATH)
            {
                //
                // The filename already contains the path, just copy it over.
                //
                wcsncpy(pwszFullPath, lpFileName, cFileNameLen);
                fIsSuccess = TRUE;
            }
        }
        else if (GetSystemRootDirW() && g_cSystemRoot)
        {
            DWORD cLen = g_cSystemRoot + cFileNameLen;

            //
            // Only copy when we know the buffer is big enough.
            //
            if (cLen < MAX_PATH)
            {
                wcsncpy(pwszFullPath, g_wszSystemRoot, g_cSystemRoot);
                wcsncpy(pwszFullPath + g_cSystemRoot, lpFileName, cFileNameLen);
                pwszFullPath[cLen - 1] = L'\0';

                fIsSuccess = TRUE;
            }
        }
    }

    return fIsSuccess;
}

//
// If the .exe name is *setup*, *install* or _INS*._MP, we consider
// them a setup program and won't shim them.
//
BOOL IsSetup(
    )
{
    WCHAR wszModuleName[MAX_PATH + 1];
    ZeroMemory(wszModuleName, (MAX_PATH + 1) * sizeof(WCHAR));

    GetModuleFileNameW(NULL, wszModuleName, MAX_PATH + 1);

    wszModuleName[MAX_PATH] = 0;
    _wcslwr(wszModuleName);

    if (wcsstr(wszModuleName, L"setup") || wcsstr(wszModuleName, L"install"))
    {
        return TRUE;
    }

    LPWSTR pwsz;
    if (pwsz = wcsstr(wszModuleName, L"_ins"))
    {
        if (wcsstr(pwsz + 4, L"_mp"))
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL LuaShouldApplyShim(
    )
{
    return (!IsSetup() && ShouldApplyShim());
}

#define REDIRECT_DIR L"\\Local Settings\\Application Data\\Redirected\\"
// We look at HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList for the users.
#define PROFILELIST_STR L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"

#define CLASSES_HIVE_SUFFIX L"_Classes"
#define CLASSES_HIVE_SUFFIX_LEN (sizeof(CLASSES_HIVE_SUFFIX) / sizeof(WCHAR) - 1)

#define USER_HIVE_NAME L"\\NtUser.dat"
#define USER_HIVE_NAME_LEN (sizeof(USER_HIVE_NAME) / sizeof(WCHAR) - 1)
#define USER_CLASSES_HIVE_NAME L"\\Local Settings\\Application Data\\Microsoft\\Windows\\UsrClass.dat"
#define USER_CLASSES_HIVE_NAME_LEN (sizeof(USER_CLASSES_HIVE_NAME) / sizeof(WCHAR) - 1)

// Total number of users which is the number of subkeys of 
// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList
static DWORD g_cUsers = 0;

// We need to keep a list of keys we had to load under HKEY_USERS and unload them 
// when the process exits.
static WCHAR** g_wszLoadedKeys = NULL;
static DWORD g_cLoadedKeys = 0;

// The number of users is the number of subkeys under 
// HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList
LONG 
InitGetUsers(
    OUT DWORD* pcUsers, 
    OUT HKEY* phKey
    )
{
    LONG lRes;

    if ((lRes = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        PROFILELIST_STR,
        0,
        KEY_READ,
        phKey)) == ERROR_SUCCESS)
    {
        lRes = RegQueryInfoKeyW(*phKey, NULL, NULL, NULL, pcUsers,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        RegCloseKey(*phKey);
    }

    return lRes;
}

// In case of failure we need to clean up our array.
VOID 
FreeUserDirectoryArray(
    REDIRECTED_USER_PATH* pRedirectUserPaths
    )
{
    for (DWORD ui = 0; ui < g_cUsers; ++ui)
    {
        delete [] pRedirectUserPaths[ui].pwszPath;
    }

    delete [] pRedirectUserPaths;
}

BOOL 
IsDirectory(
    WCHAR* pwszName
    )
{
    DWORD dwAttrib = GetFileAttributesW(pwszName);

    return (dwAttrib != -1 && dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
}

LONG GetProfilePath(
    HKEY hkProfileList,
    LPCWSTR pwszUserSID,
    LPWSTR pwszUserDirectory
    )
{
    LONG lRes;
    HKEY hkUserSID;
    DWORD dwFlags;

    // Open the user SID key.
    if ((lRes = RegOpenKeyExW(
        hkProfileList,
        pwszUserSID,
        0,
        KEY_QUERY_VALUE,
        &hkUserSID)) == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(DWORD);
        if ((lRes = RegQueryValueExW(
            hkUserSID,
            L"Flags",
            NULL,
            NULL,
            (LPBYTE)&dwFlags,
            &dwSize)) == ERROR_SUCCESS)
        {
            // Check if the value of Flag is 0, if so it's the user we care about.
            if (dwFlags == 0)
            {
                DWORD cTemp = MAX_PATH;
                WCHAR wszTemp[MAX_PATH] = L"";

                if ((lRes = RegQueryValueExW(
                    hkUserSID,
                    L"ProfileImagePath",
                    NULL,
                    NULL,
                    (LPBYTE)wszTemp,
                    &cTemp)) == ERROR_SUCCESS)
                {
                    DWORD cExpandLen = ExpandEnvironmentStringsW(wszTemp, pwszUserDirectory, MAX_PATH);

                    if (cExpandLen > MAX_PATH)
                    {
                        lRes = ERROR_MORE_DATA;
                    }
                }
            }
            else
            {
                lRes = ERROR_INVALID_HANDLE;
            }
        }

        RegCloseKey(hkUserSID);
    }

    return lRes;
}

BOOL 
GetUsersFS(
    REDIRECTED_USER_PATH** ppRedirectUserPaths,
    DWORD* pcUsers
    )
{
    WCHAR wszRedirectDir[MAX_PATH] = L"";
    DWORD cUsers;
    HKEY hkProfileList;
    if (InitGetUsers(&cUsers, &hkProfileList) != ERROR_SUCCESS)
    {
        DPF("LUAUtils", eDbgLevelError, "[GetUsersFS] Error initializing");
        return FALSE;
    }

    *ppRedirectUserPaths = new REDIRECTED_USER_PATH [cUsers];
    if (!*ppRedirectUserPaths)
    {
        DPF("LUAUtils", eDbgLevelError, "[GetUsersFS] Error allocating memory");
        return FALSE;
    }

    REDIRECTED_USER_PATH* pRedirectUserPaths = *ppRedirectUserPaths;

    ZeroMemory((PVOID)pRedirectUserPaths, cUsers * sizeof(REDIRECTED_USER_PATH));

    WCHAR wszSubKey[MAX_PATH] = L"";
    DWORD cSubKey = 0;
    HKEY hkUserSID;
    LONG lRes;
    // The number of users we care about.
    DWORD cLUAUsers = 0;
    DWORD dwIndex = 0;
    
    while (TRUE)
    {
        cSubKey = MAX_PATH;

        lRes = RegEnumKeyExW(hkProfileList, dwIndex, wszSubKey, &cSubKey, 
            NULL, NULL, NULL, NULL);
        
        if (lRes == ERROR_SUCCESS)
        {
            WCHAR wszUserDirectory[MAX_PATH] = L"";

            if ((lRes = GetProfilePath(hkProfileList, wszSubKey, wszUserDirectory))
                == ERROR_SUCCESS)
            {
                //
                // If the directory doesn't exist, it means either the user
                // never logged on, or there are no redirected files for that
                // user. We simply skip it.
                //
                if (IsDirectory(wszUserDirectory))
                {
                    DWORD cPath = wcslen(wszUserDirectory) + 1;
                    LPWSTR pwszPath = new WCHAR [cPath];

                    if (pwszPath)
                    {
                        wcscpy(pwszPath, wszUserDirectory);
                        pRedirectUserPaths[cLUAUsers].pwszPath = pwszPath;
                        pRedirectUserPaths[cLUAUsers].cLen = cPath;
                        ++cLUAUsers;
                    }
                    else
                    {
                        DPF("LUAUtils", eDbgLevelError, 
                            "[GetUsersFS] Error allocating memory");
                        lRes = ERROR_NOT_ENOUGH_MEMORY;
                        goto EXIT;
                    }
                }
            }
        }
        else if (lRes == ERROR_NO_MORE_ITEMS)
        {
            *pcUsers = cLUAUsers;
            lRes = ERROR_SUCCESS;
            goto EXIT;
        }
        else
        {
            break;
        }

        ++dwIndex;
    }

EXIT:

    RegCloseKey(hkProfileList);

    if (lRes == ERROR_SUCCESS)
    {
        return TRUE;
    }

    FreeUserDirectoryArray(pRedirectUserPaths);
    return FALSE;
}

VOID 
FreeUsersFS(
    REDIRECTED_USER_PATH* pRedirectUserPaths
    )
{
    FreeUserDirectoryArray(pRedirectUserPaths);
}

LONG 
LoadHive(
    LPCWSTR pwszHiveName,
    LPCWSTR pwszHiveFile,
    HKEY* phKey
    )
{
    LONG lRes;

    // If the hive is already loaded, we'll get a sharing violation so 
    // check that as well.
    if ((lRes = RegLoadKeyW(HKEY_USERS, pwszHiveName, pwszHiveFile))
        == ERROR_SUCCESS || lRes == ERROR_SHARING_VIOLATION)
    {
        if (lRes == ERROR_SUCCESS)
        {
            DWORD cLen = wcslen(pwszHiveName) + 1;
            g_wszLoadedKeys[g_cLoadedKeys] = new WCHAR [cLen];
            if (!(g_wszLoadedKeys[g_cLoadedKeys]))
            {
                DPF("LUAUtils", eDbgLevelError, 
                    "[LoadHive] Error allocating %d WCHARs",
                    cLen);

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            // Store the hive name so later on we can unload this hive.
            wcscpy(g_wszLoadedKeys[g_cLoadedKeys++], pwszHiveName);
        }

        lRes = RegOpenKeyExW(
            HKEY_USERS,
            pwszHiveName,
            0,
            KEY_ALL_ACCESS,
            phKey);
    }

    return lRes;
}

BOOL 
GetUsersReg(
    USER_HIVE_KEY** pphkUsers, 
    DWORD* pcUsers
    )
{
    // We have to enable the "Restore files and directories" privilege to 
    // load each user's hive.
    if (!AdjustPrivilege(SE_RESTORE_NAME, TRUE))
    {
        DPF("LUAUtils", eDbgLevelError, 
            "[GetUsersReg] Error enabling the SE_RESTORE_NAME privilege");
        return FALSE;        
    }

    DWORD cUsers;
    HKEY hkProfileList;
    if (InitGetUsers(&cUsers, &hkProfileList) != ERROR_SUCCESS)
    {
        DPF("LUAUtils", eDbgLevelError, "[GetUsersReg] Error initializing");
        return FALSE;
    }

    *pphkUsers = new USER_HIVE_KEY [cUsers];
    if (!*pphkUsers)
    {
        DPF("LUAUtils", eDbgLevelError, 
            "[GetUsersReg] Error allocating memory for %d USER_HIVE_KEYs",
            cUsers);
        return FALSE;
    }

    g_wszLoadedKeys = new WCHAR* [cUsers * 2];
    if (!g_wszLoadedKeys)
    {
        DPF("LUAUtils", eDbgLevelError, 
            "[GetUsersReg] Error allocating memory for %d WCHARs",
            cUsers * 2);

        delete [] *pphkUsers;
        return FALSE;
    }

    USER_HIVE_KEY* phkUsers = *pphkUsers;
    
    ZeroMemory((PVOID)phkUsers, cUsers * sizeof(USER_HIVE_KEY));
    ZeroMemory((PVOID)g_wszLoadedKeys, cUsers * 2 * sizeof (WCHAR*));

    WCHAR wszSubKey[MAX_PATH] = L"";
    WCHAR wszUserHive[MAX_PATH] = L"";
    WCHAR wszUserClassesHive[MAX_PATH] = L"";
    DWORD cSubKey = 0;
    HKEY hkSubKey;
    LONG lRes;
    // The number of users we care about.
    DWORD cLUAUsers = 0;
    DWORD dwIndex = 0;
    DWORD cUserHive = 0;

    while (TRUE)
    {
        cSubKey = MAX_PATH;

        lRes = RegEnumKeyExW(hkProfileList, dwIndex, wszSubKey, &cSubKey,
            NULL, NULL, NULL, NULL);
        
        if (lRes == ERROR_SUCCESS)
        {
            if ((lRes = GetProfilePath(hkProfileList, wszSubKey, wszUserHive))
                == ERROR_SUCCESS)
            {
                //
                // Make sure we don't buffer overflow.
                //
                cUserHive = wcslen(wszUserHive);
                if ((cUserHive + USER_CLASSES_HIVE_NAME_LEN + 1) > MAX_PATH ||
                    (cUserHive + USER_HIVE_NAME_LEN + 1) > MAX_PATH)
                {
                    DPF("LUAUtils", eDbgLevelError, 
                        "[GetUsersReg] The hive key names are too long - we don't handle them");
                    goto EXIT;
                }

                //
                // Construct the locations for the user hive and user classes data hive.
                //
                wcsncpy(wszUserClassesHive, wszUserHive, cUserHive);
                wcsncpy(
                    wszUserClassesHive + cUserHive, 
                    USER_CLASSES_HIVE_NAME, 
                    USER_CLASSES_HIVE_NAME_LEN);
                wszUserClassesHive[cUserHive + USER_CLASSES_HIVE_NAME_LEN] = L'\0';

                wcsncpy(wszUserHive + cUserHive, USER_HIVE_NAME, USER_HIVE_NAME_LEN);
                wszUserHive[cUserHive + USER_HIVE_NAME_LEN] = L'\0';

                //
                // Load the HKCU for this user.
                //
                if ((lRes = LoadHive(
                    wszSubKey, 
                    wszUserHive, 
                    &phkUsers[cLUAUsers].hkUser)) == ERROR_SUCCESS)
                {
                    //
                    // We can't necessarily load the HKCR for this user - it might
                    // contain no data so we only attemp to load it.
                    //

                    if ((cSubKey + CLASSES_HIVE_SUFFIX_LEN + 1) > MAX_PATH)
                    {
                        DPF("LUAUtils", eDbgLevelError, 
                            "[GetUsersReg] The CR key name is too long - we don't handle it");
                        goto EXIT;
                    }

                    wcsncpy(wszSubKey + cSubKey, CLASSES_HIVE_SUFFIX, CLASSES_HIVE_SUFFIX_LEN);
                    wszSubKey[cSubKey + CLASSES_HIVE_SUFFIX_LEN] = L'\0';

                    LoadHive(
                        wszSubKey, 
                        wszUserClassesHive, 
                        &phkUsers[cLUAUsers].hkUserClasses);

                    ++cLUAUsers;
                }
            }
        }
        else if (lRes == ERROR_NO_MORE_ITEMS)
        {
            *pcUsers = cLUAUsers;
            lRes = ERROR_SUCCESS;
            goto EXIT;
        }
        else
        {
            break;
        }

        ++dwIndex;
    }

EXIT:

    RegCloseKey(hkProfileList);

    if (lRes == ERROR_SUCCESS)
    {
        return TRUE;
    }

    FreeUsersReg(phkUsers, cUsers);
    return FALSE;
}

VOID 
FreeUsersReg(
    USER_HIVE_KEY* phkUsers,
    DWORD cUsers
    )
{
    DWORD dw;

    // Close all the open keys.
    for (dw = 0; dw < cUsers; ++dw)
    {
        RegCloseKey(phkUsers[dw].hkUser);
        RegCloseKey(phkUsers[dw].hkUserClasses);
    }

    delete [] phkUsers;

    for (dw = 0; dw < g_cLoadedKeys; ++dw)
    {
        // Unloaded the keys we had to load under HKEY_USERS.
        RegUnLoadKey(HKEY_USERS, g_wszLoadedKeys[dw]);

        delete [] g_wszLoadedKeys[dw];
    }

    delete [] g_wszLoadedKeys;

    // Disable the "Restore files and directories" privilege.
    AdjustPrivilege(SE_RESTORE_NAME, FALSE);
}

//
// Registry utilies.
//

HKEY g_hkRedirectRoot = NULL;
HKEY g_hkCurrentUserClasses = NULL;

/*++

 Function Description:
    
    We only return TRUE if it's one of the predefined keys we are interested in.
    We don't redirect the HKEY_USERS and HKEY_PERFORMANCE_DATA keys.

 Arguments:

    IN hKey - the key handle.
    IN lpSubKey - subkey to check.

 Return Value:

    TRUE - It's one of our predefined keys.
    FALSE - It's either a non-predefined key or a predefined key that we are not
            interested in.

 History:

    03/27/2001 maonis  Created

--*/

BOOL 
IsPredefinedKey(
    IN HKEY hKey
    )
{
    return (
        hKey == HKEY_CLASSES_ROOT ||
        hKey == HKEY_CURRENT_USER ||
        hKey == HKEY_LOCAL_MACHINE);
}

LONG
GetRegRedirectKeys()
{
    LONG lRet;

    if (lRet = RegCreateKeyExW(
        HKEY_CURRENT_USER,
        LUA_REG_REDIRECT_KEY,
        0,
        0,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &g_hkRedirectRoot,
        NULL) == ERROR_SUCCESS)
    {
        lRet = RegCreateKeyExW(
            HKEY_CURRENT_USER,
            LUA_SOFTWARE_CLASSES,
            0,
            0,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &g_hkCurrentUserClasses,
            NULL);
    }

    return lRet;
}

#define IS_END_OF_COMPONENT(x) (*x == L'\\' || *x == L'\0')

/*++

 Function Description:

    Determines if 2 components match - one with wildcards and the other
    without.

    Note: this function is specialized for the LUA shims - the pattern
    is all lowercase. If the components match, we advance the string
    to the end of the component so when we do the whole path/file name
    matching we don't need to go through the string twice.

 Arguments:

    IN ppPattern - component with wildcards.
    IN ppString - component without wildcards.

 Return Value:
    
    TRUE - the components match.
    FALSE - the components don't match.

 History:

    05/10/2001 maonis  Created

--*/

BOOL
DoComponentsMatch(
    LPCWSTR* ppwszPattern,
    LPCWSTR* ppwszString)
{
    LPCWSTR pwszPattern = *ppwszPattern;
    LPCWSTR pwszString = *ppwszString;
    LPCWSTR pwszSearch = NULL;
    LPCWSTR pwszSearchPattern = NULL;

    BOOL fIsSuccess = TRUE;

    do
    {
        if (*pwszPattern == L'*')
        {
            while (*++pwszPattern == L'*');

            if (IS_END_OF_COMPONENT(pwszPattern))
            {
                // Advanced the string to the end.
                while (!IS_END_OF_COMPONENT(pwszString))
                {
                    ++pwszString;
                }

                goto EXIT;
            }

            pwszSearch = pwszString;
            pwszSearchPattern = pwszPattern;
        }

        if (IS_END_OF_COMPONENT(pwszString))
        {
            break;
        }

        if ((*pwszPattern == L'?') ||
            (*pwszPattern == *pwszString))
        {
            pwszPattern++;
        }
        else if (pwszSearch == NULL)
        {
            return FALSE;
        }
        else
        {
            pwszString = pwszSearch++;
            pwszPattern = pwszSearchPattern;
        }

        ++pwszString;

    } while (!IS_END_OF_COMPONENT(pwszString));

    if (*pwszPattern == L'*')
    {
        fIsSuccess = TRUE;
        ++pwszPattern;
    }
    else
    {
        fIsSuccess = IS_END_OF_COMPONENT(pwszPattern);
    }

EXIT:

    *ppwszPattern = pwszPattern;
    *ppwszString = pwszString;
    return fIsSuccess;
}

/*++

 Function Description:

    Determines if the item is in the redirect list.

 Arguments:

    IN pwszDirectory - All lowercase name.
    IN cDirectory - The length of the directory.
    IN pwszFile - The file name.

 Return Value:
    
    TRUE - the names match.
    FALSE - the names don't match.

 History:

    11/30/2001 maonis  Created

--*/

BOOL 
DoesItemMatchRedirect(
    LPCWSTR pwszItem,
    const RITEM* pItem,
    BOOL fIsDirectory
    )
{
    LPCWSTR pwszName = &(pItem->wszName[0]);
    BOOL fMatchComponents;

    if (pItem->fHasWC)
    {
        while (*pwszItem && *pwszName)
        {
            if (!DoComponentsMatch(&pwszName, &pwszItem))
            {
                return FALSE;
            }

            if (fIsDirectory)
            {
                if (!*pwszName)
                {
                    //
                    // directory has exhausted. It's a match.
                    //
                    return TRUE;
                }

                if (!*pwszItem)
                {
                    //
                    // directory hasn't exhausted but item has, no match.
                    //
                    return FALSE;
                }
            }
            else
            {
                if (!*pwszItem)
                {
                    //
                    // item has exhausted. It's a match.
                    //
                    return TRUE;
                }

                if (!*pwszName)
                {
                    //
                    // item hasn't exhausted but file has, no match.
                    //
                    return FALSE;
                }
            }

            ++pwszName;
            ++pwszItem;
        }

        if (fIsDirectory)
        {
            return (!*pwszName);
        }
        else
        {
            return (!*pwszItem);
        }
    }
    else
    {
        while (*pwszItem && *pwszName && *pwszItem == *pwszName)
        {
            ++pwszItem;
            ++pwszName;
        }

        if (fIsDirectory)
        {
            return (!*pwszName && (!*pwszItem || *pwszItem == L'\\'));
        }
        else
        {
            return (!*pwszItem && (!*pwszName || *pwszName == L'\\'));
        }
    }
}

/*++

 Function Description:

    Parse the commandline argument for the LUA shims using ' ' as the delimiter.
    If a token has spaces, use double quotes around it. Use this function the 
    same way you use wcstok except you don't have to specify the delimiter.

 Arguments:

    IN/OUT pwsz - the string to parse.

 Return Value:
    
    pointer to the next token.

 History:

    05/17/2001 maonis  Created

--*/

LPWSTR GetNextToken(
    LPWSTR pwsz
    )
{
    static LPWSTR pwszToken;
    static LPWSTR pwszEndOfLastToken;

    if (!pwsz)
    {
        pwsz = pwszEndOfLastToken;
    }

    // Skip the white space.
    while (*pwsz && *pwsz == ' ')
    {
        ++pwsz;
    }

    pwszToken = pwsz;

    BOOL fInsideQuotes = 0;

    while (*pwsz)
    {
        switch(*pwsz)
        {
        case L'"':
            fInsideQuotes ^= 1;

            if (fInsideQuotes)
            {
                ++pwszToken;
            }

        case L' ':
            if (!fInsideQuotes)
            {
                goto EXIT;
            }

        default:
            ++pwsz;
        }
    }

EXIT:
    if (*pwsz)
    {
        *pwsz = L'\0';
        pwszEndOfLastToken = ++pwsz;
    }
    else
    {
        pwszEndOfLastToken = pwsz;
    }
    
    return pwszToken;
}

/*++

 Function Description:

    Starting from the end going backward and find the first non whitespace
    char. Set the whitespace char after it to '\0'.

 Arguments:

    IN pwsz - Beginning pointer.

 Return Value:

    None.

 History:

    06/27/2001 maonis  Created

--*/

VOID TrimTrailingSpaces(
    LPWSTR pwsz
    )
{
    if (pwsz)
    {
        DWORD   cLen = wcslen(pwsz);
        LPWSTR  pwszEnd = pwsz + cLen - 1;

        while (pwszEnd >= pwsz && (*pwszEnd == L' ' || *pwszEnd == L'\t'))
        {
            --pwszEnd;
        }

        *(++pwszEnd) = L'\0';
    }
}

/*++

 Function Description:

    If the directory doesn't exist, we create it.

 Arguments:

    IN pwszDir - The name of the directory to create. The directory should NOT 
    start with \\?\ and it should haved a trailing slash.

 Return Value:

    TRUE - the directory was created.
    FALSE - otherwise.

 History:

    05/17/2001 maonis  Created

--*/

BOOL 
CreateDirectoryOnDemand(
    LPWSTR pwszDir
    )
{
    if (!pwszDir || !*pwszDir)
    {
        DPF("LUAUtils", eDbgLevelSpew, 
            "[CreateDirectoryOnDemand] Empty directory name - nothing to do");
        return TRUE;
    }

    WCHAR* pwszStartPath = pwszDir;
    WCHAR* pwszEndPath = pwszDir + wcslen(pwszDir);
    WCHAR* pwszStartNext = pwszStartPath;
       
    // Find the end of the next sub dir.
    WCHAR* pwszEndNext;
    DWORD dwAttrib;

    while (pwszStartNext < pwszEndPath)
    {
        pwszEndNext = wcschr(pwszStartNext, L'\\');
        if (pwszEndNext)
        {
            *pwszEndNext = L'\0';
            if ((dwAttrib = GetFileAttributesW(pwszStartPath)) != -1)
            {
                // If the directory already exists, we probe its sub directory.
                *pwszEndNext = L'\\';
                pwszStartNext = pwszEndNext + 1;
                continue;
            }

            if (!CreateDirectoryW(pwszStartPath, NULL))
            {
                DPF("LUAUtils", eDbgLevelError, 
                    "[CreateDirectoryOnDemand] CreateDirectory %S failed: %d", 
                    pwszStartPath, 
                    GetLastError());
                return FALSE;
            }

            *pwszEndNext = L'\\';
            pwszStartNext = pwszEndNext + 1;
        }
        else
        {
            DPF("LUAUtils", eDbgLevelError, 
                "[CreateDirectoryOnDemand] Invalid directory name: %S", pwszStartPath);
            return FALSE;
        }
    }

    return TRUE;
}

/*++

 Function Description:

    Expand a string which might have enviorment variables embedded in it.
    It gives you options to
    1) Add a trailing slash if there's not one;
    2) Create the directory if it doesn't exist;
    3) Add the \\?\ prefix;

    NOTE: The caller is responsible of free the memory using delete [].

 Arguments:

    IN pwszItem - string to expand.
    OUT pcItemExpand - number of characters in the resulting string.
                       NOTE: this *includes* the terminating NULL.
    IN fEnsureTrailingSlash - option 1.
    IN fCreateDirectory - option 2.
    IN fAddPrefix - option 3.

 Return Value:

    The expanded string or NULL if error occured.

 History:

    05/17/2001 maonis  Created

--*/

LPWSTR  
ExpandItem(
    LPCWSTR pwszItem,
    DWORD* pcItemExpand,
    BOOL fEnsureTrailingSlash,
    BOOL fCreateDirectory,
    BOOL fAddPrefix
    )
{
    BOOL fIsSuccess = FALSE;

    //
    // Get the required length.
    //
    DWORD cLenExpand = ExpandEnvironmentStringsW(pwszItem, NULL, 0);

    if (!cLenExpand)
    {
        DPF("LUAUtils", eDbgLevelError,
            "[ExpandItem] Failed to get the required buffer size "
            "when expanding %S: %d", 
            pwszItem, GetLastError());
        return NULL;
    }

    if (fEnsureTrailingSlash) 
    {
        ++cLenExpand;
    }

    if (fAddPrefix)
    {
        cLenExpand += FILE_NAME_PREFIX_LEN;
    }

    LPWSTR pwszItemExpand = new WCHAR [cLenExpand];
    if (!pwszItemExpand)
    {
        DPF("LUAUtils", eDbgLevelError,
            "[ExpandItem] Error allocating %d WCHARs", cLenExpand);
        return NULL;
    }

    LPWSTR pwszTemp = pwszItemExpand;
    DWORD cTemp = cLenExpand;

    if (fAddPrefix)
    {
        wcscpy(pwszItemExpand, FILE_NAME_PREFIX);
        pwszTemp += FILE_NAME_PREFIX_LEN;
        cTemp -= FILE_NAME_PREFIX_LEN;
    }

    if (!ExpandEnvironmentStringsW(pwszItem, pwszTemp, cTemp))
    {
        DPF("LUAUtils", eDbgLevelError,
            "[ExpandItem] Failed to expand %S: %d", 
            pwszItem, GetLastError());

        goto Cleanup;
    }
    
    // Ensure the trailing slash.
    if (fEnsureTrailingSlash)
    {
        if (pwszItemExpand[cLenExpand - 3] != L'\\')
        {
            pwszItemExpand[cLenExpand - 2] = L'\\';
            pwszItemExpand[cLenExpand - 1] = L'\0';
        }
        else
        {
            --cLenExpand;
        }

        if (fCreateDirectory && 
            !CreateDirectoryOnDemand(pwszItemExpand + (fAddPrefix ? 4 : 0)))
        {
            DPF("LUAUtils", eDbgLevelError,
                "[ExpandItem] Failed to create %S", 
                pwszItemExpand);
            goto Cleanup;
        }
    }

    *pcItemExpand = cLenExpand;

    fIsSuccess = TRUE;

Cleanup:

    if (!fIsSuccess)
    {
        delete [] pwszItemExpand;
        pwszItemExpand = NULL;
    }

    return pwszItemExpand;
}

/*++

 Function Description:

    Given a delimiter character, returns the number of items in the string.

 Return Value:

    Number of items in the string.

 History:

    11/13/2001 maonis  Created

--*/

DWORD 
GetItemsCount(
    LPCWSTR pwsz,
    WCHAR chDelimiter
    )
{
    DWORD cItems = 0;

    while (*pwsz) {

        if (*pwsz == chDelimiter) {
            ++cItems;
        }
        ++pwsz;
    }

    return (cItems + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\trackfs.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    TrackFS.cpp

 Abstract:

    Track the directories the app looks at and record them into a file.

 History:

    04/04/2001 maonis  Created

--*/

#include "precomp.h"
#include "utils.h"
#include "secutils.h"
#include <stdio.h>

#define APPPATCH_DIR L"AppPatch\\"
#define APPPATCH_DIR_LEN (sizeof(APPPATCH_DIR) / sizeof(WCHAR) - 1)

#define TRACK_LOG_SUFFIX L".LUA.log"
#define TRACK_LOG_SUFFIX_LEN (sizeof(TRACK_LOG_SUFFIX) / sizeof(WCHAR) - 1)

struct DISTINCT_OBJ
{
    DISTINCT_OBJ* next;

    LPWSTR pwszName;
};

static WCHAR g_wszProgramFiles[MAX_PATH] = L"";
static DWORD g_cProgramFiles = 0;

DWORD
LuatpGetProgramFilesDirW()
{
    if (g_cProgramFiles == 0)
    {
        WCHAR wszProgramFiles[MAX_PATH];

        if (GetEnvironmentVariableW(L"ProgramFiles", wszProgramFiles, MAX_PATH))
        {
            DWORD dwSize = GetLongPathNameW(wszProgramFiles, g_wszProgramFiles, MAX_PATH);

            if (dwSize <= MAX_PATH)
            {
                //
                // Only if we successfully got the path and it's not more
                // than MAX_PATH will we set the global values.
                //
                g_cProgramFiles = dwSize;
            }
            else
            {
                g_wszProgramFiles[0] = L'\0';
            }
        }
    }

    return g_cProgramFiles;
}

BOOL
LuatpIsProgramFilesDirectory(
    LPCWSTR pwszPath
    )
{
    LuatpGetProgramFilesDirW();

    if (g_cProgramFiles)
    {
        return !_wcsnicmp(pwszPath, g_wszProgramFiles, g_cProgramFiles);
    }
    
    return FALSE;
}

// We only record things when the file
// 1) is not in the user profile dir - in which we know we don't need to redirect;
// 2) is not in the program files dir - in which we know we will need to redirect;
// because in those cases we know what to do so the user doesn't need to make the 
// choice.
BOOL
LuatpShouldRecord(
    LPCWSTR pwszPath
    )
{
    //if (LuatpIsUserDirectory(pwszPath) || 
    //    LuatpIsProgramFilesDirectory(pwszPath))
    if (IsUserDirectory(pwszPath))
    {
        return FALSE;
    }

    return TRUE;
}

LPWSTR 
LuatpGetLongObjectName(
    LPCWSTR pwszName,
    BOOL fIsDirectory
    )
{
    BOOL fIsSuccess = FALSE;
    LPWSTR pwszLongNameObject = NULL;
    LPWSTR pwszObject = NULL;

    if (!pwszName)
    {
        return NULL;
    }

    //
    // First get the full path.
    //
    DWORD cFullPath = GetFullPathNameW(pwszName, 0, NULL, NULL);

    if (!cFullPath)
    {
        DPF("TrackFS", eDbgLevelError,
            "[LuatpGetLongObjectName] Failed to get the length of full path: %d",
            GetLastError());

        return NULL;
    }

    //
    // We allocate one more char to make space for the trailing slash for dir names.
    //
    pwszObject = new WCHAR [cFullPath + 1];

    if (!pwszObject)
    {
        DPF("TrackFS", eDbgLevelError,
            "[LuatpGetLongObjectName] Failed to allocate %d WCHARs",
            cFullPath + 1);

        return NULL;  
    }

    if (!GetFullPathNameW(pwszName, cFullPath, pwszObject, NULL))
    {
        DPF("TrackFS", eDbgLevelError,
            "[LuatpGetLongObjectName] Failed to get the full path: %d",
            GetLastError());

        goto EXIT;
    }

    //
    // If it's not a valid file name, we don't add it.
    //
    if (wcslen(pwszObject) < 2 || !iswalpha(pwszObject[0]) || (pwszObject[1] != L':'))
    {
        goto EXIT;
    }

    if (fIsDirectory)
    {
        //
        // If it's a directory we make sure there's a trailing slash.
        //
        if (pwszObject[cFullPath - 2] != L'\\')
        {
            pwszObject[cFullPath - 1] = L'\\';
            pwszObject[cFullPath] = L'\0';
        }
    }

    //
    // Convert it to all lower case.
    //
    _wcslwr(pwszObject);

    //
    // Convert it to the long names.
    //
    DWORD cLongPath = GetLongPathName(pwszObject, NULL, 0);

    if (!cLongPath)
    {
        DPF("TrackFS", eDbgLevelError,
            "[LuatpGetLongObjectName] Failed to get the length of long path: %d",
            GetLastError());

        goto EXIT;
    }

    pwszLongNameObject = new WCHAR [cLongPath];

    if (!pwszLongNameObject)
    {
        DPF("TrackFS", eDbgLevelError,
            "[LuatpGetLongObjectName] Failed to allocate %d WCHARs",
            cLongPath);

        goto EXIT;
    }

    if (!GetLongPathName(pwszObject, pwszLongNameObject, cLongPath))
    {
        DPF("TrackFS", eDbgLevelError,
            "[LuatpGetLongObjectName] Failed to get the long path: %d",
            GetLastError());

        goto EXIT;
    }

    if (LuatpShouldRecord(pwszLongNameObject))
    {
        //
        // We only record the objects that are not in the user profile directory.
        //
        fIsSuccess = TRUE;
    }

EXIT:

    delete [] pwszObject;

    if (!fIsSuccess)
    {
        delete [] pwszLongNameObject;
        pwszLongNameObject = NULL;
    }

    return pwszLongNameObject;
}

/*++

    The tracking class for the file system.
    
 History:

    04/04/2001 maonis  Created

--*/

class CTrackObject
{
public:
    BOOL Init();
    VOID Free();

    // If the object name needs to be processed, eg, it's not the full path
    // or not the long name, call this method to process it first before
    // adding to the list.
    VOID AddObject(LPCWSTR pwszName, BOOL fIsDirectory);

    // If the caller already processed the file name, call this method
    // to add it directly.
    VOID AddObjectDirect(LPWSTR pwszName, BOOL fIsDirectory);
    
    // This is specially for GetTempFileName - we add
    // *.tmp after the path.
    VOID AddObjectGetTempFileName(LPCWSTR pwszPath);

    VOID Record();

private:

    BOOL AddObjectToList(LPWSTR pwszName, BOOL fIsDirectory);

    VOID WriteToLog(LPCWSTR pwszDir);

    HANDLE m_hLog;
    WCHAR m_wszLog[MAX_PATH];

    DISTINCT_OBJ* m_pDistinctDirs;
    DISTINCT_OBJ* m_pDistinctFiles;

    DWORD m_cDistinctDirs;
    DWORD m_cDistinctFiles;
};

BOOL 
CTrackObject::AddObjectToList(
    LPWSTR pwszName,
    BOOL fIsDirectory
    )
{
    BOOL fIsSuccess = FALSE;

    DISTINCT_OBJ* pDistinctObjs = fIsDirectory ? m_pDistinctDirs : m_pDistinctFiles;
    DISTINCT_OBJ* pObj = pDistinctObjs;

    // Check to see if this file already exists in the list.
    while (pObj)
    {
        if (!wcscmp(pObj->pwszName, pwszName))
        {
            break;
        }

        pObj = pObj->next;
    }

    if (!pObj)
    {
        pObj = new DISTINCT_OBJ;
        if (pObj)
        {
            DWORD cLen = wcslen(pwszName);

            pObj->pwszName = new WCHAR [cLen + 1];
            
            if (pObj->pwszName)
            {
                wcscpy(pObj->pwszName, pwszName);
                pObj->next = pDistinctObjs;

                if (fIsDirectory)
                {
                    ++m_cDistinctDirs;
                    m_pDistinctDirs = pObj;
                }
                else
                {
                    ++m_cDistinctFiles;
                    m_pDistinctFiles = pObj;
                }

                fIsSuccess = TRUE;
            }
            else
            {
                DPF("TrackFS", eDbgLevelError, 
                    "[CTrackObject::AddObjectToList] Error allocating %d WCHARs",
                    cLen + 1);
            }
        }
        else
        {
            DPF("TrackFS", eDbgLevelError, 
                "[CTrackObject::AddObjectToList] Error allocating memory for new node");
        }
    }
    
    return fIsSuccess;
}

/*++

 Function Description:

    For files it's simple - we just store the file name in a list and search
    through the list to see if it's already in the list. If it is we are done;
    else we add it to the beginning of the list.
    We don't expect there are too many calls to modify files so a linked list
    is fine.
    
 Arguments:
    
    IN pwszFileName - file name.

 Return Value:

    none.

 History:

    05/08/2001 maonis  Created

--*/

VOID 
CTrackObject::AddObject(
    LPCWSTR pwszName,
    BOOL fIsDirectory
    )
{
    BOOL fIsSuccess = FALSE;

    LPWSTR pwszLongNameObject = LuatpGetLongObjectName(pwszName, fIsDirectory);

    if (pwszLongNameObject)
    {
        AddObjectToList(pwszLongNameObject, fIsDirectory);

        delete [] pwszLongNameObject;
    }
}

VOID 
CTrackObject::AddObjectDirect(
    LPWSTR pwszName,
    BOOL fIsDirectory
    )
{
    if (pwszName)
    {
        AddObjectToList(pwszName, fIsDirectory);
    }
}

/*++

 Function Description:

    Write the directory to the log as ANSI characters.
    Note this method uses 2 str* routines and it IS DBCS aware.
    
 Arguments:
    
    IN pwszDir - the directory to write to the log.

 Return Value:

    None.
    
 History:

    04/04/2001 maonis  Created

--*/

VOID 
CTrackObject::WriteToLog(
    LPCWSTR pwsz)
{
    if (!pwsz || !*pwsz)
    {
        return;
    }

    //
    // Get the number of bytes required to convert the string to ansi.
    //
    DWORD dwSize = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL);

    LPSTR psz = new CHAR [dwSize + 2];
    if (psz)
    {
        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, dwSize, 0, 0);
        psz[dwSize - 1] = '\r';
        psz[dwSize] = '\n';
        psz[dwSize + 1] = '\0';

        DWORD dwBytesWritten = 0;

        WriteFile(
            m_hLog, 
            psz, 
            dwSize + 1,
            &dwBytesWritten,
            NULL);

        delete [] psz;
    }
    else
    {
        DPF("TrackFS",  eDbgLevelError, 
            "[CTrackObject::WriteToLog] Failed to allocate %d CHARs", 
            dwSize);        
    }
}

/*++

 Function Description:

    Create the log file in %windir%\apppatch directory. We want to make sure
    we can create this file so we don't run the app to the end only to find
    that we can't record the results into a file.
    
 Arguments:
    
    None

 Return Value:

    TRUE - if log created successfully.
    FALSE otherwise.
    
 History:

    04/04/2001 maonis  Created

--*/

BOOL 
CTrackObject::Init()
{
    m_pDistinctDirs = NULL;
    m_pDistinctFiles = NULL;
    m_cDistinctDirs = 0;
    m_cDistinctFiles = 0;

    WCHAR  szModuleName[MAX_PATH + 1] = L"";
    LPWSTR pwszModuleNameStart = NULL;
    LPWSTR pwszModuleNameExtStart = NULL;
    DWORD  cAppPatchLen = 0;
    DWORD  cModuleNameLen = 0;
    DWORD  cTotalLen = 0;
    DWORD  dwRes = 0;

    GetSystemRootDirW();

    //
    // GetModuleFileNameW is an awful API. If you don't pass in a buffer 
    // that's big enough to hold the module (including the terminating NULL), it
    // returns the passed in buffer size (NOT the required length) which means
    // it doesn't return an error - it just fills upto the passed in buffer size
    // so does NOT NULL terminate the string. So we set the last char to NULL and
    // make sure it doesn't get overwritten.
    //
    szModuleName[MAX_PATH] = L'\0';

    dwRes = GetModuleFileNameW(NULL, szModuleName, MAX_PATH + 1); 

    if (!dwRes || szModuleName[MAX_PATH] != L'\0')
    {
        DPF("TrackFS",  eDbgLevelError, 
            "[CTrackObject::Init] Error getting the module name: %d",
            GetLastError());

        return FALSE;
    }

    pwszModuleNameStart = wcsrchr(szModuleName, L'\\');

    if (!pwszModuleNameStart)
    {
        DPF("TrackFS",  eDbgLevelError, 
            "[CTrackObject::Init] We can't find where the file name starts??? %S",
            szModuleName);

        return FALSE;
    }

    ++pwszModuleNameStart;
    cModuleNameLen = wcslen(pwszModuleNameStart);

    //
    // We don't need the path anymore.
    //
    memmove(szModuleName, pwszModuleNameStart, cModuleNameLen * sizeof(WCHAR));
    szModuleName[cModuleNameLen] = L'\0';

    //
    // Get rid of the extension.
    //
    pwszModuleNameExtStart = wcsrchr(szModuleName, L'.');

    //
    // If there's no extension we just use the whole file name.
    //
    if (pwszModuleNameExtStart)
    {
        *pwszModuleNameExtStart = L'\0';
    }

    cModuleNameLen = wcslen(szModuleName);

    //
    // Make sure we don't have a buffer overflow.
    //
    cTotalLen = 
        g_cSystemRoot + APPPATCH_DIR_LEN + // %windir%\AppPatch\ dir
        cModuleNameLen + // module name without extension
        TRACK_LOG_SUFFIX_LEN + // .LUA.log suffix
        1; // terminating NULL

    if (cTotalLen > MAX_PATH)
    {
        DPF("TrackFS",  eDbgLevelError, 
            "[CTrackObject::Init] The file name is %d chars - "
            "we don't handle names longer than MAX_PATH",
            cTotalLen);

        return FALSE;
    }

    //
    // Construct the file name.
    //
    wcsncpy(m_wszLog, g_wszSystemRoot, g_cSystemRoot);
    wcsncpy(m_wszLog + g_cSystemRoot, APPPATCH_DIR, APPPATCH_DIR_LEN);
    wcsncpy(m_wszLog + (g_cSystemRoot + APPPATCH_DIR_LEN), szModuleName, cModuleNameLen);
    wcsncpy(m_wszLog + (g_cSystemRoot + APPPATCH_DIR_LEN + cModuleNameLen), TRACK_LOG_SUFFIX, TRACK_LOG_SUFFIX_LEN);
    m_wszLog[cTotalLen - 1] = L'\0';

    //
    // Delete the file first if it exists.
    //
    DeleteFileW(m_wszLog);

    if ((m_hLog = CreateFileW(
        m_wszLog,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL)) == INVALID_HANDLE_VALUE)
    {
        DPF("TrackFS",  eDbgLevelError, 
            "[CTrackObject::Init] Error creating log %S: %d", m_wszLog, GetLastError());

        return FALSE;
    }
    else
    {
        DPF("TrackFS",  eDbgLevelInfo, "[CTrackObject::Init] Created the log %S", m_wszLog);
        CloseHandle(m_hLog);
        return TRUE;
    }
}

/*++

 Function Description:

    Free the linked list.
    
 Arguments:
    
    None

 Return Value:

    None
    
 History:

    04/04/2001 maonis  Created

--*/

VOID 
CTrackObject::Free()
{
    DISTINCT_OBJ* pDir = m_pDistinctDirs;
    DISTINCT_OBJ* pTempDir;

    while (pDir)
    {
        pTempDir = pDir;
        pDir = pDir->next;

        delete [] pTempDir->pwszName;
        delete pTempDir;
    }
}

/*++

 Function Description:

    Write the list of directories to the log.
    
 Arguments:
    
    None

 Return Value:

    None
    
 History:

    04/04/2001 maonis  Created

--*/

VOID 
CTrackObject::Record()
{
    if ((m_hLog = CreateFileW(
        m_wszLog,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL)) != INVALID_HANDLE_VALUE)
    {
        // Empty the old log.
        SetFilePointer(m_hLog, 0, 0, FILE_BEGIN);
        SetEndOfFile(m_hLog);

        WCHAR wszHeader[32];
        if (_snwprintf(wszHeader, 31, L"D%d", m_cDistinctDirs) < 0)
        {
            DPF("TrackFS", eDbgLevelError,
                "[CTrackObject::Record] Too many dirs??? %d",
                m_cDistinctDirs);

            return;
        }

        wszHeader[31] = L'\0'; 
        WriteToLog(wszHeader);

        //
        // Dump the directories to the log - each dir is on its own line.
        //
        DISTINCT_OBJ* pDir = m_pDistinctDirs;

        while (pDir)
        {
            WriteToLog(pDir->pwszName);
            pDir = pDir->next;
        }

        if (_snwprintf(wszHeader, 31, L"F%d", m_cDistinctFiles) < 0)
        {
            DPF("TrackFS", eDbgLevelError,
                "[CTrackObject::Record] Too many files??? %d",
                m_cDistinctFiles);

            return;
        }

        wszHeader[31] = L'\0'; 
        WriteToLog(wszHeader);

        //
        // Dump the files to the log - each file is on its own line.
        //
        DISTINCT_OBJ* pFile = m_pDistinctFiles;

        while (pFile)
        {
            WriteToLog(pFile->pwszName);
            pFile = pFile->next;
        }

        CloseHandle(m_hLog);
    }

    // Make the file hidden so people don't accidently mess it up.
    DWORD dwAttrib = GetFileAttributes(m_wszLog);
    SetFileAttributes(m_wszLog, dwAttrib | FILE_ATTRIBUTE_HIDDEN);
}

CTrackObject g_td;

/*++

 Custom exception handler.

--*/

LONG 
ExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    // Whenever we get an unhandled exception, we dump the stuff to the log.
    g_td.Record();

    return EXCEPTION_CONTINUE_SEARCH;
}


//
// Exported APIs.
//

HANDLE 
LuatCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[CreateFileW] lpFileName=%S; dwDesiredAccess=0x%08x; dwCreationDisposition=%d",
        lpFileName, dwDesiredAccess, dwCreationDisposition);

    HANDLE hFile = CreateFileW(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);

    if (hFile != INVALID_HANDLE_VALUE) 
    {
        LUA_GET_API_ERROR;

        if (RequestWriteAccess(dwCreationDisposition, dwDesiredAccess))
        {
            g_td.AddObject(lpFileName, FALSE);
        }        

        LUA_SET_API_ERROR;
    }

    return hFile;
}

BOOL 
LuatCopyFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[CopyFileW] lpExistingFileName=%S; lpNewFileName=%S; bFailIfExists=%d",
        lpExistingFileName, lpNewFileName, bFailIfExists);
    
    BOOL bRet = CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);

    if (bRet)
    {
        LUA_GET_API_ERROR;
        g_td.AddObject(lpNewFileName, FALSE);
        LUA_SET_API_ERROR;
    }

    return bRet;
}

BOOL 
LuatCreateDirectoryW(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[CreateDirectoryW] lpPathName=%S", lpPathName);

    BOOL bRet = CreateDirectoryW(lpPathName, lpSecurityAttributes);

    if (bRet)
    {
        LUA_GET_API_ERROR;
        g_td.AddObject(lpPathName, TRUE);
        LUA_SET_API_ERROR;
    }

    return bRet;
}

BOOL 
LuatSetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
  )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[SetFileAttributesW] lpFileName=%S", lpFileName);

    BOOL bRet = SetFileAttributesW(lpFileName, dwFileAttributes);

    if (bRet)
    {
        LUA_GET_API_ERROR;

        DWORD dwAttrib = GetFileAttributesW(lpFileName);
        if (dwAttrib != -1)
        {
            g_td.AddObject(lpFileName, dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
        }

        LUA_SET_API_ERROR;
    }

    return bRet;
}

BOOL 
LuatDeleteFileW(
    LPCWSTR lpFileName
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[DeleteFileW] lpFileName=%S", lpFileName);

    LPWSTR pwszTempFile = LuatpGetLongObjectName(lpFileName, FALSE);

    BOOL bRet = DeleteFileW(lpFileName);

    if (bRet)
    {
        LUA_GET_API_ERROR;
        g_td.AddObjectDirect(pwszTempFile, FALSE);
        LUA_SET_API_ERROR;
    }

    delete [] pwszTempFile;

    return bRet;
}

BOOL 
LuatMoveFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[MoveFileW] lpExistingFileName=%S; lpNewFileName=%S", lpExistingFileName, lpNewFileName);

    LPWSTR pwszTempFile = LuatpGetLongObjectName(lpExistingFileName, FALSE);

    BOOL bRet = MoveFileW(lpExistingFileName, lpNewFileName);

    if (bRet)
    {
        LUA_GET_API_ERROR;
        g_td.AddObjectDirect(pwszTempFile, FALSE);
        g_td.AddObject(lpNewFileName, FALSE);
        LUA_SET_API_ERROR;
    }

    delete [] pwszTempFile;

    return bRet;
}

BOOL 
LuatRemoveDirectoryW(
    LPCWSTR lpPathName
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[RemoveDirectoryW] lpPathName=%S", lpPathName);

    LPWSTR pwszTempDir = LuatpGetLongObjectName(lpPathName, TRUE);

    BOOL bRet = RemoveDirectoryW(lpPathName);

    if (bRet)
    {
        LUA_GET_API_ERROR;
        g_td.AddObjectDirect(pwszTempDir, TRUE);
        LUA_SET_API_ERROR;
    }

    delete [] pwszTempDir;

    return bRet;
}

UINT 
LuatGetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[GetTempFileNameW] lpPathName=%S", lpPathName);

    UINT uiRet = GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);

    if (uiRet && !uUnique)
    {
        LUA_GET_API_ERROR;
        g_td.AddObject(lpTempFileName, FALSE);
        LUA_SET_API_ERROR;
    }

    return uiRet;
}

BOOL 
LuatWritePrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    DPF("TrackFS", eDbgLevelInfo, 
        "[WritePrivateProfileStringW] lpAppName=%S; lpKeyName=%S; lpString=%S; lpFileName=%S", 
        lpAppName, lpKeyName, lpString, lpFileName);

    BOOL bRet = WritePrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpString,
        lpFileName);

    if (bRet)
    {
        LUA_GET_API_ERROR;

        WCHAR wszFileName[MAX_PATH] = L"";
        MakeFileNameForProfileAPIsW(lpFileName, wszFileName);
        g_td.AddObject(wszFileName, FALSE);

        LUA_SET_API_ERROR;
    }

    return bRet;
}

BOOL 
LuatWritePrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    DPF("TrackFS", eDbgLevelInfo, 
        "[WritePrivateProfileSectionW] lpAppName=%S; lpString=%S; lpFileName=%S", 
        lpAppName, lpString, lpFileName);

    BOOL bRet = WritePrivateProfileSectionW(
        lpAppName,
        lpString,
        lpFileName);

    if (bRet)
    {
        LUA_GET_API_ERROR;

        WCHAR wszFileName[MAX_PATH] = L"";
        MakeFileNameForProfileAPIsW(lpFileName, wszFileName);

        g_td.AddObject(wszFileName, FALSE);

        LUA_SET_API_ERROR;
    }

    return bRet;
}

BOOL 
LuatWritePrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    )
{
    DPF("TrackFS", eDbgLevelInfo, 
        "[WritePrivateProfileStructW] lpszKey=%S; szFile=%S", 
        lpszKey, szFile);

    BOOL bRet = WritePrivateProfileStructW(
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile);

    if (bRet)
    {
        LUA_GET_API_ERROR;

        WCHAR wszFileName[MAX_PATH] = L"";
        MakeFileNameForProfileAPIsW(szFile, wszFileName);

        g_td.AddObject(wszFileName, FALSE);

        LUA_SET_API_ERROR;
    }

    return bRet;
}

HFILE 
LuatOpenFile(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    )
{
    DPF("TrackFS", eDbgLevelInfo, 
        "[OpenFile] lpFileName=%s", lpFileName);

    STRINGA2W wstrFileName(lpFileName);
    LPWSTR pwszTempFile = LuatpGetLongObjectName(wstrFileName, FALSE);

    HFILE hFile = OpenFile(lpFileName, lpReOpenBuff, uStyle);

    if (hFile != HFILE_ERROR)
    {
        if (uStyle & OF_CREATE || 
            uStyle & OF_DELETE ||
            uStyle & OF_READWRITE ||
            uStyle & OF_WRITE)
        {
            LUA_GET_API_ERROR;

            g_td.AddObjectDirect(pwszTempFile, FALSE);

            LUA_SET_API_ERROR;
        }
    }

    delete [] pwszTempFile;

    return hFile;
}

HFILE 
Luat_lopen(
    LPCSTR lpPathName,
    int iReadWrite
    )
{
    DPF("TrackFS", eDbgLevelInfo, 
        "[_lopen] lpPathName=%s", lpPathName);

    HFILE hFile = _lopen(lpPathName, iReadWrite);

    if (hFile != HFILE_ERROR)
    {
        if (iReadWrite & OF_READWRITE || iReadWrite & OF_WRITE)
        {
            LUA_GET_API_ERROR;

            STRINGA2W wstrPathName(lpPathName);
            g_td.AddObject(wstrPathName, FALSE);

            LUA_SET_API_ERROR;
        }

    }

    return hFile;
}

HFILE 
Luat_lcreat(
    LPCSTR lpPathName,
    int iAttribute
    )
{
    DPF("TrackFS", eDbgLevelInfo, 
        "[_lcreat] lpPathName=%s", lpPathName);

    HFILE hFile = _lcreat(lpPathName, iAttribute);

    if (hFile != HFILE_ERROR)
    {
        LUA_GET_API_ERROR;

        STRINGA2W wstrPathName(lpPathName);
        g_td.AddObject(wstrPathName, FALSE);

        LUA_SET_API_ERROR;
    }

    return hFile;
}

BOOL
LuatFSInit()
{
    SetUnhandledExceptionFilter(ExceptionFilter);

    return g_td.Init();
}

VOID 
LuatFSCleanup()
{
    g_td.Record();
    g_td.Free();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\utils.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   LUA_RedirectFS_Cleanup.cpp

 Abstract:

   Delete the redirected copies in every user's directory.

 Created:

   02/12/2001 maonis

 Modified:


--*/
#ifndef _LUA_UTILS_H_
#define _LUA_UTILS_H_

//
// Preserve the last error of the original API call.
//
#define LUA_GET_API_ERROR DWORD LUA_LAST_ERROR = GetLastError()
#define LUA_SET_API_ERROR SetLastError(LUA_LAST_ERROR)

//
// Long file names need this prefix.
//
#define FILE_NAME_PREFIX L"\\\\?\\"
// length doesn't include the terminating NULL.
#define FILE_NAME_PREFIX_LEN (sizeof(FILE_NAME_PREFIX) / sizeof(WCHAR) - 1)

//----------------
// Dynamic array.
//----------------
template <typename TYPE>
class CLUAArray
{
public:
    CLUAArray();
    ~CLUAArray();

    bool IsEmpty() const;
    DWORD GetSize() const;
    DWORD GetAllocSize() const;
    VOID SetSize(DWORD iNewSize);

    // Potentially growing the array
    VOID SetAtGrow(DWORD iIndex, TYPE newElement);
    // return the index of the new element.
    DWORD Add(TYPE newElement);
    DWORD Append(const CLUAArray& src);
    VOID RemoveAt(DWORD iIndex, DWORD nCount = 1);
    VOID Copy(const CLUAArray& src);

    const TYPE& operator[](DWORD iIndex) const;
    TYPE& operator[](DWORD iIndex);

    const TYPE& GetAt(DWORD iIndex) const;
    TYPE& GetAt(DWORD iIndex);

private:
    
    VOID DestructElements(TYPE* pElements, DWORD nCount);
    VOID ConstructElements(TYPE* pElements, DWORD nCount);
    VOID CopyElements(TYPE* pDest, const TYPE* pSrc, DWORD nCount);

    TYPE* m_pData;

    DWORD m_cElements;
    DWORD m_cMax; // the max allocated.
};

#include "utils.inl"

//
// If the file is already in the user's directory, we don't 
// redirect or track it.
//
extern WCHAR g_wszUserProfile[MAX_PATH];
extern DWORD g_cUserProfile;

//
// The PrivateProfile APIs look into the windows directory if 
// the filename doesn't contain a path.
//
extern WCHAR g_wszSystemRoot[MAX_PATH];
extern DWORD g_cSystemRoot;

BOOL 
IsUserDirectory(LPCWSTR pwszPath);

DWORD
GetSystemRootDirW();

BOOL
MakeFileNameForProfileAPIsW(LPCWSTR lpFileName, LPWSTR pwszFullPath);

//----------------------------------
// Unicode/ANSI conversion routines.
//----------------------------------

struct STRINGA2W
{
    STRINGA2W(LPCSTR psz, BOOL fCopy = TRUE)
    {
        m_pwsz = NULL;
        m_fIsOutOfMemory = FALSE;

        if (psz)
        {
            // I realize I am using strlen here but this would only allocate enough or more
            // spaces than we need. And a STRINGA2W object only lives for a very short time.
            UINT cLen = strlen(psz) + 1;

            m_pwsz = new WCHAR [cLen];
            if (m_pwsz)
            {
                if (fCopy)
                {
                    MultiByteToWideChar(CP_ACP, 0, psz, -1, m_pwsz, cLen);
                }
            }
            else
            {
                m_fIsOutOfMemory = TRUE;
            }
        }
    }

    ~STRINGA2W()
    {
        delete [] m_pwsz;
    }

    operator LPWSTR() const { return m_pwsz; }

    BOOL m_fIsOutOfMemory;

private:

    LPWSTR m_pwsz;
};

// If we need to allocate buffer for the ansi string.
inline LPSTR 
UnicodeToAnsi(LPCWSTR pwsz)
{
    LPSTR psz = NULL;

    if (pwsz)
    {
        // Taking DBCS into consideration.
        UINT cLen = wcslen(pwsz) * 2 + 1;

        psz = new CHAR [cLen];

        if (psz)
        {
            WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, cLen, 0, 0);
        }
    }

    return psz;
}

// If we need to allocate buffer for the unicode string.
inline LPWSTR 
AnsiToUnicode(LPCSTR psz)
{
    LPWSTR pwsz = NULL;

    if (psz)
    {
        UINT cLen = strlen(psz) + 1;

        pwsz = new WCHAR [cLen];

        if (pwsz)
        {
            MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cLen);
        }
    }

    return pwsz;
}

// If we already have buffer allocated for the ansi string.
inline VOID 
UnicodeToAnsi(LPCWSTR pwsz, LPSTR psz)
{
    if (pwsz && psz)
    {
        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, wcslen(pwsz) * 2 + 1, 0, 0);
    }    
}

// If we already have buffer allocated for the ansi string.
inline VOID 
AnsiToUnicode(LPCSTR psz, LPWSTR pwsz)
{
    if (pwsz && psz)
    {
        MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, strlen(psz) + 1);
    }    
}

//----------------
// File utilities.
//----------------

inline VOID 
FindDataW2A(WIN32_FIND_DATAW* pfdw, WIN32_FIND_DATAA* pfda)
{
    memcpy(pfda, pfdw, sizeof(WIN32_FIND_DATAA) - (MAX_PATH + 14) * sizeof(CHAR));
    
    UnicodeToAnsi(pfdw->cFileName, pfda->cFileName);
    UnicodeToAnsi(pfdw->cAlternateFileName, pfda->cAlternateFileName);
}

// When using the Profile APIs, the returned buffer could contain multiple
// NULLs - one NULL after each string and 2 NULLs after the final string.
inline VOID 
ConvertBufferForProfileAPIs(LPCWSTR pwsz, DWORD nSize, LPSTR psz)
{
    if (pwsz && psz)
    {
        WideCharToMultiByte(CP_ACP, 0, pwsz, nSize, psz, nSize, 0, 0);
    }
}

inline BOOL 
IsErrorNotFound()
{
    DWORD dwLastError = GetLastError();
    return (dwLastError == ERROR_FILE_NOT_FOUND || dwLastError == ERROR_PATH_NOT_FOUND);
}

// Each RITEM represents a file or a directory that the user wants to redirect.
struct RITEM
{
    WCHAR wszName[MAX_PATH];
    DWORD cLen;
    BOOL fHasWC;   // Does this item have wildcards in it?
    BOOL fAllUser; // Should this item be redirected to the All User dir?
};

//---------------------
// Registry utilities.
//---------------------


// This is where we store all the redirected registry keys.
#define LUA_REG_REDIRECT_KEY L"Software\\Redirected"
#define LUA_REG_REDIRECT_KEY_LEN (sizeof("Software\\Redirected") / sizeof(CHAR) - 1)

#define LUA_SOFTWARE_CLASSES L"Software\\Classes"
#define LUA_SOFTWARE_CLASSES_LEN (sizeof("Software\\Classes") / sizeof(CHAR) - 1)

extern HKEY g_hkRedirectRoot;
extern HKEY g_hkCurrentUserClasses;

LONG
GetRegRedirectKeys();

BOOL 
IsPredefinedKey(
    IN HKEY hKey
    );

//
// Name matching utilities.
//

BOOL DoNamesMatch(
    IN LPCWSTR pwszNameL, 
    IN LPCWSTR pwszName
    );

BOOL DoNamesMatchWC(
    IN LPCWSTR pwszNameWC, 
    IN LPCWSTR pwszName
    );

BOOL 
DoesItemMatchRedirect(
    LPCWSTR pwszItem,
    const RITEM* pItem,
    BOOL fIsDirectory
    );

//
// Commandline utilities.
// We only deal with file/dir names so we don't need to consider anything that
// has invalid characters for filenames.
//

LPWSTR GetNextToken(LPWSTR pwsz);

VOID TrimTrailingSpaces(LPWSTR pwsz);

BOOL 
CreateDirectoryOnDemand(
    LPWSTR pwszDir
    );

LPWSTR  
ExpandItem(
    LPCWSTR pwszItem,
    DWORD* pcItemExpand,
    BOOL fEnsureTrailingSlash,
    BOOL fCreateDirectory,
    BOOL fAddPrefix
    );

DWORD 
GetItemsCount(
    LPCWSTR pwsz,
    WCHAR chDelimiter
    );

BOOL LuaShouldApplyShim();

// 
// Cleanup utilities.
// Get the users on the local machine. So we can delete all the redirected stuff.
//

struct REDIRECTED_USER_PATH
{
    LPWSTR pwszPath;
    DWORD cLen;
};

struct USER_HIVE_KEY
{
    HKEY hkUser;
    HKEY hkUserClasses;
};

BOOL GetUsersFS(REDIRECTED_USER_PATH** ppRedirectUserPaths, DWORD* pcUsers);
VOID FreeUsersFS(REDIRECTED_USER_PATH* pRedirectUserPaths);

BOOL GetUsersReg(USER_HIVE_KEY** pphkUsers, DWORD* pcUsers);
VOID FreeUsersReg(USER_HIVE_KEY* phkUsers, DWORD cUsers);

#endif // _LUA_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\3dfrogfrenzy.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    3DFrogFrenzy.cpp

 Abstract:

    Workaround for a USER bug (or by design behaviour) where if you call 
    SetCursor(NULL) and the cursor is over somebody elses window, the 
    cursor stays visible. 

    We don't normally see this because most apps that want the cursor to 
    be invisible are full-screen: so the cursor is always over their window.

 Notes:

    This is an app-specific shim.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(3DFrogFrenzy)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetCursor)
APIHOOK_ENUM_END

/*++

 Move the cursor to the middle of their window, so that SetCursor works.

--*/

HCURSOR
APIHOOK(SetCursor)( 
    HCURSOR hCursor
    )
{
    HWND hWndFrog = FindWindowW(L"3DFrog", L"3D Frog Frenzy");
    BOOL bRet = FALSE;
    
    if (hWndFrog) {
        RECT r;
        if (GetWindowRect(hWndFrog, &r)) {
            SetCursorPos(r.left + (r.right - r.left) / 2, r.top + (r.bottom - r.top) / 2);
        }
    }
    
    return ORIGINAL_API(SetCursor)(hCursor);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetCursor)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\lua\utils.inl ===
//
// CLUAArray implementation.
//
template <typename TYPE>
CLUAArray<TYPE>::CLUAArray() 
: 
m_cElements(0),
m_cMax(0),
m_pData(NULL)
{
}

template <typename TYPE>
CLUAArray<TYPE>::~CLUAArray()
{
    SetSize(0);
}

template <typename TYPE>
DWORD CLUAArray<TYPE>::GetSize() const
{
    return m_cElements;
}

template <typename TYPE>
DWORD CLUAArray<TYPE>::GetAllocSize() const
{
    return m_cMax;
}

template <typename TYPE>
bool CLUAArray<TYPE>::IsEmpty() const
{
    return (m_cElements ? false : true);
}

template <typename TYPE>
VOID CLUAArray<TYPE>::SetSize(DWORD iNewSize)
{
    ASSERT(iNewSize >= 0, "Size cannot be negative");

    if (iNewSize)
    {
        if (m_pData)
        {
            // we already allocated enough space.
            if (iNewSize <= m_cMax)
            {
                if (iNewSize < m_cElements)
                {
                    DestructElements(m_pData + iNewSize, m_cElements - iNewSize);
                }
                else
                {
                    ConstructElements(m_pData + m_cElements, iNewSize - m_cElements);
                }

                m_cElements = iNewSize;
            }
            else // we don't have enough space.
            {
                // we allocate double of the requested size.
                m_cMax = iNewSize * 2;
                TYPE* pNewData = (TYPE*) new BYTE [m_cMax * sizeof(TYPE)];
                memcpy(pNewData, m_pData, m_cElements * sizeof(TYPE));

                ConstructElements(pNewData + m_cElements, iNewSize - m_cElements);

                delete [] (BYTE*)m_pData;
                m_pData = pNewData;

                m_cElements = iNewSize;
            }
        }
        else // it's an empty array, we need to allocate spaces for iNewSize elements.
        {
            m_pData = (TYPE*) new BYTE [iNewSize * sizeof(TYPE)];
            ConstructElements(m_pData, iNewSize);
            m_cElements = m_cMax = iNewSize;
        }
    }
    else // if it's 0, we should destroy all the Elements in the array.
    {
        if (m_pData)
        {
            DestructElements(m_pData, m_cElements);
            delete [] (BYTE*)m_pData;
            m_pData = NULL;
        }

        m_cElements = 0;
    }
}

template <typename TYPE>
VOID CLUAArray<TYPE>::SetAtGrow(DWORD iIndex, TYPE newElement)
{
    ASSERT(iIndex >= 0, "Index cannot be negative");

    if (iIndex >= m_cElements)
    {
        SetSize(iIndex + 1);
    }

    m_pData[iIndex] = newElement;
}

template <typename TYPE>
DWORD CLUAArray<TYPE>::Add(TYPE newElement)
{
    SetAtGrow(m_cElements, newElement);

    return m_cElements;
}

template <typename TYPE>
DWORD CLUAArray<TYPE>::Append(const CLUAArray& src)
{
    ASSERT(this != &src, "Cannot append to itself");

    DWORD nOldSize = m_cElements;
    SetSize(m_cElements + src.m_cElements);
    CopyElements(m_pData + nOldSize, src.m_pData, src.m_cElements);
    return nOldSize;
}

template <typename TYPE>
VOID CLUAArray<TYPE>::Copy(const CLUAArray& src)
{
    ASSERT(this != &src, "Cannot copy to itself");

    SetSize(src.m_cElements);
    CopyElements(m_pData, src.m_pData, src.m_cElements);
}

template <typename TYPE>
VOID CLUAArray<TYPE>::RemoveAt(DWORD iIndex, DWORD nCount)
{
    ASSERT(iIndex >= 0, "Index cannot be negative");
    ASSERT(nCount >= 0, "Count cannot be negative");
    ASSERT(iIndex + nCount <= m_nSize, "Requested to remove too many items");

    // just remove a range
    int nMoveCount = m_nSize - (iIndex + nCount);

    if (nMoveCount)
    {
        memcpy(&m_pData[iIndex], &m_pData[iIndex + nCount],
            nMoveCount * sizeof(BYTE));
    }

    m_nSize -= nCount;
}

template <typename TYPE>
const TYPE& CLUAArray<TYPE>::operator[](DWORD iIndex) const
{
    ASSERT(iIndex >= 0 && iIndex < m_cElements, "Index out of bound");

    return m_pData[iIndex];
}

template <typename TYPE>
TYPE& CLUAArray<TYPE>::operator[](DWORD iIndex)
{
    ASSERT(iIndex >= 0 && iIndex < m_cElements, "Index out of bound");

    return m_pData[iIndex]; 
}

template <typename TYPE>
const TYPE& CLUAArray<TYPE>::GetAt(DWORD iIndex) const
{
    ASSERT(iIndex >= 0 && iIndex < m_cElements, "Index out of bound");

    return m_pData[iIndex];
}

template <typename TYPE>
TYPE& CLUAArray<TYPE>::GetAt(DWORD iIndex)
{
    ASSERT(iIndex >= 0 && iIndex < m_cElements, "Index out of bound");

    return m_pData[iIndex]; 
}

template <typename TYPE>
VOID CLUAArray<TYPE>::DestructElements(TYPE* pElements, DWORD nCount)
{
    for (; nCount--; pElements++)
    {
        pElements->~TYPE();
    }
}

//
// define placement new and delete.
//
inline void *__cdecl operator new(size_t, void *P)
{
    return (P);
}

inline void __cdecl operator delete(void *, void *)
{
    return; 
}

template <typename TYPE>
VOID CLUAArray<TYPE>::ConstructElements(TYPE* pElements, DWORD nCount)
{
    // we zero memory first here.
    memset(pElements, 0, nCount * sizeof(TYPE));

    for (; nCount--; pElements++)
    {
        new (pElements) TYPE;
    }
}

template <typename TYPE>
VOID CLUAArray<TYPE>::CopyElements(TYPE* pDest, const TYPE* pSrc, DWORD nCount)
{
    while (nCount--)
    {
        *pDest++ = *pSrc++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\acrobat5.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Acrobat5.cpp

 Abstract:

   Blow off calls to SetWindowPos() w/ bogus coordinates to 
   prevent the app from erronously turning its window into a
   small sasauge in the upper left-hand corner of the screen.

 Notes:

    This is an app specific shim.

 History:

    07/9/2001  reinerf    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Acrobat5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowPos) 
APIHOOK_ENUM_END


BOOL
APIHOOK(SetWindowPos)(
  HWND hWnd,             // handle to window
  HWND hWndInsertAfter,  // placement-order handle
  int X,                 // horizontal position
  int Y,                 // vertical position
  int cx,                // width
  int cy,                // height
  UINT uFlags            // window-positioning options
)
{
    if (!(uFlags & (SWP_NOSIZE | SWP_NOMOVE)))
    {
        HWND hWndParent = GetParent(hWnd);
        
        if ((hWndParent == NULL) ||
            (hWndParent == GetDesktopWindow()))
        {
            if ((X < -3200) || 
                (Y < -3200))
            {
                // a toplevel window is being poorly positioned, ignore the call.
                DPFN( eDbgLevelInfo, "SetWindowPos passed bogus coordinates (X = %d, Y = %d), failing the call\n", X, Y);
                return FALSE;
            }
        }
    }

    return ORIGINAL_API(SetWindowPos)(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetWindowPos)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\adobelivemotion.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    AdobeLiveMotion.cpp

 Abstract:

    This installation has a version problem that is corrected
    by the MSI transform but later has a problem with it's custom action
    DLL.It calls one of the MSI API's with invalid parameters.

 Notes:

    This is specific to this app.

 History:

    05/15/2001 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(AdobeLiveMotion)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MsiGetPropertyA)  
    APIHOOK_ENUM_ENTRY(MsiGetPropertyW)  
APIHOOK_ENUM_END

/*++

    Pass valid parameters to the API.

--*/

UINT
APIHOOK(MsiGetPropertyA)(
    MSIHANDLE hInstall,
    LPCSTR szName,
    LPSTR szValueBuf,
    DWORD *pchValueBuf)
{
    char szTempBuf[] = "";

    int len = (*pchValueBuf) ?(int)(*pchValueBuf) : MAX_PATH;
    if ((szValueBuf == NULL) || IsBadStringPtrA(szValueBuf,(UINT_PTR)len))
    {
        // If the string pointer is bad, send our empty string in
        szValueBuf = szTempBuf;
        *pchValueBuf = 0;
    }
    
    return ORIGINAL_API(MsiGetPropertyA)(hInstall,szName,szValueBuf,pchValueBuf);

}

/*++



--*/

UINT
APIHOOK(MsiGetPropertyW)(
    MSIHANDLE hInstall,
    LPCWSTR szName,
    LPWSTR szValueBuf,
    DWORD *pchValueBuf)
{
    WCHAR szTempBuf[] = L"";

    int len = (*pchValueBuf) ?(int)(*pchValueBuf) : MAX_PATH;
    if ((szValueBuf == NULL) || IsBadStringPtr(szValueBuf,(UINT_PTR)len))
    {
        // If the string pointer is bad, send our empty string in
        szValueBuf = szTempBuf;
        *pchValueBuf = 0;
    }
    
    return ORIGINAL_API(MsiGetPropertyW)(hInstall,szName,szValueBuf,pchValueBuf);

}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(MSI.DLL, MsiGetPropertyA)
    APIHOOK_ENTRY(MSI.DLL, MsiGetPropertyW)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\afterdark.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AfterDark.cpp

 Abstract:

    This shim hooks SystemParametersInfo and when SPI_SETSCREENSAVEACTIVE is
    passed in with FALSE as its argument, the shim only deletes the 
    SCRNSAVE.EXE value which sets the "None" screen saver option instead of 
    setting ScreenSaverActive to 0 as well, which completely disables 
    screen savers (with no recovery UI).

 History:

    08/07/2000 t-adams   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(AfterDark)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SystemParametersInfoA) 
APIHOOK_ENUM_END

/*++

  Abstract:

    This shim hooks SystemParametersInfoA and when SPI_SETSCREENSAVEACTIVE is
    passed in with FALSE as its argument, the shim only deletes the 
    SCRNSAVE.EXE value which sets the "None" screen saver option instead of 
    setting ScreenSaverActive to 0 as well, which completely disables 
    screen savers (with no recovery UI).

  History:

    08/07/2000    t-adams     Created

--*/

BOOL
APIHOOK(SystemParametersInfoA)(
    UINT uiAction,
    UINT uiParam, 
    PVOID pvParam,
    UINT fWinIni
    )  
{
    HKEY hKey = 0;
    BOOL bRet = FALSE;
    
    if (SPI_SETSCREENSAVEACTIVE == uiAction && FALSE == uiParam) 
    {
        LOGN( eDbgLevelError, "[APIHook_SystemParametersInfo] Attempt to disable screen savers - correcting");

        if (RegOpenKeyExW(HKEY_CURRENT_USER, L"Control Panel\\Desktop", 0, KEY_WRITE, &hKey)
                == ERROR_SUCCESS) 
        {
            RegDeleteValueW(hKey, L"SCRNSAVE.EXE");
            RegCloseKey(hKey);
            bRet = TRUE;
            goto exit;
        } 
        else 
        {
            goto exit;
        }
    } 
    else 
    {
        bRet = ORIGINAL_API(SystemParametersInfoA)(uiAction, uiParam, pvParam, fWinIni);
        goto exit;
    }

exit:
    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SystemParametersInfoA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\sample\sampleshim.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   SampleShim.cpp

 Abstract:

   This DLL serves as a template for the creation of shim DLLs. Follow
   the commenting/coding style of this source file wherever possible.
   Never use tabs, configure your editor to insert spaces instead of
   tab characters.
   
 Notes:

   Hooking COM functions is also possible but is not covered in this
   sample for simplicity sake. Contact markder or linstev for more
   information on COM hooking.

 History:

    02/02/2000  markder     Created
    11/14/2000  markder     Converted to framework version 2
    02/13/2001  mnikkel     Changed notify to handle new DLL_PROCESS
                            capabilities
    03/31/2001  robkenny    Changed to use CString

--*/

#include "ShimHook.h"

//
// You must declare the type of shim this is at the top. If your shim 
// coexists with other shims in the same DLL,
// use IMPLEMENT_SHIM_BEGIN(SampleShim)
// otherwise use IMPLEMENT_SHIM_STANDALONE(SampleShim)
//
IMPLEMENT_SHIM_STANDALONE(SampleShim)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MessageBoxA) 
    APIHOOK_ENUM_ENTRY(MessageBoxW) 
APIHOOK_ENUM_END

/*++

 This stub function intercepts all calls to MessageBoxA
 and prefixes the output string with "SampleShim says:".
 
--*/

int
APIHOOK(MessageBoxA)(
    HWND hWnd,          // handle to owner window
    LPCSTR lpText,      // text in message box
    LPCSTR lpCaption,   // message box title
    UINT uType          // message box style
    )
{
    //
    // Use Hungarian notation for local variables:
    //
    //      Type                        Scope
    //      -----------------------     ------------------
    //      Pointers            p       Global          g_
    //      DWORD               dw      Class member    m_
    //      LONG                l       Static          s_
    //      ANSI strings        sz
    //      Wide-char strings   wsz
    //      Arrays              rg
    //      CString             cs
    //

    int iReturnValue;
    
    //
    // We use the CString class to perform all string operations in UNICODE
    // to prevent any problems with DBCS characters.
    //
    // Place all CString operations inside a CSTRING_TRY/CSTRING_CATCH
    // exception handler.  CString will throw an exception if it encounters
    // any memory allocation failures.
    //
    // Performing all string operations by using the CString class also prevents
    // us from accidentally modifying the original string.
    //
    
    CSTRING_TRY
    {
        CString csNewOutputString(lpText);
        csNewOutputString.Insert(0, L"SampleShim says: ");

        //
        // Use the DPF macro to print debug strings. See Hooks\inc\ShimDebug.h
        // for debug level values. Use eDbgLevelError if an unexpected error
        // occurs in your shim code. For informational output, use eDbgLevelInfo.
        //
        // Make sure you don't end the message with '\n' in this case because
        // the macro will do it by default.
        //
        // Note that when printing CString, use %S and you must call the Get() method,
        // to explicitly return a WCHAR *.
        //
        DPFN( eDbgLevelInfo,
            "MessageBoxA called with lpText = \"%s\".", lpText);
    
        //
        // Use the ORIGINAL_API macro to call the original API. You must use
        // this so that API chaining and inclusion/exclusion information is
        // preserved.
        //
        // CString will perform automatic type conversion to const WCHAR * (LPCWSTR)
        // It will not, however, automatically convert to char *, you must call GetAnsi()
        // (or GetAnsiNIE() if you wish a NULL pointer be returned when the string is empty)
        //
        iReturnValue = ORIGINAL_API(MessageBoxA)(hWnd, csNewOutputString.GetAnsi(), lpCaption, uType);
    
        //
        // Use the LOG macro to print messages to the log file. This macro should
        // be used to indicate that the shim had affected execution of the program
        // in some way. Use eDbgLevelError to indicate that the shim has
        // consciously fixed something that would have caused problems. Use
        // eDbgLevelWarning if the shim has affected execution, but it is unclear
        // whether it actually helped the program.
        //
        LOGN( eDbgLevelWarning,
            "MessageBoxA converted lpText from \"%s\" to \"%S\".", lpText, csNewOutputString.Get());
    }
    CSTRING_CATCH
    {
        //
        // We had a CString failure, call the original API with the original args
        //
        iReturnValue = ORIGINAL_API(MessageBoxA)(hWnd, lpText, lpCaption, uType);
    }
    
    return iReturnValue;
}

/*++

 This stub function intercepts all calls to MessageBoxW and prefixes the
 output string with "SampleShim says:".

 Note that to make your shim generally applicable in an NT environment,
 you should include both ANSI and wide-character versions of your stub
 function. However, if your shim emulates Win9x behaviour, it is
 redundant to include wide-character versions because Win9x did not
 support them.

--*/

int
APIHOOK(MessageBoxW)(
    HWND hWnd,          // handle to owner window
    LPCWSTR lpText,     // text in message box
    LPCWSTR lpCaption,  // message box title
    UINT uType          // message box style
    )
{
    int iReturnValue;
    
    CSTRING_TRY
    {
        CString csNewOutputString(lpText);
        csNewOutputString.Insert(0, L"SampleShim says: ");

        DPFN( eDbgLevelInfo,
            "MessageBoxW called with lpText = \"%S\".", lpText);
    
        iReturnValue = ORIGINAL_API(MessageBoxW)(
                                hWnd,
                                csNewOutputString,
                                lpCaption,
                                uType);
    
        LOGN( eDbgLevelWarning,
            "MessageBoxW converted lpText from \"%S\" to \"%S\".",
            lpText, csNewOutputString.Get());
    }
    CSTRING_CATCH
    {
        iReturnValue = ORIGINAL_API(MessageBoxW)(
                                hWnd,
                                lpText,
                                lpCaption,
                                uType);
    }
    
    return iReturnValue;

}

/*++

 Handle DLL_PROCESS_ATTACH, SHIM_STATIC_DLLS_INITIALIZED
 and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.

 IMPORTANT: Make sure you ONLY call NTDLL and KERNEL32 APIs during
 DLL_PROCESS_ATTACH notification. No other DLLs are initialized at that
 point.
 
 SHIM_STATIC_DLLS_INITIALIZED is called after all of the application's
 DLLs have been initialized.
 
 If your shim cannot initialize properly (during DLL_PROCESS_ATTACH),
 return FALSE and none of the APIs specified will be hooked.

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    //
    // Note that there are further cases besides attach and detach.
    //
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPFN( eDbgLevelSpew, "Sample Shim initialized.");
            break;
    
        case SHIM_STATIC_DLLS_INITIALIZED:
            DPFN( eDbgLevelSpew,
                "Sample Shim notification: All DLLs have been loaded.");
            break;
    
        case DLL_PROCESS_DETACH:
            DPFN( eDbgLevelSpew, "Sample Shim uninitialized.");
            break;

        default:
            break;
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    //
    // If you have any initialization to do, you must include this line.
    // Then you must implement the NOTIFY_FUNCTION as above.
    //
    CALL_NOTIFY_FUNCTION

    //
    // Add APIs that you wish to hook here. All API prototypes
    // must be declared in Hooks\inc\ShimProto.h. Compiler errors
    // will result if you forget to add them.
    //
    APIHOOK_ENTRY(USER32.DLL, MessageBoxA)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\aliensvspredator.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AliensVsPredator.cpp

 Abstract:

    The app calls a Bink API to outside of a BinkOpen/BinkClose call. This is 
    a synchronization issue fixed by delaying the BinkClose call.

 Notes:

    This is an app specific shim.


 History:
        
    01/12/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(AliensVsPredator)
#include "ShimHookMacro.h"

typedef DWORD (WINAPI *_pfn_BinkOpen)(DWORD dw1, DWORD dw2);
typedef BOOL  (WINAPI *_pfn_BinkClose)(DWORD dw1);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(BinkOpen) 
    APIHOOK_ENUM_ENTRY(BinkClose) 
APIHOOK_ENUM_END

DWORD g_dwLast = 0;
BOOL g_bReal = FALSE;

/*++

 Close the last handle.

--*/

DWORD
APIHOOK(BinkOpen)(
    DWORD dw1,              
    DWORD dw2
    )
{
    if (g_dwLast)
    {
        DPFN( eDbgLevelInfo, "Closing most recent Bink handle");
        g_bReal = TRUE;
        ORIGINAL_API(BinkClose)(g_dwLast);
        g_bReal = FALSE;
        g_dwLast = 0;
    }

    return ORIGINAL_API(BinkOpen)(dw1, dw2);
}

/*++

 Cache the handle

--*/

BOOL
APIHOOK(BinkClose)(
    DWORD dw1
    )
{
    if (g_bReal)
    {
        return ORIGINAL_API(BinkClose)(dw1);
    }
    else
    {
        DPFN( eDbgLevelInfo, "Delaying BinkClose");
        g_dwLast = dw1;
        return 1;
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_NAME(BINKW32.DLL, BinkOpen, _BinkOpen@8)
    APIHOOK_ENTRY_NAME(BINKW32.DLL, BinkClose, _BinkClose@4)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\sample\sampleshim_old.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   SampleShim_Old.cpp

 Abstract:

   This DLL serves as a template for the creation of shim DLLs. Follow
   the commenting/coding style of this source file wherever possible.
   Never use tabs, configure your editor to insert spaces instead of
   tab characters.

 Notes:

   This is a sample DLL.

   This shim is a museum piece, it nolonger compiles.

 History:

   02/02/2000 markder  Created

--*/

#include "ShimHook.h"

// Add APIs that you wish to hook to this enumeration. The first one
// must have "= USERAPIHOOKSTART", and the last one must be
// APIHOOK_Count.
enum
{
   APIHOOK_MessageBoxA = USERAPIHOOKSTART,
   APIHOOK_MessageBoxW,
   APIHOOK_Count
};

/*++

 This stub function intercepts all calls to MessageBoxA
 and prefixes the output string with "SampleShim says:".

 Note that all Win32 APIs use __stdcall calling conventions, so
 you must be sure to have this set in MSVC++. Go to Projects|Settings,
 C/C++ tab, select Category: "Code Generation" from dropdown, make
 sure "Calling convention" is set to __stdcall.

--*/

int
APIHook_MessageBoxA(
    HWND hWnd,          // handle to owner window
    LPCSTR lpText,      // text in message box
    LPCSTR lpCaption,   // message box title
    UINT uType          // message box style
    )
{
    // Declare all local variables at top of function. Always use
    // Hungarian notation as follows:
    //
    //      Type                        Scope
    //      -----------------------     ------------------
    //      Pointers            p       Global          g_
    //      DWORD               dw      Class member    m_
    //      LONG                l       Static          s_
    //      ANSI strings        sz
    //      Wide-char strings   wsz
    //      Arrays              rg
    //
    int     iReturnValue;
    LPSTR   szNewOutputString;
    CHAR    szPrefix[] = "SampleShim says: ";

    // All string alterations must be done in new memory. Never
    // alter a passed-in string in-place.
    szNewOutputString = (LPSTR) malloc( strlen( lpText ) +
                                        strlen( szPrefix ) + 1 );

    // Use the DPF macro to print debug strings. See Hooks\inc\ShimDebug.h
    // for debug level values. Use eDbgLevelError if an unexpected error occurs
    // in your shim code. For informational output, use eDbgLevelUser.
    DPF(eDbgLevelUser, "APIHook_MessageBoxA called.\n");
    
    strcpy( szNewOutputString, szPrefix );
    strcat( szNewOutputString, lpText );

    // Use the LOOKUP_APIHOOK macro to call the original API. You must use
    // this so that API chaining and inclusion/exclusion information is
    // preserved.
    iReturnValue = LOOKUP_APIHOOK(MessageBoxA)( hWnd,
                                                szNewOutputString,
                                                lpCaption,
                                                uType );


    free( szNewOutputString );

    return iReturnValue;
}

/*++

 This stub function intercepts all calls to MessageBoxW
 and prefixes the output string with "SampleShim says:".

 Note that to make your shim generally applicable, you should include
 both ANSI and wide-character versions of your stub function.

--*/

int
APIHook_MessageBoxW(
    HWND hWnd,          // handle to owner window
    LPCWSTR lpText,     // text in message box
    LPCWSTR lpCaption,  // message box title
    UINT uType          // message box style
    )
{
    // NEVER use TCHAR variables or tcs-prefixed string manipulation routines.
    // Prefix all wide-character string constants with L. Never use _T() or
    // TEXT() macros.
    int      iReturnValue;
    LPWSTR   wszNewOutputString;
    WCHAR    wszPrefix[] = L"SampleShim says: ";

    // A single line of code should never be more than 80 characters long.
    wszNewOutputString = (LPWSTR) malloc( sizeof(WCHAR) *
                                          ( wcslen( lpText ) +
                                            wcslen( wszPrefix ) + 1 ) );

    DPF(eDbgLevelUser, "APIHook_MessageBoxW called.\n");
    
    // Make sure to use wide-character versions of all string manipulation
    // routines where appropriate.
    wcscpy( wszNewOutputString, wszPrefix );
    wcscat( wszNewOutputString, lpText );

    iReturnValue = LOOKUP_APIHOOK(MessageBoxW)( hWnd,
                                                wszNewOutputString,
                                                lpCaption,
                                                uType );

    free( wszNewOutputString );

    return iReturnValue;
}

/*++

 Register hooked functions

--*/

VOID
InitializeHooks(DWORD fdwReason)
{
    if (fdwReason != DLL_PROCESS_ATTACH) return;

    // Don't touch this line.
    INIT_HOOKS(APIHOOK_Count);

    // Add APIs that you wish to hook here. All API prototypes
    // must be declared in Hooks\inc\ShimProto.h. Compiler errors
    // will result if you forget to add them.
    DECLARE_APIHOOK(USER32.DLL, MessageBoxA);
    DECLARE_APIHOOK(USER32.DLL, MessageBoxW);

    // If you have any more initialization to do, do it here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\aolfindbundledinstaller_aolcode.h ===
//-----------------------------------------------------------------------------
//                         America Online for Windows
//-----------------------------------------------------------------------------
// Copyright (c) 1987-2001 America Online, Inc.  All rights reserved.  This
// software contains valuable confidential and proprietary information of
// America Online and is subject to applicable licensing agreements.
// Unauthorized reproduction, transmission, or distribution of this file and
// its contents is a violation of applicable laws.
//-----------------------------------------------------------------------------
// $Workfile: AOLInstall.h $ $Author: RobrtLarson $
// $Date: 05/02/01 $
//-----------------------------------------------------------------------------

#if !defined(_AOLINSTALL_H__INCLUDED_)
#define _AOLINSTALL_H__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

BOOL LocateInstaller(PCHAR lpszAOLInstaller, UINT uiPathSize, BOOL *pbMessage);

#endif // !defined(_AOLINSTALL_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\aolfindbundledinstaller_aolcode.cpp ===
//-----------------------------------------------------------------------------
//                         America Online for Windows
//-----------------------------------------------------------------------------
// Copyright (c) 1987-2001 America Online, Inc.  All rights reserved.  This
// software contains valuable confidential and proprietary information of
// America Online and is subject to applicable licensing agreements.
// Unauthorized reproduction, transmission, or distribution of this file and
// its contents is a violation of applicable laws.
//-----------------------------------------------------------------------------
// $Workfile: AOLInstall.cpp $ $Author: RobrtLarson $
// $Date: 05/02/01 $
//-----------------------------------------------------------------------------

#include "precomp.h"

#include <Softpub.h>
#include <WinCrypt.h>
#include <WinTrust.h>
#include <ImageHlp.h>

#include "LegalStr.h"
#include "AOLFindBundledInstaller_AOLCode.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define  SWAPWORDS(x)   (((x) << 16) | ((x) >> 16))

// define encoding method
#define ENCODING (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING)

#define INSTALLER      0x0001
#define CLIENT         0x0002
#define COUNTRY_PICKER 0x0004
#define SERVICE_AOL    0x0010
#define SERVICE_CS     0x0020

// Local function prototypes
BOOL GetExeType(LPSTR lpszExePath, WORD &wExeType);
BOOL ExtractCertificateInfo(LPSTR lpszFileName, HCERTSTORE *hCertStore);
PCCERT_CONTEXT WINAPI CryptGetSignerCertificateCallback(void *pvGetArg,
        DWORD dwCertEncodingType, PCERT_INFO pSignerId, HCERTSTORE hCertStore);
BOOL CheckCertificateName(HCERTSTORE hCertStore);
LPSTR GetCommonName(CERT_NAME_BLOB pCertNameBlob);
BOOL VerifyFileInfo(WORD &ExeType, LPSTR lpszInstaller, PBOOL pbOldClient);
BOOL VerifyCertificate(LPSTR lpszInstaller);

_pfn_CertCloseStore g_pfn_CertCloseStore = NULL;
_pfn_CryptVerifyMessageSignature g_pfn_CryptVerifyMessageSignature = NULL;
_pfn_ImageGetCertificateData g_pfn_ImageGetCertificateData = NULL;
_pfn_ImageGetCertificateHeader g_pfn_ImageGetCertificateHeader = NULL;
_pfn_CertGetSubjectCertificateFromStore g_pfn_CertGetSubjectCertificateFromStore = NULL;
_pfn_CertDuplicateStore g_pfn_CertDuplicateStore = NULL;
_pfn_CertEnumCertificatesInStore g_pfn_CertEnumCertificatesInStore = NULL;
_pfn_CertRDNValueToStrA g_pfn_CertRDNValueToStrA = NULL;
_pfn_CertFindRDNAttr g_pfn_CertFindRDNAttr = NULL;
_pfn_CryptDecodeObject g_pfn_CryptDecodeObject = NULL;
_pfn_VerQueryValueA g_pfn_VerQueryValueA = NULL;
_pfn_GetFileVersionInfoA g_pfn_GetFileVersionInfoA = NULL;
_pfn_GetFileVersionInfoSizeA g_pfn_GetFileVersionInfoSizeA = NULL;
_pfn_WinVerifyTrust g_pfn_WinVerifyTrust = NULL;

HMODULE g_hCRYPT32    = NULL;
HMODULE g_hWINTRUST   = NULL;
HMODULE g_hVERSION    = NULL;
HMODULE g_hIMAGEHLP   = NULL;

void UnloadDependencies()
{
    g_pfn_CertCloseStore = NULL;
    g_pfn_CryptVerifyMessageSignature = NULL;
    g_pfn_ImageGetCertificateData = NULL;
    g_pfn_ImageGetCertificateHeader = NULL;
    g_pfn_CertGetSubjectCertificateFromStore = NULL;
    g_pfn_CertDuplicateStore = NULL;
    g_pfn_CertEnumCertificatesInStore = NULL;
    g_pfn_CertRDNValueToStrA = NULL;
    g_pfn_CertFindRDNAttr = NULL;
    g_pfn_CryptDecodeObject = NULL;
    g_pfn_VerQueryValueA = NULL;
    g_pfn_GetFileVersionInfoA = NULL;
    g_pfn_GetFileVersionInfoSizeA = NULL;
    g_pfn_WinVerifyTrust = NULL;

    if (g_hCRYPT32) {
        FreeLibrary(g_hCRYPT32);
        g_hCRYPT32 = NULL;
    }

    if (g_hWINTRUST) {
        FreeLibrary(g_hWINTRUST);
        g_hWINTRUST = NULL;
    }

    if (g_hVERSION) {
        FreeLibrary(g_hVERSION);
        g_hVERSION = NULL;
    }

    if (g_hIMAGEHLP) {
        FreeLibrary(g_hIMAGEHLP);
        g_hIMAGEHLP = NULL;
    }
}

BOOL LoadDependencies()
{
    BOOL bSuccess = FALSE;

    if (!(g_hCRYPT32 = LoadLibraryA("CRYPT32.DLL"))) {
        goto eh;
    }

    if (!(g_hWINTRUST = LoadLibraryA("WINTRUST.DLL"))) {
        goto eh;
    }

    if (!(g_hVERSION = LoadLibraryA("VERSION.DLL"))) {
        goto eh;
    }

    if (!(g_hIMAGEHLP = LoadLibraryA("IMAGEHLP.DLL"))) {
        goto eh;
    }

    if (!(g_pfn_CertCloseStore = (_pfn_CertCloseStore) GetProcAddress(g_hCRYPT32, "CertCloseStore"))) { goto eh; }
    if (!(g_pfn_CryptVerifyMessageSignature = (_pfn_CryptVerifyMessageSignature) GetProcAddress(g_hCRYPT32, "CryptVerifyMessageSignature"))) { goto eh; }
    if (!(g_pfn_ImageGetCertificateData = (_pfn_ImageGetCertificateData) GetProcAddress(g_hIMAGEHLP, "ImageGetCertificateData"))) { goto eh; }
    if (!(g_pfn_ImageGetCertificateHeader = (_pfn_ImageGetCertificateHeader) GetProcAddress(g_hIMAGEHLP, "ImageGetCertificateHeader"))) { goto eh; }
    if (!(g_pfn_CertGetSubjectCertificateFromStore = (_pfn_CertGetSubjectCertificateFromStore) GetProcAddress(g_hCRYPT32, "CertGetSubjectCertificateFromStore"))) { goto eh; }
    if (!(g_pfn_CertDuplicateStore = (_pfn_CertDuplicateStore) GetProcAddress(g_hCRYPT32, "CertDuplicateStore"))) { goto eh; }
    if (!(g_pfn_CertEnumCertificatesInStore = (_pfn_CertEnumCertificatesInStore) GetProcAddress(g_hCRYPT32, "CertEnumCertificatesInStore"))) { goto eh; }
    if (!(g_pfn_CertRDNValueToStrA = (_pfn_CertRDNValueToStrA) GetProcAddress(g_hCRYPT32, "CertRDNValueToStrA"))) { goto eh; }
    if (!(g_pfn_CertFindRDNAttr = (_pfn_CertFindRDNAttr) GetProcAddress(g_hCRYPT32, "CertFindRDNAttr"))) { goto eh; }
    if (!(g_pfn_CryptDecodeObject = (_pfn_CryptDecodeObject) GetProcAddress(g_hCRYPT32, "CryptDecodeObject"))) { goto eh; }
    if (!(g_pfn_VerQueryValueA = (_pfn_VerQueryValueA) GetProcAddress(g_hVERSION, "VerQueryValueA"))) { goto eh; }
    if (!(g_pfn_GetFileVersionInfoA = (_pfn_GetFileVersionInfoA) GetProcAddress(g_hVERSION, "GetFileVersionInfoA"))) { goto eh; }
    if (!(g_pfn_GetFileVersionInfoSizeA = (_pfn_GetFileVersionInfoSizeA) GetProcAddress(g_hVERSION, "GetFileVersionInfoSizeA"))) { goto eh; }
    if (!(g_pfn_WinVerifyTrust = (_pfn_WinVerifyTrust) GetProcAddress(g_hWINTRUST, "WinVerifyTrust"))) { goto eh; }

    bSuccess = TRUE;

eh:
    if (!bSuccess) {
        UnloadDependencies();
    }

    return bSuccess;
}   

//-----------------------------------------------------------------------------
// LocateInstaller
//    This functions searches for a valid AOL or CompuServe install program
//    based on the default value found in a registry key. This install program
//    is then validated by checking the Certificates and verifying that the
//    program file has not been modified since being signed by America Online.
//
//    AOL Registry Key:
//       HKLM\Software\America Online\Installers
//
//    CompuServe Registry Key:
//       HKLM\Software\CompuServe\Installers
//-----------------------------------------------------------------------------
// Function parameters:
//    LPSTR lpszInstaller            Returned installer command line,
//                                   NULL if no valid installer located
//                                   Note: allowance should be made in the
//                                   length of this string for an optional
//                                   parameter on the command line of MAX_PATH
//                                   length.
//    UINT uiPathSize                Length of lpszInstaller parameter
//    BOOL *pbMessage                TRUE - display App Compat message
//                                   FALSE - do not display App Compat message
//-----------------------------------------------------------------------------
BOOL LocateInstaller_Internal(LPSTR lpszInstaller, UINT uiPathSize, BOOL *pbMessage)
{
    BOOL  bResult = FALSE,
          bCheckCert = TRUE,
          bOldClient = FALSE;
    HKEY  hKey;
    LONG  lRet;
    CHAR  szModuleName[MAX_PATH];
    WORD  wExeType = 0;

    // Default to no App Compat message
    *pbMessage = FALSE;

    // Get the name of the file that is executing
    DWORD dwLen = GetModuleFileNameA(NULL, szModuleName, sizeof(szModuleName));
    if (0 == dwLen)
    { return FALSE; }

    // Determine the type of exe this is
    bResult = GetExeType(szModuleName, wExeType);
    if (bResult)
    {
        // Check if this is the uninstaller calling the client
        if ((CLIENT & wExeType) && (NULL != strstr(_strlwr(GetCommandLineA()), "regall")))
        { return FALSE; }

        // If the program we are running is valid, then let it run
        if (VerifyFileInfo(wExeType, szModuleName, &bOldClient))
        { return FALSE; }

        // If this is an client <= 4.0 then display message if not bundled installer found
        if (bOldClient)
        { *pbMessage = TRUE; }

        // Open registry key
        if (SERVICE_AOL & wExeType)
        {
            lRet = RegOpenKeyA(HKEY_LOCAL_MACHINE,
                    "Software\\America Online\\Installers", &hKey);
        }
        else if (SERVICE_CS & wExeType)
        {
            lRet = RegOpenKeyA(HKEY_LOCAL_MACHINE,
                    "Software\\CompuServe\\Installers", &hKey);
        }
        else
        { return FALSE; }    // Don't know what this is

        if (ERROR_SUCCESS != lRet)
        { return FALSE; }        // No bundled version of AOL/CS located in registry

        // Get size of registry key data
        ULONG  cbSize;
        DWORD  dwType;
        lRet = RegQueryValueExA(hKey, NULL, NULL, &dwType, NULL, &cbSize);
        if ((ERROR_SUCCESS != lRet) ||
             (cbSize > uiPathSize)  ||
             (REG_SZ != dwType))
        { return FALSE; }

        // See if we need to check the certificate for the installer
        lRet = RegQueryValueExA(hKey, "CC", NULL, &dwType, NULL, &cbSize);
        if ((ERROR_SUCCESS == lRet) && (cbSize > 0))
        { bCheckCert = FALSE; }

        lpszInstaller[0] = '\"';
        // Get registry key data
        cbSize = uiPathSize - 1;
        lRet = RegQueryValueExA(hKey, NULL, NULL, NULL, (UCHAR *)&lpszInstaller[1], &cbSize);

        RegCloseKey(hKey);
        if (ERROR_SUCCESS == lRet)
        {
            // Check for correct installer version
            bResult = VerifyFileInfo(wExeType, &lpszInstaller[1], NULL);
            if (bResult && bCheckCert)
            {
                // Get certificate store
                HCERTSTORE  hCertStore = NULL;
                bResult = ExtractCertificateInfo(&lpszInstaller[1], &hCertStore);
                if (bResult)
                {
                    // Check certificates for AOL/CS signature
                    bResult = CheckCertificateName(hCertStore);
                    if (bResult)
                    {
                        // Check that file has not been modified
                        bResult = VerifyCertificate(&lpszInstaller[1]);
                    }
                }

                // Close the certificate store
                if (NULL != hCertStore)
                { (*g_pfn_CertCloseStore)(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG); }
            }
        }
    }

    if (bResult)
    {
        strcat(lpszInstaller, "\"") ;
        // Check if Message should be displayed to user
        if (CLIENT & wExeType)
        { *pbMessage = TRUE; }
        else
        {
            // Add command line parameter
            if (COUNTRY_PICKER & wExeType)
            {
                if ((strlen(lpszInstaller) + strlen(szModuleName) + 6) <= uiPathSize)
                { sprintf(lpszInstaller, "%s -p \"%s\"", lpszInstaller, szModuleName); }
            }
        }
    }
    else
    { lpszInstaller[0] = '\0'; }

    return bResult;
}

BOOL LocateInstaller(LPSTR lpszInstaller, UINT uiPathSize, BOOL *pbMessage)
{
    BOOL bSuccess = FALSE;
    if (!LoadDependencies()) {
        goto eh;
    }

    if (!LocateInstaller_Internal(lpszInstaller, uiPathSize, pbMessage)) {
        goto eh;
    }

    bSuccess = TRUE;
eh:
    UnloadDependencies();    

    return bSuccess;
}

//-----------------------------------------------------------------------------
// GetExeType
//    This functions determines whether the executible is an AOL/CS client or
//    and AOL/CS installer.
//-----------------------------------------------------------------------------
// Function parameters:
//    LPSTR lpszExePath         Fully qualified path to executible
//    WORD &wExeType            Returned executible type
//                                  AOL or CS
//                                  Client or Installer
//-----------------------------------------------------------------------------
BOOL GetExeType(LPSTR lpszExePath, WORD &wExeType)
{
    // Set string to lower case for comparisons
    _strlwr(lpszExePath);

    LPSTR pszTemp = strrchr(lpszExePath, '\\');
    if (NULL == pszTemp)
    { return FALSE; }

    pszTemp++;        // Get to beginning of exe name

    // Determine if this is an AOL/CS client
    if (0 == _stricmp(pszTemp, "waol.exe"))
    {
        wExeType = SERVICE_AOL | CLIENT;
        return TRUE;
    }
    else if ((0 == _stricmp(pszTemp, "wcs2000.exe")) || 
            (0 == _stricmp(pszTemp, "cs3.exe"))) 
    {
        wExeType = SERVICE_CS | CLIENT;
        return TRUE;
    }
    else if ((NULL != strstr(pszTemp, "cs2000"))      ||
             (NULL != strstr(pszTemp, "setupcs2k"))   ||
             (NULL != strstr(pszTemp, "setupcs2000")) ||
             (0 == _stricmp(pszTemp, "d41000b.exe"))  ||
             (0 == _stricmp(pszTemp, "d41510b.exe"))  ||
             (0 == _stricmp(pszTemp, "d41540b.exe")))
    {
        // These are CS installers w/ "America Online, Inc." in version info.
        wExeType = SERVICE_CS | INSTALLER;
        return TRUE; 
    } 
    else if (0 == _stricmp(pszTemp, "wgw.exe"))
    { return FALSE; }       // There is no bundled installer for Gateway
    else if (0 == _stricmp(pszTemp, "wwm.exe"))
    { return FALSE; }       // There is no bundled installer for Wal-Mart

    // Determine AOL/CS installer

    // Get size of version info in file
    DWORD  dwHandle = 0;
    DWORD  dwVerInfoSize = (*g_pfn_GetFileVersionInfoSizeA)(lpszExePath, &dwHandle);

    // Allocate memory for version info
    BYTE *lpVerInfo = NULL;
    __try
    {
        lpVerInfo = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwVerInfoSize);
        if (NULL == lpVerInfo)
        { __leave; }

        // Get version info from file
        BOOL bResult = (*g_pfn_GetFileVersionInfoA)(lpszExePath, NULL, dwVerInfoSize, lpVerInfo);
        if (!bResult)
        { __leave; }

        // Get Language code page
        DWORD  *pdwTrans;
        UINT    uiBytes;
        DWORD dwLangCodepage = 0;

        bResult = (*g_pfn_VerQueryValueA)(lpVerInfo, "\\VarFileInfo\\Translation", (VOID **)&pdwTrans, &uiBytes);
        if (bResult)
        { dwLangCodepage = SWAPWORDS(*pdwTrans); }  // Translate language code page to something we can use
        else
        { dwLangCodepage = 0x040904e4; }     // Try English multilanguage code page

        // Obtain the "CompanyName" from the version info
        CHAR   szQuery[MAX_PATH];
        PCHAR  pszVerInfo;
        sprintf(szQuery, "\\StringFileInfo\\%08X\\CompanyName", dwLangCodepage);
        bResult = (*g_pfn_VerQueryValueA)(lpVerInfo, szQuery, (VOID **)&pszVerInfo, &uiBytes);
        if (!bResult)
        { __leave; }

        // Check "CompanyName"
        if ((NULL != strstr(pszVerInfo, "America Online")) ||
             (NULL != strstr(pszVerInfo, "AOL")))
        {
            wExeType = SERVICE_AOL | INSTALLER;
            return TRUE;
        }
        if (0 == strcmp("CompuServe Interactive Services, Inc.", pszVerInfo))
        {
            wExeType = SERVICE_CS | INSTALLER;
            return TRUE;
        }
    }
    __finally
    {
        if (NULL != lpVerInfo)
        { HeapFree(GetProcessHeap(), 0, lpVerInfo); }
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
// ExtractCertificateInfo
//    This functions obtains and verifies the certificate store for the
//    installer.
//-----------------------------------------------------------------------------
// Function parameters:
//    LPSTR  lpszFileName       Fully qualified path to installer
//    HCERTSTORE  *hCertStore   Handle to the certificate store
//-----------------------------------------------------------------------------
BOOL ExtractCertificateInfo(LPSTR lpszFileName, HCERTSTORE *hCertStore)
{
    WIN_CERTIFICATE CertificateHeader;
    LPWIN_CERTIFICATE pbCertificate = NULL;
    BOOL bResult = FALSE;
    HANDLE hFile = NULL;
    DWORD dwSize;
    CRYPT_VERIFY_MESSAGE_PARA CryptVerifyMessagePara;

    __try
    {
        // Open file
        hFile = CreateFileA(lpszFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        { return FALSE; }

        // Get Certificate Header
        bResult = (*g_pfn_ImageGetCertificateHeader)(hFile, 0, &CertificateHeader);
        if (!bResult)
        { __leave; }

        // Allocate Memory for Certificate Blob
        pbCertificate = (LPWIN_CERTIFICATE)HeapAlloc(GetProcessHeap(), 0,
                CertificateHeader.dwLength);
        if (NULL == pbCertificate)
        {
            bResult = FALSE;
            __leave;
        }

        // Get Certificate Blob
        dwSize = CertificateHeader.dwLength;
        bResult = (*g_pfn_ImageGetCertificateData)(hFile, 0, pbCertificate, &dwSize);
        if (!bResult)
        { __leave; }

        // Zero out CRYPT_VERIFY_MESSAGE_PARA structure
        ZeroMemory(&CryptVerifyMessagePara, sizeof(CryptVerifyMessagePara));

        CryptVerifyMessagePara.cbSize = sizeof(CryptVerifyMessagePara);
        CryptVerifyMessagePara.dwMsgAndCertEncodingType = ENCODING;
        CryptVerifyMessagePara.pfnGetSignerCertificate = CryptGetSignerCertificateCallback;

        // Pass Address of certificate store to callback
        CryptVerifyMessagePara.pvGetArg = (LPVOID)hCertStore;

        // Verify the message and call callback
        bResult = (*g_pfn_CryptVerifyMessageSignature)(&CryptVerifyMessagePara, 0,
                pbCertificate->bCertificate, dwSize, NULL, NULL, NULL);
    }
    __finally
    {
        if (NULL != pbCertificate)
        { HeapFree(GetProcessHeap(), 0, pbCertificate); }

        if (NULL != hFile)
        { CloseHandle(hFile); }
    }

    return bResult;
}

//-----------------------------------------------------------------------------
// CryptGetSignerCertificateCallback
//    This functions is the callback function for CryptVerifyMessageSignature.
//-----------------------------------------------------------------------------
// Function parameters:
//    See MicroSoft documentation for details.
//-----------------------------------------------------------------------------
PCCERT_CONTEXT WINAPI CryptGetSignerCertificateCallback(void *pvGetArg,
        DWORD dwCertEncodingType, PCERT_INFO pSignerId, HCERTSTORE hCertStore)
{
    if (NULL == hCertStore)
    { return FALSE; }

    *((HCERTSTORE *)pvGetArg) = (*g_pfn_CertDuplicateStore)(hCertStore);

    return (*g_pfn_CertGetSubjectCertificateFromStore)(hCertStore, dwCertEncodingType,
            pSignerId);
}

//-----------------------------------------------------------------------------
// CheckCertificateName
//    This functions checks the certificate name to verify that it is signed by
//    America Online.
//-----------------------------------------------------------------------------
// Function parameters:
//    HCERTSTORE hCertStore   Handle to the certificate store
//-----------------------------------------------------------------------------
BOOL CheckCertificateName(HCERTSTORE hCertStore)
{
    BOOL bReturn = FALSE;
    PCCERT_CONTEXT pCertContext = NULL;
    PCCERT_CONTEXT pPrevContext = NULL;
    LPSTR szSubject = NULL;

    if (NULL != hCertStore)
    {
        do
        {
            pCertContext = (*g_pfn_CertEnumCertificatesInStore)(hCertStore, pPrevContext);

            if (NULL != pCertContext)
            {
                // Get Subject common name, if not then get organization name
                szSubject = GetCommonName(pCertContext->pCertInfo->Subject);
                if (NULL != szSubject)
                {
                    // Check name of certificate signer
                    if (0 == strcmp(szSubject, "America Online, Inc."))
                    { bReturn = TRUE; }

                    HeapFree(GetProcessHeap(), 0, szSubject);
                }

                pPrevContext = pCertContext;
            }
        } while (pCertContext);
    }

    return bReturn;
}

//-----------------------------------------------------------------------------
// GetCommonName
//    This functions obtains the common name from the certificate store
//-----------------------------------------------------------------------------
// Function parameters:
//    CERT_NAME_BLOB pCertNameBlob   Pointer to the blob that contains the name
//-----------------------------------------------------------------------------
LPSTR GetCommonName(CERT_NAME_BLOB pCertNameBlob)
{
    BOOL bReturn = FALSE;
    BOOL bResult;
    PCERT_NAME_INFO pCertName = NULL;
    PCERT_RDN_ATTR pCertAttr;
    LPSTR szName = NULL;
    DWORD dwSize;

    __try
    {
        // Find out size of decrypted blob
        (*g_pfn_CryptDecodeObject)(ENCODING, X509_NAME, pCertNameBlob.pbData,
                pCertNameBlob.cbData, 0, NULL, &dwSize);

        // Allocate memory for decrypted blob
        pCertName = (PCERT_NAME_INFO)HeapAlloc(GetProcessHeap(), 0, dwSize);
        if (NULL == pCertName)
        { __leave; }

        // Decode the certificate blob
        bResult = (*g_pfn_CryptDecodeObject)(ENCODING, X509_NAME, pCertNameBlob.pbData,
                pCertNameBlob.cbData, 0, pCertName, &dwSize);
        if (!bResult)
        { __leave; }

        // Get common name
        pCertAttr = (*g_pfn_CertFindRDNAttr)(szOID_COMMON_NAME, pCertName);
        if (NULL == pCertAttr)
        {
            // Get organization name if no common name found
            pCertAttr = (*g_pfn_CertFindRDNAttr)(szOID_ORGANIZATION_NAME, pCertName);
            if (NULL == pCertAttr)
            { __leave; }
        }

        // Find out size of name
        dwSize = (*g_pfn_CertRDNValueToStrA)(pCertAttr->dwValueType, &pCertAttr->Value, NULL, 0);

        // Allocate memory for name
        szName = (LPSTR)HeapAlloc(GetProcessHeap(), 0, dwSize);
        if (NULL == szName)
        { __leave; }

        // Obtain name from decrypted blob
        (*g_pfn_CertRDNValueToStrA)(pCertAttr->dwValueType, &pCertAttr->Value, szName, dwSize);
        bReturn = TRUE;
    }
    __finally
    {
        if (NULL != pCertName)
        { HeapFree(GetProcessHeap(), 0, pCertName); }

        if (!bReturn)
        {
            if (NULL != szName)
            { HeapFree(GetProcessHeap(), 0, szName); }
        }
    }

    if (bReturn)
    { return szName; }
    else
    { return NULL; }
}

//-----------------------------------------------------------------------------
// VerifyFileInfo
//    This functions verifies that the installer is valid based on the version
//    information stored in the file.
//-----------------------------------------------------------------------------
// Function parameters:
//    INSTALLER_TYPE InstallerType   Specifies whether to look for AOL or CS
//    LPSTR lpszInstaller            Fully qualified path to installer
//    PBOOL pbOldClient              Is is a client older then 5.0
//-----------------------------------------------------------------------------
BOOL VerifyFileInfo(WORD &wExeType, LPSTR lpszInstaller, PBOOL pbOldClient)
{
    BOOL  bReturn = FALSE;
    BOOL  bResult;
    BYTE *lpVerInfo = NULL;

    __try
    {
        // Get size of version info in file
        DWORD  dwHandle = 0;
        DWORD  dwVerInfoSize = (*g_pfn_GetFileVersionInfoSizeA)(lpszInstaller, &dwHandle);

        // Allocate memory for version info
        lpVerInfo = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwVerInfoSize);
        if (NULL == lpVerInfo)
        { __leave; }

        // Get version info from file
        bResult = (*g_pfn_GetFileVersionInfoA)(lpszInstaller, NULL, dwVerInfoSize, lpVerInfo);
        if (!bResult)
        { __leave; }

        // Get Language code page
        DWORD  *pdwTrans;
        UINT    uiBytes;
        DWORD dwLangCodepage = 0;

        bResult = (*g_pfn_VerQueryValueA)(lpVerInfo, "\\VarFileInfo\\Translation", (VOID **)&pdwTrans, &uiBytes);
        if (bResult)
        { dwLangCodepage = SWAPWORDS(*pdwTrans); }  // Translate language code page to something we can use
        else
        { dwLangCodepage = 0x040904e4; }     // Try English multilanguage code page

        // Obtain the "CompanyName" from the version info
        CHAR   szQuery[MAX_PATH];
        PCHAR  pszVerInfo;
        sprintf(szQuery, "\\StringFileInfo\\%08X\\CompanyName", dwLangCodepage);
        bResult = (*g_pfn_VerQueryValueA)(lpVerInfo, szQuery, (VOID **)&pszVerInfo, &uiBytes);
        if (!bResult)
        { __leave; }

        // Check "CompanyName"
        if (SERVICE_AOL & wExeType)
        {
            if ((NULL == strstr(pszVerInfo, "America Online")) && 
               (NULL == strstr(pszVerInfo, "AOL"))) 
            { __leave; }
        }
        else if (SERVICE_CS & wExeType)
        {
            if (0 != strcmp("CompuServe Interactive Services, Inc.", pszVerInfo))
            { __leave; }
        }
        else
        { __leave; }

        // Get fixed file info
        VS_FIXEDFILEINFO* pVS_FFI;
        bResult = (*g_pfn_VerQueryValueA)(lpVerInfo, "\\", (VOID **)&pVS_FFI, &uiBytes);
        if (!bResult)
        { __leave; }

        // Check if this is the Country Picker
        sprintf(szQuery, "\\StringFileInfo\\%08X\\ProductName", dwLangCodepage);
        bResult = (*g_pfn_VerQueryValueA)(lpVerInfo, szQuery, (VOID **)&pszVerInfo, &uiBytes);
        if ((bResult) && (NULL != strstr(pszVerInfo, "Country Picker")))
        {
            wExeType |= COUNTRY_PICKER;
            if (0x00010005 > pVS_FFI->dwProductVersionMS)
            { __leave; }
        }
        else
        {
            if ((0x00060000 > pVS_FFI->dwProductVersionMS)   ||
                ((0x00060000 >= pVS_FFI->dwProductVersionMS) &&
                 (0x00020000 > pVS_FFI->dwProductVersionLS)))
            {
                if ((NULL != pbOldClient) &&
                    (CLIENT & wExeType) &&
                    (0x00050000 > pVS_FFI->dwProductVersionMS))
                { *pbOldClient = TRUE; }

                __leave;
            }
        }

        bReturn = TRUE;
    }
    __finally
    {
        if (NULL != lpVerInfo)
        { HeapFree(GetProcessHeap(), 0, lpVerInfo); }
    }

    return bReturn;
}

//-----------------------------------------------------------------------------
// VerifyCertificate
//    This functions verifies that the install has not been modified since
//    being signed by America Online.
//-----------------------------------------------------------------------------
// Function parameters:
//    LPSTR lpszInstaller            Fully qualified path to installer
//-----------------------------------------------------------------------------
BOOL VerifyCertificate(LPSTR lpszInstaller) 
{
    GUID ActionGUID = WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
    GUID SubjectPeImage = WIN_TRUST_SUBJTYPE_PE_IMAGE;

    WIN_TRUST_SUBJECT_FILE Subject;

    // Subject.lpPath is a WCHAR string, must convert
    LPWSTR  lpwszInstaller = NULL;
    int     cchUnicodeSize = 0;
    cchUnicodeSize = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,
            lpszInstaller, -1, NULL, 0);

    lpwszInstaller = (LPWSTR)malloc(cchUnicodeSize * sizeof(WCHAR));

    if (0 == MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, lpszInstaller,
            -1, lpwszInstaller, cchUnicodeSize))
    {
        if (lpwszInstaller)
        { free(lpwszInstaller); }

        return FALSE;
    }

    Subject.lpPath = lpwszInstaller;
    Subject.hFile = INVALID_HANDLE_VALUE;      // Open the using the lpPath field

    WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT ActionData;

    ActionData.Subject = &Subject;
    ActionData.hClientToken = NULL; 
                                    
    ActionData.SubjectType = &SubjectPeImage;

    // Verify the file has not be changed since being signed
    HRESULT hr = (*g_pfn_WinVerifyTrust)((HWND)INVALID_HANDLE_VALUE, &ActionGUID, (WINTRUST_DATA *) &ActionData);

    if (lpwszInstaller)
    { free(lpwszInstaller); }

    if (S_OK == hr)
    { return TRUE; }
    else
    { return FALSE; }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\aolsysteminfo.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    AOLSystemInfo.cpp

 Abstract:
    AOL looks to enumerate the registry key 
    HKLM\System\CurrentControlSet\Control\Class
    but passes a fixed size buffer. The number 
    of keys under 'Class' have changed in XP 
    causing unexpected behaviour.
   
 Notes:

    This is specific to this app.

 History:

    05/17/2001 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(AOLSystemInfo)
#include "ShimHookMacro.h"

#define ALLOC_SIZE 50

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegEnumKeyExA) 
APIHOOK_ENUM_END

/*++

    The idea here is to check for the buffer sizes and wait till it is 
    one size close to it and then allocate a buffer and pass it onto the
    API.

--*/

LONG
APIHOOK(RegEnumKeyExA)(
    HKEY hkey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcClass,
    PFILETIME lpftLastWriteTime
    )
{  
    LONG lRet = 0;
    static BOOL bSet = FALSE;    
    DWORD dwNameSize = *(lpcName) ? *(lpcName) : ALLOC_SIZE;

    // Get the difference in the passed buffer gap
    DWORD dwSize = (DWORD)((LPSTR)lpcName - lpName);
    if (!bSet && (dwSize <= dwNameSize))
    {
        bSet = TRUE;
    }

    if (bSet)
    {
        lpName = (LPSTR)HeapAlloc(GetProcessHeap(), 
                    HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY,
                    ALLOC_SIZE
                    );
        if (!lpName)
        {
            return ERROR_NO_MORE_ITEMS;
        }   
        *(lpcName) = dwNameSize;
    }


    lRet = ORIGINAL_API(RegEnumKeyExA)(hkey, dwIndex, lpName,lpcName,
                            lpReserved, lpClass, lpcClass, lpftLastWriteTime);        

    if (lRet == ERROR_NO_MORE_ITEMS)
    {
        bSet = FALSE;
    }
    return lRet;
}



/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\autocad.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    AutoCad.cpp

 Abstract:

    Prevent AV when IsEmptyRect is called with a bad pointer. This fixes a hard to 
    repro Watson bug.
    
 Notes:

    This is an app specific shim.

 History:

    02/13/2002 linstev Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(AutoCad)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(IsRectEmpty)
APIHOOK_ENUM_END

/*++

 IsEmptyRect 

--*/

BOOL
APIHOOK(IsRectEmpty)(
    CONST RECT *lprc
    )
{
    if (IsBadReadPtr(lprc, sizeof(RECT))) {
        LOGN(eDbgLevelInfo, "[IsRectEmpty] invalid lprc pointer, returning TRUE");
        return TRUE;
    }

    return ORIGINAL_API(IsRectEmpty)(lprc);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, IsRectEmpty)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\aolrassetentryproperties.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AOLRasSetEntryProperties.cpp

 Abstract:

 History:
 
    05/03/2001 markder  Created

--*/

#include "precomp.h"
#include "ras.h"

IMPLEMENT_SHIM_BEGIN(AOLRasSetEntryProperties)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RasSetEntryPropertiesA)
    APIHOOK_ENUM_ENTRY(RasSetEntryPropertiesW)
APIHOOK_ENUM_END

#define RASENTRYW_V500 struct tagRASENTRYW_V500
RASENTRYW_V500
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)
    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // EncryptionType
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    WCHAR       szCustomDialDll[MAX_PATH];

    //
    // Vpn Strategy
    //
    DWORD       dwVpnStrategy;
#endif
};

#define RASENTRYA_V500 struct tagRASENTRYA_V500
RASENTRYA_V500
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    CHAR        szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;
#endif

};


DWORD APIHOOK(RasSetEntryPropertiesA)(
   LPCSTR lpszPhoneBook, 
   LPCSTR szEntry , 
   LPRASENTRYA lpbEntry, 
   DWORD dwEntrySize, 
   LPBYTE lpb, 
   DWORD dwSize )
{
    lpbEntry->dwSize = sizeof(RASENTRYA_V500);  // win2k version struct size

    return ORIGINAL_API(RasSetEntryPropertiesA)(
              lpszPhoneBook,
              szEntry,
              lpbEntry,
              dwEntrySize,
              lpb,
              dwSize);
}


DWORD APIHOOK(RasSetEntryPropertiesW)(
   LPCWSTR lpszPhoneBook, 
   LPCWSTR szEntry , 
   LPRASENTRYW lpbEntry, 
   DWORD dwEntrySize, 
   LPBYTE lpb, 
   DWORD dwSize )
{
    lpbEntry->dwSize = sizeof(RASENTRYW_V500);  // win2k version struct size

    return ORIGINAL_API(RasSetEntryPropertiesW)(
              lpszPhoneBook,
              szEntry,
              lpbEntry,
              dwEntrySize,
              lpb,
              dwSize);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(RASAPI32.DLL, RasSetEntryPropertiesA)    
    APIHOOK_ENTRY(RASAPI32.DLL, RasSetEntryPropertiesW)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\attune.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Attune.cpp

 Abstract:

    App uses counters that are obsolete since Win2k.
    
    App uses \System\% Total Processor Time counter instead of
    \Processor(_Total)\% Processor Time counter.
    
    This shim corrects the counter name before making a 
    call to PdhAddCounterA.
    
 Notes:

    This is an app specific shim.

 History:

    03/16/2001 a-leelat Created

--*/

#include "precomp.h"




IMPLEMENT_SHIM_BEGIN(Attune)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(PdhAddCounterA)
APIHOOK_ENUM_END

/*++

 Hook PdhAddCounterA 

--*/
PDH_FUNCTION
APIHOOK(PdhAddCounterA)(
    IN      HQUERY      hQuery,
    IN      LPCSTR      szFullCounterPath,
    IN      DWORD_PTR   dwUserData,
    IN      HCOUNTER    *phCounter
)
{
    
    PDH_STATUS  ReturnStatus = ERROR_SUCCESS;
    BOOL        bCorrectedPath = false;
    CHAR        szCorrectCounterPath[] = "\\Processor(_Total)\\% Processor Time";
    
    CSTRING_TRY 
    {
        //Obsolete counter Path to check for
        CString szObsoleteCounterPath = "\\System\\% Total Processor Time";

        //Passed in counter Path
        CString szCounterPath(szFullCounterPath);

        //Check to see if we have the obolsete counter passed in
        if (szObsoleteCounterPath.CompareNoCase(szCounterPath.Get()) == 0)
            bCorrectedPath = true;
    }
    CSTRING_CATCH
    {
    }

    //Call the original API
    ReturnStatus = ORIGINAL_API(PdhAddCounterA)(
                   hQuery,
                   bCorrectedPath ? szCorrectCounterPath : szFullCounterPath,
                   dwUserData,
                   phCounter);

    return ReturnStatus;
}



/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(PDH.DLL, PdhAddCounterA)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\aolfindbundledinstaller_shim.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AOLFindBundledInstaller_Shim.cpp

 Abstract:
    This shim is to provide a way to verify existance of
    America Online bundled in OEM machines when user runs older
    version of AOL/CS program (waol.exe or wcs2000.exe) or setup.

    If it exists, it will provide Apphelp dialog to tell user that
    there is newer America Online installer available.
    If user chose "Run this program", shim will launch the bundled installer.
    If user chose "Cancel", then shim will continue with current process.

    Apphelp dialog only get displayed if LocateInstaller function says to do so.

 History:

   04/30/2001 markder   Created
   05/16/2001 andyseti  Implemented LocateInstaller and ApphelpShowDialog.

--*/


#include "precomp.h"

#include "LegalStr.h"
#include <Softpub.h>
#include <WinCrypt.h>
#include <WinTrust.h>


#include "AOLFindBundledInstaller_AOLCode.h"


IMPLEMENT_SHIM_BEGIN(AOLFindBundledInstaller)
#include "ShimHookMacro.h"

#include "shimdb.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA)
    APIHOOK_ENUM_ENTRY(GetStartupInfoA)
    APIHOOK_ENUM_ENTRY(GetModuleFileNameA)
    APIHOOK_ENUM_ENTRY(CreateWindowExA)
APIHOOK_ENUM_END



#define MAX_PARAM   4

BOOL            g_bDoneIt = FALSE;
CString         g_csHTMLHelpID_BundledFound;
CString         g_csHTMLHelpID_Incompatible;
DWORD           g_dwHTMLHelpID_BundledFound = 0;
DWORD           g_dwHTMLHelpID_Incompatible = 0;
CString         g_csAppName;
CString         g_csGUID;

//
// from apphelp\apphelp.h
//
#define APPTYPE_TYPE_MASK     0x000000FF

#define APPTYPE_INC_NOBLOCK   0x00000001
#define APPTYPE_INC_HARDBLOCK 0x00000002
#define APPTYPE_MINORPROBLEM  0x00000003
#define APPTYPE_REINSTALL     0x00000004
#define APPTYPE_VERSIONSUB    0x00000005
#define APPTYPE_SHIM          0x00000006
#define APPTYPE_NONE          0x00000000

enum ShimAppHelpSeverityType
{
   APPHELP_MINORPROBLEM = APPTYPE_MINORPROBLEM,
   APPHELP_HARDBLOCK    = APPTYPE_INC_HARDBLOCK,
   APPHELP_NOBLOCK      = APPTYPE_INC_NOBLOCK,
   APPHELP_VERSIONSUB   = APPTYPE_VERSIONSUB,
   APPHELP_SHIM         = APPTYPE_SHIM,
   APPHELP_REINSTALL    = APPTYPE_REINSTALL,
   APPHELP_NONE         = APPTYPE_NONE
};

#define APPHELP_DIALOG_FAILED ((DWORD)-1)

// from sdbapi\shimdb.w

/*
typedef struct _APPHELP_INFO {

//
//  html help id mode
//
    DWORD   dwHtmlHelpID; // html help id
    DWORD   dwSeverity;   // must have
    LPCTSTR lpszAppName;
    GUID    guidID;       // entry guid

//
//  Conventional mode
//
    TAGID   tiExe;              // the TAGID of the exe entry within the DB
    GUID    guidDB;             // the guid of the DB that has the EXE entry

    BOOL    bOfflineContent;
    BOOL    bUseHTMLHelp;
    LPCTSTR lpszChmFile;
    LPCTSTR lpszDetailsFile;

} APPHELP_INFO, *PAPPHELP_INFO;

*/

typedef BOOL (*_pfn_ApphelpShowDialog)(
    IN  PAPPHELP_INFO   pAHInfo,    // the info necessary to find the apphelp data
    IN  PHANDLE         phProcess   // [optional] returns the process handle of
                                    // the process displaying the apphelp.
                                    // When the process completes, the return value
                                    // (from GetExitCodeProcess()) will be zero
                                    // if the app should not run, or non-zero
                                    // if it should run.

    );


/*++

 Parse the command line.

 The format of the command line is:

 MODE:AOL|CS;APPNAME:xxxxxx;HTMLHELPID:99999;GUID:xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxx

--*/



BOOL
ParseCommandLine(
    LPCSTR lpCommandLine
    )
{
    int iTotalParam = 0;

    CSTRING_TRY
    {
        CStringToken csTok(lpCommandLine, L" ;");

        CString token;

        while (csTok.GetToken(token))
        {
            CStringToken csSingleTok(token, L":");

            CString csParam;
            CString csValue;

            csSingleTok.GetToken(csParam);
            csSingleTok.GetToken(csValue);

            if (csParam.CompareNoCase(L"APPNAME") == 0)
            {
                g_csAppName = csValue;
                ++iTotalParam;
            }

            if (csParam.CompareNoCase(L"HTMLHELPID_BUNDLED") == 0)
            {
                g_csHTMLHelpID_BundledFound = csValue;
                g_dwHTMLHelpID_BundledFound = _wtol(csValue.Get());
                ++iTotalParam;
            }

            if (csParam.CompareNoCase(L"HTMLHELPID_INCOMPAT") == 0)
            {
                g_csHTMLHelpID_Incompatible = csValue;
                g_dwHTMLHelpID_Incompatible = _wtol(csValue.Get());
                ++iTotalParam;
            }

            if (csParam.CompareNoCase(L"GUID") == 0)
            {
                g_csGUID = csValue;
                ++iTotalParam;
            }
        }
    }
    CSTRING_CATCH
    {
        DPF("FindAOL", eDbgLevelInfo, "Error in CString.Exiting\n");
        return FALSE;
    }

    if (iTotalParam < MAX_PARAM)
    {
        DPF("FindAOL", eDbgLevelInfo, "Total Parameter = %d is less than = %d\n",iTotalParam, MAX_PARAM);
        return FALSE;
    }


    //
    // Dump results of command line parse
    //

    DPF("FindAOL", eDbgLevelInfo, "===================================\n");
    DPF("FindAOL", eDbgLevelInfo, "              FindAOL              \n");
    DPF("FindAOL", eDbgLevelInfo, "===================================\n");
    DPF("FindAOL", eDbgLevelInfo, "COMMAND_LINE(%s)", lpCommandLine);
    DPF("FindAOL", eDbgLevelInfo, "-----------------------------------\n");

    DPF("FindAOL", eDbgLevelInfo, "APPNAME              = %S\n", g_csAppName);
    DPF("FindAOL", eDbgLevelInfo, "HTMLHELPID_BUNDLED   = %S\n", g_csHTMLHelpID_BundledFound);
    DPF("FindAOL", eDbgLevelInfo, "HTMLHELPID_INCOMPAT  = %S\n", g_csHTMLHelpID_Incompatible);
    DPF("FindAOL", eDbgLevelInfo, "GUID                 = %S\n", g_csGUID);

    DPF("FindAOL", eDbgLevelInfo, "-----------------------------------\n");

    return TRUE;
}


BOOL InvokeApphelpShowDialog(DWORD dwHTMLHelpID)
{
    _pfn_ApphelpShowDialog  pfnApphelpShowDialog = NULL;
    APPHELP_INFO            AHInfo = { 0 };
    HMODULE                 hAppHelpDLL = NULL;

    hAppHelpDLL = LoadLibrary(L"APPHELP.DLL");

    DPF("FindAOL", eDbgLevelWarning, "Apphelp:%d\n",hAppHelpDLL );

    if (hAppHelpDLL)
    {

        pfnApphelpShowDialog = (_pfn_ApphelpShowDialog) GetProcAddress(hAppHelpDLL, "ApphelpShowDialog");

        if (pfnApphelpShowDialog == NULL)
        {
            DPF("FindAOL", eDbgLevelInfo, "Unable to get APPHELP!ApphelpShowDialog procedure address.\n");
            return FALSE;
        }

        AHInfo.dwHtmlHelpID = dwHTMLHelpID;
        AHInfo.dwSeverity = APPHELP_NOBLOCK;
        AHInfo.lpszAppName = g_csAppName.Get();
        AHInfo.bPreserveChoice = TRUE;

        HRESULT         hr;
        UNICODE_STRING  ustrGuid;
        NTSTATUS        ntstatus;

        RtlInitUnicodeString(&ustrGuid, g_csGUID.Get());

        ntstatus = RtlGUIDFromString(&ustrGuid, &AHInfo.guidID);

        if (NT_SUCCESS(ntstatus)==FALSE)
        {
            DPF("FindAOL", eDbgLevelInfo, "RtlGUIDFromString failed!\n");
            return FALSE;
        }

        if (pfnApphelpShowDialog(&AHInfo,NULL))
        {
            DPF("FindAOL", eDbgLevelInfo, "!\n");
        }
        else
        {
            DPF("FindAOL", eDbgLevelInfo, "RtlGUIDFromString FAILED!\n");
            return FALSE;
        }
    }
    else
    {
        DPF("FindAOL", eDbgLevelInfo, "LoadLibrary FAILED!\n");
        return FALSE;
    }
    return TRUE;
}

void DoIt()
{
    char    szModuleName[MAX_PATH];
    DWORD   dwLen = 0;
    CHAR    lpszInstaller[MAX_PATH];
    BOOL    bBundledInstallerFound = FALSE;
    BOOL    bDisplayAppHelpDialog = FALSE;
    BOOL    bKillCurrentProcess = FALSE;
    BOOL    bLaunchBundledInstaller = FALSE;
    BOOL    bReturnValue = FALSE;
    UINT    uiWinExecReturned = 0;

    if (!g_bDoneIt) {
        if (!ParseCommandLine(COMMAND_LINE)) {
            goto eh;
        }
        bBundledInstallerFound = LocateInstaller(lpszInstaller, MAX_PATH, &bDisplayAppHelpDialog);

        if (bBundledInstallerFound) {
            DPF("FindAOL", eDbgLevelWarning, "Bundled installer found in %s.\n",lpszInstaller);
        }

        if (bBundledInstallerFound == FALSE && bDisplayAppHelpDialog == FALSE) {
            DPF("FindAOL", eDbgLevelWarning, "Bundled installer not found. Let client run normally.\n");
            goto eh;
        }

        if (bBundledInstallerFound == FALSE && bDisplayAppHelpDialog == TRUE) {
            bReturnValue = InvokeApphelpShowDialog(g_dwHTMLHelpID_Incompatible);

            // if user chose Cancel button, then just kill current process.
            if (FALSE == bReturnValue) {
                bKillCurrentProcess = TRUE;
            }
        }

        if (bBundledInstallerFound == TRUE && bDisplayAppHelpDialog == TRUE) {
            bReturnValue = InvokeApphelpShowDialog(g_dwHTMLHelpID_BundledFound);

            // if user chose Continue button, then launch bundled installer.
            if (TRUE == bReturnValue) {
                bKillCurrentProcess = TRUE;
                bLaunchBundledInstaller = TRUE;
            }
        }

        if (bBundledInstallerFound == TRUE && bDisplayAppHelpDialog == FALSE) {

            // Launch bundled installer.
            bKillCurrentProcess = TRUE;
            bLaunchBundledInstaller = TRUE;
        }

        if (bLaunchBundledInstaller) {
            // launch bundled installer instead
            uiWinExecReturned = WinExec(lpszInstaller, SW_SHOW);

            if (uiWinExecReturned <= 31) {
                DPF("FindAOL", eDbgLevelError, "Can not launch program. Error: %d\n",GetLastError());
                goto eh;
            }
        }

        if (bKillCurrentProcess) {
            ExitProcess(0);
        }
    }

eh:

    g_bDoneIt = TRUE;
}

LPSTR
APIHOOK(GetCommandLineA)()
{
    DoIt();

    return ORIGINAL_API(GetCommandLineA)();
}

VOID
APIHOOK(GetStartupInfoA)(
    LPSTARTUPINFOA lpStartupInfo)
{
    DoIt();

    ORIGINAL_API(GetStartupInfoA)(lpStartupInfo);
}

DWORD
APIHOOK(GetModuleFileNameA)(
  HMODULE hModule,    // handle to module
  LPSTR lpFilename,  // file name of module
  DWORD nSize         // size of buffer
  )
{
    DoIt();

    return ORIGINAL_API(GetModuleFileNameA)(hModule, lpFilename, nSize);
}

HWND
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam
    )
{
    DoIt();

    return ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam );
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetStartupInfoA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetModuleFileNameA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\autodeskworld2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AutoDeskWorld2.cpp

 Abstract:

    Set LPMODULEENTRY32->GlblcntUsage to 1 if the call to Module32First was 
    successful.
    
    No idea why this works on NT4 on Win9x.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"
#include <tlhelp32.h>

IMPLEMENT_SHIM_BEGIN(AutoDeskWorld2)
#include "ShimHookMacro.h"

// Undefine this here!! Otherwise, in a unicode build
// environment, Module32First is #defined as Module32FirstW.
#ifdef Module32First
#undef Module32First
#endif

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(Module32First) 
APIHOOK_ENUM_END

/*++

 Set LPMODULEENTRY32->GlblcntUsage to 1 if the call to Module32First was 
 successful.

--*/

BOOL
APIHOOK(Module32First)(
    HANDLE SnapSection,
    LPMODULEENTRY32 lpme
    )
{
    BOOL bRet;

    bRet = ORIGINAL_API(Module32First)(SnapSection, lpme);

    if (bRet) {
        DPFN( eDbgLevelInfo, "setting lpme->GlblcntUsage to 1");
        
        lpme->GlblcntUsage = 1;
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, Module32First)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\baseball2000.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    BaseBall2000.cpp

 Abstract:

    If you use a video card that supports more than 10 texture formats the
    app will AV writing passed the end of their SURFACEDESC array.
    
 History:
        
    01/04/2001 maonis Created

--*/

#include "precomp.h"
#include "d3d.h"

IMPLEMENT_SHIM_BEGIN(BaseBall2000)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

typedef HRESULT (*_pfn_IDirect3D3_CreateDevice)(PVOID pThis, REFCLSID rclsid, LPDIRECTDRAWSURFACE4, LPDIRECT3DDEVICE3*, LPUNKNOWN);
typedef HRESULT (*_pfn_IDirect3DDevice3_EnumTextureFormats)(PVOID pThis, LPD3DENUMPIXELFORMATSCALLBACK, LPVOID);

typedef HRESULT (*_pfn_EnumPixelFormatsCallback)(LPDDPIXELFORMAT lpDDPixFmt, LPVOID lpContext);

_pfn_EnumPixelFormatsCallback g_pfnEnumPixelFormatsCallback = NULL;
int g_cD3DEnumPixelFormatsCallbacks = 0;

/*++

    Hook this call so we can make sure that calling methods on the 
    IDirect3DDevice3 interface is hooked.

--*/

HRESULT 
COMHOOK(IDirect3D3, CreateDevice)(
    PVOID pThis, 
    REFCLSID rclsid,
    LPDIRECTDRAWSURFACE4 lpDDS,
    LPDIRECT3DDEVICE3* lplpD3DDevice,
    LPUNKNOWN lpUnkOuter
    )
{
    HRESULT hReturn;
    
    _pfn_IDirect3D3_CreateDevice pfnOld = 
        ORIGINAL_COM(IDirect3D3, CreateDevice, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            rclsid, 
            lpDDS, 
            lplpD3DDevice,
            NULL)))
    {
        HookObject(
            NULL, 
            IID_IDirect3DDevice3, 
            (PVOID*)lplpD3DDevice, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

    Restrict to returning at most 10 texture formats.

--*/

HRESULT 
CALLBACK 
EnumPixelFormatsCallback(
    LPDDPIXELFORMAT lpDDPixFmt,  
    LPVOID lpContext    
    )
{
    // The app only supports up to 10 texture formats.
    if (++g_cD3DEnumPixelFormatsCallbacks >= 11)
    {
        return D3DENUMRET_CANCEL;
    }
    else
    {
        return g_pfnEnumPixelFormatsCallback(lpDDPixFmt, lpContext);
    }
}

/*++

    Call our private callback instead.

--*/

HRESULT 
COMHOOK(IDirect3DDevice3, EnumTextureFormats)( 
    PVOID pThis, 
    LPD3DENUMPIXELFORMATSCALLBACK lpd3dEnumPixelProc,  
    LPVOID lpArg                                           
  )
{
    DPFN( eDbgLevelError, "it IS getting called");

    g_pfnEnumPixelFormatsCallback = lpd3dEnumPixelProc;

    _pfn_IDirect3DDevice3_EnumTextureFormats EnumTextureFormats =  ORIGINAL_COM(IDirect3DDevice3, EnumTextureFormats, pThis);

    return EnumTextureFormats(pThis, EnumPixelFormatsCallback, lpArg);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()

    COMHOOK_ENTRY(DirectDraw, IDirect3D3, CreateDevice, 8)

    COMHOOK_ENTRY(DirectDraw, IDirect3DDevice3, EnumTextureFormats, 8)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\backoffice45suite.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    BackOffice45Suite.cpp

 Abstract:

    Ignore msvcrt!exit. No idea why it worked just fine in NT4.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BackOffice45Suite)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(exit) 
APIHOOK_ENUM_END

/*++

 Ignore msvcrt!exit

--*/

void
APIHOOK(exit)(
    int status
    )
{
    DPFN( eDbgLevelInfo, "BackOffice45Suite.dll, Ignoring msvcrt!exit...");
    return;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(MSVCRT.DLL, exit)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\baanerp5c.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    BaanERP5c.cpp

 Abstract:

    The app sets the SharedSection in Windows Value under the key
    HKLM\System\CCS\Control\Session Manger\SubSystems to 4096
    from the one that is exisiting in registry. But this is resulting
    in failure of the BannLogicService and BaanSharedMemroy 
    services when they are started. 

    This shim hooks the RegSetValueExA and returns SUCCESS 
    without setting the value in registry if the app is trying to set the 
    HKLM\\System\CCS\Control\Session Manager\SubSystems\Windows 
    value from *SharedSection=####,####,512,* to *SharedSection=####,####,4096,*
    
 Notes:

    This is an app specific shim.

 History:

    02/09/2001 a-leelat Created

--*/

#include "precomp.h"


IMPLEMENT_SHIM_BEGIN(BaanERP5c)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(RegSetValueExA)

APIHOOK_ENUM_END



LONG
APIHOOK(RegSetValueExA)(
    HKEY   hKey,
    LPCSTR lpValueName,
    DWORD  Reserved,
    DWORD  dwType,
    CONST BYTE * lpData,
    DWORD  cbData
    )
{
    CSTRING_TRY
    {
        CString csValueName(lpValueName);
        if (csValueName.CompareNoCase(L"Windows") == 0 )
        {
            LPSTR lpszData = (LPSTR)lpData;
            CString csData(lpszData);
            if (csData.Find(L"4096") >= 0)
            {
                return ERROR_SUCCESS;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    
    return ORIGINAL_API(RegSetValueExA)(hKey,       
                                      lpValueName,  
                                      Reserved,     
                                      dwType,    
                                      lpData,       
                                      cbData);      
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExA);


HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\baaniv.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    BaanIV.cpp

 Abstract:

    Ignore WM_STYLECHANGED on the app's subclassed listbox. This is needed 
    because the app subclasses the listbox and Win2k changed a bit the 
    behavior of the listbox window proc with regards to handling 
    WM_STYLECHANGED.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"
#include <commdlg.h>

IMPLEMENT_SHIM_BEGIN(BaanIV)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
    APIHOOK_ENUM_ENTRY(CallWindowProcA) 
APIHOOK_ENUM_END

WNDPROC gpfnOrgListBoxWndProc;
WNDPROC gpfnAppListBoxWndProc;

/*++

 Ignore WM_STYLECHANGED.

--*/

LRESULT
Modified_ListBoxWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (message == WM_STYLECHANGED) {
        return 0;
    }

    return (*gpfnAppListBoxWndProc)(hwnd, message, wParam, lParam);
}

/*++

    When the app calls CallWindowProc passing our modified listbox
    proc call the original window proc instead

--*/
LRESULT
APIHOOK(CallWindowProcA)(
    WNDPROC pfn,
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    if (pfn == (WNDPROC)Modified_ListBoxWndProcA) {
        pfn = (WNDPROC)gpfnOrgListBoxWndProc;
    }

    return ORIGINAL_API(CallWindowProcA)(pfn, hwnd, message, wParam, lParam);
}

/*++

 When the app subclasses the listbox of a combobox grab the original listbox 
 proc, grab the pointer that the app is trying to set, set the new pointer to 
 be our modified version of the listbox proc and return to the app our pointer.

--*/

ULONG_PTR
APIHOOK(SetWindowLongA)(
    HWND hwnd,
    int nIndex,
    ULONG_PTR newLong
    )
{
    if (nIndex == GWLP_WNDPROC) {
        WNDCLASSA wndClass;
        ULONG_PTR pfnOrg;

        GetClassInfoA((HINSTANCE)GetWindowLong(hwnd, GWLP_HINSTANCE),
                      "ComboLBox",
                      &wndClass);

        pfnOrg = (ULONG_PTR)GetWindowLong(hwnd, GWLP_WNDPROC);

        if ((WNDPROC)pfnOrg == wndClass.lpfnWndProc) {

            gpfnOrgListBoxWndProc = (WNDPROC)pfnOrg;

            DPFN( eDbgLevelInfo, "Fix up subclassing of ComboLBox");

            gpfnAppListBoxWndProc = (WNDPROC)newLong;

            newLong = (ULONG_PTR)Modified_ListBoxWndProcA;

            ORIGINAL_API(SetWindowLongA)(hwnd, nIndex, newLong);

            return newLong;
        }
    }

    // Call the Initial function
    return ORIGINAL_API(SetWindowLongA)(hwnd, nIndex, newLong);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, CallWindowProcA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\baanerp5.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    BaanERP5.cpp

 Abstract:

    Set 'lpstrInitialDir' in the OPENFILENAMEA structure passed to
    GetSaveFileNameA to be the directory the app is installed to.
    This information is read from the registry.
    
    No idea why this worked in Win9x.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"
#include <commdlg.h>

IMPLEMENT_SHIM_BEGIN(BaanERP5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetSaveFileNameA) 
APIHOOK_ENUM_END

char gszLibUser[] = "\\LIB\\USER";
char gszBaanDir[MAX_PATH];

/*++

 Set the initial directory to be the directory the app was installed to. This 
 information is read from the registry.

--*/

BOOL
APIHOOK(GetSaveFileNameA)(
    LPOPENFILENAMEA lpofn
    )
{
    if (lpofn->lpstrInitialDir == NULL) {

        HKEY    hkey = NULL;
        DWORD   ret;
        DWORD   cbSize;

        /*
         * Get the directory only once
         */
        if (gszBaanDir[0] == 0) {

            ret = RegOpenKeyA(HKEY_LOCAL_MACHINE,
                              "SOFTWARE\\Baan\\bse",
                              &hkey);

            if (ret != ERROR_SUCCESS) {
                DPFN( eDbgLevelInfo, "Failed to open key 'SOFTWARE\\Baan\\bse'");
                goto Cont;
            }

            cbSize = MAX_PATH;

            ret = (DWORD)RegQueryValueExA(hkey,
                                          "BSE",
                                          NULL,
                                          NULL,
                                          (LPBYTE)gszBaanDir,
                                          &cbSize);
            
            if (ret != ERROR_SUCCESS) {
                DPFN( eDbgLevelInfo, "Failed to query value BSE");
                goto Cont;
            }
            
            lstrcatA(gszBaanDir, gszLibUser);

Cont:
            if (hkey != NULL) {
                RegCloseKey(hkey);
            }
        }

        lpofn->lpstrInitialDir = gszBaanDir;

        DPFN( eDbgLevelInfo, "BaanERP5.dll, Changing lpstrInitialDir to '%s'", gszBaanDir);
    }

    // Call the Initial function
    return ORIGINAL_API(GetSaveFileNameA)(lpofn);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(COMDLG32.DLL, GetSaveFileNameA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\battleship.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Battleship.cpp

 Abstract:

    This game is divided into 3 programs:
      1. The launcher (bshipl.exe)
      2. Classic (bship.exe)
      3. Ultimate (bs.exe)
    
    The launcher is the only shortcut exposed to the user and runs the other 2. 
    However, the launcher and Classic both have a ton of problems that aren't 
    easily fixed with a shim.

    Ultimate, is a complete superset of all the features of Classic and doesn't 
    appear to have any issues.

    Therefore, the fix is to redirect the launcher to Ultimate and prevent 
    Ultimate from spawning the launcher on quit.

 Notes:

    This is a specific shim.

 History:

    08/03/2000  a-vales     Created
    03/13/2001  robkenny    Converted to CString
    05/05/2001  linstev     Rewrote 

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(Battleship)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END

/*++
 
 Don't allow this program to spawn the launcher.

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if (lpCommandLine && (stristr(lpCommandLine, "bshipl.exe") != 0)) {
        //
        // This is the launcher, so do nothing
        //

        return TRUE;
    } 

    return ORIGINAL_API(CreateProcessA)(
        lpApplicationName,
        lpCommandLine,
        lpProcessAttributes,
        lpThreadAttributes,
        bInheritHandles,
        dwCreationFlags,
        lpEnvironment,
        lpCurrentDirectory,
        lpStartupInfo,
        lpProcessInformation);
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Set the current working directory for the launcher so 
        // the redirectexe shim works with a relative path
        //
        WCHAR szName[MAX_PATH];
        if (GetModuleFileNameW(0, szName, MAX_PATH)) {
            WCHAR *p = wcsistr(szName, L"\\bshipl.exe");
            if (p) {
                *p = L'\0';
                SetCurrentDirectoryW(szName);
            }
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\beyondatlantis.cpp ===
/*

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    BeyondAtlantis.cpp

 Abstract:

    Fix disk space error caused by bad string passed to 
    GetDiskFreeSpace. This root path is also bad on Win9x. No idea
    why that doesn't affect it.

 History:

    05/31/2002  linstev    Created

*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BeyondAtlantis)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetDiskFreeSpaceA)
APIHOOK_ENUM_END

BOOL 
APIHOOK(GetDiskFreeSpaceA)(
    LPCSTR  lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )
{
    if (lpRootPathName && (strncmp(lpRootPathName, "tla", 3) == 0)) {
        CSTRING_TRY
        {        
            CString csPath;
            csPath.GetCurrentDirectoryW();
            CString csDrive;
            csPath.SplitPath(&csDrive, NULL, NULL, NULL);
        
            return ORIGINAL_API(GetDiskFreeSpaceA)(csDrive.GetAnsi(), lpSectorsPerCluster, 
                lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
        }
        CSTRING_CATCH
        {
        }
    }
        
    return ORIGINAL_API(GetDiskFreeSpaceA)(lpRootPathName, lpSectorsPerCluster, 
        lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
}

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetDiskFreeSpaceA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\battlezone.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    BattleZone.cpp

 Abstract:
    
    This app is a really good example of things not to do:

    1. Infinite loop on mciSendString('play...'). In order to fix this we 
       return a failure case if the same play string is sent twice and the
       device is playing already. Note that the behaviour of the 
       mciSendString API is consistent with win9x. Someone managed to repro
       this hang on win9x, but it's more difficult. 

    2. They call SetCooperativeLevel(DDSCL_NORMAL) between a Begin/End 
       Scene. On NT, this causes the Z-Buffer to be lost which means that 
       when EndScene is called, it returns D3DERR_SURFACESLOST which causes 
       the app to AV.
        
 Notes:

    This is an app specific shim.

 History:

    02/10/2000 linstev  Created

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(BattleZone)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
    APIHOOK_ENUM_ENTRY(mciSendCommandA)
    APIHOOK_ENUM_ENTRY(mciSendStringA)
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

CString *           g_csLastCommand = NULL;
MCIDEVICEID         g_wDeviceID     = 0;
LPDIRECTDRAWSURFACE g_lpZBuffer     = NULL;

/*++

 Store the DeviceId.

--*/

MCIERROR 
APIHOOK(mciSendCommandA)(
    MCIDEVICEID IDDevice,  
    UINT uMsg,             
    DWORD fdwCommand,      
    DWORD dwParam          
    )
{
    MCIERROR mErr = ORIGINAL_API(mciSendCommandA)(
        IDDevice,
        uMsg,
        fdwCommand,
        dwParam);

    if ((mErr == 0) && (uMsg == MCI_OPEN))
    {
        g_wDeviceID = ((LPMCI_OPEN_PARMS)dwParam)->wDeviceID;
    }

    return mErr;
}

/*++

 Prevent looping.

--*/

MCIERROR 
APIHOOK(mciSendStringA)(
    LPCSTR lpszCommand,  
    LPSTR lpszReturnString,  
    UINT cchReturn,       
    HANDLE hwndCallback   
    )
{
    DPFN( eDbgLevelInfo, "mciSendStringA: %s", lpszCommand);

    CSTRING_TRY
    {
        CString csCommand(lpszCommand);
        if (csCommand.Compare(*g_csLastCommand) == 0)
        {
            MCI_STATUS_PARMS mciStatus;
            ZeroMemory(&mciStatus, sizeof(mciStatus));
            mciStatus.dwItem = MCI_STATUS_MODE;
            
            if (0 == ORIGINAL_API(mciSendCommandA)(
                g_wDeviceID,
                MCI_STATUS,
                MCI_STATUS_ITEM,
                (DWORD_PTR)&mciStatus))
            {
                if (mciStatus.dwReturn == MCI_MODE_PLAY)
                {
                    DPFN( eDbgLevelWarning, "Device still playing, returning busy");
                    return MCIERR_DEVICE_NOT_READY;
                }
            }
        }
        else
        {
            *g_csLastCommand = csCommand;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(mciSendStringA)(
        lpszCommand,  
        lpszReturnString,  
        cchReturn,       
        hwndCallback);
}

/*++

 Hook create surface to find the zbuffer we'll need to restore later. Note that
 we use HookObject to get the surface release notification.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)( 
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE *lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        if (lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_ZBUFFER)
        {
            g_lpZBuffer = *lplpDDSurface;
            DPFN( eDbgLevelInfo, "Found ZBuffer", g_lpZBuffer);
        } 
    }

    return hReturn;
}

/*++

 Use SetCooperativeLevel to keep track of who the exclusive mode owner is.
 
--*/

HRESULT
COMHOOK(IDirectDraw, SetCooperativeLevel)( 
    PVOID pThis, 
    HWND hWnd,
    DWORD dwFlags
    )
{
    HRESULT hReturn;

    // Original SetCooperativeLevel
    _pfn_IDirectDraw_SetCooperativeLevel pfnOld = 
        ORIGINAL_COM(IDirectDraw, SetCooperativeLevel, pThis);

    hReturn = (*pfnOld)(pThis, hWnd, dwFlags);

    __try
    {
        if (g_lpZBuffer && (g_lpZBuffer->IsLost() == DDERR_SURFACELOST))
        {
            g_lpZBuffer->Restore();
            DPFN( eDbgLevelInfo, "Restoring lost ZBuffer");
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return hReturn;
}

/*++

 Allocate global variables.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        CSTRING_TRY
        {
            g_csLastCommand = new CString;
            return g_csLastCommand != NULL;
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    
    APIHOOK_ENTRY_DIRECTX_COMSERVER()

    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, SetCooperativeLevel, 20)

    APIHOOK_ENTRY(WINMM.DLL, mciSendCommandA)
    APIHOOK_ENTRY(WINMM.DLL, mciSendStringA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\biggamehunter3.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    BigGameHunter3.cpp

 Abstract:

    BGH calls GetWindowLong() to get a window procedure and subsequently 
    does not call CallWindowProc() with the value returned from 
    GetWindowLong(). This patch calls GetWindowLongW( ), which returns the 
    window procedure. 
   
 Notes:

    This is an app specific shim. Making it general will require generating 
    a stub function that just uses CallWindowProc for every returned handle. 
    Too much work, not enough gain.

 History:

    03/16/2000 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BigGameHunter3)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetWindowLongA) 
APIHOOK_ENUM_END

/*++

 This function intercepts GetWindowLong( ), checks the nIndex for GWL_WNDPROC 
 and if it is,calls GetWindowLongW( ). Otherwise, it calls GetWindowLongA( )

--*/

LONG
APIHOOK(GetWindowLongA)(
    HWND hwnd,
    int  nIndex )
{
    LONG lRet;

    // Apply the modification only if the App wants a WindowProc.
    if (nIndex == GWL_WNDPROC) 
    {
        lRet = GetWindowLongW(hwnd, nIndex);
    }
    else
    {
        lRet = ORIGINAL_API(GetWindowLongA)(hwnd, nIndex);
    }

    return lRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, GetWindowLongA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\bizplanbuilder.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    BizPlanBuilder.cpp

 Abstract:

    App does not repaint after a WM_SETTEXT message.

 Notes:
    
    This is an app specific shim.

 History:

    01/03/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BizPlanBuilder)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowTextA) 
APIHOOK_ENUM_END

/*++

 Subclass the windowproc for this call and fix the pointer that comes out in 
 the WM_SETTEXT message that is generated by SetWindowTextA.

--*/

BOOL 
APIHOOK(SetWindowTextA)(
    HWND hWnd,         
    LPCSTR lpString   
    )
{
    BOOL bRet = ORIGINAL_API(SetWindowTextA)(hWnd, lpString);

    //
    // Redraw the window
    //

    InvalidateRect(hWnd, NULL, TRUE);

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, SetWindowTextA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\britannica2001.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Britannica2001.cpp

 Abstract:

    Britannica expects IE 5 install to install msjavx86.exe
    which doesn't happen if a newer version of IE is already there.

 Notes:

    This is an app specific shim.

 History:

    05/31/2001  mnikkel  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Britannica2001)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END



/*++

  Check CreateProcessA for execution of ie5wzdex.exe, when this
  occurs, run msjavx86.exe.

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                  lpApplicationName,                 
    LPSTR                   lpCommandLine,                      
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, 
    BOOL                    bInheritHandles,                     
    DWORD                   dwCreationFlags,                    
    LPVOID                  lpEnvironment,                     
    LPCSTR                  lpCurrentDirectory,                
    LPSTARTUPINFOA          lpStartupInfo,             
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    DPFN( eDbgLevelSpew, "[CreateProcessA] appname:(%s)\ncommandline:(%s)", lpApplicationName, lpCommandLine );

    //
    // Call the original API
    //
    BOOL bRet= ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                            lpCommandLine,
                                            lpProcessAttributes,
                                            lpThreadAttributes, 
                                            bInheritHandles,                     
                                            dwCreationFlags,                    
                                            lpEnvironment,                     
                                            lpCurrentDirectory,                
                                            lpStartupInfo,             
                                            lpProcessInformation);

    // wait for original API to finish
    if (bRet)
    {
        WaitForSingleObject( lpProcessInformation->hProcess, INFINITE);
    }


    // Check for <ie5wzd /S:\"> and if found run msjavx86.exe in quiet mode
    if (lpCommandLine)
    {
        CSTRING_TRY
        {
            CString csCL(lpCommandLine);

            int nLoc = csCL.Find(L"ie5wzd /S:\"");
            if ( nLoc > -1 )
            {
                PROCESS_INFORMATION     processInfo;

                CString csNew = csCL.Mid(nLoc+11, 3);
                csNew += L"javavm\\msjavx86.exe /Q:A /R:N";

                DPFN( eDbgLevelError, "[CreateProcessA] starting %S", csNew.Get() );

                BOOL bRet2= CreateProcessA(NULL,
                               csNew.GetAnsi(),
                               NULL,
                               NULL, 
                               FALSE,                     
                               0,                    
                               NULL,                     
                               NULL,                
                               lpStartupInfo,
                               &processInfo);

                if (bRet2)
                {
                    WaitForSingleObject( processInfo.hProcess, INFINITE);
                }
            }
        }
        CSTRING_CATCH
        {
            // Do Nothing
        }
    }

    return bRet;
}

    
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\bigactionconstruction.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    BigActionConstruction.cpp
 Abstract:
    The uninstall was not uninstalling the .lnk files on
    the ALLUSER start Menu. This was because the uninstaller
    script was not getting the right path. 

    This is an app specific shim.

 History:
 
    03/12/2001 prashkud  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BigActionConstruction)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(FindFirstFileA)    
    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
APIHOOK_ENUM_END


WCHAR g_szAllUsersStartMenu[MAX_PATH];

WCHAR* g_pszFilePath = L"\\Programs\\Big Action Construction";
WCHAR* g_pszReplacementFilePath = L"\\Programs\\Fisher~1\\Big Action Construction";


/*++
    This hook replaces the wrong path with the right replacement path.
    
--*/

HANDLE
APIHOOK(FindFirstFileA)(
    LPCSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    CSTRING_TRY
    {
        CString AllUserPath(g_szAllUsersStartMenu);
        CString FileName(lpFileName);
        // Or D:\Documents And Settings\All Users\Start Menu\g_pszFilePath\*.*
        AllUserPath.AppendPath(g_pszFilePath);
        AllUserPath.AppendPath(L"*.*");
    
        // If any of the above constructed path match
        if (AllUserPath.CompareNoCase(FileName) == 0)
        {
            // Fill in the replacement path 
            AllUserPath = g_szAllUsersStartMenu;
            AllUserPath.AppendPath(g_szAllUsersStartMenu);
            AllUserPath.AppendPath(L"*.*");
       
            DPFN( eDbgLevelInfo, "[Notify] FindFirstFileA \
                modified %s to %S",lpFileName, AllUserPath.Get());

            return ORIGINAL_API(FindFirstFileA)(AllUserPath.GetAnsi(),lpFindFileData);
        }
    }
    CSTRING_CATCH
    {
        //do nothing
    }

   return ORIGINAL_API(FindFirstFileA)(lpFileName,lpFindFileData);
}

/*++
    This hook replaces the wrong path with the right replacement path.
    
--*/

BOOL
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpFileName    
    )
{
    CSTRING_TRY
    {
        CString AllUserPath(g_szAllUsersStartMenu);
        CString FileName(lpFileName);
        // Or D:\Documents And Settings\All Users\Start Menu\g_pszFilePath    
        AllUserPath.AppendPath(g_pszFilePath);

        if (AllUserPath.CompareNoCase(FileName) == 0)
        {
            // Fill in the replacement path       
            AllUserPath = g_szAllUsersStartMenu;
            AllUserPath.AppendPath(g_szAllUsersStartMenu);

            DPFN( eDbgLevelInfo, "[Notify] RemoveDirectoryA \
                modified %s to %S", lpFileName, AllUserPath.Get());     

            return ORIGINAL_API(RemoveDirectoryA)(AllUserPath.GetAnsi());
        }
    }
    CSTRING_CATCH
    {
        //do nothing
    }

    return ORIGINAL_API(RemoveDirectoryA)(lpFileName);
}

/*++
    This hook replaces the wrong path with the right replacement path.
    
--*/

BOOL
APIHOOK(DeleteFileA)(
    LPCSTR lpFileName    
    )
{
    CSTRING_TRY
    {
        CString AllUserPath(g_szAllUsersStartMenu);            
        AllUserPath += g_pszFilePath;

        CString csFileName(lpFileName);
        int nIndex = AllUserPath.Find(csFileName);
        
        if (nIndex >= 0)
        {
            // Seperate the title from the path.
            char szTitle[MAX_PATH];
            GetFileTitleA(lpFileName, szTitle, MAX_PATH);
            CString csTitle(szTitle);
            csTitle += L".lnk";

            // Fill in the replacement path with the title.     
            AllUserPath = g_szAllUsersStartMenu;
            AllUserPath.AppendPath(g_pszReplacementFilePath);
            AllUserPath.AppendPath(csTitle);       

            DPFN( eDbgLevelInfo, "[Notify] DeleteFileA \
                modified %s to %S", lpFileName, AllUserPath.Get());   
       
            return ORIGINAL_API(DeleteFileA)(AllUserPath.GetAnsi());
        }
    }
    CSTRING_CATCH
    {
        //do nothing
    }

   return ORIGINAL_API(DeleteFileA)(lpFileName);
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        // Get the %AllUserStartMenu% from SHELL
        HRESULT result = SHGetFolderPath(NULL, CSIDL_COMMON_STARTMENU, NULL,
                            SHGFP_TYPE_DEFAULT, g_szAllUsersStartMenu);

        if ((result == S_FALSE) || (result == E_INVALIDARG))
        {
            return FALSE;
        }      
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)    
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\canvas6.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Canvas6.cpp

 Abstract:

    This app. deletes HKEY\CLASSES_ROOT \ .HTC key during uninstall. This 
    breaks the ControlPanel -> Add/Remove programs
   
 Notes:

    This is specific to this app.

 History:

    11/17/2000 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Canvas6)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegOpenKeyA) 
    APIHOOK_ENUM_ENTRY(RegCloseKey) 
    APIHOOK_ENUM_ENTRY(RegDeleteKeyA) 
APIHOOK_ENUM_END

HKEY g_hOpenKey = 0;

/*++

 Store the key for .htc

--*/

LONG
APIHOOK(RegOpenKeyA)(
    HKEY hkey,
    LPCSTR lpSubKey,
    PHKEY phkResult)
{
    LONG lRet = 0;

    lRet = ORIGINAL_API(RegOpenKeyA)(hkey,lpSubKey,phkResult);

    if ((hkey == HKEY_CLASSES_ROOT)
        && lpSubKey 
        && (lstrcmpiA((const char*) lpSubKey,".htc") == 0))
    {
        if (phkResult)
        {
            g_hOpenKey = *(phkResult);
        }
    }
    
    return lRet;
}

/*++

 Ignore the close if required.

--*/

LONG
APIHOOK(RegCloseKey)(
    HKEY hkey)
{
    if (g_hOpenKey && (g_hOpenKey == hkey))
    {
        return ERROR_SUCCESS;
    }
    else
    {
        return (ORIGINAL_API(RegCloseKey)(hkey));
    }
}

/*++

 Ignore the delete.

--*/

LONG
APIHOOK(RegDeleteKeyA)(
    HKEY hkey,
    LPCSTR lpSubKey)
{
    LONG lRet = 0;

    if ((hkey == HKEY_CLASSES_ROOT)
        && lpSubKey 
        && (lstrcmpiA((const char*)lpSubKey,".htc") == 0))
    {
        if (g_hOpenKey)
        {
            if(RegDeleteValueA(g_hOpenKey,NULL))
            {
                // Add DPF to indicate an error during deletion of the value installed by the app.
                   DPFN( eDbgLevelError,
                            "Could not delete the value in the key= \"%s\".", lpSubKey);
            }
            RegCloseKey(g_hOpenKey);
            g_hOpenKey = 0;
        }
        lRet = ERROR_SUCCESS;
    }
    else
    {
        lRet = ORIGINAL_API(RegDeleteKeyA)(hkey,lpSubKey);
    }  

    return lRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCloseKey)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\boeingfix.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    BoeingFix.cpp

 Abstract:

    This modified version of kernel32!CreateFile* adds the 
    FILE_FLAG_NO_BUFFERING flag if the app is openning a specific name that is 
    a UNIX pipe advertised as a file.

 Notes:

    This is an app specific shim.

 History:
 
    10/16/2000 garretb  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BoeingFix)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
APIHOOK_ENUM_END

static const WCHAR g_lpszPipeName[] = L"msg_in\\message.pip";
static const int   g_lpszPipeNameLen = (sizeof(g_lpszPipeName) / sizeof(g_lpszPipeName[0])) - sizeof(g_lpszPipeName[0]);


// Return FILE_FLAG_NO_BUFFERING if this filename is the special pipe.
DWORD NoBufferFlag(const CString & csFileName)
{
    if (csFileName.GetLength() >= g_lpszPipeNameLen)
    {
        CString csRight;
        csFileName.Right(g_lpszPipeNameLen, csRight);
        if (csRight.CompareNoCase(g_lpszPipeName))
        {
            return FILE_FLAG_NO_BUFFERING;
        }
    }

    return 0;
}


/*++

 Conditionally add FILE_FLAG_NO_BUFFERING

--*/

HANDLE
APIHOOK(CreateFileA)(
    LPSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    CString csFileName(lpFileName);
    dwFlagsAndAttributes |= NoBufferFlag(csFileName);

    return ORIGINAL_API(CreateFileA)(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);
}

/*++

    Conditionally add FILE_FLAG_NO_BUFFERING

--*/

HANDLE
APIHOOK(CreateFileW)(
    LPWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    CString csFileName(lpFileName);
    dwFlagsAndAttributes |= NoBufferFlag(csFileName);

    return ORIGINAL_API(CreateFileW)(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\canvascheckedbuttons.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   FakeThemeMetrics.cpp

 Abstract:

  This Shim will allow the Skemers group to shim applications that do not behave 
  well with "Themed" system metrics

 History:

  11/30/2000 a-brienw Converted to shim frame work version 2.

--*/

#include "precomp.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    sizeof(x)/sizeof((x)[0])
#endif

IMPLEMENT_SHIM_BEGIN(CanvasCheckedButtons)
#include "ShimHookMacro.h"

// Add APIs that you wish to hook to this enumeration. The first one
// must have "= USERAPIHOOKSTART", and the last one must be
// APIHOOK_Count.
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetSysColor) 
APIHOOK_ENUM_END

#define CLRMAX(x) {if (x > 227) x = 227;}
DWORD APIHOOK(GetSysColor)(int nIndex)
{
    if (nIndex == COLOR_BTNFACE)
    {
        COLORREF crOld = (COLORREF)ORIGINAL_API(GetSysColor)(nIndex);
        BYTE r = GetRValue(crOld);
        BYTE g = GetGValue(crOld);
        BYTE b = GetBValue(crOld);

        CLRMAX(r);
        CLRMAX(g);
        CLRMAX(b);

        return RGB(r,g,b);
    }

    return ORIGINAL_API(GetSysColor)(nIndex);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, GetSysColor)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\casper.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Casper.cpp

 Abstract:

    Casper copies a LNK file into %windir%\desktop.  This file is hardcoded to 
    point to c:\program files. The EXE that actually places the file into the 
    wrong place is 16-bit, so we cannot use CorrectFilePaths to fix the problem.  
    We hook IPersistFile::Save to accomplish the fixup of the incorrect link, 
    IPersistFile::Save is not modified in any way.

    App uses some 16-bit stuff when showing the intro video (see #200495) which 
    we have yet to fix (probably will never fix). After it calls CreateWindowEx
    to create the "Full-screen animation" window it assigns the return value
    to a variable. Later on the app plays videos in SmackWin windows. And it 
    checks this var to see if it's 0 - if it is, it calls DestroyWindow on the 
    SmackWin window. Now if the intro video were shown successfully it would 
    have set this var to 0 when the video exits but since in this case the 
    video is not shown, the variable still has the value equal to the 
    "Full-screen animation" window handle. We fix this by setting the return
    value of the "Full-screen animation" window creation to 0.

 History:

    1/21/1999    robkenny
    03/15/2000   robkenny   converted to use the CorrectPathChangesAllUser class
    11/07/2000   maonis     added hooks for CreateWindowExA and SetFocus (this is 
                            for the actual casper.exe)
    01/04/2001   maonis     tester found more problem with the smackwin windows. 
                            rewrote the fix to fix all of them.

--*/

#include "precomp.h"
#include "ClassCFP.h"

IMPLEMENT_SHIM_BEGIN(Casper)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateDialogParamA)
    APIHOOK_ENUM_ENTRY(CreateWindowExA)
APIHOOK_ENUM_END

/*++

 We return 0 when creating the "Full-screen animation" window.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,      // extended window style
    LPCSTR lpClassName,  // registered class name
    LPCSTR lpWindowName, // window name
    DWORD dwStyle,        // window style
    int x,                // horizontal position of window
    int y,                // vertical position of window
    int nWidth,           // window width
    int nHeight,          // window height
    HWND hWndParent,      // handle to parent or owner window
    HMENU hMenu,          // menu handle or child identifier
    HINSTANCE hInstance,  // handle to application instance
    LPVOID lpParam        // window-creation data
    )
{
    HWND hWnd = ORIGINAL_API(CreateWindowExA)(
        dwExStyle, 
        lpClassName, 
        lpWindowName, 
        dwStyle, 
        x, 
        y, 
        nWidth, 
        nHeight, 
        hWndParent, 
        hMenu, 
        hInstance,
        lpParam);

    if (lpWindowName)
    {
        CSTRING_TRY
        {
            CString csWindowName(lpWindowName);
            if (csWindowName.Compare(L"Full-screen animation") == 0)
            {
                hWnd = 0;
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return hWnd;
}

/*++

 Our path changing class.  We want to convert paths to All User

--*/

CorrectPathChangesAllUser * g_PathCorrector    = NULL;

static bool g_bLinkCorrected = false;

/*++

 Return a pointer to the PathCorrecting object

--*/

inline CorrectPathChangesBase * GetPathcorrecter()
{
    if (g_PathCorrector == NULL)
    {
        // Create our correct file path object
        g_PathCorrector = new CorrectPathChangesAllUser;
        g_PathCorrector->AddPathChangeW(L"\\MsM\\", L"\\MorningStar\\" );
    }

    return g_PathCorrector;
}

/*++

 Call CorrectPathAllocA and print a debug message if the two strings differ

--*/

WCHAR * CorrectPathAllocDebugW(const WCHAR * uncorrect, const char * debugMsg)
{
    if (uncorrect == NULL)
        return NULL;

    WCHAR * strCorrectFile = GetPathcorrecter()->CorrectPathAllocW(uncorrect);

    if (strCorrectFile && uncorrect && _wcsicmp(strCorrectFile, uncorrect) != 0)
    {
        DPFN( eDbgLevelInfo, "%s corrected path:\n    %S\n    %S\n",
            debugMsg, uncorrect, strCorrectFile);
    }
    else // Massive Spew:
    {
        DPFN( eDbgLevelSpew, "%s unchanged %S\n", debugMsg, uncorrect);
    }

    return strCorrectFile;
}

/*++

 Casper *copies* a link to %windir%\Desktop; it contains hardcoded paths to incorrect places.
 Move the link to the proper desktop directory.
 Correct the Path, Working Directory, and Icon values--all which are wrong.

--*/

void CorrectCasperLink()
{
    if (!g_bLinkCorrected)
    {
        // The path to the incorrect desktop link
        WCHAR * lpIncorrectCasperPath = GetPathcorrecter()->ExpandEnvironmentValueW(L"%windir%\\Desktop\\casper.lnk");

        // Correct the bad desktop link path
        WCHAR * lpCorrectCasperPath = GetPathcorrecter()->CorrectPathAllocW(lpIncorrectCasperPath);

        DPFN( eDbgLevelInfo, "CorrectCasperLink MoveFileW(%S, %S)\n", lpIncorrectCasperPath, lpCorrectCasperPath);
        // Move the file to the correct location.
        MoveFileW(lpIncorrectCasperPath, lpCorrectCasperPath);

        // All finished with the bad path, I never want to see it again.
        free(lpIncorrectCasperPath);

        HRESULT hres = CoInitialize(NULL);
        if (SUCCEEDED(hres))
        {
            // Get a pointer to the IShellLink interface.
            IShellLinkW *psl;
            hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLinkW, (void **)&psl);
            if (SUCCEEDED(hres))
            {
                // Get a pointer to the IPersistFile interface.
                IPersistFile *ppf;
                hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);

                if (SUCCEEDED(hres))
                {
                    // Load the shortcut.
                    hres = ppf->Load(lpCorrectCasperPath, STGM_READ);
                    if (SUCCEEDED(hres))
                    {
                        // We have successfully loaded the link
                        g_bLinkCorrected = true;

                        DPFN( eDbgLevelInfo, "CorrectCasperLink %S\n", lpCorrectCasperPath);

                        // Correct the path to the shortcut target.
                        WCHAR szBadPath[MAX_PATH];
                        WCHAR * szCorrectPath;

                        WIN32_FIND_DATAW wfd;
                        hres = psl->GetPath(szBadPath, MAX_PATH, &wfd, SLGP_UNCPRIORITY);
                        if (SUCCEEDED(hres))
                        {
                            szCorrectPath = CorrectPathAllocDebugW(szBadPath, "CorrectCasperLink, SetPath");
                            psl->SetPath(szCorrectPath);
                            free(szCorrectPath);
                        }

                        // Correct the working directory
                        hres = psl->GetWorkingDirectory(szBadPath, MAX_PATH);
                        if (SUCCEEDED(hres))
                        {
                            szCorrectPath = CorrectPathAllocDebugW(szBadPath, "CorrectCasperLink, SetWorkingDirectory");
                            psl->SetWorkingDirectory(szCorrectPath);
                            free(szCorrectPath);
                        }

                        // Correct the icon
                        int iIcon;
                        hres = psl->GetIconLocation(szBadPath, MAX_PATH, &iIcon);
                        if (SUCCEEDED(hres))
                        {
                            szCorrectPath = CorrectPathAllocDebugW(szBadPath, "CorrectCasperLink, SetIconLocation");
                            psl->SetIconLocation(szCorrectPath, iIcon);
                            free(szCorrectPath);
                        }

                        // Save the shortcut.
                        ppf->Save(NULL, TRUE);
                    }
                }
                // Release the pointer to IShellLink.
                ppf->Release();
            }
            // Release the pointer to IPersistFile.
            psl->Release();
        }
        CoUninitialize();
        free(lpCorrectCasperPath);
    }
}

/*++

  Do nothing to the CreateDialogParamA call, just an opportunity to correct the casper link

--*/

HWND 
APIHOOK(CreateDialogParamA)(
  HINSTANCE hInstance,     // handle to module
  LPCSTR lpTemplateName,  // dialog box template
  HWND hWndParent,         // handle to owner window
  DLGPROC lpDialogFunc,    // dialog box procedure
  LPARAM dwInitParam       // initialization value
)
{
    CorrectCasperLink();

    HWND returnValue = ORIGINAL_API(CreateDialogParamA)(
        hInstance, 
        lpTemplateName, 
        hWndParent, 
        lpDialogFunc, 
        dwInitParam);

    return returnValue;
}

/*++

  Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\chollian2000plus.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Chollian2000Plus.cpp

 Abstract:

    The app has a binary logon.ocx which uses sub-classed editbox as password 
    editbox. It does not hook all messages (whistler seems has more message 
    than win2k's), so when the mouse drags through it, the password typed will 
    be shown as plain text, the fix is to apply ES_PASSWORD to this specific 
    EditBox.

 Notes: 
  
    This is an app specific shim.

 History:

    05/15/2001 xiaoz    Created

--*/

#include "precomp.h"
#include "psapi.h"

IMPLEMENT_SHIM_BEGIN(Chollian2000Plus)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateWindowExA) 
APIHOOK_ENUM_END

/*++

 Correct Window Style if Necessary

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle, 
    LPCSTR lpClassName, 
    LPCSTR lpWindowName, 
    DWORD dwStyle, 
    int x, 
    int y, 
    int nWidth, 
    int nHeight, 
    HWND hWndParent, 
    HMENU hMenu, 
    HINSTANCE hInstance, 
    LPVOID lpParam 
    )
{
    WCHAR szBaseName[MAX_PATH];
    CString cstrClassname;
    CString cstrBaseName;


    
    // If dwExStyle is not zero, goto original call
    if (dwExStyle)
    {
        goto Original;
    }

    // If dwStyle is not 0x50010000, goto original call
    if (0x50010000 != dwStyle)
    {
        goto Original;
    }

    if (!GetModuleBaseName(GetCurrentProcess(), hInstance, szBaseName, MAX_PATH))
    {
        goto Original;
    }
    
    // If the call is not from login.ocx ,goto original call
    cstrBaseName = szBaseName;
    if (cstrBaseName.CompareNoCase(L"login.ocx"))
    {
        goto Original;
    }

    // If it's not an EditBox , goto original call
    cstrClassname = lpClassName;
    if (cstrClassname.CompareNoCase(L"Edit"))
    {
        goto Original;
    }

    // If it has window's name , goto original call
    if (lpWindowName)
    {
        goto Original;
    }

    
    
    LOGN(eDbgLevelWarning, "Window style corrected");
    dwStyle = dwStyle | 0x0020;

Original:

    return ORIGINAL_API(CreateWindowExA)(dwExStyle, lpClassName, lpWindowName, 
        dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)        

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\chemoffice.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    ChemOffice.cpp

 Abstract:

    This shim fixes a problem where a dialog box comes up after
    selecting Gaussian Run.  The dialog box warns of a windows
    error that only occurs because we are shim'ing the app with
    EmulateHeap.  We are unable to remove EmulateHeap since this
    causes the app to AV so the only solution at this time is to
    ignore the invalid paramater windows error message that occurs.

  Notes:

    This is a specific shim.

 History:

    03/06/2001  mnikkel  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ChemOffice)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetLastError) 
APIHOOK_ENUM_END

/*++

 Hook GetLastError 

--*/

DWORD 
APIHOOK(GetLastError)(VOID)
{
    DWORD dwResult;

    dwResult = ORIGINAL_API(GetLastError)();

    if ( dwResult == ERROR_INVALID_PARAMETER )
        dwResult = 0;

    return dwResult;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetLastError)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\coffeecuphtmleditor.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CoffeeCupHTMLEditor.cpp

 Abstract:

    This app implicitly loads a DLL whose linkage is not found and the loader 
    comes up with a message box.

 Notes:

    This is specific to this app.

 History:

    11/21/2000 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CoffeeCupHTMLEditor)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END

/*++

 This function hooks CreateProcessA and checks the COMMAND_LINE. If the commandline has 
 %systemdir%\lftif90n.dll.

--*/

BOOL
APIHOOK(CreateProcessA)(    
    LPCSTR lpApplicationName,                  // name of executable module
    LPSTR lpCommandLine,                       // command line string
    LPSECURITY_ATTRIBUTES lpProcessAttributes, // SD
    LPSECURITY_ATTRIBUTES lpThreadAttributes,  // SD
    BOOL bInheritHandles,                      // handle inheritance option
    DWORD dwCreationFlags,                     // creation flags
    LPVOID lpEnvironment,                      // new environment block
    LPCSTR lpCurrentDirectory,                 // current directory name
    LPSTARTUPINFOA lpStartupInfo,              // startup information
    LPPROCESS_INFORMATION lpProcessInformation // process information
    )
{
    CSTRING_TRY
    {
        CString csIgnoreDLL;
        csIgnoreDLL.GetSystemDirectoryW();
        csIgnoreDLL.AppendPath(L"lftif90n.dll");
        
        CString csCl(lpCommandLine);
        
        if (csCl.Find(csIgnoreDLL) >= 0)
        {
            return TRUE;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(CreateProcessA)(
            lpApplicationName,                 
            lpCommandLine,                     
            lpProcessAttributes, 
            lpThreadAttributes,  
            bInheritHandles,     
            dwCreationFlags,     
            lpEnvironment,       
            lpCurrentDirectory,  
            lpStartupInfo,       
            lpProcessInformation);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\commandos.cpp ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    Commandos.cpp

 Abstract:

    A hack for Commandos (EIDOS). The game caches a pointer to the ddraw
    primary surface. On NT, after a mode change, the memory can be mapped 
    into a different location - so when they try to write to it, it access
    violates.

    We know from debugging the app where they keep the cached pointer, so
    when they restore the surface, we relock it, and patch the new pointer 
    into their store.

 Notes:

    This is an app specific hack.

 History:

    10/29/1999 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Commandos)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

static LPVOID pLastPrimary = NULL;
static LPDWORD pAppPrimary = NULL;

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)( 
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw_CreateSurface pfnOld = ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Find out where they store the pointer.

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Lock)( 
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPRECT lpDestRect,
    LPDDSURFACEDESC lpDDSurfaceDesc,
    DWORD dwFlags,
    HANDLE hEvent
    )
{
    DDSURFACEDESC ddsd = {sizeof(ddsd)};
    HRESULT hReturn, hr;

    // Retrieve the old function
    _pfn_IDirectDrawSurface_Lock pfnOld = ORIGINAL_COM(IDirectDrawSurface, Lock, lpDDSurface);
        
    // Call the old API
    if (FAILED(hReturn = (*pfnOld)(
            lpDDSurface, 
            lpDestRect, 
            lpDDSurfaceDesc, 
            dwFlags, 
            hEvent)))
    {
        return hReturn;
    }

    // Make sure it's a primary
    hr = lpDDSurface->GetSurfaceDesc(&ddsd);
    if (SUCCEEDED(hr) && 
       (ddsd.ddsCaps.dwCaps & (DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)))
    {

        // We know:
        //   1. They cache the primary address in [esi+0x20]
        //   2. They lock the primary more than once 
        //
        // We assume:
        //   1. When they lock the primary, esi+0x20 is a valid pointer

        if ((pLastPrimary) && (!pAppPrimary))
        {
            __asm
            {
                pop edi
                pop esi
                mov eax,pLastPrimary
                
                cmp [esi+0x20],eax
                jne WrongESI

                // [esi+0x20] does contain the cached pointer

                lea eax,[esi+0x20]
                mov pAppPrimary,eax
            
            WrongESI:

                push esi
                push edi
            }
        }

        pLastPrimary = lpDDSurfaceDesc->lpSurface;
    }
    
    return hReturn;
}

/*++

 Patch the new pointer directly into their data segment. 

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Restore)( 
    LPDIRECTDRAWSURFACE lpDDSurface
    )
{
    DDSURFACEDESC ddsd = {sizeof(ddsd)};
    HRESULT hReturn, hr, hrt;
    
    // Retrieve the old function
    _pfn_IDirectDrawSurface_Restore pfnOld = ORIGINAL_COM(IDirectDrawSurface, Restore, lpDDSurface);

    // Call the old API
    if (FAILED(hReturn = (*pfnOld)(lpDDSurface)))
    {
        return hReturn;
    }

    // Make sure it's a primary
    hr = lpDDSurface->GetSurfaceDesc(&ddsd);
    if (SUCCEEDED(hr) && 
       (ddsd.ddsCaps.dwCaps & (DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)))
    {
        // Check if we've been set up
        if (!((pLastPrimary) && (pAppPrimary)))
        {
            return hReturn;
        }

        // We must get a pointer here, so keep trying  
        do
        {
            hr = lpDDSurface->Lock(
                NULL, 
                &ddsd, 
                DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, 
                NULL);

            if (hr == DDERR_SURFACELOST)
            {
                // Don't care about result
                (*pfnOld)(lpDDSurface);     
            }
        } while (hr == DDERR_SURFACELOST);

        // Patch the new pointer into their memory
        pLastPrimary = ddsd.lpSurface;
        if ((pLastPrimary) && (pAppPrimary))
        {
            *pAppPrimary = (DWORD_PTR)pLastPrimary;
        }

        // Unlock the surface
        lpDDSurface->Unlock(NULL);
    }

    return hReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Lock, 25)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Restore, 27)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\chollian2000.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   Chollian2000.cpp

 Abstract:

   The application has two problems.
   1. it is expecting metric value 1. it is ok in win9x and win2k but it's not the
       case in winXP.
   2. the application calls CreateIpForwardEntry with MIB_IPPROTO_LOCAL. 
       it will fail in winXP. the application should use MIB_IPPROTO_NETMGMT.
   The GetIpForwardTable and CreateIpForwardEntry are shimed to fix this problem.
   In GetIpForwardTable, I changed the metric value to 1. In CreateIpForwardEntry, 
   I changed MIB_IPPROTO_LOCAL to MIB_IPPROTO_NETMGMT.
   
 History:

    06/12/2001  zhongyl     Created

--*/

#include "precomp.h"
#include "iphlpapi.h"

IMPLEMENT_SHIM_BEGIN(Chollian2000)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateIpForwardEntry) 
    APIHOOK_ENUM_ENTRY(GetIpForwardTable) 
APIHOOK_ENUM_END


BOOL
APIHOOK(CreateIpForwardEntry)(
    PMIB_IPFORWARDROW pRoute
    )
{
        DWORD dwReturn;
        if (pRoute != NULL)
            pRoute->dwForwardProto = MIB_IPPROTO_NETMGMT;
            // The application used MIB_IPPROTO_LOCAL. It was ok for Win2k but it fails on WinXP. Change it to MIB_IPPROTO_NETMGMT
        dwReturn = ORIGINAL_API(CreateIpForwardEntry)(pRoute);
        return dwReturn;
}

BOOL
APIHOOK(GetIpForwardTable)(
    PMIB_IPFORWARDTABLE pIpForwardTable,
    PULONG pdwSize,
    BOOL bOrder
    )
{
        DWORD dwReturn;
        dwReturn = ORIGINAL_API(GetIpForwardTable)(pIpForwardTable, pdwSize, bOrder);
        if (pIpForwardTable != NULL)
            if (pIpForwardTable->dwNumEntries > 0)
                pIpForwardTable->table[0].dwForwardMetric1 = 1;
                // The application expects the Metric value to be one. In WinXP, the value is changed to 30. Application should not expect a fixed value here.
        return dwReturn;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    //
    // Add APIs that you wish to hook here. All API prototypes
    // must be declared in Hooks\inc\ShimProto.h. Compiler errors
    // will result if you forget to add them.
    //
    APIHOOK_ENTRY(iphlpapi.dll,GetIpForwardTable)
    APIHOOK_ENTRY(iphlpapi.dll,CreateIpForwardEntry)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\corelappsregistration.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    CorelAppsRegistration.cpp

 Abstract:


 Notes:

    This is an app specific shim.

 History:

    11/13/2001 prashkud     Created

--*/

#include "precomp.h"
IMPLEMENT_SHIM_BEGIN(CorelAppsRegistration)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShowWindow)
    APIHOOK_ENUM_ENTRY(CreateWindowExA)   
APIHOOK_ENUM_END

/*++

 Calls SetForegroundWindow directly after a ShowWindow call with SW_SHOW as
 the operation. The mouse_event call allows the SetForegroundWindow call to 
 succeed. This is a hack borrowed from the DirectX sources.

--*/

BOOL 
APIHOOK(ShowWindow)(
    HWND hWnd, 
    INT nCmdShow
    )
{
    BOOL bReturn;
 
    bReturn = ORIGINAL_API(ShowWindow)(hWnd, nCmdShow | SW_SHOW);

    mouse_event(MOUSEEVENTF_WHEEL, 0, 0, 0, 0);
    SetForegroundWindow(hWnd);
    LOGN( eDbgLevelWarning, 
          "Forcing to foreground.");

    return bReturn;
}

/*++

 Calls SetForegroundWindow directly after a CreateWindowEx call with 
 WS_VISIBLE as a style. The mouse_event call allows the
 SetForegroundWindow call to succeed. This is a hack borrowed from
 the DirectX sources.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,      
    LPCSTR lpClassName,  
    LPCSTR lpWindowName, 
    DWORD dwStyle,       
    int x,               
    int y,               
    int nWidth,          
    int nHeight,         
    HWND hWndParent,     
    HMENU hMenu,         
    HINSTANCE hInstance, 
    LPVOID lpParam       
    )
{
    HWND hReturn;

    dwStyle |= WS_VISIBLE;
    hReturn = ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,      
        lpWindowName,     
        dwStyle,          
        x,                
        y,                
        nWidth,           
        nHeight,          
        hWndParent,       
        hMenu,            
        hInstance,        
        lpParam);

   mouse_event(MOUSEEVENTF_WHEEL, 0, 0, 0, 0);
   SetForegroundWindow(hReturn);
   LOGN( eDbgLevelWarning, 
         "Forcing to foreground.");

    return hReturn;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, ShowWindow)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\cluefinders3rdgrade.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ClueFinders3rdGrade.cpp

 Abstract:

    This shim simulates the behaviour of Win9x wrt static controls and 
    Get/SetWindowText. Basically, Win9x stored the resource id for a static
    control in it's name. On NT, this isn't stored.

    We used to set a low-level window hook that catches the CreateWindow calls,
    but gave up because it kept regressing and it would be too expensive for 
    the layer.

 Notes:
    
    This is an app specific shim.

 History:

    06/19/2000 linstev  Created
    11/17/2000 linstev  Made app specific

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ClueFinders3rdGrade)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetWindowTextA) 
    APIHOOK_ENUM_ENTRY(SetWindowTextA)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA) 
APIHOOK_ENUM_END

typedef HMODULE (*_pfn_GetModuleHandleA)(LPCSTR lpModuleName);
 
//
// List of static handles
//

struct HWNDITEM
{
    HWND hWnd;
    DWORD dwRsrcId;
    HWNDITEM *next;
};
HWNDITEM *g_hWndList = NULL;

//
// Handle to use for CallNextHook
//

HHOOK g_hHookCbt = 0;

//
// Critical section for list access
//

CRITICAL_SECTION g_csList;

/*++

 Search the window list for a resource id if GetWindowTextA fails.

--*/

int 
APIHOOK(GetWindowTextA)(
    HWND hWnd,        
    LPSTR lpString,  
    int nMaxCount     
    )
{
    int iRet = ORIGINAL_API(GetWindowTextA)(
        hWnd,
        lpString,
        nMaxCount);

    if (iRet == 0) {
        //
        // Check for Resource Id
        //
    
        EnterCriticalSection(&g_csList);

        HWNDITEM *hitem = g_hWndList;
        while (hitem) {
            if (hitem->hWnd == hWnd) {
                //
                // Copy the resource id into the buffer
                //
                
                if ((hitem->dwRsrcId != (DWORD)-1) && (nMaxCount >= 3)) {
                    MoveMemory(lpString, (LPBYTE) &hitem->dwRsrcId + 1, 3);
                    iRet = 2;
                
                    DPFN( eDbgLevelError, "Returning ResourceId: %08lx for HWND=%08lx", *(LPDWORD)lpString, hWnd);
                }

                break;
            }
            hitem = hitem->next;
        }

        LeaveCriticalSection(&g_csList);
    }

    return iRet;
}
 
/*++

 Hook SetWindowText so the list is kept in sync.

--*/

BOOL 
APIHOOK(SetWindowTextA)(
    HWND hWnd,         
    LPCSTR lpString   
    )
{
    //
    // Set the text for this window if it's in our list
    //

    EnterCriticalSection(&g_csList);
    
    HWNDITEM *hitem = g_hWndList;
    while (hitem) {
        if (hitem->hWnd == hWnd) {
            if (lpString && (*(LPBYTE) lpString == 0xFF)) {
                hitem->dwRsrcId = *(LPDWORD) lpString;
            }

            break;
        }

        hitem = hitem->next;
    }
    
    LeaveCriticalSection(&g_csList);

    return ORIGINAL_API(SetWindowTextA)(hWnd, lpString);
}

/*++

 Hook to find CreateWindow calls and get the attached resource id.

--*/

LRESULT 
CALLBACK 
CBTProcW(
    int nCode,      
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    HWND hWnd = (HWND) wParam;
    LPCBT_CREATEWNDW pCbtWnd;

    switch (nCode) {
    case HCBT_CREATEWND:

        //
        // Add to our list of windows if it's a static - or we don't know 
        //
        
        pCbtWnd = (LPCBT_CREATEWNDW) lParam;

        if (pCbtWnd && pCbtWnd->lpcs && pCbtWnd->lpcs->lpszClass && 
            (IsBadReadPtr(pCbtWnd->lpcs->lpszClass, 4) || 
             (_wcsicmp(pCbtWnd->lpcs->lpszClass, L"static") == 0))) {
            HWNDITEM *hitem = (HWNDITEM *) malloc(sizeof(HWNDITEM));

            if (hitem) {
                hitem->hWnd = hWnd;

                //
                // Check for a resource id in the name
                //
                
                if (pCbtWnd->lpcs->lpszName && 
                    (*(LPBYTE) pCbtWnd->lpcs->lpszName == 0xFF)) {
                    hitem->dwRsrcId = *(LPDWORD) pCbtWnd->lpcs->lpszName;
                } else {
                    hitem->dwRsrcId = (DWORD)-1;
                }

                //
                // Update our list
                // 
                
                EnterCriticalSection(&g_csList);
                
                hitem->next = g_hWndList;
                g_hWndList = hitem;
       
                LeaveCriticalSection(&g_csList);

                DPFN( eDbgLevelError, "CreateWindow HWND=%08lx, ResourceId=%08lx", hitem->hWnd, hitem->dwRsrcId);
            } else {
                DPFN( eDbgLevelError, "Failed to allocate list item");
            }
        }
        
        break;

    case HCBT_DESTROYWND:
        
        //
        // Remove the window from our list
        //
        
        EnterCriticalSection(&g_csList);

        HWNDITEM *hitem = g_hWndList, *hprev = NULL;
        
        while (hitem) {
            if (hitem->hWnd == hWnd) {
                if (hprev) {
                    hprev->next = hitem->next;
                } else {
                    g_hWndList = hitem->next;
                }

                free(hitem);

                DPFN( eDbgLevelError, "DestroyWindow %08lx", hWnd);

                break;
            }
            hprev = hitem;
            hitem = hitem->next;
        }

        LeaveCriticalSection(&g_csList);

        break;
    }

    return CallNextHookEx(g_hHookCbt, nCode, wParam, lParam);
}

/*++

 Hook CreateDialog which is where the problem occurs

--*/

HWND
APIHOOK(CreateDialogIndirectParamA)(
    HINSTANCE hInstance,        
    LPCDLGTEMPLATE lpTemplate,  
    HWND hWndParent,            
    DLGPROC lpDialogFunc,       
    LPARAM lParamInit           
    )
{
    if (!g_hHookCbt) {
        g_hHookCbt = SetWindowsHookExW(WH_CBT, CBTProcW, GetModuleHandleW(0), 0);
        DPFN( eDbgLevelInfo, "[CreateDialogIndirectParamA] Hook added");
    }

    HWND hRet = ORIGINAL_API(CreateDialogIndirectParamA)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit);

    if (g_hHookCbt) {
        UnhookWindowsHookEx(g_hHookCbt);
        g_hHookCbt = 0;
    }

    return hRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Initialize our critical section here
        //
        
        InitializeCriticalSection(&g_csList);

    } else if (fdwReason == DLL_PROCESS_DETACH) {
        //
        // Clear the hook
        //

        if (g_hHookCbt) {
            UnhookWindowsHookEx(g_hHookCbt);
        }
    }


    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL, GetWindowTextA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowTextA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\comptonsbible.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ComptonsBible.cpp

 Abstract:
    
    This shim checks to see if Compton's Interactive Bible is calling DdeClientTransaction to create 
    a program group in the Start Menu for America Online.  If so, NULL is passed as pData to prevent 
    the application from doing anything with the program group, i.e. CreateGroup or ShowGroup. 
    
 Notes:

    This is an app specific shim.

 History:

    12/14/2000 jdoherty  Created

--*/

#include "precomp.h"
#include <ParseDde.h>

IMPLEMENT_SHIM_BEGIN(ComptonsBible)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DdeClientTransaction)
APIHOOK_ENUM_END

/*++

 Hook ShellExecuteA so we can check the return value.

--*/

HDDEDATA
APIHOOK(DdeClientTransaction)(
    IN LPBYTE pData,       // pointer to data to pass to server
    IN DWORD cbData,       // length of data
    IN HCONV hConv,        // handle to conversation
    IN HSZ hszItem,        // handle to item name string
    IN UINT wFmt,          // clipboard data format
    IN UINT wType,         // transaction type
    IN DWORD dwTimeout,    // time-out duration
    OUT LPDWORD pdwResult   // pointer to transaction result    
    )
{
    //
    //  Checking to see if pData contains America Online.
    //
    DPFN( eDbgLevelInfo, "[DdeClientTransaction] Checking pData parameter: %s, for calls including America Online.", pData);
    
    if (pData)
    {
        CSTRING_TRY
        {
            CString csData((LPSTR)pData);
            if (csData.Find(L"America Online") >= 0)
            {
                DPFN( eDbgLevelInfo, "[DdeClientTransaction] They are trying to create or show the "
                    "America Online Group calling DdeClientTransaction with NULL pData.");
                //
                //  The application is trying to create or show the America Online Group recalling API with 
                //  NULL as pData.
                //
                return ORIGINAL_API(DdeClientTransaction)(
                                 NULL,
                                 cbData,
                                 hConv, 
                                 hszItem, 
                                 wFmt,   
                                 wType,  
                                 dwTimeout,
                                 pdwResult
                                );
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return ORIGINAL_API(DdeClientTransaction)(
                         pData,
                         cbData,
                         hConv, 
                         hszItem, 
                         wFmt,   
                         wType,  
                         dwTimeout,
                         pdwResult
                        );
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, DdeClientTransaction)

HOOK_END
IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\coreldraw9jpn.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    CorelDraw9JPN.cpp

 Abstract:

    The App has some RTF files, seems the font and charset specified not correct 
    in it. When later on riched20 do ANSI-Unicode Code conversion, it used 
    English code-page. Fix this by checking the 1st parameter passed to 
    MultiByteToWideChar by richedit, if it's English, try to use CP_ACP, which 
    is always safe.

 Notes: 
  
    This is an app specific shim.

 History:

    05/10/2001 xiaoz    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorelDraw9JPN)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MultiByteToWideChar) 
APIHOOK_ENUM_END

/*++

 Correct the code page if required.

--*/

int
APIHOOK(MultiByteToWideChar)(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar
    )
{
    if (1252 == CodePage) {
        //
        // Change the code page
        //
        CodePage = CP_ACP;

        LOGN(eDbgLevelWarning, "Code page corrected");
    }

    return ORIGINAL_API(MultiByteToWideChar)(CodePage, dwFlags, lpMultiByteStr,
        cbMultiByte, lpWideCharStr, cchWideChar);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, MultiByteToWideChar)        

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\createresumesquickandeasy.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CreateResumesQuickandEasy.cpp

 Abstract:

    Hooks all application-defined window procedures and filters out an illegal
    OCM notification code which causes the application to beep annoyingly.

 Notes:


 History:

    03/22/2000 mnikkel  Created
    01/10/2001 mnikkel  Corrected to prevent a recursion problem.
    01/11/2001 mnikkel  Trimmed down to only necessary routines.

--*/

#include "precomp.h"
#include "olectl.h"

IMPLEMENT_SHIM_BEGIN(CreateResumesQuickandEasy)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA)
APIHOOK_ENUM_END

/*++
 Change OCM_NOTIFY behaviour
--*/

LRESULT CALLBACK 
CreateResumesQuickandEasy_WindowProcHook(
    WNDPROC pfnOld, // address of old WindowProc
    HWND hwnd,      // handle to window
    UINT uMsg,      // message identifier
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{

    if (uMsg == OCM_NOTIFY)
    {
        NMHDR *pNmhdr = (LPNMHDR) lParam;

        // For OCM Notification check for the illegal code and toss it
        // (App Create Resumes Quick and Easy)
        if (pNmhdr && pNmhdr->idFrom == 0 && pNmhdr->code == 0x704)
            return 0;
    }

    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}


/*++
 Hook all possible calls that can initialize or change a window's
 WindowProc (or DialogProc)
--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  // class data
    )
{
    WNDCLASSA wcNewWndClass = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, CreateResumesQuickandEasy_WindowProcHook);

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}


/*++
 Register hooked functions
--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA);
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\corelsitebuilder.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CorelSiteBuilder.cpp

 Abstract:

    App repeatedly calls SetWindowTextA with the same title causing 
    flickering. This repros on some machines and not others: we don't know why.

 Notes:

    This is an app specific shim.

 History:

    01/31/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorelSiteBuilder)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowTextA) 
APIHOOK_ENUM_END

HWND g_hLast = NULL;
CString * g_csLastWindowText = NULL;

CRITICAL_SECTION g_csGlobals;

/*++

 Only send the message if the text has changed.

--*/

BOOL
APIHOOK(SetWindowTextA)(
    HWND hWnd,         
    LPCSTR lpString   
    )
{
    EnterCriticalSection(&g_csGlobals);

    if (lpString)
    {
        CSTRING_TRY
        {
            CString csString(lpString);

            if ((g_hLast == hWnd) && g_csLastWindowText->Compare(csString) == 0) {
                //
                // We have the same window and title, don't bother setting it again
                //

                LeaveCriticalSection(&g_csGlobals);

                return TRUE;
            }

            //
            // Store the current settings as the last known values
            //
            g_hLast = hWnd;
            *g_csLastWindowText = csString;
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    LeaveCriticalSection(&g_csGlobals);

    return ORIGINAL_API(SetWindowTextA)(hWnd, lpString);
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        CSTRING_TRY
        {
            InitializeCriticalSection(&g_csGlobals);
            g_csLastWindowText = new CString;
            if (g_csLastWindowText == NULL)
            {
                return FALSE;
            }
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL, SetWindowTextA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\cossacks.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Cossacks.cpp

 Abstract:

    This is a workaround for a problem created by SafeDisc 2.0. The application 
    uses the WM_ACTIVATEAPP message to determine if it has focus or not. The 
    Safedisc wrapper prevents this message from hitting their main window on 
    NT, because it goes to the SafeDisc window before everything has been 
    unwrapped. So the app never thinks it has focus.

    The fix is to send an activate message after the window has been created.

 Notes:

    This is an app specific shim.

 History:

    06/16/2001 linstev   Created

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(Cossacks)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(mciSendCommandA) 
APIHOOK_ENUM_END

/*++

 Hook mciSendCommand and try to find the window we need to activate.

--*/

BOOL g_bFirst = TRUE;

MCIERROR 
APIHOOK(mciSendCommandA)(
    MCIDEVICEID IDDevice,  
    UINT uMsg,             
    DWORD fdwCommand,      
    DWORD dwParam          
    )
{
    if (g_bFirst) {
        //
        // Only need to hit this code once
        //
        HWND hWnd = FindWindowW(L"Kernel", L"Game");
        if (hWnd) {
            //
            // We've found the window, send the message
            //
            g_bFirst = FALSE;
            LOGN(eDbgLevelError, "Sent a WM_ACTIVATEAPP to the window");
            SendMessageW(hWnd, WM_ACTIVATEAPP, 1, 0);
        }
    }

    return ORIGINAL_API(mciSendCommandA)(IDDevice, uMsg, fdwCommand, dwParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(WINMM.DLL, mciSendCommandA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\crystalwebpageserver.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CrystalWebPageServer.cpp

 Abstract:

    The app calls GetEnhMetaFileHeader passing
    nSize of 1000. We need to change it to 100 to make the app not crash.
    If we don't do it this will cause memory corruption. Win9x seems to
    be fine with it. Maybe it will crash the app less often in Win9x than
    it does in Win2k.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CrystalWebPageServer)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetEnhMetaFileHeader)
APIHOOK_ENUM_END


/*++

    The app calls GetEnhMetaFileHeader passing
    nSize of 1000. We need to change it to 100 to make the app work

--*/

UINT
APIHOOK(GetEnhMetaFileHeader)(
    HENHMETAFILE    hemf,
    UINT            nSize,
    LPENHMETAHEADER lpEnhMetaHeader
    )
{
    if (nSize == 1000) {
        nSize = 100;
        
        DPFN(
            eDbgLevelInfo,
            "CrystalWebPageServer.dll, GetEnhMetaFileHeader: changed the size to 100.\n");
    }

    //
    // Call the original API
    //
    return ORIGINAL_API(GetEnhMetaFileHeader)(
                            hemf,
                            nSize,
                            lpEnhMetaHeader);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, GetEnhMetaFileHeader)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\creativeonscreendisplay.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    CreativeOnScreenDisplay.cpp

 Abstract:

    App crashes with low resolution display changes.

 Notes:
 
    This is an app specific shim.

 History:

    06/25/2002 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CreativeOnScreenDisplay)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA) 
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
APIHOOK_ENUM_END

/*++

 Handle display change messages

--*/

LRESULT 
CALLBACK 
Creative_WindowProcHook(
    WNDPROC pfnOld, 
    HWND hwnd,      
    UINT uMsg,      
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    if (uMsg == WM_DISPLAYCHANGE)
    {
        // Ignore this message if the resolution is too low
        if ((LOWORD(lParam) < 512) || (HIWORD(lParam) < 384))
        {
            LOGN(eDbgLevelError, "[WndProc] Hiding WM_DISPLAYCHANGE for low resolution mode");
            return 0;
        }
    }
        
    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  
    )
{
    WNDCLASSA wcNewWndClass = *lpWndClass;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, Creative_WindowProcHook);

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Creative_WindowProcHook);
    }

    return ORIGINAL_API(SetWindowLongA)(
        hWnd,
        nIndex,
        dwNewLong);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\cuseeme4.cpp ===
/*

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CUSeeMe4.cpp

 Abstract:

    This DLL fixes a profiles bug in CU-SeeMe Pro 4.0 setup where it only adds some certain
    Reg values to the per-user hive (HKCU) instead of putting them in HKLM.

    We don't actually hook any functions, instead, we just copy the regkeys after setup finishes
    when our process detach is called.

 Notes:

 History:

    08/07/2000  reinerf  Created
    11/29/2000  andyseti Renamed file from setup.cpp into CUSeeMe4.cpp.
                         Converted into AppSpecific shim.
*/

#include "precomp.h"


IMPLEMENT_SHIM_BEGIN(CUSeeMe4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_DETACH)
    {
        HKEY hkCU;
        HKEY hkLM;

        if ((RegOpenKeyExA(HKEY_CURRENT_USER,
                           "Software\\White Pine\\CU-SeeMe Pro\\4.0\\Installer",
                           0,
                           KEY_QUERY_VALUE,
                           &hkCU) == ERROR_SUCCESS))
        {
            if (RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                              "Software\\White Pine\\CU-SeeMe Pro\\4.0\\Installer",
                              0,
                              KEY_SET_VALUE,
                              &hkLM) == ERROR_SUCCESS)
            {
                // these are the values we want to migrate
                static char* aszValues[] = {"Folder",
                                            "Serial",
                                            "Help",
                                             0,
                                           };
                char** ppszValue = aszValues;

                LOGN( eDbgLevelError, 
                    "Copying values from 'HKCU\\Software\\White Pine\\CU-SeeMe Pro\\4.0\\Installer' into"
                    "'HKLM\\Software\\White Pine\\CU-SeeMe Pro\\4.0\\Installer'.");

                while (*ppszValue)
                {
                    DWORD dwType;
                    DWORD cbData;
                    char szData[MAX_PATH];

                    cbData = sizeof(szData);
                    if (RegQueryValueExA(hkCU,
                                         *ppszValue,
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&szData,
                                         &cbData) == ERROR_SUCCESS)
                    {
                        RegSetValueExA(hkLM, *ppszValue, 0, dwType, (LPBYTE)&szData, cbData);
                    }

                    // get the next value to migrate from hkcu -> hklm
                    ppszValue++;
                }
                
                RegCloseKey(hkLM);
            }
            
            RegCloseKey(hkCU);
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\descent2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Descent2.cpp

 Abstract:

    Hooks all application-defined window procedures and forcefully clears the 
    background to white. For some reason the EraseBackground that normally 
    comes through on win9x does not always work.

 Notes:

    This shim can be reused for other shims that need to forcefully clear the 
    background.

 History:

    03/28/2000 a-michni  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Descent2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA) 
    APIHOOK_ENUM_ENTRY(RegisterClassW) 
    APIHOOK_ENUM_ENTRY(RegisterClassExA) 
    APIHOOK_ENUM_ENTRY(RegisterClassExW) 
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
    APIHOOK_ENUM_ENTRY(SetWindowLongW) 
APIHOOK_ENUM_END

/*++

 Change WM_ERASEBKGND behaviour

--*/


LRESULT CALLBACK 
Descent2_WindowProcHook(
    WNDPROC pfnOld, // address of old WindowProc
    HWND hwnd,      // handle to window
    UINT uMsg,      // message identifier
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{
    HDC     hdc;
    RECT    rc;

    /* Retrieve the size info and fill with a standard White */
    switch( uMsg )
    {
        case WM_ERASEBKGND: 
            hdc = (HDC) wParam; 
            GetClientRect(hwnd, &rc); 
            SetMapMode(hdc, MM_ANISOTROPIC); 
            SetWindowExtEx(hdc, 100, 100, NULL); 
            SetViewportExtEx(hdc, rc.right, rc.bottom, NULL); 
            FillRect(hdc, &rc, (HBRUSH)GetStockObject(WHITE_BRUSH)); 
            break;

        default: break;
    }
    
    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}

INT_PTR CALLBACK 
Descent2_DialogProcHook(
    DLGPROC   pfnOld,   // address of old DialogProc
    HWND      hwndDlg,  // handle to dialog box
    UINT      uMsg,     // message
    WPARAM    wParam,   // first message parameter
    LPARAM    lParam    // second message parameter
    )
{
    return (*pfnOld)(hwndDlg, uMsg, wParam, lParam);    
}



ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  // class data
)
{
    WNDCLASSA   wcNewWndClass   = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, Descent2_WindowProcHook);

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassW)(
    CONST WNDCLASSW *lpWndClass  // class data
)
{
    WNDCLASSW   wcNewWndClass   = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, Descent2_WindowProcHook);

    return ORIGINAL_API(RegisterClassW)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  // class data
)
{
    WNDCLASSEXA   wcNewWndClass   = *lpwcx;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpwcx->lpfnWndProc, Descent2_WindowProcHook);

    return ORIGINAL_API(RegisterClassExA)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassExW)(
    CONST WNDCLASSEXW *lpwcx  // class data
)
{
    WNDCLASSEXW   wcNewWndClass   = *lpwcx;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpwcx->lpfnWndProc, Descent2_WindowProcHook);

    return ORIGINAL_API(RegisterClassExW)(&wcNewWndClass);
}

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if( nIndex == GWL_WNDPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Descent2_WindowProcHook);
    else if( nIndex == DWL_DLGPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Descent2_DialogProcHook);

    return ORIGINAL_API(SetWindowLongA)(hWnd, nIndex, dwNewLong );
}

LONG 
APIHOOK(SetWindowLongW)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if( nIndex == GWL_WNDPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Descent2_WindowProcHook);
    else if( nIndex == DWL_DLGPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Descent2_DialogProcHook);

    return ORIGINAL_API(SetWindowLongA)(hWnd, nIndex, dwNewLong );
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassW)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExW)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\dinosauractivitycenter.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    DinosaurActivityCenter.cpp

 Abstract:
    The app doesn't handle the WM_PAINT messages so when you drag the "Save As"
    dialog box, the main window doesn't redraw. 
    We fix this by capturing the static image of the main window into a 
    memory DC and blit from it when the WM_PAINT messages arrive (the 
    image under the dialog doesn't change).

 Notes:

    This is an app specific shim.

 History:

    09/21/2000 maonis  Created
    11/29/2000 andyseti Converted into AppSpecific shim.

--*/

#include "precomp.h"

static HWND g_hwndOwner;
static HDC g_hdcMemory;
static RECT g_rect;

IMPLEMENT_SHIM_BEGIN(DinosaurActivityCenter)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassExA) 
    APIHOOK_ENUM_ENTRY(GetSaveFileNameA) 
APIHOOK_ENUM_END

BOOL
APIHOOK(GetSaveFileNameA)(
    LPOPENFILENAMEA lpofn
    )
{
    BOOL fRet;

    HDC hdcWindow = NULL;
    HBITMAP hbmMemory = NULL;
    HBITMAP hbmOld = NULL;
    HWND hwndOwner = lpofn->hwndOwner;

    DPFN( eDbgLevelInfo, "GetSaveFileNameA called with hwnd = 0x%x.", hwndOwner);
    
    if (hdcWindow = GetDC(hwndOwner))
    {
        if ((g_hdcMemory = CreateCompatibleDC(hdcWindow)) &&
            GetWindowRect(hwndOwner, &g_rect) &&
            (hbmMemory = CreateCompatibleBitmap(hdcWindow, g_rect.right, g_rect.bottom)) &&
            (hbmOld = (HBITMAP)SelectObject(g_hdcMemory, hbmMemory)) &&
            BitBlt(g_hdcMemory, 0, 0, g_rect.right, g_rect.bottom, hdcWindow, 0, 0, SRCCOPY))
        {
            g_hwndOwner = hwndOwner;
        }
        else
        {
            DPFN( eDbgLevelError, "GetSaveFileName(hwnd = 0x%x): Error creating bitmap", hwndOwner);
        }

        ReleaseDC(hwndOwner, hdcWindow);
    }
    
    fRet = ORIGINAL_API(GetSaveFileNameA)(lpofn);

    g_hwndOwner = NULL;

    if (g_hdcMemory)
    {
        if (hbmMemory)
        {
            if (hbmOld)
            {
                SelectObject(g_hdcMemory, hbmOld);
            }

            DeleteObject(hbmMemory);
        }
        
        DeleteDC(g_hdcMemory);
    }

    return fRet;
}

/*++

 Validate after paint and filter syskey messages.

--*/

LRESULT 
CALLBACK 
DinosaurActivityCenter_WindowProcHook(
    WNDPROC pfnOld, 
    HWND hwnd,      
    UINT uMsg,      
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    if (hwnd == g_hwndOwner)
    {
        if (uMsg == WM_PAINT)
        {
            PAINTSTRUCT ps;
            HDC hdcWindow;
        
            if (hdcWindow = BeginPaint(hwnd, &ps))
            {
                BitBlt(hdcWindow, 0, 0, g_rect.right, g_rect.bottom, g_hdcMemory, 0, 0, SRCCOPY);

                EndPaint(hwnd, &ps);
            }
        
            LOGN( eDbgLevelError, "hwnd = 0x%x: Paint to the screen", hwnd);
        }
    }

    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  
    )
{
    CSTRING_TRY
    {
        CString csClassName(lpwcx->lpszClassName);
        if (csClassName.CompareNoCase(L"GAMEAPP") == 0)
        {
            WNDCLASSEXA wcNewWndClass = *lpwcx;

            wcNewWndClass.lpfnWndProc = 
                (WNDPROC) HookCallback(lpwcx->lpfnWndProc, DinosaurActivityCenter_WindowProcHook);

            return ORIGINAL_API(RegisterClassExA)(&wcNewWndClass);
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }
    return ORIGINAL_API(RegisterClassExA)(lpwcx);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA)
    APIHOOK_ENTRY(COMDLG32.DLL, GetSaveFileNameA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\dirttrackracing.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    DirtTrackRacing.cpp

 Abstract:
    
    App shows a white (or whatever your default window background color is) screen when starting up which is 
    inconsistent behavior from on 9x because on 9x it doesn't draw anything if the app's window class doesn't
    have a background brush. Use a black brush for the background.

 Notes:

    This is an app specific shim.

 History:

    10/01/2000 maonis   Created
    11/07/2000 maonis   Added checking for Dirt Track Racing Sprint Cars window class.
    11/29/2000 andyseti Converted into AppSpecific shim.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DirtTrackRacing)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA) 
    APIHOOK_ENUM_ENTRY(CreateWindowExA) 
APIHOOK_ENUM_END

/*++
 
   Register a black brush for the window class.

--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpwcx  
    )
{
    CSTRING_TRY
    {
        CString csClassName(lpwcx->lpszClassName);
        
        if ( !csClassName.CompareNoCase(L"DTR Class") || !csClassName.CompareNoCase(L"DTRSC Class"))
        {
            WNDCLASSA wcNewWndClass = *lpwcx;
            wcNewWndClass.hbrBackground = (HBRUSH) GetStockObject(BLACK_BRUSH);

            LOGN( 
                eDbgLevelError, 
                "RegisterClassA called. Register a black brush for the window class=%s.",
                lpwcx->lpszClassName);

            return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(RegisterClassA)(lpwcx);
}

/*++

 We need to hide the window at first so after you choose the mode and start the app it won't flicker.
 DDraw will automatically unhide the window.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,      
    LPCSTR lpClassName,  // registered class name
    LPCSTR lpWindowName, // window name
    DWORD dwStyle,        // window style
    int x,                // horizontal position of window
    int y,                // vertical position of window
    int nWidth,           // window width
    int nHeight,          // window height
    HWND hWndParent,      // handle to parent or owner window
    HMENU hMenu,          // menu handle or child identifier
    HINSTANCE hInstance,  // handle to application instance
    LPVOID lpParam        // window-creation data
    )
{
    CSTRING_TRY
    {
        CString csClassName(lpClassName);
        
        if ( !csClassName.CompareNoCase(L"DTR Class") || !csClassName.CompareNoCase(L"DTRSC Class"))
        {
            dwStyle &= ~WS_VISIBLE;
            LOGN( eDbgLevelError, 
                "CreateWindowExA called. Hide the window at first for the window class=%s.",
                lpClassName);
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(CreateWindowExA)(
        dwExStyle, 
        lpClassName, 
        lpWindowName, 
        dwStyle, 
        x, y, 
        nWidth, nHeight, 
        hWndParent, 
        hMenu, 
        hInstance, 
        lpParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\dominantspecies.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    DominantSpecies.cpp

 Abstract:

    See Force21 shim - almost exactly the same problem.

    DominantSpecies contains an invalid check code that looks like the following:

        mov  esi,A
        mov  eax,B
        sub  eax,esi
        cmp  eax,ebp
        jle  @@Loc
        mov  eax,ebp
    @@Loc:

    In a particular case: B=-1 and A<0x80000000 this jump will be incorrectly 
    taken. The reason this works on Win9x is that A>0x80000000 because it's a 
    memory mapped file. On NT, no user mode address can normally be >2GB.

    This shim patches the app with a 'cli' instruction so that it can perform 
    some logic when the exception gets hit. This is admittedly slow.

    Note we didn't use the in memory patching facility of the shim because we
    still needed logic. It didn't make sense to split the shim from the patch.

    Also, we can't have a general shim which makes all memory addresses high and 
    catches the fallout, because game performance suffers too much. 

 Notes:

    This is an app specific shim.

 History:

    06/30/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DominantSpecies)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END


/*++

 In memory patch the executable with a cli instruction. This patch works 
 for both the release version and a patch.

--*/

VOID
ExecutePatch()
{
    BYTE bPatchMatch[] = { 
        0x2b, 0xc6, 0x3b, 0xc5, 0x7c, 0x02, 0x8b, 0xc5, 0x85, 0xc0 };

    LPBYTE pPatchAddress[] = {
        (LPBYTE)0x53f543,       // the shipping version
        (LPBYTE)0x000000};      // placeholder for a vendor patch in case they get it wrong again
        
    BYTE bPatch = 0xFA;         // cli - to cause an exception

    //
    // Run through the patches and see which one matches
    //

    for (UINT j=0; j<sizeof(pPatchAddress)/sizeof(LPBYTE); j++)
    {
        LPBYTE pb = pPatchAddress[j];

        // Make sure it's an OK address.
        if (!IsBadReadPtr(pb, sizeof(bPatchMatch)))
        {
            // Check the bytes match
            for (UINT i=0; i < sizeof(bPatchMatch); i++)
            {
                if (*pb != bPatchMatch[i])
                {
                   break;
                }
                pb++;
            }

            // In memory patch
            if (i == sizeof(bPatchMatch))
            {
                DWORD dwOldProtect;
                if (VirtualProtect(
                      (PVOID)pPatchAddress[j],
                      1,
                      PAGE_READWRITE,
                      &dwOldProtect))
                {
                    *pPatchAddress[j] = bPatch;
                    LOGN(
                        eDbgLevelError,
                        "Successfully patched\n");
                    return;
                }
            }
        }
    }
}

/*++

 Handle the cli in such a way that the correct logic is performed.

--*/

LONG 
ExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    CONTEXT *lpContext = ExceptionInfo->ContextRecord;

    if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_PRIV_INSTRUCTION)
    {
        // Looks like we've hit our cli instruction

        if ((LONG)lpContext->Eax < 0)   // Boundary condition, EDI<0
        {
            // Jump past the invalid check
            lpContext->Eip = lpContext->Eip + 6;
        }
        else
        {
            // Replace the 'sub edi,eax' and continue
            lpContext->Eax = lpContext->Eax - lpContext->Esi; 
            lpContext->Eip = lpContext->Eip + 2;
        }
        return EXCEPTION_CONTINUE_EXECUTION;
    }

    return EXCEPTION_CONTINUE_SEARCH;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        ExecutePatch();

        // Try to find new exception handler
        _pfn_RtlAddVectoredExceptionHandler pfnExcept;
        pfnExcept = (_pfn_RtlAddVectoredExceptionHandler)
            GetProcAddress(
                GetModuleHandle(L"NTDLL.DLL"), 
                "RtlAddVectoredExceptionHandler");

        if (pfnExcept)
        {
            (_pfn_RtlAddVectoredExceptionHandler) pfnExcept(
                0, 
                (PVOID)ExceptionFilter);
        }
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\easycdcreator4.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EasyCDCreator4.cpp

 Abstract:

    Prevent the uninstall program from deleting the whole 
    HKCR\Drive\ShellEx\ContextMenuHandlers key.

 Notes:

    This is an app specific shim.

 History:

    06/10/2001 maonis   Created

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(EasyCDCreator4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegOpenKeyA) 
APIHOOK_ENUM_END

/*++

 Return failure to this call so it doesn't attempt to delete the subkeys.

--*/

LONG
APIHOOK(RegOpenKeyA)(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    if (hKey == HKEY_CLASSES_ROOT && !strcmp(lpSubKey, "Drive"))
    {
        // We delete the key that the app created manually.
        RegDeleteKeyA(
            HKEY_CLASSES_ROOT, 
            "Drive\\shellex\\ContextMenuHandlers\\{df987040-eac5-11cf-bc30-444553540000}");

        return 1;
    }
    else
    {
        return ORIGINAL_API(RegOpenKeyA)(hKey, lpSubKey, phkResult);
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\ea3dsetup.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    EA3dSetup.cpp

 Abstract:

    EA Sports titles use something called a "Thrash driver", which is just a 
    graphics wrapper library. They currently appear to have at least 2 types, 
    one for DX and one for Voodoo. The Voodoo version is not supported on NT,
    because it uses Glide.

    The fix is to modify the registry to prevent the voodoo driver from 
    being used. The DirectX fallback works fine.

 Notes:

    This is a application specific shim.

 History:

    01/29/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EA3dSetup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++
 
 Cleanup voodoo thrash drivers if they're there.

--*/

void CleanupVoodoo()
{
#define EA_SPORTS_KEY L"SOFTWARE\\EA SPORTS"
#define THRASH_DRIVER L"Thrash Driver"
#define VOODOOX       L"voodoo"
#define DIRECTX       L"dx"

    HKEY hKey;
    
    if (RegOpenKeyW(HKEY_LOCAL_MACHINE, EA_SPORTS_KEY, &hKey) == ERROR_SUCCESS) {
        //
        // At least 1 EA Sports title exists, so enumerate through them
        //

        for (int i=0;; i++) { 
            WCHAR wzSubKey[MAX_PATH];
            if (RegEnumKeyW(hKey, i, wzSubKey, MAX_PATH) == ERROR_SUCCESS) {
                //
                // Check the THRASH_DRIVER key for voodoo*
                //

                HKEY hSubKey;

                if (RegOpenKeyW(hKey, wzSubKey, &hSubKey) == ERROR_SUCCESS) {
                    //
                    // Set the value to "dx" if it's voodoo
                    //

                    LONG lRet;
                    DWORD dwType;
                    WCHAR wzValue[MAX_PATH] = L"\0";
                    DWORD dwLen = sizeof(wzValue);

                    lRet = RegQueryValueExW(hSubKey, THRASH_DRIVER, NULL, &dwType, 
                        (LPBYTE) wzValue, &dwLen);

                    if ((lRet == ERROR_SUCCESS) && (dwType == REG_SZ) &&
                        (_wcsnicmp(wzValue, VOODOOX, wcslen(VOODOOX)) == 0)) {

                            lRet = RegSetValueExW(hSubKey, THRASH_DRIVER, 0, REG_SZ, 
                                (LPBYTE) DIRECTX, wcslen(DIRECTX) * sizeof(WCHAR));

                            if (lRet == ERROR_SUCCESS) {
                                LOGN(eDbgLevelError, "Modified VOODOO Thrash driver to DX");
                            } else {
                                LOGN(eDbgLevelError, "Failed to set VOODOO Thrash driver to DX");
                            }
                    }

                    RegCloseKey(hSubKey);
                }
            } else {
                // Done
                break;
            }
        }

        RegCloseKey(hKey);
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_DETACH) {
        CleanupVoodoo();
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\dreye.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    DrEye.cpp

 Abstract:

    The App calls GetFocus Which returned NULL. This value was passed onto CWnd::FromHandle.
    CWnd::FromHandle returned NULL. App checked for this return value & threw AV.

    The fix is to return a valid handle when GetFocus is called.

 Notes:

    This is an app specific shim.

 History:

    01/07/2002 mamathas   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DrEye)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetFocus)
APIHOOK_ENUM_END

/*++

 Hook GetFocus and try to return a valid handle.

--*/

HWND
APIHOOK(GetFocus)()
{
       HWND hWnd = ORIGINAL_API(GetFocus)();

       if (hWnd) {
           return hWnd;
       }
       else {
           return GetDesktopWindow();
       }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, GetFocus)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\dongfangyingdu.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    DongFangYingDu.cpp

 Abstract:

    The app installs its own wmpui.dll (which I believe it is from Windows
    Media Play's 6.0) and then register it during installation and un-register
    it during un-installation. This makes WMP AV since this old DLL got loaded
    (through CoCreateInstance) the fix is make the app not bother to register / 
    unregister during the installation process.

 Notes: 
  
    This is an app specific shim.

 History:

    06/02/2001 xiaoz    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DongFangYingDu)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DllRegisterServer)
    APIHOOK_ENUM_ENTRY(DllUnregisterServer)
APIHOOK_ENUM_END

STDAPI 
APIHOOK(DllRegisterServer)(
    void
    )
{
    return S_OK;
}

STDAPI 
APIHOOK(DllUnregisterServer)(
    void
    )
{
    return S_OK;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(WMPUI.DLL, DllRegisterServer)
    APIHOOK_ENTRY(WMPUI.DLL, DllUnregisterServer)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\easycdcreator5.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    EasyCDCreator5.cpp

 Abstract:

    Clean up the filter drivers on the uninstaller on process termination.

 Notes:

    This is an app specific shim.

 History:

    08/09/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EasyCDCreator5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

BOOL 
StripStringFromValue(HKEY hKey, WCHAR *lpValue, WCHAR *lpStrip)
{
    DWORD dwType, dwSize;
    LONG lRet;
    BOOL bRet = FALSE;
    WCHAR *lpString = NULL, *lpNewString = NULL;
    WCHAR wzSystem[MAX_PATH];

    //
    // Build the %systemdir%\drivers\filename.sys to see if it's available
    //
    if (GetSystemDirectoryW(wzSystem, MAX_PATH) == 0) {
        DPFN(eDbgLevelError, "GetSystemDirectory failed");
        goto Exit;
    }
    wcscat(wzSystem, L"\\Drivers\\");
    wcscat(wzSystem, lpStrip);
    wcscat(wzSystem, L".sys");

    //
    // Check to see if the file exists - if it does, we don't touch the registry
    //
    if (GetFileAttributesW(wzSystem) != 0xFFFFFFFF) {
        DPFN(eDbgLevelError, "%S found so leave registry value alone", lpStrip);
        goto Exit;
    }

    //
    // Checking the registry for the bad state now
    //
    
    // Get the size
    if (ERROR_SUCCESS != RegQueryValueExW(hKey, lpValue, NULL, &dwType, NULL, &dwSize)) {
        DPFN(eDbgLevelError, "%S value not found", lpValue);
        goto Exit;
    }

    // Make sure it's a MULTI_STRING
    if (dwType != REG_MULTI_SZ) {
        DPFN(eDbgLevelError, "%S not correct type, expecting a multi-string", lpStrip);
        goto Exit;
    }

    // Allocate memory for it and clear it
    lpString = (WCHAR *) malloc(dwSize);
    if (!lpString) {
        DPFN(eDbgLevelError, "Out of memory");
        goto Exit;
    }
    ZeroMemory(lpString, dwSize);

    // Get the actual data
    if (ERROR_SUCCESS != RegQueryValueExW(hKey, lpValue, NULL, &dwType, (LPBYTE)lpString, &dwSize)) {
        DPFN(eDbgLevelError, "%S QueryValue failed unexpectedly", lpStrip);
        goto Exit;
    }

    // Allocate an output buffer
    lpNewString = (WCHAR *) malloc(dwSize);
    if (!lpNewString) {
        DPFN(eDbgLevelError, "Out of memory");
        goto Exit;
    }
    ZeroMemory(lpNewString, dwSize);

    // Run the input buffer looking for lpStrip
    WCHAR *lpCurr = lpString;
    WCHAR *lpCurrOut = lpNewString;
    BOOL bStripped = FALSE;
    while (*lpCurr) {
        if (_wcsicmp(lpCurr, lpStrip) != 0) {
            // Keep this entry
            wcscpy(lpCurrOut, lpCurr);
            lpCurrOut += wcslen(lpCurrOut) + 1;
        } else {
            // Remove this entry
            bStripped = TRUE;
        }

        lpCurr += wcslen(lpCurr) + 1;
    }

    if (bStripped) {
        //
        // Fix up the registry with the new value. If there's nothing left, then kill the 
        // value.
        // 
        LOGN(eDbgLevelError, "Removing filter driver - Value: %S, Name: %S", lpValue, lpStrip);

        dwSize = (lpCurrOut - lpNewString) * sizeof(WCHAR);
        if (dwSize == 0) {
            RegDeleteValueW(hKey, lpValue);
        } else {
            RegSetValueExW(hKey, lpValue, NULL, dwType, (LPBYTE) lpNewString, dwSize + sizeof(WCHAR));
        }
    }

    bRet = TRUE;

Exit:

    if (lpString) {
        free(lpString);
    }

    if (lpNewString) {
        free(lpNewString);
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(DWORD fdwReason)
{
   if (fdwReason == DLL_PROCESS_DETACH) {

       HKEY hKey;

       if (ERROR_SUCCESS == RegOpenKeyW(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E965-E325-11CE-BFC1-08002BE10318}", &hKey)) {

           StripStringFromValue(hKey, L"UpperFilters", L"Cdralw2k");
           StripStringFromValue(hKey, L"LowerFilters", L"Cdr4_2K");

           RegCloseKey(hKey);
       }
   }

   return TRUE;
}

HOOK_BEGIN

   CALL_NOTIFY_FUNCTION   

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\encartaencyclopediadeluxe2k.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:
    
    EncartaEncyclopediaDeluxe2K.cpp

 Abstract:

    This shim fixes a problem with Encarta Encyclopedia Deluxe 2000.

  Notes:

    This is an app specific shim.

 History:

    01/04/2001 a-brienw  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EncartaEncyclopediaDeluxe2K)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WinExec) 
APIHOOK_ENUM_END

/*++

 Hook WinExec to see if Encarta is calling for MSINFO32.
 If so then direct it to the version that comes with the OS.

--*/

UINT
APIHOOK(WinExec)(
  LPSTR lpCmdLine,   // command line
  UINT uCmdShow      // window style
  )
{
    CSTRING_TRY
    {
        CString csCmdLine(lpCmdLine);
        
        int nMsinfoIndex = csCmdLine.Find(L"MSINFO32.EXE");
        if (nMsinfoIndex)
        {
            CString csCmdLine;
            SHGetSpecialFolderPathW(csCmdLine, CSIDL_PROGRAM_FILES_COMMON);
            csCmdLine += L"\\Microsoft Shared\\MSInfo\\msinfo32.exe";

            // Test for existance of the corrected path of msinfo32.exe
            HANDLE hFile = CreateFileW(csCmdLine, GENERIC_READ, FILE_SHARE_READ, 
                NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
            if( hFile != INVALID_HANDLE_VALUE )
            {
                CloseHandle( hFile );

                return ORIGINAL_API(WinExec)(csCmdLine.GetAnsi(), uCmdShow); 
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(WinExec)(lpCmdLine, uCmdShow);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    
    APIHOOK_ENTRY(KERNEL32.DLL, WinExec)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\dongfangkuaiche3000setup.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    DongFangKuaiChe3000Setup.cpp

 Abstract:

    At the end of setup, the app is calling CreateProcessA with following 
        
        "rundll32.exe setupapi,InstallHinfSection DefaultInstall 132 \Z:\act\DongFangKuaiChe3000Pro\dfkc3000\MultiLanguage\Chinese\cn.inf"  
 
    there are altogether 4 calls to install Japanese/Chinese/Korean languagepack 
    (lagacy IE's langpack). The '\' before Z:\act\DongFang... is an extra one 
    and caused rundll32.exe fails in NT.

 Notes:

    This shim is to disable calls to install lagacy IE langpack, since NT has 
    already it's own.

 History:

    07/09/2001  xiaoz        Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DongFangKuaiChe3000Setup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END


BOOL
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,                  // name of executable module
    LPSTR  lpCommandLine,                      // command line string
    LPSECURITY_ATTRIBUTES lpProcessAttributes, // SD
    LPSECURITY_ATTRIBUTES lpThreadAttributes,  // SD
    BOOL bInheritHandles,                      // handle inheritance option
    DWORD dwCreationFlags,                     // creation flags
    LPVOID lpEnvironment,                      // new environment block
    LPCSTR lpCurrentDirectory,                 // current directory name
    LPSTARTUPINFOA lpStartupInfo,              // startup information
    LPPROCESS_INFORMATION lpProcessInformation // process information
    )
{
    CSTRING_TRY
    {
        CString cstrPattern = L"rundll32.exe setupapi,InstallHinfSection DefaultInstall 132 \\";
        CString cstrCmdLine(lpCommandLine);
        int nIndex;
    
        nIndex = cstrCmdLine.Find(cstrPattern);
    
        if ( nIndex >=0 )
        {
            return TRUE;
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return ORIGINAL_API(CreateProcessA)(lpApplicationName, lpCommandLine, 
        lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
        dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, 
        lpProcessInformation);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\encompassmonitor.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   EncompassMonitor.cpp  

 Abstract:

    Filters messages from the apps CBT WindowsHook.

 Notes:

    This is a general purpose shim. 
    
 History:

    1/30/2001 a-larrsh  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EncompassMonitor)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowsHookExA)
APIHOOK_ENUM_END


// Local Hook Information
HHOOK g_hCBTHook = NULL;
HOOKPROC g_OriginalEncompassMonitorCBTProc = NULL;

// Shared Data Infomation

#define SHARED_SECTION_NAME   "EncompassMonitor_SharedMemoryData"
typedef struct
{
   char     szModuleFileName[MAX_PATH];
   HANDLE   hModule;
   HOOKPROC pfnHookProc;

} SHARED_HOOK_INFO, *PSHARED_HOOK_INFO;

HANDLE g_hSharedMapping = NULL;
PSHARED_HOOK_INFO g_pSharedHookInfo = NULL;


// Creates Shared memory.  Only called by the originial SHIM
void CreateSharedMemory(HMODULE hModule, HOOKPROC pfnHookProc)
{
    HANDLE hSharedFile;
    char   szTempPath[MAX_PATH];
    char   szTempFileName[MAX_PATH];
    DWORD  dwTemp;

    // create the memory mapped file necessary to comunicate between the original Instanace of SHIM
    // and the following instances of SHIMS
    if (GetTempPathA(sizeof(szTempPath), szTempPath) == 0) 
    {
        DPFN( eDbgLevelError, "GetTempPath failed\n");
        goto errCreateSharedSection;
    }

    if (GetTempFileNameA(szTempPath, "mem", NULL, szTempFileName) == 0) 
    {
        DPFN( eDbgLevelError, "GetTempFileName failed\n");
        goto errCreateSharedSection;
    }

    hSharedFile = CreateFileA(   szTempFileName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
                                 NULL);

    if (hSharedFile == NULL) 
    {
        DPFN( eDbgLevelError, "CreateFile failed to create '%s'\n", szTempFileName);
        goto errCreateSharedSection;
    }

    // Increase size of file (create the mapping)
    g_hSharedMapping = CreateFileMappingA(   hSharedFile,
                                             NULL,
                                             PAGE_READWRITE,
                                             NULL,
                                             sizeof(SHARED_HOOK_INFO),
                                             SHARED_SECTION_NAME);

    if (g_hSharedMapping == NULL) 
    {
        DPFN( eDbgLevelError, "CreateFileMapping failed\n");
        goto errCreateSharedSection;
    }

    g_pSharedHookInfo = (PSHARED_HOOK_INFO)MapViewOfFile(g_hSharedMapping,
                                                         FILE_MAP_ALL_ACCESS,
                                                         0,
                                                         0,
                                                         sizeof(SHARED_HOOK_INFO));

    if (g_pSharedHookInfo == NULL) 
    {
       DWORD dwErr = GetLastError();
       DPFN( eDbgLevelError, "MapViewOfFile failed [%d]", (int)dwErr);
       goto errCreateSharedSection;
    }

    CloseHandle(hSharedFile);

    g_pSharedHookInfo->hModule = hModule;
    g_pSharedHookInfo->pfnHookProc = pfnHookProc;
    GetModuleFileNameA(hModule, g_pSharedHookInfo->szModuleFileName, MAX_PATH);    
    
    if (!FlushViewOfFile(g_pSharedHookInfo, sizeof(SHARED_HOOK_INFO))) 
    {
        DPFN( eDbgLevelError, "FlushViewOfFile failed\n");
        goto errCreateSharedSection;
    }

    DPFN( eDbgLevelInfo, "WRITE::Shared Section Successful");
    DPFN( eDbgLevelInfo, "WRITE::g_pSharedHookInfo->hModule=%x", g_pSharedHookInfo->hModule);    
    DPFN( eDbgLevelInfo, "WRITE::g_pSharedHookInfo->pfnHookProc=%x", g_pSharedHookInfo->pfnHookProc);    
    DPFN( eDbgLevelInfo, "WRITE::g_pSharedHookInfo->szModuleFileName=%s", g_pSharedHookInfo->szModuleFileName);    
    
    return;

errCreateSharedSection:
    DPFN( eDbgLevelError, "WRITE::Shared Section FAILED");
   return;
}

// Gets Shared Memory - Only called by injected versions of hook function
void GetSharedMemory()
{
   HANDLE hSharedFileMapping = NULL;
   void *pSharedMem = NULL;

   hSharedFileMapping = OpenFileMappingA( FILE_MAP_ALL_ACCESS,
                                         FALSE,
                                         SHARED_SECTION_NAME);   

   if (hSharedFileMapping != NULL) 
   {
      PSHARED_HOOK_INFO pSharedHookInfo = (PSHARED_HOOK_INFO)MapViewOfFile(  hSharedFileMapping,
                                                            FILE_MAP_ALL_ACCESS,
                                                            0,
                                                            0,
                                                            0);

      if (pSharedHookInfo)
      {      
         DPFN( eDbgLevelInfo, "READ::pSharedHookInfo->hModule=%x", pSharedHookInfo->hModule);    
         DPFN( eDbgLevelInfo, "READ::pSharedHookInfo->pfnHookProc=%x", pSharedHookInfo->pfnHookProc);    
         DPFN( eDbgLevelInfo, "READ::pSharedHookInfo->szModuleFileName=%s", pSharedHookInfo->szModuleFileName);    

         // Load DLL with origianl CBT Proc in it.
         HANDLE hMod = LoadLibraryA(pSharedHookInfo->szModuleFileName);

         if (!hMod)
         {
            DPFN( eDbgLevelError, "LoadLibrary(\"%s\") - FAILED", pSharedHookInfo->szModuleFileName);
         }

         g_OriginalEncompassMonitorCBTProc = (HOOKPROC)((DWORD)hMod + ((DWORD)pSharedHookInfo->pfnHookProc) - (DWORD)pSharedHookInfo->hModule);      
         DPFN( eDbgLevelInfo, "READ::Shared Section Successful - Original Hook at %x", g_OriginalEncompassMonitorCBTProc);

         CloseHandle(hSharedFileMapping);
         UnmapViewOfFile(pSharedHookInfo);
      }
      else
      {
         DPFN( eDbgLevelError, "MapViewOfFile() Failed");
      }
   }   
   else
   {
      DPFN( eDbgLevelError, "READ::Shared Section Failed");
   }
}

// Replacement CBT Hook function
LRESULT CALLBACK Filtered_EncompassMonitorCBTProc(
  int nCode,      // hook code
  WPARAM wParam,  // depends on hook code
  LPARAM lParam   // depends on hook code
)
{
   LRESULT lResult = 0; // Allow operation to continue
   bool bFilterMessage = false;   

   if(g_OriginalEncompassMonitorCBTProc == NULL)
   {
      GetSharedMemory();
   }

   if (nCode == HCBT_CREATEWND)
   {
      CBT_CREATEWNDA *pccw = (CBT_CREATEWNDA*)lParam;

      if ( (IS_INTRESOURCE(pccw->lpcs->lpszClass)) )
      {
         char szBuf[256];
         GetClassNameA((HWND)wParam, szBuf, 255);

         bFilterMessage=true;
         DPFN( eDbgLevelInfo, "[%x] - Filtered_EncompassMonitorCBTProc::HCBT_CREATEWND %s [ATOM CLASS FILTERED]", g_OriginalEncompassMonitorCBTProc, szBuf);
      }
      else
      {
         DPFN( eDbgLevelInfo, "[%x] - Filtered_EncompassMonitorCBTProc::HCBT_CREATEWND %s ", g_OriginalEncompassMonitorCBTProc, pccw->lpcs->lpszClass);
      }
   }

   if ( g_OriginalEncompassMonitorCBTProc )
   {
      if (bFilterMessage)
      {
         lResult = CallNextHookEx(g_hCBTHook, nCode, wParam, lParam);
      }
      else
      {
         lResult = g_OriginalEncompassMonitorCBTProc(nCode, wParam, lParam);      
      }
   }
   else
   {
      DPFN( eDbgLevelError, "Filtered_EncompassMonitorCBTProc:: ** BAD g_OriginalEncompassMonitorCBTProc2 **");

      lResult = CallNextHookEx(g_hCBTHook, nCode, wParam, lParam);      
   }

   return lResult;
}


// SHIMMED API
HHOOK APIHOOK(SetWindowsHookExA)(
  int idHook,        // hook type
  HOOKPROC lpfn,     // hook procedure
  HINSTANCE hMod,    // handle to application instance
  DWORD dwThreadId   // thread identifier
)
{ 
   static int nNumCBThooks = 0;
   
   HHOOK hHook;

   if (idHook == WH_CBT)
   {      
      nNumCBThooks++;

      switch(nNumCBThooks)
      {
      case 1:
         hHook = ORIGINAL_API(SetWindowsHookExA)(idHook, lpfn, hMod, dwThreadId);
         DPFN( eDbgLevelInfo, "%x=SetWindowsHookEx(%d, %x, %x, %x) - Ignoring First Hook Call", hHook, idHook, lpfn, hMod, dwThreadId);
         break;

      case 2:
         g_OriginalEncompassMonitorCBTProc = lpfn;
         g_hCBTHook = hHook = ORIGINAL_API(SetWindowsHookExA)(idHook, Filtered_EncompassMonitorCBTProc, g_hinstDll, dwThreadId);

         DPFN( eDbgLevelInfo, "%x=SetWindowsHookEx(%d, %x, %x, %x) - Replacing Hook with Filtered_EncompassMonitorCBTProc", hHook, idHook, lpfn, hMod, dwThreadId);

         CreateSharedMemory(hMod, lpfn);
         break;

      default:         
         hHook = ORIGINAL_API(SetWindowsHookExA)(idHook, lpfn, hMod, dwThreadId);
         DPFN( eDbgLevelError, "SetWindowsHookEx -- More then 2  WH_CBT hooks [%d]", nNumCBThooks);
         break;
      }
   }
   else
   {
      hHook = ORIGINAL_API(SetWindowsHookExA)(idHook, lpfn, hMod, dwThreadId);         
   }

   return hHook;
}


BOOL
NOTIFY_FUNCTION(DWORD fdwReason)
{
   if (fdwReason == DLL_PROCESS_DETACH)
   {
      if (g_hSharedMapping)
      {
         CloseHandle(g_hSharedMapping);
         g_hSharedMapping = NULL;
      }

      if (g_pSharedHookInfo)
      {
         UnmapViewOfFile(g_pSharedHookInfo);
         g_pSharedHookInfo = NULL;
      }
   }

   return TRUE;
}
   

/*++

 Register hooked functions

--*/

HOOK_BEGIN
   CALL_NOTIFY_FUNCTION   

   APIHOOK_ENTRY(USER32.DLL, SetWindowsHookExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\firefighters.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    FireFighters.cpp

 Abstract:

    This game stores the filenames it calls CreateFile on in a block of memory and
    occasionally it gets the offsets wrong and it's always off by 9 bytes.
    
 History:
        
    09/03/2000 maonis Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FireFighters)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
APIHOOK_ENUM_END


/*++

 Remove write attributes for read-only devices.

--*/

HANDLE 
APIHOOK(CreateFileA)(
    LPSTR                   lpFileName,
    DWORD                   dwDesiredAccess,
    DWORD                   dwShareMode,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    DWORD                   dwCreationDisposition,
    DWORD                   dwFlagsAndAttributes,
    HANDLE                  hTemplateFile
    )
{
    // if the 1st char is not '.' or an alphabetical char, we add 9 bytes to the filename pointer.
    char chFirst = *lpFileName;

    if (!isalpha(chFirst) && chFirst != '.')
    {
        lpFileName += 9;

        DPFN(
            eDbgLevelError,
            "[CreateFileA] filename is now %s", lpFileName);
    }

    HANDLE hRet = ORIGINAL_API(CreateFileA)(
                        lpFileName, 
                        dwDesiredAccess, 
                        dwShareMode, 
                        lpSecurityAttributes, 
                        dwCreationDisposition, 
                        dwFlagsAndAttributes, 
                        hTemplateFile);
    
    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\f18carrier.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    F18Carrier.cpp

 Abstract:

    This fixes 2 problems:
        
      1. In the Officers quarters, while reading the flight manual, pressing 
         escape minimizes the app. This happens on win9x as well, but since 
         the app does not recover well from task switching, we ignore the
         syskey messages that caused the switch.

      2. The dialogs are cleared after drawing by a paint message that goes to
         the parent window after the dialog is drawn. Since they use a 
         DirectDraw Blt to draw, they are not aware of that they're drawing 
         over the dialog. On win9x, this extra paint message does not come 
         through, but it's not clear why.

         We fix this by validating the drawing rect after after the paint 
         message has come through.

    The window handling of the app is really weird, they have 2 main windows
    at any one time and switch focus between them. Then they have Screen*.dll 
    files which each contain WndProcs which handle individual parts of the UI.

 Notes:

    This is an app specific shim.

 History:

    07/12/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(F18Carrier)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA) 
    APIHOOK_ENUM_ENTRY(RegisterClassW) 
    APIHOOK_ENUM_ENTRY(RegisterClassExA) 
    APIHOOK_ENUM_ENTRY(RegisterClassExW) 
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
    APIHOOK_ENUM_ENTRY(SetWindowLongW) 
APIHOOK_ENUM_END

/*++

 Validate after paint and filter syskey messages.

--*/

LRESULT 
CALLBACK 
F18Carrier_WindowProcHook(
    WNDPROC pfnOld, 
    HWND hwnd,      
    UINT uMsg,      
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    LRESULT lRet;
    RECT r;

    if ((uMsg == WM_PAINT) && (GetUpdateRect(hwnd, &r, FALSE)))
    {
        lRet = (*pfnOld)(hwnd, uMsg, wParam, lParam);    
    
        //
        // Only do this for certain window classes, to prevent side-effects
        //
        WCHAR szName[MAX_PATH];
        if (GetClassNameW(hwnd, szName, MAX_PATH))
        {
            if (!wcsistr(szName, L"UI Class")) 
            {
                return lRet;
            }
        }

        LOGN(
            eDbgLevelSpew,
            "Validating after paint");

        ValidateRect(hwnd, &r);
    }
    else if ((uMsg == WM_SYSKEYDOWN) || (uMsg == WM_SYSKEYUP))
    { 
        LOGN(
            eDbgLevelSpew,
            "Removing syskey messages");

        return 0;
    }
    else
    {
        lRet = (*pfnOld)(hwnd, uMsg, wParam, lParam);    
    }

    return lRet;
}

/*++

 The dialogproc hook

--*/

INT_PTR 
CALLBACK 
F18Carrier_DialogProcHook(
    DLGPROC   pfnOld,   
    HWND      hwndDlg,  
    UINT      uMsg,     
    WPARAM    wParam,   
    LPARAM    lParam    
    )
{
    return (*pfnOld)(hwndDlg, uMsg, wParam, lParam);    
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  
    )
{
    WNDCLASSA wcNewWndClass = *lpWndClass;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, F18Carrier_WindowProcHook);

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassW)(
    CONST WNDCLASSW *lpWndClass  
    )
{
    WNDCLASSW wcNewWndClass = *lpWndClass;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, F18Carrier_WindowProcHook);

    return ORIGINAL_API(RegisterClassW)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  
    )
{
    WNDCLASSEXA wcNewWndClass = *lpwcx;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpwcx->lpfnWndProc, F18Carrier_WindowProcHook);

    return ORIGINAL_API(RegisterClassExA)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassExW)(
    CONST WNDCLASSEXW *lpwcx  
    )
{
    WNDCLASSEXW wcNewWndClass = *lpwcx;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpwcx->lpfnWndProc, F18Carrier_WindowProcHook);

    return ORIGINAL_API(RegisterClassExW)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, F18Carrier_WindowProcHook);
    }
    else if (nIndex == DWL_DLGPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, F18Carrier_DialogProcHook);
    }

    return ORIGINAL_API(SetWindowLongA)(
        hWnd,
        nIndex,
        dwNewLong);
}

/*++

 Hook the wndproc

--*/

LONG 
APIHOOK(SetWindowLongW)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC)
    { 
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, F18Carrier_WindowProcHook);
    }
    else if (nIndex == DWL_DLGPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, F18Carrier_DialogProcHook);
    }

    return ORIGINAL_API(SetWindowLongA)(
        hWnd,
        nIndex,
        dwNewLong);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassW)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExW)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\exchangeserversetup.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ExchangeServerSetup.cpp

 Abstract:

    This is a non-reusable patch for Exchange Server Setup 5.5 for SP2 and SP3
    to change the parameters passed to xcopy. The reason for that is that
    Win2k's xcopy doesn't have the /y parameter a default parameter.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ExchangeServerSetup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessW)
APIHOOK_ENUM_END

/*++

 Change the parameters passed to xcopy.

--*/

BOOL
APIHOOK(CreateProcessW)(
    LPWSTR                lpApplicationName,
    LPWSTR                lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPWSTR                lpCurrentDirectory,
    LPSTARTUPINFOW        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    BOOL bRet;

    if (lpCommandLine != NULL) {

        int   cbSize = lstrlenW(lpCommandLine);
        WCHAR ch;

        if (cbSize > 12) {

            DPFN(
                eDbgLevelInfo,
                "[CreateProcessW] for \"%ws\".\n",
                lpCommandLine);

            ch = lpCommandLine[11];
            lpCommandLine[11] = 0;

            if (lstrcmpiW(lpCommandLine, L"xcopy /s /e") == 0) {

                lstrcpyW(lpCommandLine, L"xcopy /sye ");
                lpCommandLine[11] = ch;

                DPFN(
                    eDbgLevelInfo,
                    "[CreateProcessW] changed to \"%ws\".\n",
                    lpCommandLine);
                
            } else {
                lpCommandLine[11] = ch;
            }
        }
    }

    bRet = ORIGINAL_API(CreateProcessW)(
                            lpApplicationName,
                            lpCommandLine,
                            lpProcessAttributes,
                            lpThreadAttributes,
                            bInheritHandles,
                            dwCreationFlags,
                            lpEnvironment,
                            lpCurrentDirectory,
                            lpStartupInfo,
                            lpProcessInformation);
    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\gangsters.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Gangsters.cpp

 Abstract:

    This shim hooks FindFirstFileA and FindNextFileA to simulate the
    finding of files named "$$$$$$$$.$$$" 8 times in total.  Gangsters
    apparently changed the FAT on their CD to make it appear to Win9x
    as if there were 8 of these files on the CD.

    It also hooks mciSendCommand to return 10 as the number of tracks
    on the CD instead of 11.

 History:

 07/12/2000 t-adams    Created

--*/

#include "precomp.h"
#include <mmsystem.h>

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(Gangsters)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindNextFileA)
    APIHOOK_ENUM_ENTRY(mciSendCommandA)
APIHOOK_ENUM_END


int g_iTimesFound = 0;
HANDLE g_hIntercept = INVALID_HANDLE_VALUE;

/*++

  Abstract:
    Pass the FindFirstFile call through, but if it was trying to find a file
    named "$$$$$$$$.$$$" then remember the handle to be returned so that we
    can intercept subsequent attempts to find more files with the same name.

  History:

  07/12/2000    t-adams     Created

--*/

HANDLE APIHOOK(FindFirstFileA)(
            LPCSTR lpFileName,
            LPWIN32_FIND_DATAA lpFindFileData) {

    HANDLE hRval;

    hRval = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

    if( strcmp(&lpFileName[3], "$$$$$$$$.$$$") == 0 ) {
        DPFN( eDbgLevelSpew, "FindFirstFileA: Beginning spoof of \"$$$$$$$$.$$$\"");
        g_hIntercept = hRval;
        g_iTimesFound = 1;
    }

    return hRval;
}


/*++

  Abstract:
     If the handle is of the search that we are intercepting, then report
     that a match has been found up to eight times.  Don't bother changing
     lpFindFileData because Gangsters only checks for the existance of the
     files, not for any information about them.
       Otherwise, just pass the call through.

  History:
  
    07/12/2000  t-adams     Created

--*/

BOOL APIHOOK(FindNextFileA)(
            HANDLE hFindFile, 
            LPWIN32_FIND_DATAA lpFindFileData) {

    BOOL bRval;

    if( hFindFile == g_hIntercept ) {
        if( 8 == g_iTimesFound ) {
            SetLastError(ERROR_NO_MORE_FILES);
            bRval = FALSE;
        } else {
            g_iTimesFound++;
            DPFN( eDbgLevelSpew, "FindNextFileA: Spoofing \"$$$$$$$$.$$$\" occurrence %d", g_iTimesFound);
            bRval = TRUE;
        }
    } else {
        bRval = ORIGINAL_API(FindNextFileA)(hFindFile, lpFindFileData);
    }

    return bRval;
}


/*++

  Abstract:
    If the app is trying to find the number of tracks on the CD, return 10.
    Otherwise, pass through.

  History:
  
    07/13/2000  t-adams     Created

--*/

MCIERROR APIHOOK(mciSendCommandA)(
                MCIDEVICEID IDDevice, 
                UINT uMsg,             
                DWORD fdwCommand, 
                DWORD dwParam) {

    MCIERROR rval;
    
    rval = ORIGINAL_API(mciSendCommandA)(IDDevice, uMsg, fdwCommand, dwParam);

    if( uMsg==MCI_STATUS && fdwCommand==MCI_STATUS_ITEM && 
        ((LPMCI_STATUS_PARMS)dwParam)->dwItem==MCI_STATUS_NUMBER_OF_TRACKS) 
    {
        DPFN( eDbgLevelSpew, "MCI_STATUS_NUMBER_OF_TRACKS -> 10");
        ((LPMCI_STATUS_PARMS)dwParam)->dwReturn = 10;
    }

    return rval;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileA)
    APIHOOK_ENTRY(WINMM.DLL, mciSendCommandA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\europeanairwar.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EuropeanAirWar.cpp

 Abstract:
    
    European Air War takes advantage of the fact GDI and DDRAW affect separate 
    palettes in win98. This causes a problem on win2k when EAW calls
    GetSystemPaletteEntries and expects the original GDI palette, but in win2k 
    it has be faded to black by DDRAW.  This fix restores the system palette at
    a convienient spot in SetSystemPaletteUse.  It also sets SYSPAL_STATIC 
    before creating dialog boxes.

    In addition this corrects an install problem that occurs when setting the 
    path for the readme file in a start->programs shortcut.

 Notes:

    This is an app specific shim and should NOT be
    included in the layer.

 History:

    10/23/2000 linstev  Created
    10/23/2000 mnikkel  Modified

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EuropeanAirWar)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetSystemPaletteUse) 
    APIHOOK_ENUM_ENTRY(DialogBoxParamA)
    APIHOOK_ENUM_ENTRY_COMSERVER(SHELL32)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(SHELL32)

CString *   g_csArgBuffer = NULL;

/*++

 Retrieve the system palette and set the palette entries flag so the palette is 
 updated correctly.

--*/

UINT 
APIHOOK(SetSystemPaletteUse)(
    HDC hdc,      
    UINT uUsage   
    )
{
    UINT iRet = ORIGINAL_API(SetSystemPaletteUse)(hdc, uUsage);

    int i;
    HDC hdcnew;
    HPALETTE hpal, hpalold;
    LPLOGPALETTE plogpal;

    // Create a palette we can realize
    plogpal = (LPLOGPALETTE) malloc(sizeof(LOGPALETTE) + sizeof(PALETTEENTRY)*256);
    if ( plogpal )
    {
        LOGN( eDbgLevelError, "[EuropeanAirWar] APIHook_SetSystemPaletteUse reseting palette");

        plogpal->palVersion = 0x0300;
        plogpal->palNumEntries = 256;

        hdcnew = GetDC(0);

        GetSystemPaletteEntries(hdcnew, 0, 256, &plogpal->palPalEntry[0]);

        for (i=0; i<256; i++)
        { 
            plogpal->palPalEntry[i].peFlags = PC_RESERVED | PC_NOCOLLAPSE;
        }
        
        // Realize the palette
        hpal = CreatePalette(plogpal);
        hpalold = SelectPalette(hdcnew, hpal, FALSE);
        RealizePalette(hdcnew);
        SelectPalette(hdcnew, hpalold, FALSE);
        DeleteObject(hpal);

        ReleaseDC(0, hdcnew);

        free(plogpal);
    }
    else
    {
        LOGN( eDbgLevelError, "[EuropeanAirWar] APIHook_SetSystemPaletteUse failed to allocate memory");
    }

    return iRet;
}

/*++

 Set the Palette Use to static before creating a dialog box.

--*/

int 
APIHOOK(DialogBoxParamA)(
    HINSTANCE hInstance,  
    LPCSTR lpTemplateName,
    HWND hWndParent,      
    DLGPROC lpDialogFunc, 
    LPARAM dwInitParam    
    )
{
    int iRet;
    HDC hdc;

    LOGN( eDbgLevelError, "[EuropeanAirWar] APIHook_DialogBoxParamA setting palette static for dialog box");

    // Set the palette use to static to prevent
    // any color changes in the dialog box.
    if (hdc = GetDC(0))
    {
        SetSystemPaletteUse(hdc, SYSPAL_STATIC);
        ReleaseDC(0, hdc);
    }

    iRet = ORIGINAL_API(DialogBoxParamA)(
        hInstance,
        lpTemplateName,
        hWndParent,
        lpDialogFunc,
        dwInitParam);

    // Reset the palette use to NoStatic256
    // after dialog box has been displayed.
    // use 256 to prevent white dot artifacts.
    if (hdc = GetDC(0))
    {
        SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC256);
        ReleaseDC(0, hdc);
    }

    return iRet;
}

/*++

 Catch IShellLink::SetPathA and correct the wordpad path

--*/

HRESULT 
COMHOOK(IShellLinkA, SetPath)(
    PVOID pThis,
    LPCSTR pszFile 
    )
{
    HRESULT hrReturn = E_FAIL;
    PCHAR  pStr= NULL;
    CHAR   szBuffer[MAX_PATH];

    _pfn_IShellLinkA_SetPath pfnOld = ORIGINAL_COM(IShellLinkA, SetPath, pThis);

    if ( pfnOld )
    {
        CSTRING_TRY
        {
            // pszFile = "c:\windows\wordpad.exe command line arguments"
            // Strip off the arguments and save them for when they call IShellLinkA::SetArguments
            CString csFile(pszFile);

            int nWordpadIndex = csFile.Find(L"wordpad.exe");
            if (nWordpadIndex >= 0)
            {
                // Find the first space after wordpad.exe
                int nSpaceIndex = csFile.Find(L' ', nWordpadIndex);
                if (nSpaceIndex >= 0)
                {
                    // Save the cl args in g_csArgBuffer
                    g_csArgBuffer = new CString;
                    if (g_csArgBuffer)
                    {
                        csFile.Mid(nSpaceIndex, *g_csArgBuffer); // includes the space

                        csFile.Truncate(nSpaceIndex);
                    }
                }

                hrReturn = (*pfnOld)( pThis, csFile.GetAnsi() );
                return hrReturn;
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }

        hrReturn = (*pfnOld)( pThis, pszFile );
    }

    return hrReturn;
}


/*++

 Catch IShellLink::SetArguments and correct the readme path.

--*/

HRESULT 
COMHOOK(IShellLinkA, SetArguments)(
    PVOID pThis,
    LPCSTR pszArgs 
    )
{
    HRESULT hrReturn = E_FAIL;

    _pfn_IShellLinkA_SetArguments pfnOld = ORIGINAL_COM(IShellLinkA, SetArguments, pThis);
    if (pfnOld)
    {
        if (g_csArgBuffer && !g_csArgBuffer->IsEmpty())
        {
            CSTRING_TRY
            {
                CString csArgs(pszArgs);
                *g_csArgBuffer += L" ";
                *g_csArgBuffer += csArgs;

                hrReturn = (*pfnOld)( pThis, g_csArgBuffer->GetAnsi() );
                                
                // Delete the buffer so we don't add these args to everthing
                delete g_csArgBuffer;
                g_csArgBuffer = NULL;

                return hrReturn;
            }
            CSTRING_CATCH
            {
                // Do Nothing
            }
        }

        hrReturn = (*pfnOld)( pThis, pszArgs );
    }

    return hrReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(GDI32.DLL, SetSystemPaletteUse)
    APIHOOK_ENTRY(USER32.DLL, DialogBoxParamA)

    APIHOOK_ENTRY_COMSERVER(SHELL32)
    COMHOOK_ENTRY(ShellLink, IShellLinkA, SetPath, 20)
    COMHOOK_ENTRY(ShellLink, IShellLinkA, SetArguments, 11)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\gizmos.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Gizmos.cpp

 Abstract:

    The Shredder and Vault Explorer extensions both call
    SetWindowLong(GWL_STYLE) with improper style values.

 Notes:

    This is an app specific shim.

 History:

    04/12/2001  robkenny    Created

--*/

#include "precomp.h"
#include <shlguid.h>

IMPLEMENT_SHIM_BEGIN(Gizmos)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_COMSERVER(SHELLX98)
APIHOOK_ENUM_END


// This is the CLSID the application placed in the registry:
// c500687e 11ceab3b 00006884 6b2768b4

// Can't use the DEFINE_GUID macro, since INITGUID was not defined in the PCH.
//DEFINE_GUID(CLSID_Gizmos, 0xc500687d, 0xab3b, 0x11ce, 0x84, 0x68, 0x00, 0x00, 0xb4, 0x68, 0x27, 0x6b);
const GUID CLSID_Vault      = { 0xc500687d, 0xab3b, 0x11ce, { 0x84, 0x68, 0x00, 0x00, 0xb4, 0x68, 0x27, 0x6b } };
const GUID CLSID_Shredder   = { 0xc500687e, 0xab3b, 0x11ce, { 0x84, 0x68, 0x00, 0x00, 0xb4, 0x68, 0x27, 0x6b } };



typedef HRESULT     (*_pfn_IShellFolder_CreateViewObject)(PVOID pThis, HWND hwndOwner, REFIID riid, VOID **ppv);
typedef HRESULT     (*_pfn_IShellView_CreateViewWindow)(PVOID pThis, IShellView *psvPrevious, LPCFOLDERSETTINGS pfs, IShellBrowser *psb, RECT *prcView, HWND *phWnd );

IMPLEMENT_COMSERVER_HOOK(SHELLX98)

/*++

    Convert Win9x paths to WinNT paths for IShellLinkW::SetPath

--*/
HRESULT COMHOOK(IShellFolder, CreateViewObject)(
    PVOID pThis,
    HWND hwndOwner,
    REFIID riid,
    VOID **ppv )
{
    HRESULT hReturn = ORIGINAL_COM(IShellFolder, CreateViewObject, pThis)(pThis, hwndOwner, riid, ppv);

    if (hReturn == NOERROR)
    {
        // Only hook IShellView objects
        if (IsEqualGUID(riid,  IID_IShellView))
        {

            // We don't know the CLSID, but since this routine is only called
            // for IShellFolder's that were created by ShellX98.dll;
            // we really don't need to know: it can only be one of the two
            // IShellFolder CLSID that we hooked.
            HookObject(
                NULL,  
                riid, 
                ppv,
                NULL, 
                FALSE);
        }
    }

    return hReturn;
}


/*++

    Convert Win9x paths to WinNT paths for IShellLinkW::SetPath

--*/
HRESULT COMHOOK(IShellView, CreateViewWindow)(
    PVOID pThis,
    IShellView *psvPrevious,
    LPCFOLDERSETTINGS pfs,
    IShellBrowser *psb,
    RECT *prcView,
    HWND *phWnd
)
{
    LPFOLDERSETTINGS lpFolderSettings = const_cast<LPFOLDERSETTINGS>(pfs);

    // ShellX98.dll only handles ViewModes FVM_ICON to FVM_THUMBNAIL
    if (lpFolderSettings->ViewMode > FVM_THUMBNAIL)
    {
        LOGN( eDbgLevelError, "[IShellView::CreateViewWindow] forced FOLDERSETTINGS->ViewMode from %d to %d", lpFolderSettings->ViewMode, FVM_ICON);
        lpFolderSettings->ViewMode = FVM_ICON;
    }

    HRESULT hReturn = ORIGINAL_COM(IShellView, CreateViewWindow, pThis)(pThis, psvPrevious, lpFolderSettings, psb, prcView, phWnd);
    return hReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_COMSERVER(SHELLX98)

    // Explorer creates an IShellFolder via ShellX98.dll's class factory.
    // Eventually it calls IShellFolder::CreateViewObject to create an 
    // IShellView object.  We want to shim IShellView::CreateViewWindow.

    COMHOOK_ENTRY(Vault,    IShellFolder, CreateViewObject, 8)
    COMHOOK_ENTRY(Shredder, IShellFolder, CreateViewObject, 8)

    COMHOOK_ENTRY(Vault,    IShellView,   CreateViewWindow, 9)
    COMHOOK_ENTRY(Shredder, IShellView,   CreateViewWindow, 9)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\herosdvd.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeroSDVD.cpp

 Abstract:
    Background: clicking the nonclient close button when a movie clip is playing causes the app 
    to hang and then AV when themes are active.   The DisableThemes shim has no effect.
 
    This is related to the app's repeated calls to SetClassLong(hwnd, GCL_HICON) in order to produce 
    the effect of an animated window icon.   This generates frequent requests to redraw the window's icon, 
    which in turn generates the NCUAHDRAWCAPTION.   This is a huge perf hit to the app in any case, 
    but particularly if the SetClassLong call makes an extra round trip to user mode and back as a 
    result of the SendMessage.    
 
    When the user hits the Close button, the app's WM_SYSCOMMAND handler resets an event that is waited 
    on by the icon-transitioning thread, and then puts himself (the UI thread) to sleep.    
    Then he calls SetClassLong(..., GCL_ICON) one last time from the icon-switching thread, 
    which hangs the app because the message-pumping thread is sleeping. This does not repro when win32k 
    doesn't send the NCUAHDRAWCAPTION message; i.e., when user API hooks are not active.
 
    The DisableTheme does not work because this shim operates in user mode on a per-process basis.
    This shim has no effect on win32k, which does special processing on a session-wide basis when themes are enabled.
 
    To address this, we shim this app to nop on SetClassLong(..., GCL_HICON), which means the app at 
    best loses animation of the icon and at worst display a bogus icon when themes are active, 


 Notes:
    
    This is an app specific shim.

 History:

    05/11/2001 scotthan  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeroSDVD)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetClassLongA) 
APIHOOK_ENUM_END

typedef BOOL (STDAPICALLTYPE * PFNTHEMEACTIVE)(void);
PFNTHEMEACTIVE g_pfnThemeActive;
HINSTANCE      g_hinstUxtheme;

HINSTANCE LoadUxTheme()
{
    if( NULL == g_hinstUxtheme )
    {
        HINSTANCE hinst = LoadLibrary(TEXT("UxTheme.dll"));
        if( NULL != hinst )
        {
            if( InterlockedCompareExchangePointer( (PVOID*)&g_hinstUxtheme, hinst, NULL ) )
            {
                FreeLibrary(hinst); // already loaded.
            }
        }
    }
    return g_hinstUxtheme;
}

DWORD 
APIHOOK(SetClassLongA)(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG dwNewLong 
    )
{
    if( GCL_HICON == nIndex )
    {
        if( NULL == g_pfnThemeActive )
        {
            HINSTANCE hinst = LoadUxTheme();
            if( hinst )
            {
                g_pfnThemeActive = (PFNTHEMEACTIVE)GetProcAddress( hinst, "IsThemeActive" );
            }
        }

        if( g_pfnThemeActive && g_pfnThemeActive() )
        {
            //  no-op the request to change icon, and return the current one.
            return GetClassLongA(hwnd, nIndex);
        }
    }

    return ORIGINAL_API(SetClassLongA)(hwnd, nIndex, dwNewLong);
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if( DLL_PROCESS_ATTACH == fdwReason )
    {
        g_hinstUxtheme   = NULL;
        g_pfnThemeActive = NULL;
    }
    else if( DLL_PROCESS_DETACH == fdwReason )
    {
        if( g_hinstUxtheme )
        {
            FreeLibrary(g_hinstUxtheme);
            g_hinstUxtheme = NULL;
        }
        g_pfnThemeActive = NULL;
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(USER32.DLL, SetClassLongA )
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\hotfaxmessagecenter4.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HotFaxMessageCenter4.cpp
 Abstract:
    The app was AV'ing as it was passing a NULL handle
    ontained from GetDlgItem() to another call.
    This appspecific SHIM prevents that from happening.

    This is an app specific shim.

 History:
 
    03/13/2001 prashkud  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HotFaxMessageCenter4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetDlgItem)    
APIHOOK_ENUM_END


/*++
    Correct the returned HANDLE if it is NULL by passsing the previous valid    
    HANDLE
--*/

HWND
APIHOOK(GetDlgItem)(
    HWND hDlg,
    int nIDDlgItem
    )
{
    static HWND hDlgItem = 0;
    HWND hCurDlgItem = 0;

    hCurDlgItem = ORIGINAL_API(GetDlgItem)(hDlg, nIDDlgItem);

    if (hCurDlgItem != NULL)
    {
        hDlgItem = hCurDlgItem;
    }

    return hDlgItem;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, GetDlgItem)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\hptourguide.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    HPTourGuide.cpp

 Abstract:

    The application causes Explorer to crash when
    a tour is selected. To fix we are eating LVM_GETITEMA
    messages if the window handle matches the ListView
    that the app was sending to.
    Fix for Whistler bug #177103
    
 Notes:

    This is an app specific shim.

 History:

    03/28/2001  robdoyle    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HPTourGuide)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SendMessageA) 
APIHOOK_ENUM_END

/*++

  Eat LVM_GETITEMA messages for a specific hWnd

--*/

BOOL
APIHOOK(SendMessageA)(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        )
{

    LRESULT lRet;


    HWND hWnd_TARGET, hWnd_temp;

    hWnd_temp = FindWindowExA (NULL, NULL, "Progman", "Program Manager");    
    hWnd_temp = FindWindowExA (hWnd_temp, NULL, "SHELLDLL_DefView", NULL);
    hWnd_TARGET = FindWindowExA (hWnd_temp, NULL, "SysListView32", NULL);


    if ((hWnd == hWnd_TARGET) && (uMsg == LVM_GETITEMA))
    {
        /* Uncomment to aid debugging
        DPFN( eDbgLevelError, "bypassing SendMessage of LVM_GETITEMA");
        */

        lRet = TRUE;
    }

    else
    {
    lRet = ORIGINAL_API(SendMessageA)(
        hWnd,
        uMsg,
        wParam,
        lParam);
    }
    return lRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, SendMessageA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\force21.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Force21.cpp

 Abstract:

    Force21 contains an invalid check code that looks like the following:

        mov  ebx,A
        mov  edi,B
        mov  eax,C
        sub  edi,eax
        cmp  edi,ebx
        jle  @@Loc
        mov  edi,ebx
    @@Loc:

    In a particular case: B=-1 and C<0x80000000 this jump will be incorrectly 
    taken. The reason this works on Win9x is that C>0x80000000 because it's a 
    memory mapped file. On NT, no user mode address can be >2GB.

    This shim patches the app with a 'cli' instruction so that it can perform 
    some logic when the exception gets hit. This is admittedly slow.

    Note we didn't use the in memory patching facility of the shim because we
    still needed logic. It didn't make sense to split the shim from the patch.

 History:

    04/10/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Force21)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END


/*++

 In memory patch the executable with a cli instruction. This patch works 
 for both the release version and a patch.

--*/

VOID
Force21_ExecutePatch()
{
    BYTE bPatchMatch[] = { 
        0x2b, 0xf8, 0x3b, 0xfb, 0x7c, 
        0x02, 0x8b, 0xfb, 0x85, 0xff };

    LPBYTE pPatchAddress[] = {
        (LPBYTE)0x5aa1f3,       // the shipping version
        (LPBYTE)0x5ac4a0 };     // with patch 1 applied
        
    BYTE bPatch = 0xFA;         // cli - to cause an exception

    //
    // Run through the patches and see which one matches
    //

    for (UINT j=0; j<sizeof(pPatchAddress)/sizeof(LPBYTE); j++)
    {
        LPBYTE pb = pPatchAddress[j];

        // Make sure it's an OK address.
        if (!IsBadReadPtr(pb, sizeof(bPatchMatch)))
        {
            // Check the bytes match
            for (UINT i=0; i < sizeof(bPatchMatch); i++)
            {
                if (*pb != bPatchMatch[i])
                {
                   break;
                }
                pb++;
            }

            // In memory patch
            if (i == sizeof(bPatchMatch))
            {
                DWORD dwOldProtect;
                if (VirtualProtect(
                      (PVOID)pPatchAddress[j],
                      1,
                      PAGE_READWRITE,
                      &dwOldProtect))
                {
                    *pPatchAddress[j] = bPatch;
                    LOGN(
                        eDbgLevelError,
                        "Successfully patched\n");
                    return;
                }
            }
        }
    }
}

/*++

 Handle the cli in such a way that the correct logic is performed.

--*/

LONG 
Force21_ExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    CONTEXT *lpContext = ExceptionInfo->ContextRecord;

    if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_PRIV_INSTRUCTION)
    {
        // Looks like we've hit our cli instruction

        if ((LONG)lpContext->Edi < 0)   // Boundary condition, EDI<0
        {
            // Jump past the invalid check
            lpContext->Eip = lpContext->Eip + 6;
        }
        else
        {
            // Replace the 'sub edi,eax' and continue
            lpContext->Edi = lpContext->Edi - lpContext->Eax; 
            lpContext->Eip = lpContext->Eip + 2;
        }
        return EXCEPTION_CONTINUE_EXECUTION;
    }

    return EXCEPTION_CONTINUE_SEARCH;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        Force21_ExecutePatch();
        SetUnhandledExceptionFilter(Force21_ExceptionFilter);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\hoylegames.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HoyleGames.cpp

 Abstract:
   
     All Hoyle apps have one common problem and that is a hard
     coded "C:\" in its data section of the image.The apps crash
     because of this if installed and run from any other drive
     other than C:\.
        This shim goes through the image of the app searching
     for the hardcoded string and replaces them if found. This 
     shim replaces all the existing app specific shims for
     Hoyle Games.

     This is an app specific shim.


 History:

    04/17/2001  Prashkud    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HoyleGames)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA) 
APIHOOK_ENUM_END

// Max Virtual address replacements in all sections
#define MAX_VA          50

// Global array to hold the replacement VA 
DWORD g_ReplaceVA[MAX_VA];

// Replacement count
int g_ReplaceCnt;

/*++

    Parse the Section and fill in the location index into the 
    SECTION structure. This function also fills in the number
    of occurences of the hard-coded "C:\" string in this section.

--*/

BOOL
GetReplacementLocations(
    DWORD dwSecPtr,
    DWORD dwSize
    )
{
    BYTE *pbFilePtr = (BYTE*)dwSecPtr;
    BOOL bRet = FALSE;


    for (DWORD i = 0; i < dwSize; i++)
    {
        if ((BYTE)*(pbFilePtr + i) == 'c')
        {
            if((BYTE)*(pbFilePtr + i + 1) == ':' &&
               (BYTE)*(pbFilePtr + i + 2) == '\\')
            {
                g_ReplaceVA[g_ReplaceCnt++] = dwSecPtr + i;
                bRet = TRUE;                
            }
        }
    }
    return bRet;
}

/*++

    This function loops through each section looking for a Initialized Data
    section. Once it gets the Initialized Data section, it calls the helper
    function GetReplacementLocations() to get the offset from the base of the 
    section. It then calculates the Virtual Address at which the replacement
    should occur.

--*/

BOOL
GetInitializedDataSection()
{
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER NtSection;
    DWORD dwSectionVA = 0, dwSize = 0;    
    BOOL bRet = FALSE;

    // Get the module base address
    PUCHAR Base = (PUCHAR)GetModuleHandle(NULL);

    if ((ULONG_PTR)Base & 0x00000001) 
    {
        Base = (PUCHAR)((ULONG_PTR)Base & ~0x1);        
     }

    NtHeader = RtlpImageNtHeader(Base);

    if (NtHeader) 
    {
        FileHeader = &NtHeader->FileHeader;
        OptionalHeader = &NtHeader->OptionalHeader;
    } 
    else 
    {
        // Handle case where Image passed in doesn't have a dos stub (ROM images for instance);
        FileHeader = (PIMAGE_FILE_HEADER)Base;
        OptionalHeader = (PIMAGE_OPTIONAL_HEADER) ((ULONG_PTR)Base + IMAGE_SIZEOF_FILE_HEADER);
    }

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                FileHeader->SizeOfOptionalHeader);


    for (DWORD i=0; i<FileHeader->NumberOfSections; i++) 
    {
        // Check whether the section is a Initialized Data Section
        if (NtSection->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA) 
        {
            // Size of the Section to search         
            dwSize = NtSection->SizeOfRawData;

            // Get the Section's Virtual address
            dwSectionVA = (DWORD)(Base + NtSection->VirtualAddress);

            __try
            {               
                if(GetReplacementLocations(dwSectionVA, dwSize))
                {
                    bRet = TRUE;
                }
                DPFN( eDbgLevelError, "Replacing was successful");
                
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                DPFN( eDbgLevelError, "Replacing crashed");
                goto Exit;
            }

        }

        ++NtSection;
    }
    return bRet;


Exit:
    return FALSE;
}

/*++

 Very specific hack to return a good FaceMaker path, so the app doesn't fail
 when it is installed on the wrong drive.

--*/

DWORD 
APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    )
{
    CSTRING_TRY
    {
        CString csApp = lpAppName;
        CString csKey = lpKeyName;
        CString csFile = lpFileName;

        if ((csApp.Compare(L"Settings") == 0) && 
            (csKey.Compare(L"FaceMakerPath") == 0) && 
            (csFile.Find(L"CARDGAME.INI") > -1)) {

            DWORD dwRet = ORIGINAL_API(GetPrivateProfileStringA)(lpAppName, lpKeyName, 
                lpDefault, lpReturnedString, nSize, lpFileName);

            if (!dwRet) {
                // Substitute the right path
                CString csPath = L"%ProgramFiles%\\WON\\FaceMaker";
                csPath.ExpandEnvironmentStringsW();
                if (lpReturnedString && ((int)nSize > csPath.GetLength())) {
                    LOGN(eDbgLevelError, "[GetPrivateProfileStringA] Forced correct FaceMaker path");
                    strncpy(lpReturnedString, csPath.GetAnsi(), nSize);
                    dwRet = csPath.GetLength();
                }
            }

            return dwRet;
        }
    }
    CSTRING_CATCH
    {
        // fall through
    }

    
    return ORIGINAL_API(GetPrivateProfileStringA)(lpAppName, lpKeyName, 
                lpDefault, lpReturnedString, nSize, lpFileName);
}

/*++

 This function hooks GetVersion (called early on by Hoyle Board Games)
 and replaces the hard coded 'c's with the correct install drive letter
 that it looks up in the registry.
    
 It uses g_HoyleWordGames_bPatched to patch only once.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        CHAR szInstallDir[MAX_PATH];
        CHAR szProgFilesDir[MAX_PATH];      // Added by Noah Young on 1/26/01
        DWORD cb           = MAX_PATH;
        HKEY hKey          = 0;
        DWORD dwOldProtect = 0;    

        
     
        // Fix problem where Program Files dir isn't on same drive as BOARD3.EXE
        if( ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                              "SOFTWARE\\Microsoft\\Windows\\CurrentVersion",
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hKey) ) 
        {
            goto exit;
        }
    
        if( ERROR_SUCCESS != RegQueryValueExA(hKey,
                                             "ProgramFilesDir",
                                             NULL,
                                             NULL,  // REG_SZ
                                             (LPBYTE)szProgFilesDir,
                                             &cb) ) 
        {
            goto exit;
        }


        // Scan the image's initialized data section....    
        char szModule[MAX_PATH];

        if(!GetModuleFileNameA(NULL, szModule, MAX_PATH))
        {
            DPFN( eDbgLevelError, "GetModuleFileA returned error");
            goto exit;
        }

        // Get the Virtual adresses that need to be replaced
        if(!GetInitializedDataSection())
        {
            DPFN( eDbgLevelError, "No patching done!");
            goto exit;
        }
    
        long PATCH_LENGTH = g_ReplaceVA[ g_ReplaceCnt - 1] - g_ReplaceVA[0] + 1;

        // Make the memory page writable
        if( VirtualProtect( (PVOID) g_ReplaceVA[0],
                            PATCH_LENGTH,
                            PAGE_READWRITE,
                            &dwOldProtect ) ) 
        {
            for (int i=0; i< g_ReplaceCnt; i++)
            {
                // Make sure it's what we expect
                if( 'c' == *((CHAR*) g_ReplaceVA[i]) )
                {
                    if (i==0)
                    {
                        *((CHAR*) g_ReplaceVA[i]) = szProgFilesDir[0];  
                    }
                    else
                    {
                        *((CHAR*) g_ReplaceVA[i]) = szModule[0];
                    }
                }
            }
        }
    }

exit:
   return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION    
    APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStringA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\iconfig.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    IConfig.cpp

 Abstract:

    Remove iconfig.exe from \\HKLM\Software\Microsoft\Windows\CurrentVersion\Run.
    Delete iconfig.exe and iconfig.dll.
    
 Notes:

    This is an app specific shim.

 History:

    09/17/2001  astritz     Created

--*/

 
#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IConfig)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    // Not hooking an API
APIHOOK_ENUM_END

/*++
    Notify Function
--*/    
BOOL
NOTIFY_FUNCTION(DWORD fdwReason)
{
    HKEY hKey = 0;
    WCHAR wszFileName[MAX_PATH];
    DWORD dwLen = 0;

    if( SHIM_STATIC_DLLS_INITIALIZED == fdwReason ) {

        if( RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Run",
                0,
                KEY_ALL_ACCESS,
                &hKey
                ) != ERROR_SUCCESS ) {

            goto EXIT_PROCESS;
        }

        DPFN(eDbgLevelError, "Removing ICONFIG.EXE from \\HKLM\\Software\\Microsoft\\Windows\\CurrentVerion\\Run");
        RegDeleteValueW(hKey, L"ICONFIG");
        RegCloseKey(hKey);


        dwLen = GetModuleFileNameW(NULL, wszFileName, MAX_PATH);

        if( 0 == dwLen) {
            goto EXIT_PROCESS;
        }

        DPFN(eDbgLevelError, "Deleting %S.", wszFileName);
        MoveFileExW(wszFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
        
        if( dwLen < 3 ) {
            goto EXIT_PROCESS;
        }

        wcscpy(&wszFileName[dwLen-3], L"DLL");
        DPFN(eDbgLevelError, "Deleting %S.", wszFileName);
        MoveFileExW(wszFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);


EXIT_PROCESS:
        ExitProcess(0);

    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\ie5domsetup.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IE5DOMSetup.cpp

 Abstract:

    This DLL fixes a problem with Internet Explorer's IE5DOM.EXE package. If 
    the command line contains /n:v, the package will replace the 128-bit 
    encryption modules that shipped with Win2K, which can cause serious harm -
    no one can log on to the machine.

    This shim simply removes /n:v from the command line so that the package 
    does not replace the encryption DLLs.

 History:

    02/01/2000 jarbats  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IE5DOMSetup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

VOID 
StartSecondProcess(LPWSTR lpCommandLine)
{
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFOW StartupInfo;
    LPWSTR FileName;
    LPWSTR CurrentDir;
    DWORD Size;
        
    Size=GetCurrentDirectoryW(0,NULL);

    CurrentDir=(LPWSTR)ShimMalloc(Size*sizeof(WCHAR));

    if(NULL == CurrentDir)
    {
        //it is better to fail now then go on and bomb the system
        ExitProcess(0);
    }

    GetCurrentDirectoryW(Size,CurrentDir);

    FileName=(LPWSTR)ShimMalloc((MAX_PATH+2)*sizeof(WCHAR));

    if(NULL == FileName)
    {
        ExitProcess(0);
    }

    GetModuleFileNameW(NULL, FileName, MAX_PATH+2);

    StartupInfo.cb=sizeof(STARTUPINFO);
    StartupInfo.lpReserved=NULL;
    StartupInfo.lpDesktop=NULL;
    StartupInfo.lpTitle=NULL;
    StartupInfo.dwFlags=0;
    StartupInfo.cbReserved2=0;
    StartupInfo.lpReserved2=NULL;

    CreateProcessW(
        FileName,
        lpCommandLine,
        NULL,
        NULL,
        FALSE,
        NORMAL_PRIORITY_CLASS,
        NULL,
        CurrentDir,
        &StartupInfo,
        &ProcessInfo
        );

    ExitProcess(0);
}


VOID CheckCommandLine()
{
LPWSTR lpCommandLine,lpNewCommandLine;
LPWSTR *lpArgV;
LPWSTR lpSwitch={L"/n:v"};
BOOL   b;
INT    nArgC=0;
DWORD  nSwitch=1;
INT    i, j;

       lpCommandLine=GetCommandLineW();
       if(NULL == lpCommandLine)
       {
           //without arguments this exe is harmless
           return;
       }
       
       i = lstrlenW(lpCommandLine)+2;

       lpNewCommandLine=(LPWSTR)ShimMalloc( i*sizeof(WCHAR) );

       if(NULL == lpNewCommandLine)
       {
            ExitProcess(0);
       }

       lpArgV = _CommandLineToArgvW(lpCommandLine,&nArgC);

       if(NULL == lpArgV)
       {
           //better to fail now
           ExitProcess(0);
       }
       else
       {
           if( nArgC < 2)
           {
              //there isn't any chance for /n:v
              ShimFree(lpNewCommandLine);
              GlobalFree(lpArgV);
              return;
           }
       }
       
       b = FALSE;
       
       for ( i=1; i<nArgC; i++ )
       {     
           if(lstrcmpiW(lpArgV[i],lpSwitch))
           {
               wcscat(lpNewCommandLine,lpArgV[i]);
           }
           else
           {
               b = TRUE;
           }
       }
       
       if (TRUE == b)
       {
           StartSecondProcess(lpNewCommandLine);
       }
       
       //never gets here because startsecondprocess doesn't return
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.

 IMPORTANT: Make sure you ONLY call NTDLL, KERNEL32 and MSVCRT APIs during
 DLL_PROCESS_ATTACH notification. No other DLLs are initialized at that
 point.
 
 If your shim cannot initialize properly, return FALSE and none of the
 APIs specified will be hooked.
 
--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        CheckCommandLine();
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\htmleditor8587.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HTMLEditor8587.cpp

 Abstract:

     HTML Editor 8.5/8.7 Call CreateFileA without closing the
     handle that was opened with the first call to CreateFileA.
     This SHIM hooks CreateFileA and CloseHandle and ensures
     that the temporary file is deleted and the handle closed
     before the next call to CreateFileA with the same filename.

    This is an app specific shim.

 History:
 
    02/06/2001 prashkud  Created

--*/

#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(HTMLEditor8587)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN  
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CloseHandle)
APIHOOK_ENUM_END


HANDLE g_FileHandle = 0;

/*++

 Hook CreateFileA so that we can monitor the filename
 and the handle and ensure that the previous handle that
 was opened is closed before this call to the same file.

--*/

HANDLE
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpsa,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTempFile
    )
{
    if (g_FileHandle && (stristr(lpFileName, "\\working\\~tm") != NULL))
    {
        DeleteFileA(lpFileName);
        CloseHandle(g_FileHandle);
        g_FileHandle = 0;
    }

    if (stristr(lpFileName, "\\working\\~tm") != NULL)
    {
        g_FileHandle = ORIGINAL_API(CreateFileA)(
                    lpFileName,
                    dwDesiredAccess,
                    dwShareMode,
                    lpsa,
                    dwCreationDisposition,
                    dwFlagsAndAttributes,
                    hTempFile
                    );
        return g_FileHandle;
    }
    else
    {
        return ORIGINAL_API(CreateFileA)(
                    lpFileName,
                    dwDesiredAccess,
                    dwShareMode,
                    lpsa,
                    dwCreationDisposition,
                    dwFlagsAndAttributes,
                    hTempFile
                    );

    }
    

    
}
/*++

 Hook CloseHandle to ensure that the global handle that we maintain 
 is set to '0'.

--*/

BOOL
APIHOOK(CloseHandle)(
    HANDLE hObject
    )
{
    BOOL bRet = FALSE;

    bRet = ORIGINAL_API(CloseHandle)(hObject);
    if (hObject == g_FileHandle)
    {
        g_FileHandle = 0;
    }
    return bRet;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN    
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\intelvideophone.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IntelVideoPhone.cpp

 Abstract:

    Hooks all dialog procs and make the window handles on WM_COMMAND messages 16 bit.

 Notes:

    This is an app specific shim.

 History:

    11/08/2000 linstev  Created

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IntelVideoPhone)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA) 
APIHOOK_ENUM_END

INT_PTR CALLBACK 
DialogProcHook_IntelVideoPhone(
    DLGPROC pfnOld, 
    HWND hwndDlg,  
    UINT uMsg,     
    WPARAM wParam,   
    LPARAM lParam    
    )
{
    if (uMsg == WM_COMMAND) {
        lParam = 0;
    }

    return (*pfnOld)(hwndDlg, uMsg, wParam, lParam);    
}

HWND
APIHOOK(CreateDialogIndirectParamA)(
    HINSTANCE hInstance,        
    LPCDLGTEMPLATE lpTemplate,  
    HWND hWndParent,            
    DLGPROC lpDialogFunc,       
    LPARAM lParamInit           
    )
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, DialogProcHook_IntelVideoPhone);

    return ORIGINAL_API(CreateDialogIndirectParamA)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\isa.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ISA.cpp

 Abstract:

    The ISA setup needs to successfully open the SharedAccess service and get the
    its status in order to succeed. But on whistler we remove this from advanced
    server since it's a consumer feature so the ISA setup bails out. 

    We fake the service API call return values to make the ISA setup happy.

 History:

    04/24/2001 maonis   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ISA)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OpenServiceA) 
    APIHOOK_ENUM_ENTRY(OpenServiceW) 
    APIHOOK_ENUM_ENTRY(QueryServiceStatus) 
    APIHOOK_ENUM_ENTRY(QueryServiceConfigA) 
    APIHOOK_ENUM_ENTRY(ChangeServiceConfigA)
    APIHOOK_ENUM_ENTRY(CloseServiceHandle) 
APIHOOK_ENUM_END

/*++

  Abstract:

    This checks to see if the service is being opened is SharedAccess.
    If so we simply return a fake handle.

  History:

    04/24/2001    maonis     Created

--*/

SC_HANDLE 
APIHOOK(OpenServiceA)(
    SC_HANDLE hSCManager,  // handle to SCM database
    LPCSTR lpServiceName, // service name
    DWORD dwDesiredAccess  // access
    )
{
    DPF("ISA", eDbgLevelInfo, "Calling OpenServiceA on %s", lpServiceName);

    SC_HANDLE hService;

    if (!(hService = ORIGINAL_API(OpenServiceA)(hSCManager, lpServiceName, dwDesiredAccess)))
    {
        if (lpServiceName && !lstrcmpiA(lpServiceName, "SharedAccess"))
        {
            DPF("ISA", eDbgLevelError, "it's trying to open SharedAccess!!!");
            return (SC_HANDLE)0xBAADF00D;
        }
    }

    return hService;
}

SC_HANDLE 
APIHOOK(OpenServiceW)(
    SC_HANDLE hSCManager,  // handle to SCM database
    LPCWSTR lpServiceName, // service name
    DWORD dwDesiredAccess  // access
    )
{
    DPF("ISA", eDbgLevelInfo, "Calling OpenServiceW on %S", lpServiceName);

    SC_HANDLE hService;

    if (!(hService = ORIGINAL_API(OpenServiceW)(hSCManager, lpServiceName, dwDesiredAccess)))
    {
        if (lpServiceName && !lstrcmpiW(lpServiceName, L"SharedAccess"))
        {
            DPF("ISA", eDbgLevelError, "it's trying to open SharedAccess!!!");
            return (SC_HANDLE)0xBAADF00D;
        }
    }

    return hService;
}

/*++

  Abstract:

    This checks to see if the service handle is 0xBAADF00D, if so just sets
    the service status to SERVICE_STOPPED.

  History:

    04/24/2001    maonis     Created

--*/

BOOL 
APIHOOK(QueryServiceStatus)(
    SC_HANDLE hService,               // handle to service
    LPSERVICE_STATUS lpServiceStatus  // service status
    )
{
    if (hService == (SC_HANDLE)0xBAADF00D)
    {
        lpServiceStatus->dwCurrentState = SERVICE_STOPPED;
        return TRUE;
    }
    else
    {
        return ORIGINAL_API(QueryServiceStatus)(hService, lpServiceStatus);
    }
}

/*++

  Abstract:

    ISA calls this API first with a NULL lpServiceConfig to get the size
    of the buffer needs to be allocated for the structure; then it calls
    the API again with the pointer to the structure.

  History:

    05/07/2001    maonis     Created

--*/

BOOL 
APIHOOK(QueryServiceConfigA)(
    SC_HANDLE hService,                     // handle to service
    LPQUERY_SERVICE_CONFIGA lpServiceConfig, // buffer
    DWORD cbBufSize,                        // size of buffer
    LPDWORD pcbBytesNeeded                  // bytes needed
    )
{
    if (hService == (SC_HANDLE)0xBAADF00D)
    {
        if (lpServiceConfig)
        {
            lpServiceConfig->lpDependencies = NULL;
            return TRUE;
        }
        else
        {
            *pcbBytesNeeded = sizeof(QUERY_SERVICE_CONFIGA);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return TRUE;
        }
    }
    else
    {
        return ORIGINAL_API(QueryServiceConfigA)(hService, lpServiceConfig, cbBufSize, pcbBytesNeeded);
    }
}

/*++

  Abstract:

    We simply make this API succeed when hService is 0xBAADF00D.

  History:

    05/07/2001    maonis     Created

--*/

BOOL 
APIHOOK(ChangeServiceConfigA)(
    SC_HANDLE hService,          // handle to service
    DWORD dwServiceType,        // type of service
    DWORD dwStartType,          // when to start service
    DWORD dwErrorControl,       // severity of start failure
    LPCSTR lpBinaryPathName,   // service binary file name
    LPCSTR lpLoadOrderGroup,   // load ordering group name
    LPDWORD lpdwTagId,          // tag identifier
    LPCSTR lpDependencies,     // array of dependency names
    LPCSTR lpServiceStartName, // account name
    LPCSTR lpPassword,         // account password
    LPCSTR lpDisplayName       // display name
    )
{
    if (hService == (SC_HANDLE)0xBAADF00D)
    {
        return TRUE;
    }
    else
    {
        return ORIGINAL_API(ChangeServiceConfigA)(
            hService,
            dwServiceType,
            dwStartType,
            dwErrorControl,
            lpBinaryPathName,
            lpLoadOrderGroup,
            lpdwTagId,
            lpDependencies,
            lpServiceStartName,
            lpPassword,
            lpDisplayName);
    }
}

/*++

  Abstract:

    This checks to see if the service handle is 0xBAADF00D, if so simply return

  History:

    04/24/2001    maonis     Created

--*/

BOOL 
APIHOOK(CloseServiceHandle)(
    SC_HANDLE hSCObject   // handle to service or SCM object
    )
{
    if (hSCObject == (SC_HANDLE)0xBAADF00D)
    {
        return TRUE;
    }
    else
    {
        return ORIGINAL_API(CloseServiceHandle)(hSCObject);
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(Advapi32.DLL, OpenServiceA)
    APIHOOK_ENTRY(Advapi32.DLL, OpenServiceW)
    APIHOOK_ENTRY(Advapi32.DLL, QueryServiceStatus)
    APIHOOK_ENTRY(Advapi32.DLL, QueryServiceConfigA)
    APIHOOK_ENTRY(Advapi32.DLL, ChangeServiceConfigA)
    APIHOOK_ENTRY(Advapi32.DLL, CloseServiceHandle)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\installshield6.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    InstallShield6.cpp

 Abstract:

    - InstallShield6 is using IKernel.exe. The problem is IKernel.exe is an out-of-process
      OLE server that is spawned by svchost. IKernel.exe is located in InstallShield common
      folder and it's known as InstallShield engine.
    - In order to enable us to do matching against app that is using IKernel, we catch 
      first call to CreateFileA that has "data1.hdr" filename on the path.
      We should be able to use matching info available in the path of this data1.hdr.
      (which is located in temp folder in current user setting).
      Then we call apphelp!ApphelpCheckExe to verify whether there is a match.
      If there is a match, it will call shimeng!SE_DynamicShim to dynamically load additional shim 
      available for this application.
          

 History:
        
    04/11/2001 andyseti Created
    06/27/2001 andyseti Added code to prevent multiple Dynamic Shimming

--*/

#include "precomp.h"

typedef BOOL    (WINAPI *_pfn_CheckExe)(LPCWSTR, BOOL, BOOL, BOOL);

IMPLEMENT_SHIM_BEGIN(InstallShield6)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
APIHOOK_ENUM_END



HANDLE 
APIHOOK(CreateFileA)(
    LPSTR                   lpFileName,
    DWORD                   dwDesiredAccess,
    DWORD                   dwShareMode,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    DWORD                   dwCreationDisposition,
    DWORD                   dwFlagsAndAttributes,
    HANDLE                  hTemplateFile
    )
{
    static  _pfn_CheckExe             pfnCheckExe = NULL;
    
    static  const char  Apphelp_ModuleName[]            = "Apphelp.dll";
    static  const char  CheckExeProcedureName[]         = "ApphelpCheckExe";
    
    HMODULE         hmodApphelp = 0;

    if (pfnCheckExe != NULL)
    {
        goto Done;
    }

    CSTRING_TRY
    {
        CString csFileName(lpFileName);
        csFileName.MakeLower();
    
        if (-1 == csFileName.Find(L"data1.hdr"))
        {
            // not the one that we are looking for.
            goto Done;
        }

        DPFN(
            eDbgLevelInfo,
            "[CreateFileA] Accessing %S", csFileName.Get());

        // load apphelp & shimengine modules

        DPFN(
            eDbgLevelInfo,
            "[CreateFileA] Loading Apphelp");

        hmodApphelp = LoadLibraryA(Apphelp_ModuleName);

        if (0 == hmodApphelp)
        {
            DPFN(
                eDbgLevelError,
                "[CreateFileA] Failed to get apphelp module handle");
            goto Done;
        }

        // Get procedure addresses
        DPFN(
            eDbgLevelInfo,
            "[CreateFileA] Getting ApphelpCheckExe proc address");

        pfnCheckExe = (_pfn_CheckExe) GetProcAddress(hmodApphelp, CheckExeProcedureName);

        if (NULL == pfnCheckExe)
        {
            DPFN(
                eDbgLevelError,
                "[CreateFileA] Failed to get %s procedure from %s module",
                CheckExeProcedureName,Apphelp_ModuleName);
            goto Done;        
        }

        DPFN(
            eDbgLevelInfo,
            "[CreateFileA] Calling CheckExe");

        if (FALSE == (*pfnCheckExe)(
            (WCHAR *)csFileName.Get(),
            FALSE,
            TRUE,
            FALSE
            ))

        {
            DPFN(
                eDbgLevelError,
                "[CreateFileA] There is no match for %S",
                csFileName.Get());
            goto Done;
        }

    }
    CSTRING_CATCH
    {
        // Do nothing
    }

Done:
    HANDLE hRet = ORIGINAL_API(CreateFileA)(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);

    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\jetfighter4.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    JetFighter4.cpp

 Abstract:

    The app has a malformed ICON in it's resource.

 Notes:

    This is an app specific shim.

 History:

    01/30/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(JetFighter4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadIconA) 
APIHOOK_ENUM_END

/*++

 Check for the bad icon.

--*/

HICON
APIHOOK(LoadIconA)(
    HINSTANCE hInstance, 
    LPCSTR lpIconName
    )
{
    if ((DWORD) lpIconName == 103) {
        lpIconName = (LPCSTR) 8;
    }

    return ORIGINAL_API(LoadIconA)(hInstance, lpIconName);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, LoadIconA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\javavm2.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    JavaVM2.cpp

 Abstract:

    For versions of msjavx86.exe >= 06.00.3229.0000 we need to
    append /nowin2kcheck to the execution of javatrig.exe.

 Notes:

    This is an app specific shim.

 History:

    05/31/2001  mnikkel  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(JavaVM2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END



/*++

  Check CreateProcessA for execution of javatrig, if found
  append /nowin2kcheck to the command line.

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                  lpApplicationName,                 
    LPSTR                   lpCommandLine,                      
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, 
    BOOL                    bInheritHandles,                     
    DWORD                   dwCreationFlags,                    
    LPVOID                  lpEnvironment,                     
    LPCSTR                  lpCurrentDirectory,                
    LPSTARTUPINFOA          lpStartupInfo,             
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    DPFN( eDbgLevelSpew, "[CreateProcessA] appname:(%s)\ncommandline:(%s)", lpApplicationName, lpCommandLine );

    if (lpCommandLine)
    {
        CSTRING_TRY
        {
            CString csCL(lpCommandLine);

            int nLoc = csCL.Find(L"javatrig.exe ");
            if ( nLoc > -1 )
            {
                csCL += L" /nowin2kcheck";
                DPFN( eDbgLevelSpew, "[CreateProcessA] appname:(%s)\nNEW commandline:(%S)", lpApplicationName, csCL.Get() );

                return ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                                    csCL.GetAnsi(),
                                                    lpProcessAttributes,
                                                    lpThreadAttributes, 
                                                    bInheritHandles,                     
                                                    dwCreationFlags,                    
                                                    lpEnvironment,                     
                                                    lpCurrentDirectory,                
                                                    lpStartupInfo,             
                                                    lpProcessInformation);
            }
        }
        CSTRING_CATCH
        {
            // Do Nothing
        }
    }

    //
    // Call the original API
    //
    return ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                        lpCommandLine,
                                        lpProcessAttributes,
                                        lpThreadAttributes, 
                                        bInheritHandles,                     
                                        dwCreationFlags,                    
                                        lpEnvironment,                     
                                        lpCurrentDirectory,                
                                        lpStartupInfo,             
                                        lpProcessInformation);
}
    
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\keisoku7.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Keisoku7.cpp

 Abstract:

    The app has an executable bplayer.exe to launch its virtual CD driver. The 
    problem is bplayer.exe is put in start-group and will be launched by 
    explorer.exe, at the time the virtual CD driver is launched, explorer.exe 
    has already finished initialization and cached all local drive info. Fixing 
    this by broadcasting a WM_DEVICECHANGE message.

 Notes: 
  
    This is an app specific shim.

 History:

    06/20/2001 xiaoz    Created

--*/

#include "precomp.h"
#include "Dbt.h"

IMPLEMENT_SHIM_BEGIN(Keisoku7)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(StartServiceA) 
APIHOOK_ENUM_END

/*++

 Hook StartServiceA to broadcast a WM_DEVICECHANGE message 

--*/

BOOL  
APIHOOK(StartServiceA)( 
    SC_HANDLE hService,
    DWORD dwNumServiceArgs,
    LPCSTR *lpServiceArgVectors
    )
{
    BOOL bRet;
    DEV_BROADCAST_VOLUME devbVol;
    
    bRet = ORIGINAL_API(StartServiceA)(hService, dwNumServiceArgs, 
        lpServiceArgVectors);    

    //
    // If succeed, we will broadcast WM_DEVICECHANGE message
    //
    if (bRet)
    {
        devbVol.dbcv_size = sizeof(DEV_BROADCAST_VOLUME);
        devbVol.dbcv_devicetype = DBT_DEVTYP_VOLUME; 
        devbVol.dbcv_reserved = 0; 
        devbVol.dbcv_unitmask = 0x3FFFFF8; // All drives except A: B: C:
        devbVol.dbcv_flags = 0;
        SendMessageTimeout(HWND_BROADCAST, WM_DEVICECHANGE, DBT_DEVICEARRIVAL,
            (LPARAM) &devbVol, SMTO_NOTIMEOUTIFNOTHUNG, 1000, NULL);

        LOGN(eDbgLevelWarning, "WM_DEVICECHANGE broadcasted");        
    }    
    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, StartServiceA)        
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\ispeed.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ISpeed.cpp

 Abstract:

    The app doesn't handle directory/file names with spaces.

 Notes:

    This is an app specific shim.

 History:

    11/15/2000 maonis   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ISpeed)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetDlgItemTextA) 
APIHOOK_ENUM_END

/*++

 After we call GetDlgItemTextA we convert the long path name to the short path name.

--*/

UINT
APIHOOK(GetDlgItemTextA)(
    HWND hDlg,
    int nIDDlgItem,
    LPSTR lpString,
    int nMaxCount    
    )
{
    UINT uiRet = ORIGINAL_API(GetDlgItemTextA)(hDlg, nIDDlgItem, lpString, nMaxCount);

    if (uiRet)
    {
        CSTRING_TRY
        {
            // Check if the title is "iSpeed"
            CString csTitle;
            WCHAR * lpwszBuffer = csTitle.GetBuffer(7);
            int nTitle = GetWindowTextW(hDlg, lpwszBuffer, 7);
            csTitle.ReleaseBuffer(nTitle);

            if (csTitle.CompareNoCase(L"iSpeed") == 0)
            {
                int nIndexSpace = csTitle.Find(L" ");
                if (nIndexSpace >= 0)
                {
                    CString csString(lpString);
                    
                    // If the directory doesn't already exist, we create it so we can get the short path name.
                    if ((GetFileAttributesW(csString) == -1) && (GetLastError() == ERROR_FILE_NOT_FOUND))
                    {
                        if (!CreateDirectoryW(csString, NULL))
                        {
                            return 0;
                        }
                    }

                    csString.GetShortPathNameW();

                    lstrcpynA(lpString, csString.GetAnsi(), nMaxCount);
                    uiRet = _tcslenChars(lpString);
                }
            }
        }
        CSTRING_CATCH
        {
            // Do Nothing
        }
    }

    return uiRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, GetDlgItemTextA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\khunmin2album.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Khunmin2Album.cpp

 Abstract:

    When doing WideCharToMultiByte, the app does not pass the ansi string 
    buffer length correctly, while it seems the app allocates enough big 
    buffer, fix this by correcting the ansi string length, (try-except 
    protected in case the buffer allocated is not enough).

 Notes: 
  
    This is an app specific shim.

 History:

    05/15/2001 xiaoz    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Khunmin2Album)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WideCharToMultiByte) 
APIHOOK_ENUM_END

/*++

 Correct ansi string length if necessary

--*/

int
APIHOOK(WideCharToMultiByte)(
    UINT CodePage,            // code page
    DWORD dwFlags,            // performance and mapping flags
    LPCWSTR lpWideCharStr,    // wide-character string
    int cchWideChar,          // number of chars in string
    LPSTR lpMultiByteStr,     // buffer for new string
    int cbMultiByte,          // size of buffer
    LPCSTR lpDefaultChar,     // default for unmappable chars
    LPBOOL lpUsedDefaultChar  // set when default char used
    )
{

    int nMultiByte;
    int nOriginalMultiByte = cbMultiByte;

    //
    // Get the exact size in byte needed to convert the string from unicode to 
    // ansi 
    //
    nMultiByte = ORIGINAL_API(WideCharToMultiByte)(CodePage, dwFlags, 
        lpWideCharStr, cchWideChar, lpMultiByteStr, 0, lpDefaultChar, 
        lpUsedDefaultChar);
    
    //
    // See if we need to correct the buffer size
    //
    if (nMultiByte > cbMultiByte) 
    {
        LOGN(eDbgLevelWarning, "Buffer size corrected");
        cbMultiByte = nMultiByte;
    }
    
    __try 
    {
        return ORIGINAL_API(WideCharToMultiByte)(CodePage, dwFlags, 
            lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, 
            lpDefaultChar, lpUsedDefaultChar);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        //
        // If somehow exception happens, probally AV , since we enlarge
        // the buffer size, we will use what ever the parameter originally
        // passed in, and do nothing
        //
       return ORIGINAL_API(WideCharToMultiByte)(CodePage, dwFlags, 
           lpWideCharStr, cchWideChar, lpMultiByteStr, nOriginalMultiByte, 
           lpDefaultChar, lpUsedDefaultChar);
    }

}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, WideCharToMultiByte)        

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\javavm.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    JavaVM.cpp

 Abstract:

    Prevent the installation of cab files via rundll32 so that older versions
    of JavaVM do not install non-compatible software.

 Notes:

    This is an app specific shim.

 History:

    05/24/2001  mnikkel  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(JavaVM)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegSetValueExW) 
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END

/*++

  Check Value for rundll32 JavaPkgMgr_Install string.
  Typical string we are looking to stop:
  "rundll32 E:\WINDOWS\System32\msjava.dll,JavaPkgMgr_Install E:\WINDOWS\Java\classes\xmldso.cab,0,0,0,0,4,282"

--*/
BOOL
JavaPkgMgrInstallCheck( const CString & csInput)
{
    DPFN( eDbgLevelSpew, "[JavaPkgMgrInstallCheck] input value:\n(%S)\n", csInput.Get() );

    CSTRING_TRY
    {
        CStringToken csValue(csInput, L",");
        CString csToken;

        // get the first token
        if ( csValue.GetToken(csToken) )
        {
            if ( csToken.Find(L"rundll32 ") > -1 )
            {
                // Second token
                if ( csValue.GetToken(csToken) )
                {
                    if ( csToken.Find(L"JavaPkgMgr_Install ") > -1 )
                    {
                        // Third token
                        if ( csValue.GetToken(csToken) )
                        {
                            if ( csToken.Find(L"0") == 0 )
                            {
                                DPFN( eDbgLevelInfo, "[JavaPkgMgrInstallCheck] Match found, returning TRUE.\n" );
                                return TRUE;
                            }
                        }
                    }
                }
            }
        }             
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return FALSE;
}


/*++

  Check RegSetValueExW for JavaPkgMgr_Install of cabs.  If
  found, return successfully without setting value.

--*/

LONG
APIHOOK(RegSetValueExW)(
    HKEY   hKey,
    LPWSTR lpValueName,
    DWORD  Reserved,
    DWORD  dwType,
    CONST BYTE * lpData,
    DWORD  cbData
    )
{
    DPFN( eDbgLevelSpew, "[RegSetValueExW] dwType:(%d)\n", dwType );

    // Check to see if we are dealing with a string value.
    if (dwType == REG_SZ ||
        dwType == REG_EXPAND_SZ )
    {
        // Convert to unicode and add null terminator.
        CSTRING_TRY
        {
            CString csDest;
            int nWChars = cbData/2;

            WCHAR * lpszDestBuffer = csDest.GetBuffer(nWChars);
            memcpy(lpszDestBuffer, lpData, cbData);
            lpszDestBuffer[nWChars] = '\0';
            csDest.ReleaseBuffer(nWChars);

            DPFN( eDbgLevelSpew, "[RegSetValueExW] lpdata:(%S)\n", csDest.Get() );

            if ( JavaPkgMgrInstallCheck(csDest) )
                return ERROR_SUCCESS;
        }
        CSTRING_CATCH
        {
            // Do Nothing
        }
    }

    //
    // Call the original API
    //
    
    return ORIGINAL_API(RegSetValueExW)(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}

/*++

  Check CreateProcessA for JavaPkgMgr_Install of cabs.  If
  found, return successfully without running.

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                  lpApplicationName,                 
    LPSTR                   lpCommandLine,                      
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, 
    BOOL                    bInheritHandles,                     
    DWORD                   dwCreationFlags,                    
    LPVOID                  lpEnvironment,                     
    LPCSTR                  lpCurrentDirectory,                
    LPSTARTUPINFOA          lpStartupInfo,             
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    DPFN( eDbgLevelSpew, "[CreateProcessA] appname:(%s)\ncommandline:(%s)\n", lpApplicationName, lpCommandLine );

    if (lpCommandLine)
    {
        CSTRING_TRY
        {
            CString csCL(lpCommandLine);

            if ( JavaPkgMgrInstallCheck(csCL) )
            {

                // find the rundll32 and truncate the commandline at that point
                int nLoc = csCL.Find(L"rundll32 ");
                if (nLoc > -1)
                {
                    csCL.Truncate(nLoc+8);

                    return ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                                        csCL.GetAnsi(),
                                                        lpProcessAttributes,
                                                        lpThreadAttributes, 
                                                        bInheritHandles,                     
                                                        dwCreationFlags,                    
                                                        lpEnvironment,                     
                                                        lpCurrentDirectory,                
                                                        lpStartupInfo,             
                                                        lpProcessInformation);
                }
            }
        }
        CSTRING_CATCH
        {
            // Do Nothing
        }
    }

    //
    // Call the original API
    //
    return ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                        lpCommandLine,
                                        lpProcessAttributes,
                                        lpThreadAttributes, 
                                        bInheritHandles,                     
                                        dwCreationFlags,                    
                                        lpEnvironment,                     
                                        lpCurrentDirectory,                
                                        lpStartupInfo,             
                                        lpProcessInformation);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExW)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\kingsquestmask.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    KingsQuestMask.cpp

 Abstract:

    The app calls UnmapViewOfFile with a bogus address - an address that wasn't obtained 
    from MapViewOfFile. We validate the address before calling UnmapViewOfFile.

 History:

    11/20/2000 maonis Created

--*/

#include "precomp.h"

typedef BOOL      (WINAPI *_pfn_UnmapViewOfFile)(LPCVOID lpBaseAddress);

IMPLEMENT_SHIM_BEGIN(KingsQuestMask)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MapViewOfFile)
    APIHOOK_ENUM_ENTRY(UnmapViewOfFile)
APIHOOK_ENUM_END


// Link list of base addresses
struct MAPADDRESS
{
    MAPADDRESS *next;
    LPCVOID pBaseAddress;
};
MAPADDRESS *g_pBaseAddressList;

/*++

 Function Description:

    Add a base address to the linked list of addresses. Does not add if the
    address is NULL or a duplicate.

 Arguments:

    IN  pBaseAddress - base address returned by MapViewOfFile.

 Return Value:

    None

 History:

    11/20/2000 maonis Created

--*/

VOID 
AddBaseAddress(
    IN LPCVOID pBaseAddress
    )
{
    if (pBaseAddress)
    {
        MAPADDRESS *pMapAddress = g_pBaseAddressList;
        while (pMapAddress)
        {
            if (pMapAddress->pBaseAddress == pBaseAddress)
            {
                return;
            }
            pMapAddress = pMapAddress->next;
        }

        pMapAddress = (MAPADDRESS *) malloc(sizeof MAPADDRESS);

        pMapAddress->pBaseAddress = pBaseAddress;
        pMapAddress->next = g_pBaseAddressList;
        g_pBaseAddressList = pMapAddress;
    }
}


/*++

 Function Description:

    Remove a base address if it can be found in the linked list of addresses. 

 Arguments:

    IN  pBaseAddress - the base address to remove.

 Return Value:

    TRUE if the address is found.
    FALSE if the address is not found.

 History:

    11/20/2000 maonis Created

--*/

BOOL 
RemoveBaseAddress(
    IN LPCVOID pBaseAddress
    )
{
    MAPADDRESS *pMapAddress = g_pBaseAddressList;
    MAPADDRESS *last = NULL;
    
    while (pMapAddress)
    {
        if (pMapAddress->pBaseAddress == pBaseAddress)
        {
            if (last)
            {
                last->next = pMapAddress->next;
            }
            else
            {
                g_pBaseAddressList = pMapAddress->next;
            }
            free(pMapAddress);

            return TRUE;    
        }
        last = pMapAddress;
        pMapAddress = pMapAddress->next;
    }

    return FALSE;
}

/*++

 Add the base address to our list.
 
--*/

LPVOID
APIHOOK(MapViewOfFile)(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap
    )
{
    LPVOID pRet = ORIGINAL_API(MapViewOfFile)(    
        hFileMappingObject,
        dwDesiredAccess,
        dwFileOffsetHigh,
        dwFileOffsetLow,
        dwNumberOfBytesToMap);

    AddBaseAddress(pRet);

    DPFN( eDbgLevelInfo, "MapViewOfFile: added base address = 0x%x\n", pRet);

    return pRet;
}

/*++

 Remove the address from our list if it can be found; otherwise do nothing.

--*/

BOOL
APIHOOK(UnmapViewOfFile)(
    LPCVOID lpBaseAddress 
    )
{
    BOOL bRet;

    if (RemoveBaseAddress(lpBaseAddress))
    {
        bRet = ORIGINAL_API(UnmapViewOfFile)(lpBaseAddress);
        if (bRet)
        {
            DPFN( eDbgLevelInfo, "UnmapViewOfFile unmapped address 0x%x\n", lpBaseAddress);
        }

        return bRet;
    }
    else
    {
        DPFN( eDbgLevelError,"UnmapViewOfFile was passed an invalid address 0x%x\n", lpBaseAddress);
        return FALSE;
    }
}

/*++

 Free the list.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_DETACH) {
        DWORD dwCount = 0;
        MAPADDRESS *pMapAddress = g_pBaseAddressList;
        
        while (pMapAddress)
        {
            g_pBaseAddressList = pMapAddress->next;
            ORIGINAL_API(UnmapViewOfFile)(pMapAddress->pBaseAddress);
            free(pMapAddress);
            pMapAddress = g_pBaseAddressList;
            dwCount++;
        }
        
        if (dwCount > 0)
        {
            DPFN( eDbgLevelInfo,"%d addresses not unmapped.", dwCount);
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, MapViewOfFile)
    APIHOOK_ENTRY(KERNEL32.DLL, UnmapViewOfFile)
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\koeisecuritycheck.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   KOEISecurityCheck.cpp

 Abstract:

   This shim sets the SID for TokenOwner at the beginning of the setup.exe. It checks 
   if the administrator group SID is enabled in current process token. If it is enabled then
   we set the TokenOwner SID to administrator group SID. If its not then it does nothing.

 History:

   04/17/2001 zhongyl   create

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(KOEISecurityCheck)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 DisableStickyKeys saves the current value for LPSTICKYKEYS and then disables the option.

--*/

VOID
SetSidForOwner()
{
    BYTE sidBuffer[50];
    PSID pSID = (PSID)&sidBuffer;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL IsMember;
    HANDLE hToken;
    TOKEN_OWNER SIDforOwner;

    // Open a handle to the access token for the calling process.
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_DEFAULT, &hToken ))
        return;      //if OpenProcessToken fails, do nothing
    
    // Create a SID for the BUILTIN\Administrators group.
    if (!AllocateAndInitializeSid(&SIDAuth, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pSID))
        return;      //if AllocateAndInitializedSid fails, do nothing

    // Check if the administrator group SID is enabled in current process token
    if (!CheckTokenMembership(NULL, pSID, &IsMember))
        return;      //if CheckTokenMembership fails, do nothing

    SIDforOwner.Owner = pSID;

    // if the administrator group SID is enabled in current process token, call SetTokenInformation to set the SID for Owner.
    if (IsMember)
        SetTokenInformation(hToken, TokenOwner, &SIDforOwner, sizeof(SIDforOwner));

    return;

}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        SetSidForOwner();
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\mahjonggmadness.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MahjonggMadness.cpp

 Abstract:

    Prevent the app from task switching - it messes with it's synchronization 
    logic.

 Notes:

    This is an app specific shim.

 History:

    11/10/2000 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MahjonggMadness)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShellExecuteA) 
APIHOOK_ENUM_END

/*++

 Ignore this call.

--*/

HINSTANCE 
APIHOOK(ShellExecuteA)(
    HWND hwnd, 
    LPCTSTR lpOperation,
    LPCTSTR lpFile, 
    LPCTSTR lpParameters, 
    LPCTSTR lpDirectory,
    INT nShowCmd
    )
{
    // Return minimum error code
    return (HINSTANCE)32;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\lotusorganizer5.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    LotusOrganizer5.cpp
    
 Abstract:

    Yield on ResumeThread to avoid poor design and race condition is the app.

 Notes:

    This is an app specific shim.

 History:

    02/17/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LotusOrganizer5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ResumeThread)
APIHOOK_ENUM_END

/*++

 Delay ResumeThread a little bit to avoid a race condition

--*/

BOOL
APIHOOK(ResumeThread)(
    HANDLE hThread
    )
{
    DWORD dwRet;

    Sleep(0);

    dwRet = ORIGINAL_API(ResumeThread)(hThread);

    return dwRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, ResumeThread)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\lhvoicexpressplus.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    LHVoiceXPressPlus.cpp

 Abstract:

    App passes a .hlp without path. Winhlp32 can't locate the file because 
    it's not in any of the locations that winhlp32 looks at. We pass in
    the file with full path.

 History:

    01/28/2001 maonis Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LHVoiceXPressPlus)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WinHelpA) 
APIHOOK_ENUM_END

BOOL 
APIHOOK(WinHelpA)(
    HWND hWndMain,
    LPCSTR lpszHelp,
    UINT uCommand,
    DWORD dwData
    )
{
    CSTRING_TRY
    {
        CString csHelp(lpszHelp);
    
        if (csHelp.CompareNoCase(L"Correction.hlp") == 0)
        {
            // The way we get the directory for the app is we look into the 
            // registry and get the location of the inproc server ksysint.dll.
            // Coolpad.exe always loads this dll - if you don't have this dll
            // registered, you can't run the app anyway.
            HKEY hkey;
            DWORD type;
            DWORD cbPath = MAX_PATH;
            CString csRegValue;
            WCHAR * lpszNewHelpFile = csRegValue.GetBuffer(cbPath);
    
            const WCHAR szInprocServer[] = L"CLSID\\{B9C12481-D072-11D0-9E80-0060976FD1F8}\\InprocServer32";
    
            if (RegOpenKeyExW(HKEY_CLASSES_ROOT, szInprocServer, 0, KEY_READ, &hkey) == ERROR_SUCCESS) 
            {
                LONG lRet = RegQueryValueExW(hkey, NULL, 0, &type, (LPBYTE)lpszNewHelpFile, &cbPath);
                if (lRet == ERROR_SUCCESS)
                {
                    RegCloseKey(hkey);
                    csRegValue.ReleaseBuffer(cbPath);
                    csRegValue.Replace(L"ksysint.dll", L"Correction.hlp");
    
                    return ORIGINAL_API(WinHelpA)(hWndMain, csRegValue.GetAnsi(), uCommand, dwData);
                }
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(WinHelpA)(hWndMain, lpszHelp, uCommand, dwData); 
}

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, WinHelpA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\linksextreme.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    LinksExtreme.cpp

 Abstract:

    This app cannot recognise the MIDI technology flags properly.
    The app's internal logic cannot handle the last two technology 
    flags viz. MOD_WAVETABLE and MOD_SWSYNTH. If these flags are 
    returned by the call to MidiOutGetDevCapsA API, the app shows 
    a messagebox and restarts after playing for a while.(AV's).

 Notes:

    This is specific to this app.

 History:

    06/20/2001 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LinksExtreme)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(midiOutGetDevCapsA)
APIHOOK_ENUM_END


/*++

 This stub function fixes the returned wTechnology flags.

--*/

MMRESULT 
APIHOOK(midiOutGetDevCapsA)(
    UINT_PTR       uDeviceID,
    LPMIDIOUTCAPSA pmoc,
    UINT           cbmoc
    )
{
    MMRESULT mRes = ORIGINAL_API(midiOutGetDevCapsA)(
                            uDeviceID, 
                            pmoc, 
                            cbmoc);

    if (mRes == MMSYSERR_NOERROR)
    {
        if ((pmoc->wTechnology & MOD_WAVETABLE) ||
            (pmoc->wTechnology & MOD_SWSYNTH))
        {
            pmoc->wTechnology &= ~MOD_WAVETABLE;
            pmoc->wTechnology &= ~MOD_SWSYNTH;
            // Use any of the first five wTechnology flags !!
            pmoc->wTechnology |= MOD_FMSYNTH;
            LOGN( eDbgLevelInfo, 
                "[midiOutGetDevCapsA] Fixed the wTechnology flags" );
        }
    }

    return mRes;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, midiOutGetDevCapsA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\mastersoforion2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MastersOfOrion2.cpp

 Abstract:

    This shim is designed to fix a synchronization issue which occurs when 
    SendMessage is called on a different thread from the window proc. I've not 
    confirmed this, but it looks as if SendMessage will relinquish control to 
    the thread with the window proc on Win9x. 

    The effect on an application can be varied. In Masters of Orion II, the 
    mouse cursor stops moving.

 Notes:

    This is an app specific shim.

 History:

    04/19/2000 linstev  Created
    06/06/2001 linstev  Added fix for heap problems

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MastersOfOrion2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SendMessageA) 
    APIHOOK_ENUM_ENTRY(LocalAlloc) 
APIHOOK_ENUM_END

/*++

 Make sure we switch threads after the SendMessage.

--*/

LRESULT
APIHOOK(SendMessageA)(
    HWND hWnd,      
    UINT Msg,       
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    LRESULT lRet = ORIGINAL_API(SendMessageA)(
        hWnd,
        Msg,
        wParam,
        lParam);

    SwitchToThread();

    return lRet;
}

/*++

 Pad allocations for Ddraw surfaces so they don't trash Ddraw structures.

--*/

HLOCAL
APIHOOK(LocalAlloc)(
    UINT uFlags,
    SIZE_T uBytes
    )
{
    if (uBytes >= 640*480) {
        //
        // This is probably a screen size surface
        //
        uBytes += 4096;
    }

    return ORIGINAL_API(LocalAlloc)(uFlags, uBytes);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SendMessageA)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalAlloc)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\maxpayne.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    MaxPayne.cpp

 Abstract:

    They try to size their window to the entire screen and use the wrong system 
    metrics. This shim just redirects them to the ones they should be using so 
    the taskbar doesn't flicker through into the game. 

    This is not a Win9x regression, but since there is so much more activity in 
    the task bar area on XP, it's much more noticable.

 Notes:

    This is an app specific shim.

 History:

    07/31/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MaxPayne)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetSystemMetrics) 
APIHOOK_ENUM_END

/*++

 Redirect SM_C?FULLSCREEN to SM_C?SCREEN.

--*/

int
APIHOOK(GetSystemMetrics)(
    int nIndex
    )
{
    if (nIndex == SM_CXFULLSCREEN) {
        nIndex = SM_CXSCREEN;
    } else if (nIndex == SM_CYFULLSCREEN) {
        nIndex = SM_CYSCREEN;
    }

    return ORIGINAL_API(GetSystemMetrics)(nIndex);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, GetSystemMetrics)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\mathblaster9_12.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MathBlaster9_12.cpp

 Abstract:
     
    App requires lookaside on VirtualAllocs...
     
 Notes:

    This is an appspecific shim.

 History:
           
    10/10/2000 linstev   Created 
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MathBlaster9_12)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(VirtualAlloc) 
    APIHOOK_ENUM_ENTRY(VirtualFree) 
APIHOOK_ENUM_END

LPVOID g_pLast = NULL;

/*++

 Use the cached value.

--*/

LPVOID 
APIHOOK(VirtualAlloc)(
    LPVOID lpAddress, 
    DWORD dwSize,     
    DWORD flAllocationType,
    DWORD flProtect   
    )
{
    LPVOID pRet = 0;

    if (!lpAddress && g_pLast)    
    {   
        pRet =  ORIGINAL_API(VirtualAlloc)(g_pLast, dwSize, flAllocationType, flProtect);
    }

    if (!pRet) 
    {
        pRet =  ORIGINAL_API(VirtualAlloc)(lpAddress, dwSize, flAllocationType, flProtect);
    }

    return pRet;
}

/*++

 Use the cached value.

--*/

BOOL 
APIHOOK(VirtualFree)(
    LPVOID lpAddress,
    DWORD dwSize,    
    DWORD dwFreeType )
{
    
    BOOL bRet = ORIGINAL_API(VirtualFree)(lpAddress, dwSize, dwFreeType);

    if (bRet)
    {
        g_pLast = lpAddress;
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(Kernel32.DLL, VirtualAlloc )
    APIHOOK_ENTRY(Kernel32.DLL, VirtualFree )

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\main.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AppSpecific.cpp

 Abstract:


 Notes:

 History:

    10/28/2000 markder Created

--*/

#include "precomp.h"

#include "ShimHookMacro.h"

DECLARE_SHIM(3DFrogFrenzy)
DECLARE_SHIM(Acrobat5)
DECLARE_SHIM(AdobeLiveMotion)
DECLARE_SHIM(AfterDark)
DECLARE_SHIM(AliensVsPredator)
DECLARE_SHIM(AOLFindBundledInstaller)
DECLARE_SHIM(AOLRasSetEntryProperties)
DECLARE_SHIM(AOLSystemInfo)
DECLARE_SHIM(Attune)
DECLARE_SHIM(AutoCad)
DECLARE_SHIM(AutoDeskWorld2)
DECLARE_SHIM(BaanERP5)
DECLARE_SHIM(BaanERP5c)
DECLARE_SHIM(BaanIV)
DECLARE_SHIM(BackOffice45Suite)
DECLARE_SHIM(BaseBall2000)
DECLARE_SHIM(Battleship)
DECLARE_SHIM(BattleZone)
DECLARE_SHIM(BeyondAtlantis)
DECLARE_SHIM(BigActionConstruction)
DECLARE_SHIM(BigGameHunter3)
DECLARE_SHIM(BizPlanBuilder)
DECLARE_SHIM(BoeingFix)
DECLARE_SHIM(Britannica2001)
DECLARE_SHIM(Canvas6)
DECLARE_SHIM(CanvasCheckedButtons)
DECLARE_SHIM(Casper)
DECLARE_SHIM(ChemOffice)
DECLARE_SHIM(Chollian2000)
DECLARE_SHIM(Chollian2000Plus)
DECLARE_SHIM(ClueFinders3rdGrade)
DECLARE_SHIM(CoffeeCupHTMLEditor)
DECLARE_SHIM(Commandos)
DECLARE_SHIM(Cossacks)
DECLARE_SHIM(ComptonsBible)
DECLARE_SHIM(CorelAppsRegistration)
DECLARE_SHIM(CorelDraw9JPN)
DECLARE_SHIM(CorelSiteBuilder)
DECLARE_SHIM(CreateResumesQuickandEasy)
DECLARE_SHIM(CreativeOnScreenDisplay)
DECLARE_SHIM(CrystalWebPageServer)
DECLARE_SHIM(CUSeeMe4)
DECLARE_SHIM(Descent2)
DECLARE_SHIM(DinosaurActivityCenter)
DECLARE_SHIM(DirtTrackRacing)
DECLARE_SHIM(DominantSpecies)
DECLARE_SHIM(DongFangKuaiChe3000Setup)
DECLARE_SHIM(DongFangYingDu)
DECLARE_SHIM(DrEye)
DECLARE_SHIM(EA3dSetup)
DECLARE_SHIM(EasyCDCreator4)
DECLARE_SHIM(EasyCDCreator5)
DECLARE_SHIM(EncartaEncyclopediaDeluxe2K)
DECLARE_SHIM(EncompassMonitor)
DECLARE_SHIM(EuropeanAirWar)
DECLARE_SHIM(ExchangeServerSetup)
DECLARE_SHIM(F18Carrier)
DECLARE_SHIM(FireFighters)
DECLARE_SHIM(Force21)
DECLARE_SHIM(Gangsters)
DECLARE_SHIM(Gizmos)
DECLARE_SHIM(HeroSDVD)
DECLARE_SHIM(HotFaxMessageCenter4)
DECLARE_SHIM(HoyleGames)
DECLARE_SHIM(HPTourGuide)
DECLARE_SHIM(HTMLEditor8587)
DECLARE_SHIM(IConfig)
DECLARE_SHIM(IE5DOMSetup)
DECLARE_SHIM(InstallShield6)
DECLARE_SHIM(IntelVideoPhone)
DECLARE_SHIM(ISA)
DECLARE_SHIM(ISpeed)
DECLARE_SHIM(JavaVM)
DECLARE_SHIM(JavaVM2)
DECLARE_SHIM(JetFighter4)
DECLARE_SHIM(Keisoku7)
DECLARE_SHIM(Khunmin2Album)
DECLARE_SHIM(KingsQuestMask)
DECLARE_SHIM(KOEISecurityCheck)
DECLARE_SHIM(LHVoiceXPressPlus)
DECLARE_SHIM(LinksExtreme)
DECLARE_SHIM(LotusOrganizer5)
DECLARE_SHIM(MahjonggMadness)
DECLARE_SHIM(MastersOfOrion2)
DECLARE_SHIM(MathBlaster9_12)
DECLARE_SHIM(MaxPayne)
DECLARE_SHIM(MECCommander)
DECLARE_SHIM(MechWarrior2)
DECLARE_SHIM(MidTownMadness2)
DECLARE_SHIM(Millionaire)
DECLARE_SHIM(MindSpring4)
DECLARE_SHIM(ModemWizard)
DECLARE_SHIM(Money2001)
DECLARE_SHIM(Money2002)
DECLARE_SHIM(MSAccess2000IME)
DECLARE_SHIM(MSDevDisabledButtons)
DECLARE_SHIM(MSWorks6)
DECLARE_SHIM(MyPhotoCenter2)
DECLARE_SHIM(NBALive)
DECLARE_SHIM(NetObjectsFusion5)
DECLARE_SHIM(NetManageViewNow)
DECLARE_SHIM(NetZip)
DECLARE_SHIM(NewShenDiaoXiaLv)
DECLARE_SHIM(NFLBlitz)
DECLARE_SHIM(NFLFever2000)
DECLARE_SHIM(NHL2001)
DECLARE_SHIM(NikonView)
DECLARE_SHIM(Omikron)
DECLARE_SHIM(OmniPage)
DECLARE_SHIM(OmniPagePro11Uninstall)
DECLARE_SHIM(OperationsManager)
DECLARE_SHIM(Outlook2000)
DECLARE_SHIM(Outlook97)
DECLARE_SHIM(Outlook98Wizard)
DECLARE_SHIM(OverlayPro)
DECLARE_SHIM(PanzerCommander)
DECLARE_SHIM(Petz)
DECLARE_SHIM(PickyEater)
DECLARE_SHIM(Pirch98)
DECLARE_SHIM(PlaneCrazy)
DECLARE_SHIM(PostIt2)
DECLARE_SHIM(PowerBuilder)
DECLARE_SHIM(Ppo3svrScr)
DECLARE_SHIM(PrintMaster4)
DECLARE_SHIM(ProAtlas2000)
DECLARE_SHIM(Quicken2000)
DECLARE_SHIM(Quicken2001)
DECLARE_SHIM(QuickTime5)
DECLARE_SHIM(RCenter)
DECLARE_SHIM(ResumeWriter3)
DECLARE_SHIM(ReturnToKrondor)
DECLARE_SHIM(RiskII)
DECLARE_SHIM(Riven)
DECLARE_SHIM(RumbaOffice)
DECLARE_SHIM(SafeDisc)
DECLARE_SHIM(SchoolHouseRockMath)
DECLARE_SHIM(SevenKingdoms)
DECLARE_SHIM(Settlers3)
DECLARE_SHIM(ShockwaveLocation)
DECLARE_SHIM(SierraCartRacing)
DECLARE_SHIM(Simply3D)
DECLARE_SHIM(SirenJukebox2)
DECLARE_SHIM(SolidWorks99Plus)
DECLARE_SHIM(SpecOps2)
DECLARE_SHIM(SpeechViewer3)
DECLARE_SHIM(StoneAge)
DECLARE_SHIM(Suda2000)
DECLARE_SHIM(Summoner)
DECLARE_SHIM(SuperBike)
DECLARE_SHIM(SuperChix76)
DECLARE_SHIM(SysAdmiral)
DECLARE_SHIM(TaskbarAndStartMenuProperty)
DECLARE_SHIM(ThreeDJungleTrain)
DECLARE_SHIM(TimeSlips)
DECLARE_SHIM(TonkaConstruction)
DECLARE_SHIM(TreasureCove)
DECLARE_SHIM(TurkeyHunter)
DECLARE_SHIM(TwinssensOdyssey)
DECLARE_SHIM(Ultima9)
DECLARE_SHIM(UltimateSoccerManager)
DECLARE_SHIM(UltraWinCleaner2002)
DECLARE_SHIM(UnInstallShield)
DECLARE_SHIM(UrbanChaos)
DECLARE_SHIM(USNF97)
DECLARE_SHIM(ViaVoice8J)
DECLARE_SHIM(ViperRacing)
DECLARE_SHIM(VJEDelta)
DECLARE_SHIM(VJEDeltaSetup)
DECLARE_SHIM(VSAnalyzerServerSetup)
DECLARE_SHIM(WebPage6)
DECLARE_SHIM(WinFaxPro9)
DECLARE_SHIM(WinStone99)
DECLARE_SHIM(WordPerfect8)
DECLARE_SHIM(WordPerfect9_1)
DECLARE_SHIM(WordPerfect9_2)
DECLARE_SHIM(WordPerfect9_3)
DECLARE_SHIM(Works99)
DECLARE_SHIM(WorksSuite2001)
DECLARE_SHIM(Worms2)
DECLARE_SHIM(WPS2000)
DECLARE_SHIM(ZenWorks)

VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPF("AcSpecfc", eDbgLevelSpew, "Application Specific Shims initialized.");
            break;
    
        case DLL_PROCESS_DETACH:
            DPF("AcSpecfc", eDbgLevelSpew, "Application Specific Shims uninitialized.");
            break;

        default:
            break;
    }
}

MULTISHIM_BEGIN()
    MULTISHIM_ENTRY(3DFrogFrenzy)
    MULTISHIM_ENTRY(Acrobat5)
    MULTISHIM_ENTRY(AdobeLiveMotion)
    MULTISHIM_ENTRY(AfterDark)
    MULTISHIM_ENTRY(AliensVsPredator)
    MULTISHIM_ENTRY(AOLFindBundledInstaller)
    MULTISHIM_ENTRY(AOLRasSetEntryProperties)
    MULTISHIM_ENTRY(AOLSystemInfo)    
    MULTISHIM_ENTRY(Attune)
    MULTISHIM_ENTRY(AutoCad)
    MULTISHIM_ENTRY(AutoDeskWorld2)
    MULTISHIM_ENTRY(BaanERP5)
    MULTISHIM_ENTRY(BaanERP5c)
    MULTISHIM_ENTRY(BaanIV)
    MULTISHIM_ENTRY(BackOffice45Suite)
    MULTISHIM_ENTRY(BaseBall2000)
    MULTISHIM_ENTRY(Battleship)
    MULTISHIM_ENTRY(BattleZone)
    MULTISHIM_ENTRY(BeyondAtlantis)
    MULTISHIM_ENTRY(BigActionConstruction)
    MULTISHIM_ENTRY(BigGameHunter3)
    MULTISHIM_ENTRY(BizPlanBuilder)
    MULTISHIM_ENTRY(BoeingFix)
    MULTISHIM_ENTRY(Britannica2001)
    MULTISHIM_ENTRY(Canvas6)
    MULTISHIM_ENTRY(CanvasCheckedButtons)
    MULTISHIM_ENTRY(Casper)
    MULTISHIM_ENTRY(ChemOffice)
    MULTISHIM_ENTRY(ClueFinders3rdGrade)
    MULTISHIM_ENTRY(Chollian2000)
    MULTISHIM_ENTRY(Chollian2000Plus)
    MULTISHIM_ENTRY(CoffeeCupHTMLEditor)
    MULTISHIM_ENTRY(Commandos)
    MULTISHIM_ENTRY(Cossacks)
    MULTISHIM_ENTRY(ComptonsBible)
    MULTISHIM_ENTRY(CorelAppsRegistration)
    MULTISHIM_ENTRY(CorelDraw9JPN)
    MULTISHIM_ENTRY(CorelSiteBuilder)
    MULTISHIM_ENTRY(CreateResumesQuickandEasy)
    MULTISHIM_ENTRY(CreativeOnScreenDisplay)
    MULTISHIM_ENTRY(CrystalWebPageServer)
    MULTISHIM_ENTRY(CUSeeMe4)
    MULTISHIM_ENTRY(Descent2)    
    MULTISHIM_ENTRY(DinosaurActivityCenter)
    MULTISHIM_ENTRY(DirtTrackRacing)
    MULTISHIM_ENTRY(DominantSpecies)
    MULTISHIM_ENTRY(DongFangKuaiChe3000Setup)
    MULTISHIM_ENTRY(DongFangYingDu)
    MULTISHIM_ENTRY(DrEye)
    MULTISHIM_ENTRY(EA3dSetup)
    MULTISHIM_ENTRY(EasyCDCreator4)
    MULTISHIM_ENTRY(EasyCDCreator5)
    MULTISHIM_ENTRY(EncartaEncyclopediaDeluxe2K)
    MULTISHIM_ENTRY(EncompassMonitor)
    MULTISHIM_ENTRY(EuropeanAirWar)
    MULTISHIM_ENTRY(ExchangeServerSetup)
    MULTISHIM_ENTRY(F18Carrier)
    MULTISHIM_ENTRY(FireFighters)
    MULTISHIM_ENTRY(Force21)
    MULTISHIM_ENTRY(Gangsters)
    MULTISHIM_ENTRY(Gizmos)
    MULTISHIM_ENTRY(HeroSDVD)
    MULTISHIM_ENTRY(HotFaxMessageCenter4)
    MULTISHIM_ENTRY(HoyleGames)
    MULTISHIM_ENTRY(HPTourGuide)    
    MULTISHIM_ENTRY(HTMLEditor8587)
    MULTISHIM_ENTRY(IConfig)
    MULTISHIM_ENTRY(IE5DOMSetup)
    MULTISHIM_ENTRY(InstallShield6)
    MULTISHIM_ENTRY(IntelVideoPhone)
    MULTISHIM_ENTRY(ISA)
    MULTISHIM_ENTRY(ISpeed)
    MULTISHIM_ENTRY(JavaVM)
    MULTISHIM_ENTRY(JavaVM2)
    MULTISHIM_ENTRY(JetFighter4)
    MULTISHIM_ENTRY(Keisoku7)
    MULTISHIM_ENTRY(Khunmin2Album)
    MULTISHIM_ENTRY(KingsQuestMask)
    MULTISHIM_ENTRY(KOEISecurityCheck)
    MULTISHIM_ENTRY(LHVoiceXPressPlus)
    MULTISHIM_ENTRY(LinksExtreme)
    MULTISHIM_ENTRY(LotusOrganizer5)
    MULTISHIM_ENTRY(MahjonggMadness)
    MULTISHIM_ENTRY(MastersOfOrion2)
    MULTISHIM_ENTRY(MathBlaster9_12)
    MULTISHIM_ENTRY(MaxPayne)
    MULTISHIM_ENTRY(MECCommander)
    MULTISHIM_ENTRY(MechWarrior2)
    MULTISHIM_ENTRY(MidTownMadness2)
    MULTISHIM_ENTRY(Millionaire)
    MULTISHIM_ENTRY(MindSpring4)
    MULTISHIM_ENTRY(ModemWizard)
    MULTISHIM_ENTRY(Money2001)
    MULTISHIM_ENTRY(Money2002)
    MULTISHIM_ENTRY(MSAccess2000IME)
    MULTISHIM_ENTRY(MSDevDisabledButtons)
    MULTISHIM_ENTRY(MSWorks6)
    MULTISHIM_ENTRY(MyPhotoCenter2)
    MULTISHIM_ENTRY(NBALive)
    MULTISHIM_ENTRY(NetObjectsFusion5)
    MULTISHIM_ENTRY(NetManageViewNow)
    MULTISHIM_ENTRY(NetZip)
    MULTISHIM_ENTRY(NewShenDiaoXiaLv)
    MULTISHIM_ENTRY(NFLBlitz)
    MULTISHIM_ENTRY(NFLFever2000)
    MULTISHIM_ENTRY(NHL2001)
    MULTISHIM_ENTRY(NikonView)
    MULTISHIM_ENTRY(Omikron)
    MULTISHIM_ENTRY(OmniPage)
    MULTISHIM_ENTRY(OmniPagePro11Uninstall)
    MULTISHIM_ENTRY(OperationsManager)
    MULTISHIM_ENTRY(Outlook2000)
    MULTISHIM_ENTRY(Outlook97)
    MULTISHIM_ENTRY(Outlook98Wizard)
    MULTISHIM_ENTRY(OverlayPro)
    MULTISHIM_ENTRY(PanzerCommander)
    MULTISHIM_ENTRY(Petz)
    MULTISHIM_ENTRY(PickyEater)
    MULTISHIM_ENTRY(Pirch98)
    MULTISHIM_ENTRY(PlaneCrazy)
    MULTISHIM_ENTRY(PowerBuilder)
    MULTISHIM_ENTRY(Ppo3svrScr)
    MULTISHIM_ENTRY(PrintMaster4)
    MULTISHIM_ENTRY(ProAtlas2000)
    MULTISHIM_ENTRY(PostIt2)
    MULTISHIM_ENTRY(Quicken2000)
    MULTISHIM_ENTRY(Quicken2001)
    MULTISHIM_ENTRY(QuickTime5)
    MULTISHIM_ENTRY(RCenter)
    MULTISHIM_ENTRY(ResumeWriter3)
    MULTISHIM_ENTRY(ReturnToKrondor)
    MULTISHIM_ENTRY(RiskII)
    MULTISHIM_ENTRY(Riven)
    MULTISHIM_ENTRY(RumbaOffice)
    MULTISHIM_ENTRY(SafeDisc)
    MULTISHIM_ENTRY(SchoolHouseRockMath)
    MULTISHIM_ENTRY(Settlers3)
    MULTISHIM_ENTRY(SevenKingdoms)
    MULTISHIM_ENTRY(ShockwaveLocation)
    MULTISHIM_ENTRY(SierraCartRacing)
    MULTISHIM_ENTRY(Simply3D)
    MULTISHIM_ENTRY(SirenJukebox2)
    MULTISHIM_ENTRY(SolidWorks99Plus)
    MULTISHIM_ENTRY(SpecOps2)
    MULTISHIM_ENTRY(SpeechViewer3)
    MULTISHIM_ENTRY(StoneAge)
    MULTISHIM_ENTRY(Suda2000)
    MULTISHIM_ENTRY(Summoner)
    MULTISHIM_ENTRY(SuperBike)
    MULTISHIM_ENTRY(SuperChix76)
    MULTISHIM_ENTRY(SysAdmiral)
    MULTISHIM_ENTRY(TaskbarAndStartMenuProperty)
    MULTISHIM_ENTRY(ThreeDJungleTrain)
    MULTISHIM_ENTRY(TimeSlips)
    MULTISHIM_ENTRY(TonkaConstruction)
    MULTISHIM_ENTRY(TreasureCove)
    MULTISHIM_ENTRY(TurkeyHunter)
    MULTISHIM_ENTRY(TwinssensOdyssey)
    MULTISHIM_ENTRY(Ultima9)
    MULTISHIM_ENTRY(UltimateSoccerManager)
    MULTISHIM_ENTRY(UltraWinCleaner2002)
    MULTISHIM_ENTRY(UnInstallShield)
    MULTISHIM_ENTRY(UrbanChaos)
    MULTISHIM_ENTRY(USNF97)
    MULTISHIM_ENTRY(ViaVoice8J)
    MULTISHIM_ENTRY(ViperRacing)
    MULTISHIM_ENTRY(VJEDelta)
    MULTISHIM_ENTRY(VJEDeltaSetup)
    MULTISHIM_ENTRY(VSAnalyzerServerSetup)
    MULTISHIM_ENTRY(WebPage6)
    MULTISHIM_ENTRY(WinFaxPro9)
    MULTISHIM_ENTRY(WinStone99)
    MULTISHIM_ENTRY(WordPerfect8)
    MULTISHIM_ENTRY(WordPerfect9_1)
    MULTISHIM_ENTRY(WordPerfect9_2)
    MULTISHIM_ENTRY(WordPerfect9_3)
    MULTISHIM_ENTRY(Works99)
    MULTISHIM_ENTRY(WorksSuite2001)
    MULTISHIM_ENTRY(Worms2)
    MULTISHIM_ENTRY(WPS2000)
    MULTISHIM_ENTRY(ZenWorks)

    CALL_MULTISHIM_NOTIFY_FUNCTION()
MULTISHIM_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\meccommander.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MECCommander.cpp

 Abstract:

    This dll prevents the MEC Commander install program from successfully
    calling the cpuid.exe. This is because the cpuid.exe can AV's with a
    divide by 0.

 Notes:

    This is an app specific shim.

 History:

    11/18/1999 philipdu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MECCommander)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END


/*++

 We do not want to run this application since it AV's with a divide by zero 
 calculation. The only purpose for this exe is to time the CPU. Since the 
 final result of this calculation is a string in a dialog box we can safely 
 bypass this. The app puts a string "Pentinum 166 or Better recommented" in
 the cases where it cannot get the CPU frequency. The interesting thing 
 here is that the app will actually run better with this patch since this 
 cpuid exe also faults on 9x.

--*/

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    BOOL bRet;

    CSTRING_TRY
    {
        AppAndCommandLine acl(lpApplicationName, lpCommandLine);
        if (acl.GetApplicationName().CompareNoCase(L"cpuid.exe") == 0)
        {
            return FALSE;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    bRet = ORIGINAL_API(CreateProcessA)(
        lpApplicationName,
        lpCommandLine,
        lpProcessAttributes,
        lpThreadAttributes,
        bInheritHandles,
        dwCreationFlags,
        lpEnvironment,
        lpCurrentDirectory,
        lpStartupInfo,
        lpProcessInformation);

    return bRet;
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    APIHOOK_ENTRY(Kernel32.DLL, CreateProcessA )

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\millionaire.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Millionaire.cpp

 Abstract:

    On Win9x, paint messages did not always cause WM_ERASEBKGND messages. This 
    is for applications that paint themselves before the WM_PAINT message and
    then pass WM_PAINT onto the default handler.

 Notes:

    This is a general purpose shim, but should not be in a layer.

 History:

    06/05/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Millionaire)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA) 
    APIHOOK_ENUM_ENTRY(RegisterClassW) 
    APIHOOK_ENUM_ENTRY(RegisterClassExA) 
    APIHOOK_ENUM_ENTRY(RegisterClassExW) 
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
    APIHOOK_ENUM_ENTRY(SetWindowLongW) 
APIHOOK_ENUM_END

/*++

 Handle paint messages

--*/

LRESULT 
CALLBACK 
Millionaire_WindowProcHook(
    WNDPROC pfnOld, 
    HWND hwnd,      
    UINT uMsg,      
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    switch( uMsg )
    {
        case WM_PAINT: 
            RECT r;
            
            if (GetUpdateRect(hwnd, &r, FALSE))
            {
                DPFN( eDbgLevelSpew, "Validating on paint");

                ValidateRect(hwnd, &r);
            }

            break;

            default: break;
    }
        
    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}

/*++

 The dialogproc hook

--*/

INT_PTR 
CALLBACK 
Millionaire_DialogProcHook(
    DLGPROC   pfnOld,   
    HWND      hwndDlg,  
    UINT      uMsg,     
    WPARAM    wParam,   
    LPARAM    lParam    
    )
{
    return (*pfnOld)(hwndDlg, uMsg, wParam, lParam);    
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  
    )
{
    WNDCLASSA wcNewWndClass = *lpWndClass;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, Millionaire_WindowProcHook);

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassW)(
    CONST WNDCLASSW *lpWndClass  
    )
{
    WNDCLASSW wcNewWndClass = *lpWndClass;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, Millionaire_WindowProcHook);

    return ORIGINAL_API(RegisterClassW)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  
    )
{
    WNDCLASSEXA wcNewWndClass = *lpwcx;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpwcx->lpfnWndProc, Millionaire_WindowProcHook);

    return ORIGINAL_API(RegisterClassExA)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassExW)(
    CONST WNDCLASSEXW *lpwcx  
    )
{
    WNDCLASSEXW wcNewWndClass = *lpwcx;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpwcx->lpfnWndProc, Millionaire_WindowProcHook);

    return ORIGINAL_API(RegisterClassExW)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Millionaire_WindowProcHook);
    }
    else if (nIndex == DWL_DLGPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Millionaire_DialogProcHook);
    }

    return ORIGINAL_API(SetWindowLongA)(
        hWnd,
        nIndex,
        dwNewLong);
}

/*++

 Hook the wndproc

--*/

LONG 
APIHOOK(SetWindowLongW)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC)
    { 
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Millionaire_WindowProcHook);
    }
    else if (nIndex == DWL_DLGPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Millionaire_DialogProcHook);
    }

    return ORIGINAL_API(SetWindowLongA)(
        hWnd,
        nIndex,
        dwNewLong);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassW)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExW)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\mechwarrior2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MechWarrior2.cpp

 Abstract:
     
    This shim fixes a problem with MW2 expecting BitBlt to return a specific 
    value, contrary to the published documentation. It also fixes a situation 
    in which a thread calls "SuspendThread" on itself, killing itself.
     
 Notes:

    This shim is specific to Mechwarrior, though potentially some of this could 
    be applied to other apps that use the AIL32 libraries.

 History:
           
    05/16/2000 dmunsil  Created 
   
--*/

#include "precomp.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

IMPLEMENT_SHIM_BEGIN(MechWarrior2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(BitBlt) 
    APIHOOK_ENUM_ENTRY(SuspendThread) 
    APIHOOK_ENUM_ENTRY(ResumeThread) 
APIHOOK_ENUM_END

DWORD dwGetThreadID(HANDLE hThread)
{
    THREAD_BASIC_INFORMATION ThreadBasicInfo;
    NTSTATUS Status;
    TEB teb;

    Status = NtQueryInformationThread(
                hThread,
                ThreadBasicInformation,
                &ThreadBasicInfo,
                sizeof(ThreadBasicInfo),
                NULL
                );

    if (!NT_SUCCESS(Status)) {
        DPFN( eDbgLevelError, "NtQueryInfomationThread failed\n");
        return 0;
    }

    return (DWORD)ThreadBasicInfo.ClientId.UniqueThread;
}

/*++

 Return what Mechwarrior is expecting from BitBlt

--*/

BOOL
APIHOOK(BitBlt)(
    HDC hdcDest, // handle to destination DC
    int nXDest,  // x-coord of destination upper-left corner
    int nYDest,  // y-coord of destination upper-left corner
    int nWidth,  // width of destination rectangle
    int nHeight, // height of destination rectangle
    HDC hdcSrc,  // handle to source DC
    int nXSrc,   // x-coordinate of source upper-left corner
    int nYSrc,   // y-coordinate of source upper-left corner
    DWORD dwRop  // raster operation code
    )
{
    BOOL bRet;
    
    bRet = ORIGINAL_API(BitBlt)(
        hdcDest,
        nXDest,
        nYDest,
        nWidth,
        nHeight,
        hdcSrc,
        nXSrc,
        nYSrc,
        dwRop
        );

    if (bRet) {
        bRet = 0x1e0; // this is what MechWarrior expects to be returned.
    }

    return bRet;
}

/*++

 Disallow suspending self

--*/

DWORD 
APIHOOK(SuspendThread)(
    HANDLE hThread   // handle to the thread
    )
{
    // if we're trying to suspend our own thread, refuse
    if (dwGetThreadID(hThread) != dwGetThreadID(GetCurrentThread())) {
        return ORIGINAL_API(SuspendThread)(hThread);
    } else {
        return 0;
    }
}

/*++

 Disallow resuming self, for same reason

--*/

DWORD 
APIHOOK(ResumeThread)(
    HANDLE hThread   // handle to the thread
    )
{
    // if we're trying to resume our own thread, refuse
    if (dwGetThreadID(hThread) != dwGetThreadID(GetCurrentThread())) {
        return ORIGINAL_API(SuspendThread)(hThread);
    } else {
        return 0;
    }
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    APIHOOK_ENTRY(GDI32.DLL, BitBlt )
    APIHOOK_ENTRY(Kernel32.DLL, SuspendThread )
    APIHOOK_ENTRY(Kernel32.DLL, ResumeThread )

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\midtownmadness2.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    MidTownMadness2.cpp

 Abstract:
    
    This app has a funky timing system whereby it waits for the processor that 
    it's running on to return a 'stable' speed. The calculation is especially 
    prone to problems on faster machines because there is greater uncertainty.

    Not sure why we hit this so easily on dual-procs - perhaps something about 
    the scheduler wrt sleep and timeGetTime.

 Notes:

    This is an app specific shim.

 History:

    11/15/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MidTownMadness2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(Sleep) 
    APIHOOK_ENUM_ENTRY(timeGetTime) 
APIHOOK_ENUM_END

DWORD g_dwState;
DWORD g_dwTimer;
DWORD g_dwLastTime;

/*++

 After we call GetDlgItemTextA we convert the long path name to the short path name.

--*/

DWORD
APIHOOK(timeGetTime)(VOID)
{
    DWORD dwRet = ORIGINAL_API(timeGetTime)();

    switch (g_dwState) {
        case 0:          
            // Initial state
            g_dwLastTime = dwRet;
            g_dwState++;
            break;
        case 1: 
            // Shouldn't get here, reset state
            g_dwState = 0;
            break;
        case 2:
            // We're in the known bad zone, return our precalculated value
            dwRet = g_dwLastTime + g_dwTimer;
            g_dwState = 0;
            break;
    }

    return dwRet;
}

VOID
APIHOOK(Sleep)(
    DWORD dwMilliseconds
    )
{
    //
    // Check for their specific sleep and update our state if required
    //
    if (dwMilliseconds == 100 && g_dwState == 1) {
        g_dwState = 2;
    }
    ORIGINAL_API(Sleep)(dwMilliseconds);
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {

        // Make the calculation that the app does

        DWORD dwTimer = timeGetTime();
        Sleep(100);
        g_dwTimer = timeGetTime() - dwTimer;

        // Set initial state to 0
        g_dwState = 0;
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, Sleep)
    APIHOOK_ENTRY(WINMM.DLL, timeGetTime)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\money2001.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    Money2001.cpp

 Abstract:

    Retry passwords at 128-bit encryption if 40-bit fails. Most code from Money 
    team.
    
    We have to patch the API directly since it is called from within it's own 
    DLL, i.e. it doesn't go through the import table.

    The function we're patching is cdecl and is referenced by it's ordinal 
    because the name is mangled.

 Notes:

    This is an app specific shim.

 History:

    07/11/2002 linstev   Created
    08/07/2002 linstev   Fixed allocations to go through crt

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Money2001)
#include "ShimHookMacro.h"
#include <wincrypt.h>

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
    APIHOOK_ENUM_ENTRY(FreeLibrary) 
APIHOOK_ENUM_END

#define Assert(a)

void *crtmalloc(size_t size)
{
    HMODULE hMod = GetModuleHandleW(L"msvcrt.dll");

    if (hMod) {

        typedef void * (__cdecl *_pfn_malloc)(size_t size);

        _pfn_malloc pfnmalloc = (_pfn_malloc) GetProcAddress(hMod, "malloc");
        if (pfnmalloc) {
            return pfnmalloc(size);
        }
    }

    return malloc(size);
}

void crtfree(void *memblock)
{
    HMODULE hMod = GetModuleHandleW(L"msvcrt.dll");

    if (hMod) {

        _pfn_free pfnfree = (_pfn_free) GetProcAddress(hMod, "free");
        if (pfnfree) {
            pfnfree(memblock);
            return;
        }
    }

    free(memblock);
}


//
// This section from the Money team
//

#define MAXLEN (100)
#define ENCRYPT_BLOCK_SIZE (8)
#define ENCRYPT_ALGORITHM CALG_RC2
#define KEY_LENGTH          (128)
#define KEY_LENGTH40        (40)

#define LgidMain(lcid)              PRIMARYLANGID(LANGIDFROMLCID(lcid))
#define LgidSub(lcid)               SUBLANGID(LANGIDFROMLCID(lcid))

BOOL FFrenchLCID()
    {
    LCID lcidSys=::GetSystemDefaultLCID();
    if (LgidMain(lcidSys)==LANG_FRENCH && LgidSub(lcidSys)==SUBLANG_FRENCH)
        return TRUE;
    else
        return FALSE;
    }

// the smallest buffer size is 8
#define BLOCKSIZE 8

// process a block, either encrypt it or decrypt it
void ProcessBlock(BOOL fEncrypt, BYTE * buffer)
    {
    BYTE mask[BLOCKSIZE];           // mask array
    BYTE temp[BLOCKSIZE];           // temporary array
    int rgnScramble[BLOCKSIZE];     // scramble array
    int i;

    // initialized scramble array
    for (i=0; i<BLOCKSIZE; i++)
        rgnScramble[i] = i;

    // generate mask and scramble indice
    for (i=0; i<BLOCKSIZE; i++)
        mask[i] = (BYTE)rand();

    for (i=0; i<4*BLOCKSIZE; i++)
        {
        int temp;
        int ind = rand() % BLOCKSIZE;
        temp = rgnScramble[i%BLOCKSIZE];
        rgnScramble[i%BLOCKSIZE] = rgnScramble[ind];
        rgnScramble[ind] = temp;
        }

    if (fEncrypt)
        {
        // xor encryption
        for (i=0; i<BLOCKSIZE; i++)
            mask[i] ^= buffer[i];

        // scramble the data
        for (i=0; i<BLOCKSIZE; i++)
            buffer[rgnScramble[i]] = mask[i];
        }
    else
        {
        // descramble the data
        for (i=0; i<BLOCKSIZE; i++)
            temp[i] = buffer[rgnScramble[i]];

        // xor decryption
        for (i=0; i<BLOCKSIZE; i++)
            buffer[i] = (BYTE) (temp[i] ^ mask[i]);
        }
    }


BYTE * DecryptFrench(const BYTE * pbEncryptedBlob, DWORD cbEncryptedBlob, DWORD * pcbDecryptedBlob, LPCSTR szPassword)
    {
    BYTE buffer[BLOCKSIZE];
    int i;
    unsigned int seed = 0;
    unsigned int seedAdd = 0;
    BYTE * pb;
    BYTE * pbResult = NULL;
    unsigned int cBlocks;
    unsigned int cbResult = 0;
    unsigned int iBlocks;

    // make sure blob is at least 1 block long
    // and it's an integral number of blocks
    Assert(cbEncryptedBlob >= BLOCKSIZE);
    Assert(cbEncryptedBlob % BLOCKSIZE == 0);
    *pcbDecryptedBlob = 0;
    if (cbEncryptedBlob < BLOCKSIZE || cbEncryptedBlob % BLOCKSIZE != 0)
        return NULL;

    // calculate initial seed
    while (*szPassword)
        seed += *szPassword++;
    srand(seed);

    // retrieve the first block
    for (i=0; i<BLOCKSIZE; i++)
        buffer[i] = *pbEncryptedBlob++;
    ProcessBlock(FALSE, buffer);

    // find out the byte count and addon seed
    cbResult = *pcbDecryptedBlob = *((DWORD*)buffer);
    seedAdd = *(((DWORD*)buffer) + 1);

    // find out how many blocks we need
    cBlocks = 1 + (*pcbDecryptedBlob-1)/BLOCKSIZE;

    // make sure we have the right number of blocks
    Assert(cBlocks + 1 == cbEncryptedBlob / BLOCKSIZE);
    if (cBlocks + 1 == cbEncryptedBlob / BLOCKSIZE)
        {
        // allocate output memory
        pbResult = (BYTE*)crtmalloc(*pcbDecryptedBlob);
        if (pbResult)
            {
            // re-seed
            srand(seed + seedAdd);
            pb = pbResult;

            // process all blocks of data
            for (iBlocks=0; iBlocks<cBlocks; iBlocks++)
                {
                for (i=0; i<BLOCKSIZE; i++)
                    buffer[i] = *pbEncryptedBlob++;
                ProcessBlock(FALSE, buffer);
                for (i=0; i<BLOCKSIZE && cbResult>0; i++, cbResult--)
                    *pb++ = buffer[i];
                }
            }
        }

    if (!pbResult)
        *pcbDecryptedBlob = 0;
    return pbResult;
    }


HCRYPTKEY CreateSessionKey(HCRYPTPROV hCryptProv, LPCSTR szPassword, BOOL f40bit)
    {
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hKey = 0;
    DWORD dwEffectiveKeyLen;
    DWORD dwPadding = PKCS5_PADDING;
    DWORD dwMode = CRYPT_MODE_CBC;
    
    if (f40bit)
        dwEffectiveKeyLen=KEY_LENGTH40;
    else
        dwEffectiveKeyLen= KEY_LENGTH;

//--------------------------------------------------------------------
// The file will be encrypted with a session key derived from a
// password.
// The session key will be recreated when the file is decrypted.

//--------------------------------------------------------------------
// Create a hash object. 

    if (!CryptCreateHash(
           hCryptProv, 
           CALG_MD5, 
           0, 
           0, 
           &hHash))
        {
        goto CLEANUP;
        }  

//--------------------------------------------------------------------
// Hash the password. 

    if (!CryptHashData(
           hHash, 
           (BYTE *)szPassword, 
           strlen(szPassword)*sizeof(CHAR), 
           0))
        {
        goto CLEANUP;
        }
//--------------------------------------------------------------------
// Derive a session key from the hash object. 

    if (!CryptDeriveKey(
           hCryptProv, 
           ENCRYPT_ALGORITHM, 
           hHash, 
           0, 
           &hKey))
        {
        goto CLEANUP;
        }

// set effective key length explicitly
    if (!CryptSetKeyParam(
        hKey,
        KP_EFFECTIVE_KEYLEN,
        (BYTE*)&dwEffectiveKeyLen,
        0))
        {
        if(hKey) 
            CryptDestroyKey(hKey);
        hKey = 0;
        goto CLEANUP;
        }

    if (!f40bit)
        {
            // set padding explicitly
            if (!CryptSetKeyParam(
                hKey,
                KP_PADDING,
            (BYTE*)&dwPadding,
                    0))
                    {
                    if(hKey) 
                        CryptDestroyKey(hKey);
                    hKey = 0;
                    goto CLEANUP;
                }

            // set mode explicitly
            if (!CryptSetKeyParam(
                hKey,
                KP_MODE,
            (BYTE*)&dwMode,
                    0))
                    {
                    if(hKey) 
                        CryptDestroyKey(hKey);
                    hKey = 0;
                    goto CLEANUP;
                }
        }

//--------------------------------------------------------------------
// Destroy the hash object. 

CLEANUP:
    if (hHash)
        CryptDestroyHash(hHash);

    return hKey;
    }


BYTE * DecryptWorker(const BYTE * pbEncryptedBlob, DWORD cbEncryptedBlob, DWORD * pcbDecryptedBlob, LPCSTR szPassword, BOOL f40bit, BOOL* pfRet)
    {
    HCRYPTPROV      hCryptProv = NULL;          // CSP handle
    HCRYPTKEY       hKey = 0;
    DWORD           cbDecryptedMessage = 0;
    BYTE*           pbDecryptedMessage = NULL;
    DWORD           dwBlockLen;
    DWORD           dwBufferLen;
    BOOL            fCreateKeyset = FALSE;

    Assert(pfRet);
    *pfRet=TRUE;

//--------------------------------------------------------------------
//  Begin processing.

    Assert(pcbDecryptedBlob);

    *pcbDecryptedBlob = 0;

    if (!pbEncryptedBlob || cbEncryptedBlob == 0)
        return NULL;

    if (FFrenchLCID())
        return DecryptFrench(pbEncryptedBlob, cbEncryptedBlob, pcbDecryptedBlob, szPassword);

//--------------------------------------------------------------------
// Get a handle to a cryptographic provider.

    while (!CryptAcquireContext(
                &hCryptProv,         // Address for handle to be returned.
                NULL,                // Container
                NULL,                // Use the default provider.
                PROV_RSA_FULL,       // Need to both encrypt and sign.
                (fCreateKeyset ? CRYPT_NEWKEYSET:0)))   // flags.
        {
        // Cryptographic context could not be acquired
        DWORD nError = GetLastError();

        if (!fCreateKeyset && (nError == NTE_BAD_KEYSET || nError == NTE_KEYSET_NOT_DEF))
            {
            fCreateKeyset = TRUE;
            continue;
            }
        Assert(FALSE);
        goto CLEANUP;
        }

//--------------------------------------------------------------------
// Create the session key.
    hKey = CreateSessionKey(hCryptProv, szPassword, f40bit);
    if (!hKey)
        {
        goto CLEANUP;
        }

    dwBlockLen = cbEncryptedBlob;
    dwBufferLen = dwBlockLen; 

//--------------------------------------------------------------------
// Allocate memory.
    pbDecryptedMessage = (BYTE *)crtmalloc(dwBufferLen);
    if (!pbDecryptedMessage)
        { 
        // Out of memory
        goto CLEANUP;
        }

    memcpy(pbDecryptedMessage, pbEncryptedBlob, cbEncryptedBlob);
    cbDecryptedMessage = cbEncryptedBlob;

//--------------------------------------------------------------------
// Decrypt data. 
    if (!CryptDecrypt(
          hKey, 
          0, 
          TRUE, 
          0,
          pbDecryptedMessage, 
          &cbDecryptedMessage))
        {
        crtfree(pbDecryptedMessage);
        pbDecryptedMessage = NULL;
        cbDecryptedMessage = 0;
        *pfRet=FALSE;       
        goto CLEANUP;
        }


//--------------------------------------------------------------------
// Clean up memory.
CLEANUP:

    if(hKey) 
        CryptDestroyKey(hKey); 

    if (hCryptProv)
        {
        CryptReleaseContext(hCryptProv,0);
        // The CSP has been released.
        }

    *pcbDecryptedBlob = cbDecryptedMessage;

    return pbDecryptedMessage;
    }

BYTE * __cdecl Decrypt(const BYTE * pbEncryptedBlob, DWORD cbEncryptedBlob, DWORD * pcbDecryptedBlob, LPCSTR szEncryptionPassword)
    {
    BYTE*   pbDecryptedMessage;
    BOOL fRet;
    // try 128 bit first, if we fail, try 40 bit again.
    pbDecryptedMessage = DecryptWorker(pbEncryptedBlob, cbEncryptedBlob, pcbDecryptedBlob, szEncryptionPassword, FALSE, &fRet);
    if (!fRet)
        {
        if (pbDecryptedMessage)
            crtfree(pbDecryptedMessage);
        pbDecryptedMessage = DecryptWorker(pbEncryptedBlob, cbEncryptedBlob, pcbDecryptedBlob, szEncryptionPassword, TRUE, &fRet);
        }
    return pbDecryptedMessage;
    }

//
// End section from Money team
//

/*++

 Patch the Decrypt entry point.

--*/

CRITICAL_SECTION g_csPatch;
DWORD g_dwDecrypt = (DWORD_PTR)&Decrypt;

HINSTANCE
APIHOOK(LoadLibraryA)(
    LPCSTR lpLibFileName
    )
{
    HMODULE hMod = ORIGINAL_API(LoadLibraryA)(lpLibFileName);

    //
    // Wrap the patch in a critical section so we know the library won't be 
    // freed underneath us
    //

    EnterCriticalSection(&g_csPatch);

    HMODULE hMoney = GetModuleHandleW(L"mnyutil.dll");
    if (hMoney) {
        // Patch the dll with a jump to our function

        LPBYTE lpProc = (LPBYTE) GetProcAddress(hMoney, (LPCSTR)274);

        if (lpProc) {
            __try {
                DWORD dwOldProtect;
                if (VirtualProtect((PVOID)lpProc, 5, PAGE_READWRITE, &dwOldProtect)) {
                    *(WORD *)lpProc = 0x25ff; lpProc += 2;
                    *(DWORD *)lpProc = (DWORD_PTR)&g_dwDecrypt;
                }
            } __except(1) {
                LOGN(eDbgLevelError, "[LoadLibraryA] Exception while patching entry point");
            }
        }
    }

    LeaveCriticalSection(&g_csPatch);

    return hMod;
}

BOOL
APIHOOK(FreeLibrary)( 
    HMODULE hModule
    )
{
    EnterCriticalSection(&g_csPatch);
    BOOL bRet = ORIGINAL_API(FreeLibrary)(hModule);
    LeaveCriticalSection(&g_csPatch);

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {

        if (!InitializeCriticalSectionAndSpinCount(&g_csPatch, 0x80000000)) {
            LOGN(eDbgLevelError, "[NotifyFn] Failed to initialize critical section");
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)
    APIHOOK_ENTRY(KERNEL32.DLL, FreeLibrary)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\mindspring4.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MindSpring4.cpp

 Abstract:

    Shim to register the files using regedt32.exe
    The app creates *.dcu files during installation but fails to register them
    thus leading to no entires under the HKLM/Software/MindSpring Enterprise/MID4 subkey.
    This causes the the app to AV when run after successfull installation.

 Notes:

    This is an app specific shim.

 History:

    01/29/2001  a-leelat    Created
    03/13/2001  robkenny    Converted to CString

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MindSpring4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CopyFileA)
APIHOOK_ENUM_END



BOOL APIHOOK(CopyFileA)(
             LPCSTR lpExistingFileName, // name of an existing file
             LPCSTR lpNewFileName,      // name of new file
             BOOL bFailIfExists          // operation if file exists
)
{
    
    BOOL bRet = ORIGINAL_API(CopyFileA)(
                            lpExistingFileName,
                            lpNewFileName,
                            bFailIfExists); 
    if ( bRet != 0 )
    {
        CSTRING_TRY
        {
            CString csExisting(lpExistingFileName);
            CString csExt;
            csExisting.SplitPath(NULL, NULL, NULL, &csExt);
    
            //Check if the file name has .dcu in it
            //if so run regedit on it
            if (csExt.CompareNoCase(L"dcu") == 0)
            {
                CString csCl(L"regedit.exe /s ");
                csCl += lpExistingFileName;
    
                STARTUPINFOW si;
                ZeroMemory( &si, sizeof(si) );
                si.cb = sizeof(si);
    
                PROCESS_INFORMATION pi;
                ZeroMemory( &pi, sizeof(pi) );
    
                BOOL bProc = CreateProcessW(NULL,
                                            (WCHAR *)csCl.Get(), // Stupid non-const api
                                            NULL,
                                            NULL,
                                            FALSE,
                                            NORMAL_PRIORITY_CLASS,
                                            NULL,
                                            NULL,
                                            &si,
                                            &pi);
                if (bProc)
                {
                    WaitForSingleObject(pi.hProcess,INFINITE);
                }
                else
                {
                    //Fail to run the regedit
                    DPFN(eDbgLevelInfo,"Failed to run regedit on %s\n",lpExistingFileName);
                }
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return bRet;
                                    
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\modemwizard.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ModemWizard.cpp

 Abstract:

    This shim hooks the RegQueryValueEx and passes in the app expected values 
    if the values are missing in the registry. 
    
 Notes:

    This is an app specific shim.

 History:

    01/18/2001 a-leelat Created

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(ModemWizard)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
APIHOOK_ENUM_END

LONG 
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,
    LPSTR   lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    LONG lRet;

    CSTRING_TRY
    {
        CString csValueName(lpValueName);

        int iType = 0;
        if (csValueName.Compare(L"Class") == 0)
            iType = 1;
        else if (csValueName.Compare(L"ClassGUID") == 0)
            iType = 2;
        else if (csValueName.Compare(L"Driver") == 0)
            iType = 3;
        
        const CHAR szGUID[] = "{4D36E96D-E325-11CE-BFC1-08002BE10318}";
        DWORD dwRegType = REG_SZ;

        //Save the passed in size of buffer
        DWORD oldcbData = lpcbData ? *lpcbData : 0;
        if (iType) {
    
            //
            // Query the registry to see if there is a service name for the subkey
            // If there is one then check to see if the value returned is "Modem"
            //
    
            lRet = ORIGINAL_API(RegQueryValueExA)(hKey, "Service", lpReserved, &dwRegType, lpData, lpcbData);
            if (lRet == ERROR_SUCCESS)
            {
                CString csData((LPCSTR)lpData);
                if (csData.Compare(L"Modem") == 0)
                {
                    switch (iType) {
                        case 1: 
                            //
                            // We are being queried for a class
                            //
                            return lRet;
                            break;
                        case 2: 
                            //
                            // We are being queried for a ClassGUID
                            // class GUID for modems is 
                            // {4D36E96D-E325-11CE-BFC1-08002BE10318}
                            //
        
                            if (lpData) {
                                _tcscpy((LPSTR)lpData, szGUID);
                                *lpcbData = _tcslenBytes(szGUID);
                                return lRet;
                            }
                            break;
                        case 3:
                            //
                            // we are being queried for a Driver
                            // Check for DrvInst to append to the modemGUID
                            // its like {4D36E96D-E325-11CE-BFC1-08002BE10318}\0000
                            //
        
                            dwRegType = REG_DWORD;
                            if ((lRet = ORIGINAL_API(RegQueryValueExA)(hKey, "DrvInst", lpReserved,&dwRegType,lpData,lpcbData)) == ERROR_SUCCESS) {
        
                                CString csDrv;
                                csDrv.Format(L"%s\\%04d", szGUID, (int)(LOBYTE(LOWORD((DWORD)*lpData))));

                                LPSTR lpszData = (LPSTR)lpData;

                                _tcscpy(lpszData, csDrv.GetAnsi());
                                *lpcbData = _tcslenBytes(lpszData);
                                return lRet;
                            }
                            break;
                        default:
                            break;
                    }
                }
            }
        }

        if (lpcbData) {
            *lpcbData = oldcbData;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    
    lRet = ORIGINAL_API(RegQueryValueExA)(hKey, lpValueName, lpReserved, 
        lpType, lpData, lpcbData);

    return lRet;

}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA);

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\money2002.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    Money2002.cpp

 Abstract:

    Retry passwords at 128-bit encryption if 40-bit fails. Most code from Money 
    team.
    
    We have to patch the API directly since it is called from within it's own 
    DLL, i.e. it doesn't go through the import table.

    The function we're patching is cdecl and is referenced by it's ordinal 
    because the name is mangled.

 Notes:

    This is an app specific shim.

 History:

    07/11/2002 linstev   Created
    08/07/2002 linstev   Fixed allocations to go through crt

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Money2002)
#include "ShimHookMacro.h"
#include <wincrypt.h>

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
    APIHOOK_ENUM_ENTRY(FreeLibrary) 
APIHOOK_ENUM_END

#define Assert(a)

void *crtmalloc(size_t size)
{
    HMODULE hMod = GetModuleHandleW(L"msvcrt.dll");

    if (hMod) {

        typedef void * (__cdecl *_pfn_malloc)(size_t size);

        _pfn_malloc pfnmalloc = (_pfn_malloc) GetProcAddress(hMod, "malloc");
        if (pfnmalloc) {
            return pfnmalloc(size);
        }
    }

    return malloc(size);
}

void crtfree(void *memblock)
{
    HMODULE hMod = GetModuleHandleW(L"msvcrt.dll");

    if (hMod) {

        _pfn_free pfnfree = (_pfn_free) GetProcAddress(hMod, "free");
        if (pfnfree) {
            pfnfree(memblock);
            return;
        }
    }

    free(memblock);
}

//
// This section from the Money team
//

#define MAXLEN (100)
#define ENCRYPT_BLOCK_SIZE  (8)
#define ENCRYPT_ALGORITHM   CALG_RC2
#define KEY_LENGTH          (128)
#define KEY_LENGTH40        (40)

#define LgidMain(lcid)              PRIMARYLANGID(LANGIDFROMLCID(lcid))
#define LgidSub(lcid)               SUBLANGID(LANGIDFROMLCID(lcid))

// this function is only used for conversion
BOOL FFrenchLCID()
    {
    LCID lcidSys=::GetSystemDefaultLCID();
    if (LgidMain(lcidSys)==LANG_FRENCH && LgidSub(lcidSys)==SUBLANG_FRENCH)
        return TRUE;
    else
        return FALSE;
    }

// the smallest buffer size is 8
#define BLOCKSIZE 8

// process a block, either encrypt it or decrypt it
// this function is only used for conversion
void ProcessBlock(BOOL fEncrypt, BYTE * buffer)
    {
    BYTE mask[BLOCKSIZE];           // mask array
    BYTE temp[BLOCKSIZE];           // temporary array
    int rgnScramble[BLOCKSIZE];     // scramble array
    int i;

    // initialized scramble array
    for (i=0; i<BLOCKSIZE; i++)
        rgnScramble[i] = i;

    // generate mask and scramble indice
    for (i=0; i<BLOCKSIZE; i++)
        mask[i] = (BYTE)rand();

    for (i=0; i<4*BLOCKSIZE; i++)
        {
        int temp;
        int ind = rand() % BLOCKSIZE;
        temp = rgnScramble[i%BLOCKSIZE];
        rgnScramble[i%BLOCKSIZE] = rgnScramble[ind];
        rgnScramble[ind] = temp;
        }

    if (fEncrypt)
        {
        // xor encryption
        for (i=0; i<BLOCKSIZE; i++)
            mask[i] ^= buffer[i];

        // scramble the data
        for (i=0; i<BLOCKSIZE; i++)
            buffer[rgnScramble[i]] = mask[i];
        }
    else
        {
        // descramble the data
        for (i=0; i<BLOCKSIZE; i++)
            temp[i] = buffer[rgnScramble[i]];

        // xor decryption
        for (i=0; i<BLOCKSIZE; i++)
            buffer[i] = (BYTE) (temp[i] ^ mask[i]);
        }
    }


// this function is only used for conversion
BYTE * DecryptFrench(const BYTE * pbEncryptedBlob, DWORD cbEncryptedBlob, DWORD * pcbDecryptedBlob, LPCSTR szPassword)
    {
    BYTE buffer[BLOCKSIZE];
    int i;
    unsigned int seed = 0;
    unsigned int seedAdd = 0;
    BYTE * pb;
    BYTE * pbResult = NULL;
    unsigned int cBlocks;
    unsigned int cbResult = 0;
    unsigned int iBlocks;

    // make sure blob is at least 1 block long
    // and it's an integral number of blocks
    Assert(cbEncryptedBlob >= BLOCKSIZE);
    Assert(cbEncryptedBlob % BLOCKSIZE == 0);
    *pcbDecryptedBlob = 0;
    if (cbEncryptedBlob < BLOCKSIZE || cbEncryptedBlob % BLOCKSIZE != 0)
        return NULL;

    // calculate initial seed
    while (*szPassword)
        seed += *szPassword++;
    srand(seed);

    // retrieve the first block
    for (i=0; i<BLOCKSIZE; i++)
        buffer[i] = *pbEncryptedBlob++;
    ProcessBlock(FALSE, buffer);

    // find out the byte count and addon seed
    cbResult = *pcbDecryptedBlob = *((DWORD*)buffer);
    seedAdd = *(((DWORD*)buffer) + 1);

    // find out how many blocks we need
    cBlocks = 1 + (*pcbDecryptedBlob-1)/BLOCKSIZE;

    // make sure we have the right number of blocks
    Assert(cBlocks + 1 == cbEncryptedBlob / BLOCKSIZE);
    if (cBlocks + 1 == cbEncryptedBlob / BLOCKSIZE)
        {
        // allocate output memory
        pbResult = (BYTE*)crtmalloc(*pcbDecryptedBlob);
        if (pbResult)
            {
            // re-seed
            srand(seed + seedAdd);
            pb = pbResult;

            // process all blocks of data
            for (iBlocks=0; iBlocks<cBlocks; iBlocks++)
                {
                for (i=0; i<BLOCKSIZE; i++)
                    buffer[i] = *pbEncryptedBlob++;
                ProcessBlock(FALSE, buffer);
                for (i=0; i<BLOCKSIZE && cbResult>0; i++, cbResult--)
                    *pb++ = buffer[i];
                }
            }
        }

    if (!pbResult)
        *pcbDecryptedBlob = 0;
    return pbResult;
    }



HCRYPTKEY CreateSessionKey(HCRYPTPROV hCryptProv, LPCSTR szPassword, BOOL fConvert, BOOL f40bit)
    {
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hKey = 0;
    DWORD dwEffectiveKeyLen;
    DWORD dwPadding = PKCS5_PADDING;
    DWORD dwMode = CRYPT_MODE_CBC;

    if (f40bit)
        dwEffectiveKeyLen=KEY_LENGTH40;
    else
        dwEffectiveKeyLen= KEY_LENGTH;
//--------------------------------------------------------------------
// The file will be encrypted with a session key derived from a
// password.
// The session key will be recreated when the file is decrypted.

//--------------------------------------------------------------------
// Create a hash object. 

    if (!CryptCreateHash(
           hCryptProv, 
           CALG_MD5, 
           0, 
           0, 
           &hHash))
        {
        goto CLEANUP;
        }  

//--------------------------------------------------------------------
// Hash the password. 

    if (!CryptHashData(
           hHash, 
           (BYTE *)szPassword, 
           strlen(szPassword)*sizeof(CHAR), 
           0))
        {
        goto CLEANUP;
        }
//--------------------------------------------------------------------
// Derive a session key from the hash object. 

    if (!CryptDeriveKey(
           hCryptProv, 
           ENCRYPT_ALGORITHM, 
           hHash, 
           (fConvert ? 0 : (KEY_LENGTH << 16) | CRYPT_EXPORTABLE), 
           &hKey))
        {
        goto CLEANUP;
        }

    // set effective key length explicitly
    if (!CryptSetKeyParam(
        hKey,
        KP_EFFECTIVE_KEYLEN,
        (BYTE*)&dwEffectiveKeyLen,
        0))
        {
        if(hKey) 
            CryptDestroyKey(hKey);
        hKey = 0;
        goto CLEANUP;
        }
    
    if (!fConvert && !f40bit)
        {
            // set padding explicitly
            if (!CryptSetKeyParam(
                hKey,
                KP_PADDING,
            (BYTE*)&dwPadding,
                    0))
                    {
                    if(hKey) 
                        CryptDestroyKey(hKey);
                    hKey = 0;
                    goto CLEANUP;
                }

            // set mode explicitly
            if (!CryptSetKeyParam(
                hKey,
                KP_MODE,
            (BYTE*)&dwMode,
                    0))
                    {
                    if(hKey) 
                        CryptDestroyKey(hKey);
                    hKey = 0;
                    goto CLEANUP;
                }
        }


//--------------------------------------------------------------------
// Destroy the hash object. 

CLEANUP:

    if (hHash)
        CryptDestroyHash(hHash);

    return hKey;
    }


BYTE * DecryptWorker(const BYTE * pbEncryptedBlob, DWORD cbEncryptedBlob, DWORD * pcbDecryptedBlob, LPCSTR szPassword, BOOL fConvert, BOOL f40bit, BOOL* pfRet)
    {
    HCRYPTPROV      hCryptProv = NULL;          // CSP handle
    HCRYPTKEY       hKey = 0;
    DWORD           cbDecryptedMessage = 0;
    BYTE*           pbDecryptedMessage = NULL;
    DWORD           dwBlockLen;
    DWORD           dwBufferLen;

    Assert(pfRet);
    *pfRet=TRUE;
//--------------------------------------------------------------------
//  Begin processing.

    Assert(pcbDecryptedBlob);

    *pcbDecryptedBlob = 0;

    if (!pbEncryptedBlob || cbEncryptedBlob == 0)
        return NULL;

    if (FFrenchLCID() && fConvert)
        return DecryptFrench(pbEncryptedBlob, cbEncryptedBlob, pcbDecryptedBlob, szPassword);

//--------------------------------------------------------------------
// Get a handle to a cryptographic provider.

    if (!CryptAcquireContext(
                &hCryptProv,         // Address for handle to be returned.
                NULL,                // Container
                (fConvert ? NULL : MS_ENHANCED_PROV),    // Use the default provider.
                PROV_RSA_FULL,       // Need to both encrypt and sign.
                CRYPT_VERIFYCONTEXT))   // flags.
        {
        Assert(FALSE);
        goto CLEANUP;
        }

//--------------------------------------------------------------------
// Create the session key.
    hKey = CreateSessionKey(hCryptProv, szPassword, fConvert, f40bit);
    if (!hKey)
        {
        goto CLEANUP;
        }

    dwBlockLen = cbEncryptedBlob;
    dwBufferLen = dwBlockLen; 

//--------------------------------------------------------------------
// Allocate memory.
    pbDecryptedMessage = (BYTE *)crtmalloc(dwBufferLen);
    if (!pbDecryptedMessage)
        { 
        // Out of memory
        goto CLEANUP;
        }

    memcpy(pbDecryptedMessage, pbEncryptedBlob, cbEncryptedBlob);
    cbDecryptedMessage = cbEncryptedBlob;

//--------------------------------------------------------------------
// Decrypt data. 
    if (!CryptDecrypt(
          hKey, 
          0, 
          TRUE, 
          0,
          pbDecryptedMessage, 
          &cbDecryptedMessage))
        {
        crtfree(pbDecryptedMessage);
        pbDecryptedMessage = NULL;
        cbDecryptedMessage = 0;
        *pfRet=FALSE;
        goto CLEANUP;
        }

//--------------------------------------------------------------------
// Clean up memory.
CLEANUP:

    if(hKey) 
        CryptDestroyKey(hKey); 

    if (hCryptProv)
        {
        CryptReleaseContext(hCryptProv,0);
        // The CSP has been released.
        }

    *pcbDecryptedBlob = cbDecryptedMessage;

    return pbDecryptedMessage;
    }

BYTE * __cdecl Decrypt(const BYTE * pbEncryptedBlob, DWORD cbEncryptedBlob, DWORD * pcbDecryptedBlob, LPCSTR szEncryptionPassword, BOOL fConvert)
    {
    BYTE*   pbDecryptedMessage;
    BOOL fRet;
    // try 128 bit first, if we fail, try 40 bit again.
    pbDecryptedMessage = DecryptWorker(pbEncryptedBlob, cbEncryptedBlob, pcbDecryptedBlob, szEncryptionPassword, fConvert, FALSE, &fRet);
    if (!fRet)
        {
        if (pbDecryptedMessage)
            crtfree(pbDecryptedMessage);
        pbDecryptedMessage = DecryptWorker(pbEncryptedBlob, cbEncryptedBlob, pcbDecryptedBlob, szEncryptionPassword, fConvert, TRUE, &fRet);
        }
    return pbDecryptedMessage;
    }

//
// End section from Money team
//

/*++

 Patch the Decrypt entry point.

--*/

CRITICAL_SECTION g_csPatch;
DWORD g_dwDecrypt = (DWORD_PTR)&Decrypt;

HINSTANCE
APIHOOK(LoadLibraryA)(
    LPCSTR lpLibFileName
    )
{
    HMODULE hMod = ORIGINAL_API(LoadLibraryA)(lpLibFileName);

    //
    // Wrap the patch in a critical section so we know the library won't be 
    // freed underneath us
    //

    EnterCriticalSection(&g_csPatch);

    HMODULE hMoney = GetModuleHandleW(L"mnyutil.dll");
    if (hMoney) {
        // Patch the dll with a jump to our function

        LPBYTE lpProc = (LPBYTE) GetProcAddress(hMoney, (LPCSTR)290);

        if (lpProc) {
            __try {
                DWORD dwOldProtect;
                if (VirtualProtect((PVOID)lpProc, 5, PAGE_READWRITE, &dwOldProtect)) {
                    *(WORD *)lpProc = 0x25ff; lpProc += 2;
                    *(DWORD *)lpProc = (DWORD_PTR)&g_dwDecrypt;
                }
            } __except(1) {
                LOGN(eDbgLevelError, "[LoadLibraryA] Exception while patching entry point");
            }
        }
    }

    LeaveCriticalSection(&g_csPatch);

    return hMod;
}

BOOL
APIHOOK(FreeLibrary)( 
    HMODULE hModule
    )
{
    EnterCriticalSection(&g_csPatch);
    BOOL bRet = ORIGINAL_API(FreeLibrary)(hModule);
    LeaveCriticalSection(&g_csPatch);

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        if (!InitializeCriticalSectionAndSpinCount(&g_csPatch, 0x80000000)) {
            LOGN(eDbgLevelError, "[NotifyFn] Failed to initialize critical section");
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)
    APIHOOK_ENTRY(KERNEL32.DLL, FreeLibrary)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\msdevdisabledbuttons.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   FakeThemeMetrics.cpp

 Abstract:

  This Shim will allow the Skemers group to shim applications that do not behave 
  well with "Themed" system metrics

 History:

  11/30/2000 a-brienw Converted to shim frame work version 2.

--*/

#include "precomp.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    sizeof(x)/sizeof((x)[0])
#endif

IMPLEMENT_SHIM_BEGIN(MSDevDisabledButtons)
#include "ShimHookMacro.h"

// Add APIs that you wish to hook to this enumeration. The first one
// must have "= USERAPIHOOKSTART", and the last one must be
// APIHOOK_Count.
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetSysColor) 
APIHOOK_ENUM_END

DWORD APIHOOK(GetSysColor)(int nIndex)
{
    if (nIndex == COLOR_MENU)
        return ORIGINAL_API(GetSysColor)(COLOR_BTNFACE);

    if (nIndex == COLOR_MENUBAR)
        return ORIGINAL_API(GetSysColor)(COLOR_BTNFACE);

    return ORIGINAL_API(GetSysColor)(nIndex);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, GetSysColor)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\myphotocenter2.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    MyPhotoCenter2.cpp

 Abstract:

    Ignore Exception caused by the application "My Photo Center 2".

 Notes:

    This is an app specific shim.

 History:

    04/25/2002  v-bvella     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MyPhotoCenter2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ReleaseStgMedium) 
APIHOOK_ENUM_END

/*++

 This function intercepts ReleaseStgMedium call. It will ignore exception 
 cased by ReleaseStgMedium.

--*/

void
APIHOOK(ReleaseStgMedium)(
        STGMEDIUM *pmedium //Pointer to storage medium to be freed
        )
{
    __try {
        ORIGINAL_API(ReleaseStgMedium)(pmedium);
    }
    __except (1) {
        return;
    }
    return;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(OLE32.DLL, ReleaseStgMedium)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\msworks6.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MSWorks6.cpp

 Abstract:

    Due to a modification in the registry in Windows XP, this app gets the path 
    for IE as "%programfiles%\ Internet Explorer\iexplore.exe" and since the 
    env variable option flag is not set for ShellExecuteEx, it cannot expand it.
    Hooked ShellExecuteW also as the app calls this at a few places.

 Notes:

    This is an app specific shim.

 History:
 
    01/25/2001 prashkud  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MSWorks6)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShellExecuteExW)
    APIHOOK_ENUM_ENTRY(ShellExecuteW)
APIHOOK_ENUM_END

/*++

 Hooks ShellExecuteExW and sets the flag for expanding the environment variables

--*/

BOOL
APIHOOK(ShellExecuteExW)(
    LPSHELLEXECUTEINFO lpExecInfo
    )
{
    lpExecInfo->fMask |= SEE_MASK_DOENVSUBST;    
    return ORIGINAL_API(ShellExecuteExW)(lpExecInfo);              
}

/*++

 Hooks ShellExecuteW and expands the passed file path.

--*/

HINSTANCE
APIHOOK(ShellExecuteW)(
    HWND hWnd,
    LPCWSTR lpVerb,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    INT nShowCmd
    )
{
    CSTRING_TRY
    {
        CString csPassedFile(lpFile);
        csPassedFile.ExpandEnvironmentStringsW();

        return ORIGINAL_API(ShellExecuteW)(hWnd, lpVerb, csPassedFile.Get(),
                    lpParameters, lpDirectory, nShowCmd);
    }
    CSTRING_CATCH
    {
        return ORIGINAL_API(ShellExecuteW)(hWnd, lpVerb, lpFile,
                    lpParameters, lpDirectory, nShowCmd);
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteExW)    
    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteW) 
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\netmanageviewnow.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    NetManageViewNow.cpp

 Abstract:


    The app doesnt follow stdcall conventions for the ServiceMain function
    it registers with SCM. This is resulting in an AV as the ServiceMain
    is not cleaning up the stack on return,  after being called by SCM. 
    We clean up the stack for the app registered ServiceMain by hooking 
    StartServiceCtrlDispatcher and registering our own ServiceMain routine, 
    which makes the actual call to the app registered servicemain and then
    pop 8 bytes of the stack before returning.

    
 Notes:

    This is an app specific shim.

 History:

    03/08/2001 a-leelat Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NetManageViewNow)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(StartServiceCtrlDispatcherA)
    APIHOOK_ENUM_ENTRY(StartServiceCtrlDispatcherW)
APIHOOK_ENUM_END



//last entry of the service table are supposed to be NULL entries
SERVICE_TABLE_ENTRYA        g_SvcTableA[] = { {NULL,NULL},{NULL,NULL} };
SERVICE_TABLE_ENTRYW        g_SvcTableW[] = { {NULL,NULL},{NULL,NULL} };

LPSERVICE_MAIN_FUNCTIONA    g_pfnActualMainA = NULL;
LPSERVICE_MAIN_FUNCTIONW    g_pfnActualMainW = NULL;




VOID WINAPI ServiceMainA(
  DWORD dwArgc,     // number of arguments
  LPSTR *lpszArgv  // array of arguments
)
{

    //call the actual routine
    (g_pfnActualMainA)(dwArgc,lpszArgv);

    //pop 8 bytes of stack to compensate for
    //the app not following stdcall convention
    __asm
    {
        add esp,8
    }
}


VOID WINAPI ServiceMainW(
  DWORD dwArgc,     // number of arguments
  LPWSTR *lpszArgv  // array of arguments
)
{

    //call the actual routine
    (g_pfnActualMainW)(dwArgc,lpszArgv);

    //pop 8 bytes of stack to compensate for
    //the app not following stdcall convention
    __asm
    {
        add esp, 8
    }

}




BOOL APIHOOK(StartServiceCtrlDispatcherA)(
  CONST LPSERVICE_TABLE_ENTRYA lpServiceTable   // service table
)
{

    BOOL bRet = false;
    
    LPSERVICE_TABLE_ENTRYA lpSvcTblToPass = lpServiceTable;

    //Allocate buffer to copy the actual service name
    g_SvcTableA[0].lpServiceName = 
        (LPSTR) malloc(_tcslenBytes(lpServiceTable->lpServiceName)+1);

    if (!g_SvcTableA[0].lpServiceName)
    {
        DPFN( eDbgLevelError, 
            "[StartServiceCtrlDispatcherA] Buffer allocation failure");
    }
    else
    {
        //Setup our service table to register with SCM
    
        //Copy the service name as defined by the app
        _tcscpy(g_SvcTableA[0].lpServiceName,lpServiceTable->lpServiceName);
        
        //Now put our service routine
        g_SvcTableA[0].lpServiceProc = ServiceMainA;

        //Save the old servicemain func ptr
        g_pfnActualMainA = lpServiceTable->lpServiceProc;

        //Set the service table to our table
        lpSvcTblToPass = &g_SvcTableA[0];

        DPFN( eDbgLevelInfo, 
            "[StartServiceCtrlDispatcherA] Hooked ServiceMainA");
    }


   //Call the Original API
   bRet =  StartServiceCtrlDispatcherA(lpSvcTblToPass); 
   
   return bRet;
 
}




BOOL APIHOOK(StartServiceCtrlDispatcherW)(
  CONST LPSERVICE_TABLE_ENTRYW lpServiceTable   // service table
)
{
    BOOL bRet = false;
    
    LPSERVICE_TABLE_ENTRYW lpSvcTblToPass = lpServiceTable;

    //Allocate buffer to copy the actual service name
    g_SvcTableW[0].lpServiceName = 
        (LPWSTR) malloc(wcslen(lpServiceTable->lpServiceName)+1);

    if (!g_SvcTableW[0].lpServiceName)
    {

        DPFN( eDbgLevelError, 
            "[StartServiceCtrlDispatcherW] Buffer allocation failure");
    }
    else
    {
        //Setup our service table to register with SCM

        //Copy the service name as defined by the app
        wcscpy(g_SvcTableW[0].lpServiceName,lpServiceTable->lpServiceName);
        
        //Now put our service routine
        g_SvcTableW[0].lpServiceProc = ServiceMainW;

        //Save the old servicemain func ptr
        g_pfnActualMainW = lpServiceTable->lpServiceProc;

        //Set the service table to our table
        lpSvcTblToPass = &g_SvcTableW[0];

        DPFN( eDbgLevelInfo, 
            "[StartServiceCtrlDispatcherW] Hooked ServiceMainW");
    }


   //Call the Original API
   bRet =  StartServiceCtrlDispatcherW(lpSvcTblToPass);
   
   return bRet;
}



/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, StartServiceCtrlDispatcherA)
    APIHOOK_ENTRY(ADVAPI32.DLL, StartServiceCtrlDispatcherW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\msaccess2000ime.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    MSAccess2000IME.cpp

 Abstract:
    
    MSAccess 2000 disable IME for the non text column but failing enable IME
    when user move the caret into text column with non IME keyboard ex.German.
    When user switch keyboard from German to IME, IME is disabled and user
    cannot input Far East language text.

    This shim disregard the attempt to disable IME.
    The problem is fixed in MSAccess 2002.

 Notes:

    This is an app specific shim.

 History:

    12/14/2001 hioh     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MSAccess2000IME)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ImmAssociateContext)
APIHOOK_ENUM_END

/*++

 Disregard disabling IME.

--*/

HIMC
APIHOOK(ImmAssociateContext)(HWND hWnd, HIMC hIMC)
{
    // enable by original
    if (hIMC != NULL)
    {
        return (ORIGINAL_API(ImmAssociateContext)(hWnd, hIMC));
    }

    // disregard disable
    // msaccess.exe saves the input context return value as static, fool this
    return (ImmGetContext(hWnd));
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(IMM32.DLL, ImmAssociateContext)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\nbalive.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    NBALive.cpp

 Abstract:

    On Win9x, SetWindowText used to pass the pointer directly to the window 
    proc in a WM_SETTEXT message. However, on NT, the string goes through the 
    standard message workers and get's converted to unicode etc. When it does 
    get to the window proc, it's not the original pointer.

    NBA Live 99 depends on the pointer being the same, since it sends more than 
    just the string. 

    The fix is to subclass the WindowProc on SetWindowText and change the 
    pointer (in lParam) to the one that was originally passed.

 Notes:
    
    This is an app specific shim.

 History:

    06/19/2000 linstev  Created

--*/

#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(NBALive)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowTextA) 
APIHOOK_ENUM_END


//
// Critical section for global variable access
//

CRITICAL_SECTION g_csGlobals;

//
// Text for window and previous windowproc
//

CHAR *g_szText; 
WNDPROC g_lpWndProc;

/*++

 The subclassed windowproc that we use to change the text pointer to the 
 original one passed to SetWindowTextA.

--*/

LRESULT
CALLBACK
WindowProcA(
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    if (uMsg == WM_SETTEXT) {
        if (lParam)  {
            if (strcmp(g_szText, (CHAR *) lParam) == 0)  {
                lParam = (LPARAM) g_szText;
            }
        }
    }

    return CallWindowProcA(g_lpWndProc, hWnd, uMsg, wParam, lParam);
}

/*++

 Subclass the windowproc for this call and fix the pointer that comes out in 
 the WM_SETTEXT message that is generated by SetWindowTextA.

--*/

BOOL 
APIHOOK(SetWindowTextA)(
    HWND hWnd,         
    LPCSTR lpString   
    )
{
    BOOL bRet = FALSE;

    //
    // Set the text for this window
    //

    EnterCriticalSection(&g_csGlobals);

    //
    // Subclass the window
    //
    
    g_lpWndProc = (WNDPROC) GetWindowLongA(hWnd, GWL_WNDPROC);

    if (g_lpWndProc)  {
        SetWindowLongA(hWnd, GWL_WNDPROC, (LONG_PTR) WindowProcA);
    }

    //
    // Call the original function which generates a WM_SETTEXT message
    //
    
    g_szText = (CHAR *) lpString;
    bRet = ORIGINAL_API(SetWindowTextA)(hWnd, lpString);

    //
    // Restore the wndproc
    //

    SetWindowLongA(hWnd, GWL_WNDPROC, (LONG_PTR) g_lpWndProc);

    LeaveCriticalSection(&g_csGlobals);

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        InitializeCriticalSection(&g_csGlobals);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(USER32.DLL, SetWindowTextA )

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\netobjectsfusion5.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    NetObjectsFusion5.cpp

 Abstract:

    This shim hooks the CreateFile/WriteFile if the file is corpwiz_loader.html
    to write in the  required javascript so as to make the appwork if the IE browser
    version is > 5.

 Notes:

    This is an app specific shim.

 History:
 
    01/24/2001  a-leelat    Created
    03/13/2001  robkenny    Converted to CString

--*/


#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(NetObjectsFusion5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CloseHandle)
    APIHOOK_ENUM_ENTRY(WriteFile)
    APIHOOK_ENUM_ENTRY(CreateFileA)
APIHOOK_ENUM_END



volatile HANDLE g_Handle = NULL;


HANDLE
APIHOOK(CreateFileA)(
    LPSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    
    CHAR szNameToCheck[] = "corpwiz_loader.html";

    HANDLE l_Handle =  (HANDLE)ORIGINAL_API(CreateFileA)(
                                            lpFileName,
                                            dwDesiredAccess,
                                            dwShareMode,
                                            lpSecurityAttributes,
                                            dwCreationDisposition,
                                            dwFlagsAndAttributes,
                                            hTemplateFile);
    

    if ( strstr(lpFileName,szNameToCheck) )
    {
        
        if (l_Handle != INVALID_HANDLE_VALUE ) 
            g_Handle = l_Handle;
   
    }
    else
        g_Handle = NULL;

    return l_Handle;

}


BOOL
APIHOOK(WriteFile)(
    HANDLE       hFile,              
    LPCVOID      lpBuffer,        
    DWORD        nNumberOfBytesToWrite,
    LPDWORD      lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped    
    )
{
    BOOL bRet = FALSE;

    
    if ( g_Handle && (hFile == g_Handle) && lpBuffer)
    {
        
        
        CHAR szStringToWrite[] = "\r\n        var IsIE6 = navigator.userAgent.indexOf(\"IE 6\") > -1;\r\n\r\n    if ( IsIE6 == true ) { IsIE5 = true; }\r\n";
        CHAR szStringToCheck[] = "var IsIE5 = navigator.userAgent.indexOf(\"IE 5\") > -1;";
        CHAR *szPtr = NULL;

        if ((szPtr = strstr((LPCSTR)lpBuffer,szStringToCheck)))
        {

                int iSize = sizeof(CHAR) * (szPtr - (LPSTR)lpBuffer + _tcslenBytes(szStringToCheck));
                
                DWORD dwTotalBytesWritten;
                
                bRet = ORIGINAL_API(WriteFile)(
                        hFile,
                        lpBuffer,
                        (DWORD)iSize,
                        lpNumberOfBytesWritten,
                        lpOverlapped);
               

                dwTotalBytesWritten = *lpNumberOfBytesWritten;
                
                bRet = ORIGINAL_API(WriteFile)(
                        hFile,
                        (LPVOID)szStringToWrite,
                        (DWORD)strlen(szStringToWrite),
                        lpNumberOfBytesWritten,
                        lpOverlapped);
                

                CHAR* szrBuf = (LPSTR)lpBuffer + iSize;

                bRet = ORIGINAL_API(WriteFile)(
                        hFile,
                        (LPVOID)szrBuf,
                        (nNumberOfBytesToWrite - (DWORD)iSize),
                        lpNumberOfBytesWritten,
                        lpOverlapped);
                

                *lpNumberOfBytesWritten += dwTotalBytesWritten;

                return bRet;
            
        }//end of if
    }
    
   return ORIGINAL_API(WriteFile)(
                       hFile,
                       lpBuffer,
                       nNumberOfBytesToWrite,
                       lpNumberOfBytesWritten,
                       lpOverlapped);
        
}


BOOL
APIHOOK(CloseHandle)(
        HANDLE hObject
        )
{

    if ( g_Handle && (hObject == g_Handle) )
    {
        g_Handle = NULL;
    }
    
    return ORIGINAL_API(CloseHandle)(hObject);

}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, WriteFile)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\newshendiaoxialv.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:
